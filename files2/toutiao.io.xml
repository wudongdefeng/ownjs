<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>25f3f75ea94dea8931f23672cca7d455</guid>
<title>聊聊Java中代码优化的30个小技巧</title>
<link>https://toutiao.io/k/jv8g1r6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前写过两篇关于优化相关的问题：《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490473&amp;amp;idx=1&amp;amp;sn=ba07d64aa8c89054bd263efd660d3a3f&amp;amp;chksm=c0ebc341f79c4a579a6f41465df0459a696ab8ef0499a5f6fd76269af1064fde0286afdb027d&amp;amp;token=751314179&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊sql优化的15个小技巧&lt;/a&gt;》和《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490731&amp;amp;idx=1&amp;amp;sn=29ed0295c7990157a3a56ba33cf7f8be&amp;amp;chksm=c0ebc443f79c4d55a2bac81744992c96f97737e5d0717ec99231f4d08f57a7f0220eafdac9c9&amp;amp;token=660773166&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊接口性能优化的11个小技巧&lt;/a&gt;》，发表之后，在全网受到广大网友的好评。阅读量和点赞率都很高，说明了这类文章的价值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天接着优化这个话题，我们一起聊聊Java中代码优化的30个小技巧，希望会对你有所帮助。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8313253012048193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSsU9ic3SneiahUCRSjva6M3gbGFxut8tpXCGkemeH8ibE42v0xwM88BcWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1660&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.用String.format拼接字符串&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有拼接过字符串，特别是那种有多个参数，字符串比较长的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如现在有个需求：要用get请求调用第三方接口，url后需要拼接多个参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前我们的请求地址是这样拼接的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String url = &lt;span&gt;&quot;http://susan.sc.cn?userName=&quot;&lt;/span&gt;+userName+&lt;span&gt;&quot;&amp;amp;age=&quot;&lt;/span&gt;+age+&lt;span&gt;&quot;&amp;amp;address=&quot;&lt;/span&gt;+address+&lt;span&gt;&quot;&amp;amp;sex=&quot;&lt;/span&gt;+sex+&lt;span&gt;&quot;&amp;amp;roledId=&quot;&lt;/span&gt;+roleId;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串使用&lt;code&gt;+&lt;/code&gt;号拼接，非常容易出错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面优化了一下，改为使用&lt;code&gt;StringBuilder&lt;/code&gt;拼接字符串：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;StringBuilder urlBuilder = &lt;span&gt;new&lt;/span&gt; StringBuilder(&lt;span&gt;&quot;http://susan.sc.cn?&quot;&lt;/span&gt;);&lt;br/&gt;urlBuilder.append(&lt;span&gt;&quot;userName=&quot;&lt;/span&gt;)&lt;br/&gt;.append(userName)&lt;br/&gt;.append(&lt;span&gt;&quot;&amp;amp;age=&quot;&lt;/span&gt;)&lt;br/&gt;.append(age)&lt;br/&gt;.append(&lt;span&gt;&quot;&amp;amp;address=&quot;&lt;/span&gt;)&lt;br/&gt;.append(address)&lt;br/&gt;.append(&lt;span&gt;&quot;&amp;amp;sex=&quot;&lt;/span&gt;)&lt;br/&gt;.append(sex)&lt;br/&gt;.append(&lt;span&gt;&quot;&amp;amp;roledId=&quot;&lt;/span&gt;)&lt;br/&gt;.append(roledId);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码优化之后，稍微直观点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但还是看起来比较别扭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以使用&lt;code&gt;String.format&lt;/code&gt;方法优化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String requestUrl = &lt;span&gt;&quot;http://susan.sc.cn?userName=%s&amp;amp;age=%s&amp;amp;address=%s&amp;amp;sex=%s&amp;amp;roledId=%s&quot;&lt;/span&gt;;&lt;br/&gt;String url = String.format(requestUrl,userName,age,address,sex,roledId);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的可读性，一下子提升了很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平常可以使用&lt;code&gt;String.format&lt;/code&gt;方法拼接url请求参数，日志打印等字符串。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;但不建议在for循环中用它拼接字符串，因为它的执行效率，比使用+号拼接字符串，或者使用StringBuilder拼接字符串都要慢一些。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.创建可缓冲的IO流&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IO流&lt;/code&gt;想必大家都使用得比较多，我们经常需要把数据&lt;code&gt;写入&lt;/code&gt;某个文件，或者从某个文件中&lt;code&gt;读取&lt;/code&gt;数据到&lt;code&gt;内存&lt;/code&gt;中，甚至还有可能把文件a，从目录b，&lt;code&gt;复制&lt;/code&gt;到目录c下等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK给我们提供了非常丰富的API，可以去操作IO流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IoTest1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        FileInputStream fis = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        FileOutputStream fos = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            File srcFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/1.txt&quot;&lt;/span&gt;);&lt;br/&gt;            File destFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/2.txt&quot;&lt;/span&gt;);&lt;br/&gt;            fis = &lt;span&gt;new&lt;/span&gt; FileInputStream(srcFile);&lt;br/&gt;            fos = &lt;span&gt;new&lt;/span&gt; FileOutputStream(destFile);&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; len;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; ((len = fis.read()) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                fos.write(len);&lt;br/&gt;            }&lt;br/&gt;            fos.flush();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (fos != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    fos.close();&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (fis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    fis.close();&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子主要的功能，是将1.txt文件中的内容复制到2.txt文件中。这例子使用普通的IO流从功能的角度来说，也能满足需求，但性能却不太好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这个例子中，从1.txt文件中读一个字节的数据，就会马上写入2.txt文件中，需要非常频繁的读写文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IoTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        BufferedInputStream bis = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        BufferedOutputStream bos = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        FileInputStream fis = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        FileOutputStream fos = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            File srcFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/1.txt&quot;&lt;/span&gt;);&lt;br/&gt;            File destFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/2.txt&quot;&lt;/span&gt;);&lt;br/&gt;            fis = &lt;span&gt;new&lt;/span&gt; FileInputStream(srcFile);&lt;br/&gt;            fos = &lt;span&gt;new&lt;/span&gt; FileOutputStream(destFile);&lt;br/&gt;            bis = &lt;span&gt;new&lt;/span&gt; BufferedInputStream(fis);&lt;br/&gt;            bos = &lt;span&gt;new&lt;/span&gt; BufferedOutputStream(fos);&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; len;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; ((len = bis.read(buffer)) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                bos.write(buffer, &lt;span&gt;0&lt;/span&gt;, len);&lt;br/&gt;            }&lt;br/&gt;            bos.flush();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (bos != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    bos.close();&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (fos != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    fos.close();&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (bis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    bis.close();&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (fis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    fis.close();&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子使用&lt;code&gt;BufferedInputStream&lt;/code&gt;和&lt;code&gt;BufferedOutputStream&lt;/code&gt;创建了&lt;code&gt;可缓冲&lt;/code&gt;的输入输出流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最关键的地方是定义了一个buffer字节数组，把从1.txt文件中读取的数据临时保存起来，后面再把该buffer字节数组的数据，一次性批量写入到2.txt中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的好处是，减少了读写文件的次数，而我们都知道读写文件是非常耗时的操作。也就是说使用可缓存的输入输出流，可以提升IO的性能，特别是遇到文件非常大时，效率会得到显著提升。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.减少循环次数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们日常开发中，循环遍历集合是必不可少的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果循环层级比较深，循环中套循环，可能会影响代码的执行效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(User user: userList) {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt;(Role role: roleList) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(user.getRoleId().equals(role.getId())) {&lt;br/&gt;         user.setRoleName(role.getName());&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中有两层循环，如果userList和roleList数据比较多的话，需要循环遍历很多次，才能获取我们所需要的数据，非常消耗cpu资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Map&amp;lt;Long, List&amp;lt;Role&amp;gt;&amp;gt; roleMap = roleList.stream().collect(Collectors.groupingBy(Role::getId));&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (User user : userList) {&lt;br/&gt;    List&amp;lt;Role&amp;gt; roles = roleMap.get(user.getRoleId());&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(CollectionUtils.isNotEmpty(roles)) {&lt;br/&gt;        user.setRoleName(roles.get(&lt;span&gt;0&lt;/span&gt;).getName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;减少循环次数，最简单的办法是，把第二层循环的集合变成&lt;code&gt;map&lt;/code&gt;，这样可以直接通过&lt;code&gt;key&lt;/code&gt;，获取想要的&lt;code&gt;value&lt;/code&gt;数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说map的key存在&lt;code&gt;hash冲突&lt;/code&gt;的情况，但遍历存放数据的&lt;code&gt;链表&lt;/code&gt;或者&lt;code&gt;红黑树&lt;/code&gt;的&lt;code&gt;时间复杂度&lt;/code&gt;，比遍历整个list集合要小很多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.用完资源记得及时关闭&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们日常开发中，可能经常访问&lt;code&gt;资源&lt;/code&gt;，比如：获取数据库连接，读取文件等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以获取数据库连接为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//1. 加载驱动类&lt;/span&gt;&lt;br/&gt;Class.forName(&lt;span&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//2. 创建连接&lt;/span&gt;&lt;br/&gt;Connection connection = DriverManager.getConnection(&lt;span&gt;&quot;jdbc:mysql//localhost:3306/db?allowMultiQueries=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;&lt;/span&gt;,&lt;span&gt;&quot;root&quot;&lt;/span&gt;,&lt;span&gt;&quot;123456&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//3.编写sql&lt;/span&gt;&lt;br/&gt;String sql =&lt;span&gt;&quot;select * from user&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//4.创建PreparedStatement&lt;/span&gt;&lt;br/&gt;PreparedStatement pstmt = conn.prepareStatement(sql);&lt;br/&gt;&lt;span&gt;//5.获取查询结果&lt;/span&gt;&lt;br/&gt;ResultSet rs = pstmt.execteQuery();&lt;br/&gt;&lt;span&gt;while&lt;/span&gt;(rs.next()){&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; id = rs.getInt(&lt;span&gt;&quot;id&quot;&lt;/span&gt;);&lt;br/&gt;   String name = rs.getString(&lt;span&gt;&quot;name&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这段代码可以正常运行，但却犯了一个很大的错误，即：ResultSet、PreparedStatement和Connection对象的资源，使用完之后，没有关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，数据库连接是非常宝贵的资源。我们不可能一直创建连接，并且用完之后，也不回收，白白浪费数据库资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//1. 加载驱动类&lt;/span&gt;&lt;br/&gt;Class.forName(&lt;span&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;Connection connection = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;PreparedStatement pstmt = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;ResultSet rs = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;//2. 创建连接&lt;/span&gt;&lt;br/&gt;    connection = DriverManager.getConnection(&lt;span&gt;&quot;jdbc:mysql//localhost:3306/db?allowMultiQueries=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;&lt;/span&gt;,&lt;span&gt;&quot;root&quot;&lt;/span&gt;,&lt;span&gt;&quot;123456&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;//3.编写sql&lt;/span&gt;&lt;br/&gt;    String sql =&lt;span&gt;&quot;select * from user&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//4.创建PreparedStatement&lt;/span&gt;&lt;br/&gt;    pstmt = conn.prepareStatement(sql);&lt;br/&gt;    &lt;span&gt;//5.获取查询结果&lt;/span&gt;&lt;br/&gt;    rs = pstmt.execteQuery();&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(rs.next()){&lt;br/&gt;       &lt;span&gt;int&lt;/span&gt; id = rs.getInt(&lt;span&gt;&quot;id&quot;&lt;/span&gt;);&lt;br/&gt;       String name = rs.getString(&lt;span&gt;&quot;name&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt;(Exception e) {&lt;br/&gt;  log.error(e.getMessage(),e);&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(rs != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      rs.close();&lt;br/&gt;   }&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(pstmt != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      pstmt.close();&lt;br/&gt;   }&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(connection != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      connection.close();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中，无论是ResultSet，或者PreparedStatement，还是Connection对象，使用完之后，都会调用&lt;code&gt;close&lt;/code&gt;方法关闭资源。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在这里温馨提醒一句：ResultSet，或者PreparedStatement，还是Connection对象，这三者关闭资源的顺序不能反了，不然可能会出现异常。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.使用池技术&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，从数据库查数据，首先要连接数据库，获取&lt;code&gt;Connection&lt;/code&gt;资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想让程序多线程执行，需要使用&lt;code&gt;Thread&lt;/code&gt;类创建线程，线程也是一种资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常一次数据库操作的过程是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进行数据库操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关闭连接&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而创建连接和关闭连接，是非常耗时的操作，创建连接需要同时会创建一些资源，关闭连接时，需要回收那些资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户的每一次数据库请求，程序都都需要去创建连接和关闭连接的话，可能会浪费大量的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，可能会导致数据库连接过多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道数据库的&lt;code&gt;最大连接数&lt;/code&gt;是有限的，以mysql为例，最大连接数是：&lt;code&gt;100&lt;/code&gt;，不过可以通过参数调整这个数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户请求的连接数超过最大连接数，就会报：&lt;code&gt;too many connections&lt;/code&gt;异常。如果有新的请求过来，会发现数据库变得不可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以通过命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;show&lt;/span&gt; &lt;span&gt;variables&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; max_connections&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看最大连接数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;set GLOBAL max_connections=&lt;span&gt;1000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手动修改最大连接数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种做法只能暂时缓解问题，不是一个好的方案，无法从根本上解决问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最大的问题是：数据库连接数可以无限增长，不受控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我们可以使用&lt;code&gt;数据库连接池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前Java开源的数据库连接池有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;DBCP：是一个依赖Jakarta commons-pool对象池机制的数据库连接池。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C3P0：是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布，包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Druid：阿里的Druid，不仅是一个数据库连接池，还包含一个ProxyDriver、一系列内置的JDBC组件库、一个SQL Parser。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Proxool：是一个Java SQL Driver驱动程序，它提供了对选择的其它类型的驱动程序的连接池封装，可以非常简单的移植到已有代码中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前用的最多的数据库连接池是:&lt;code&gt;Druid&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.反射时加缓存&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道通过&lt;code&gt;反射&lt;/code&gt;创建对象实例，比使用&lt;code&gt;new&lt;/code&gt;关键字要慢很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此，不太建议在用户请求过来时，每次都通过反射&lt;code&gt;实时&lt;/code&gt;创建实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，为了代码的灵活性，又不得不用反射创建实例，这时该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：加&lt;code&gt;缓存&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实spring中就使用了大量的反射，我们以支付方法为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据前端传入不同的支付code，动态找到对应的支付方法，发起支付。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先定义一个注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)  &lt;br/&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; PayCode {  &lt;br/&gt;     &lt;span&gt;String &lt;span&gt;value&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;    &lt;br/&gt;     &lt;span&gt;String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在所有的支付类上都加上该注解&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PayCode&lt;/span&gt;(value = &lt;span&gt;&quot;alia&quot;&lt;/span&gt;, name = &lt;span&gt;&quot;支付宝支付&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@PayCode&lt;/span&gt;(value = &lt;span&gt;&quot;weixin&quot;&lt;/span&gt;, name = &lt;span&gt;&quot;微信支付&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;} &lt;br/&gt; &lt;br/&gt;&lt;span&gt;@PayCode&lt;/span&gt;(value = &lt;span&gt;&quot;jingdong&quot;&lt;/span&gt;, name = &lt;span&gt;&quot;京东支付&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后增加最关键的类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService2&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationListener&lt;/span&gt;&amp;lt;&lt;span&gt;ContextRefreshedEvent&lt;/span&gt;&amp;gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, IPay&amp;gt; payMap = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onApplicationEvent&lt;/span&gt;&lt;span&gt;(ContextRefreshedEvent contextRefreshedEvent)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();  &lt;br/&gt;         Map&amp;lt;String, Object&amp;gt; beansWithAnnotation = applicationContext.getBeansWithAnnotation(PayCode&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;  &lt;br/&gt;        &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (beansWithAnnotation != &lt;span&gt;null&lt;/span&gt;) {  &lt;br/&gt;             payMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();  &lt;br/&gt;             beansWithAnnotation.forEach((key, value) -&amp;gt;{  &lt;br/&gt;                 String bizType = value.getClass().getAnnotation(PayCode&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;value&lt;/span&gt;()&lt;/span&gt;;  &lt;br/&gt;                 payMap.put(bizType, (IPay) value);  &lt;br/&gt;             });  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;    &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        payMap.get(code).pay();  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PayService2类实现了&lt;code&gt;ApplicationListener&lt;/code&gt;接口，这样在&lt;code&gt;onApplicationEvent方法&lt;/code&gt;中，就可以拿到&lt;code&gt;ApplicationContext&lt;/code&gt;的实例。这一步，其实是在spring容器启动的时候，spring通过反射我们处理好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再获取打了PayCode注解的类，放到一个&lt;code&gt;map&lt;/code&gt;中，map中的&lt;code&gt;key&lt;/code&gt;就是PayCode注解中定义的value，跟code参数一致，value是支付类的实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，每次就可以每次直接通过code获取支付类实例，而不用if...else判断了。如果要加新的支付方法，只需在支付类上面打上PayCode注解定义一个新的code即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：这种方式的code可以没有业务含义，可以是纯数字，只要不重复就行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.多线程处理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们需要在某个接口中，调用其他服务的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有这样的业务场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用户信息查询接口中需要返回：用户名称、性别、等级、头像、积分、成长值等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而用户名称、性别、等级、头像在用户服务中，积分在积分服务中，成长值在成长值服务中。为了汇总这些数据统一返回，需要另外提供一个对外接口服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，用户信息查询接口需要调用用户查询接口、积分查询接口 和 成长值查询接口，然后汇总数据统一返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用过程如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.184049079754601&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSegV4nBn6pQ0dYTz332ibOEmveuhTbiaDUAk72mHLVzpVz0MyvetPkGGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;326&quot;/&gt;调用远程接口总耗时 530ms = 200ms + 150ms + 180ms&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然这种串行调用远程接口性能是非常不好的，调用远程接口总的耗时为所有的远程接口耗时之和。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何优化远程接口性能呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到，既然串行调用多个远程接口性能很差，为什么不改成并行呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img data-ratio=&quot;0.5012285012285013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSSNAsEvIlgoiczQbO9k60Wz61Mp4q58OXgnEYm8aLTxgRL7wk2icFzvwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;调用远程接口总耗时 200ms = 200ms（即耗时最长的那次远程接口调用）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java8之前可以通过实现&lt;code&gt;Callable&lt;/code&gt;接口，获取线程返回结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java8以后通过&lt;code&gt;CompleteFuture&lt;/code&gt;类实现该功能。我们这里以CompleteFuture为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserInfo &lt;span&gt;getUserInfo&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; UserInfo userInfo = &lt;span&gt;new&lt;/span&gt; UserInfo();&lt;br/&gt;    CompletableFuture userFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteUserAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteBonusAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteGrowthAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();&lt;br/&gt;&lt;br/&gt;    userFuture.get();&lt;br/&gt;    bonusFuture.get();&lt;br/&gt;    growthFuture.get();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userInfo;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;温馨提醒一下，这两种方式别忘了使用线程池。示例中我用到了executor，表示自定义的线程池，为了防止高并发场景下，出现线程过多的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.懒加载&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，创建对象是一个非常耗时的操作，特别是在该对象的创建过程中，还需要创建很多其他的对象时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以单例模式为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍单例模式的时候，必须要先介绍它的两种非常著名的实现方式：&lt;code&gt;饿汉模式&lt;/code&gt; 和 &lt;code&gt;懒汉模式&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8.1 饿汉模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例在初始化的时候就已经建好了，不管你有没有用到，先建好了再说。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//持有自己类的引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//私有的构造方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//对外提供获取实例的静态方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用饿汉模式的好处是：&lt;code&gt;没有线程安全的问题&lt;/code&gt;，但带来的坏处也很明显。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始就实例化对象了，如果实例化过程非常耗时，并且最后这个对象没有被使用，不是白白造成资源浪费吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还真是啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候你也许会想到，不用提前实例化对象，在真正使用的时候再实例化不就可以了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是我接下来要介绍的：&lt;code&gt;懒汉模式&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8.2 懒汉模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton2 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton2 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton2();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例中的INSTANCE对象一开始是空的，在调用getInstance方法才会真正实例化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;懒汉模式相对于饿汉模式，没有提前实例化对象，在真正使用的时候再实例化，在实例化对象的阶段效率更高一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了单例模式之外，懒加载的思想，使用比较多的可能是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;spring的@Lazy注解。在spring容器启动的时候，不会调用其getBean方法初始化实例。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mybatis的懒加载。在mybatis做级联查询的时候，比如查用户的同时需要查角色信息。如果用了懒加载，先只查用户信息，真正使用到角色了，才取查角色信息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.初始化集合时指定大小&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在实际项目开发中，需要经常使用集合，比如：ArrayList、HashMap等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有个问题：你在初始化集合时指定了大小的吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; time1 = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100000&lt;/span&gt;; i++) {&lt;br/&gt;            list.add(i);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(System.currentTimeMillis() - time1);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行时间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在初始化集合时指定了大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Integer&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;100000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; time2 = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100000&lt;/span&gt;; i++) {&lt;br/&gt;            list2.add(i);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(System.currentTimeMillis() - time2);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行时间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们惊奇的发现，在创建集合时指定了大小，比没有指定大小，添加10万个元素的效率提升了一倍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看过&lt;code&gt;ArrayList&lt;/code&gt;源码，你就会发现它的默认大小是&lt;code&gt;10&lt;/code&gt;，如果添加元素超过了一定的阀值，会按&lt;code&gt;1.5&lt;/code&gt;倍的大小扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你想想，如果装10万条数据，需要扩容多少次呀？而每次扩容都需要不停的复制元素，从老集合复制到新集合中，需要浪费多少时间呀。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.不要满屏try...catch异常&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前我们在开发接口时，如果出现&lt;code&gt;异常&lt;/code&gt;，为了给用户一个更友好的提示，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不做任何处理，当我们请求add接口时，执行结果直接报错：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBS6NAiaefsh2FScQC5sFLbnUPCiaJcNuZlHHUYWiaapdBwCvTsr3ZTsN0xA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;what？用户能直接看到错误信息？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种交互方式给用户的体验非常差，为了解决这个问题，我们通常会在接口中捕获异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String result = &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        result = &lt;span&gt;&quot;数据异常&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口改造后，出现异常时会提示：“数据异常”，对用户来说更友好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来挺不错的，但是有问题。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是一个接口还好，但是如果项目中有成百上千个接口，都要加上异常捕获代码吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的，这时全局异常处理就派上用场了：&lt;code&gt;RestControllerAdvice&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestControllerAdvice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;handleException&lt;/span&gt;(&lt;span&gt;Exception&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; ArithmeticException) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;数据异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; Exception) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;服务器内部异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        retur nnull;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需在&lt;code&gt;handleException&lt;/code&gt;方法中处理异常情况，业务接口中可以放心使用，不再需要捕获异常（有人统一处理了）。真是爽歪歪。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.位运算效率更高&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你读过JDK的源码，比如：&lt;code&gt;ThreadLocal&lt;/code&gt;、&lt;code&gt;HashMap&lt;/code&gt;等类，你就会发现，它们的底层都用了&lt;code&gt;位运算&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么开发JDK的大神们，都喜欢用位运算？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：因为位运算的效率更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ThreadLocal的get、set、remove方法中都有这样一行代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过key的hashCode值，&lt;code&gt;与&lt;/code&gt;数组的长度减1。其中key就是ThreadLocal对象，&lt;code&gt;与&lt;/code&gt;数组的长度减1，相当于除以数组的长度减1，然后&lt;code&gt;取模&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一种hash算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来给大家举个例子：假设len=16，key.threadLocalHashCode=31，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是：int i = 31 &amp;amp; 15 = 15&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相当于：int i = 31 % 16 = 15&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算的结果是一样的，但是使用&lt;code&gt;与运算&lt;/code&gt;效率跟高一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么与运算效率更高？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：因为ThreadLocal的初始大小是&lt;code&gt;16&lt;/code&gt;，每次都是按&lt;code&gt;2&lt;/code&gt;倍扩容，数组的大小其实一直都是2的n次方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种数据有个规律就是高位是0，低位都是1。在做与运算时，可以不用考虑高位，因为与运算的结果必定是0。只需考虑低位的与运算，所以效率更高。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.巧用第三方工具类&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java的庞大体系中，其实有很多不错的小工具，也就是我们平常说的：&lt;code&gt;轮子&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在我们的日常工作当中，能够将这些轮子用户，再配合一下idea的快捷键，可以极大得提升我们的开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你引入&lt;code&gt;com.google.guava&lt;/code&gt;的pom文件，会获得很多好用的小工具。这里推荐一款&lt;code&gt;com.google.common.collect&lt;/code&gt;包下的集合工具：&lt;code&gt;Lists&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是在太好用了，让我爱不释手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将一个&lt;code&gt;大集合&lt;/code&gt;分成若干个&lt;code&gt;小集合&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们是这样做的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; partitionList = Lists.newArrayList();&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;List&amp;lt;Integer&amp;gt; dataList = Lists.newArrayList();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(Integer data : list) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(size &amp;gt;= &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;      dataList = Lists.newArrayList();&lt;br/&gt;      size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;   } &lt;br/&gt;   size++;&lt;br/&gt;   dataList.add(data);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将list按size=2分成多个小集合，上面的代码看起来比较麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用&lt;code&gt;Lists&lt;/code&gt;的&lt;code&gt;partition&lt;/code&gt;方法，可以这样写代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; partitionList = Lists.partition(list, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;System.out.println(partitionList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;], [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;], [&lt;span&gt;5&lt;/span&gt;]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是我最喜欢的方法之一，经常在项目中使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你了解更多非常有用的第三方工具类的话，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247495296&amp;amp;idx=1&amp;amp;sn=6ff4affb2d00dce011c08d8eb5448d7a&amp;amp;chksm=c0e83668f79fbf7ead1410a998f4d4406badd65f943ca1b6833a7b1d663d5d5d0808e4c462e4&amp;amp;token=1690710950&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;吐血推荐17个提升开发效率的“轮子”&lt;/a&gt;》。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.用同步代码块代替同步方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些业务场景中，为了防止多个线程并发修改某个共享数据，造成数据异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决并发场景下，多个线程同时修改数据，造成数据不一致的情况。通常情况下，我们会：&lt;code&gt;加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果锁加得不好，导致&lt;code&gt;锁的粒度太粗&lt;/code&gt;，也会非常影响接口性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中提供了&lt;code&gt;synchronized&lt;/code&gt;关键字给我们的代码加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常有两种写法：&lt;code&gt;在方法上加锁&lt;/code&gt; 和 &lt;code&gt;在代码块上加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看如何在方法上加锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;&lt;span&gt;(String fileUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    mkdir();&lt;br/&gt;    uploadFile(fileUrl);&lt;br/&gt;    sendMessage(fileUrl);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里加锁的目的是为了防止并发的情况下，创建了相同的目录，第二次会创建失败，影响业务功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这种直接在方法上加锁，锁的粒度有点粗。因为doSave方法中的上传文件和发消息方法，是不需要加锁的。只有创建目录方法，才需要加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道文件上传操作是非常耗时的，如果将整个方法加锁，那么需要等到整个方法执行完之后才能释放锁。显然，这会导致该方法的性能很差，变得得不偿失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我们可以改成在代码块上加锁了，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;&lt;span&gt;(String path,String fileUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(!exists(path)) {&lt;br/&gt;          mkdir(path);&lt;br/&gt;       }&lt;br/&gt;    }&lt;br/&gt;    uploadFile(fileUrl);&lt;br/&gt;    sendMessage(fileUrl);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样改造之后，锁的粒度一下子变小了，只有并发创建目录功能才加了锁。而创建目录是一个非常快的操作，即使加锁对接口的性能影响也不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最重要的是，其他的上传文件和发送消息功能，任然可以并发执行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.不用的数据及时清理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中保证线程安全的技术有很多，可以使用&lt;code&gt;synchroized&lt;/code&gt;、&lt;code&gt;Lock&lt;/code&gt;等关键字给代码块&lt;code&gt;加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是它们有个共同的特点，就是加锁会对代码的性能有一定的损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在jdk中还提供了另外一种思想即：&lt;code&gt;用空间换时间&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，使用&lt;code&gt;ThreadLocal&lt;/code&gt;类就是对这种思想的一种具体体现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal为每个使用变量的线程提供了一个独立的变量副本，这样每一个线程都能独立地改变自己的副本，而不会影响其它线程所对应的副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal的用法大致是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先创建一个CurrentUser类，其中包含了ThreadLocal的逻辑。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CurrentUser&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;UserInfo&amp;gt; THREA_LOCAL = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(UserInfo userInfo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        THREA_LOCAL.set(userInfo);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UserInfo &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.get();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.remove();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在业务代码中调用CurrentUser类。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   CurrentUser.set(userInfo);&lt;br/&gt;   ...&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;   UserInfo userInfo = CurrentUser.get();&lt;br/&gt;   ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务代码的第一行，将userInfo对象设置到CurrentUser，这样在业务代码中，就能通过CurrentUser.get()获取到刚刚设置的userInfo对象。特别是对业务代码调用层级比较深的情况，这种用法非常有用，可以减少很多不必要传参。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在高并发的场景下，这段代码有问题，只往ThreadLocal存数据，数据用完之后并没有及时清理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal即使使用了&lt;code&gt;WeakReference&lt;/code&gt;（弱引用）也可能会存在&lt;code&gt;内存泄露&lt;/code&gt;问题，因为 entry对象中只把key(即threadLocal对象)设置成了弱引用，但是value值没有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;     CurrentUser.set(userInfo);&lt;br/&gt;     ...&lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;     UserInfo userInfo = CurrentUser.get();&lt;br/&gt;     ...&lt;br/&gt;   } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;      CurrentUser.remove();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要在&lt;code&gt;finally&lt;/code&gt;代码块中，调用&lt;code&gt;remove&lt;/code&gt;方法清理没用的数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15.用equals方法比较是否相等&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你在项目中有没有见过，有些同事对&lt;code&gt;Integer&lt;/code&gt;类型的两个参数使用&lt;code&gt;==&lt;/code&gt;号比较是否相等？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反正我见过的，那么这种用法对吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的回答是看具体场景，不能说一定对，或不对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些状态字段，比如：orderStatus有：-1(未下单)，0（已下单），1（已支付），2（已完成），3（取消），5种状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时如果用==判断是否相等：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer orderStatus1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Integer orderStatus2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;System.out.println(orderStatus1 == orderStatus2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果会是true吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：是false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些同学可能会反驳，Integer中不是有范围是：&lt;code&gt;-128-127&lt;/code&gt;的缓存吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么是false？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看Integer的构造方法：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2754237288135593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSGoDWXuoUVJoGiayMxPSkuKayLarclUJxotziaQOBf9FLygUF9G4GBKoA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;472&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它其实并没有用到&lt;code&gt;缓存&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么缓存是在哪里用的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案在&lt;code&gt;valueOf&lt;/code&gt;方法中：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.226457399103139&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSrichYZ6WD1k8jazQES87KDkhNu2wGhM526E9lqcEEbtPbticaIWXXXNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面的判断改成这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String orderStatus1 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;String orderStatus2 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(Integer.valueOf(orderStatus1) == Integer.valueOf(orderStatus2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果会是true吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：还真是true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要养成良好编码习惯，尽量少用==判断两个Integer类型数据是否相等，只有在上述非常特殊的场景下才相等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而应该改成使用&lt;code&gt;equals&lt;/code&gt;方法判断：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer orderStatus1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Integer orderStatus2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;System.out.println(orderStatus1.equals(orderStatus2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果为true。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.避免创建大集合&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们在日常开发中，需要创建集合。比如：为了性能考虑，从数据库查询某张表的所有数据，一次性加载到内存的某个集合中，然后做业务逻辑处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;User&amp;gt; userList = userMapper.getAllUser();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(User user:userList) {&lt;br/&gt;   doSamething();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从数据库一次性查询出所有用户，然后在循环中，对每个用户进行业务逻辑处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;code&gt;用户表&lt;/code&gt;的数据量非常多时，这样userList集合会很大，可能直接导致内存不足，而使整个应用挂掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种情况，必须做&lt;code&gt;分页处理&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PAGE_SIZE = &lt;span&gt;500&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; currentPage = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;RequestPage page = &lt;span&gt;new&lt;/span&gt; RequestPage();&lt;br/&gt;page.setPageNo(currentPage);&lt;br/&gt;page.setPageSize(PAGE_SIZE);&lt;br/&gt;&lt;br/&gt;Page&amp;lt;User&amp;gt; pageUser = userMapper.search(page);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt;(pageUser.getPageCount() &amp;gt;= currentPage) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(User user:pageUser.getData()) {&lt;br/&gt;       doSamething();&lt;br/&gt;    }&lt;br/&gt;   page.setPageNo(++currentPage);&lt;br/&gt;   pageUser = userMapper.search(page);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的分页改造之后，每次从数据库中只查询&lt;code&gt;500&lt;/code&gt;条记录，保存到userList集合中，这样userList不会占用太多的内存。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里特别说明一下，如果你查询的表中的数据量本来就很少，一次性保存到内存中，也不会占用太多内存，这种情况也可以不做分页处理。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，还有中特殊的情况，即表中的记录数并算不多，但每一条记录，都有很多字段，单条记录就占用很多内存空间，这时也需要做分页处理，不然也会有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体的原则是要尽量避免创建大集合，导致内存不足的问题，但是具体多大才算大集合。目前没有一个唯一的衡量标准，需要结合实际的业务场景进行单独分析。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.状态用枚举&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们建的表中，有很多状态字段，比如：订单状态、禁用状态、删除状态等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每种状态都有多个值，代表不同的含义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如订单状态有：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有使用枚举，一般是这样做的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ORDER_STATUS_CREATE = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ORDER_STATUS_PAY = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ORDER_STATUS_DONE = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ORDER_STATUS_CANCEL = &lt;span&gt;4&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ORDER_STATUS_CREATE_MESSAGE = &lt;span&gt;&quot;下单&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ORDER_STATUS_PAY = &lt;span&gt;&quot;下单&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ORDER_STATUS_DONE = &lt;span&gt;&quot;下单&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ORDER_STATUS_CANCEL = &lt;span&gt;&quot;下单&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要定义很多静态常量，包含不同的状态和状态的描述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;枚举&lt;/code&gt;定义之后，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; OrderStatusEnum {  &lt;br/&gt;     CREATE(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;下单&quot;&lt;/span&gt;),  &lt;br/&gt;     PAY(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;支付&quot;&lt;/span&gt;),  &lt;br/&gt;     DONE(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&quot;完成&quot;&lt;/span&gt;),  &lt;br/&gt;     CANCEL(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;&quot;撤销&quot;&lt;/span&gt;);  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; code;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; String message;  &lt;br/&gt;&lt;br/&gt;     OrderStatusEnum(&lt;span&gt;int&lt;/span&gt; code, String message) {  &lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.code = code;  &lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.message = message;  &lt;br/&gt;     }  &lt;br/&gt;   &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.code;  &lt;br/&gt;     }  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.message;  &lt;br/&gt;     }  &lt;br/&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; OrderStatusEnum &lt;span&gt;getOrderStatusEnum&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Arrays.stream(OrderStatusEnum.values()).filter(x -&amp;gt; x.code == code).findFirst().orElse(&lt;span&gt;null&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用枚举改造之后，职责更单一了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且使用枚举的好处是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;代码的可读性变强了，不同的状态，有不同的枚举进行统一管理和维护。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;枚举是天然单例的，可以直接使用==号进行比较。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;code和message可以成对出现，比较容易相关转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;枚举可以消除if...else过多问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.把固定值定义成静态常量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你在实际的项目开发中，有没有使用过固定值？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(user.getId() &amp;lt; &lt;span&gt;1000L&lt;/span&gt;) {&lt;br/&gt;   doSamething();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(Objects.isNull(user)) {&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(&lt;span&gt;&quot;该用户不存在&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中&lt;code&gt;1000L&lt;/code&gt;和&lt;code&gt;该用户不存在&lt;/code&gt;是固定值，每次都是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然是固定值，我们为什么不把它们定义成静态常量呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样语义上更直观，方便统一管理和维护，更方便代码复用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码优化为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_USER_ID = &lt;span&gt;1000L&lt;/span&gt;;&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(user.getId() &amp;lt; DEFAULT_USER_ID) {&lt;br/&gt;   doSamething();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String NOT_FOUND_MESSAGE = &lt;span&gt;&quot;该用户不存在&quot;&lt;/span&gt;;&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(Objects.isNull(user)) {&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(NOT_FOUND_MESSAGE);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;static final&lt;/code&gt;关键字修饰静态常量，&lt;code&gt;static&lt;/code&gt;表示&lt;code&gt;静态&lt;/code&gt;的意思，即类变量，而&lt;code&gt;final&lt;/code&gt;表示&lt;code&gt;不允许修改&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个关键字加在一起，告诉Java虚拟机这种变量，在内存中只有一份，在全局上是唯一的，不能修改，也就是&lt;code&gt;静态常量&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.避免大事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多小伙伴在使用spring框架开发项目时，为了方便，喜欢使用&lt;code&gt;@Transactional&lt;/code&gt;注解提供事务功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，使用@Transactional注解这种声明式事务的方式提供事务功能，确实能少写很多代码，提升开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但也容易造成大事务，引发其他的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图看看大事务引发的问题。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSElRhibpG7ykB9z1QsOon7r2NqJmoShOScCwjcdd5LibPpF5iay5ZDyuvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;从图中能够看出，大事务问题可能会造成接口超时，对接口的性能有直接的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们该如何优化大事务呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;少用@Transactional注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将查询(select)方法放到事务外&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务中避免远程调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务中避免一次性处理太多数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些功能可以非事务执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些功能可以异步处理&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于大事务问题我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490259&amp;amp;idx=1&amp;amp;sn=1dd11c5f49103ca303a61fc82ce406e0&amp;amp;chksm=c0ebc23bf79c4b2db58b28ef752560bd91a1932ceb6713c9b19b821db0f29e1c58275d334076&amp;amp;token=2041133408&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;让人头痛的大事务问题到底要如何解决？&lt;/a&gt;》，它里面做了非常详细的介绍，如果大家感兴趣可以看看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.消除过长的if...else&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在写代码的时候，if...else的判断条件是必不可少的。不同的判断条件，走的代码逻辑通常会不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说，先看看下面的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;); &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; AliaPay aliaPay;  &lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; WeixinPay weixinPay;  &lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; JingDongPay jingDongPay;  &lt;br/&gt;   &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;toPay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;alia&quot;&lt;/span&gt;.equals(code)) {  &lt;br/&gt;             aliaPay.pay();  &lt;br/&gt;         } elseif (&lt;span&gt;&quot;weixin&quot;&lt;/span&gt;.equals(code)) {  &lt;br/&gt;              weixinPay.pay();  &lt;br/&gt;         } elseif (&lt;span&gt;&quot;jingdong&quot;&lt;/span&gt;.equals(code)) {  &lt;br/&gt;              jingDongPay.pay();  &lt;br/&gt;         } &lt;span&gt;else&lt;/span&gt; {  &lt;br/&gt;              System.out.println(&lt;span&gt;&quot;找不到支付方式&quot;&lt;/span&gt;);  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PayService类的toPay方法主要是为了发起支付，根据不同的code，决定调用用不同的支付类（比如：aliaPay）的pay方法进行支付。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码有什么问题呢？也许有些人就是这么干的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想一下，如果支付方式越来越多，比如：又加了百度支付、美团支付、银联支付等等，就需要改toPay方法的代码，增加新的else...if判断，判断多了就会导致逻辑越来越多？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显，这里违法了设计模式六大原则的：开闭原则 和 单一职责原则。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;开闭原则：对扩展开放，对修改关闭。就是说增加新功能要尽量少改动已有代码。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;单一职责原则：顾名思义，要求逻辑尽量单一，不要太复杂，便于复用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何优化if...else判断呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用 &lt;code&gt;策略模式&lt;/code&gt;+&lt;code&gt;工厂模式&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;策略模式定义了一组算法，把它们一个个封装起来, 并且使它们可相互替换。工厂模式用于封装和管理对象的创建，是一种创建型模式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.register(&lt;span&gt;&quot;aliaPay&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.register(&lt;span&gt;&quot;weixinPay&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.register(&lt;span&gt;&quot;jingDongPay&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayStrategyFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, IPay&amp;gt; PAY_REGISTERS = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(String code, IPay iPay)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; != code &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(code)) {&lt;br/&gt;            PAY_REGISTERS.put(code, iPay);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IPay &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; PAY_REGISTERS.get(code);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService3&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;toPay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.get(code).pay();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的关键是PayStrategyFactory类，它是一个策略工厂，里面定义了一个全局的map，在所有IPay的实现类中注册当前实例到map中，然后在调用的地方通过PayStrategyFactory类根据code从map获取支付类实例即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果加了一个新的支付方式，只需新加一个类实现IPay接口，定义init方法，并且重写pay方法即可，其他代码基本上可以不用动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，消除又臭又长的if...else判断，还有很多方法，比如：使用注解、动态拼接类名称、模板方法、枚举等等。由于篇幅有限，在这里我就不过多介绍了，更详细的内容可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490272&amp;amp;idx=1&amp;amp;sn=c5db63c7b52e7518b7a42e48c70927fc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;消除if...else是9条锦囊妙计&lt;/a&gt;》&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.防止死循环&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些小伙伴看到这个标题，可能会感到有点意外，代码中不是应该避免死循环吗？为啥还是会产生死循环？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;殊不知有些死循环是我们自己写的，例如下面这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(condition) {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;do samething&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用了while(true)的循环调用，这种写法在&lt;code&gt;CAS自旋锁&lt;/code&gt;中使用比较多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当满足condition等于true的时候，则自动退出该循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果condition条件非常复杂，一旦出现判断不正确，或者少写了一些逻辑判断，就可能在某些场景下出现死循环的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现死循环，大概率是开发人员人为的bug导致的，不过这种情况很容易被测出来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还有一种隐藏的比较深的死循环，是由于代码写的不太严谨导致的。如果用正常数据，可能测不出问题，但一旦出现异常数据，就会立即出现死循环。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，还有另一种死循环：&lt;code&gt;无限递归&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要打印某个分类的所有父分类，可以用类似这样的递归方法实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printCategory&lt;/span&gt;&lt;span&gt;(Category category)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(category == &lt;span&gt;null&lt;/span&gt; &lt;br/&gt;      || category.getParentId() == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  } &lt;br/&gt;  System.out.println(&lt;span&gt;&quot;父分类名称：&quot;&lt;/span&gt;+ category.getName());&lt;br/&gt;  Category parent = categoryMapper.getCategoryById(category.getParentId());&lt;br/&gt;  printCategory(parent);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，这段代码是没有问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果某次有人误操作，把某个分类的parentId指向了它自己，这样就会出现无限递归的情况。导致接口一直不能返回数据，最终会发生堆栈溢出。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;建议写递归方法时，设定一个递归的深度，比如：分类最大等级有4级，则深度可以设置为4。然后在递归方法中做判断，如果深度大于4时，则自动返回，这样就能避免无限循环的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.注意BigDecimal的坑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常我们会把一些小数类型的字段（比如：金额），定义成&lt;code&gt;BigDecimal&lt;/code&gt;，而不是&lt;code&gt;Double&lt;/code&gt;，避免丢失精度问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Double时可能会有这种场景：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;double&lt;/span&gt; amount1 = &lt;span&gt;0.02&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;double&lt;/span&gt; amount2 = &lt;span&gt;0.03&lt;/span&gt;;&lt;br/&gt;System.out.println(amount2 - amount1);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下预计amount2 - amount1应该等于0.01&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是执行结果，却为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;0.009999999999999998&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际结果小于预计结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Double类型的两个参数相减会转换成二进制，因为Double有效位数为16位这就会出现存储小数位数不够的情况，这种情况下就会出现误差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常识告诉我们使用&lt;code&gt;BigDecimal&lt;/code&gt;能避免丢失精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是使用BigDecimal能避免丢失精度吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal amount1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;0.02&lt;/span&gt;);&lt;br/&gt;BigDecimal amount2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;0.03&lt;/span&gt;);&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中定义了两个BigDecimal类型参数，使用构造函数初始化数据，然后打印两个参数相减后的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;0.0099999999999999984734433411404097569175064563751220703125&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不科学呀，为啥还是丢失精度了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Jdk&lt;/code&gt;中&lt;code&gt;BigDecimal&lt;/code&gt;的&lt;code&gt;构造方法&lt;/code&gt;上有这样一段描述：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2511013215859031&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSH69HIOJwzLbx8F0uoMgeDicyDBUKjAyWDulF9OB9sx66Sds4Orre8vA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;908&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致的意思是此构造函数的结果可能不可预测，可能会出现创建时为0.1，但实际是0.1000000000000000055511151231257827021181583404541015625的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，使用BigDecimal构造函数初始化对象，也会丢失精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何才能不丢失精度呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal amount1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(Double.toString(&lt;span&gt;0.02&lt;/span&gt;));&lt;br/&gt;BigDecimal amount2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(Double.toString(&lt;span&gt;0.03&lt;/span&gt;));&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用&lt;code&gt;Double.toString&lt;/code&gt;方法，对double类型的小数进行转换，这样能保证精度不丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，还有更好的办法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal amount1 = BigDecimal.valueOf(&lt;span&gt;0.02&lt;/span&gt;);&lt;br/&gt;BigDecimal amount2 = BigDecimal.valueOf(&lt;span&gt;0.03&lt;/span&gt;);&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;BigDecimal.valueOf&lt;/code&gt;方法初始化BigDecimal类型参数，也能保证精度不丢失。在新版的阿里巴巴开发手册中，也推荐使用这种方式创建BigDecimal参数。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.尽可能复用代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ctrl + c&lt;/code&gt; 和 &lt;code&gt;ctrl + v&lt;/code&gt;可能是程序员使用最多的快捷键了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，我们是大自然的搬运工。哈哈哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目初期，我们使用这种工作模式，确实可以提高一些工作效率，可以少写（实际上是少敲）很多代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但它带来的问题是：会出现大量的代码重复。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        addLog(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (log.isInfoEnabled()) {&lt;br/&gt;            log.info(&lt;span&gt;&quot;info:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        addLog(&lt;span&gt;&quot;test2&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (log.isInfoEnabled()) {&lt;br/&gt;            log.info(&lt;span&gt;&quot;info:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService3&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        addLog(&lt;span&gt;&quot;test3&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (log.isInfoEnabled()) {&lt;br/&gt;            log.info(&lt;span&gt;&quot;info:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在TestService1、TestService2、TestService3类中，都有一个addLog方法用于添加日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来该功能用得好好的，直到有一天，线上出现了一个事故：服务器磁盘满了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因是打印的日志太多，记了很多没必要的日志，比如：查询接口的所有返回值，大对象的具体打印等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没办法，只能将addLog方法改成只记录&lt;code&gt;debug&lt;/code&gt;日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是乎，你需要全文搜索，addLog方法去修改，改成如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;        log.debug(&lt;span&gt;&quot;debug:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是有三个类中需要修改这段代码，但如果实际工作中有三十个、三百个类需要修改，会让你非常痛苦。改错了，或者改漏了，都会埋下隐患，把自己坑了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为何不把这种功能的代码提取出来，放到某个工具类中呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;LogUtil&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;初始化失败&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;            log.debug(&lt;span&gt;&quot;debug:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，在其他的地方，只需要调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        LogUtil.addLog(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果哪天addLog的逻辑又要改了，只需要修改LogUtil类的addLog方法即可。你可以自信满满的修改，不需要再小心翼翼了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们写的代码，绝大多数是可维护性的代码，而非一次性的。所以，建议在写代码的过程中，如果出现重复的代码，尽量提取成公共方法。千万别因为项目初期一时的爽快，而给项目埋下隐患，后面的维护成本可能会非常高。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.foreach循环中不remove元素&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道在Java中，循环有很多种写法，比如：while、for、foreach等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;,&lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String temp : list) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;c&quot;&lt;/span&gt;.equals(temp)) {&lt;br/&gt;                list.remove(temp);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        System.out.println(list);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception in thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.util.ConcurrentModificationException&lt;br/&gt; at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:&lt;span&gt;901&lt;/span&gt;)&lt;br/&gt; at java.util.ArrayList$Itr.next(ArrayList.java:&lt;span&gt;851&lt;/span&gt;)&lt;br/&gt; at com.sue.jump.service.test1.Test2.main(Test2.java:&lt;span&gt;24&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种在&lt;code&gt;foreach&lt;/code&gt;循环中调用&lt;code&gt;remove&lt;/code&gt;方法删除元素，可能会报&lt;code&gt;ConcurrentModificationException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想在遍历集合时，删除其中的元素，可以用for循环，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;,&lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;            String temp = list.get(i);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;c&quot;&lt;/span&gt;.equals(temp)) {&lt;br/&gt;                list.remove(temp);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        System.out.println(list);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[a, b]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.避免随意打印日志&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们写代码的时候，打印日志是必不可少的工作之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为日志可以帮我们快速定位问题，判断代码当时真正的执行逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但打印日志的时候也需要注意，不是说任何时候都要打印日志，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/query&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt; &lt;span&gt;query&lt;/span&gt;&lt;span&gt;(@RequestBody List&amp;lt;Long&amp;gt; ids)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    log.info(&lt;span&gt;&quot;request params:{}&quot;&lt;/span&gt;, ids);&lt;br/&gt;    List&amp;lt;User&amp;gt; userList = userService.query(ids);&lt;br/&gt;    log.info(&lt;span&gt;&quot;response:{}&quot;&lt;/span&gt;, userList);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userList;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于有些查询接口，在日志中打印出了请求参数和接口返回值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咋一看没啥问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果ids中传入值非常多，比如有1000个。而该接口被调用的频次又很高，一下子就会打印大量的日志，用不了多久就可能把&lt;code&gt;磁盘空间&lt;/code&gt;打满。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果真的想打印这些日志该怎么办？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/query&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt; &lt;span&gt;query&lt;/span&gt;&lt;span&gt;(@RequestBody List&amp;lt;Long&amp;gt; ids)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;        log.debug(&lt;span&gt;&quot;request params:{}&quot;&lt;/span&gt;, ids);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    List&amp;lt;User&amp;gt; userList = userService.query(ids);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;        log.debug(&lt;span&gt;&quot;response:{}&quot;&lt;/span&gt;, userList);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userList;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;isDebugEnabled&lt;/code&gt;判断一下，如果当前的日志级别是&lt;code&gt;debug&lt;/code&gt;才打印日志。生产环境默认日志级别是&lt;code&gt;info&lt;/code&gt;，在有些紧急情况下，把某个接口或者方法的日志级别改成debug，打印完我们需要的日志后，又调整回去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方便我们定位问题，又不会产生大量的垃圾日志，一举两得。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.比较时把常量写前面&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在比较两个参数值是否相等时，通常我们会使用&lt;code&gt;==&lt;/code&gt;号，或者&lt;code&gt;equals&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在第15章节中说过，使用&lt;code&gt;==&lt;/code&gt;号比较两个值是否相等时，可能会存在问题，建议使用&lt;code&gt;equals&lt;/code&gt;方法做比较。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(user.getName().equals(&lt;span&gt;&quot;苏三&quot;&lt;/span&gt;)) {&lt;br/&gt;   System.out.println(&lt;span&gt;&quot;找到：&quot;&lt;/span&gt;+user.getName());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面这段代码中，如果user对象，或者user.getName()方法返回值为&lt;code&gt;null&lt;/code&gt;，则都报&lt;code&gt;NullPointerException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何避免空指针异常呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String FOUND_NAME = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; == user) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(FOUND_NAME.equals(user.getName())) {&lt;br/&gt;   System.out.println(&lt;span&gt;&quot;找到：&quot;&lt;/span&gt;+user.getName());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用&lt;code&gt;equals&lt;/code&gt;做比较时，尽量将&lt;code&gt;常量&lt;/code&gt;写在前面，即equals方法的左边。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样即使user.getName()返回的数据为null，equals方法会直接返回false，而不再是报空指针异常。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.名称要见名知意&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java中没有强制规定参数、方法、类或者包名该怎么起名。但如果我们没有养成良好的起名习惯，随意起名的话，可能会出现很多奇怪的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;27.1 有意义的参数名&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们写代码时为了省事（可以少敲几个字母），参数名起得越简单越好。假如同事A写的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;String c = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; b = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一段时间之后，同事A离职了，同事B接手了这段代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他此时一脸懵逼，a是什么意思，b又是什么意思，还有c...然后心里一万个草泥马。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给参数起一个有意义的名字，是非常重要的事情，避免给自己或者别人埋坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; supplierCount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; purchaserCount = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;String userName = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; hasSuccess = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;27.2 见名知意&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;光起有意义的参数名还不够，我们不能就这点追求。我们起的参数名称最好能够&lt;code&gt;见名知意&lt;/code&gt;，不然就会出现这样的情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String yongHuMing = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;String 用户Name = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;String su3 = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;String suThree = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几种参数名看起来是不是有点怪怪的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为啥不定义成国际上通用的（地球人都能看懂）英文单词呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String userName = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;String susan = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这两个参数名，基本上大家都能看懂，减少了好多沟通成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以建议在定义不管是参数名、方法名、类名时，优先使用国际上通用的英文单词，更简单直观，减少沟通成本。少用汉子、拼音，或者数字定义名称。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;27.3 参数名风格一致&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数名其实有多种风格，列如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//字母全小写&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; suppliercount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//字母全大写&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; SUPPLIERCOUNT = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//小写字母 + 下划线&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; supplier_count = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//大写字母 + 下划线&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; SUPPLIER_COUNT = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//驼峰标识&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; supplierCount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某个类中定义了多种风格的参数名称，看起来是不是有点杂乱无章？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以建议类的成员变量、局部变量和方法参数使用supplierCount，这种&lt;code&gt;驼峰风格&lt;/code&gt;，即：第一个字母小写，后面的每个单词首字母大写。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; supplierCount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，为了好做区分，静态常量建议使用SUPPLIER_COUNT，即：&lt;code&gt;大写字母&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;下划线&lt;/code&gt;分隔的参数名。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SUPPLIER_COUNT = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.SimpleDateFormat线程不安全&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java8之前，我们对时间的格式化处理，一般都是用的&lt;code&gt;SimpleDateFormat&lt;/code&gt;类实现的。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleDateFormatService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;time&lt;/span&gt;&lt;span&gt;(String time)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;        SimpleDateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dateFormat.parse(time);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你真的这样写，是没问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就怕哪天抽风，你觉得dateFormat是一段固定的代码，应该要把它抽取成常量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是把代码改成下面的这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleDateFormatService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleDateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;time&lt;/span&gt;&lt;span&gt;(String time)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dateFormat.parse(time);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dateFormat对象被定义成了静态常量，这样就能被所有对象共用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只有一个线程调用time方法，也不会出现问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但Serivce类的方法，往往是被Controller类调用的，而Controller类的接口方法，则会被&lt;code&gt;tomcat&lt;/code&gt;的&lt;code&gt;线程池&lt;/code&gt;调用。换句话说，可能会出现多个线程调用同一个Controller类的同一个方法，也就是会出现多个线程会同时调用time方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而time方法会调用&lt;code&gt;SimpleDateFormat&lt;/code&gt;类的&lt;code&gt;parse&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(String text, ParsePosition pos)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    Date parsedDate;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        parsedDate = calb.establish(calendar).getTime();&lt;br/&gt;        ...&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IllegalArgumentException e) {&lt;br/&gt;        pos.errorIndex = start;&lt;br/&gt;        pos.index = oldStart;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; parsedDate;&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法会调用&lt;code&gt;establish&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Calendar &lt;span&gt;establish&lt;/span&gt;&lt;span&gt;(Calendar cal)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;//1.清空数据&lt;/span&gt;&lt;br/&gt;    cal.clear();&lt;br/&gt;    &lt;span&gt;//2.设置时间&lt;/span&gt;&lt;br/&gt;    cal.set(...);&lt;br/&gt;    &lt;span&gt;//3.返回&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; cal;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的步骤1、2、3是非原子操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果cal对象是局部变量还好，坏就坏在parse方法调用establish方法时，传入的calendar是&lt;code&gt;SimpleDateFormat&lt;/code&gt;类的父类&lt;code&gt;DateFormat&lt;/code&gt;的成员变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateFormat&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Forma&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ....&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Calendar calendar;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可能会出现多个线程，同时修改同一个对象即：dateFormat，它的同一个成员变量即：Calendar值的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样可能会出现，某个线程设置好了时间，又被其他的线程修改了，从而出现时间错误的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;SimpleDateFormat类的对象不要定义成静态的，可以改成方法的局部变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用ThreadLocal保存SimpleDateFormat类的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用java8的DateTimeFormatter类。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.少用Executors创建线程池&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道&lt;code&gt;JDK5&lt;/code&gt;之后，提供了&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类，用它可以&lt;code&gt;自定义线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的好处有很多，下面主要说说这3个方面。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;降低资源消耗&lt;/code&gt;：避免了频繁的创建线程和销毁线程，可以直接复用已有线程。而我们都知道，创建线程是非常耗时的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;提供速度&lt;/code&gt;：任务过来之后，因为线程已存在，可以拿来直接使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;提高线程的可管理性&lt;/code&gt;：线程是非常宝贵的资源，如果创建过多的线程，不仅会消耗系统资源，甚至会影响系统的稳定。使用线程池，可以非常方便的创建、管理和监控线程。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然JDK为了我们使用更便捷，专门提供了：&lt;code&gt;Executors&lt;/code&gt;类，给我们快速创建&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类中包含了很多&lt;code&gt;静态方法&lt;/code&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt;：创建一个可缓冲的线程，如果线程池大小超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt;：创建一个固定大小的线程池，如果任务数量超过线程池大小，则将多余的任务放到队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newScheduledThreadPool&lt;/code&gt;：创建一个固定大小，并且能执行定时周期任务的线程池。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;：创建只有一个线程的线程池，保证所有的任务安装顺序执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的场景下，如果大家使用这些静态方法创建线程池，会有一些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们一起看看有哪些问题？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt;：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt;：允许创建的线程数是Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们该怎办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先推荐使用&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类，我们自定义线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ExecutorService threadPool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;br/&gt;    &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;//corePoolSize线程池中核心线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;//maximumPoolSize 线程池中最大线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;//线程池中线程的最大空闲时间，超过这个时间空闲线程将被回收&lt;/span&gt;&lt;br/&gt;    TimeUnit.SECONDS,&lt;span&gt;//时间单位&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue(&lt;span&gt;500&lt;/span&gt;), &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy()); &lt;span&gt;//拒绝策略&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说一下，如果是一些低并发场景，使用&lt;code&gt;Executors&lt;/code&gt;类创建线程池也未尝不可，也不能完全一棍子打死。在这些低并发场景下，很难出现&lt;code&gt;OOM&lt;/code&gt;问题，所以我们需要根据实际业务场景选择。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.Arrays.asList转换的集合别修改&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们日常工作中，经常需要把&lt;code&gt;数组&lt;/code&gt;转换成&lt;code&gt;List&lt;/code&gt;集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为数组的长度是固定的，不太好扩容，而List的长度是可变的，它的长度会根据元素的数量动态扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK的&lt;code&gt;Arrays&lt;/code&gt;类中提供了&lt;code&gt;asList&lt;/code&gt;方法，可以把&lt;code&gt;数组&lt;/code&gt;转换成&lt;code&gt;List&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String [] array = &lt;span&gt;new&lt;/span&gt; String [] {&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;,&lt;span&gt;&quot;c&quot;&lt;/span&gt;};&lt;br/&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(array);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String str : list) {&lt;br/&gt;    System.out.println(str);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，使用Arrays.asList方法将array数组，直接转换成了list。然后在for循环中遍历list，打印出它里面的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果转换后的list，只是使用，没新增或修改元素，不会有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String[] array = &lt;span&gt;new&lt;/span&gt; String[]{&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;};&lt;br/&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(array);&lt;br/&gt;list.add(&lt;span&gt;&quot;d&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String str : list) {&lt;br/&gt;    System.out.println(str);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception in thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.UnsupportedOperationException&lt;br/&gt;at java.util.AbstractList.add(AbstractList.java:&lt;span&gt;148&lt;/span&gt;)&lt;br/&gt;at java.util.AbstractList.add(AbstractList.java:&lt;span&gt;108&lt;/span&gt;)&lt;br/&gt;at com.sue.jump.service.test1.Test2.main(Test2.java:&lt;span&gt;24&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会直接报&lt;code&gt;UnsupportedOperationException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;Arrays.asList&lt;/code&gt;方法转换后的&lt;code&gt;ArrayList&lt;/code&gt;，是&lt;code&gt;Arrays&lt;/code&gt;类的内部类，并非&lt;code&gt;java.util&lt;/code&gt;包下我们常用的&lt;code&gt;ArrayList&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Arrays类的内部ArrayList类，它没有实现父类的add和remove方法,用的是父类AbstractList的默认实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看看&lt;code&gt;AbstractList&lt;/code&gt;是如何实现的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index, E element)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类的&lt;code&gt;add&lt;/code&gt;和&lt;code&gt;remove&lt;/code&gt;方法直接抛异常了，因此调用Arrays类的内部ArrayList类的add和remove方法，同样会抛异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，Java代码优化是一个比较大的话题，它里面可以优化的点非常多，我没办法一一列举完。在这里只能抛砖引玉，介绍一下比较常见的知识点，更全面的内容，需要小伙伴们自己去思考和探索。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章写了很久，花了很多时间和心思，如果你看了文章有些收获，记得给我点赞鼓励一下喔。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8b90be95ae4eb810cd8946e47553f9d9</guid>
<title>换掉Postman，事实证明它更牛逼！</title>
<link>https://toutiao.io/k/uncruss</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tools=&quot;新媒体管家&quot; data-label=&quot;powered by xmt.cn&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span/&gt;&lt;span&gt;最近国产API管理工具卷起来了，甚至发生了公开踩踏事件，但最后还是要回归产品，产品好才真的好。给大家推荐Eolink，低调又强大。Eolink是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;结合了 API 设计、文档管理、自动化测试、监控、研发管理和团队协作的一站式 API 生产平台&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，还集成  Gitlab、Jenkins、钉钉、企业微信、飞书等平台，简直就是一个六边形战士，没有短板！最重要的是，Eolink在商用方面已全面领先！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LGh7bn8KbYDH7CosT0CQ8XJJW9w6aymWiaU8BZg4A5Rvc3Pf3RoiaDYGOWIobp4tVCR1MicbvhVruUcrDpenQ5Vyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1538&quot;/&gt;&lt;/p&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;目前SaaS产品完全免费，你可使用web版，也可下载桌面端，Windows、Mac、Linux 平台均支持！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;体验地址：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.eolink.com/?utm_source=w3003&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给大家准备了介绍视频，如果你不想看图文，也可&lt;span&gt;&lt;span&gt;滑到文章底部看视频&lt;/span&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;01.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;API研发测试天花板&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前市面上有众多API研发工具，但Eolink依然在&lt;span&gt;&lt;span&gt;功能深度、广度以及用户体验&lt;/span&gt;&lt;/span&gt;等方面都做到了更好，尤其是针对批量操作和重复工作开展了大量自动化和智能化提升。&lt;span&gt;&lt;span&gt;其实一个产品是不是用心打磨过，体验好不好，一上手就知道了。&lt;/span&gt;&lt;/span&gt;让我们看看Eolink到底有多强！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 支持所有类型的API文档管理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;无论使用什么语言开发，无论是 &lt;span&gt;&lt;span&gt;&lt;span&gt;HTTPS、Websocket、TCP、UDP、gRPC、RPC&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;等什么协议，还是 Restful、SOAP、WebService 等什么规范，Eolink 都可以协助团队快速、统一、规范地管理起来。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2. 一键发起API测试，打通 API 文档与测试&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Eolink可以一键发起测试，支持自动生成测试数据，能够通过 Javascript 代码对请求报文、返回结果等进行加解密、签名等处理，让繁琐的API测试变得简单顺滑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3. 0代码自动化测试，一键进行大范围回归测试&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当 API 发生变化时，可以一键进行API回归测试，系统会自动根据规则判断返回结果并得出测试报告，方便团队快速了解 API 改动的影响范围，可减少超过 95% 的测试时间！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 强大的COOKIE管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在测试需要 Cookie 的 API 时，Eolink支持在 Cookie 管理里添加所需的 Cookie 信息，系统会自动存储 Cookie，下次测试其他相同域名的 API 时会自动传递 Cookie 请求参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前SaaS产品完全免费，你可使用web版，也可下载桌面端，Windows、Mac、Linux 平台均支持！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;体验地址：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.eolink.com/?utm_source=w3003&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;02.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;隐秘又好用的小亮点&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;还发现Eolink几个隐藏的亮点功能，用起来特别香！&lt;/span&gt;&lt;/p&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;API变更智能通知&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;API历史版本比对&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;项目分析报表&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;超强Mock API&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;API文档评论功能&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;定时测试任务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持数据驱动&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直接上图，一看就懂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LGh7bn8KbYDH7CosT0CQ8XJJW9w6aymWiaQVUPIKNVO8n39c1NXLvPz2S0Sibzh6hUqO6CtLn9Y144IUrccEIYUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;当 API 发生变化时通过邮件和站内信自动通知相关成员，并且已与QQ和飞书打通&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LGh7bn8KbYDH7CosT0CQ8XJJW9w6aymWgn3FdXFVxqyxDaz2Aric6TNlJnGNwJenMGs6DYxBFhoZPolPTRuPEXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1837&quot;/&gt;&lt;/p&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;回滚查看API文档历史版本，智能查找不同版本文档差异&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LGh7bn8KbYDH7CosT0CQ8XJJW9w6aymWCl050EMNCELzia2nOBh494OrDVPYCFk4DxSrecFZWTn9m1U52tyic9Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1715&quot;/&gt;&lt;/p&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;强大的项目数据统计分析功能和醒目的可视化呈现，团队开发工作一目了然&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cmN2YSn1WojBMOZCCnVx1a2zdgV1krqr2H6dGJZXQqJq0mt8JJ5ePWgiaOUTueIv0K34RiaV8yg4ffEFcrClJGaw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;2539&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;简易Mock功能，减轻Mock规则编写压力&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cmN2YSn1WojBMOZCCnVx1a2zdgV1krqrDYW2icVyANpPHsPuwfww8EiaqFmK0kJr6ZH4iaovbWKApMJjFibQkRas0A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;2551&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;智能Mock功能，实现Mock规则零配置&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;当然，Eolink的功能还远不止如此，还有很多亮点可以探索。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前SaaS产品完全免费，你可使用web版，也可下载桌面端，Windows、Mac、Linux 平台均支持！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;体验地址：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;https://www.eolink.com/?utm_source=w3003&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;03.&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;API全生命周期解决方案&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Eolink除了API管理、自动化测试服务以外，还是全球首个API全生命周期管理的SaaS平台，提供包括&lt;span&gt;&lt;span&gt;API网关、API监控、API自动生成&lt;/span&gt;&lt;/span&gt;等服务。API-First大势所趋，不掌握API全生命周期管理容易掉队！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LGh7bn8KbYDH7CosT0CQ8XJJW9w6aymWx3BeuCDTME8UbicHzsw2Fwr1TeGS97gyErHbtricHiajrVLsYHciaWm7AQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1210&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;截至目前，Eolink已经为包括奇安信、深信服、泰康集团、索尼、统一企业、博时基金、圆通速递等&lt;/span&gt;&lt;span&gt;&lt;span&gt;3万家各行业领先的企业&lt;/span&gt;&lt;/span&gt;&lt;span&gt;提供API管理服务，私有云续费率接近100%，实力非常硬，口碑非常好，值得信赖！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫码加入官方微信群，领取&lt;span&gt;&lt;span&gt;API全生命周期管理资料，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;与开发团队进行深入交流！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwyIvRlq2cmUWziaV05u38at25Ud0uTPFnNnT3D2qaiakiaSfV9T6BXPXYsYNLxoSpl1WicEmafS3T1kA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;目前SaaS产品完全免费，你可使用web版，也可下载桌面端，Windows、Mac、Linux 平台均支持！更加厉害的是，他们还有开源产品！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;体验地址：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.eolink.com/?utm_source=w3003&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>683960c8c1846bbb6d4f9362c8ed6159</guid>
<title>彻底搞懂之C++智能指针</title>
<link>https://toutiao.io/k/yw510cs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body blogpost-body-html&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2022.cnblogs.com/blog/420532/202207/420532-20220720095122706-149653483.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;1658296992483&quot;/&gt;
&lt;p id=&quot;1658281911421&quot;/&gt;
&lt;p id=&quot;1658281899056&quot;/&gt;
&lt;p id=&quot;1658281884769&quot;/&gt;
&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p id=&quot;smart-pointers-modern-c&quot;&gt;&lt;span&gt;在现代 c + + 编程中，标准库包含 &lt;/span&gt;&lt;em&gt;智能指针&lt;/em&gt;&lt;span&gt;，这些指针用于帮助确保程序不会出现内存和资源泄漏，并具有异常安全。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;标准库智能指针分类&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被c++11弃用。所以我只说后3个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;shared_ptr&lt;/strong&gt;&lt;br/&gt;采用引用计数的智能指针。 如果你想要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时），请使用该指针。 直至所有 shared_ptr 所有者超出了范围或放弃所有权，才会删除原始指针。 大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块。 头文件：&amp;lt;memory&amp;gt;。 有关详细信息，请参阅 如何：创建和使用 Shared_ptr 实例 和 shared_ptr 类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unique_ptr&lt;/strong&gt;&lt;br/&gt;只允许基础指针的一个所有者。 除非你确信需要 shared_ptr，否则请将该指针用作 POCO 的默认选项。 可以移到新所有者，但不会复制或共享。 替换已弃用的 auto_ptr。 与 boost::scoped_ptr 比较。 unique_ptr 很小且高效;大小是一个指针，它支持用于从 c + + 标准库集合快速插入和检索的右值引用。 头文件：&amp;lt;memory&amp;gt;。 有关详细信息，请参阅 如何：创建和使用 Unique_ptr 实例 和 unique_ptr 类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;weak_ptr&lt;/strong&gt;&lt;br/&gt;结合 shared_ptr 使用的特例智能指针。 weak_ptr 提供对一个或多个 shared_ptr 实例拥有的对象的访问，但不参与引用计数。 如果你想要观察某个对象但不需要其保持活动状态，请使用该实例。 在某些情况下，需要断开 shared_ptr 实例间的循环引用。 头文件：&amp;lt;memory&amp;gt;。 有关详细信息，请参阅 如何：创建和使用 Weak_ptr 实例 和 weak_ptr 类。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;shared_ptr&lt;/h2&gt;
&lt;p&gt;shared_ptr 类型是 C++ 标准库中的一个智能指针，是为多个所有者可能必须管理对象在内存中的生命周期的方案设计的。 在您初始化一个 shared_ptr 之后，您可复制它，按值将其传入函数参数，然后将其分配给其他 shared_ptr 实例。 所有实例均指向同一个对象，并共享对一个“控制块”（每当新的 shared_ptr 添加、超出范围或重置时增加和减少引用计数）的访问权限。 当引用计数达到零时，控制块将删除内存资源和自身。&lt;/p&gt;
&lt;p&gt;下图显示了指向一个内存位置的几个 &lt;code&gt;shared_ptr&lt;/code&gt; 实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/zh-cn/cpp/cpp/media/shared_ptr.png?view=msvc-170&quot; alt=&quot;Shared pointer diagram.&quot; data-linktype=&quot;relative-path&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 原始用法：&lt;/p&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;Object * obj = new ChildObject(9);//从heap分配原始父对象，必须手动触发析构, 但子对象不会释放
testObject(*obj);
printf(&quot;release9 %p \n&quot;, obj);
delete obj;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当testObject()出现异常时，delete将不被执行，因此将导致内存泄露。&lt;/p&gt;
&lt;p&gt;如何避免这种问题？有人会说，这还不简单，直接在&lt;code&gt;throw exception(); 在catch中&lt;/code&gt;加上&lt;code&gt;delete ps;&lt;/code&gt;不就行了。问题是很多人都会忘记在适当的地方加上delete语句，如果你要对一个庞大的工程进行review，看是否有这种潜在的内存泄露问题，那就是一场灾难！&lt;br/&gt;这时我们会想：&lt;strong&gt;如果指向heap的内存也能像stack变量一样用完时被自动释放，那该有多好啊。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这正是 auto_ptr、unique_ptr和shared_ptr这几个智能指针背后的设计思想。我简单的总结下就是：&lt;strong&gt;将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用shared_ptr：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;{
    std::shared_ptr&amp;lt;Object&amp;gt; sObj = std::make_shared&amp;lt;ChildObject&amp;gt;(1);
    testObject(*sObj); //调用父对象
    //自动回收 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很简单对吧~&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;unique_ptr&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;unique_ptr不共享指针。 它不能复制到另一个 unique_ptr函数，由值传递给函数，或在任何需要复制副本的 C++ 标准库算法中使用。 只能移动 unique_ptr。 这意味着，内存资源所有权将转移到另一 unique_ptr，并且原始 unique_ptr 不再拥有此资源。 我们建议你将对象限制为由一个所有者所有，因为多个所有权会使程序逻辑变得复杂。 因此，当需要纯 C++ 对象的智能指针时，请使用make_unique帮助程序函数。&lt;/p&gt;
&lt;p&gt;下图演示了两个 &lt;code&gt;unique_ptr&lt;/code&gt; 实例之间的所有权转换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/zh-cn/cpp/cpp/media/unique_ptr.png?view=msvc-170&quot; alt=&quot;Diagram that shows moving the ownership of a unique pointer.&quot; data-linktype=&quot;relative-path&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt; 在 C++ 标准库的标头中 &lt;code&gt;&amp;lt;memory&amp;gt;&lt;/code&gt; 定义。 它与原始指针一样高效，可在 C++ 标准库容器中使用。 将实例添加到 &lt;code&gt;unique_ptr&lt;/code&gt; C++ 标准库容器是有效的，因为移动构造函数 &lt;code&gt;unique_ptr&lt;/code&gt; 无需复制操作。&lt;/p&gt;
&lt;p&gt;unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权，包括：&lt;/p&gt;
&lt;p&gt;1、拥有它指向的对象&lt;/p&gt;
&lt;p&gt;2、无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作&lt;/p&gt;
&lt;p&gt;3、保存指向某个对象的指针，当它本身被删除释放的时候，会使用给定的删除器释放它指向的对象&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;std::unique_ptr&amp;lt;int&amp;gt;p1(new int(5));
std::unique_ptr&amp;lt;int&amp;gt;p2=p1;// 编译会出错
std::unique_ptr&amp;lt;int&amp;gt;p3=std::move(p1);// 转移所有权,那块内存归p3所有, p1成为无效的针.
p3.reset();//释放内存.
p1.reset();//无效&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;share_ptr和unique_ptr的例子：&lt;/p&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

namespace Test
{
    #define formatBool(b) ((b) ? &quot;true&quot; : &quot;false&quot;)
    class Object
    {
    protected:
        int id;

    public:
        using pointer = std::shared_ptr&amp;lt;Object&amp;gt;;
        virtual std::string version() const {
            return &quot;1.0.0&quot;;
        }; 
        Object(int _id):id(_id){
            cout &amp;lt;&amp;lt; &quot;\nnew parent Object id:&quot; &amp;lt;&amp;lt; id  &amp;lt;&amp;lt; endl;
        };
        virtual ~Object(){//释放时，首先是派生，然后是基类。必须将基类析构函数设为虚基类， 防止delete 子对象时不会调用父析构函数，导致内存泄露
            delete parent_str_ptr;
            cout &amp;lt;&amp;lt; &quot;delete parent Object id:&quot; &amp;lt;&amp;lt; id  &amp;lt;&amp;lt; endl;
        };
        virtual std::string debug() const
        {
            auto str = std::string( &quot;debug Object id:&quot; + std::to_string(id) );
            return str;
        }

    private:
        std::string *parent_str_ptr = new std::string(&quot;parent_str_ptr memory leak&quot;);                                          
    };
    class ChildObject : public Object
    {
    public:
        ChildObject(int _id):Object(_id)
        {
            std::cout &amp;lt;&amp;lt; &quot;new ChildObject id:&quot; &amp;lt;&amp;lt; (id) &amp;lt;&amp;lt; &quot;\n&quot;;
        }

        ~ChildObject()
        {
            delete str_ptr;
            std::cout &amp;lt;&amp;lt; &quot;delete ChildObject id:&quot; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &quot;\n&quot;;
        }
        virtual std::string version() const {
            return &quot;2.0.0&quot;;
        }; 
    private:
        std::string *str_ptr = new std::string(&quot;memory leak&quot;);  

    };

    void testObject(const Object &amp;amp;obj)
    {
        std::cout &amp;lt;&amp;lt; obj.debug() &amp;lt;&amp;lt; &quot; version:&quot;&amp;lt;&amp;lt; obj.version() &amp;lt;&amp;lt; &quot;\n&quot;;
    }

    void testCase()
    {
        {
            std::shared_ptr&amp;lt;Object&amp;gt; sObj = std::make_shared&amp;lt;ChildObject&amp;gt;(1);
            testObject(*sObj); //调用父对象
            //自动回收 
        }

        {
            std::unique_ptr&amp;lt;Object&amp;gt; obj = std::make_unique&amp;lt;ChildObject&amp;gt;(2);
            testObject(*obj);
            auto obj2 = std::move(obj);//转移所有权到obj2

            printf(&quot;obj:%s obj2:%s \n&quot;, formatBool(!!obj), formatBool(!!obj2));

            testObject(*obj2);//调用父对象

            obj2.release();//手动释放后， obj, obj2指向的对象已经被回收， 不会触发自动回收
            printf(&quot;obj2.release， obj:%s obj2:%s \n&quot;, formatBool(!!obj), formatBool(!!obj2));
        }

        {
            std::unique_ptr&amp;lt;ChildObject&amp;gt; obj = std::make_unique&amp;lt;ChildObject&amp;gt;(3);// 使用make_unique
            testObject(*obj);
            printf(&quot;release3 %s \n&quot;, formatBool(!!obj));
        }
        {
            std::unique_ptr&amp;lt;ChildObject&amp;gt; obj(new ChildObject(4));//使用new
            testObject(*obj);
            printf(&quot;release4 %s \n&quot;, formatBool(!!obj));
        }
        {
            // std::unique_ptr&amp;lt;ChildObject&amp;gt; obj(ChildObject(5));//使用stack对象，这是错误的用法， error: no matching constructor for initialization of &#x27;std::unique_ptr&amp;lt;Object&amp;gt;&#x27;
            // printf(&quot;release5 %d \n&quot;, !!obj);
        }
        {
            std::unique_ptr&amp;lt;Object&amp;gt; obj = std::make_unique&amp;lt;ChildObject&amp;gt;(6);//用父对象, 会触发析构
            testObject(*obj);
            printf(&quot;release6 %s \n&quot;, formatBool(!!obj));
        }
        {
            ChildObject obj = ChildObject(7);//从stack分配原始对象， 会触发析构
            testObject(obj);
            printf(&quot;release7 %p \n&quot;, &amp;amp;obj);
        }
        {
            ChildObject * obj = new ChildObject(8);//从heap分配原始对象， 必须手动触发析构
            testObject(*obj);
            printf(&quot;release8 %p \n&quot;, obj);
            delete obj;
        }
        {
            Object * obj = new ChildObject(9);//从heap分配原始父对象，必须手动触发析构
            testObject(*obj);
            printf(&quot;release9 %p \n&quot;, obj);
            delete obj;
        }
        {
            Object * obj = new Object(10);//从heap分配原始父对象，必须手动触发析构
            testObject(*obj);
            printf(&quot;release10 %p \n&quot;, obj);
            delete obj;
        }
        {
            std::shared_ptr&amp;lt;Object&amp;gt; obj = std::make_unique&amp;lt;ChildObject&amp;gt;(11);//指向父对象, 会释放子对象
            testObject(*obj);
            printf(&quot;release11 %s \n&quot;, formatBool(!!obj));
        }
        // {
        //     std::unique_ptr&amp;lt;Object&amp;gt; obj = std::make_shared&amp;lt;ChildObject&amp;gt;(11);//error: no viable conversion from &#x27;shared_ptr&amp;lt;Test::ChildObject&amp;gt;&#x27; to &#x27;std::unique_ptr&amp;lt;Object&amp;gt;&#x27;
        //     testObject(*obj);
        //     printf(&quot;release11 %s \n&quot;, formatBool(!!obj));
        // }
    }
}

int main(int argc, char **argv)
{
    Test::testCase();

    return EXIT_SUCCESS;
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;#  c++ -std=c++14 -o a share_ptr.cpp; ./a
new parent Object id:1
new ChildObject id:1
debug Object id:1 version:2.0.0
delete ChildObject id:1
delete parent Object id:1

new parent Object id:2
new ChildObject id:2
debug Object id:2 version:2.0.0
obj:false obj2:true 
debug Object id:2 version:2.0.0
obj2.release， obj:false obj2:false 

new parent Object id:3
new ChildObject id:3
debug Object id:3 version:2.0.0
release3 true 
delete ChildObject id:3
delete parent Object id:3

new parent Object id:4
new ChildObject id:4
debug Object id:4 version:2.0.0
release4 true 
delete ChildObject id:4
delete parent Object id:4

new parent Object id:6
new ChildObject id:6
debug Object id:6 version:2.0.0
release6 true 
delete ChildObject id:6
delete parent Object id:6

new parent Object id:7
new ChildObject id:7
debug Object id:7 version:2.0.0
release7 0x7ff7bfcf3488 
delete ChildObject id:7
delete parent Object id:7

new parent Object id:8
new ChildObject id:8
debug Object id:8 version:2.0.0
release8 0x7fcaef705ba0 
delete ChildObject id:8
delete parent Object id:8

new parent Object id:9
new ChildObject id:9
debug Object id:9 version:2.0.0
release9 0x7fcaef705ba0 
delete ChildObject id:9
delete parent Object id:9

new parent Object id:10
debug Object id:10 version:1.0.0
release10 0x7fcaef705ba0 
delete parent Object id:10

new parent Object id:11
new ChildObject id:11
debug Object id:11 version:2.0.0
release11 true 
delete ChildObject id:11
delete parent Object id:11&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;strong&gt;weak_ptr&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;weak_ptr是用来&lt;strong&gt;解决shared_ptr相互引用时的死锁问题,&lt;/strong&gt;如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。&lt;/p&gt;
&lt;p&gt;最佳设计是避免在任何时候都能实现指针的共享所有权。 但是，如果您必须有实例的 &lt;code&gt;shared_ptr&lt;/code&gt; 共享所有权，请避免它们之间存在循环引用。 如果无法避免循环引用，或者出于某种原因更可取，则使用 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/cpp/standard-library/weak-ptr-class?view=msvc-170&quot; data-linktype=&quot;relative-path&quot; rel=&quot;noopener&quot;&gt;weak_ptr&lt;/a&gt; 向一个或多个所有者提供对另 &lt;code&gt;shared_ptr&lt;/code&gt; 一个的弱引用。 通过使用 &lt;code&gt;weak_ptr&lt;/code&gt; ，可以创建一个 &lt;code&gt;shared_ptr&lt;/code&gt; 联接到一组现有相关实例的，但前提是基础内存资源仍有效。 &lt;code&gt;weak_ptr&lt;/code&gt;本身并不参与引用计数，因此它无法阻止引用计数转到零。 但是，你可以使用 &lt;code&gt;weak_ptr&lt;/code&gt; 来尝试获取用于初始化的的新副本 &lt;code&gt;shared_ptr&lt;/code&gt; 。 如果已删除内存，则的 bool 运算符将 &lt;code&gt;weak_ptr&lt;/code&gt; 返回 &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt; 。 如果内存仍有效，新的共享指针会递增引用计数，并保证只要 &lt;code&gt;shared_ptr&lt;/code&gt; 变量保持在范围内，内存就有效。weak_ptr是弱智能指针对象，它不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的智能指针。将一个weak_ptr绑定到一个shared_ptr对象，不会改变shared_ptr的引用计数。一旦最后一个所指向对象的shared_ptr被销毁，所指向的对象就会被释放，即使此时有weak_ptr指向该对象，所指向的对象依然被释放。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;

class A;

class B
{
public:
    ~B()
    {
        std::cout &amp;lt;&amp;lt; &quot;B destory, a_ptr use_count:&quot; &amp;lt;&amp;lt; a_ptr.use_count() &amp;lt;&amp;lt; &quot;\n&quot;;
    }

    //    std::shared_ptr&amp;lt;A&amp;gt; a_ptr; //它会造成循环引用
    std::weak_ptr&amp;lt;A&amp;gt; a_ptr;//它不会循环引用
};

class A
{
public:
    ~A()
    {
        std::cout &amp;lt;&amp;lt; &quot;A destory, b_ptr use_count:&quot; &amp;lt;&amp;lt; b_ptr.use_count() &amp;lt;&amp;lt; &quot;\n&quot;;
    }

    // std::shared_ptr&amp;lt;B&amp;gt; b_ptr;//它会造成循环引用
    std::weak_ptr&amp;lt;B&amp;gt; b_ptr;//它不会循环引用
};

int main()
{
    std::shared_ptr&amp;lt;A&amp;gt; a(new A());
    std::shared_ptr&amp;lt;B&amp;gt; b(new B());
    a-&amp;gt;b_ptr = b;
    b-&amp;gt;a_ptr = a;

    std::cout &amp;lt;&amp;lt; &quot;A:&quot; &amp;lt;&amp;lt; a.use_count() &amp;lt;&amp;lt; &quot;\n&quot;;
    std::cout &amp;lt;&amp;lt; &quot;B:&quot; &amp;lt;&amp;lt; b.use_count() &amp;lt;&amp;lt; &quot;\n&quot;;
}
// * 运行结果：
// A:2
// B:2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;如何选择智能指针&lt;/h2&gt;
&lt;p&gt;（1）如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；&lt;/li&gt;
&lt;li&gt;两个对象包含都指向第三个对象的指针；&lt;/li&gt;
&lt;li&gt;STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr。如果函数使用new分配内存，并返还指向该内存的指针，将其返回类型声明为unique_ptr是不错的选择。这样，所有权转让给接受返回值的unique_ptr，而该智能指针将负责调用delete。可将unique_ptr存储到STL容器在那个，只要不调用将一个unique_ptr复制或赋给另一个算法（如sort()）。例如，可在程序中使用类似于下面的代码段。&lt;/p&gt;
&lt;h4&gt;  (3) 基于性能考虑：&lt;/h4&gt;
&lt;p data-pid=&quot;KBzKGqcF&quot;&gt;1、unique_ptr独占对象的所有权，由于没有引用计数，因此性能较好&lt;/p&gt;
&lt;p data-pid=&quot;ThoTZDbv&quot;&gt;2、shared_ptr共享对象的所有权，但性能略差&lt;/p&gt;
&lt;p data-pid=&quot;2XVph8ZH&quot;&gt;3、weak_ptr配合shared_ptr，解决循环引用的问题&lt;/p&gt;
&lt;p data-pid=&quot;_KQ0j_TC&quot;&gt;       由于性能问题，那么可以粗暴的理解：优先使用unique_ptr。但由于unique_ptr不能进行复制，因此部分场景下不能使用的。&lt;/p&gt;
&lt;p data-pid=&quot;_KQ0j_TC&quot;&gt; &lt;/p&gt;
&lt;h2&gt;智能指针的错误用法&lt;/h2&gt;
&lt;p data-pid=&quot;Tb2cu2q5&quot;&gt;1、使用智能指针托管的对象，尽量不要在再使用原生指针&lt;/p&gt;
&lt;p data-pid=&quot;tl1Iy6bw&quot;&gt;很多开发同学（包括我在内）在最开始使用智能指针的时候，对同一个对象会混用智能指针和原生指针，导致程序异常。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;void incorrect_smart_pointer1()
{
    A *a= new A();
    std::unique_ptr&amp;lt;A&amp;gt; unique_ptr_a(a);

    // 此处将导致对象的二次释放
    delete a;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p data-pid=&quot;zBa3ey9V&quot;&gt;2、不要把一个原生指针交给多个智能指针管理&lt;/p&gt;
&lt;p data-pid=&quot;VN4A8u8R&quot;&gt;如果将一个原生指针交个多个智能指针，这些智能指针释放对象时会产生对象的多次销毁&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;void incorrect_smart_pointer2()
{
    A *a= new A();
    std::unique_ptr&amp;lt;A&amp;gt; unique_ptr_a1(a);
    std::unique_ptr&amp;lt;A&amp;gt; unique_ptr_a2(a);// 此处将导致对象的二次释放
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p data-pid=&quot;QsomhVjP&quot;&gt;3、尽量不要使用 get()获取原生指针&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;void incorrect_smart_pointer3()
{
    std::shared_ptr&amp;lt;A&amp;gt; shared_ptr_a1 = std::make_shared&amp;lt;A&amp;gt;();

    A *a= shared_ptr_a1.get();

    std::shared_ptr&amp;lt;A&amp;gt; shared_ptr_a2(a);// 此处将导致对象的二次释放

    delete a;// 此处也将导致对象的二次释放
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p data-pid=&quot;Femj9eFt&quot;&gt;4、不要将 this 指针直接托管智能指针&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;class E
{
    void use_this()
    {
        //错误方式，用this指针重新构造shared_ptr，将导致二次释放当前对象
        std::shared_ptr&amp;lt;E&amp;gt; this_shared_ptr1(this);
    }
};

std::shared_ptr&amp;lt;E&amp;gt; e = std::make_shared&amp;lt;E&amp;gt;();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p data-pid=&quot;7kECTiJF&quot;&gt;5、智能指针只能管理堆对象，不能管理栈上对象&lt;/p&gt;
&lt;p data-pid=&quot;JETEOtA3&quot;&gt;栈上对象本身在出栈时就会被自动销毁，如果将其指针交给智能指针，会造成对象的二次销毁&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;void incorrect_smart_pointer5()
{
    int int_num = 3;
    std::unique_ptr&amp;lt;int&amp;gt; int_unique_ptr(&amp;amp;int_num);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2&gt;如何优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存占用高&lt;/strong&gt;&lt;br/&gt;shared_ptr 的内存占用是裸指针的两倍。因为除了要管理一个裸指针外，还要维护一个引用计数。&lt;br/&gt;因此相比于 unique_ptr, shared_ptr 的内存占用更高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原子操作性能低&lt;/strong&gt;&lt;br/&gt;考虑到线程安全问题，引用计数的增减必须是原子操作。而原子操作一般情况下都比非原子操作慢。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用移动优化性能&lt;/strong&gt;&lt;br/&gt;shared_ptr 在性能上固然是低于 unique_ptr。而通常情况，我们也可以尽量避免 shared_ptr 复制。&lt;br/&gt;如果，一个 shared_ptr 需要将所有权共享给另外一个新的 shared_ptr，而我们确定在之后的代码中都不再使用这个 shared_ptr，那么这是一个非常鲜明的移动语义。&lt;br/&gt;对于此种场景，我们尽量使用 std::move，将 shared_ptr 转移给新的对象。因为移动不用增加引用计数，性能比复制更好。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;汇总 &lt;/h2&gt;
&lt;p&gt;智能指针能更安全的回收内存，它能防止：&lt;/p&gt;
&lt;p&gt;  1. 忘记delete造成的内存泄露&lt;/p&gt;
&lt;p&gt;  2. delete了，又被访问到了，比如并发时，导致“野指针”的危险情况&lt;/p&gt;
&lt;p&gt;  3. delete了，又被delete了，导致重复回收，导致报错中断程序&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;总的来说，一般推荐用智能指针，性能要求很高性，可以用裸指针，但要十分小心。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;https://docs.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/319277442/answer/2384378560&lt;/p&gt;
&lt;p&gt;https://www.cyhone.com/articles/right-way-to-use-cpp-smart-pointer/&lt;/p&gt;
&lt;p&gt;https://juejin.cn/post/6844904198962675719&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>28dac3e426be9bfbe0fa71dd7081be7e</guid>
<title>松果出行 x StarRocks：实时数仓新范式的实践之路</title>
<link>https://toutiao.io/k/5vklfca</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;list&quot; data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;span/&gt;&lt;strong&gt;&lt;span&gt;作者：松果出行数据中台部门&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;松果出行成立于 2017 年，以“构建更智慧的交通基础设施，提升全球所有人的移动能力”为使命，定位于“以工业互联网为基础的交通科技公司”。松果出行创新打造“工业互联网在交通科技领域的典型样本”，构建由工业基础、落地产品、数字引擎和科技应用组成的完整产业生态。松果智能工厂（合肥）是全球首个电动两轮车智能自动化整装工厂，以严格的国标车型，满足政府监管需求、用户需求、业务需求和运维需求。松果电单车是国内县域层面国内较大、行业知名的经营共享电单车品牌之一，截至 2021 年 9 月，覆盖全国 24 个省份、700 多个城市，全国注册用户超 5000 万，日订单峰值达 300 万单。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为一家面向未来的交通行业科技公司，松果出行的软硬件关键系统基本自研，以实现自主可控。&lt;/span&gt;&lt;span&gt;目前业务数据涵盖支付、车辆、制造、营销、订单、广告等，数据多元，维度丰富，B、C、G 等不同方向都有丰富的应用场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;凭借 StarRocks 高效的多表关联以及实时更新能力，我们放弃了原有基于 Impala+Kudu 和 ClickHouse 的实时数仓构建模式，基于 StarRocks 实践了全新的实时数仓模式，大幅的降低了实时分析构建的复杂性。通过这个平台，我们不仅可以快速构建各种小时、分钟、秒级的看板指标以及数据服务，还能保证数据在导入准确的同时保持高性能。基于 StarRocks 在核心的订单以及车辆业务方向的成功应用，我们对其他场景的数据链路也进行了调整，整个实时链路都接入到 StarRocks。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以前我们使用了很多不同类型的查询引擎，不断做加法，大多数时候都要忙于处理各种组件的异常。在引入 StarRocks 后，我们不断做减法，成功统一查询引擎、降低维护成本、提高数据取用灵活性。如今，StarRocks 已成为我们数据中台统一分析的底座。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;#01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;松果出行实时 OLAP 的演进&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;—&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为对内对外的数据窗口的提供者，松果出行数据中台部门的职责是围绕数据集群、OLAP 引擎、离线/实时数仓、画像标签、数据治理、产品工具等，结合数据建模、人工智能、增强分析、数据可视化等技术，为业务的智能化分析决策提供支撑。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;两轮电单车出行是我们的核心业务。业务链条主要包含投车、骑行、支付、换电、营销、挪车等很多环节。在这些过程中我们既需要对中间过程的变更做留存，也需要对最终的结果数据做计算。既有针对车的也有针对不同区域、订单的纬度需求，需要定时或不定时提供多维度的数据。准实时、实时的数据需求也越来越多，越来越迫切。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;松果出行数据中台采用的是经典的 Lambda 架构，离线跟实时是两套单独的体系；离线以 Apache Hive（以下简称 Hive）、Apache Spark（以下简称 Spark）、Presto、MySQL 为主，做数据清洗、计算、查询、展示使用，这套架构基本能满足离线分析的需求。对于实时场景的探索，主要经历了三个阶段：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;113983&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;实时数仓 1.0 的架构&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;225&quot; data-backw=&quot;562&quot; data-height=&quot;152&quot; data-ratio=&quot;0.40059790732436473&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC5kl11rY7nZILcoxnKmA4RibrPmP7gkpFecsjZv2xR0zyFn7zInZIWu2CnLPict2c0zk9DQdGv5Ur6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1338&quot; data-width=&quot;432&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MySQL 业务库数据经 Canal 实时抽取并发送到 Apache Kafka（以下简称 Kafka），然后写入 Kudu。Apache Spark（以下简称 Spark）定时从 Kudu 读取数据并计算，通过 Apache Impala （以下简称 Impala）进行查询，提供小时级看板指标到 BI，解决了业务对于小时级数据的分析需求。另外一部分数据经 Spark 计算后写入 MySQL，用作对外的数据服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但随着深入使用，这套方案也存在以下痛点：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;115224&quot; data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot; data-width=&quot;100%&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;需要单独开发维护一套 Spark 程序来读取 Apache Kudu（以下简称 Kudu）表，定时计算，维护成本高；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Kudu 表的创建、读取、修改都不是很方便，要花很多时间修改程序；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于一些由多个原子指标组合衍生出来的指标无法快速实现；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;mpala + Kudu 的组件维护成本高；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无法获取每条变更日志所有变更状态的明细数据；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对 Kudu 跟 Impala 的监控缺失；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;大数据量的快速查询无法支撑。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;113983&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;2&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;实时数仓 2.0 的架构&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了解决以上痛点，我们又引入了实时 2.0 的架构，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;290&quot; data-backw=&quot;546&quot; data-height=&quot;204&quot; data-ratio=&quot;0.5309882747068677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC5kl11rY7nZILcoxnKmA4RibicLFibcCl6h3U4WJbv03ASI0xf0woa58LT8CEgLlLVrxic95ybfSN4bzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2388&quot; data-width=&quot;430&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;此方案数据采集阶段跟 1.0 架构相同，都是利用 Canal 组件实时抽取业务库数据日志到 Kafka，ETL 阶段用 Flink Stream+Flink SQL 消费 Kafka 做数据清洗和分层，DIM 层数据存储在 Apache HBase（以下简称 HBase）和 MySQL 中，ODS、DWD 等其他层数据放入 Kafka，最后通过 Apache Flink（以下简称 Flink）对数据进行关联、扩维、深度清洗后写入 ClickHouse 对外提供查询。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在 2.0 架构中，用 ClickHouse 替换了 Kudu + Impala，主要利用 ClickHouse 的如下功能：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;115224&quot; data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot; data-width=&quot;100%&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;丰富多样的表引擎可以支持不同业务查询；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;利&lt;/span&gt;&lt;span&gt;用任意合法表达式的分区操作进行裁剪，大大提高查询效率；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;支持表级及列级过期设置，降低空间占用率；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;支持不同压缩方式，提高查询速度；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;类 SQL 语法，且支持多种不同组件，对外提供 HTTP、JDBC、ODBC 等不同链接方式，便于整合到不同工具链路当中；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;丰富的函数库，可满足不同查询需求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这套方案提供了小时级以及更小时间粒度的看板指标需求，解决了 1.0 方案的一部分痛点，在一段时间内可以满足业务需求。但随着应用的深入，这套方案也展现出一些问题：&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;115224&quot; data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot; data-width=&quot;100%&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;更新删除能力差，去重能力差，导致数据准确性差；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;组件&lt;/span&gt;&lt;span&gt;维护成本高；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;表结构变更成本高；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;查询并发有限制;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分布式表的节点横向扩展差；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多表 Join 性能差。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;113983&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;3&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;实时数仓 3.0 的架构&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了解决以上问题，我们又引入了 StarRocks，实时架构演化了到了 3.0 方案：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;303&quot; data-backw=&quot;562&quot; data-height=&quot;207&quot; data-ratio=&quot;0.5394295302013423&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC5kl11rY7nZILcoxnKmA4RibPtaPuQlpjMNP9tuNrXTxtkueuTs0daic8ES7AIXWWusjIDqew5aibZTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2384&quot; data-width=&quot;432&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-lark-record-data=&quot;{&amp;quot;isCut&amp;quot;:false,&amp;quot;rootId&amp;quot;:&amp;quot;doxcnCL1HmSHD65FG5TQq0YrHQH&amp;quot;,&amp;quot;parentId&amp;quot;:&amp;quot;doxcnCL1HmSHD65FG5TQq0YrHQH&amp;quot;,&amp;quot;blockIds&amp;quot;:[46],&amp;quot;recordIds&amp;quot;:[&amp;quot;doxcnCnflOF3Bk3j4UM6LLhDjPc&amp;quot;],&amp;quot;recordMap&amp;quot;:{&amp;quot;doxcnCnflOF3Bk3j4UM6LLhDjPc&amp;quot;:{&amp;quot;id&amp;quot;:&amp;quot;doxcnCnflOF3Bk3j4UM6LLhDjPc&amp;quot;,&amp;quot;snapshot&amp;quot;:{&amp;quot;type&amp;quot;:&amp;quot;image&amp;quot;,&amp;quot;parent_id&amp;quot;:&amp;quot;doxcnCL1HmSHD65FG5TQq0YrHQH&amp;quot;,&amp;quot;comments&amp;quot;:null,&amp;quot;locked&amp;quot;:false,&amp;quot;hidden&amp;quot;:false,&amp;quot;author&amp;quot;:&amp;quot;7052984963809116163&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;image&amp;quot;:{&amp;quot;token&amp;quot;:&amp;quot;boxcnPTwaykG4FnAxc48aQaEbsg&amp;quot;,&amp;quot;mimeType&amp;quot;:&amp;quot;image/png&amp;quot;,&amp;quot;size&amp;quot;:268393,&amp;quot;scale&amp;quot;:1.4375,&amp;quot;width&amp;quot;:432,&amp;quot;height&amp;quot;:207,&amp;quot;name&amp;quot;:&amp;quot;56adb.png&amp;quot;}}},&amp;quot;doxcnCL1HmSHD65FG5TQq0YrHQH&amp;quot;:{&amp;quot;id&amp;quot;:&amp;quot;doxcnCL1HmSHD65FG5TQq0YrHQH&amp;quot;,&amp;quot;snapshot&amp;quot;:{&amp;quot;type&amp;quot;:&amp;quot;page&amp;quot;,&amp;quot;parent_id&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;comments&amp;quot;:null,&amp;quot;locked&amp;quot;:false,&amp;quot;hidden&amp;quot;:false,&amp;quot;author&amp;quot;:&amp;quot;7052984963809116163&amp;quot;,&amp;quot;children&amp;quot;:[&amp;quot;doxcnMkscUOcyii4ygJMnihJJVc&amp;quot;,&amp;quot;doxcnOOaKcSmKaIw4cvUsAW5nId&amp;quot;,&amp;quot;doxcnyicuSsQUCyeeqdUGeI4Lmb&amp;quot;,&amp;quot;doxcnIOW4Y42uGK20snysZxczad&amp;quot;,&amp;quot;doxcn3NZ5tgnW84xtCWghgY9rZc&amp;quot;,&amp;quot;doxcn2Caoi0qAs4yS8Vy41KW4Eg&amp;quot;,&amp;quot;doxcnc8wMACGCkcsYcJXZN9nLhf&amp;quot;,&amp;quot;doxcnYwaYoMw08CgGg9pRy5GsRg&amp;quot;,&amp;quot;doxcnkwKmgc4MQQoI0Z9yVQP8Ul&amp;quot;,&amp;quot;doxcntmxAwvZPgFT5gqMmVsEM9g&amp;quot;,&amp;quot;doxcnYeQaA46ccmIigPPTR51RWf&amp;quot;,&amp;quot;doxcnw0XH8OAJrCYHJz3xxKXFPb&amp;quot;,&amp;quot;doxcnYzktRn8dEwXanAoutlIeOd&amp;quot;,&amp;quot;doxcnIqqe0yAiAGUeG8IeJGs1Oe&amp;quot;,&amp;quot;doxcnX3IkQBc2GWZsGUYjoCZsee&amp;quot;,&amp;quot;doxcnHQV8WbzWNJT7JReRja1r3S&amp;quot;,&amp;quot;doxcnwcIEMU2MmiSGQbG3SrFrQh&amp;quot;,&amp;quot;doxcnuWW288ik6YSs6PgTJ1BWWe&amp;quot;,&amp;quot;doxcnUsseO0eSSIsWYh3kRSE0Jh&amp;quot;,&amp;quot;doxcncqkGy0222U0AUhQhWv0AAg&amp;quot;,&amp;quot;doxcnKEESy6G0yCemMteJTapt7c&amp;quot;,&amp;quot;doxcnys0ISKQA2Ou4EH7nEhwxGg&amp;quot;,&amp;quot;doxcnKqkmSQgUOoW2uS6BRcBGxc&amp;quot;,&amp;quot;doxcnyqS42OSA46oMgNh4I0WHYb&amp;quot;,&amp;quot;doxcnCKAmG4gciyGWgtQsiZHwIc&amp;quot;,&amp;quot;doxcnOC3Own7qhCpU7k36POQY7e&amp;quot;,&amp;quot;doxcndYsEctFhKinOb2dqJMsBhd&amp;quot;,&amp;quot;doxcnqR0pSuA5s4t4VXxyI9Y0Vb&amp;quot;,&amp;quot;doxcnUNnE8OQYoVOKudYHvAP9nd&amp;quot;,&amp;quot;doxcnva81Fhj51Ordd9PuC5CMG1&amp;quot;,&amp;quot;doxcn2U0is0yQ2wEEi8a8O8tDXc&amp;quot;,&amp;quot;doxcnKyYiAUYe60WEAfc58R4oQe&amp;quot;,&amp;quot;doxcnCemMKgGqkeGuYlFPG4BrQf&amp;quot;,&amp;quot;doxcniSWWaci2ue6O4PWhIS4Png&amp;quot;,&amp;quot;doxcnaQKsKYwie4IMKsq4hmmXkg&amp;quot;,&amp;quot;doxcnyuDeM0nCIvQ6JrQF6pVDMg&amp;quot;,&amp;quot;doxcnbKmdAoShQAP03fRnwT2xag&amp;quot;,&amp;quot;doxcnm2UOou00EYqK8d6M8xcn3g&amp;quot;,&amp;quot;doxcnWW2Ye8QqCQ62G4IiqgTU5d&amp;quot;,&amp;quot;doxcnYuA4wcsUMgMAsxB0Mbu2Vd&amp;quot;,&amp;quot;doxcn8OK4aIy2gW4OqKENFdKOLd&amp;quot;,&amp;quot;doxcnU8Kg2WKaKIiSAFJGBY9qee&amp;quot;,&amp;quot;doxcnA6eoKeEYaOCWZtRMDJ0BIF&amp;quot;,&amp;quot;doxcnneSBMp1NB1qcjWRODw287e&amp;quot;,&amp;quot;doxcnCnflOF3Bk3j4UM6LLhDjPc&amp;quot;,&amp;quot;doxcnY7n3kFiDyoTknx29NBUtl6&amp;quot;,&amp;quot;doxcnM4YY8602cMeS2L5sX0HlJf&amp;quot;,&amp;quot;doxcnQciI8CI8EeiawpcMHbAqdf&amp;quot;,&amp;quot;doxcnwY2EfOaig5U7Xunblr2zpc&amp;quot;,&amp;quot;doxcnBr5vDI8cXZzPk2TBy8p4fh&amp;quot;,&amp;quot;doxcnGKW8YagUumCGPmsVxhRKvy&amp;quot;,&amp;quot;doxcniUT7lCSOU5g20Y7s77UGFd&amp;quot;,&amp;quot;doxcnoaaK4W6mmKcaoXfAxRZKJc&amp;quot;,&amp;quot;doxcnI2484oeOOGoQ0Gx1BtXpid&amp;quot;,&amp;quot;doxcnWI8QOCEQsSMguspDkkHMFb&amp;quot;,&amp;quot;doxcnQ22m42QsuMwAc5yuAodTde&amp;quot;,&amp;quot;doxcnWWS4WsMYS8ayYxCHI0Royb&amp;quot;,&amp;quot;doxcnG062KE6mAYUmO6t86A1x9g&amp;quot;,&amp;quot;doxcn0Us024k48AAG87WZOdO1Ef&amp;quot;,&amp;quot;doxcnCDdjRnzp0JhBlEHBGnKXWP&amp;quot;,&amp;quot;doxcnbUa3oiodqmhcdpIpGBK7pb&amp;quot;,&amp;quot;doxcntC8LL0EnQwR3LMGPnfjgTf&amp;quot;,&amp;quot;doxcncA6UQUOuC4e6OghBYiNoCe&amp;quot;,&amp;quot;doxcnIkM8EyWgYWKAGIHeZSxh7d&amp;quot;,&amp;quot;doxcnfl1hIZ8wTXyBLBkkUXGZyg&amp;quot;,&amp;quot;doxcnqtAxp2nevwTjZsJzoYKMLf&amp;quot;,&amp;quot;doxcnBsOjJCPTfoHM96hBvYnZvb&amp;quot;,&amp;quot;doxcnPqRdY5hCHk06iXkQgUB5pd&amp;quot;,&amp;quot;doxcnMomIyF6raiCQ1IDNXT94qe&amp;quot;,&amp;quot;doxcncPTBndWdN1InuC7EJjWQKj&amp;quot;,&amp;quot;doxcnh0S3ToqRODvCUqtLGukISz&amp;quot;,&amp;quot;doxcn23dfmL1H61TjymaALJRDqZ&amp;quot;,&amp;quot;doxcngyoWqQoEEu60uwkhknGeUe&amp;quot;,&amp;quot;doxcnJ3mGkra3mkCwXjwLj8bcJe&amp;quot;,&amp;quot;doxcnrX3yKUQAdLll36MR4kTe9g&amp;quot;,&amp;quot;doxcnSU6i8C6Mauq2kVVbStqIoh&amp;quot;,&amp;quot;doxcnSEy6246uacwUQp1bOTinHe&amp;quot;,&amp;quot;doxcnzqzjM3PCPFix97RUg9ngvd&amp;quot;,&amp;quot;doxcnO0kMwasCGye2wJkRUer1Tg&amp;quot;,&amp;quot;doxcnr9iy7KUmaPcgsoedCUXcCg&amp;quot;,&amp;quot;doxcnU8IaM2ecIeKYMDxCnsEnNe&amp;quot;,&amp;quot;doxcn4QouS0iUoqmAaYDI7WeZYf&amp;quot;,&amp;quot;doxcngEWIM6Yk4qGaOeuo2rpKPJ&amp;quot;,&amp;quot;doxcn9duX4PNN7vxr99NR9ROrtd&amp;quot;,&amp;quot;doxcnjdP6wMw9SXbDPGaEOXMpkg&amp;quot;,&amp;quot;doxcnzTKIWadm3uxxAnUuqYNrab&amp;quot;,&amp;quot;doxcnvTgyUCvi0f5fLJwOt09Pch&amp;quot;,&amp;quot;doxcnLVIOcP4KuhFXJCCJLerh6g&amp;quot;,&amp;quot;doxcng8W22sCQgUEiCkX5o51ylc&amp;quot;,&amp;quot;doxcnzpbFESIKsXCTU9orcWyXgb&amp;quot;,&amp;quot;doxcnZHrCrMrHlKSYGRnQJ8ghUb&amp;quot;,&amp;quot;doxcnmUIIMYaUuywqia2Zw1GGNd&amp;quot;,&amp;quot;doxcnai6wwoEasE8EuWjNH4Z5Qc&amp;quot;,&amp;quot;doxcnCiu2WAG2gueqWqEKoc4kse&amp;quot;,&amp;quot;doxcn6yA8kk88YYSIWGUpQBZaYe&amp;quot;,&amp;quot;doxcnWQ42eiQ6AsUKQnDYMSTDAc&amp;quot;,&amp;quot;doxcnagZVWLXNMsjdZzVno8uYnh&amp;quot;,&amp;quot;doxcnUXq48Ob1vFPzxtopZPs9hg&amp;quot;,&amp;quot;doxcnECsgIG8igqeoyYzqrQGWad&amp;quot;,&amp;quot;doxcn8KswyesmUUOswHPwaHE9ub&amp;quot;,&amp;quot;doxcnzk7P2J7ULkVOMftljT7nOh&amp;quot;,&amp;quot;doxcnIToKKr8G9TKdFUW278hKrh&amp;quot;,&amp;quot;doxcnrdzyMen9bxGwZ7szDeU9ff&amp;quot;,&amp;quot;doxcn0JMwUAVNGYtTrKQecp2yfh&amp;quot;,&amp;quot;doxcnjHbp00Pz1xewesPmRCW13b&amp;quot;,&amp;quot;doxcneoxgs1OnVdmjjNofrK3Hgf&amp;quot;,&amp;quot;doxcnLegBf75pCImvXN1Mc3VUoc&amp;quot;,&amp;quot;doxcnaRGdRaXAV0sQqngQinIymd&amp;quot;,&amp;quot;doxcn8uQCOYsgmKWWyKi5pKSgnb&amp;quot;,&amp;quot;doxcnWIugygcSkyIaey7sNLSU5g&amp;quot;,&amp;quot;doxcn4A8q2WeOUaGus9Kr9nv6Hh&amp;quot;,&amp;quot;doxcnAwSyAqsS2GMyMlM3cIsrZf&amp;quot;,&amp;quot;doxcnv5R5SBD4Lb8rvgK3idr24d&amp;quot;,&amp;quot;doxcna6lM5tm7rgshNsB1Ac849b&amp;quot;,&amp;quot;doxcnm3oGzQKhhALrgiMM6M411Z&amp;quot;,&amp;quot;doxcn3121ZK3RqtBBy0VECWZ2fh&amp;quot;,&amp;quot;doxcnYAkiakSoKkk2ywsdQQJrZE&amp;quot;,&amp;quot;doxcn6o8Aka04i4GAuujQpuGbjg&amp;quot;,&amp;quot;doxcnkk4C6CAY4UgCsV1hWGxcqg&amp;quot;,&amp;quot;doxcnwAMkyM0wYYS2Ax0APmdxyc&amp;quot;,&amp;quot;doxcnKUiQeAQi8MMEyqadLo0LJc&amp;quot;,&amp;quot;doxcnI2Uu2qGMmEw4yQ2eire3SS&amp;quot;,&amp;quot;doxcnSSw96n0xwquQOaKLlCGODg&amp;quot;,&amp;quot;doxcnYGC6swYwOaAA6qHsMg1aZp&amp;quot;],&amp;quot;text&amp;quot;:{&amp;quot;apool&amp;quot;:{&amp;quot;nextNum&amp;quot;:1,&amp;quot;numToAttrib&amp;quot;:{&amp;quot;0&amp;quot;:[&amp;quot;author&amp;quot;,&amp;quot;7052984963809116163&amp;quot;]}},&amp;quot;initialAttributedTexts&amp;quot;:{&amp;quot;attribs&amp;quot;:{&amp;quot;0&amp;quot;:&amp;quot;*0+8&amp;quot;},&amp;quot;text&amp;quot;:{&amp;quot;0&amp;quot;:&amp;quot;松果出行案例文章&amp;quot;}}},&amp;quot;align&amp;quot;:&amp;quot;&amp;quot;}}},&amp;quot;payloadMap&amp;quot;:{},&amp;quot;extra&amp;quot;:{&amp;quot;mention_page_title&amp;quot;:{},&amp;quot;external_mention_url&amp;quot;:{}},&amp;quot;pasteFlag&amp;quot;:&amp;quot;79b3f549-ebb9-4f9b-ba85-f95923439452&amp;quot;}&quot; data-lark-record-format=&quot;docx/record&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;数据采集到 Kafka 之后&lt;/span&gt;&lt;span&gt;，先是通过 Flink Stream 进行反序列化、分流等操作，然后通过 Flink SQL 进行关联、扩维等，分为ODS、DIM、DWD、DWS 层，其中 DIM 层存储在 MySQL 与 HBase 当中，其他层存储在 Kafka 当中，层到层之间都是通过 Flink 来实现，所有数据的最终归口在 StarRocks。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前提供小时、分钟、秒级的看板指标及数据服务，历史数据和增量数据共同存储。3.0 方案完美解决了 1.0 跟 2.0 方案的痛点，甚至超出了我们的预期。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;#02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;StarRocks 的引入&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;—&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;114645&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;引入 StarRocks 主要是为了解决 2.0 架构面临的痛点。总结下来，我们对新的 OLAP 引擎的期望主要包括下面几点：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;115224&quot; data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot; data-width=&quot;100%&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不仅大宽表查询性能好，多表 Join 查询性能也非常优秀；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;支持 SQL 和类 SQL 查询，方便业务使用；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;支持批量、实时数据导入，满足历史数据和增量数据的提数需求；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;支持数据的更新、过期等，支持表结构的快速变更；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;支持大数据量的秒级查询响应；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有较好的并发支持能力；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;可以兼容已有的数据架构，可以方便地与 HDFS、Hive、MySQL 等交互使用;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有较强的容灾能力，运维简单，部署快速；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以方便地融进我们的平台工具当中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为此我们调研了一些主流 OLAP 引擎：&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;产品&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;优点&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;缺点&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;ClickHouse&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;单表性能优秀&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类 SQL 语法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多种表引擎&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询延迟低&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;数据更新支持差&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Join 性能差&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维护成本高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Apache Druid&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;查询延迟低&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;支持更新&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;聚合数据优秀&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;明细查询支持差&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询类型单一&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SQL 语法支持差&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Presto&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;SQL 语法灵活&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对 AdHoc 效果好&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;支持数据源丰富&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;查询延迟高&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并发能力弱&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Apache Kylin&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;预聚合优秀&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询延迟低&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;灵活性差&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维护成本高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;StarRocks&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;大宽表和多表查询性能都非常优秀&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类 SQL 语法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;支持多种数据模型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;支持较高并发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维护成本低&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;兼容 MySQL 协议&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;社区比较年轻&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;产品迭代比较快&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StarRocks 从功能层面很好地匹配了我们对实时 OLAP 引擎的需求。为了充分验证 StarRocks 的性能，我们按照下述方式搭建了测试环境进行性能测试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在相同资源配置下，我们对 StarRocks（1.16）和 ClickHouse（20.8）进行了对比测试，分别对比测试单表及多表关联查询的性能。在单表查询中，10亿以下的数据量，对于“select * ”、count、sum 等查询，ClickHouse 和 StarRocks 性能相近。在多表查询方面，StarRocks 完胜 ClickHouse。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在基于主键的数据更新场景中，我们希望做到尽可能高的数据准确性，但 ClickHouse 无论是使用 ReplacingMergeTree 表引擎还是数据整体更新，都无法很好支持。StarRocks 的更新模型则达到了我们的期望，通过数据导入的事务性保证了数据更新的准确性，同时能保持高性能。综合考虑下，我们最终选用 StarRocks 来作为实时 3.0 方案 的 OLAP 引擎。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如今，StarRocks 已经在松果出行广泛使用。StarRocks 也经历了多个版本的迭代，性能大幅提升。根据官方最新的基准测试，相较于之前测试的 1.16 版本，StarRocks 目前在性能方面已经接近 ClickHouse 的 2 倍，并且通过 LTS 版本的支持，也能在保持版本快速迭代的同时保障线上集群的稳定性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;#03&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;StarRocks 在松果出行的应用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;—&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;114645&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;113983&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;在订单业务中的应用&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;订单分析是我们的核心业务场景之一。引入 StarRocks 后，整个链路设计如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;277&quot; data-backw=&quot;562&quot; data-height=&quot;207&quot; data-ratio=&quot;0.4930139720558882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC5kl11rY7nZILcoxnKmA4RibYCsQDxxJCxhYgJ4FFchzFeBibTib0XA1ffSp8EVUYJNTIk193Ip7GUTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot; data-width=&quot;420&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;历史数据用 Broker Load 从 Hive 直接导入StarRocks。增量数据通过 Canal 抽取后再通过 Flink SQL 将订单表做字段补齐后，作为宽表直接用 Routine Load 写入 StarRocks 明细模型表，然后创建逻辑视图来满足不同维度的计算及所有状态的明细数据查询需求。在这层逻辑视图之上，通过调度平台定时对数据加工汇总后 Insert 到 StarRocks，作为数仓 ADS 层来满足不同团队的查询需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这套架构的好处是，我们只需用 Flink 做简单的 ETL 处理，后续业务计算在 StarRocks 进行，避免数据重复消费。这样可以快速灵活地响应不同团队不同维度的需求，而不需要在对接新的需求时，重新设计方案来对接，从而降低开发工期、灵活适用不同场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，我们基于 StarRocks 实现了秒级、小时级、天级的时间分析粒度，城市、大区、全国的区域分析粒度，提供订单量、订单总金额、超时费、里程费、客单价等维度下 30 多种不同的指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务变更已完全不需要我们重新修改开发程序，数据验证也简单快速。作为数据中台部门，只需新建一个视图或者修改视图逻辑，即可快速上线，提供数据支撑。在进行数据修复、异常追溯时也链路清晰，极大地提高了开发效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;113983&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;2&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;在车辆方向的应用&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;车辆是我们的核心资产。&lt;/span&gt;&lt;span&gt;从车辆的投放，到挪车、换电、维修等，整个链路非常长，不同车辆的状态是我们关注的重点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整个数据链路如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;562&quot; data-height=&quot;248&quot; data-ratio=&quot;0.5786407766990291&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC5kl11rY7nZILcoxnKmA4RibwWvFd2lwL8cX9JY12GbEK0crSquUh7PUG8orBZrvmqcb7dxUicibIzog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1030&quot; data-width=&quot;430&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这条数据链路涉及 10 张多表，基本都是业务库数据。每张表要求的数据存储状态都不一样。比如实际投放车辆数，需要用到历史和实时的所有数据，中间会减去未投放的车辆数。而投放状态是时刻变化的，实际使用车辆数需要从订单表中增量获取当天被骑行的车辆数，可用车辆数则要从投放车辆数中减去那些维修、被收车、缺电等状态的车辆。这些状态的数据库表又是不同的业务团队所产生的，整合在一起非常繁琐。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果用传统的实时数仓的模型，基于 Kafka+Flink 窗口+状态无法实现这一复杂逻辑。如果用 Spark+Hive 的方式，数据的及时性无法保证，线上 Apache Hadoop（以下简称 Hadoop） 集群压力会非常大，口径变更时修改也很复杂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述基于 StarRocks 搭建的数据链路，则解决了这些问题。对于能提前关联的数据，我们用 Flink SQL 打成大宽表入库，需要历史数据且状态时刻变化的数据全量从 Hive 导入 StarRocks，然后通过 Canal 抽取增量数据到 Kafka ，再导入 StarRocks 来更新状态。在最上层创建逻辑视图，通过调度平台定时计算输出到 ADS 层，供业务方使用。当需要口径做变更，或者查看不同维度的车辆指标时，我们只需新建一个逻辑视图即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如今在车辆方向的应用，我们提供小时粒度的数据、20 多种不同的指标，给业务运营提供了扎实的数据支撑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;113983&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;3&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;StarRocks “极速统一”落地&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;基于 StarRock&lt;/span&gt;&lt;span&gt;s 在上述场景的成功应用，我们对其他场景的数据链路也进行了调整。&lt;/span&gt;&lt;span&gt;目前 StarRocks 在数据中台的实时链路中应用非常广泛，已经是我们的重要基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大部分准实时、实时需求已接入这套体系。基于 StarRocks 的任务大概有 50 多个，提供了大概 150 多个指标、2T 多的数据。后续我们会将全部实时数据接入到 StarRocks，支撑实时数据分析、数据服务、指标展示、监控告警等方面的应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在接触并选用 StarRocks 之前，我们早期使用了很多组件：Druid、Kylin、ElasticSearch、Kudu、ClickHouse、Impala。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些组件的适用场景都不尽相同，语法以及能力也各有千秋。我们用 Druid 来预计算所有内部服务的埋点日志数据，但无法查看明细数据；用 Kudu 主键去重，来满足实时更新的业务数据去重需求，使用 Impala 或者 Presto 对外提供查询；用 ClickHouse 来存储实时埋点数据和业务数据，采用复杂语句来实现去重和窗口功能；用 Kylin 试点数据口径和维度相对固定的指标计算场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总体而言，组件比较多，使用也比较混乱，不仅数据存储分散，占用有限的机器资源，而且每个组件的语法完全不一样，学习成本高。另外，各组件都需要单独搭建性能监控报警体系，后期的升级维护困难，运维压力很大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过改造后，整个实时链路都接入到 StarRocks，StarRocks 成为我们大数据通用 OLAP 的重要底座。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从数据源头来看，目前有以下源头：离线的 Hive 数据，实时的 Kafka 数据，Flink-Connector 的数据，MySQL/HDFS 的数据。这些都能通过 StarRocks 原生的 Load 方式进行数据导入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在表的设计方面：&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;114645&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;115224&quot; data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在运维方面：&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;114645&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;115224&quot; data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot; data-width=&quot;100%&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对 FE，我们配置了 VIP 代理，保证查询请求的高可用，同时也保证查询请求负载均衡，不至于单节点承受高频次请求；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;目前使用的是社区版，我们自己实现了针对 FE、BE、Routine Load 任务的监控告警;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用 Grafana 搭建了指标监控大盘。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在性能方面：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;153&quot; data-ratio=&quot;0.9241379310344827&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC5kl11rY7nZILcoxnKmA4RibaGiaPzoVp7Rq23faopuiazJ8etwSjDJlMX2zVQoePzZX6fR2uoCohK5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;290&quot; data-width=&quot;181&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;154&quot; data-ratio=&quot;0.8742138364779874&quot; data-type=&quot;png&quot; data-w=&quot;318&quot; data-width=&quot;186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC5kl11rY7nZILcoxnKmA4Ribs79wbfwiclPPmm8TuHOKoOmvRb27YX3yRMCrFdnGmPCIbQAQgtnQQJQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;以前我们使用了很多不同类型的查询引擎，不断做加法，大多数时候都要忙于处理各种组件的异常。现在引入 StarRocks 后，不断做减法，最终统一查询引擎、降低维护成本、提高数据取用灵活性。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;113983&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;4&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;StarRocks 与内部平台的融合&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;StarRocks 现在也作为一个基础数据库，融合在了松果出行的数据分析平台和数据资产平台中。&lt;/span&gt;&lt;span&gt;在这些平台&lt;/span&gt;&lt;span&gt;中，作为工具的底层基础框架，StarRocks 为业务发挥着重要的支撑作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，在使用过程中我们也发现了一些小问题：&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;114645&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;115224&quot; data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;#04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;总结与规划&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;—&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;114645&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;使用 StarRocks 后，不仅我们前期的业务痛点得到了解决，实时 OLAP 分析的需求也被更好地满足。同时，将多组件收敛到 StarRocks，不仅满足了多样化的业务需求，也极大降低了使用和运维成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们将进一步优化 StarRocks 的使用性能和使用场景：&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;114645&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;115224&quot; data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot; data-width=&quot;100%&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;更多的离线业务从 Hive/Presto 迁移过来，支撑更多的离线业务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进一步收敛 OLAP 引擎，将 ClickHouse 的所有任务迁移到 StarRocks；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;充分利用 StarRocks 的优越性能进行多业务的多维分析；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;优化我们的表、任务，充分利用物化视图的能力；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;完善对 StarRocks 指标的监控；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将 StarRocks 嵌入更多的平台工具当中，使建表导数等更加智能化；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;探索实时标签在 StarRocks 中的运用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;作为 StarRocks 社区一份子，我们也将大力投入社区工作。最后非常感谢 StarRocks 社区团队的大力支持，期望 StarRocks 可以在“极速统一”的产品能力上持续快速进步！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;&lt;strong&gt;关于 StarRocks &lt;/strong&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;StarRocks 创立两年多来，一直专注打造世界顶级的新一代极速全场景 MPP 数据库，帮助企业建立“极速统一”的数据分析新范式，助力企业全面数字化经营。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当前已经帮助腾讯、携程、顺丰、Airbnb 、滴滴、京东、众安保险等超过 110 家大型用户构建了全新的数据分析能力，生产环境中稳定运行的 StarRocks 服务器数目达数千台。 &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2021 年 9 月，StarRocks 源代码开放，在 Github 上的星数已超过 3000 个。StarRocks 的全球社区飞速成长，至今已有超百位贡献者，社群用户突破 5000 人，吸引几十家国内外行业头部企业参与共建。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;241&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;243&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4287037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC46iceibkssic8z2ZtuI1VYGECjvUcqvKxU3mx3Y3rT8ia48c8o82XWGRGRIF2qodC9M60mWu2r1FgT4w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;2160&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;252&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4351851851851852&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC42JjC2oGVttbR45UnziaYXk8kutneUajW0YIiaqibgRnGFogtMTfJF5Fial1zTNQYj2s5aujgM6wpYmw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10683760683760683&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC42JjC2oGVttbR45UnziaYXkicZOmzAOtN3OMOqfcTawo6OhzzhgvpfPleYs1tHf6uclpt8cbMUaVsw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;“极速统一” 数据分析新范式：&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247485289&amp;amp;idx=1&amp;amp;sn=6f65b0361f79aa9ef22b7cd38eaa7af2&amp;amp;chksm=e9f1784dde86f15b5ae2a593a43945b003c61f2d60e762eb4341fe5e7a6146f9df6192101453&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;阿里云&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;阿里云&lt;/a&gt;    &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247485788&amp;amp;idx=1&amp;amp;sn=fd7f8f86d1a7ee02063a8ca7cba295cf&amp;amp;chksm=e9f17678de86ff6ed2af617780d227bf2b04df8f99c102df0acb507ae7373ec6ec6e8a31c200&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;众安&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;众安&lt;/a&gt;&lt;span&gt;   &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247484378&amp;amp;idx=1&amp;amp;sn=53ba8ffc20d185932c6eaac9cfa5aa62&amp;amp;chksm=e9f17cfede86f5e8c60d02e7c494208b0fc9aa15b0449172e93b1fc09224ea8616703b1620b1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;携程&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;携程&lt;/a&gt;    &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247485975&amp;amp;idx=1&amp;amp;sn=dc80115074f959e9f389a9f1199d7894&amp;amp;chksm=e9f17533de86fc25650bd4c190f845eaab588acf3d97c4709f41cd2b23370cc3a9d7b9afdef3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;马蜂窝&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;马蜂窝&lt;/a&gt;&lt;span&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247484926&amp;amp;idx=1&amp;amp;sn=09ceb7940091b9356609376747a36ac7&amp;amp;chksm=e9f17adade86f3cc3afa02f5b0ecc9bbbbc4072b56c27296eff80f6af815c8fd6c1af442a5be&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;信也科技&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247484613&amp;amp;idx=1&amp;amp;sn=7704c22b16a36851b2392f14ef7cda70&amp;amp;chksm=e9f17be1de86f2f765a2352b67a2ff49ea2c89d0940a3b27529cb18b78e5a51bcf8308a182dd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;小米&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;小米&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247485820&amp;amp;idx=1&amp;amp;sn=7aa47ec35feec64e49ea462fe7506864&amp;amp;chksm=e9f17658de86ff4e1bd61f12d70ee8b478cc0ecd8fa7860df72ce2b5dc4b8ac05c77235809d6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;理想汽车&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;理想汽车&lt;/a&gt;   &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247484870&amp;amp;idx=1&amp;amp;sn=74ab3350c6b7e86376c009b3ee6b5b98&amp;amp;chksm=e9f17ae2de86f3f45cc32c4ae153b61c57cdf6e66dd7b10ae9fb8ec689994598130257c43936&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;汽车之家&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;汽车之家&lt;/a&gt;   &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247484326&amp;amp;idx=1&amp;amp;sn=3e038503ce8a81a74728b50f676a35ec&amp;amp;chksm=e9f17c82de86f5949d4f5c0622efe4b69d65edf6b7faeddbe30d410dcd2e84a6c95249ad4ff7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;滴滴&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;滴滴&lt;span&gt;   &lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247485647&amp;amp;idx=1&amp;amp;sn=b9eddd4b269eb1545c144e8ad8ccfc27&amp;amp;chksm=e9f177ebde86fefdfb2a9d25729d5b7c4a3bd7ffe4da1d51297c4e5bb4a6a8bae93a6395880f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;华米&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;华米&lt;/a&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247484926&amp;amp;idx=1&amp;amp;sn=09ceb7940091b9356609376747a36ac7&amp;amp;chksm=e9f17adade86f3cc3afa02f5b0ecc9bbbbc4072b56c27296eff80f6af815c8fd6c1af442a5be&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;信也科技&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247485899&amp;amp;idx=1&amp;amp;sn=c8b13a6a6f9d0d59de1721a36f52c4cd&amp;amp;chksm=e9f176efde86fff974e81dfe2fb72a834528141a9b0f4a99f647b11c1a2e9001822b82ddbd1e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot; 360&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;360&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247486188&amp;amp;idx=1&amp;amp;sn=f495dcff3c1564d56afd206f1c387d18&amp;amp;chksm=e9f175c8de86fcde90a2c1e0e3d4a35150a7b0f68aedfa9b3715b2adc6b9069786d1b6253c99&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;酷家乐 &quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;酷家乐 &lt;/a&gt;   &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247486150&amp;amp;idx=1&amp;amp;sn=bc272d1174edb74233c584c1b7f970da&amp;amp;chksm=e9f175e2de86fcf4b78f09ce88ead3dc591e11edd11a3efafe74441591928d37c213b9871e7d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;波克城市&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;波克城市&lt;/a&gt;    &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247486170&amp;amp;idx=1&amp;amp;sn=bd5de60aa15f03a6972467c45c58bb9b&amp;amp;chksm=e9f175fede86fce8c2495df1d7f6f3096b70ec8ac69ee94e12f96f3e15c256a85a94c3e3c5f7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;欢聚集团&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;欢聚集团&lt;/a&gt;    &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247485710&amp;amp;idx=1&amp;amp;sn=7438bc119f8e0cac3f7535a7c34539d8&amp;amp;chksm=e9f1762ade86ff3cbd4f4bf45b4d422cee972f4cf646e6822591e9213fb064a3e3ed8a3912bb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;搜狐&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;搜狐&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247484971&amp;amp;idx=1&amp;amp;sn=8f7e7ec424335b81fb34f1da85efbf8f&amp;amp;chksm=e9f1790fde86f019016e67a8a820f866bcbffe484414fa93b403605f957874bb7450672bfc3d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;DMALL&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;DMALL&lt;/a&gt;&lt;span&gt;   &lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247484829&amp;amp;idx=1&amp;amp;sn=344fb330aac7d722a57a9591a82ca019&amp;amp;chksm=e9f17ab9de86f3af2e6d995b9ff8493c2a4d8e992d30e205904e3bd0ba88075061ea0158cb82&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;顺丰&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;顺丰&lt;/a&gt;  &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247486458&amp;amp;idx=1&amp;amp;sn=88058c480d5f163155bb885e3d1fbc2a&amp;amp;chksm=e9f174dede86fdc8defec71ca637bc2a5a9c87dd245c6bf9c51e11f2811fcdbcd507776ccd71&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot; 京东物流&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt; 京东物流&lt;/a&gt;   &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247485053&amp;amp;idx=1&amp;amp;sn=b9dfda8d35c27621c8012f3df54d9728&amp;amp;chksm=e9f17959de86f04f15f2d86a7df86e66192ee2cc38bdcafbc790c2a5149f96629fb79f511c76&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;京东到家&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;京东到家&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;StarRocks 技术内幕：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247485727&amp;amp;idx=1&amp;amp;sn=548ed6a15bd4b938cae8551500e3275d&amp;amp;chksm=e9f1763bde86ff2dcea5aacf2e1d8b9401cee6236b41571e241de74178cd856842e4e62fb48a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;大数据自动管理 &quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;大数据自动管理 &lt;/a&gt;   &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247485848&amp;amp;idx=1&amp;amp;sn=90e47d7a46eb120701d28b5acfbcc401&amp;amp;chksm=e9f176bcde86ffaaa0c4a3b686eea5b053ff286164cb9a27e85daf4e42bec08985f5a41975c3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot; 查询原理浅析&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt; &lt;span&gt;查询原理浅析&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTYxOTkxNQ==&amp;amp;mid=2247485927&amp;amp;idx=1&amp;amp;sn=56051046f9eb51a563c6c24eb22c9364&amp;amp;chksm=e9f176c3de86ffd5bab12e9b8657ad58c2b4b4d2741dc0f7de292c800e4ec23cb064955013d0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;实时更新与极速查询如何兼得&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;实时更新与极速查询如何兼得&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;👇 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;了解 StarRocks 产品详细信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ef37379867b108924d600d5a3b13a03b</guid>
<title>使用Go语言开发eBPF程序</title>
<link>https://toutiao.io/k/c8oeoo7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面的&lt;span&gt;《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyNzM0MDk0Mg==&amp;amp;mid=2247492847&amp;amp;idx=1&amp;amp;sn=7472210233cee735527f2cd880aab40d&amp;amp;chksm=e860030edf178a18700016e7898e88882b03d5dca033841731b7eaa5c35bf12027b6b76b6232&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;使用C语言从头开发一个Hello World级别的eBPF程序》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;使用C语言从头开发一个Hello World级别的eBPF程序》&lt;/a&gt;&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;一文中，我们详细说明了如何基于C语言和libbpf库从头开发一个eBPF程序(包括其用户态部分)。那篇文章是后续有关eBPF程序开发文章的基础，因为到目前为止，无论eBPF程序的用户态部分用什么语言开发，运行于内核态的eBPF程序内核态部分还是必须由C语言开发的。这样一来，其他编程语言只能拼一下如何让eBPF程序的用户态部分的开发更为简单了，Go语言也不例外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Go社区中，目前最为活跃的用于开发eBPF用户态部分的Go eBPF包莫过于cilium项目开源的&lt;span&gt;cilium/ebpf&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，cilium项目背后的&lt;span&gt;Isovalent公司&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;也是eBPF技术在云原生领域应用的主要推手之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们就来说说&lt;strong&gt;基于cilium/ebpf开发eBPF程序的套路&lt;/strong&gt;！&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-traceid=&quot;undefined&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;101_13694000&quot; data-appuin=&quot;3227340942&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:0,&amp;quot;pid&amp;quot;:&amp;quot;101_13694000&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3227340942&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;101_13694000&amp;quot;,&amp;quot;source_id&amp;quot;:2,&amp;quot;source_name&amp;quot;:&amp;quot;京东&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://img.zhls.qq.com/3/3c88eec690984b17b01468415f9b5d18.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;Go语言精进之路：从新手到高手的编程思想、方法和技巧 套装共2册&amp;quot;,&amp;quot;current_price&amp;quot;:10900,&amp;quot;first_category_id&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;appuin&amp;quot;:&amp;quot;3227340942&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;一. 探索cilium/ebpf项目示例&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cilium/ebpf项目借鉴了&lt;span&gt;libbpf-boostrap&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;的思路，通过代码生成与bpf程序内嵌的方式构建eBPF程序用户态部分。为了搞清楚基于cilium/ebpf开发ebpf程序的套路，我们先来探索一下cilium/ebpf项目提供的示例代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先来下载和看看ebpf的示例的结构。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ git &lt;span&gt;clone&lt;/span&gt; https://github.com/cilium/ebpf.git&lt;br/&gt;Cloning into &lt;span&gt;&#x27;ebpf&#x27;&lt;/span&gt;...&lt;br/&gt;remote: Enumerating objects: 7054, &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;remote: Counting objects: 100% (183/183), &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;remote: Compressing objects: 100% (112/112), &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;remote: Total 7054 (delta 91), reused 124 (delta 69), pack-reused 6871&lt;br/&gt;Receiving objects: 100% (7054/7054), 10.91 MiB | 265.00 KiB/s, &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;Resolving deltas: 100% (4871/4871), &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ebpf示例在examples目录下，我们以tracepoint_in_c为例看看其组织形式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$tree&lt;/span&gt; tracepoint_in_c&lt;br/&gt;tracepoint_in_c&lt;br/&gt;├── bpf_bpfeb.go&lt;br/&gt;├── bpf_bpfeb.o&lt;br/&gt;├── bpf_bpfel.go&lt;br/&gt;├── bpf_bpfel.o&lt;br/&gt;├── main.go&lt;br/&gt;└── tracepoint.c&lt;br/&gt;&lt;br/&gt;0 directories, 6 files&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据经验判断，这里面的tracepoint.c对应的是ebpf程序内核态部分，而main.go和bpf_bpfel.go/bpf_bpfeb.go则是ebpf程序用户态部分，至于bpf_bpfeb.o/bpf_bpfel.o应该是某种中间目标文件。通过readelf -a bpf_bpfeb.o查看该中间文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$readelf&lt;/span&gt; -a bpf_bpfeb.o&lt;br/&gt;ELF Header:&lt;br/&gt;  Magic:   7f 45 4c 46 02 02 01 00 00 00 00 00 00 00 00 00 &lt;br/&gt;  Class:                             ELF64&lt;br/&gt;  Data:                              2&lt;span&gt;&#x27;s complement, big endian&lt;br/&gt;  Version:                           1 (current)&lt;br/&gt;  OS/ABI:                            UNIX - System V&lt;br/&gt;  ABI Version:                       0&lt;br/&gt;  Type:                              REL (Relocatable file)&lt;br/&gt;  Machine:                           Linux BPF&lt;br/&gt;  Version:                           0x1&lt;br/&gt;  Entry point address:               0x0&lt;br/&gt;  Start of program headers:          0 (bytes into file)&lt;br/&gt;  Start of section headers:          1968 (bytes into file)&lt;br/&gt;  Flags:                             0x0&lt;br/&gt;  Size of this header:               64 (bytes)&lt;br/&gt;  Size of program headers:           0 (bytes)&lt;br/&gt;  Number of program headers:         0&lt;br/&gt;  Size of section headers:           64 (bytes)&lt;br/&gt;  Number of section headers:         13&lt;br/&gt;  Section header string table index: 1&lt;br/&gt;... ...&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到这是一个内含linux bpf字节码的elf文件(Machine: Linux BPF)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读了cilium/ebpf的相关文档，我搞明白了这几个文件的关系，用下面示意图呈现给大家：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.33671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cH6WzfQ94mYY6v7wXhOUtfXGUBHe1Bbb5rWZ8ibe64dbviag4GDCPZuQrekib4YvqtLnCbkncibKiaC3lsM4z8pqAcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ebpf程序的源码文件(比如图中tracepoint.c)经过bpf2go(cilium/ebpf提供的一个代码生成工具)被编译(bpf2go调用clang)为ebpf字节码文件bpf_bpfeb.o(大端)和bpf_bpfel.o(小端)，然后bpf2go会基于ebpf字节码文件生成bpf_bpfeb.go或bpf_bpfel.go，ebpf程序的字节码会以二进制数据的形式内嵌到这两个go源文件中，以bpf_bpfel.go为例，我们可以在其代码中找到下面内容(利用&lt;span&gt;go:embed特性&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;)：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//go:embed bpf_bpfel.o&lt;br/&gt;var _BpfBytes []byte&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main.go则是ebpf程序用户态部分的主程序，将main.go与bpf_bpfeb.go或bpf_bpfel.go之一一起编译就形成了ebpf程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了对cilium/ebpf项目示例的初步探索后，我们来构建ebpf示例代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;二. 构建ebpf示例代码&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cilium/ebpf提供了便利的构建脚本，我们只需在ebpf/examples下面执行&quot;make -C ..&quot;即可进行示例代码的构建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;make构建过程会基于quay.io/cilium/ebpf-builder镜像启动构建容器，不过在国内的童鞋需要像下面一样对Makefile内容做一丁点修改，增加GOPROXY环境变量，否则wall外的go module无法拉取：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$git&lt;/span&gt; diff ../Makefile&lt;br/&gt;diff --git a/Makefile b/Makefile&lt;br/&gt;index 3a1da88..d7b1712 100644&lt;br/&gt;--- a/Makefile&lt;br/&gt;+++ b/Makefile&lt;br/&gt;@@ -48,6 +48,7 @@ container-all:&lt;br/&gt;        &lt;span&gt;${CONTAINER_ENGINE}&lt;/span&gt; run --rm &lt;span&gt;${CONTAINER_RUN_ARGS}&lt;/span&gt; \&lt;br/&gt;                -v &lt;span&gt;&quot;&lt;span&gt;${REPODIR}&lt;/span&gt;&quot;&lt;/span&gt;:/ebpf -w /ebpf --env MAKEFLAGS \&lt;br/&gt;                --env CFLAGS=&lt;span&gt;&quot;-fdebug-prefix-map=/ebpf=.&quot;&lt;/span&gt; \&lt;br/&gt;+               --env GOPROXY=&lt;span&gt;&quot;https://goproxy.io&quot;&lt;/span&gt; \&lt;br/&gt;                --env HOME=&lt;span&gt;&quot;/tmp&quot;&lt;/span&gt; \&lt;br/&gt;                &lt;span&gt;&quot;&lt;span&gt;${IMAGE}&lt;/span&gt;:&lt;span&gt;${VERSION}&lt;/span&gt;&quot;&lt;/span&gt; \&lt;br/&gt;                $(MAKE) all&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这之后再执行构建就会顺利得到我们所要的结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ &lt;span&gt;cd&lt;/span&gt; examples&lt;br/&gt;$ make -C ..&lt;br/&gt;make: Entering directory &lt;span&gt;&#x27;/root/go/src/github.com/cilium/ebpf&#x27;&lt;/span&gt;&lt;br/&gt;docker run --rm  --user &lt;span&gt;&quot;0:0&quot;&lt;/span&gt; \&lt;br/&gt;    -v &lt;span&gt;&quot;/root/go/src/github.com/cilium/ebpf&quot;&lt;/span&gt;:/ebpf -w /ebpf --env MAKEFLAGS \&lt;br/&gt;    --env CFLAGS=&lt;span&gt;&quot;-fdebug-prefix-map=/ebpf=.&quot;&lt;/span&gt; \&lt;br/&gt;    --env GOPROXY=&lt;span&gt;&quot;https://goproxy.io&quot;&lt;/span&gt; \&lt;br/&gt;    --env HOME=&lt;span&gt;&quot;/tmp&quot;&lt;/span&gt; \&lt;br/&gt;    &lt;span&gt;&quot;quay.io/cilium/ebpf-builder:1648566014&quot;&lt;/span&gt; \&lt;br/&gt;    make all&lt;br/&gt;make: Entering directory &lt;span&gt;&#x27;/ebpf&#x27;&lt;/span&gt;&lt;br/&gt;find . -&lt;span&gt;type&lt;/span&gt; f -name &lt;span&gt;&quot;*.c&quot;&lt;/span&gt; | xargs clang-format -i&lt;br/&gt;go generate ./cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;&lt;br/&gt;go: downloading golang.org/x/sys v0.0.0-20210906170528-6f6e22806c34&lt;br/&gt;Compiled /ebpf/cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;/test_bpfel.o&lt;br/&gt;Stripped /ebpf/cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;/test_bpfel.o&lt;br/&gt;Wrote /ebpf/cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;/test_bpfel.go&lt;br/&gt;Compiled /ebpf/cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;/test_bpfeb.o&lt;br/&gt;Stripped /ebpf/cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;/test_bpfeb.o&lt;br/&gt;Wrote /ebpf/cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;/test_bpfeb.go&lt;br/&gt;go generate ./internal/sys&lt;br/&gt;enum AdjRoomMode&lt;br/&gt;enum AttachType&lt;br/&gt;enum Cmd&lt;br/&gt;enum FunctionId&lt;br/&gt;enum HdrStartOff&lt;br/&gt;enum LinkType&lt;br/&gt;enum MapType&lt;br/&gt;enum ProgType&lt;br/&gt;enum RetCode&lt;br/&gt;enum SkAction&lt;br/&gt;enum StackBuildIdStatus&lt;br/&gt;enum StatsType&lt;br/&gt;enum XdpAction&lt;br/&gt;struct BtfInfo&lt;br/&gt;... ...&lt;br/&gt;attr ProgRun&lt;br/&gt;attr RawTracepointOpen&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; examples/ &amp;amp;&amp;amp; go generate ./...&lt;br/&gt;go: downloading github.com/cilium/ebpf v0.8.2-0.20220424153111-6da9518107a8&lt;br/&gt;go: downloading golang.org/x/sys v0.0.0-20211001092434-39dca1131b70&lt;br/&gt;Compiled /ebpf/examples/cgroup_skb/bpf_bpfel.o&lt;br/&gt;Stripped /ebpf/examples/cgroup_skb/bpf_bpfel.o&lt;br/&gt;Wrote /ebpf/examples/cgroup_skb/bpf_bpfel.go&lt;br/&gt;Compiled /ebpf/examples/cgroup_skb/bpf_bpfeb.o&lt;br/&gt;Stripped /ebpf/examples/cgroup_skb/bpf_bpfeb.o&lt;br/&gt;Wrote /ebpf/examples/cgroup_skb/bpf_bpfeb.go&lt;br/&gt;Compiled /ebpf/examples/fentry/bpf_bpfeb.o&lt;br/&gt;Stripped /ebpf/examples/fentry/bpf_bpfeb.o&lt;br/&gt;Wrote /ebpf/examples/fentry/bpf_bpfeb.go&lt;br/&gt;Compiled /ebpf/examples/fentry/bpf_bpfel.o&lt;br/&gt;Stripped /ebpf/examples/fentry/bpf_bpfel.o&lt;br/&gt;Wrote /ebpf/examples/fentry/bpf_bpfel.go&lt;br/&gt;Compiled /ebpf/examples/kprobe/bpf_bpfel.o&lt;br/&gt;Stripped /ebpf/examples/kprobe/bpf_bpfel.o&lt;br/&gt;Wrote /ebpf/examples/kprobe/bpf_bpfel.go&lt;br/&gt;Stripped /ebpf/examples/uretprobe/bpf_bpfel_x86.o&lt;br/&gt;... ...&lt;br/&gt;Wrote /ebpf/examples/uretprobe/bpf_bpfel_x86.go&lt;br/&gt;ln -srf testdata/loader-clang-14-el.elf testdata/loader-el.elf&lt;br/&gt;ln -srf testdata/loader-clang-14-eb.elf testdata/loader-eb.elf&lt;br/&gt;make: Leaving directory &lt;span&gt;&#x27;/ebpf&#x27;&lt;/span&gt;&lt;br/&gt;make: Leaving directory &lt;span&gt;&#x27;/root/go/src/github.com/cilium/ebpf&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以uretprobe下面的ebpf为例，我们运行一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$go&lt;/span&gt; run -&lt;span&gt;exec&lt;/span&gt; sudo uretprobe/*.go&lt;br/&gt;2022/06/05 18:23:23 Listening &lt;span&gt;for&lt;/span&gt; events..&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开一个新的terminal，然后在用户home目录下执行vi .bashrc。在上面的uretprobe程序的执行窗口我们能看到：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2022/06/05 18:24:34 Listening &lt;span&gt;for&lt;/span&gt; events..&lt;br/&gt;2022/06/05 18:24:42 /bin/bash:readline &lt;span&gt;return&lt;/span&gt; value: vi .bashrc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就表明uretprobe下面的ebpf程序如预期地执行了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;三. 使用cilium/ebpf为前文的Hello World eBPF程序开发用户态部分&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了对cilium/ebpf示例程序的初步了解，下面我们就来为前面的&lt;span&gt;《使用C语言从头开发一个Hello World级别的eBPF程序》&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;一文中的那个helloworld ebpf程序开发用户态部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾一下那个hello world ebpf程序的C源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// github.com/bigwhite/experiments/tree/master/ebpf-examples/helloworld-go/helloworld.bpf.c&lt;br/&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;bpf/bpf_helpers.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;SEC(&lt;span&gt;&quot;tracepoint/syscalls/sys_enter_execve&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;int bpf_prog(void *ctx) {&lt;br/&gt;  char msg[] = &lt;span&gt;&quot;Hello, World!&quot;&lt;/span&gt;;&lt;br/&gt;  bpf_printk(&lt;span&gt;&quot;invoke bpf_prog: %s\n&quot;&lt;/span&gt;, msg);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; 0;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;char LICENSE[] SEC(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;Dual BSD/GPL&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当这个ebpf程序被加载到内核中后，每当execve这个系统调用被执行，该ebpf程序都会被调用一次，我们就会在/sys/kernel/debug/tracing/trace_pipe中看到对应的日志输出。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;1. 使用bpf2go将ebpf核心态程序转换为Go代码&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据我们在前面探索cilium/ebpf示例程序时所得到的“套路”，我们接下来第一个要做的就是将helloworld.bpf.c转换为Go代码文件，这一转换过程不可缺少的工具就是cilium/ebpf提供的bpf2go工具，我们先来安装一下该工具：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$go&lt;/span&gt; install github.com/cilium/ebpf/cmd/bpf2go@latest&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们可以直接使用bpf2go工具将helloworld.ebpf.c转换为对应的go源文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$GOPACKAGE&lt;/span&gt;=main bpf2go -cc clang-10 -cflags &lt;span&gt;&#x27;-O2 -g -Wall -Werror&#x27;&lt;/span&gt; -target bpfel,bpfeb bpf helloworld.bpf.c -- -I /home/tonybai/&lt;span&gt;test&lt;/span&gt;/ebpf/libbpf/include/uapi -I /usr/&lt;span&gt;local&lt;/span&gt;/bpf/include -idirafter /usr/&lt;span&gt;local&lt;/span&gt;/include -idirafter /usr/lib/llvm-10/lib/clang/10.0.0/include -idirafter /usr/include/x86_64-linux-gnu -idirafter /usr/include&lt;br/&gt;&lt;br/&gt;Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o&lt;br/&gt;Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o&lt;br/&gt;Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.go&lt;br/&gt;Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o&lt;br/&gt;Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o&lt;br/&gt;Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这里有一个问题，那就是bpf2go命令行后面的一系列提供给clang编译器的头文件引用路径参考了&lt;span&gt;《使用C语言从头开发一个Hello World级别的eBPF程序》&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;一文中的Makefile。如果按照这些头文件路径来引用，虽然bpf2go转换可以成功，但是我们需要依赖并安装libbpf这个库，这显然不是我们想要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cilium/ebpf在examples中提供了一个headers目录，这个目录中包含了开发ebpf程序用户态部分所需的所有头文件，我们使用它作为我们的头文件引用路径。不过要想基于这个headers目录构建ebpf，我们需要将helloworld.bpf.c中的原头文件include语句由：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;bpf/bpf_helpers.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#include &quot;common.h&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们再来执行bpf2go工具进行转换：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$GOPACKAGE&lt;/span&gt;=main bpf2go -cc clang-10 -cflags &lt;span&gt;&#x27;-O2 -g -Wall -Werror&#x27;&lt;/span&gt; -target bpfel,bpfeb bpf helloworld.bpf.c -- -I /home/tonybai/go/src/github.com/cilium/ebpf/examples/headers&lt;br/&gt;&lt;br/&gt;Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o&lt;br/&gt;Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o&lt;br/&gt;Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.go&lt;br/&gt;Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o&lt;br/&gt;Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o&lt;br/&gt;Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到bpf2go顺利生成ebpf字节码与对应的Go源文件。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2. 构建helloworld ebpf程序用户态部分&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是参考cilium/ebpf示例而构建的helloword ebpf程序用户态部分的main.go源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// github.com/bigwhite/experiments/ebpf-examples/helloworld-go/main.go&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;os/signal&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;syscall&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/cilium/ebpf/link&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/cilium/ebpf/rlimit&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; stopper := make(chan os.Signal, 1)&lt;br/&gt; signal.Notify(stopper, os.Interrupt, syscall.SIGTERM)&lt;br/&gt;&lt;br/&gt; // Allow the current process to lock memory &lt;span&gt;for&lt;/span&gt; eBPF resources.&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := rlimit.RemoveMemlock(); err != nil {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; // Load pre-compiled programs and maps into the kernel.&lt;br/&gt; objs := bpfObjects{}&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := loadBpfObjects(&amp;amp;objs, nil); err != nil {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;loading objects: %s&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt; defer objs.Close()&lt;br/&gt;&lt;br/&gt; //SEC(&lt;span&gt;&quot;tracepoint/syscalls/sys_enter_execve&quot;&lt;/span&gt;)&lt;br/&gt; // attach to xxx&lt;br/&gt; kp, err := link.Tracepoint(&lt;span&gt;&quot;syscalls&quot;&lt;/span&gt;, &lt;span&gt;&quot;sys_enter_execve&quot;&lt;/span&gt;, objs.BpfProg, nil)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;opening tracepoint: %s&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt; defer kp.Close()&lt;br/&gt;&lt;br/&gt; log.Printf(&lt;span&gt;&quot;Successfully started! Please run \&quot;sudo cat /sys/kernel/debug/tracing/trace_pipe\&quot; to see output of the BPF programs\n&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; // Wait &lt;span&gt;for&lt;/span&gt; a signal and close the perf reader,&lt;br/&gt; // &lt;span&gt;which&lt;/span&gt; will interrupt rd.Read() and make the program &lt;span&gt;exit&lt;/span&gt;.&lt;br/&gt; &amp;lt;-stopper&lt;br/&gt; log.Println(&lt;span&gt;&quot;Received signal, exiting program..&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道一个ebpf程序有几个关键组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ebpf程序数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;map：用于用户态与内核态的数据交互&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;挂接点(attach point)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;span&gt;cilium/ebpf架构&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;的说明，ebpf包将前两部分抽象为了一个数据结构bpfObjects：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.go&lt;br/&gt;&lt;br/&gt;// bpfObjects contains all objects after they have been loaded into the kernel.&lt;br/&gt;//&lt;br/&gt;// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; bpfObjects struct {&lt;br/&gt;    bpfPrograms&lt;br/&gt;    bpfMaps&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到，main函数通过生成的loadBpfObjects函数将ebpf程序加载到内核，并填充bpfObjects结构，一旦加载bpf程序成功，后续我们便可以使用bpfObjects结构中的字段来完成其余操作，比如通过link包的函数将bpf程序与目标挂节点对接在一起(如文中的link.Tracepoint函数），这样挂接后，bpf才能在对应的事件发生后被回调执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面编译执行一下该helloworld示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$go&lt;/span&gt; run -&lt;span&gt;exec&lt;/span&gt; sudo main.go bpf_bpfel.go&lt;br/&gt;[sudo] password &lt;span&gt;for&lt;/span&gt; tonybai: &lt;br/&gt;2022/06/05 14:12:40 Successfully started! Please run &lt;span&gt;&quot;sudo cat /sys/kernel/debug/tracing/trace_pipe&quot;&lt;/span&gt; to see output of the BPF programs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后新打开一个窗口，执行sudo cat /sys/kernel/debug/tracing/trace_pipe，当execve被调用时，我们就能看到类似下面的日志输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;...&amp;gt;-551077  [000] .... 6062226.208943: 0: invoke bpf_prog: Hello, World!&lt;br/&gt;&amp;lt;...&amp;gt;-551077  [000] .... 6062226.209098: 0: invoke bpf_prog: Hello, World!&lt;br/&gt;&amp;lt;...&amp;gt;-551079  [007] .... 6062226.215421: 0: invoke bpf_prog: Hello, World!&lt;br/&gt;&amp;lt;...&amp;gt;-551079  [007] .... 6062226.215578: 0: invoke bpf_prog: Hello, World!&lt;br/&gt;&amp;lt;...&amp;gt;-554756  [007] .... 6063476.785212: 0: invoke bpf_prog: Hello, World!&lt;br/&gt;&amp;lt;...&amp;gt;-554756  [007] .... 6063476.785378: 0: invoke bpf_prog: Hello, World!&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3. 使用go generate来驱动bpf2go的转换&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在生成代码方面，Go工具链原生提供了go generate工具，cilium/ebpf的examples中也是利用go generate来驱动bpf2go将bpf程序转换为Go源文件的，这里我们也来做一下改造。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们在main.go的main函数上面增加一行go:generate指示语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// github.com/bigwhite/experiments/ebpf-examples/helloworld-go/main.go&lt;br/&gt;&lt;br/&gt;// &lt;span&gt;$BPF_CLANG&lt;/span&gt;, &lt;span&gt;$BPF_CFLAGS&lt;/span&gt; and &lt;span&gt;$BPF_HEADERS&lt;/span&gt; are &lt;span&gt;set&lt;/span&gt; by the Makefile.&lt;br/&gt;//go:generate bpf2go -cc &lt;span&gt;$BPF_CLANG&lt;/span&gt; -cflags &lt;span&gt;$BPF_CFLAGS&lt;/span&gt; -target bpfel,bpfeb bpf helloworld.bpf.c -- -I &lt;span&gt;$BPF_HEADERS&lt;/span&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    stopper := make(chan os.Signal,  1)&lt;br/&gt;    ... ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样当我们显式执行go generate语句时，go generate会扫描到该指示语句，并执行后面的命令。这里使用了几个变量，变量是定义在Makefile中的。当然如果你不想使用Makefile，也可以将变量替换为相应的值。这里我们使用Makefile，下面是Makefile的内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// github.com/bigwhite/experiments/ebpf-examples/helloworld-go/Makefile&lt;br/&gt;&lt;br/&gt;CLANG ?= clang-10&lt;br/&gt;CFLAGS ?= -O2 -g -Wall -Werror&lt;br/&gt;&lt;br/&gt;LIBEBPF_TOP = /home/tonybai/go/src/github.com/cilium/ebpf&lt;br/&gt;EXAMPLES_HEADERS = $(LIBEBPF_TOP)/examples/headers&lt;br/&gt;&lt;br/&gt;all: generate&lt;br/&gt;&lt;br/&gt;generate: &lt;span&gt;export&lt;/span&gt; BPF_CLANG=$(CLANG)&lt;br/&gt;generate: &lt;span&gt;export&lt;/span&gt; BPF_CFLAGS=$(CFLAGS)&lt;br/&gt;generate: &lt;span&gt;export&lt;/span&gt; BPF_HEADERS=$(EXAMPLES_HEADERS)&lt;br/&gt;generate:&lt;br/&gt; go generate ./...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了该Makefile后，我们执行make命令便可以执行bpf2go对bpf程序的转换：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$make&lt;/span&gt;&lt;br/&gt;go generate ./...&lt;br/&gt;Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o&lt;br/&gt;Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o&lt;br/&gt;Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.go&lt;br/&gt;Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o&lt;br/&gt;Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o&lt;br/&gt;Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;四. 小结&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们讲解了如何基于cilium/ebpf包来开发ebpf的用户态部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ebpf借鉴了libbpf的思路，通过生成代码与数据内嵌的方式来构建ebpf的用户态部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ebpf提供了bpf2go工具，可以将bpf的C源码转换为相应的go源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ebpf将bpf程序抽象为bpfObjects，通过生成的loadBpfObjects完成bpf程序加载到内核的过程，然后利用ebpf库提供的诸如link之类的包实现ebpf与内核事件的关联。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ebpf包的玩法还有很多，这一篇仅仅是为了打好基础，在后续文章中，我们还会针对各种类型的bpf程序做进一步学习和说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文代码可以在&lt;span&gt;这里&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;下载。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;无. 参考资料&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用Go语言管理和分发ebpf程序&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt; - https://www.ebpf.top/post/ebpf_go/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;A Pure Go eBPF library&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt; - https://lpc.events/event/4/contributions/449/attachments/239/529/A_pure_Go_eBPF_library.pdf&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;cilium ebpf library architecture&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt; - https://github.com/cilium/ebpf/blob/master/ARCHITECTURE.md&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“Gopher部落”知识星球&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;旨在打造一个精品Go学习和进阶社群！高品质首发Go技术文章，“三天”首发阅读权，每年两期Go语言发展现状分析，每天提前1小时阅读到新鲜的Gopher日报，网课、技术专栏、图书内容前瞻，六小时内必答保证等满足你关于Go语言生态的所有需求！2022年，Gopher部落全面改版，将持续分享Go语言与Go应用领域的知识、技巧与实践，并增加诸多互动形式。欢迎大家加入！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.247167868177137&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cH6WzfQ94mb54jsFJZ3Knmz8obUsf3PBIMyZScLjHJSVL4jnaGBSFYZNhRQEwdUoGsAISHfVKfCHhWPic8yY0Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;971&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6484620213433773&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cH6WzfQ94mYKSeNd014VMtNhYulia0OHrHVoyrVYb2JvBa5ycFaeDfscQdubicnZkxB6je42bo3J4cZcx0FticLmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1593&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48884976525821594&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cH6WzfQ94mb54jsFJZ3Knmz8obUsf3PBShthmdSw5E01TcYmUReGkj0BWpxHak1HlnlzHvLmKax53YSGr7aNlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1704&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Gopher Daily(Gopher每日新闻)归档仓库 - https://github.com/bigwhite/gopherdaily&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的联系方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;微博：https://weibo.com/bigwhite20xx&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;博客：tonybai.com&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;github: https://github.com/bigwhite&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3436123348017621&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cH6WzfQ94mb54jsFJZ3Knmz8obUsf3PBrSoqeMvoWCticN2cpU64fJ0FYQdXJhP7ia7WRh8628uOAsQYeE2NibRRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1816&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;商务合作方式：撰稿、出书、培训、在线课程、合伙创业、咨询、广告合作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;p&gt;《使用C语言从头开发一个Hello World级别的eBPF程序》: &lt;em&gt;https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;p&gt;cilium/ebpf: &lt;em&gt;https://github.com/cilium/ebpf/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3] &lt;/span&gt;&lt;p&gt;Isovalent公司: &lt;em&gt;https://isovalent.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;p&gt;libbpf-boostrap: &lt;em&gt;https://github.com/libbpf/libbpf-bootstrap&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5] &lt;/span&gt;&lt;p&gt;go:embed特性: &lt;em&gt;https://tonybai.com/2021/02/25/some-changes-in-go-1-16&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6] &lt;/span&gt;&lt;p&gt;《使用C语言从头开发一个Hello World级别的eBPF程序》: &lt;em&gt;https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7] &lt;/span&gt;&lt;p&gt;《使用C语言从头开发一个Hello World级别的eBPF程序》: &lt;em&gt;https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8] &lt;/span&gt;&lt;p&gt;cilium/ebpf架构: &lt;em&gt;https://github.com/cilium/ebpf/blob/master/ARCHITECTURE.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9] &lt;/span&gt;&lt;p&gt;这里: &lt;em&gt;https://github.com/bigwhite/experiments/tree/master/ebpf-examples/helloworld-go&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10] &lt;/span&gt;&lt;p&gt;使用Go语言管理和分发ebpf程序: &lt;em&gt;https://www.ebpf.top/post/ebpf_go/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11] &lt;/span&gt;&lt;p&gt;A Pure Go eBPF library: &lt;em&gt;https://lpc.events/event/4/contributions/449/attachments/239/529/A_pure_Go_eBPF_library.pdf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12] &lt;/span&gt;&lt;p&gt;cilium ebpf library architecture: &lt;em&gt;https://github.com/cilium/ebpf/blob/master/ARCHITECTURE.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13] &lt;/span&gt;&lt;p&gt;“Gopher部落”知识星球: &lt;em&gt;https://wx.zsxq.com/dweb2/index/group/51284458844544&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>