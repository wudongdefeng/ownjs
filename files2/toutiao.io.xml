<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e9e5cf1b3cef89e3768c589dbe75ff8d</guid>
<title>项目经理必备的 25 张管理分析卡</title>
<link>https://toutiao.io/k/9grr194</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content              autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;在做项目管理时，层出不穷的问题需要项目经理作出各种决策和分析，以便推动问题解决。&lt;/span&gt;&lt;span&gt;如果项目经理能够掌握并灵活使用以下这25个管理分析卡片，那么分析和解决问题的效率都会大大提高——&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2I5YGDZcaQ9mthAMGYYAXib9Lgd0h2KM7OcywricqRZ17FFORwf69hoqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;决策&lt;/span&gt;&lt;span&gt;树是在已知各种情况发生概率的基础上，通过构成决策树来求取净现值的期望值大于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2u9iaMcibsvR2bDVjWGb12mw2l43UUassh8uic2nNpyLz9XicDPoUtkd3IA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;鱼骨图，帮助发现问题根本原因的分析方法，问题或缺陷（即后果）标在“鱼头”处，在鱼骨上长出鱼刺，上面按出现机会多寡列出产生问题额可能原因，有助于说明各个原因是如何影响后果的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia26HdRRDroqaQKlQwt4zxmDGrkJHFAnzkg10DOp0JTBHGkGpNKFlkFEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;DCA&lt;/span&gt;&lt;span&gt;循环是美国质量管理专家休哈特博士首先提出的，由戴明采纳、宣传并获得普及，所以又叫作“戴明环”。全面质量管理的思想基础和方法依据就是PDCA循环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2rZBCNEGDuIGkwhmYiaYYgAfqoL4umRRulqay51GsHHmGBJIgZ3NiaickQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GREP模型是进行组织内环境分析的有效工具，是分析企业竞争优势的内生战略分析法，即将企业的战略分为四个部分构成：治理结构、资源、企业家、产品或服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2yA08hZE9GN6WswictRiczZXEvas5viaCzUl6saMXeD6vCedNYrpXjlXwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;麦肯锡7S模型指出，企业在发展过程中必须全面的考虑各方面的情况，包括结构（structure）、制度（system）、风格（style）、员工（staff）、技能（skill）、战略（strategy）、共同的价值观（shared value）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2qiblA8icP4wiaYSb07RKdicU72ibF4j3ibl3e9RNWLN3OKFxRbp3WnFA4DAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;行业的生命周期指行业从出现到完全退出社会经济活动所经历的时间。行业的生命周期曲线忽略了具体的产品型号、质量、规格等差异，仅从整个行业的角度考虑问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2AXyC7prIb3z4AgMs5PrrOdGIgIDeQwXsfJCLvLKyyUCPgd7Ts868MQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SWOT分析就是基于内外部竞争环境和竞争条件下的态势分析，通过这种方法，可以对研究对象所处的情境进行全面、系统、准确的研究，从而根据研究结果制定相应的发展战略、计划以及对策等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2prUc5YwrmFuyoicnOgMPdddGRjDptfPcaFwptRiaUd3uL7dU7ls9iafjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即&lt;/span&gt;&lt;span&gt;目标与关键成果法，是一套明确和跟踪目标极其完成情况的工作方法，旨在确保员工共同工作，并集中精力做出可衡量的贡献。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2YHfwc4GoJHbnnKyN6FZ9sbFGaXwfclzuclqVb5SCT2WDDicaNMIdS7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SCQA即情景（Situation）、冲突（Complication）、问题（Question）、答案（Answer），它能够引导你站在消费者的角度考虑问题，提升消费者的兴趣和接受意愿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2hWcyPicLP1UHIrDm0lT5TMSh2MyfXnXG9dIJqFkuiaibo388oEfUv7FvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;MECE”是对于一个重大的议题，能够做到不重叠、不遗漏的分类，而且能够借此有效把握问题的核心，最终有效解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2sQTNYUlGoJJUTK4AOKSouLTicshribOlPYAubWPCS9iaiaP7XYUTcPu0jw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通用矩阵法可以根据事业单位在市场上的实力和所在时长的吸引力对这些事业单位进行评估，也可以表述一个公司的事业单位组合判断其强项和弱点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2M4kkYnMHdUVOUbj1oTghicklxCp0WRYTYNn0tLENxzxC0LTcgBclic9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;波士顿矩阵认为，一般决定产品结构的基本因素有两个：即市场引力与企业实力，其中最主要的&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;反映市场引力的综合指标——销售增长率，这是决定企业产品结构是否合理的外在因素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2iaLeVZ13ZXvElg6R7uAEkpGiboM5YGpFsI7waiaflgGGEvU80aHgND7OA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;波特的五力模型由迈克尔·波特提出，他认为行业中存在决定竞争规模和程度的五种力量，这五种力量综合起来影响着产业吸引力和现有企业的竞争战略决策。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2hiaWx0Lg7dKlbaybW1r8aDgoyjR334ozCf2sEZtoGRlQZ1CtEO3rVSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一种在企业竞争力“资源观”的观照下对企业内部的静态属性和外部的动态属性做系统分析的工具，从而对企业目前的竞争力有全面的认识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2GHCL6sQ9VWVRqGoGAfXs34IcShldtLptLr2t7CugvgLzSThkM8FUPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种方法把企业内外价值增加的活动分为基本活动和支持性活动，实际上只有某些特定的活动才真正创造价值，这就是价值链上的“战略环节”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2Zf2A3fN3yYxA65iakCsBfy7k9voiakDAxUaIohkUMTAnyFOibpFIs7Xyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是对企业经营状况进行系统分析的一种有效方法，从经营收益性、安全性、流动性、生产性、成长性等五个方面分析企业的经营成果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia29iaqraTQ0gV6KYct6h0AD070V0Bf4QV630L9ZlFebwl6kwHFhDID4wQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2zVfq6lljb5A6w6vAMIzQHHickU64O3JuTCRhX6e8DAd0VIzWGWHfAFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;战略地位与行动评价矩阵主要分析企业外部环境及企业应该采用的战略组合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2Yeg19Eb7nJSl39ib4bw6MdyjvO4iat8G9J3ibH7sRfbFBFl2ZIElvichdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关键路径是指设计中从输入到输出经过的延时最长的逻辑路径，优化关键路径是一种提高工作速度的有效方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2I5byA6JE7k28eu2eSJmXczG8BJHbiaNdVuZIHklUXWBjYYp9ORPu4icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5W2H分析法又叫七问分析法，简单方便、易于使用，被广泛用于企业管理和技术活动，对于决策和执行性的活动措施也非常有帮助，更有助于弥补考虑问题的疏漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2Le61N3UH6viboREMhefSGDCd5ucbhiabNEE0KMEV6vdOjKH6wv9Y791Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直方图又称”质量分布图“，是一种统计报告图，一般用横轴表示数据类型，纵轴表示分布情况。通过直方图对所收集的貌似无序的数据进行处理，可以反映出产品质量的分布情况，判断和预测产品质量及不合格率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2aEqicI3qrK3eIYkHaibLWtVnLLDUBkQ4rWGtPIDpI4udyByibJbu3KBbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RACI是一个相对直观的模型，用以明确组织变革过程中的各个角色及其相关责任，分配个每项工作的资源可以是个人或小组，项目经理也可根据项目需要，选择“领导”或“资源”等适用词汇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2hLU2MWAgUdAIuwYAyY0DicN0hwD4U030TmvsBOqia9l11PF5F9UI833w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即目标管理原则，这是使管理者的工作由被动变主动的一个很好的手段，不但能让员工更明确高效的工作，还能保证绩效考核的公平、公正与公开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2QzjkDXZMicSCD7kib2IlTU8icg78btiaCP5QRXojXApIVuXyRIxy8knVbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该理论&lt;/span&gt;&lt;span&gt;由&lt;/span&gt;&lt;span&gt;日本战略研究的领军人物大前研一提出，他强调成功的战略有三个关键因素，分别是公司自身、顾客和竞争者，在制定任何经营战略时，都必须考虑这三个因素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsnf5hwK5sKqgM3FfiaNHicia2rLviaQR0y49jNqsjT6SiaLLlnoGt6V5pfUeh42c7KJXPI8Cz260pInhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;PEST分析是指对宏观环境的分析，P是政治（Politics）、E是经济（Economy）、S是社会（Society）、T是技术（Technology）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;◆◆◆&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上就是比较常用的25张种管理分析卡片，要想让这些方法发挥出最大的效果，关键在于项目经理能否灵活使用，我们建议大家可以收藏文章或把图片保存下来，方便随时查阅学习哦&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;-THE END-&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;38806&quot;&gt;&lt;section&gt;&lt;section data-bcless=&quot;darken&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;近期热文&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NTE3NTgyNA==&amp;amp;mid=2650943423&amp;amp;idx=1&amp;amp;sn=6f51525df240db7b83df8f4393f92d40&amp;amp;chksm=f157d9c0c62050d6768c202217aae2f50dfdf7d466b5b7641ff69d962ceab59523dd586385ac&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;能做项目经理的个个都是人才&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;能做项目经理的个个都是人才&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NTE3NTgyNA==&amp;amp;mid=2650943099&amp;amp;idx=1&amp;amp;sn=a96b8ce5065ea9037d105eb973862efa&amp;amp;chksm=f157d804c6205112227406612f1f79dfe2a6207db6796364e72fe6e56b8f69ee874aa0b576d4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;小心，别让敏捷，搞垮你的团队！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;小心，别让敏捷，搞垮你的团队！&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NTE3NTgyNA==&amp;amp;mid=2650943046&amp;amp;idx=1&amp;amp;sn=505e7946f10263e39a8bd4770cec55df&amp;amp;chksm=f157d839c620512faaeb329dd657d9c05802be5aa6416064b02cc396da93ced170f6fcdeacf2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PM可收藏，华为内部【流程管理体系】详解&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;PM可收藏，华为内部【流程管理体系】详解&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NTE3NTgyNA==&amp;amp;mid=2650942725&amp;amp;idx=1&amp;amp;sn=f0c22c850b119832796c2a46282e280c&amp;amp;chksm=f157db7ac620526cf4663288863dc72f1197f6fed734147852d2708a94fc8c5e92e2a66d22a7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;项目经理长点心吧，小心办公室里的任何人！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;项目经理长点心吧，小心办公室里的任何人！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI2NTE3NTgyNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EKK4IJyFJIsNhx9CkDnx7PsAXGw6oHDUq1cpFKtAuEFWyWgON8W5BU7CHKibM5Y8VgDSOHaYSw8ibEC4UXJ7WCmA/0?wx_fmt=png&quot; data-nickname=&quot;PM圈子&quot; data-alias=&quot;pm1178&quot; data-signature=&quot;洞察150W项目经理的苦与乐&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ae27bdd50b818791e6465a5b7a44fe5</guid>
<title>GPT-4 加持，GitHub Copilot X：AI 赋能的开发</title>
<link>https://toutiao.io/k/pt1unof</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//github.blog/2023-03-22-github-copilot-x-the-ai-powered-developer-experience/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-text=&quot;GitHub Copilot X: The AI-powered developer experience | The GitHub Blog&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;h2&gt;GitHub Copilot X&lt;/h2&gt;&lt;p data-pid=&quot;7je33TQF&quot;&gt;虽然 2021 年发布的 Codex API 已不再更新，作为产品的 GtiHub Copilot 还将继续进化，并利用 GPT-4 支持新特性。&lt;/p&gt;&lt;p data-pid=&quot;cKYlcYBy&quot;&gt;GitHub Copilot 正在尝试带来聊天和语音交互，支持拉动请求（Pull Request），回答关于文档的问题，并采用 OpenAI 的 GPT-4 以获得更个性化的开发者体验，即四项正在进行预览的特性：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;U79NCiKb&quot;&gt;&lt;b&gt;GitHub Copilot Chat&lt;/b&gt;：为编辑器带来了一个聊天界面，专注于开发人员的场景，并与 VS Code 和 Visual Studio 进行了原生整合。这远比建议代码的作用要大得多。GitHub Copilot Chat 不仅仅是一个聊天窗口。它能识别开发者输入的代码，显示的错误信息，并深入嵌入到 IDE 中。开发者可以得到深入的分析和解释，了解代码块要做什么，生成单元测试，甚至得到对错误的建议修复。&lt;/li&gt;&lt;li data-pid=&quot;71vpKQml&quot;&gt;&lt;b&gt;Copilot for Pull Requests&lt;/b&gt;：人工智能生成的拉动请求描述（descriptions for Pull Request）的技术预览。这项新功能由 OpenAI 的新 GPT-4 模型驱动，并通过组织管理员和个人仓库所有者可以安装的 GitHub 应用程序，在拉动请求描述中增加了对 AI 驱动的标签的支持。这些标签是由 GitHub Copilot 根据更改的代码自动填写的。然后，开发人员可以审查或修改建议的描述。&lt;/li&gt;&lt;li data-pid=&quot;0rQs-xfe&quot;&gt;&lt;b&gt;Copilot for Docs&lt;/b&gt;：使用聊天界面为用户提供人工智能生成的关于文档的问答，包括开发者关于他们正在使用的语言、框架和技术的问题。GitHub 从 React、Azure Docs 和 MDN的文档开始，因此可以与这些项目的开发者和用户一起快速学习和迭代。&lt;/li&gt;&lt;li data-pid=&quot;s9RT3Nr8&quot;&gt;&lt;b&gt;Copilot for the command line interface (CLI)&lt;/b&gt;：除了编辑器和 pull request 之外，终端是开发者花费时间最多的地方。但即使是最熟练的开发者也需要翻阅许多页面来记住许多命令的精确语法。GitHub Copilot CLI 可以组成命令和循环，并抛出晦涩的查找标志来满足你的查询。&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h2&gt;GitHub Next&lt;/h2&gt;&lt;p data-pid=&quot;BalxUswz&quot;&gt;现在，这几项功能提供 waitlist 可加入。更多的 GitHub 技术预览还可以在以下网页找到。&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//githubnext.com/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-46501e97975fe3d9a191fb745511b112_180x120.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;630&quot; data-text=&quot;GitHub Next&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d3f9c133f84d8dcb4802f7ecf7742731</guid>
<title>时区处理与东八区的程序员们</title>
<link>https://toutiao.io/k/2nvc6me</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content              autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;在和前端同学联调的过程中，我们通常会遇到与时间有关的场景：为什么传过来的时间落库的时候总是1970年？为什么相同的时间戳在不同的区域里转换成的时间字符串不一样？为什么不同的转换方法换成的结果一会是GMT，一会是UTC？&lt;/p&gt;&lt;p&gt;时间，这个在开发中不起眼的一环，却又往往会让很多开发者在遇到时犹豫不决。&lt;/p&gt;&lt;p&gt;在本文开始之前，先抛出一个问题：在日常的业务场景中，什么场景使用北京时间？什么场景使用本地时间？&lt;/p&gt;&lt;h2&gt;GMT与UTC&lt;/h2&gt;&lt;p&gt;我们先来复习一下以前的地理知识：&lt;/p&gt;&lt;p&gt;我们知道，地球分为24 个时区，一个时区的范围是十五个经度，地球又分东西半球，东西半球各占十二个时区；每个时区相差一个小时，最多相差24小时，也就是一天。&lt;/p&gt;&lt;p&gt;凡向西走，每过一个时区，时间要慢一个小时，就要把表拨慢1小时（就是说你所在的位置是两点，向西一个时区就减去一个小时，也就是一点）；凡向东走，每过一个时区，时间要快一个小时，就要把表拨快1小时（比如1点拨到2点）。&lt;/p&gt;&lt;p&gt;而这一切的起点，就在英国伦敦，那里有一条世界上著名的线，叫&lt;strong&gt;&lt;span&gt;本初子午线&lt;/span&gt;&lt;/strong&gt;，是&lt;strong&gt;人类世界计算时间的起点(时区的划分)以及经度的起点&lt;/strong&gt;。而这条线的划定是由格林尼治天文台确定的，因此格林尼治天文台所在的地方叫零时区。零时区表示为GMT+00,零时区缩写叫z。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gyby3e7IwTSYuydPAGcGY8N8FAee6faKncSyGwTRxu6vALGal6AuSsF11MgFibBx5Y8fRdIZUMG7DB4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;所以GMT，即Greenwich Mean Time，格林尼治标准时间(格林尼治所在地的标准时间)。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;以格林尼治天文台所在的时区为中心(GMT+00)，向东为正，向西为负；零时区比东时区晚，比西时区早。&lt;/p&gt;&lt;p&gt;北京所在的时区叫东八区，东八区表示形式是：GMT+08。0时区比东八区的时间晚8小时，比西五区的时间早5小时。美国华盛顿比北京慢13小时。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;UTC全称Universal Time Coordinated&lt;/strong&gt;，是国际无线电咨询委员会制定和推荐的，UTC相当于本初子午线(即经度0度)上的平均太阳时。它是经过平均太阳时(以格林威治标准时间GMT)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间，计算过程相当严谨精密，因此若以「世界标准时间」的角度来说，UTC比GMT来得更加精准。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;所以，简单来说，UTC就是一个比GMT更加精确的时间表述。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;说完了人类世界的时间表示，我们来看看计算机世界的时间表述。&lt;/p&gt;&lt;h2&gt;认识二进制世界中的时间&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gyby3e7IwTSYuydPAGcGY8N8FpFI4CS95X5icFMIfek1K46lTFicZTIjIDxmT6zbreicctSMvUGNHhldxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6175925925925926&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种表述方式被称为&lt;strong&gt;Unix时间(Unix Time)&lt;/strong&gt;，也叫做&lt;strong&gt;POSIX时间或&lt;/strong&gt;，是用来记录时间的流逝，定义为从UTC时间&lt;strong&gt;&lt;span&gt;1970年1月1日0时0分&lt;/span&gt;&lt;/strong&gt;开始流逝的秒数，不考虑闰秒。&lt;/p&gt;&lt;p&gt;上述图中，有一个很不起眼但很关键的一个点：&lt;strong&gt;t=0时刻&lt;/strong&gt;。这个时刻为&lt;strong&gt;&lt;span&gt;1970年1月1日0时0分&lt;/span&gt;&lt;/strong&gt;，被称为&lt;strong&gt;纪元时间(epoch time)&lt;/strong&gt;。从定义可以看到它只代表了从Unix纪元开始流逝的秒数，&lt;strong&gt;&lt;span&gt;所以你身处地球上何处，这个时间都是一样的&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;有一点值得注意的是，Unix纪元是Unix或类Unix系统，一些C/C++，Java等编程语言使用的纪元。而其他的操作系统或者编程语言，使用的就是不一样的纪元起始日期了。&lt;/p&gt;&lt;p&gt;例如：Microsoft C/C++ 7.0 使用的是 1899年十二月31号&lt;/p&gt;&lt;h2&gt;时区转换&lt;/h2&gt;&lt;p&gt;既然地球上的不同时区所处的时间是不一样的，那么计算机在处理跨时区问题时就需要做时区的转换。在我们对时区问题抽象之前，我们可以先看看跨时区可能会出现什么异常？&lt;/p&gt;&lt;h3&gt;跨时区可能会出现什么异常？&lt;/h3&gt;&lt;h4&gt;问题1：跨时区引发的展示异常&lt;/h4&gt;&lt;p&gt;如果在日本(比北京时间快1小时)使用淘宝下单，看到的时间是日本时间还是北京时间？支付服务是按照北京时间还是日本时间执行？&lt;/p&gt;&lt;h4&gt;问题2：时间错乱引发的处理异常&lt;/h4&gt;&lt;p&gt;在旧金山（比北京时间慢16小时）的用户A计划在2023-01-01给北京的用户B预约一笔转账计划，但后端收到之后当做北京时间处理，于是在北京时间&quot;2023-01-01&quot;(对应旧金山时间 2022-12-31)进行了转账，于是用户B提前了1天2022-12-31就收到了转账。 &lt;/p&gt;&lt;h2&gt;对跨时区问题的抽象处理&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gyby3e7IwTSYuydPAGcGY8N8F5hoG6Rl7luIV4K8NDtbs2phJfQgNIZ0b3R6qmjMuePmFtrMH7k6lqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.0898148148148148&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;在上述场景中，有几个不同的时间，接下来我们一一阐述&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;用户的时间（客户端）与服务器的时间（展示与计算）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务器与服务器的时间（跨时区计算）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务器与数据库的时间（计算与存储）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;Client &amp;lt;=&amp;gt; Web Server&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;Web Server =&amp;gt; Client&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;若二者时区相同(已将server服务器设置为当地时区)，那么可以在server端将时间格式化为字符串字面量直接传输到client端展示。其中，若server端时间为其他时区的字符串字面量时，需转为当前时区；若为Date对象，直接format，Java默认取当前系统时区；若为毫秒long，转为Date再格式化&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;若时区不同，server端将时间转换成毫秒数long或者字面量+时区，传输到client，由client所处的时区进行转换处理，最终展示。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;Client =&amp;gt; Web Server&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;如用户通过前端时间控件选择的时间，需要转化为毫秒数long或者字面量+时区，传输到server端。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Server-n &amp;lt;=&amp;gt;Server-k&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;取决于时间的序列化和反序列方式，如dubbo所使用的hession序列化方式会将Date对象序列化为毫秒数、json将时间序列化为字符串(需要指定时区)&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Server-n &amp;lt;=&amp;gt; DB&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gyby3e7IwTSYuydPAGcGY8N8Ff5exKXibxFQQ7TxJCiakzhcFibYXMD5twGpOg4natgJ7k8Qn5O34TVnpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3592592592592593&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库时间最常用的字段类型有bigint、datetime和timestamp&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;bigint用于&lt;/span&gt;&lt;span&gt;自己维护一个时间戳&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;8字节的长度让其使用几乎无上限&lt;/span&gt;&lt;span&gt;，因此使用bigint不存在时区问题，可以使用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;datetime字段以字符串格式存储，对应应用层String，无时区属性，在&lt;/span&gt;&lt;strong&gt;&lt;span&gt;多时区场景&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;下传输与转换不建议使用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;timestamp字段以时间戳格式存储，对应应用层Date类型，与系统时区无关，但需要注意的是，由于4字节的长度导致存储的时间上限为&lt;/span&gt;&lt;span&gt;2038-01-19 03:14:07，需做好对应的处理。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;有关2038-01-19 03:14:07这个著名的时间点，详情可参考我之前写过的一篇&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484245&amp;amp;idx=1&amp;amp;sn=722227215c32fdf65013c55434171833&amp;amp;scene=21#wechat_redirect&quot; data-href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484245&amp;amp;idx=1&amp;amp;sn=722227215c32fdf65013c55434171833&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《聊一聊2038年问题》&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;时间序列化和反序列化&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;上文提到使用bigint不存在时区问题，因此这里我们来重点讨论下datetime和timestamp在时间存储与读取时所遇到的序列化与反序列化的情况&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DateTime类型字段，MySQL存储时不存时区信息，并且怎么存就怎么取，不做任何处理和转换。所以时区timeZone1的server1插入MySQL一条记录后，时区timeZone2的server2读取出来的时间就不对了。这里只能将所有的server的时区设置为一样的，或者在数据库表中添加一个字段存储时区信息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TimeStamp类型字段，这个比较特殊。当server创建connection时，可以在数据库URL中手动指定时区信息，即不同时区的server连接MySQL时，指定connection时区使用自己所在时区。当MySQL处理不同的connection时，就有了时间字符串和发出请求的时区，然后转换为UTC时间进行存储。从MySQL中读取时也是基于connection的时区设置进行转换。但是如果不指定connection时区，那么MySQL就将存储的UTC时间，按MySQL服务器所在时区进行转换和展示或者传输，此时若MySQL服务器和server的时区不一致，就会出现时区问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;由上可知，产生时区问题的根本原因在于&lt;/span&gt;&lt;strong&gt;&lt;span&gt;不同时区的机器对时间进行序列化和反序列化时，Date对象或者毫秒数long与字符串之间的转换，丢失了时区信息&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，最终导致问题。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;跨时区场景应用调研&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;了解了跨时区场景的处理后，我们来看看业内产品是如何处理跨时区业务的。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;行业&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;业内App&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;通讯类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;微信、QQ&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;微信统一了app内所有的时间：使用&lt;/span&gt;&lt;span&gt;设备本地时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;QQ消息、QQ空间、收藏中的时间是&lt;/span&gt;&lt;span&gt;设备本地时间，&lt;/span&gt;&lt;span&gt;消息中的登录时间、交易记录的时间是&lt;/span&gt;&lt;span&gt;北京时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;电商类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;抖音、淘宝、拼多多、亚马逊&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;会话消息、退款详情、退款、交易通知、评论等服务使用&lt;/span&gt;&lt;span&gt;设备本地时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;订单、交易详情使用北京时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;金融类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;招银、中银、工银、paypal&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;银行统一使用&lt;span&gt;北京时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;paypal 支持&lt;/span&gt; 手动 &lt;span&gt;设置时区&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;分析&lt;/h3&gt;&lt;h4&gt;1. 非金融类的app不太关心跨时区场景？&lt;/h4&gt;&lt;p&gt;常规业务对于时间点信息的感知偏弱，更倾向于&lt;strong&gt;感知距离“现在”的时间差&lt;/strong&gt;（消息、评论等），不同的服务有各自对应的最佳“时区”搭配。&lt;/p&gt;&lt;h4&gt;2. 银行类App的时间是统一使用“北京时间”？&lt;/h4&gt;&lt;p&gt;国内银行类服务、金融类服务（基金、股票）有强制使用北京时间的诉求。&lt;/p&gt;&lt;h4&gt;3. 国际化业务有时区设置能力？&lt;/h4&gt;&lt;p&gt;可选，国际化业务中一般在时间信息之后回携带上时区信息（如：时区偏移量、城市信息）, 移动端服务 常见的是跟随设备的时区，部分服务商会在业务中提供出选择时区的能力。&lt;/p&gt;&lt;h4&gt;4. 衡量使用北京时间和设备本地时间的标准是什么？&lt;/h4&gt;&lt;p&gt;业内暂无具体的标准，合规、安全也没有详细要求，最佳的是站在用户体验角度case by case去分析。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;&lt;span&gt;国际化背景下多时区问题日益严重，多时区引发的问题一般不易发现，发现时已经灾难性问题，应对及改造成本也较高。架构层面尽量规避时区问题，在系统设计阶段需要考虑并遵循相应的原则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DB层面:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;新增表或字段时需要对时间类型慎重选择，非跨时区场景建议选择datetime，跨时区场景可以选择timestamp或bigint。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于VARCHAR类型时间字符串都必须使用iso标准时间格式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;新建库的DB时区需为UTC时区，不能使用其他时区（如LA时区）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;应用层面:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb32caecace2cbcefcb9af82187c7d28</guid>
<title>为啥我的代码库那么大？聊聊 Git 使用坏习惯</title>
<link>https://toutiao.io/k/9c0wmix</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content              autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naIff4DEKMpQB8W0zJFKKmTEVciaeSfgHqNfRlEc8V60PvIsBGzPMcyZDo3cycLLmngeGRnicSWcp90g/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;阿里妹导读&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;本文作者用幽默又真实的文字总结了开发者日常工作中遇到的那些事儿。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;说点真实的&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;众所周知啊🤔，&lt;/span&gt;&lt;span&gt;很多公司的度量系统&lt;/span&gt;&lt;span&gt;可以展示你提交了多少次commit，以及每一次提交包含多少行代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;搞得部分兄弟一天可劲 add commit push。他那一个变更发上线，你打开Git Log，好家伙那一大串都是他。加加减减缝缝补补，最后一共改了&lt;strong&gt;20行代码，硬是刷出了200行的功德。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一串Git commit message如下：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;AoneBuild Merge feautre/777_平台赋能牛逼新特性 to master&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Fix老板CR中建议&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;fix again&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;fix2&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;fix&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;save&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;update&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;new feature&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;典！典中典！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;仿佛能看到他信心满满，直接发预发！一刷新， 哦豁，白屏！ &lt;br/&gt;哦忘了传这个了，fix，push，部署，玩手机，抬头一刷新，哦豁，白屏！&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIff4DEKMpQB8W0zJFKKmTEWwRic35wX86j3dUfichicibw7MwekHmebibCGOa0HiaOLoWTnRNygTb6IHuw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;好活！&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下次 OC 再搞脱口秀我提个节目！随机找几个这种上去对着这种 git log 现场即兴模仿表演。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;他们欢快而自信的时候，以及受痛苦和绝望所折磨的时候，生活中的痛苦和压迫会像血汗一样，一行行地全写在了他们的Git Log里。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;你们好不好奇， 一个代码库几百个文件，为啥能用一两个G？小小一个系统，下个代码都十几分钟？&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;部署和CI场景可以 depth=1 &lt;/span&gt;浅&lt;span&gt;克隆加速&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;完全没有意义的Git 提交历史，极速膨胀的代码库大小，混乱的分支关系。正在压死你的代码库和项目！&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每一个程序员，在遇到一个可爱而热心的代码仓看门大爷前，都会随意的对待自己的commit，因为大家都这么做。没见过怎么best practice，所以就doesn&#x27;t matter。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;求求你们了！好好写你的Git commit message！squash你的 fixfixfix！删删你已经没用的分支！重构拆掉哪些超大文件和几万行的类！&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;让Git Log能做到写清楚你到底改了啥！而不是你的草纸！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阿里很多资深Coder都是野生哆啦A梦，技能树包括但不限于：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;ol ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;手里维护的代码库，托前人的福，一堆方法 JsonObject 出入参，他能如特工，手持密码本相互通信。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;系统日志print全是不带id的sout，也能靠口袋里的见都没见过的神奇道具和监控线条里波纹感应定位故障源头。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一个代码文件3万行，硬是一眼扫找出在哪儿再加个if else能5分钟hotfix一下线上Bug。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&quot;线上bug！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很急，来不及加单测了，帮忙过一下！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对代码系统机魂, 了如指掌，深谙取悦机魂之道。知道一些外人看来十分玄妙的独特逻辑。掌握很多，“&lt;strong&gt;又不是不能用，只是你不会用，要这么这么就能用”&lt;/strong&gt;的高级黑盒功能。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;虽然兄弟们这么用Git “&lt;strong&gt;又不是不能用&lt;/strong&gt;”，但是要我说 “&lt;strong&gt;那是你不会用&lt;/strong&gt;”，“&lt;strong&gt;要这么这么用&lt;/strong&gt;”&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;到这里，聪明的小朋友就要问了。为啥几百个文件，为啥能用一两个G呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;Git的结构，图文实例解说&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;众所周知，Git 主要数据结构是一颗树，在你的.git文件夹里，结构是这样的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06851851851851852&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIff4DEKMpQB8W0zJFKKmTEd8vKjcgwf7sKFaMv1KZYNiaTOrapczdRibaCCYQF0OQpnc6PHmflzHWA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;.git文件内部结构&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中的 refs中保存有分支的信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5662650602409639&quot; data-type=&quot;png&quot; data-w=&quot;332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIff4DEKMpQB8W0zJFKKmTERhibNHnSEhULPPHicx9o3ibBs3rqYlnbiaox5aaFkB2kZTQBcKPXolEtmA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;refs文件内部结构&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中的  &lt;/span&gt;&lt;span&gt;heads，本地分支，remotes，远程分支（用git fetch更新）&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt; tags 不可变的版本指针，&lt;/span&gt;&lt;span&gt;他们都是指向一个commit的指针。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5116279069767442&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIff4DEKMpQB8W0zJFKKmTEnvZlsib8tjEZdqAmJ1S3Z16DoyibdUTmFjP1SGfVD7akHMbl6BA3Xhrw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;master的内容物&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如 这里， master，就是一个commit id。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;你可能注意到了，分支似乎不是一个分支一个文件的。而是按/分割，当成文件夹存储的。 &lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如feature是不是个分支？其实不是，假设 我新建一个名为 feature/newaCTO的分支，会在feature文件夹里建一个newaCTO, 而不是直接新建一个feature/newaCTO。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;小zips， linux文件系统中，文件与文件夹是不能重名的。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所以， 一旦谁建了一个叫做feature的分支。那么，在第一个小聪明删掉他之前。就没人能拉出任何feature/*的分支了。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;分支是指向commit的指针，那让我们更近一步， commit是啥呢？&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20967741935483872&quot; data-type=&quot;png&quot; data-w=&quot;992&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIff4DEKMpQB8W0zJFKKmTERpZmgTRvk06HnnEBNF9rjSxv7f1QK0BUCEGiaO1072AjzqibuL3VviaiaQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;master节点的详情&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是一个merge 节点。和普通的commit节点不同，merge节点有两个parent。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;除此之外，有author和committer， author是作者，committer是提交人。在本地开发中，这两者基本上是一样的。注意，这里使用的，是gitConfig中的name 和 email。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;这里parent指向的是另一个commit， 典型的树状数据结构。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么Tree中有什么呢。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6748582230623819&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIff4DEKMpQB8W0zJFKKmTEd5d4QrHAcumKdvIOpWzicJa7ibeXbZR8AgzKjA3icziaeJfL6RwtqMSTGw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;tree的结构&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7597765363128491&quot; data-type=&quot;png&quot; data-w=&quot;1074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIff4DEKMpQB8W0zJFKKmTEZZMeO5GxSZeSZLRCTezic4gFjGuNkXz5icfUfpWmcejs9qicCKkojO8Ug/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;tree的详情&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到展示了一个列表，&lt;strong&gt;与GIt Log中展示不同， Tree里其实包含了完整的文件树&lt;/strong&gt;。树的末端，指向一个文件的oid。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;列表中四个字段分别是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、mode：&lt;strong&gt; 权限&lt;/strong&gt;（chmod加的东西）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、type：  &lt;strong&gt;类型&lt;/strong&gt;，&lt;/span&gt;&lt;span&gt;tree说明是文件夹，blob则是文件&lt;/span&gt;&lt;span&gt;，大部分情况下就是代码，也可能是图片或其他文件。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;游戏团队的代码库中就会包含很多美术素材图片。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，Git不是文件存储系统，大文件建议使用Git LFS技术，上传OSS，Git仅管理文件链接。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;3、revision（oid）：每当你提交commit时，你在这个commit中改动的文件，git会把文件的二进制数据加个信息头，然后算个hash，从而产生一个新的oid。然后这个commit会指向他。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;所以，每当你commit，就算提交一行的改动。就会存整个文件！（把代码文件，把类拆小点吧！不小心摸一下触摸板，代码就不知道去哪儿找了！）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;然后你在每一改个两行，就来个commit，存储膨胀能不快么！&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;就不谈没维护好 gitIgonre，胡乱git add .把编译文件，摸鱼刷的leetcode代码或者其他奇奇怪怪的东西提交到Git中的情况了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;你可能会问，我这的文件已经都删掉了，为啥.git还有这么大？你们是不是有Bug？&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为Git会保存你历史的所有版本！&lt;strong&gt;除非没有一个任何一个commit指向这个blob&lt;/strong&gt;，才会成为游离节点，在Git Gc的时候被处理掉。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;当然Git也没那么呆，是可以存增量的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;你在Git pc的时候会执行repack，repack会压缩一部分到增量，不过一般没人这么做，所以一般都是存了完整的离散文件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;git gc是个好课题，存储未来可能可以智能化的全自动gc，但是现在还不行。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;因此！&lt;/span&gt;&lt;span&gt;没事删删分支！&lt;/span&gt;&lt;span&gt;不小心提上来的大东西，得把对应的commit squash掉！&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;本地也可以允许git gc清理掉游离节点释放空间。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;我们并不是说要squash到一个变更一个commit，或者一个feature分支就一个commit。&lt;/span&gt;&lt;span&gt;就像游戏存档一样。&lt;/span&gt;&lt;span&gt;你可以在关中频繁存档，但是一大关打完了，你可以存一个然后把关中的存档都删了。&lt;/span&gt;&lt;strong&gt; 只留关键节点&lt;/strong&gt;&lt;span&gt;，这样万一你后悔选了这条命运线，可以&lt;/span&gt;&lt;span&gt;读&lt;/span&gt;&lt;span&gt;档重来。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这也是为什么那些大库需要严格执行主干开发的原因。要是我们公司几万研发都用一个大库，还都是用Git记日记的憨批， 我觉得我们会被迫在存储技术上卷死OSS。坏了，顺手把多版本云盘做成主营业务了。以后新人来了先发一块移动硬盘好了， 微服务那么多系统，下代码不得先下个半个月？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;span&gt;一是&lt;strong&gt;git log和commit message是很重要的信息来源，要保持整洁，用的正确，这个比发布文档还清晰。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;二是代码存储膨胀问题是很现实的， 随着系统发展，代码库一个G你还能下下，再大点咋办呢。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;虽然我们存代码不收费，说到这儿dataworks的兄弟们可能有同感， 不要钱就使劲造，狠角色拿git当oss用的都有几个。&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;主要影响的，还是可见的未来，不治理的话，clone代码越来越慢。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Best practice：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、Code Owner要建立 &lt;strong&gt;代码库统一的commit messgae 格式规范&lt;/strong&gt;，例如 Feature(commit): write an article to introduce git&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、打完Boss，单测通过，squash掉你之前上厕所或者测试时候的commit！化零为整但也不要矫枉过正！团队应该根据自己业务情况探索&lt;strong&gt;合适commit的大小和规范。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、&lt;strong&gt;重构掉“巨石类”！&lt;/strong&gt;他们早就不够内聚了！把能拆掉功能拆出来吧！我先替管存代码的那个亘古和其他用这个类的开发先感谢你！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4、&lt;strong&gt;大文件用Git LFS！&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5、及时&lt;strong&gt;维护GitIgonre！&lt;/strong&gt;误提交的文件一定要清理掉！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;6、用心维护主干分支的Git Log！让改动清晰可见！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;7、删掉没用的分支！Later Equals Never！当机立断舍离！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;8、&lt;strong&gt;Readme要持续更新！&lt;/strong&gt;怎么启动，格式规范都可以写在readme里！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Bad Practice: &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、&lt;strong&gt;不要建 feature，release这两个分支&lt;/strong&gt;，虽然git没有保留关键字，但是后人发现为啥建不出来分支的时候肯定会问候你的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、&lt;strong&gt;不要多分支并行开发的时候merge 来 merge去， git会脏合并&lt;/strong&gt;&lt;strong&gt;！&lt;/strong&gt; 保持提交历史干净简单！业务太复杂不行咱就上主干开发！&lt;/span&gt;&lt;span&gt;&lt;strong&gt;不要每次代码合并不符合预期就跑去找管代码的同学说Git丢代码，这种侦探服务的难度挺大的，在我建议按次收费！&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3dc0cdcd40a432202a368e96e6dc68c1</guid>
<title>并发编程（从 C++11 到 C++17）</title>
<link>https://toutiao.io/k/l9za4xd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content              autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;点击关注&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzk0MzI4OTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHhKgtwWvzaYZodgfpphdA6WWKEMXTn6ImCCCuEzlPKicNBcpzBUyjK1XicWwqIwusqLGpwyyOc87JPQ/0?wx_fmt=png&quot; data-nickname=&quot;高性能架构探索&quot; data-alias=&quot;gxnjgts_&quot; data-signature=&quot;专注于分享干货，硬货，欢迎关注😄&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;自C++11标准以来，C++语言开始支持多线程模型。借助多线程模型，我们可以开发出更好的并发系统。本文以C++语言为例，讲解如何进行并发编程。并尽可能涉及C++11，C++14以及C++17中的主要内容。&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;为什么要并发编程&lt;/h2&gt;&lt;p&gt;大型的软件项目常常包含非常多的任务需要处理。例如：对于大量数据的数据流处理，或者是包含复杂GUI界面的应用程序。如果将所有的任务都以串行的方式执行，则整个系统的效率将会非常低下，应用程序的用户体验会非常的差。&lt;/p&gt;&lt;p&gt;另一方面，自上个世纪六七十年代英特尔创始人之一 &lt;span&gt;Gordon Moore&lt;/span&gt; 提出 &lt;span&gt;摩尔定义&lt;/span&gt; 以来，CPU频率以每18个月翻一番的指数速度增长。但这一增长在最近的十年已经基本停滞，大家会发现曾经有过一段时间CPU的频率从3G到达4G，但在这之后就停滞不前了。因此最近的新款CPU也基本上都是3G左右的频率。相应的，CPU以更多核的形式在增长。目前的Intel i7有8核的版本，Xeon处理器达到了28核。并且，最近几年手机上使用的CPU也基本上是4核或者8核的了。&lt;/p&gt;&lt;p&gt;由此，掌握并发编程技术，利用多处理器来提升软件项目的性能将是软件工程师的一项基本技能。&lt;/p&gt;&lt;p&gt;本文以C++语言为例，讲解如何进行并发编程。并尽可能涉及C++11，C++14以及C++17中的主要内容。&lt;/p&gt;&lt;h2&gt;并发与并行&lt;/h2&gt;&lt;p&gt;并发（Concurrent）与并行（Parallel）都是很常见的术语。&lt;/p&gt;&lt;p&gt;Erlang之父Joe Armstrong曾经以人们使用咖啡机的场景为例描述了这两个术语。如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7516666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/p3sYCQXkuHjYKzmrrIp1Pl8K5QoMztuE0NoibE8nXkL79YVFYH0OhPtQlYGHDPaltEb2L7Hu6K0BU3iaNesrdzaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;并发&lt;/strong&gt;：如果多个队列可以交替使用某台咖啡机，则这一行为就是并发的。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;并行&lt;/strong&gt;：如果存在多台咖啡机可以被多个队列交替使用，则就是并行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这里队列中的每个人类比于计算机的任务，咖啡机类比于计算机处理器。因此：并发和并行都是在多任务的环境下的讨论。&lt;/p&gt;&lt;p&gt;更严格的来说：如果一个系统支持多个动作同时存在，那么这个系统就是一个并发系统。如果这个系统还支持多个动作（物理时间上）同时执行，那么这个系统就是一个并行系统。&lt;/p&gt;&lt;p&gt;你可能已经看出，“并行”其实是“并发”的子集。它们的区别在于是否具有多个处理器。如果存在多个处理器同时执行多个线程，就是并行。&lt;/p&gt;&lt;p&gt;在不考虑处理器数量的情况下，我们统称之为“并发”。&lt;/p&gt;&lt;h2&gt;进程与线程&lt;/h2&gt;&lt;p&gt;进程与线程是操作系统的基本概念。无论是桌面系统：MacOS，Linux，Windows，还是移动操作系统：Android，iOS，都存在进程和线程的概念。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;（英语：process），是指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。&lt;/p&gt;&lt;p&gt;– 维基百科&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;关于这两个概念在任何一本操作系统书上都可以找到定义。网上也有很多文章对它们进行了解释。因此这里不再赘述，这里仅仅提及一下它们与编程的关系。&lt;/p&gt;&lt;p&gt;对于绝大部分编程语言或者编程环境来说，我们所写的程序都会在一个进程中运行。一个进程至少会包含一个线程。这个线程我们通常称之为主线程。&lt;/p&gt;&lt;p&gt;在默认的情况下，我们写的代码都是在进程的主线程中运行，除非开发者在程序中创建了新的线程。&lt;/p&gt;&lt;p&gt;不同编程语言的线程环境会不一样，Java语言在很早就支持了多线程接口。（Java程序在Java虚拟机中运行，虚拟机通常还会包含自己特有的线程，例如垃圾回收线程。）。而对于JavaScript这样的语言来说，它就没有多线程的概念。&lt;/p&gt;&lt;p&gt;当我们只有一个处理器时，所有的进程或线程会分时占用这个处理器。但如果系统中存在多个处理器时，则就可能有多个任务并行的运行在不同的处理器上。&lt;/p&gt;&lt;p&gt;下面两幅图以不同颜色的矩形代表不同的任务（可能是进程，也可能是线程）来描述它们可能在处理器上执行的顺序。&lt;/p&gt;&lt;p&gt;下图是单核处理器的情况：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27685185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjYKzmrrIp1Pl8K5QoMztuEBvmGPiagA1wCDRiaGT6XretymooKXMJbUEcbIWY5AY34kJEsETeJUNibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;下面是四核处理器的情况：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.65&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjYKzmrrIp1Pl8K5QoMztuE9amQrib3JQX8UibTB7FhvRCvnqP26dv9NqotGLT9Ev5YOtG9R7vj6Ymg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;任务会在何时占有处理器，通常是由操作系统的调度策略决定的。在&lt;span&gt;《Android系统上的进程管理：进程的调度》&lt;/span&gt;一文中，我们介绍过Linux的调度策略。&lt;/p&gt;&lt;p&gt;当我们在开发跨平台的软件时，我们不应当对调度策略做任何假设，而应该抱有“系统可能以任意顺序来调度我的任务”这样的想法。&lt;/p&gt;&lt;h2&gt;并发系统的性能&lt;/h2&gt;&lt;p&gt;开发并发系统最主要的动机就是提升系统性能（事实上，这是以增加复杂度为代价的）。&lt;/p&gt;&lt;p&gt;但我们需要知道，单纯的使用多线程并不一定能提升系统性能（当然，也并非线程越多系统的性能就越好）。从上面的两幅图我们就可以直观的感受到：线程（任务）的数量要根据具体的处理器数量来决定。假设只有一个处理器，那么划分太多线程可能会适得其反。因为很多时间都花在任务切换上了。&lt;/p&gt;&lt;p&gt;因此，在设计并发系统之前，一方面我们需要做好对于硬件性能的了解，另一方面需要对我们的任务有足够的认识。&lt;/p&gt;&lt;p&gt;关于这一点，你可能需要了解一下&lt;span&gt;阿姆达尔定律&lt;/span&gt;了。对于这个定律，简单来说：我们想要预先意识到那些任务是可以并行的，那些是无法并行的。只有明确了任务的性质，才能有的放矢的进行优化。这个定律告诉了我们将系统并行之后性能收益的上限。&lt;/p&gt;&lt;p&gt;关于阿姆达尔定律在&lt;span&gt;Linux系统监测工具sysstat介绍&lt;/span&gt;一文中已经介绍过，因此这里不再赘述。&lt;/p&gt;&lt;h2&gt;C++与并发编程&lt;/h2&gt;&lt;p&gt;前面我们已经了解到，并非所有的语言都提供了多线程的环境。&lt;/p&gt;&lt;p&gt;即便是C++语言，直到&lt;span&gt;C++11&lt;/span&gt;标准之前，也是没有多线程支持的。在这种情况下，Linux/Unix平台下的开发者通常会使用&lt;span&gt;POSIX Threads&lt;/span&gt;，Windows上的开发者也会有&lt;span&gt;相应的接口&lt;/span&gt;。但很明显，这些API都只针对特定的操作系统平台，可移植性较差。如果要同时支持Linux和Windows系统，你可能要写两套代码。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;相较而言，Java自JDK 1.0就包含了多线程模型。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这个状态在C++ 11标准发布之后得到了改变。并且，在C++ 14和C++ 17标准中又对并发编程机制进行了增强。&lt;/p&gt;&lt;p&gt;下图是最近几个版本的C++标准特性的线路图。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5023201856148491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjYKzmrrIp1Pl8K5QoMztuEAXFlH4QzYtbgUfiaEf2QQZzAGAx8hkySoiciaJIXtNDtGeZKeaOAibBhdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;编译器与C++标准&lt;/h2&gt;&lt;p&gt;编译器对于语言特性的支持是逐步完成的。想要使用特定的特性你需要相应版本的编译器。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;GCC对于C++特性的支持请参见这里：&lt;span&gt;C++ Standards Support in GCC&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Clang对于C++特性的支持请参见这里：&lt;span&gt;C++ Support in Clang&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下面两个表格列出了C++标准和相应编译器的版本对照：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;C++标准与相应的GCC版本要求如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;C++版本&lt;/td&gt;&lt;td&gt;GCC版本&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;4.8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C++14&lt;/td&gt;&lt;td&gt;5.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C++17&lt;/td&gt;&lt;td&gt;7.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;C++标准与相应的Clang版本要求如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;C++版本&lt;/td&gt;&lt;td&gt;Clang版本&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;3.3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C++14&lt;/td&gt;&lt;td&gt;3.4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C++17&lt;/td&gt;&lt;td&gt;5.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;默认情况下编译器是以较低的标准来进行编译的，如果希望使用新的标准，你需要通过编译参数&lt;code&gt;-std=c++xx&lt;/code&gt;告知编译器，例如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;g++ -std=c++17 your_file.cpp -o your_program&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;测试环境&lt;/h2&gt;&lt;p&gt;本文的源码可以到下载我的github上获取，地址：&lt;span&gt;paulQuei/cpp-concurrency&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;你可以直接通过下面这条命令获取源码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;git clone https://github.com/paulQuei/cpp-concurrency.git&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;源码下载之后，你可以通过任何文本编辑器浏览源码。如果希望编译和运行程序，你还需要按照下面的内容来准备环境。&lt;/p&gt;&lt;p&gt;本文中的源码使用&lt;span&gt;cmake&lt;/span&gt;编译，只有cmake 3.8以上的版本才支持C++ 17，所以你需要安装这个或者更新版本的cmake。&lt;/p&gt;&lt;p&gt;另外，截止目前（2019年10月）为止，&lt;code&gt;clang&lt;/code&gt;编译器还不支持&lt;span&gt;并行算法&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;但是&lt;span&gt;gcc-9&lt;/span&gt;是支持的。因此想要编译和运行这部分代码，你需要安装gcc 9.0或更新的版本。并且，gcc-9还要依赖&lt;span&gt;Intel Threading Building Blocks&lt;/span&gt;才能使用并行算法以及&lt;code&gt;&amp;lt;execution&amp;gt;&lt;/code&gt;头文件。&lt;/p&gt;&lt;p&gt;具体的安装方法见下文。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;具体编译器对于C++特性支持的情况请参见这里：&lt;span&gt;C++ compiler support&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;安装好之后运行根目录下的下面这个命令即可：&lt;/p&gt;&lt;p&gt;它会完成所有的编译工作。&lt;/p&gt;&lt;p&gt;本文的源码在下面两个环境中经过测试，环境的准备方法如下。&lt;/p&gt;&lt;h2&gt;MacOS&lt;/h2&gt;&lt;p&gt;在Mac上，我使用&lt;span&gt;brew&lt;/span&gt;工具安装&lt;code&gt;gcc&lt;/code&gt;以及&lt;code&gt;tbb&lt;/code&gt;库。&lt;/p&gt;&lt;p&gt;考虑到其他人与我的环境可能会有所差异，所以需要手动告知&lt;code&gt;tbb&lt;/code&gt;库的安装路径。&lt;/p&gt;&lt;p&gt;读者需要执行下面这些命令来准备环境：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;brew install gcc&lt;br/&gt;brew install tbb&lt;br/&gt;&lt;br/&gt;export tbb_path=/usr/local/Cellar/tbb/2019_U8/&lt;br/&gt;./make_all.sh&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，请通过运行&lt;code&gt;g++-9&lt;/code&gt;命令以确认gcc的版本是否正确，如果版本较低，则需要通过&lt;code&gt;brew&lt;/code&gt;命令将其升级到新版本：&lt;/p&gt;&lt;h2&gt;Ubuntu&lt;/h2&gt;&lt;p&gt;Ubuntu上，通过下面的命令安装&lt;code&gt;gcc-9&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:ubuntu-toolchain-r/test&lt;br/&gt;sudo apt-get update&lt;br/&gt;sudo apt install  gcc-9 g++-9&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但安装&lt;code&gt;tbb&lt;/code&gt;库就有些麻烦了。这是因为&lt;span&gt;Ubuntu 16.04默认关联的版本是较低的&lt;/span&gt;，直接安装是无法使用的。我们需要安装&lt;span&gt;更新的版本&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;联网安装的方式&lt;span&gt;步骤繁琐&lt;/span&gt;，所以可以通过下载包的方式进行安装，我已经将这需要的两个文件放到的这里：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;libtbb2_2019~U8-1_amd64.deb&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;libtbb-dev_2019~U8-1_amd64.deb&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果需要，你可以下载后通过&lt;code&gt;apt&lt;/code&gt;命令安装即可：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;sudo apt install ~/Downloads/libtbb2_2019~U8-1_amd64.deb &lt;br/&gt;sudo apt install ~/Downloads/libtbb-dev_2019~U8-1_amd64.deb &lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;线程&lt;/h2&gt;&lt;h2&gt;创建线程&lt;/h2&gt;&lt;p&gt;创建线程非常的简单的，下面就是一个使用了多线程的Hello World示例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 01_hello_thread.cpp&lt;br/&gt;&lt;br/&gt;#include &amp;lt;iostream&amp;gt;&lt;br/&gt;#include &amp;lt;thread&amp;gt; // ①&lt;br/&gt;&lt;br/&gt;using namespace std; // ②&lt;br/&gt;&lt;br/&gt;void hello() { // ③&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Hello World from new thread.&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;int main() {&lt;br/&gt;  thread t(hello); // ④&lt;br/&gt;  t.join(); // ⑤&lt;br/&gt;&lt;br/&gt;  return 0;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于这段代码说明如下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;为了使用多线程的接口，我们需要&lt;code&gt;#include &amp;lt;thread&amp;gt;&lt;/code&gt;头文件。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;为了简化声明，本文中的代码都将&lt;code&gt;using namespace std;&lt;/code&gt;。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;新建线程的入口是一个普通的函数，它并没有什么特别的地方。&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;创建线程的方式就是构造一个&lt;code&gt;thread&lt;/code&gt;对象，并指定入口函数。与普通对象不一样的是，此时编译器便会为我们创建一个新的操作系统线程，并在新的线程中执行我们的入口函数。&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;关于&lt;code&gt;join&lt;/code&gt;函数在下文中讲解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;thread&lt;/code&gt;可以和&lt;code&gt;callable&lt;/code&gt;类型一起工作，因此如果你熟悉&lt;span&gt;lambda表达式&lt;/span&gt;，你可以直接用它来写线程的逻辑，像这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 02_lambda_thread.cpp&lt;br/&gt;&lt;br/&gt;#include &amp;lt;iostream&amp;gt;&lt;br/&gt;#include &amp;lt;thread&amp;gt;&lt;br/&gt;&lt;br/&gt;using namespace std;&lt;br/&gt;&lt;br/&gt;int main() {&lt;br/&gt;  thread t([] {&lt;br/&gt;    cout &amp;lt;&amp;lt; &quot;Hello World from lambda thread.&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  t.join();&lt;br/&gt;&lt;br/&gt;  return 0;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;为了减少不必要的重复，若无必要，下文中的代码将不贴出&lt;code&gt;include&lt;/code&gt;指令以及&lt;code&gt;using&lt;/code&gt;声明。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;当然，你可以传递参数给入口函数，像下面这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 03_thread_argument.cpp&lt;br/&gt;&lt;br/&gt;void hello(string name) {&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Welcome to &quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;int main() {&lt;br/&gt;  thread t(hello, &quot;https://paul.pub&quot;);&lt;br/&gt;  t.join();&lt;br/&gt;&lt;br/&gt;  return 0;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过需要注意的是，参数是以拷贝的形式进行传递的。因此对于拷贝耗时的对象你可能需要传递指针或者引用类型作为参数。但是，如果是传递指针或者引用，你还需要考虑参数对象的生命周期。因为线程的运行长度很可能会超过参数的生命周期（见下文&lt;code&gt;detach&lt;/code&gt;），这个时候如果线程还在访问一个已经被销毁的对象就会出现问题。&lt;/p&gt;&lt;h2&gt;join与detach&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;主要API&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;API&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;join&lt;/td&gt;&lt;td&gt;等待线程完成其执行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;detach&lt;/td&gt;&lt;td&gt;允许线程独立执行&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;一旦启动线程之后，我们必须决定是要等待直接它结束（通过&lt;code&gt;join&lt;/code&gt;），还是让它独立运行（通过&lt;code&gt;detach&lt;/code&gt;），我们必须二者选其一。如果在&lt;code&gt;thread&lt;/code&gt;对象&lt;strong&gt;销毁的时候&lt;/strong&gt;我们还没有做决定，则&lt;code&gt;thread&lt;/code&gt;对象在析构函数出将调用&lt;code&gt;std::terminate()&lt;/code&gt;从而导致我们的进程异常退出。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;请思考在上面的代码示例中，&lt;code&gt;thread&lt;/code&gt;对象在何时会销毁。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;需要注意的是：在我们做决定的时候，很可能线程已经执行完了（例如上面的示例中线程的逻辑仅仅是一句打印，执行时间会很短）。新的线程创建之后，究竟是新的线程先执行，还是当前线程的下一条语句先执行这是不确定的，因为这是由操作系统的调度策略决定的。不过这不要紧，我们只要在&lt;code&gt;thread&lt;/code&gt;对象销毁前做决定即可。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;join&lt;/code&gt;：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成（当然，很可能目标线程在此处调用之前就已经执行完成了，不过这不要紧）。因此，如果目标线程的任务非常耗时，你就要考虑好是否需要在主线程上等待它了，因此这很可能会导致主线程卡住。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;detach&lt;/code&gt;：&lt;code&gt;detach&lt;/code&gt;是让目标线程成为守护线程（daemon threads）。一旦&lt;code&gt;detach&lt;/code&gt;之后，目标线程将独立执行，即便其对应的&lt;code&gt;thread&lt;/code&gt;对象销毁也不影响线程的执行。并且，你无法再与之通信。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;对于这两个接口，都必须是可执行的线程才有意义。你可以通过&lt;code&gt;joinable()&lt;/code&gt;接口查询是否可以对它们进行&lt;code&gt;join&lt;/code&gt;或者&lt;code&gt;detach&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;管理当前线程&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;主要API&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;API&lt;/td&gt;&lt;td&gt;C++标准&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;yield&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;让出处理器，重新调度各执行线程&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;get_id&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;返回当前线程的线程 id&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sleep_for&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;使当前线程的执行停止指定的时间段&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sleep_until&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;使当前线程的执行停止直到指定的时间点&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;上面是一些在线程内部使用的API，它们用来对当前线程做一些控制。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;yield&lt;/code&gt; 通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;get_id&lt;/code&gt; 返回当前线程的id，可以以此来标识不同的线程。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;sleep_for&lt;/code&gt; 是让当前线程停止一段时间。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;sleep_until&lt;/code&gt; 和&lt;code&gt;sleep_for&lt;/code&gt;类似，但是是以具体的时间点为参数。这两个API都以&lt;span&gt;chrono&lt;/span&gt; API（由于篇幅所限，这里不展开这方面内容）为基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下面是一个代码示例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 04_thread_self_manage.cpp&lt;br/&gt;&lt;br/&gt;void print_time() {&lt;br/&gt;  auto now = chrono::system_clock::now();&lt;br/&gt;  auto in_time_t = chrono::system_clock::to_time_t(now);&lt;br/&gt;&lt;br/&gt;  std::stringstream ss;&lt;br/&gt;  ss &amp;lt;&amp;lt; put_time(localtime(&amp;amp;in_time_t), &quot;%Y-%m-%d %X&quot;);&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;now is: &quot; &amp;lt;&amp;lt; ss.str() &amp;lt;&amp;lt; endl;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;void sleep_thread() {&lt;br/&gt;  this_thread::sleep_for(chrono::seconds(3));&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;[thread-&quot; &amp;lt;&amp;lt; this_thread::get_id() &amp;lt;&amp;lt; &quot;] is waking up&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;void loop_thread() {&lt;br/&gt;  for (int i = 0; i &amp;lt; 10; i++) {&lt;br/&gt;    cout &amp;lt;&amp;lt; &quot;[thread-&quot; &amp;lt;&amp;lt; this_thread::get_id() &amp;lt;&amp;lt; &quot;] print: &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;int main() {&lt;br/&gt;  print_time();&lt;br/&gt;&lt;br/&gt;  thread t1(sleep_thread);&lt;br/&gt;  thread t2(loop_thread);&lt;br/&gt;&lt;br/&gt;  t1.join();&lt;br/&gt;  t2.detach();&lt;br/&gt;&lt;br/&gt;  print_time();&lt;br/&gt;  return 0;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码应该还是比较容易理解的，这里创建了两个线程。它们都会有一些输出，其中一个会先停止3秒钟，然后再输出。主线程调用&lt;code&gt;join&lt;/code&gt;会一直卡住等待它运行结束。&lt;/p&gt;&lt;p&gt;这段程序的输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;now is: 2019-10-13 10:17:48&lt;br/&gt;[thread-0x70000cdda000] print: 0&lt;br/&gt;[thread-0x70000cdda000] print: 1&lt;br/&gt;[thread-0x70000cdda000] print: 2&lt;br/&gt;[thread-0x70000cdda000] print: 3&lt;br/&gt;[thread-0x70000cdda000] print: 4&lt;br/&gt;[thread-0x70000cdda000] print: 5&lt;br/&gt;[thread-0x70000cdda000] print: 6&lt;br/&gt;[thread-0x70000cdda000] print: 7&lt;br/&gt;[thread-0x70000cdda000] print: 8&lt;br/&gt;[thread-0x70000cdda000] print: 9&lt;br/&gt;[thread-0x70000cd57000] is waking up&lt;br/&gt;now is: 2019-10-13 10:17:51&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;一次调用&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;主要API&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;API&lt;/td&gt;&lt;td&gt;C++标准&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;call_once&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;即便在多线程环境下，也能保证只调用某个函数一次&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;once_flag&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;与&lt;code&gt;call_once&lt;/code&gt;配合使用&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。&lt;/p&gt;&lt;p&gt;下面就是一个示例：有三个线程都会使用&lt;code&gt;init&lt;/code&gt;函数，但是只会有一个线程真正执行它。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 05_call_once.cpp&lt;br/&gt;&lt;br/&gt;void init() {&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Initialing...&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;  // Do something...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;void worker(once_flag* flag) {&lt;br/&gt;  call_once(*flag, init);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;int main() {&lt;br/&gt;  once_flag flag;&lt;br/&gt;&lt;br/&gt;  thread t1(worker, &amp;amp;flag);&lt;br/&gt;  thread t2(worker, &amp;amp;flag);&lt;br/&gt;  thread t3(worker, &amp;amp;flag);&lt;br/&gt;&lt;br/&gt;  t1.join();&lt;br/&gt;  t2.join();&lt;br/&gt;  t3.join();&lt;br/&gt;&lt;br/&gt;  return 0;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们无法确定具体是哪一个线程会执行&lt;code&gt;init&lt;/code&gt;。而事实上，我们也不关心，因为只要有某个线程完成这个初始化工作就可以了。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;请思考一下，为什么要在main函数中创建&lt;code&gt;once_flag flag&lt;/code&gt;。如果是在&lt;code&gt;worker&lt;/code&gt;函数中直接声明一个&lt;code&gt;once_flag&lt;/code&gt;并使用行不行？为什么？&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;并发任务&lt;/h2&gt;&lt;p&gt;下面以一个并发任务为示例讲解如何引入多线程。&lt;/p&gt;&lt;p&gt;任务示例：现在假设我们需要计算某个范围内所有自然数的平方根之和，例如&lt;code&gt;[1, 10e8]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在单线程模型下，我们的代码可能是这样的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 06_naive_multithread.cpp&lt;br/&gt;&lt;br/&gt;static const int MAX = 10e8; // ①&lt;br/&gt;static double sum = 0; // ②&lt;br/&gt;&lt;br/&gt;void worker(int min, int max) { // ③&lt;br/&gt;  for (int i = min; i &amp;lt;= max; i++) {&lt;br/&gt;    sum += sqrt(i);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;void serial_task(int min, int max) { // ④&lt;br/&gt;  auto start_time = chrono::steady_clock::now();&lt;br/&gt;  sum = 0;&lt;br/&gt;  worker(0, MAX);&lt;br/&gt;  auto end_time = chrono::steady_clock::now();&lt;br/&gt;  auto ms = chrono::duration_cast&amp;lt;chrono::milliseconds&amp;gt;(end_time - start_time).count();&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Serail task finish, &quot; &amp;lt;&amp;lt; ms &amp;lt;&amp;lt; &quot; ms consumed, Result: &quot; &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码说明如下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;通过一个常量指定数据范围，这个是为了方便调整。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;通过一个全局变量来存储结果。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;通过一个任务函数来计算值。&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;统计任务的执行时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这段程序输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Serail task finish, 6406 ms consumed, Result: 2.10819e+13&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很显然，上面单线程的做法性能太差了。我们的任务完全是可以并发执行的。并且任务很容易划分。&lt;/p&gt;&lt;p&gt;下面我们就尝试以多线程的方式来改造原先的程序。&lt;/p&gt;&lt;p&gt;改造后的程序如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 06_naive_multithread.cpp&lt;br/&gt;&lt;br/&gt;void concurrent_task(int min, int max) {&lt;br/&gt;  auto start_time = chrono::steady_clock::now();&lt;br/&gt;&lt;br/&gt;  unsigned concurrent_count = thread::hardware_concurrency(); // ①&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;hardware_concurrency: &quot; &amp;lt;&amp;lt; concurrent_count &amp;lt;&amp;lt; endl;&lt;br/&gt;  vector&amp;lt;thread&amp;gt; threads;&lt;br/&gt;  min = 0;&lt;br/&gt;  sum = 0;&lt;br/&gt;  for (int t = 0; t &amp;lt; concurrent_count; t++) { // ②&lt;br/&gt;    int range = max / concurrent_count * (t + 1);&lt;br/&gt;    threads.push_back(thread(worker, min, range)); // ③&lt;br/&gt;    min = range + 1;&lt;br/&gt;  }&lt;br/&gt;  for (auto&amp;amp; t : threads) {&lt;br/&gt;    t.join(); // ④&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  auto end_time = chrono::steady_clock::now();&lt;br/&gt;  auto ms = chrono::duration_cast&amp;lt;chrono::milliseconds&amp;gt;(end_time - start_time).count();&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Concurrent task finish, &quot; &amp;lt;&amp;lt; ms &amp;lt;&amp;lt; &quot; ms consumed, Result: &quot; &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码说明如下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;&lt;code&gt;thread::hardware_concurrency()&lt;/code&gt;可以获取到当前硬件支持多少个线程并行执行。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;根据处理器的情况决定线程的数量。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;对于每一个线程都通过&lt;code&gt;worker&lt;/code&gt;函数来完成任务，并划分一部分数据给它处理。&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;等待每一个线程执行结束。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;很好，似乎很简单就完成了并发的改造。然后我们运行一下这个程序：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;hardware_concurrency: 16&lt;br/&gt;Concurrent task finish, 6246 ms consumed, Result: 1.78162e+12&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很抱歉，我们会发现这里的性能并没有明显的提升。更严重的是，这里的结果是错误的。&lt;/p&gt;&lt;p&gt;要搞清楚为什么结果不正确我们需要更多的背景知识。&lt;/p&gt;&lt;p&gt;我们知道，对于现代的处理器来说，为了加速处理的速度，每个处理器都会有自己的高速缓存（Cache），这个高速缓存是与每个处理器相对应的，如下图所示：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;事实上，目前大部分CPU的缓存已经不只一层。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3351851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjYKzmrrIp1Pl8K5QoMztuEdcTATlwyYN1rxqehVbN9H3O9VeezJGRwmBibxAAicb9jzJiaQJ0bdLicyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;处理器在进行计算的时候，高速缓存会参与其中，例如数据的读和写。而高速缓存和系统主存（Memory）是有可能存在不一致的。即：某个结果计算后保存在处理器的高速缓存中了，但是没有同步到主存中，此时这个值对于其他处理器就是不可见的。&lt;/p&gt;&lt;p&gt;事情还远不止这么简单。我们对于全局变量值的修改：&lt;code&gt;sum += sqrt(i);&lt;/code&gt;这条语句，它并非是原子的。它其实是很多条指令的组合才能完成。假设在某个设备上，这条语句通过下面这几个步骤来完成。它们的时序可能如下所示：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7453703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjYKzmrrIp1Pl8K5QoMztuElUHNs77zq9PibmjmqDWpuZysNo48I7qHr9B6tG7VqU5cTZK8q90NYDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在时间点a的时候，所有线程对于&lt;code&gt;sum&lt;/code&gt;变量的值是一致的。&lt;/p&gt;&lt;p&gt;但是在时间点b之后，thread3上已经对&lt;code&gt;sum&lt;/code&gt;进行了赋值。而这个时候其他几个线程也同时在其他处理器上使用了这个值，那么这个时候它们所使用的值就是旧的（错误的）。最后得到的结果也自然是错的。&lt;/p&gt;&lt;h2&gt;竞争条件与临界区&lt;/h2&gt;&lt;p&gt;当多个进程或者线程同时访问共享数据时，只要有一个任务会修改数据，那么就可能会发生问题。此时结果依赖于这些任务执行的相对时间，这种场景称为&lt;span&gt;&lt;strong&gt;竞争条件&lt;/strong&gt;（race condition）&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;访问共享数据的代码片段称之为&lt;strong&gt;临界区&lt;/strong&gt;（critical section）。具体到上面这个示例，临界区就是读写&lt;code&gt;sum&lt;/code&gt;变量的地方。&lt;/p&gt;&lt;p&gt;要避免竞争条件，就需要对临界区进行数据保护。&lt;/p&gt;&lt;p&gt;很自然的，现在我们能够理解发生竞争条件是因为这些线程在同时访问共享数据，其中有些线程的改动没有让其他线程知道，导致其他线程在错误的基础上进行处理，结果自然也就是错误的。&lt;/p&gt;&lt;p&gt;那么，如果一次只让一个线程访问共享数据，访问完了再让其他线程接着访问，这样就可以避免问题的发生了。&lt;/p&gt;&lt;p&gt;接下来介绍的API提供的就是这样的功能。&lt;/p&gt;&lt;h2&gt;互斥体与锁&lt;/h2&gt;&lt;h2&gt;mutex&lt;/h2&gt;&lt;p&gt;开发并发系统的目的主要是为了提升性能：将任务分散到多个线程，然后在不同的处理器上同时执行。这些分散开来的线程通常会包含两类任务：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;独立的对于划分给自己的数据的处理&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;对于处理结果的汇总&lt;/span&gt;&lt;/p&gt;&lt;p&gt;其中第1项任务因为每个线程是独立的，不存在竞争条件的问题。而第2项任务，由于所有线程都可能往总结果（例如上面的&lt;code&gt;sum&lt;/code&gt;变量）汇总，这就需要做保护了。在某一个具体的时刻，只应当有一个线程更新总结果，即：保证每个线程对于共享数据的访问是“互斥”的。&lt;code&gt;mutex&lt;/code&gt; 就提供了这样的功能。&lt;/p&gt;&lt;p&gt;&lt;code&gt;mutex&lt;/code&gt;是&lt;strong&gt;mut&lt;/strong&gt;ual &lt;strong&gt;ex&lt;/strong&gt;clusion（互斥）的简写。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;主要API&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;API&lt;/td&gt;&lt;td&gt;C++标准&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;mutex&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;提供基本互斥设施&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;timed_mutex&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;提供互斥设施，带有超时功能&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;recursive_mutex&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;提供能被同一线程递归锁定的互斥设施&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;recursive_timed_mutex&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;提供能被同一线程递归锁定的互斥设施，带有超时功能&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;shared_timed_mutex&lt;/td&gt;&lt;td&gt;C++14&lt;/td&gt;&lt;td&gt;提供共享互斥设施并带有超时功能&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;shared_mutex&lt;/td&gt;&lt;td&gt;C++17&lt;/td&gt;&lt;td&gt;提供共享互斥设施&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;很明显，在这些类中，&lt;code&gt;mutex&lt;/code&gt;是最基础的API。其他类都是在它的基础上的改进。所以这些类都提供了下面三个方法，并且它们的功能是一样的：&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;方法&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;lock&lt;/td&gt;&lt;td&gt;锁定互斥体，如果不可用，则阻塞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;try_lock&lt;/td&gt;&lt;td&gt;尝试锁定互斥体，如果不可用，直接返回&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;unlock&lt;/td&gt;&lt;td&gt;解锁互斥体&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这三个方法提供了基础的锁定和解除锁定的功能。使用&lt;code&gt;lock&lt;/code&gt;意味着你有很强的意愿一定要获取到互斥体，而使用&lt;code&gt;try_lock&lt;/code&gt;则是进行一次尝试。这意味着如果失败了，你通常还有其他的路径可以走。&lt;/p&gt;&lt;p&gt;在这些基础功能之上，其他的类分别在下面三个方面进行了扩展：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;超时&lt;/strong&gt;：&lt;code&gt;timed_mutex&lt;/code&gt;，&lt;code&gt;recursive_timed_mutex&lt;/code&gt;，&lt;code&gt;shared_timed_mutex&lt;/code&gt;的名称都带有&lt;code&gt;timed&lt;/code&gt;，这意味着它们都支持超时功能。它们都提供了&lt;code&gt;try_lock_for&lt;/code&gt;和&lt;code&gt;try_lock_until&lt;/code&gt;方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;可重入&lt;/strong&gt;：&lt;code&gt;recursive_mutex&lt;/code&gt;和&lt;code&gt;recursive_timed_mutex&lt;/code&gt;的名称都带有&lt;code&gt;recursive&lt;/code&gt;。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;共享&lt;/strong&gt;：&lt;code&gt;shared_timed_mutex&lt;/code&gt;和&lt;code&gt;shared_mutex&lt;/code&gt;提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁；但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。这里互斥锁的使用和其他的互斥体接口和功能一样。而共享锁可以同时被多个线程同时获取到（使用共享锁的接口见下面的表格）。共享锁通常用在&lt;span&gt;读者写者模型&lt;/span&gt;上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;使用共享锁的接口如下：&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;方法&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;lock_shared&lt;/td&gt;&lt;td&gt;获取互斥体的共享锁，如果无法获取则阻塞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;try_lock_shared&lt;/td&gt;&lt;td&gt;尝试获取共享锁，如果不可用，直接返回&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;unlock_shared&lt;/td&gt;&lt;td&gt;解锁共享锁&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;接下来，我们就借助刚学到的&lt;code&gt;mutex&lt;/code&gt;来改造我们的并发系统，改造后的程序如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 07_mutex_lock.cpp&lt;br/&gt;&lt;br/&gt;static const int MAX = 10e8;&lt;br/&gt;static double sum = 0;&lt;br/&gt;&lt;br/&gt;static mutex exclusive;&lt;br/&gt;&lt;br/&gt;void concurrent_worker(int min, int max) {&lt;br/&gt;  for (int i = min; i &amp;lt;= max; i++) {&lt;br/&gt;    exclusive.lock(); // ①&lt;br/&gt;    sum += sqrt(i);&lt;br/&gt;    exclusive.unlock(); // ②&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;void concurrent_task(int min, int max) {&lt;br/&gt;  auto start_time = chrono::steady_clock::now();&lt;br/&gt;&lt;br/&gt;  unsigned concurrent_count = thread::hardware_concurrency();&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;hardware_concurrency: &quot; &amp;lt;&amp;lt; concurrent_count &amp;lt;&amp;lt; endl;&lt;br/&gt;  vector&amp;lt;thread&amp;gt; threads;&lt;br/&gt;  min = 0;&lt;br/&gt;  sum = 0;&lt;br/&gt;  for (int t = 0; t &amp;lt; concurrent_count; t++) {&lt;br/&gt;    int range = max / concurrent_count * (t + 1);&lt;br/&gt;    threads.push_back(thread(concurrent_worker, min, range)); // ③&lt;br/&gt;    min = range + 1;&lt;br/&gt;  }&lt;br/&gt;  for (int i = 0; i &amp;lt; threads.size(); i++) {&lt;br/&gt;    threads[i].join();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  auto end_time = chrono::steady_clock::now();&lt;br/&gt;  auto ms = chrono::duration_cast&amp;lt;chrono::milliseconds&amp;gt;(end_time - start_time).count();&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Concurrent task finish, &quot; &amp;lt;&amp;lt; ms &amp;lt;&amp;lt; &quot; ms consumed, Result: &quot; &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里只有三个地方需要关注：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;在访问共享数据之前加锁&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;访问完成之后解锁&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;在多线程中使用带锁的版本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;执行之后结果输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;hardware_concurrency: 16&lt;br/&gt;Concurrent task finish, 74232 ms consumed, Result: 2.10819e+13&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这下结果是对了，但是我们却发现这个版本比原先单线程的版本性能还要差很多。这是为什么？&lt;/p&gt;&lt;p&gt;这是因为加锁和解锁是有代价的，这里计算最耗时的地方在锁里面，每次只能有一个线程串行执行，相比于单线程模型，它不但是串行的，还增加了锁的负担，因此就更慢了。&lt;/p&gt;&lt;p&gt;这就是为什么前面说多线程系统会增加系统的复杂度，而且并非多线程系统一定就有更好的性能。&lt;/p&gt;&lt;p&gt;不过，对于这里的问题是可以改进的。我们仔细思考一下：我们划分给每个线程的数据其实是独立的，对于数据的处理是耗时的，但其实这部分逻辑每个线程可以单独处理，没必要加锁。只有在最后汇总数据的时候进行一次锁保护就可以了。&lt;/p&gt;&lt;p&gt;于是我们改造&lt;code&gt;concurrent_worker&lt;/code&gt;，像下面这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 08_improved_mutex_lock.cpp&lt;br/&gt;&lt;br/&gt;void concurrent_worker(int min, int max) {&lt;br/&gt;  double tmp_sum = 0;&lt;br/&gt;  for (int i = min; i &amp;lt;= max; i++) {&lt;br/&gt;    tmp_sum += sqrt(i); // ①&lt;br/&gt;  }&lt;br/&gt;  exclusive.lock(); // ②&lt;br/&gt;  sum += tmp_sum;&lt;br/&gt;  exclusive.unlock();&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码的改变在于两处：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;通过一个局部变量保存当前线程的处理结果&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;在汇总总结过的时候进行锁保护&lt;/span&gt;&lt;/p&gt;&lt;p&gt;运行一下改进后的程序，其结果输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;hardware_concurrency: 16&lt;br/&gt;Concurrent task finish, 451 ms consumed, Result: 2.10819e+13&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，性能一下就提升了好多倍。我们终于体验到多线程带来的好处了。&lt;/p&gt;&lt;p&gt;我们用锁的&lt;strong&gt;粒度&lt;/strong&gt;（granularity）来描述锁的范围。&lt;strong&gt;细粒度&lt;/strong&gt;（fine-grained）是指锁保护较小的范围，&lt;strong&gt;粗粒度&lt;/strong&gt;（coarse-grained）是指锁保护较大的范围。出于性能的考虑，我们应该保证锁的粒度尽可能的细。并且，不应该在获取锁的范围内执行耗时的操作，例如执行IO。如果是耗时的运算，也应该尽可能的移到锁的外面。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;In general, a lock should be held for only the minimum possible time needed to perform the required operations.&lt;/p&gt;&lt;p&gt;–《C++ Concurrency in Action》&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;死锁&lt;/h2&gt;&lt;p&gt;死锁是并发系统很常见的一类问题。&lt;/p&gt;&lt;p&gt;死锁是指：两个或以上的运算单元，每一方都在等待其他方释放资源，但是所有方都不愿意释放资源。结果是没有任何一方能继续推进下去，于是整个系统无法再继续运转。&lt;/p&gt;&lt;p&gt;死锁在现实中也很常见，例如：两个孩子分别拿着玩具的一半然后哭着要从对方手里得到另外一半玩具，但是谁都不肯让步。&lt;/p&gt;&lt;p&gt;在成年人的世界里也会发生类似的情况，例如下面这个交通状况：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7490909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/p3sYCQXkuHjYKzmrrIp1Pl8K5QoMztuELmFQZLSBkpzwySLbIAHpqoxkTBKOBdlcLPep7icryHViaf69zEQUHeeA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;550&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;下面我们来看一个编程示例。&lt;/p&gt;&lt;p&gt;现在假设我们在开发一个银行的系统，这个系统包含了转账的功能。&lt;/p&gt;&lt;p&gt;首先我们创建一个&lt;code&gt;Account&lt;/code&gt;类来描述银行账号。由于这仅仅是一个演示使用的代码，所以我们希望代码足够的简单。&lt;code&gt;Account&lt;/code&gt;类仅仅包含名称和金额两个字段。&lt;/p&gt;&lt;p&gt;另外，为了支持并发，这个类包含了一个&lt;code&gt;mutex&lt;/code&gt;对象，用来保护账号金额，在读写账号金额时需要先加锁保护。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 09_deadlock_bank_transfer.cpp&lt;br/&gt;&lt;br/&gt;class Account {&lt;br/&gt;public:&lt;br/&gt;  Account(string name, double money): mName(name), mMoney(money) {};&lt;br/&gt;&lt;br/&gt;public:&lt;br/&gt;  void changeMoney(double amount) {&lt;br/&gt;    mMoney += amount;&lt;br/&gt;  }&lt;br/&gt;  string getName() {&lt;br/&gt;    return mName;&lt;br/&gt;  }&lt;br/&gt;  double getMoney() {&lt;br/&gt;    return mMoney;&lt;br/&gt;  }&lt;br/&gt;  mutex* getLock() {&lt;br/&gt;    return &amp;amp;mMoneyLock;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;private:&lt;br/&gt;  string mName;&lt;br/&gt;  double mMoney;&lt;br/&gt;  mutex mMoneyLock;&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Account&lt;/code&gt;类很简单，我想就不用多做说明了。&lt;/p&gt;&lt;p&gt;接下来，我们再创建一个描述银行的&lt;code&gt;Bank&lt;/code&gt;类。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 09_deadlock_bank_transfer.cpp&lt;br/&gt;&lt;br/&gt;class Bank {&lt;br/&gt;public:&lt;br/&gt;  void addAccount(Account* account) {&lt;br/&gt;    mAccounts.insert(account);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  bool transferMoney(Account* accountA, Account* accountB, double amount) {&lt;br/&gt;    lock_guard guardA(*accountA-&amp;gt;getLock()); // ①&lt;br/&gt;    lock_guard guardB(*accountB-&amp;gt;getLock());&lt;br/&gt;&lt;br/&gt;    if (amount &amp;gt; accountA-&amp;gt;getMoney()) { // ②&lt;br/&gt;      return false;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    accountA-&amp;gt;changeMoney(-amount); // ③&lt;br/&gt;    accountB-&amp;gt;changeMoney(amount);&lt;br/&gt;    return true;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  double totalMoney() const {&lt;br/&gt;    double sum = 0;&lt;br/&gt;    for (auto a : mAccounts) {&lt;br/&gt;      sum += a-&amp;gt;getMoney();&lt;br/&gt;    }&lt;br/&gt;    return sum;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;private:&lt;br/&gt;  set&amp;lt;Account*&amp;gt; mAccounts;&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;银行类中记录了所有的账号，并且提供了一个方法用来查询整个银行的总金额。&lt;/p&gt;&lt;p&gt;这其中，我们最主要要关注转账的实现：&lt;code&gt;transferMoney&lt;/code&gt;。该方法的几个关键点如下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;为了保证线程安全，在修改每个账号之前，需要获取相应的锁。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;判断转出账户金额是否足够，如果不够此次转账失败。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;进行转账。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;有了银行和账户结构之后就可以开发转账系统了，同样的，由于是为了演示所用，我们的转账系统也会尽可能的简单：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 09_deadlock_bank_transfer.cpp&lt;br/&gt;&lt;br/&gt;void randomTransfer(Bank* bank, Account* accountA, Account* accountB) {&lt;br/&gt;  while(true) {&lt;br/&gt;    double randomMoney = ((double)rand() / RAND_MAX) * 100;&lt;br/&gt;    if (bank-&amp;gt;transferMoney(accountA, accountB, randomMoney)) {&lt;br/&gt;      cout &amp;lt;&amp;lt; &quot;Transfer &quot; &amp;lt;&amp;lt; randomMoney &amp;lt;&amp;lt; &quot; from &quot; &amp;lt;&amp;lt; accountA-&amp;gt;getName()&lt;br/&gt;           &amp;lt;&amp;lt; &quot; to &quot; &amp;lt;&amp;lt; accountB-&amp;gt;getName()&lt;br/&gt;           &amp;lt;&amp;lt; &quot;, Bank totalMoney: &quot; &amp;lt;&amp;lt; bank-&amp;gt;totalMoney() &amp;lt;&amp;lt; endl;&lt;br/&gt;    } else {&lt;br/&gt;      cout &amp;lt;&amp;lt; &quot;Transfer failed, &quot;&lt;br/&gt;           &amp;lt;&amp;lt; accountA-&amp;gt;getName() &amp;lt;&amp;lt; &quot; has only $&quot; &amp;lt;&amp;lt; accountA-&amp;gt;getMoney() &amp;lt;&amp;lt; &quot;, but &quot;&lt;br/&gt;           &amp;lt;&amp;lt; randomMoney &amp;lt;&amp;lt; &quot; required&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里每次生成一个随机数，然后通过银行进行转账。&lt;/p&gt;&lt;p&gt;最后我们在&lt;code&gt;main&lt;/code&gt;函数中创建两个线程，互相在两个账号之间来回转账：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 09_deadlock_bank_transfer.cpp&lt;br/&gt;&lt;br/&gt;int main() {&lt;br/&gt;  Account a(&quot;Paul&quot;, 100);&lt;br/&gt;  Account b(&quot;Moira&quot;, 100);&lt;br/&gt;&lt;br/&gt;  Bank aBank;&lt;br/&gt;  aBank.addAccount(&amp;amp;a);&lt;br/&gt;  aBank.addAccount(&amp;amp;b);&lt;br/&gt;&lt;br/&gt;  thread t1(randomTransfer, &amp;amp;aBank, &amp;amp;a, &amp;amp;b);&lt;br/&gt;  thread t2(randomTransfer, &amp;amp;aBank, &amp;amp;b, &amp;amp;a);&lt;br/&gt;&lt;br/&gt;  t1.join();&lt;br/&gt;  t2.join();&lt;br/&gt;&lt;br/&gt;  return 0;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此，我们的银行转账系统就开发完成了。然后编译并运行，其结果可能像下面这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;...&lt;br/&gt;Transfer 13.2901 from Paul to Moira, Bank totalMoney: 20042.6259 from Moira to Paul, Bank totalMoney: 200&lt;br/&gt;Transfer failed, Moira has only $34.7581, but 66.3208 required&lt;br/&gt;Transfer failed, Moira has only $34.7581, but &lt;br/&gt;Transfer 93.191 from 53.9176 required&lt;br/&gt;Transfer 60.6146 from Moira to Paul, Bank totalMoney: 200&lt;br/&gt;Transfer 49.7304 from Moira to Paul, Bank totalMoney: 200Paul to Moira, Bank totalMoney: &lt;br/&gt;Transfer failed, Moira has only $17.6041, but 18.1186 required&lt;br/&gt;Transfer failed, Moira has only $17.6041, but 18.893 required&lt;br/&gt;Transfer failed, Moira has only $17.6041, but 34.7078 required&lt;br/&gt;Transfer failed, Moira has only $17.6041, but 33.9569 required&lt;br/&gt;Transfer 12.7899 from 200&lt;br/&gt;Moira to Paul, Bank totalMoney: 200&lt;br/&gt;Transfer failed, Moira has only $63.9373, but 80.9038 required&lt;br/&gt;Transfer 50.933 from Moira to Paul, Bank totalMoney: 200&lt;br/&gt;Transfer failed, Moira has only $13.0043, but 30.2056 required&lt;br/&gt;Transfer failed, Moira has only $Transfer 59.123 from Paul to Moira, Bank totalMoney: 200&lt;br/&gt;Transfer 29.0486 from Paul to Moira, Bank totalMoney: 20013.0043, but 64.7307 required&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你运行了这个程序，你会发现很快它就卡住不动了。为什么？&lt;/p&gt;&lt;p&gt;因为发生了死锁。&lt;/p&gt;&lt;p&gt;我们仔细思考一下这两个线程的逻辑：这两个线程可能会同时获取其中一个账号的锁，然后又想获取另外一个账号的锁，此时就发生了死锁。如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32592592592592595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjYKzmrrIp1Pl8K5QoMztuEYF19hkfoxuX0Q6ccWueYdjEOYplrzaWP6zUzeH4McngmfI09xJrPRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当然，发生死锁的原因远不止上面这一种情况。如果两个线程互相&lt;code&gt;join&lt;/code&gt;就可能发生死锁。还有在一个线程中对一个不可重入的互斥体（例如&lt;code&gt;mutex&lt;/code&gt;而非&lt;code&gt;recursive_mutex&lt;/code&gt;）多次加锁也会死锁。&lt;/p&gt;&lt;p&gt;你可能会觉得，我可不会这么傻，写出这样的代码。但实际上，很多时候是由于代码的深层次嵌套导致了死锁的发生，由于调用关系的复杂导致发现这类问题并不容易。&lt;/p&gt;&lt;p&gt;如果仔细看一下上面的输出，我们会发现还有另外一个问题：这里的输出是乱的。两个线程的输出混杂在一起了。究其原因也很容易理解：两个线程可能会同时输出，没有做好隔离。&lt;/p&gt;&lt;p&gt;下面我们就来逐步解决上面的问题。&lt;/p&gt;&lt;p&gt;对于输出混乱的问题很好解决，专门用一把锁来保护输出逻辑即可：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 10_improved_bank_transfer.cpp&lt;br/&gt;&lt;br/&gt;mutex sCoutLock;&lt;br/&gt;void randomTransfer(Bank* bank, Account* accountA, Account* accountB) {&lt;br/&gt;  while(true) {&lt;br/&gt;    double randomMoney = ((double)rand() / RAND_MAX) * 100;&lt;br/&gt;    if (bank-&amp;gt;transferMoney(accountA, accountB, randomMoney)) {&lt;br/&gt;      sCoutLock.lock();&lt;br/&gt;      cout &amp;lt;&amp;lt; &quot;Transfer &quot; &amp;lt;&amp;lt; randomMoney &amp;lt;&amp;lt; &quot; from &quot; &amp;lt;&amp;lt; accountA-&amp;gt;getName()&lt;br/&gt;          &amp;lt;&amp;lt; &quot; to &quot; &amp;lt;&amp;lt; accountB-&amp;gt;getName()&lt;br/&gt;          &amp;lt;&amp;lt; &quot;, Bank totalMoney: &quot; &amp;lt;&amp;lt; bank-&amp;gt;totalMoney() &amp;lt;&amp;lt; endl;&lt;br/&gt;      sCoutLock.unlock();&lt;br/&gt;    } else {&lt;br/&gt;      sCoutLock.lock();&lt;br/&gt;      cout &amp;lt;&amp;lt; &quot;Transfer failed, &quot;&lt;br/&gt;           &amp;lt;&amp;lt; accountA-&amp;gt;getName() &amp;lt;&amp;lt; &quot; has only &quot; &amp;lt;&amp;lt; accountA-&amp;gt;getMoney() &amp;lt;&amp;lt; &quot;, but &quot;&lt;br/&gt;           &amp;lt;&amp;lt; randomMoney &amp;lt;&amp;lt; &quot; required&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;      sCoutLock.unlock();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;请思考一下两处&lt;code&gt;lock&lt;/code&gt;和&lt;code&gt;unlock&lt;/code&gt;调用，并考虑为什么不在&lt;code&gt;while(true)&lt;/code&gt;下面写一次整体的加锁和解锁。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;通用锁定算法&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;主要API&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;API&lt;/td&gt;&lt;td&gt;C++标准&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;lock&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;锁定指定的互斥体，若任何一个不可用则阻塞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;try_lock&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;试图通过重复调用 try_lock 获得互斥体的所有权&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;要避免死锁，需要仔细的思考和设计业务逻辑。&lt;/p&gt;&lt;p&gt;有一个比较简单的原则可以避免死锁，即：对所有的锁进行排序，每次一定要按照顺序来获取锁，不允许乱序。例如：要获取某个玩具，一定要先拿到锁A，再拿到锁B，才能玩玩具。这样就不会死锁了。&lt;/p&gt;&lt;p&gt;这个原则虽然简单，但却不容易遵守。因为数据常常是分散在很多地方的。&lt;/p&gt;&lt;p&gt;不过好消息是，C++ 11标准中为我们提供了一些工具来避免因为多把锁而导致的死锁。我们只要直接调用这些接口就可以了。这个就是上面提到的两个函数。它们都支持传入多个&lt;span&gt;Lockable&lt;/span&gt;对象。&lt;/p&gt;&lt;p&gt;接下来我们用它来改造之前死锁的转账系统：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 10_improved_bank_transfer.cpp&lt;br/&gt;&lt;br/&gt;bool transferMoney(Account* accountA, Account* accountB, double amount) {&lt;br/&gt;  lock(*accountA-&amp;gt;getLock(), *accountB-&amp;gt;getLock());    // ①&lt;br/&gt;  lock_guard lockA(*accountA-&amp;gt;getLock(), adopt_lock);  // ②&lt;br/&gt;  lock_guard lockB(*accountB-&amp;gt;getLock(), adopt_lock);  // ③&lt;br/&gt;&lt;br/&gt;  if (amount &amp;gt; accountA-&amp;gt;getMoney()) {&lt;br/&gt;    return false;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  accountA-&amp;gt;changeMoney(-amount);&lt;br/&gt;  accountB-&amp;gt;changeMoney(amount);&lt;br/&gt;  return true;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里只改动了3行代码。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;这里通过&lt;code&gt;lock&lt;/code&gt;函数来获取两把锁，标准库的实现会保证不会发生死锁。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;code&gt;lock_guard&lt;/code&gt;在下面我们还会详细介绍。这里只要知道它会在自身对象生命周期的范围内锁定互斥体即可。创建&lt;code&gt;lock_guard&lt;/code&gt;的目的是为了在&lt;code&gt;transferMoney&lt;/code&gt;结束的时候释放锁，&lt;code&gt;lockB&lt;/code&gt;也是一样。但需要注意的是，这里传递了 &lt;code&gt;adopt_lock&lt;/code&gt;表示：现在是已经获取到互斥体了的状态了，不用再次加锁（如果不加&lt;code&gt;adopt_lock&lt;/code&gt;就是二次锁定了）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;运行一下这个改造后的程序，其输出如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;...&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 17.5974 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 59.2104 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 49.6379 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 63.6373 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 51.8742 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 50.0081 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 86.1041 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 51.3278 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 66.5754 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 32.1867 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 62.0039 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 98.7819 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 27.046 required&lt;br/&gt;Transfer failed, Paul has only $1.76243, but 62.9155 required&lt;br/&gt;Transfer 98.8478 from Moira to Paul, Bank totalMoney: 200&lt;br/&gt;Transfer 80.0722 from Moira to Paul, Bank totalMoney: 200&lt;br/&gt;Transfer 73.7035 from Moira to Paul, Bank totalMoney: 200&lt;br/&gt;Transfer 34.4476 from Moira to Paul, Bank totalMoney: 200&lt;br/&gt;Transfer failed, Moira has only $10.0142, but 61.3033 required&lt;br/&gt;Transfer failed, Moira has only $10.0142, but 24.5595 required&lt;br/&gt;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在这个转账程序会一直运行下去，不会再死锁了。输出也是正常的了。&lt;/p&gt;&lt;h2&gt;通用互斥管理&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;主要API&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;API&lt;/td&gt;&lt;td&gt;C++标准&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;lock_guard&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;实现严格基于作用域的互斥体所有权包装器&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;unique_lock&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;实现可移动的互斥体所有权包装器&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;shared_lock&lt;/td&gt;&lt;td&gt;C++14&lt;/td&gt;&lt;td&gt;实现可移动的共享互斥体所有权封装器&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;scoped_lock&lt;/td&gt;&lt;td&gt;C++17&lt;/td&gt;&lt;td&gt;用于多个互斥体的免死锁 RAII 封装器&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;锁定策略&lt;/td&gt;&lt;td&gt;C++标准&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;defer_lock&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;类型为 &lt;code&gt;defer_lock_t&lt;/code&gt;，不获得互斥的所有权&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;try_to_lock&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;类型为&lt;code&gt;try_to_lock_t&lt;/code&gt;，尝试获得互斥的所有权而不阻塞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;adopt_lock&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;类型为&lt;code&gt;adopt_lock_t&lt;/code&gt;，假设调用方已拥有互斥的所有权&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;互斥体（&lt;code&gt;mutex&lt;/code&gt;相关类）提供了对于资源的保护功能，但是手动的锁定（调用&lt;code&gt;lock&lt;/code&gt;或者&lt;code&gt;try_lock&lt;/code&gt;）和解锁（调用&lt;code&gt;unlock&lt;/code&gt;）互斥体是要耗费比较大的精力的，我们需要精心考虑和设计代码才行。因为我们需要保证，在任何情况下，解锁要和加锁配对，因为假设出现一条路径导致获取锁之后没有正常释放，就会影响整个系统。如果考虑方法还可以会抛出异常，这样的代码写起来会很费劲。&lt;/p&gt;&lt;p&gt;鉴于这个原因，标准库就提供了上面的这些API。它们都使用了叫做RAII的编程技巧，来简化我们手动加锁和解锁的“体力活”。&lt;/p&gt;&lt;p&gt;请看下面的例子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// https://en.cppreference.com/w/cpp/thread/lock_guard&lt;br/&gt;&lt;br/&gt;#include &amp;lt;thread&amp;gt;&lt;br/&gt;#include &amp;lt;mutex&amp;gt;&lt;br/&gt;#include &amp;lt;iostream&amp;gt;&lt;br/&gt; &lt;br/&gt;int g_i = 0;&lt;br/&gt;std::mutex g_i_mutex;  // ①&lt;br/&gt; &lt;br/&gt;void safe_increment()&lt;br/&gt;{&lt;br/&gt;  std::lock_guard&amp;lt;std::mutex&amp;gt; lock(g_i_mutex);  // ②&lt;br/&gt;  ++g_i;&lt;br/&gt;&lt;br/&gt;  std::cout &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; g_i &amp;lt;&amp;lt; &#x27;\n&#x27;;&lt;br/&gt;  // ③&lt;br/&gt;}&lt;br/&gt; &lt;br/&gt;int main()&lt;br/&gt;{&lt;br/&gt;  std::cout &amp;lt;&amp;lt; &quot;main: &quot; &amp;lt;&amp;lt; g_i &amp;lt;&amp;lt; &#x27;\n&#x27;;&lt;br/&gt; &lt;br/&gt;  std::thread t1(safe_increment); // ④&lt;br/&gt;  std::thread t2(safe_increment);&lt;br/&gt; &lt;br/&gt;  t1.join();&lt;br/&gt;  t2.join();&lt;br/&gt; &lt;br/&gt;  std::cout &amp;lt;&amp;lt; &quot;main: &quot; &amp;lt;&amp;lt; g_i &amp;lt;&amp;lt; &#x27;\n&#x27;;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码中：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;全局的互斥体&lt;code&gt;g_i_mutex&lt;/code&gt;用来保护全局变量&lt;code&gt;g_i&lt;/code&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;这是一个设计为可以被多线程环境使用的方法。因此需要通过互斥体来进行保护。这里没有调用&lt;code&gt;lock&lt;/code&gt;方法，而是直接使用&lt;code&gt;lock_guard&lt;/code&gt;来锁定互斥体。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;在方法结束的时候，局部变量&lt;code&gt;std::lock_guard&amp;lt;std::mutex&amp;gt; lock&lt;/code&gt;会被销毁，它对互斥体的锁定也就解除了。&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;在多个线程中使用这个方法。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;RAII&lt;/h3&gt;&lt;p&gt;上面的几个类（&lt;code&gt;lock_guard&lt;/code&gt;，&lt;code&gt;unique_lock&lt;/code&gt;，&lt;code&gt;shared_lock&lt;/code&gt;，&lt;code&gt;scoped_lock&lt;/code&gt;）都使用了一个叫做RAII的编程技巧。&lt;/p&gt;&lt;p&gt;RAII全称是Resource Acquisition Is Initialization，直译过来就是：资源获取即初始化。&lt;/p&gt;&lt;p&gt;RAII是一种&lt;span&gt;C++编程技术&lt;/span&gt;，它将必须在使用前请求的资源（例如：分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存周期相绑定。RAII保证资源可用于任何会访问该对象的函数。它亦保证所有资源在其控制对象的生存期结束时，以获取顺序的逆序释放。类似地，若资源获取失败（构造函数以异常退出），则为已构造完成的对象和基类子对象所获取的所有资源，会以初始化顺序的逆序释放。这有效地利用了语言特性以消除内存泄漏并保证异常安全。&lt;/p&gt;&lt;p&gt;RAII 可总结如下:&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;将每个资源封装入一个类，其中：&lt;span&gt;&lt;span&gt;•&lt;/span&gt;构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;析构函数释放资源并决不抛出异常；&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;始终经由 RAII 类的实例使用满足要求的资源，该资源&lt;span&gt;&lt;span&gt;•&lt;/span&gt;自身拥有自动存储期或临时生存期，或&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;具有与自动或临时对象的生存期绑定的生存期&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;回想一下上文中的&lt;code&gt;transferMoney&lt;/code&gt;方法中的三行代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lock(*accountA-&amp;gt;getLock(), *accountB-&amp;gt;getLock());&lt;br/&gt;lock_guard lockA(*accountA-&amp;gt;getLock(), adopt_lock);&lt;br/&gt;lock_guard lockB(*accountB-&amp;gt;getLock(), adopt_lock);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果使用&lt;code&gt;unique_lock&lt;/code&gt;这三行代码还有一种等价的写法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;unique_lock lockA(*accountA-&amp;gt;getLock(), defer_lock);&lt;br/&gt;unique_lock lockB(*accountB-&amp;gt;getLock(), defer_lock);&lt;br/&gt;lock(*accountA-&amp;gt;getLock(), *accountB-&amp;gt;getLock());&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请注意这里&lt;code&gt;lock&lt;/code&gt;方法的调用位置。这里先定义&lt;code&gt;unique_lock&lt;/code&gt;指定了&lt;code&gt;defer_lock&lt;/code&gt;，因此实际没有锁定互斥体，而是到第三行才进行锁定。&lt;/p&gt;&lt;p&gt;最后，借助&lt;code&gt;scoped_lock&lt;/code&gt;，我们可以将三行代码合成一行，这种写法也是等价的。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;scoped_lock lockAll(*accountA-&amp;gt;getLock(), *accountB-&amp;gt;getLock());&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;scoped_lock&lt;/code&gt;会在其生命周期范围内锁定互斥体，销毁的时候解锁。同时，它可以锁定多个互斥体，并且避免死锁。&lt;/p&gt;&lt;p&gt;目前，只还有&lt;code&gt;shared_lock&lt;/code&gt;我们没有提到。它与其他几个类的区别在于：它是以共享的方式锁定互斥体。&lt;/p&gt;&lt;h2&gt;条件变量&lt;/h2&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;API&lt;/td&gt;&lt;td&gt;C++标准&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;condition_variable&lt;/td&gt;&lt;td&gt;C++ 11&lt;/td&gt;&lt;td&gt;提供与 std::unique_lock 关联的条件变量&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;condition_variable_any&lt;/td&gt;&lt;td&gt;C++ 11&lt;/td&gt;&lt;td&gt;提供与任何锁类型关联的条件变量&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;notify_all_at_thread_exit&lt;/td&gt;&lt;td&gt;C++ 11&lt;/td&gt;&lt;td&gt;安排到在此线程完全结束时对 notify_all 的调用&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;cv_status&lt;/td&gt;&lt;td&gt;C++ 11&lt;/td&gt;&lt;td&gt;列出条件变量上定时等待的可能结果&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;至此，我们还有一个地方可以改进。那就是：转账金额不足的时候，程序直接返回了&lt;code&gt;false&lt;/code&gt;。这很难说是一个好的策略。因为，即便虽然当前账号金额不足以转账，但只要别的账号又转账进来之后，当前这个转账操作也许就可以继续执行了。&lt;/p&gt;&lt;p&gt;这在很多业务中是很常见的一个需求：每一次操作都要正确执行，如果条件不满足就停下来等待，直到条件满足之后再继续。而不是直接返回。&lt;/p&gt;&lt;p&gt;条件变量提供了一个可以让多个线程间同步协作的功能。这对于&lt;span&gt;生产者-消费者模型&lt;/span&gt;很有意义。在这个模型下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;生产者和消费者共享一个工作区。这个区间的大小是有限的。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;生产者总是产生数据放入工作区中，当工作区满了。它就停下来等消费者消费一部分数据，然后继续工作。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;消费者总是从工作区中拿出数据使用。当工作区中的数据全部被消费空了之后，它也会停下来等待生产者往工作区中放入新的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从上面可以看到，无论是生产者还是消费者，当它们工作的条件不满足时，它们并不是直接报错返回，而是停下来等待，直到条件满足。&lt;/p&gt;&lt;p&gt;下面我们就借助于条件变量，再次改造之前的银行转账系统。&lt;/p&gt;&lt;p&gt;这个改造主要在于账号类。我们重点是要调整&lt;code&gt;changeMoney&lt;/code&gt;方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 11_bank_transfer_wait_notify.cpp&lt;br/&gt;&lt;br/&gt;class Account {&lt;br/&gt;public:&lt;br/&gt;  Account(string name, double money): mName(name), mMoney(money) {};&lt;br/&gt;&lt;br/&gt;public:&lt;br/&gt;  void changeMoney(double amount) {&lt;br/&gt;    unique_lock lock(mMoneyLock); // ②&lt;br/&gt;    mConditionVar.wait(lock, [this, amount] { // ③&lt;br/&gt;      return mMoney + amount &amp;gt; 0; // ④&lt;br/&gt;    });&lt;br/&gt;    mMoney += amount;&lt;br/&gt;    mConditionVar.notify_all(); // ⑤&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  string getName() {&lt;br/&gt;    return mName;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  double getMoney() {&lt;br/&gt;    return mMoney;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;private:&lt;br/&gt;  string mName;&lt;br/&gt;  double mMoney;&lt;br/&gt;  mutex mMoneyLock;&lt;br/&gt;  condition_variable mConditionVar; // ①&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这几处改动说明如下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;这里声明了一个条件变量，用来在多个线程之间协作。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;这里使用的是&lt;code&gt;unique_lock&lt;/code&gt;，这是为了与条件变量相配合。因为条件变量会解锁和重新锁定互斥体。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;这里是比较重要的一个地方：通过条件变量进行等待。此时：会通过后面的lambda表达式判断条件是否满足。如果满足则继续；如果不满足，则&lt;strong&gt;此处会解锁互斥体，并让当前线程等待&lt;/strong&gt;。&lt;strong&gt;解锁&lt;/strong&gt;这一点非常重要，因为只有这样，才能让其他线程获取互斥体。&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;这里是条件变量等待的条件。如果你不熟悉lambda表达式，请自行网上学习，或者阅读&lt;span&gt;我之前写的文章&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;此处也很重要。当金额发生变动之后，我们需要通知所有在条件变量上等待的其他线程。此时所有调用&lt;code&gt;wait&lt;/code&gt;线程都会再次唤醒，然后尝试获取锁（当然，只有一个能获取到）并再次判断条件是否满足。除了&lt;code&gt;notify_all&lt;/code&gt;还有&lt;code&gt;notify_one&lt;/code&gt;，它只通知一个等待的线程。&lt;code&gt;wait&lt;/code&gt;和&lt;code&gt;notify&lt;/code&gt;就构成了线程间互相协作的工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;请注意：&lt;code&gt;wait&lt;/code&gt;和&lt;code&gt;notify_all&lt;/code&gt;虽然是写在一个函数中的，但是在运行时它们是在多线程环境中执行的，因此对于这段代码，需要能够从不同线程的角度去思考代码的逻辑。这也是开发并发系统比较难的地方。&lt;/p&gt;&lt;p&gt;有了上面的改动之后，银行的转账方法实现起来就很简单了，不用再考虑数据保护的问题了：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 11_bank_transfer_wait_notify.cpp&lt;br/&gt;&lt;br/&gt;void Bank::transferMoney(Account* accountA, Account* accountB, double amount) {&lt;br/&gt;    accountA-&amp;gt;changeMoney(-amount);&lt;br/&gt;    accountB-&amp;gt;changeMoney(amount);&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，转账逻辑也会变得简单，不用再管转账失败的情况发生。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 11_bank_transfer_wait_notify.cpp&lt;br/&gt;&lt;br/&gt;mutex sCoutLock;&lt;br/&gt;void randomTransfer(Bank* bank, Account* accountA, Account* accountB) {&lt;br/&gt;  while(true) {&lt;br/&gt;    double randomMoney = ((double)rand() / RAND_MAX) * 100;&lt;br/&gt;    {&lt;br/&gt;      lock_guard guard(sCoutLock);&lt;br/&gt;      cout &amp;lt;&amp;lt; &quot;Try to Transfer &quot; &amp;lt;&amp;lt; randomMoney&lt;br/&gt;           &amp;lt;&amp;lt; &quot; from &quot; &amp;lt;&amp;lt; accountA-&amp;gt;getName() &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; accountA-&amp;gt;getMoney()&lt;br/&gt;           &amp;lt;&amp;lt; &quot;) to &quot; &amp;lt;&amp;lt; accountB-&amp;gt;getName() &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; accountB-&amp;gt;getMoney()&lt;br/&gt;           &amp;lt;&amp;lt; &quot;), Bank totalMoney: &quot; &amp;lt;&amp;lt; bank-&amp;gt;totalMoney() &amp;lt;&amp;lt; endl;&lt;br/&gt;    }&lt;br/&gt;    bank-&amp;gt;transferMoney(accountA, accountB, randomMoney);&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改完之后的程序运行输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;...&lt;br/&gt;Try to Transfer 13.72 from Moira(10.9287) to Paul(189.071), Bank totalMoney: 200&lt;br/&gt;Try to Transfer 28.6579 from Paul(189.071) to Moira(10.9287), Bank totalMoney: 200&lt;br/&gt;Try to Transfer 91.8049 from Paul(160.413) to Moira(39.5866), Bank totalMoney: 200&lt;br/&gt;Try to Transfer 5.56383 from Paul(82.3285) to Moira(117.672), Bank totalMoney: 200&lt;br/&gt;Try to Transfer 11.3594 from Paul(76.7646) to Moira(123.235), Bank totalMoney: 200&lt;br/&gt;Try to Transfer 16.9557 from Paul(65.4053) to Moira(134.595), Bank totalMoney: 200&lt;br/&gt;Try to Transfer 74.998 from Paul(48.4495) to Moira(151.55), Bank totalMoney: 200&lt;br/&gt;Try to Transfer 65.3005 from Moira(151.55) to Paul(48.4495), Bank totalMoney: 200&lt;br/&gt;Try to Transfer 90.6084 from Moira(86.25) to Paul(113.75), Bank totalMoney: 125.002&lt;br/&gt;Try to Transfer 99.6425 from Moira(70.6395) to Paul(129.36), Bank totalMoney: 200&lt;br/&gt;Try to Transfer 55.2091 from Paul(129.36) to Moira(70.6395), Bank totalMoney: 200&lt;br/&gt;Try to Transfer 92.259 from Paul(74.1513) to Moira(125.849), Bank totalMoney: 200&lt;br/&gt;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这下比之前都要好了。&lt;/p&gt;&lt;p&gt;但是细心的读者会发现，Bank totalMoney的输出有时候是200，有时候不是。但不管怎样，即便这一次不是，下一次又是了。关于这一点，请读者自行思考一下为什么，以及如何改进。&lt;/p&gt;&lt;h2&gt;future&lt;/h2&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;API&lt;/td&gt;&lt;td&gt;C++标准&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;async&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;异步运行一个函数，并返回保有其结果的&lt;code&gt;std::future&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;future&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;等待被异步设置的值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;packaged_task&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;打包一个函数，存储其返回值以进行异步获取&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;promise&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;存储一个值以进行异步获取&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;shared_future&lt;/td&gt;&lt;td&gt;C++11&lt;/td&gt;&lt;td&gt;等待被异步设置的值（可能为其他 future 所引用）&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;这一小节中，我们来熟悉更多的可以在并发环境中使用的工具，它们都位于&lt;code&gt;&amp;lt;future&amp;gt;&lt;/code&gt;头文件中。&lt;/p&gt;&lt;h2&gt;async&lt;/h2&gt;&lt;p&gt;很多语言都提供了异步的机制。异步使得耗时的操作不影响当前主线程的执行流。&lt;/p&gt;&lt;p&gt;在C++11中，&lt;code&gt;async&lt;/code&gt;便是完成这样的功能的。下面是一个代码示例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 12_async_task.cpp&lt;br/&gt;&lt;br/&gt;static const int MAX = 10e8;&lt;br/&gt;static double sum = 0;&lt;br/&gt;&lt;br/&gt;void worker(int min, int max) {&lt;br/&gt;  for (int i = min; i &amp;lt;= max; i++) {&lt;br/&gt;    sum += sqrt(i);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;int main() {&lt;br/&gt;  sum = 0;&lt;br/&gt;  auto f1 = async(worker, 0, MAX);&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Async task triggered&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;  f1.wait();&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Async task finish, result: &quot; &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; endl;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这仍然是我们之前熟悉的例子。这里有两个地方需要说明：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;这里以异步的方式启动了任务。它会返回一个&lt;code&gt;future&lt;/code&gt;对象。&lt;code&gt;future&lt;/code&gt;用来存储异步任务的执行结果，关于&lt;code&gt;future&lt;/code&gt;我们在后面&lt;code&gt;packaged_task&lt;/code&gt;的例子中再详细说明。在这个例子中我们仅仅用它来等待任务执行完成。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;此处是等待异步任务执行完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;需要注意的是，默认情况下，&lt;code&gt;async&lt;/code&gt;是启动一个新的线程，还是以同步的方式（不启动新的线程）运行任务，这一点标准是没有指定的，由具体的编译器决定。如果希望一定要以新的线程来异步执行任务，可以通过&lt;code&gt;launch::async&lt;/code&gt;来明确说明。&lt;code&gt;launch&lt;/code&gt;中有两个常量：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;async&lt;/code&gt;：运行新线程，以异步执行任务。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;deferred&lt;/code&gt;：调用方线程上第一次请求其结果时才执行任务，即惰性求值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;除了通过函数来指定异步任务，还可以lambda表达式的方式来指定。如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 12_async_task.cpp&lt;br/&gt;&lt;br/&gt;int main() {&lt;br/&gt;&lt;br/&gt;  double result = 0;&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Async task with lambda triggered, thread: &quot; &amp;lt;&amp;lt; this_thread::get_id() &amp;lt;&amp;lt; endl;&lt;br/&gt;  auto f2 = async(launch::async, [&amp;amp;result]() {&lt;br/&gt;    cout &amp;lt;&amp;lt; &quot;Lambda task in thread: &quot; &amp;lt;&amp;lt; this_thread::get_id() &amp;lt;&amp;lt; endl;&lt;br/&gt;    for (int i = 0; i &amp;lt;= MAX; i++) {&lt;br/&gt;      result += sqrt(i);&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;  f2.wait();&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Async task with lambda finish, result: &quot; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; endl;&lt;br/&gt;  &lt;br/&gt;  return 0;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上面这段代码中，我们使用一个lambda表达式来编写异步任务的逻辑，并通过&lt;code&gt;launch::async&lt;/code&gt;明确指定要通过独立的线程来执行任务，同时我们打印出了线程的id。&lt;/p&gt;&lt;p&gt;这段代码输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Async task with lambda triggered, thread: 0x11290d5c0&lt;br/&gt;Lambda task in thread: 0x700007aa1000&lt;br/&gt;Async task with lambda finish, result: 2.10819e+13&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于面向对象编程来说，很多时候肯定希望以对象的方法来指定异步任务。下面是一个示例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 12_async_task.cpp&lt;br/&gt;&lt;br/&gt;class Worker {&lt;br/&gt;public:&lt;br/&gt;  Worker(int min, int max): mMin(min), mMax(max) {} // ①&lt;br/&gt;  double work() { // ②&lt;br/&gt;    mResult = 0;&lt;br/&gt;    for (int i = mMin; i &amp;lt;= mMax; i++) {&lt;br/&gt;      mResult += sqrt(i);&lt;br/&gt;    }&lt;br/&gt;    return mResult;&lt;br/&gt;  }&lt;br/&gt;  double getResult() {&lt;br/&gt;    return mResult;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;private:&lt;br/&gt;  int mMin;&lt;br/&gt;  int mMax;&lt;br/&gt;  double mResult;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;int main() {&lt;br/&gt;  Worker w(0, MAX);&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Task in class triggered&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;  auto f3 = async(&amp;amp;Worker::work, &amp;amp;w); // ③&lt;br/&gt;  f3.wait();&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Task in class finish, result: &quot; &amp;lt;&amp;lt; w.getResult() &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; endl;&lt;br/&gt;&lt;br/&gt;  return 0;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码有三处需要说明：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;这里通过一个类来描述任务。这个类是对前面提到的任务的封装。它包含了任务的输入参数，和输出结果。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;code&gt;work&lt;/code&gt;函数是任务的主体逻辑。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;通过&lt;code&gt;async&lt;/code&gt;执行任务：这里指定了具体的任务函数以及相应的对象。请注意这里是&lt;code&gt;&amp;amp;w&lt;/code&gt;，因此传递的是对象的指针。如果不写&lt;code&gt;&amp;amp;&lt;/code&gt;将传入&lt;code&gt;w&lt;/code&gt;对象的临时复制。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;packaged_task&lt;/h2&gt;&lt;p&gt;在一些业务中，我们可能会有很多的任务需要调度。这时我们常常会设计出任务队列和线程池的结构。此时，就可以使用&lt;code&gt;packaged_task&lt;/code&gt;来包装任务。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果你了解设计模式，你应该会知道&lt;span&gt;命令模式&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;packaged_task&lt;/code&gt;绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的&lt;code&gt;future&lt;/code&gt;来获取任务的结果。调度程序只需要处理&lt;code&gt;packaged_task&lt;/code&gt;，而非各个函数。&lt;/p&gt;&lt;p&gt;&lt;code&gt;packaged_task&lt;/code&gt;对象是一个可调用对象，它可以被封装成一个&lt;code&gt;std::fucntion&lt;/code&gt;，或者作为线程函数传递给&lt;code&gt;std::thread&lt;/code&gt;，或者直接调用。&lt;/p&gt;&lt;p&gt;下面是一个代码示例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 13_packaged_task.cpp&lt;br/&gt;&lt;br/&gt;double concurrent_worker(int min, int max) {&lt;br/&gt;  double sum = 0;&lt;br/&gt;  for (int i = min; i &amp;lt;= max; i++) {&lt;br/&gt;    sum += sqrt(i);&lt;br/&gt;  }&lt;br/&gt;  return sum;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;double concurrent_task(int min, int max) {&lt;br/&gt;  vector&amp;lt;future&amp;lt;double&amp;gt;&amp;gt; results; // ①&lt;br/&gt;&lt;br/&gt;  unsigned concurrent_count = thread::hardware_concurrency();&lt;br/&gt;  min = 0;&lt;br/&gt;  for (int i = 0; i &amp;lt; concurrent_count; i++) { // ②&lt;br/&gt;    packaged_task&amp;lt;double(int, int)&amp;gt; task(concurrent_worker); // ③&lt;br/&gt;    results.push_back(task.get_future()); // ④&lt;br/&gt;&lt;br/&gt;    int range = max / concurrent_count * (i + 1);&lt;br/&gt;    thread t(std::move(task), min, range); // ⑤&lt;br/&gt;    t.detach();&lt;br/&gt;&lt;br/&gt;    min = range + 1;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;threads create finish&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;  double sum = 0;&lt;br/&gt;  for (auto&amp;amp; r : results) {&lt;br/&gt;    sum += r.get(); // ⑥&lt;br/&gt;  }&lt;br/&gt;  return sum;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;int main() {&lt;br/&gt;  auto start_time = chrono::steady_clock::now();&lt;br/&gt;&lt;br/&gt;  double r = concurrent_task(0, MAX);&lt;br/&gt;&lt;br/&gt;  auto end_time = chrono::steady_clock::now();&lt;br/&gt;  auto ms = chrono::duration_cast&amp;lt;chrono::milliseconds&amp;gt;(end_time - start_time).count();&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Concurrent task finish, &quot; &amp;lt;&amp;lt; ms &amp;lt;&amp;lt; &quot; ms consumed, Result: &quot; &amp;lt;&amp;lt; r &amp;lt;&amp;lt; endl;&lt;br/&gt;  return 0;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这段代码中：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;首先创建一个集合来存储&lt;code&gt;future&lt;/code&gt;对象。我们将用它来获取任务的结果。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;同样的，根据CPU的情况来创建线程的数量。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;将任务包装成&lt;code&gt;packaged_task&lt;/code&gt;。请注意，由于&lt;code&gt;concurrent_worker&lt;/code&gt;被包装成了任务，我们无法直接获取它的&lt;code&gt;return&lt;/code&gt;值。而是要通过&lt;code&gt;future&lt;/code&gt;对象来获取。&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;获取任务关联的&lt;code&gt;future&lt;/code&gt;对象，并将其存入集合中。&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;通过一个新的线程来执行任务，并传入需要的参数。&lt;/span&gt;&lt;span&gt;&lt;span&gt;6.&lt;/span&gt;通过&lt;code&gt;future&lt;/code&gt;集合，逐个获取每个任务的计算结果，将其累加。这里&lt;code&gt;r.get()&lt;/code&gt;获取到的就是每个任务中&lt;code&gt;concurrent_worker&lt;/code&gt;的返回值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;为了简单起见，这里的示例只使用了我们熟悉的例子和结构。但在实际上的工程中，调用关系通常更复杂，你可以借助于&lt;code&gt;packaged_task&lt;/code&gt;将任务组装成队列，然后通过&lt;span&gt;线程池&lt;/span&gt;的方式进行调度：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5172413793103449&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/r48cSSlr7jgrxjXOcVU3OCFtvXjMayYoysMK8pH4gegaALWUibNucic4b2opqiaxc6h6ibJTjXW1ibj6jEAPadHSj6R1x9sdbnbNn/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;580&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;promise与future&lt;/h2&gt;&lt;p&gt;在上面的例子中，&lt;code&gt;concurrent_task&lt;/code&gt;的结果是通过&lt;code&gt;return&lt;/code&gt;返回的。但在一些时候，我们可能不能这么做：在得到任务结果之后，可能还有一些事情需要继续处理，例如清理工作。&lt;/p&gt;&lt;p&gt;这个时候，就可以将&lt;code&gt;promise&lt;/code&gt;与&lt;code&gt;future&lt;/code&gt;配对使用。这样就可以将返回结果和任务结束两个事情分开。&lt;/p&gt;&lt;p&gt;下面是对上面代码示例的改写：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 14_promise_future.cpp&lt;br/&gt;&lt;br/&gt;double concurrent_worker(int min, int max) {&lt;br/&gt;  double sum = 0;&lt;br/&gt;  for (int i = min; i &amp;lt;= max; i++) {&lt;br/&gt;    sum += sqrt(i);&lt;br/&gt;  }&lt;br/&gt;  return sum;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;void concurrent_task(int min, int max, promise&amp;lt;double&amp;gt;* result) { // ①&lt;br/&gt;  vector&amp;lt;future&amp;lt;double&amp;gt;&amp;gt; results;&lt;br/&gt;&lt;br/&gt;  unsigned concurrent_count = thread::hardware_concurrency();&lt;br/&gt;  min = 0;&lt;br/&gt;  for (int i = 0; i &amp;lt; concurrent_count; i++) {&lt;br/&gt;    packaged_task&amp;lt;double(int, int)&amp;gt; task(concurrent_worker);&lt;br/&gt;    results.push_back(task.get_future()); &lt;br/&gt;&lt;br/&gt;    int range = max / concurrent_count * (i + 1);&lt;br/&gt;    thread t(std::move(task), min, range);&lt;br/&gt;    t.detach();&lt;br/&gt;&lt;br/&gt;    min = range + 1;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;threads create finish&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;  double sum = 0;&lt;br/&gt;  for (auto&amp;amp; r : results) {&lt;br/&gt;    sum += r.get();&lt;br/&gt;  }&lt;br/&gt;  result-&amp;gt;set_value(sum); // ②&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;concurrent_task finish&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;int main() {&lt;br/&gt;  auto start_time = chrono::steady_clock::now();&lt;br/&gt;&lt;br/&gt;  promise&amp;lt;double&amp;gt; sum; // ③&lt;br/&gt;  concurrent_task(0, MAX, &amp;amp;sum);&lt;br/&gt;&lt;br/&gt;  auto end_time = chrono::steady_clock::now();&lt;br/&gt;  auto ms = chrono::duration_cast&amp;lt;chrono::milliseconds&amp;gt;(end_time - start_time).count();&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Concurrent task finish, &quot; &amp;lt;&amp;lt; ms &amp;lt;&amp;lt; &quot; ms consumed.&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Result: &quot; &amp;lt;&amp;lt; sum.get_future().get() &amp;lt;&amp;lt; endl; // ④&lt;br/&gt;  return 0;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码和上面的示例在很大程度上是一样的。只有小部分内容做了改动：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;&lt;code&gt;concurrent_task&lt;/code&gt;不再直接返回计算结果，而是增加了一个&lt;code&gt;promise&lt;/code&gt;对象来存放结果。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;在任务计算完成之后，将总结过设置到&lt;code&gt;promise&lt;/code&gt;对象上。一旦这里调用了&lt;code&gt;set_value&lt;/code&gt;，其相关联的&lt;code&gt;future&lt;/code&gt;对象就会就绪。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;这里是在&lt;code&gt;main&lt;/code&gt;中创建一个&lt;code&gt;promoise&lt;/code&gt;来存放结果，并以指针的形式传递进&lt;code&gt;concurrent_task&lt;/code&gt;中。&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;通过&lt;code&gt;sum.get_future().get()&lt;/code&gt;来获取结果。第2点中已经说了：一旦调用了&lt;code&gt;set_value&lt;/code&gt;，其相关联的&lt;code&gt;future&lt;/code&gt;对象就会就绪。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;需要注意的是，&lt;code&gt;future&lt;/code&gt;对象只有被一个线程获取值。并且在调用&lt;code&gt;get()&lt;/code&gt;之后，就没有可以获取的值了。如果从多个线程调用&lt;code&gt;get()&lt;/code&gt;会出现数据竞争，其结果是未定义的。&lt;/p&gt;&lt;p&gt;如果真的需要在多个线程中获取&lt;code&gt;future&lt;/code&gt;的结果，可以使用&lt;code&gt;shared_future&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;并行算法&lt;/h2&gt;&lt;p&gt;从C++17开始。&lt;span&gt;&lt;algorithm/&gt;&lt;/span&gt;和&lt;span&gt;&lt;numeric/&gt;&lt;/span&gt; 头文件的中的很多算法都添加了一个新的参数：&lt;code&gt;sequenced_policy&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;借助这个参数，开发者可以直接使用这些算法的并行版本，不用再自己创建并发系统和划分数据来调度这些算法。&lt;/p&gt;&lt;p&gt;&lt;code&gt;sequenced_policy&lt;/code&gt;可能的取值有三种，它们的说明如下：&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;变量&lt;/td&gt;&lt;td&gt;类型&lt;/td&gt;&lt;td&gt;C++版本&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;execution::seq&lt;/td&gt;&lt;td&gt;execution::sequenced_policy&lt;/td&gt;&lt;td&gt;C++17&lt;/td&gt;&lt;td&gt;要求并行算法的执行可以不并行化&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;execution::par&lt;/td&gt;&lt;td&gt;execution::parallel_policy&lt;/td&gt;&lt;td&gt;C++17&lt;/td&gt;&lt;td&gt;指示并行算法的执行可以并行化&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;execution::par_unseq&lt;/td&gt;&lt;td&gt;execution::parallel_unsequenced_policy&lt;/td&gt;&lt;td&gt;C++17&lt;/td&gt;&lt;td&gt;指示并行算法的执行可以并行化、向量化&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;注意：&lt;span&gt;本文的前面&lt;/span&gt;已经提到，目前clang编译器还不支持这个功能。因此想要编译这部分代码，你需要使用gcc 9.0或更高版本，同时还需要安装&lt;span&gt;Intel Threading Building Blocks&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;下面还是通过一个示例来进行说明：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 15_parallel_algorithm.cpp&lt;br/&gt;&lt;br/&gt;void generateRandomData(vector&amp;lt;double&amp;gt;&amp;amp; collection, int size) {&lt;br/&gt;  random_device rd;&lt;br/&gt;  mt19937 mt(rd());&lt;br/&gt;  uniform_real_distribution&amp;lt;double&amp;gt; dist(1.0, 100.0);&lt;br/&gt;  for (int i = 0; i &amp;lt; size; i++) {&lt;br/&gt;    collection.push_back(dist(mt));&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;int main() {&lt;br/&gt;  vector&amp;lt;double&amp;gt; collection;&lt;br/&gt;  generateRandomData(collection, 10e6); // ①&lt;br/&gt;&lt;br/&gt;  vector&amp;lt;double&amp;gt; copy1(collection); // ②&lt;br/&gt;  vector&amp;lt;double&amp;gt; copy2(collection);&lt;br/&gt;  vector&amp;lt;double&amp;gt; copy3(collection);&lt;br/&gt;&lt;br/&gt;  auto time1 = chrono::steady_clock::now(); // ③&lt;br/&gt;  sort(execution::seq, copy1.begin(), copy1.end()); // ④&lt;br/&gt;  auto time2 = chrono::steady_clock::now();&lt;br/&gt;  auto duration = chrono::duration_cast&amp;lt;chrono::milliseconds&amp;gt;(time2 - time1).count();&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Sequenced sort consuming &quot; &amp;lt;&amp;lt; duration &amp;lt;&amp;lt; &quot;ms.&quot; &amp;lt;&amp;lt; endl; // ⑤&lt;br/&gt;&lt;br/&gt;  auto time3 = chrono::steady_clock::now();&lt;br/&gt;  sort(execution::par, copy2.begin(),copy2.end()); // ⑥&lt;br/&gt;  auto time4 = chrono::steady_clock::now();&lt;br/&gt;  duration = chrono::duration_cast&amp;lt;chrono::milliseconds&amp;gt;(time4 - time3).count();&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Parallel sort consuming &quot; &amp;lt;&amp;lt; duration &amp;lt;&amp;lt; &quot;ms.&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;&lt;br/&gt;  auto time5 = chrono::steady_clock::now();&lt;br/&gt;  sort(execution::par_unseq, copy2.begin(),copy2.end()); // ⑦&lt;br/&gt;  auto time6 = chrono::steady_clock::now();&lt;br/&gt;  duration = chrono::duration_cast&amp;lt;chrono::milliseconds&amp;gt;(time6 - time5).count();&lt;br/&gt;  cout &amp;lt;&amp;lt; &quot;Parallel unsequenced sort consuming &quot; &amp;lt;&amp;lt; duration &amp;lt;&amp;lt; &quot;ms.&quot; &amp;lt;&amp;lt; endl;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码很简单：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;通过一个函数生成1000,000个随机数。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;将数据拷贝3份，以备使用。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;接下来将通过三个不同的&lt;code&gt;parallel_policy&lt;/code&gt;参数来调用同样的&lt;code&gt;sort&lt;/code&gt;算法。每次调用记录开始和结束的时间。&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;第一次调用使用&lt;code&gt;std::execution::seq&lt;/code&gt;参数。&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;输出本次测试所使用的时间。&lt;/span&gt;&lt;span&gt;&lt;span&gt;6.&lt;/span&gt;第二次调用使用&lt;code&gt;std::execution::par&lt;/code&gt;参数。&lt;/span&gt;&lt;span&gt;&lt;span&gt;7.&lt;/span&gt;第三次调用使用&lt;code&gt;std::execution::par_unseq&lt;/code&gt;参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;该程序的输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Sequenced sort consuming 4464ms.&lt;br/&gt;Parallel sort consuming 459ms.&lt;br/&gt;Parallel unsequenced sort consuming 168ms.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，性能最好的和最差的相差了超过26倍。&lt;/p&gt;&lt;h2&gt;结束语&lt;/h2&gt;&lt;p&gt;在本篇文章中，我们介绍了C++语言中新增的并发编程API。虽然这部分内容已经不少（大部分人很难一次性搞懂所有这些内容，包括我自己），但实际上还有一个很重要的话题我们没有触及，那就是“内存模型”。&lt;/p&gt;&lt;p&gt;C++内存模型是C++11标准中最重要的特性之一。它是多线程环境能够可靠工作的基础。考虑到这部分内容还需要比较多的篇幅来说明，因此我们会在下一篇文章中继续讨论。&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;原文：&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;https://paul.pub/cpp-concurrency/&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101592&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;文章来源于网络，版权归原作者所有，如有侵权，请联系删除&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section data-tools=&quot;新媒体管家&quot; data-label=&quot;powered by xmt.cn&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247489665&amp;amp;idx=1&amp;amp;sn=3f0449139d79b7747062e1f40a14caef&amp;amp;chksm=c3377e46f440f7505c953fc35d2b05a3f6dd150e8058275841fcb02cf4b687cac959c4acf3ee&amp;amp;token=913602264&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; textvalue=&quot;诡异！std::bind in std::bind 编译失败&quot; data-linktype=&quot;2&quot;&gt;诡异！std::bind in std::bind 编译失败&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247489638&amp;amp;idx=1&amp;amp;sn=6bb8c62f541bad25aadbd223f782f418&amp;amp;chksm=c3377ea1f440f7b7e1efb90acc200378c1f781a44fb088757a2a7dc4077342b2f91d7df784a6&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; textvalue=&quot;inline: 我的理解还停留在20年前&quot; data-linktype=&quot;2&quot;&gt;inline: 我的理解还停留在20年前&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247489554&amp;amp;idx=1&amp;amp;sn=f5d7e6cd5d23e8e01c413af1dc8fe9fd&amp;amp;chksm=c3377ed5f440f7c32c5596c962823e65ddd17382f621899d63f78d1cc93346918fa92cf50ca0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; textvalue=&quot;再议内存布局&quot; data-linktype=&quot;2&quot;&gt;再议内存布局&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;90215&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; data-width=&quot;100%&quot;&gt;&lt;span&gt;你好，我是雨乐，从业十二年有余，历经过传统行业网络研发、互联网推荐引擎研发，目前在广告行业从业8年。&lt;/span&gt;&lt;span&gt;目前任职某互联网公司高级技术专家一职，负责广告引擎的架构和研发。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本公众号专注于架构、技术、线上bug分析等干货，欢迎关注。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzk0MzI4OTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHhKgtwWvzaYZodgfpphdA6WWKEMXTn6ImCCCuEzlPKicNBcpzBUyjK1XicWwqIwusqLGpwyyOc87JPQ/0?wx_fmt=png&quot; data-nickname=&quot;高性能架构探索&quot; data-alias=&quot;gxnjgts_&quot; data-signature=&quot;专注于分享干货，硬货，欢迎关注😄&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>