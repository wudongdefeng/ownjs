<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bf4e2fb3c7a28c69210c2142210116d2</guid>
<title>聊聊Spring中最常用的11个扩展点</title>
<link>https://toutiao.io/k/dsdovcg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一说到spring，可能第一个想到的是 &lt;code&gt;IOC&lt;/code&gt;（控制反转） 和 &lt;code&gt;AOP&lt;/code&gt;（面向切面编程）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，它们是spring的基石，得益于它们的优秀设计，使得spring能够从众多优秀框架中脱颖而出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，我们在使用spring的过程中，有没有发现它的&lt;code&gt;扩展能力非常强&lt;/code&gt;。由于这个优势的存在，让spring拥有强大的包容能力，让很多第三方应用能够轻松投入spring的怀抱。比如：rocketmq、mybatis、redis等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天跟大家一起聊聊，在Spring中最常用的11个扩展点。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9602836879432625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaDcuvJ3nHO9icHddBSomYUxDmwa9TMnkpXkojB1z60Dh8Dtib4P74A3c1cmHS3ZnCS9UFQqfaMcJGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1410&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.自定义拦截器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring mvc拦截器根spring拦截器相比，它里面能够获取&lt;code&gt;HttpServletRequest&lt;/code&gt;和&lt;code&gt;HttpServletResponse&lt;/code&gt;等web对象实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring mvc拦截器的顶层接口是：&lt;code&gt;HandlerInterceptor&lt;/code&gt;，包含三个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;preHandle 目标方法执行前执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;postHandle 目标方法执行后执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;afterCompletion 请求完成时执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便我们一般情况会用&lt;code&gt;HandlerInterceptor&lt;/code&gt;接口的实现类&lt;code&gt;HandlerInterceptorAdapter&lt;/code&gt;类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有权限认证、日志、统计的场景，可以使用该拦截器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，继承&lt;code&gt;HandlerInterceptorAdapter&lt;/code&gt;类定义拦截器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AuthInterceptor&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;HandlerInterceptorAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;preHandle&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, HttpServletResponse response, Object handler)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        String requestUrl = request.getRequestURI();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (checkAuth(requestUrl)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;checkAuth&lt;/span&gt;&lt;span&gt;(String requestUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===权限校验===&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，将该拦截器注册到spring容器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebAuthConfig&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WebMvcConfigurerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; AuthInterceptor &lt;span&gt;getAuthInterceptor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AuthInterceptor();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addInterceptors&lt;/span&gt;&lt;span&gt;(InterceptorRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registry.addInterceptor(&lt;span&gt;new&lt;/span&gt; AuthInterceptor());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，在请求接口时spring mvc通过该拦截器，能够自动拦截该接口，并且校验权限。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.获取Spring容器对象&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们日常开发中，经常需要从Spring容器中获取Bean，但你知道如何获取Spring容器对象吗？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.1 BeanFactoryAware接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonService&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryAware&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; BeanFactory beanFactory;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setBeanFactory&lt;/span&gt;&lt;span&gt;(BeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.beanFactory = beanFactory;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Person person = (Person) beanFactory.getBean(&lt;span&gt;&quot;person&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;BeanFactoryAware&lt;/code&gt;接口，然后重写&lt;code&gt;setBeanFactory&lt;/code&gt;方法，就能从该方法中获取到spring容器对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.2 ApplicationContextAware接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonService2&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationContextAware&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ApplicationContext applicationContext;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setApplicationContext&lt;/span&gt;&lt;span&gt;(ApplicationContext applicationContext)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.applicationContext = applicationContext;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Person person = (Person) applicationContext.getBean(&lt;span&gt;&quot;person&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;ApplicationContextAware&lt;/code&gt;接口，然后重写&lt;code&gt;setApplicationContext&lt;/code&gt;方法，也能从该方法中获取到spring容器对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.3 ApplicationListener接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonService3&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationListener&lt;/span&gt;&amp;lt;&lt;span&gt;ContextRefreshedEvent&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ApplicationContext applicationContext;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onApplicationEvent&lt;/span&gt;&lt;span&gt;(ContextRefreshedEvent event)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        applicationContext = event.getApplicationContext();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Person person = (Person) applicationContext.getBean(&lt;span&gt;&quot;person&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.全局异常处理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前我们在开发接口时，如果出现异常，为了给用户一个更友好的提示，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不做任何处理请求add接口结果直接报错：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaDcuvJ3nHO9icHddBSomYUxuR5ZfQIjHZVVqwroDTtO8xiaVWQuY90wQD8fXYdGSACmOicnEzpfPic8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;what？用户能直接看到错误信息？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种交互方式给用户的体验非常差，为了解决这个问题，我们通常会在接口中捕获异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String result = &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        result = &lt;span&gt;&quot;数据异常&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口改造后，出现异常时会提示：“数据异常”，对用户来说更友好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来挺不错的，但是有问题。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是一个接口还好，但是如果项目中有成百上千个接口，都要加上异常捕获代码吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的，这时全局异常处理就派上用场了：&lt;code&gt;RestControllerAdvice&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestControllerAdvice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;handleException&lt;/span&gt;(&lt;span&gt;Exception&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; ArithmeticException) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;数据异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; Exception) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;服务器内部异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        retur nnull;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需在&lt;code&gt;handleException&lt;/code&gt;方法中处理异常情况，业务接口中可以放心使用，不再需要捕获异常（有人统一处理了）。真是爽歪歪。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.类型转换器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring目前支持3中类型转换器：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Converter&amp;lt;S,T&amp;gt;：将 S 类型对象转为 T 类型对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConverterFactory&amp;lt;S, R&amp;gt;：将 S 类型对象转为 R 类型及子类对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GenericConverter：它支持多个source和目标类型的转化，同时还提供了source和目标类型的上下文，这个上下文能让你实现基于属性上的注解或信息来进行类型转换。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这3种类型转换器使用的场景不一样，我们以&lt;code&gt;Converter&amp;lt;S,T&amp;gt;为&lt;/code&gt;例。假如：接口中接收参数的实体对象中，有个字段的类型是Date，但是实际传参的是字符串类型：2021-01-03 10:20:15，要如何处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，定义一个实体User：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Long id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Date registerDate;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，实现&lt;code&gt;Converter&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateConverter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Converter&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Date&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; SimpleDateFormat simpleDateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(String source)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (source != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(source)) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                simpleDateFormat.parse(source);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (ParseException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，将新定义的类型转换器注入到spring容器中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebConfig&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WebMvcConfigurerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addFormatters&lt;/span&gt;&lt;span&gt;(FormatterRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registry.addConverter(&lt;span&gt;new&lt;/span&gt; DateConverter());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四步，调用接口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/user&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/save&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(@RequestBody User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求接口时User对象中registerDate字段会被自动转换成Date类型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.导入配置&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时我们需要在某个配置类中引入另外一些类，被引入的类也加到spring容器中。这时可以使用&lt;code&gt;@Import&lt;/code&gt;注解完成这个功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看过它的源码会发现，引入的类支持三种不同类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我认为最好将普通类和@Configuration注解的配置类分开讲解，所以列了四种不同类型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30185185185185187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaDcuvJ3nHO9icHddBSomYUxiclRH4kP1BV372N3MRDmMicxaLvBhSicAKfqmGNHh0zBf8weickJ9uHl2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.1 普通类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种引入方式是最简单的，被引入的类会被实例化bean对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(A&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;@Import&lt;/code&gt;注解引入A类，spring就能自动实例化A对象，然后在需要使用的地方通过&lt;code&gt;@Autowired&lt;/code&gt;注解注入即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; A a;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是挺让人意外的？不用加&lt;code&gt;@Bean&lt;/code&gt;注解也能实例化bean。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.2 配置类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种引入方式是最复杂的，因为&lt;code&gt;@Configuration&lt;/code&gt;注解还支持多种组合注解，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@Import&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@ImportResource&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@PropertySource等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(B&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;AConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; A &lt;span&gt;a&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; A();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(AConfiguration&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过@Import注解引入@Configuration注解的配置类，会把该配置类相关&lt;code&gt;@Import&lt;/code&gt;、&lt;code&gt;@ImportResource&lt;/code&gt;、&lt;code&gt;@PropertySource&lt;/code&gt;等注解引入的类进行递归，一次性全部引入。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.3 ImportSelector&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种引入方式需要实现&lt;code&gt;ImportSelector&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AImportSelector&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportSelector&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CLASS_NAME = &lt;span&gt;&quot;com.sue.cache.service.test13.A&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt; &lt;span&gt;public&lt;/span&gt; String[] selectImports(AnnotationMetadata importingClassMetadata) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[]{CLASS_NAME};&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(AImportSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的好处是&lt;code&gt;selectImports&lt;/code&gt;方法返回的是数组，意味着可以同时引入多个类，还是非常方便的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.4 ImportBeanDefinitionRegistrar&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种引入方式需要实现&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AImportBeanDefinitionRegistrar&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportBeanDefinitionRegistrar&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerBeanDefinitions&lt;/span&gt;&lt;span&gt;(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RootBeanDefinition rootBeanDefinition = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(A&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        registry.registerBeanDefinition(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, rootBeanDefinition);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(AImportBeanDefinitionRegistrar&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式是最灵活的，能在&lt;code&gt;registerBeanDefinitions&lt;/code&gt;方法中获取到&lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;容器注册对象，可以手动控制BeanDefinition的创建和注册。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.项目启动时&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们需要在项目启动时定制化一些附加功能，比如：加载一些系统参数、完成初始化、预热本地缓存等，该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好消息是springboot提供了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CommandLineRunner&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ApplicationRunner&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个接口帮助我们实现以上需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们的用法还是挺简单的，以&lt;code&gt;ApplicationRunner&lt;/code&gt;接口为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestRunner&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationRunner&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; LoadDataService loadDataService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(ApplicationArguments args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        loadDataService.load();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;ApplicationRunner&lt;/code&gt;接口，重写&lt;code&gt;run&lt;/code&gt;方法，在该方法中实现自己定制化需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果项目中有多个类实现了ApplicationRunner接口，他们的执行顺序要怎么指定呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是使用&lt;code&gt;@Order(n)&lt;/code&gt;注解，n的值越小越先执行。当然也可以通过&lt;code&gt;@Priority&lt;/code&gt;注解指定顺序。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.修改BeanDefinition&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring IOC在实例化Bean对象之前，需要先读取Bean的相关属性，保存到&lt;code&gt;BeanDefinition&lt;/code&gt;对象中，然后通过BeanDefinition对象，实例化Bean对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想修改BeanDefinition对象中的属性，该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：我们可以实现&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyBeanFactoryPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanFactory&lt;/span&gt;&lt;span&gt;(ConfigurableListableBeanFactory configurableListableBeanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;&lt;br/&gt;        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        beanDefinitionBuilder.addPropertyValue(&lt;span&gt;&quot;id&quot;&lt;/span&gt;, &lt;span&gt;123&lt;/span&gt;);&lt;br/&gt;        beanDefinitionBuilder.addPropertyValue(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, &lt;span&gt;&quot;苏三说技术&quot;&lt;/span&gt;);&lt;br/&gt;        defaultListableBeanFactory.registerBeanDefinition(&lt;span&gt;&quot;user&quot;&lt;/span&gt;, beanDefinitionBuilder.getBeanDefinition());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在postProcessBeanFactory方法中，可以获取BeanDefinition的相关对象，并且修改该对象的属性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.初始化Bean前后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时，你想在初始化Bean前后，实现一些自己的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以实现：&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口目前有两个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;postProcessBeforeInitialization 该在初始化方法之前调用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;postProcessAfterInitialization 该方法再初始化方法之后调用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyBeanPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (bean &lt;span&gt;instanceof&lt;/span&gt; User) {&lt;br/&gt;            ((User) bean).setUserName(&lt;span&gt;&quot;苏三说技术&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果spring中存在User对象，则将它的userName设置成：苏三说技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，我们经常使用的注解，比如：@Autowired、@Value、@Resource、@PostConstruct等，是通过AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor实现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.初始化方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前spring中使用比较多的初始化bean的方法有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用@PostConstruct注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现InitializingBean接口&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;9.1 使用@PostConstruct注解&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===初始化===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要初始化的方法上增加&lt;code&gt;@PostConstruct&lt;/code&gt;注解，这样就有初始化的能力。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;9.2 实现InitializingBean接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BService&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InitializingBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterPropertiesSet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===初始化===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;InitializingBean&lt;/code&gt;接口，重写&lt;code&gt;afterPropertiesSet&lt;/code&gt;方法，该方法中可以完成初始化功能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.关闭容器前&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要在关闭spring容器前，做一些额外的工作，比如：关闭资源文件等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以实现&lt;code&gt;DisposableBean&lt;/code&gt;接口，并且重写它的&lt;code&gt;destroy&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DService&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InitializingBean&lt;/span&gt;, &lt;span&gt;DisposableBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;DisposableBean destroy&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterPropertiesSet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;InitializingBean afterPropertiesSet&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样spring容器销毁前，会调用该destroy方法，做一些额外的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，我们会同时实现InitializingBean和DisposableBean接口，重写初始化方法和销毁方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.自定义作用域&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道spring默认支持的&lt;code&gt;Scope&lt;/code&gt;只有两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;singleton 单例，每次从spring容器中获取到的bean都是同一个对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;prototype 多例，每次从spring容器中获取到的bean都是不同的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring web又对Scope进行了扩展，增加了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RequestScope 同一次请求从spring容器中获取到的bean都是同一个对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SessionScope 同一个会话从spring容器中获取到的bean都是同一个对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即便如此，有些场景还是无法满足我们的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们想在同一个线程中从spring容器获取到的bean都是同一个对象，该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就需要自定义Scope了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步实现Scope接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalScope&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Scope&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal THREAD_LOCAL_SCOPE = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(String name, ObjectFactory&amp;lt;?&amp;gt; objectFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object value = THREAD_LOCAL_SCOPE.get();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        Object object = objectFactory.getObject();&lt;br/&gt;        THREAD_LOCAL_SCOPE.set(object);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; object;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        THREAD_LOCAL_SCOPE.remove();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerDestructionCallback&lt;/span&gt;&lt;span&gt;(String name, Runnable callback)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;resolveContextualObject&lt;/span&gt;&lt;span&gt;(String key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getConversationId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步将新定义的Scope注入到spring容器中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalBeanFactoryPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanFactory&lt;/span&gt;&lt;span&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        beanFactory.registerScope(&lt;span&gt;&quot;threadLocalScope&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ThreadLocalScope());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步使用新定义的Scope：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Scope&lt;/span&gt;(&lt;span&gt;&quot;threadLocalScope&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8cc5aa14e435815f6272508c6d4b211a</guid>
<title>Rust 太难？那是你没看到这套 Rust 语言语言学习总结（下)</title>
<link>https://toutiao.io/k/gi384gt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;cloud-blog-detail-content blog-content-block-0&quot; id=&quot;blogContent&quot;&gt;&amp;#13;
            &lt;h1&gt;&lt;b&gt;&lt;span&gt;2.6 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;原生类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;内置的原生类型&lt;/span&gt;&lt;span&gt; (primitive types) &lt;/span&gt;&lt;span&gt;有以下几类：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;布尔类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：有两个值&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;字符类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示单个&lt;/span&gt;&lt;span&gt;Unicode&lt;/span&gt;&lt;span&gt;字符，存储为&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;个字节。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;数值类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：分为有符号整数&lt;/span&gt;&lt;span&gt; (i8, i16, i32, i64, isize)&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;无符号整数&lt;/span&gt;&lt;span&gt; (u8, u16, u32, u64, usize) &lt;/span&gt;&lt;span&gt;以及浮点数&lt;/span&gt;&lt;span&gt; (f32, f64)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;字符串类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：最底层的是不定长类型&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;，更常用的是字符串切片&lt;/span&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;span&gt;和堆分配字符串&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;其中字符串切片是静态分配的，有固定的大小，并且不可变，而堆分配字符串是可变的。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;数组&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：具有固定大小，并且元素都是同种类型，可表示为&lt;/span&gt;&lt;span&gt;[T; N]&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;切片&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：引用一个数组的部分数据并且不需要拷贝，可表示为&lt;/span&gt;&lt;span&gt;&amp;amp;[T]&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;元组&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：具有固定大小的有序列表，每个元素都有自己的类型，通过解构或者索引来获得每个元素的值。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;指针&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：最底层的是裸指针&lt;/span&gt;&lt;span&gt;const T&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;mut T&lt;/span&gt;&lt;span&gt;，但解引用它们是不安全的，必须放到&lt;/span&gt;&lt;span&gt;unsafe&lt;/span&gt;&lt;span&gt;块里。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：具有函数类型的变量实质上是一个函数指针。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;元类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：即&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;，其唯一的值也是&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.7 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.7.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;函数参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;当函数参数按值传递时，会转移所有权或者执行复制（&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;）语义。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;当函数参数按引用传递时，所有权不会发生变化，但是需要有生命周期参数（符合规则时不需要显示的标明）。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.7.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;函数参数模式匹配&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;ref&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：使用模式匹配来获取参数的不可变引用。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;ref mut&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：使用模式匹配来获取参数的可变引用。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;除了&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;ref mut&lt;/span&gt;&lt;span&gt;，函数参数也可以使用通配符来忽略参数。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.7.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;泛型函数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数参数并未指定具体的类型，而是用了泛型&lt;/span&gt;&lt;b&gt;&lt;span&gt;T&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，对&lt;/span&gt;&lt;b&gt;&lt;span&gt;T&lt;/span&gt;&lt;/b&gt;&lt;span&gt;只有一个&lt;/span&gt;&lt;span&gt;Mult trait&lt;/span&gt;&lt;span&gt;限定，即只有实现了&lt;/span&gt;&lt;span&gt;Mul&lt;/span&gt;&lt;span&gt;的类型才可以作为参数，从而保证了类型安全。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;泛型函数并未指定具体类型，而是靠编译器来进行自动推断的。如果使用的都是基本原生类型，编译器推断起来比较简单。&lt;/span&gt;&lt;span&gt;如果编译器无法自动推断，就需要显式的指定函数调用的类型&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.7.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;方法和函数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法代表&lt;/span&gt;&lt;span&gt;某个实例对象的行为&lt;/span&gt;&lt;span&gt;，函数只是一段简单的代码，它可以通过名字来进行调用。方法也是通过名字来进行调用，但它必须关联一个&lt;/span&gt;&lt;span&gt;方法接受者&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.7.5 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;高阶函数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高阶函数是指&lt;/span&gt;&lt;span&gt;以函数作为参数或返回值&lt;/span&gt;&lt;span&gt;的函数，它是函数式编程语言最基础的特性。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.8 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Closure&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/b&gt;&lt;span&gt;通常是指词法闭包，是一个&lt;/span&gt;&lt;span&gt;持有外部环境变量&lt;/span&gt;&lt;span&gt;的函数。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;外部环境&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是指闭包定义时所在的词法作用域。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;外部环境变量&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，在函数式编程范式中也被称为&lt;/span&gt;&lt;b&gt;&lt;span&gt;自由变量&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，是指并不是在闭包内定义的变量。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将自由变量和自身绑定的函数就是&lt;/span&gt;&lt;b&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包的大小在编译期是未知的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.8.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;闭包的基本语法&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/b&gt;&lt;span&gt;由&lt;/span&gt;&lt;b&gt;&lt;span&gt;管道符&lt;/span&gt;&lt;/b&gt;&lt;span&gt;（两个对称的竖线）和&lt;/span&gt;&lt;b&gt;&lt;span&gt;花括号&lt;/span&gt;&lt;/b&gt;&lt;span&gt;（或圆括号）组成。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;管道符&lt;/span&gt;&lt;/b&gt;&lt;span&gt;里是闭包函数的参数，可以向普通函数参数那样在冒号后添加类型标注，也可以省略。例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt;let add = |a, b| -&amp;gt; i32 { a + b };&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;花括号&lt;/span&gt;&lt;/b&gt;&lt;span&gt;里包含的是闭包函数执行体，花括号和返回值也可以省略。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt;let add = |a, b| a + b;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;当闭包函数没有参数只有捕获的自由变量时，管道符里的参数也可以省略。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt; let add = || a + b;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.8.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;闭包的实现&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是一种&lt;/span&gt;&lt;b&gt;&lt;span&gt;语法糖&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。闭包不属于&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;语言提供的基本语法要素，而是在基本语法功能之上又提供的一层方便开发者编程的语法。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包和普通函数的&lt;/span&gt;&lt;b&gt;&lt;span&gt;差别&lt;/span&gt;&lt;/b&gt;&lt;span&gt;就是&lt;/span&gt;&lt;span&gt;闭包可以捕获环境中的自由变量&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包可以作为函数参数，这一点直接提升了&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;语言的抽象表达能力。当它作为函数参数传递时，可以被用作泛型的&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;限定，也可以直接作为&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;对象来使用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包无法直接作为函数的返回值，如果要把闭包作为返回值，必须使用&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.8.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;闭包与所有权&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包表达式会由编译器自动翻译为结构体实例，并为其实现&lt;/span&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;span&gt;三个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;中的一个。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：会转移方法接收者的所有权。没有改变环境的能力，只能调用一次。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;会对方法接收者进行可变借用。有改变环境的能力，可以多次调用。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;会对方法接收者进行不可变借用。没有改变环境的能力，可以多次调用。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果要实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，就必须实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;/b&gt;&lt;span&gt;；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果要实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，就必须实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;/b&gt;&lt;span&gt;；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果要实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，就不需要实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.8.3.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;捕获环境变量的方式&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;对于&lt;/span&gt;&lt;b&gt;&lt;span&gt;复制语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型，以&lt;/span&gt;&lt;b&gt;&lt;span&gt;不可变引用（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;&amp;amp;T&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来进行捕获。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;对于&lt;/span&gt;&lt;b&gt;&lt;span&gt;移动语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型，执行移动语义，&lt;/span&gt;&lt;b&gt;&lt;span&gt;转移所有权&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来进行捕获。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;对于&lt;/span&gt;&lt;b&gt;&lt;span&gt;可变绑定&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，并且在闭包中包含对其进行修改的操作，则以&lt;/span&gt;&lt;b&gt;&lt;span&gt;可变引用（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;&amp;amp;mut T&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来进行捕获。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;move&lt;/span&gt;&lt;/b&gt;&lt;span&gt;关键字来&lt;/span&gt;&lt;span&gt;强制让闭包所定义环境中的自由变量转移到闭包中&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.8.3.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;规则总结&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;如果闭包中&lt;/span&gt;&lt;span&gt;没有捕获&lt;/span&gt;&lt;span&gt;任何环境变量，则默认自动实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果闭包中&lt;/span&gt;&lt;span&gt;捕获了&lt;/span&gt;&lt;span&gt;复制语义&lt;/span&gt;&lt;span&gt;类型的环境变量，则：&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;不需要修改&lt;/span&gt;&lt;span&gt;环境变量，无论是否使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;move&lt;/span&gt;&lt;/b&gt;&lt;span&gt;关键字，均会自动实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;需要修改&lt;/span&gt;&lt;span&gt;环境变量，则自动实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果闭包中&lt;/span&gt;&lt;span&gt;捕获了&lt;/span&gt;&lt;span&gt;移动语义&lt;/span&gt;&lt;span&gt;类型的环境变量，则：&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;不需要修改&lt;/span&gt;&lt;span&gt;环境变量，而且没有使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;move&lt;/span&gt;&lt;/b&gt;&lt;span&gt;关键字，则会自动实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;不需要修改&lt;/span&gt;&lt;span&gt;环境变量，而且使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;move&lt;/span&gt;&lt;/b&gt;&lt;span&gt;关键字，则会自动实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;需要修改&lt;/span&gt;&lt;span&gt;环境变量，则自动实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的闭包在使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;move&lt;/span&gt;&lt;/b&gt;&lt;span&gt;关键字时，如果捕获变量是&lt;/span&gt;&lt;span&gt;复制语义&lt;/span&gt;&lt;span&gt;类型的，则闭包会自动实现&lt;/span&gt;&lt;span&gt;Copy/Clone&lt;/span&gt;&lt;span&gt;。如果捕获变量是&lt;/span&gt;&lt;span&gt;移动语义&lt;/span&gt;&lt;span&gt;类型的，则闭包不会自动实现&lt;/span&gt;&lt;span&gt;Copy/Clone&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.9 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;迭代器&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Rust&lt;/span&gt;&lt;span&gt;使用的是外部迭代器，也就是&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环。外部迭代器：外部可以控制整个遍历进程。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Rust&lt;/span&gt;&lt;span&gt;中使用了&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;来抽象迭代器模式。&lt;/span&gt;&lt;b&gt;&lt;span&gt;Iterator trait&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中对迭代器模式的抽象接口。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;迭代器主要包含：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;next&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：迭代其内部元素&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;关联类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Item&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;size_hint&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：返回类型是一个元组，该元组表示迭代器剩余长度的边界信息。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;let iterator = iter&lt;/span&gt;&lt;b&gt;&lt;span&gt;.into_iter();      &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;let size_lin = iterator&lt;/span&gt;&lt;b&gt;&lt;span&gt;.size_hint(); &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;let mut counter = Counter { count: 0};&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;counter&lt;/span&gt;&lt;b&gt;&lt;span&gt;.next();                         &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;Iter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型迭代器，&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;方法返回的是&lt;/span&gt;&lt;b&gt;&lt;span&gt;Option&amp;lt;&amp;amp;[T]&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;或&lt;/span&gt;&lt;b&gt;&lt;span&gt;Option&amp;lt;&amp;amp;mut [T]&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型的值。&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环会自动调用迭代器的&lt;/span&gt;&lt;b&gt;&lt;span&gt;next&lt;/span&gt;&lt;/b&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环中的循环变量则是通过模式匹配，从&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;返回的&lt;/span&gt;&lt;b&gt;&lt;span&gt;Option&amp;lt;&amp;amp;[T]&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;或&lt;/span&gt;&lt;b&gt;&lt;span&gt;Option&amp;lt;&amp;amp;mut [T]&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型中获取&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;[T]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;或&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;mut [T]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型的值。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;Iter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型迭代器在&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环中产生的循环变量为&lt;/span&gt;&lt;b&gt;&lt;span&gt;引用&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;IntoIter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型的迭代器的&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;方法返回的是&lt;/span&gt;&lt;b&gt;&lt;span&gt;Option&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型，在&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环中产生的循环变量是&lt;/span&gt;&lt;b&gt;&lt;span&gt;值&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，而&lt;/span&gt;&lt;b&gt;&lt;span&gt;不是引用&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td valign=&quot;top&quot;&gt; &lt;p&gt;let v = vec![1, 2, 3];&lt;/p&gt; &lt;p&gt;for i in v {&lt;/p&gt; &lt;p&gt;    …&lt;/p&gt; &lt;p&gt;}&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了确保&lt;/span&gt;&lt;span&gt;size_hint&lt;/span&gt;&lt;span&gt;方法可以获得迭代器长度的准确信息，&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;引入了两个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;，他们是&lt;/span&gt;&lt;span&gt;Iterator&lt;/span&gt;&lt;span&gt;的子&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;，均被定义在&lt;/span&gt;&lt;span&gt;std::iter&lt;/span&gt;&lt;span&gt;模块中。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;ExactSizeIterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：提供了两个额外的方法&lt;/span&gt;&lt;b&gt;&lt;span&gt;len&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;is_empty&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;TrustedLen&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：像一个标签&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;，只要实现了&lt;/span&gt;&lt;span&gt;TrustLen&lt;/span&gt;&lt;span&gt;的迭代器，其&lt;/span&gt;&lt;span&gt;size_hint&lt;/span&gt;&lt;span&gt;获取的长度信息均是可信的。完全避免了容器的容量检查，提升了性能。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.9.1 IntoIterator trait&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;如果想要迭代某个集合容器中的元素，必须将其转换为迭代器才可以使用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Rust&lt;/span&gt;&lt;span&gt;提供了&lt;/span&gt;&lt;span&gt;FromIterator&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;IntoIterator&lt;/span&gt;&lt;span&gt;两个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;，他们互为反操作。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;FromIterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：可以从迭代器转换为指定类型。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;IntoIterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：可以从指定类型转换为迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Intoiter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;可以使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;into_iter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;之类的方法来获取一个迭代器。&lt;/span&gt;&lt;span&gt;into_iter&lt;/span&gt;&lt;span&gt;的参数时&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;，代表该方法会转移方法接收者的所有权。而还有其他两个迭代器不用转移所有权。具体的如下所示：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;Intoiter&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：转移所有权，对应&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;Iter&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：获取不可变借用，对应&lt;/span&gt;&lt;span&gt;&amp;amp;self&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;IterMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：获得可变借用，对应&lt;/span&gt;&lt;span&gt;&amp;amp;mut slef&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.9.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Iterator&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;的类型？&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只有实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;Iterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的类型才能作为迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;IntoIterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的集合容器可以通过&lt;/span&gt;&lt;b&gt;&lt;span&gt;into_iter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;方法来转换为迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;IntoIterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的集合容器有：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;Vec&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span/&gt;&lt;b&gt;&lt;span&gt;&amp;amp;’a [T]&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;’a mut [T]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;  =&amp;gt; &lt;/span&gt;&lt;span&gt;没有为&lt;/span&gt;&lt;b&gt;&lt;span&gt;[T]&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;IntoIterator&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.9.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;迭代器适配器&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过适配器模式可以将一个接口转换成所需要的另一个接口。适配器模式能够使得接口不兼容的类型在一起工作。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;适配器也叫&lt;/span&gt;&lt;b&gt;&lt;span&gt;包装器（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Wrapper&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;迭代器适配器，都定义在&lt;/span&gt;&lt;b&gt;&lt;span&gt;std::iter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;模块中：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Map&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：通过对原始迭代器中的每个元素调用指定闭包来产生一个新的迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;l&lt;/span&gt;&lt;b&gt;&lt;span&gt;Chain&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：通过连接两个迭代器来创建一个新的迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Cloned&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：通过拷贝原始迭代器中全部元素来创建新的迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Cycle&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建一个永远循环迭代的迭代器，当迭代完毕后，再返回第一个元素开始迭代。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Enumerate&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建一个包含计数的迭代器，它返回一个元组（&lt;/span&gt;&lt;span&gt;i,val&lt;/span&gt;&lt;span&gt;），其中&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;usize&lt;/span&gt;&lt;span&gt;类型，为迭代的当前索引，&lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;是迭代器返回的值。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Filter&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建一个机遇谓词判断式过滤元素的迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;FlatMap&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建一个类似&lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;span&gt;的结构的迭代器，但是其中不会包含任何嵌套。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;FilterMap&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：相当于&lt;/span&gt;&lt;span&gt;Filter&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;span&gt;两个迭代器一次使用后的效果。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Fuse&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建一个可以快速遍历的迭代器。在遍历迭代器时，只要返回过一次&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;，那么之后所有的遍历结果都为&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;。该迭代器适配器可以用于优化。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Rev&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建一个可以反向遍历的迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;可以自定义迭代器适配器，具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.10 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;消费器&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;迭代器不会自动发生遍历行为，需要调用&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;方法去消费其中的数据。最直接消费迭代器数据的方法就是使用&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;提供了&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环之外的用于消费迭代器内数据的方法，叫做&lt;/span&gt;&lt;b&gt;&lt;span&gt;消费器（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;标准库&lt;/span&gt;&lt;b&gt;&lt;span&gt;std::iter::Iterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt;中常用的消费器：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;any&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：可以查找容器中是否存在满足条件的元素。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;fold&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：该方法接收两个参数，第一个为初始值，第二个为带有两个参数的闭包。其中闭包的第一个参数被称为累加器，它会将闭包每次迭代执行的结果进行累计，并最终作为&lt;/span&gt;&lt;span&gt;fold&lt;/span&gt;&lt;span&gt;方法的返回值。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;collect&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：专门用来将迭代器转换为指定的集合类型。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;all&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;for_each&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;position&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.11 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;锁&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;RwLock&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;读写锁&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：是&lt;/span&gt;&lt;b&gt;&lt;span&gt;多读单写锁&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，也叫共享独占锁。它允许&lt;/span&gt;&lt;span&gt;多个线程读&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;单个线程写&lt;/span&gt;&lt;span&gt;。但是在写的时候，只能有一个线程占有写锁；而在读的时候，允许任意线程获取读锁。&lt;/span&gt;&lt;b&gt;&lt;span&gt;读锁和写锁不能被同时获取&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Mutex&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;互斥锁&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：只允许单个线程读和写。&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;三、&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;属性&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[lang = “drop”] &lt;/span&gt;&lt;/b&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;将&lt;/span&gt;&lt;span&gt;drop&lt;/span&gt;&lt;span&gt;标记为语言项&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[derive(Debug)] &lt;/span&gt;&lt;/b&gt;&lt;span&gt;:&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[derive(Copy, Clone)]&lt;/span&gt;&lt;/b&gt;&lt;span&gt; :&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[derive(Debug,Copy,Clone)]&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[lang = “owned_box”] &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt; Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;与原生类型不同，并不具备类型名称，它代表所有权唯一的智能指针的特殊性，需要使用&lt;/span&gt;&lt;span&gt;lang item&lt;/span&gt;&lt;span&gt;来专门识别。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[lang = “fn/fn_mut/fn_once”] &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示其属于语言项，分别以&lt;/span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;fn_mut&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;fn_once&lt;/span&gt;&lt;span&gt;名称来查找这三个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;fn_once&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：会转移方法接收者的所有权&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;fn_mut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;会对方法接收者进行可变借用&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;会对方法接收者进行不可变借用&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[lang = “rust_pareen_sugar”] &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示对括号调用语法的特殊处理。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[must_use=”iterator adaptors are lazy ……”] &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：用来发出警告，提示开发者迭代器适配器是惰性的。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;四、内存管理&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;4.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;内存回收&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         drop-flag&lt;/span&gt;&lt;span&gt;：在函数调用栈中为离开作用域的变量自动插入布尔标记，标注是否调用析构函数，这样，在运行时就可以根据编译期做的标记来调用析构函数。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;的类型，是没有析构函数的。因为实现了&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;的类型会复制，其生命周期不受析构函数的影响。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要继续深入理解第&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;章并总结，待后续补充。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;五、&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;unicode&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Unicode&lt;/span&gt;&lt;span&gt;字符集相当于一张表，每个字符对应一个非负整数，该数字称为&lt;/span&gt;&lt;b&gt;&lt;span&gt;码点（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Code Point&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些码点也分为不同的类型：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;标量值&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;代理对码点&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;非字符码点&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;保留码点&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;私有码点&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;标量值&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是指实际存在对应字符的码位，其范围是&lt;/span&gt;&lt;b&gt;&lt;span&gt;0x0000~0xD7FF&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;0xE000~0x10FFFF&lt;/span&gt;&lt;/b&gt;&lt;span&gt;两段。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Unicode&lt;/span&gt;&lt;span&gt;字符集的每个字符占&lt;/span&gt;&lt;b&gt;&lt;span&gt;4&lt;/span&gt;&lt;/b&gt;&lt;span&gt;个字节，使用的存储方式是：&lt;/span&gt;&lt;b&gt;&lt;span&gt;码元（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Code Unit&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;组成的序列。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;码元&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是指用于处理和交换编码文本的最小比特组合。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Unicode&lt;/span&gt;&lt;span&gt;字符编码表：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;/b&gt;&lt;span&gt;      =&amp;gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;1&lt;/span&gt;&lt;/b&gt;&lt;span&gt;字节码元&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;UTF-16&lt;/span&gt;&lt;/b&gt;&lt;span&gt;    =&amp;gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;2&lt;/span&gt;&lt;/b&gt;&lt;span&gt;字节码元&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;UTF-32&lt;/span&gt;&lt;/b&gt;&lt;span&gt;    =&amp;gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;4&lt;/span&gt;&lt;/b&gt;&lt;span&gt;字节码元&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;的源码文件&lt;/span&gt;&lt;span&gt;.rs&lt;/span&gt;&lt;span&gt;的默认文本编码格式是&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;六、&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;附录&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;字符串对象常用的方法&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;原型&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;new()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub const fn new() -&amp;gt; String&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;创建一个新的字符串对象&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;to_string()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;fn to_string(&amp;amp;self) -&amp;gt; String&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;将字符串字面量转换为字符串对象&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;replace()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn replace&amp;lt;&#x27;a, P&amp;gt;(&amp;amp;&#x27;a self, from: P, to: &amp;amp;str) -&amp;gt; String&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;搜索指定模式并替换&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;as_str()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn as_str(&amp;amp;self) -&amp;gt; &amp;amp;str&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;将字符串对象转换为字符串字面量&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;push()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn push(&amp;amp;mut self, ch: char)&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;再字符串末尾追加字符&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;push_str()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn push_str(&amp;amp;mut self, string: &amp;amp;str)&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;再字符串末尾追加字符串&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;len()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn len(&amp;amp;self) -&amp;gt; usize&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;返回字符串的字节长度&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;trim()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn trim(&amp;amp;self) -&amp;gt; &amp;amp;str&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;去除字符串首尾的空白符&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;split_whitespace()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn split_whitespace(&amp;amp;self) -&amp;gt; SplitWhitespace&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;根据空白符分割字符串并返回分割后的迭代器&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;split()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn split&amp;lt;&#x27;a, P&amp;gt;(&amp;amp;&#x27;a self, pat: P) -&amp;gt; Split&amp;lt;&#x27;a, P&amp;gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;根据指定模式分割字符串并返回分割后的迭代器。模式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;可以是字符串字面量或字符或一个返回分割符的闭包&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;chars()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn chars(&amp;amp;self) -&amp;gt; Chars&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;返回字符串所有字符组成的迭代器&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&amp;#13;
        &lt;/div&gt;&amp;#13;
        &amp;#13;
&amp;#13;
        &amp;#13;
        &amp;#13;
            &amp;#13;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0f8d23d2740e476a2719c9fd455412a4</guid>
<title>哔哩哔哩如何基于 Trino+Iceberg 打造高效湖仓一体平台</title>
<link>https://toutiao.io/k/byi6i0p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;哔哩哔哩如何基于Trino+Iceberg打造高效湖仓一体平台&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/strong&gt;哔哩哔哩 OLAP平台负责人-李呈祥在2022年9月24日的Hadoop meetup 2022上海站活动分享了题为《哔哩哔哩如何基于Trino+Iceberg打造高效湖仓一体平台》的主题内容，以下是具体分享。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHax9o4YDzSgribvBBA2EI81vaq9pTEbunBUjFvicL0SsXUJPicA1pwPeWKMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;大家好，我是来自哔哩哔哩的李呈祥，非常高兴来参加Hadoop Meetup，能和大家线下沟通交流，这次我主要分享的内容是哔哩哔哩如何基于Trino+Iceberg打造高效湖仓一体平台。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxafzuk3pC3yyjYjFq9HvplqGJN9r6icuNLpsO3icZ82TQNWVOTdEKuJJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;首先我介绍下哔哩哔哩的数据处理流程，我们的数据主要来自于三个方面：来自APP/网页端等的埋点数据，服务端的日志数据以及业务系统数据库中的数据，经过我们数据采集端的工具和服务，采集到大数据平台中，包括离线的HDFS数据和实时的Kafka数据。&lt;/p&gt;&lt;p&gt;进入大数据平台后，我们的数据开发人员按照数据需求对数据进行加工处理，分层数据建模。主要是用Hive和Spark进行离线的数据处理，使用Flink进行实时的数据处理。用户可以使用Spark或者Trino直接访问数据开发同学建模好的数据表，但是很多时候，为了更好地支持业务在数据探索/BI报表/数据服务/全文检索等方面的实际需求，我们还需要将数据从HDFS上的Hive表导出到外部存储，从而更高效地满足用户需求，比如ClickHouse/Redis/ES等。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxqPBYe62aywhVYujqKLbRuuuuOqbSPu9v0Pk3lNYOTT3ibH5DEY0ye8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;当前的这套架构可以基本满足我们对于数据分析的需求，但是也存在许多不足之处，主要问题在于：&lt;/p&gt;&lt;p&gt;第一，从Hive表导出到外部存储，需要额外的数据同步和数据存储成本，整个数据加工的链路也变长了，可靠性降低。&lt;/p&gt;&lt;p&gt;第二，各个存储之间实际上是数据孤岛，跨源查询的成本高，效率低，基本不太可行。&lt;/p&gt;&lt;p&gt;第三，我们内部基于Hadoop/Hive生态构建的数据质量/数据血缘/安全/元数据管理等平台服务工具链很难完整覆盖各个外部存储计算引擎。&lt;/p&gt;&lt;p&gt;所以我们引入了基于Trino+Iceberg的湖仓一体架构，希望能够简化当前的数据处理流程，核心的目标有两个：一是之前存在大量的通过Trino/Spark访问Hive的情况，我们希望通过湖仓一体加速这部分的查询效率，在提升用户体验的同时，降低查询的机器资源成本。&lt;/p&gt;&lt;p&gt;第二是对于之前很多需要同步到外部存储的场景，在对性能要求没有特别高的情况下，可以不用同步到外部存储，直接使用Iceberg表响应，简化业务的数据开发流程，提升开发效率。&lt;/p&gt;&lt;p&gt;最后基于Trino+Iceberg的湖仓一体的架构可以基本上完全兼容我们大数据开发平台的所有工具链，适配的成本非常低。&lt;/p&gt;&lt;p&gt;我们希望能够基于Trino和Iceberg实现高效的OLAP引擎，提供秒级的查询响应能力，支持大部分的交互式分析需求，少部分特殊需求通过ClickHouse/ElasticSearch以及KV类存储满足。业界对于湖仓一体有多个方向的实践，比如解决数据upsert场景，或者实时数据可见性等，B站在这些方向也都有一些探索和落地实践，不过我今天要介绍的重点是我们在湖仓一体中对于仓的查询性能方向的探索。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHax8XBoibndcKtnBnseR4zB5DTyKzvkKmf8ia8licF7C7K8nuRySqQkl5u0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxxZ2RV3XDquQfwkqYgUfffuRHaurLnQqqnXqnDrrE5771VCHUsWy83Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们湖仓一体的整体架构如图所示，基于Spark/Flink的ETL任务读写Iceberg表，外部服务通过Trino引擎查询Iceberg表数据。&lt;/p&gt;&lt;p&gt;Magnus是我们自研的Iceberg智能数据管理服务，Spark/Flink每次向Iceberg commit新的文件时会向Magnus通知commit信息，Magnus根据表的commit信息以及相关的policy异步调度Spark任务用于对Iceberg表中的数据组织进行优化，比如小文件合并，数据排序等等。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxh4w3KKoWb1vRBibYx4KPj9DaEOCpPBImEmQE8ZeR0ZzAB7QFA0gxNug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们的目标是基于Trino和Iceberg构建秒级响应的湖仓一体平台，这个目标的设定主要基于以下的几个我们观察到的事实：&lt;/p&gt;&lt;p&gt;一是我们主要目标业务场景，比如报表/数据产品，他们的表都是经过我们数据开发同学ETL后的强Schema规范化数据，查询的场景也主要是投影/过滤/关联/聚合这几种基本算子的组合，像是两个大表关联，或者复杂嵌套子查询，当然可以执行，但不是我们主要的目标场景。对于这种SPJA查询，一般来说结果集都是非常小的。&lt;/p&gt;&lt;p&gt;二是我们可以通过对Iceberg和Trino进行增强，支持排序/索引/预计算等OLAP高级特性，使得查询时只扫描SQL逻辑上需要的数据，不需要的数据都Skip掉，同时控制需要扫描的数据量在一定的范围内。&lt;/p&gt;&lt;p&gt;第三，Iceberg的事务支持是的我们可以安全地对数据进行合理的重新组织，这个基础是我们能够通过Magnus服务异步进行数据排序/索引/预计算的基础。&lt;/p&gt;&lt;p&gt;同时我们也并不追求向ClickHouse那样的毫秒级响应的能力，主要是不同于ClickHouse的存算一体架构，Iceberg数据存储在HDFS分布式文件系统上，引入了额外网络和文件系统开销，Iceberg主要是在文件级别进行元数据管理，文件一般在256M左右大小级别，粒度相比ClickHouse更粗。&lt;/p&gt;&lt;p&gt;此外，开放的查询引擎在计算侧相比于其他基于native语言开发的，充分利用向量化能力的OLAP引擎也是有不少差距的。基于可预期的数据扫描量和可控的SPJA计算复杂度，我们可以有一个可预期的查询响应时间，那问题就在于：我们如何基于Trino和Iceberg做到在执行查询时，尽量只访问查询逻辑上需要的数据？&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHax5zm4b6JJYLhg0l5XuwOVRE2ZEkAu77sBmzuyRgZdOlXN7PaMibvEe5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;对于典型的多位分析场景SPJA算子，我们针对每个算子类型进行分析。首先是投影，Iceberg表实际的数据存储类型是ORC列存格式，所以查询中投影的字段下推到TableScan层，ORC Reader只会读取需要的字段而不是所有字段，这是一个已经解决的问题。&lt;/p&gt;&lt;p&gt;对于过滤，我们需要考虑不同的过滤类型，找到合适的解决方案。过滤一般可以分为两种过滤条件，等值和范围过滤，过滤字段本身也可以根据字段基数的不同分为高基数字段和低基数字段。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxRUg6sKMMT8ictf8yjWUSSvtgqxzRADL7tWCiccrlSYqZ7t5gSOEwjNCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;在当前Trino和Iceberg的社区版本中，已经有实现了一些针对过滤条件的Data Skipping相关技术。在引擎侧，Trino通过FiterPushDown相关优化器规则会尽可能把过滤条件下推到最底下的TableScan层。&lt;/p&gt;&lt;p&gt;Iceberg首先支持Partition Prunning，分区的文件存储在分区目录中，过滤条件中包含分区时可以skip不相干的分区目录，同时会在表的metadata中记录每个文件所有字段的minmax值信息，在生成InputSplit时，如果某个字段的过滤条件和该字段的minmax值匹配判断是否需要扫描这个文件。&lt;/p&gt;&lt;p&gt;此外，Iceberg还支持用户定义排序字段，比如示例中，age是常用的过滤字段，用户可以定义age为排序字段，Magnus会拉起异步的Spark任务，将该Iceberg表的数据按照用户的定义将数据按照age字段排序。数据排序的好处是重新调整数据的聚集性，让他们按照age字段聚集，比如对于age=16的查询，排序前需要扫描3个文件，排序后只需要扫描1个文件就行了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5611111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxF5Fiahh3RTfywA2lu0th1hXE07WX7p0mzuYkkT0dSQiaXkpdvogfI7ibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面的例子解释了数据的排序分布对于索引和查询性能的影响，我们进一步拓展了Iceberg对于数据排序分布的能力。我们首先将Iceberg表数据的排序分布分为两类：文件间的数据组织和文件内的数据组织，两者相互独立，可以分别单独配置。我们主要扩展的是文件间的数据组织，总共支持了Hash/Range/Zorder和HibertCurve四种数据组织方式。Hash和Range大家都比较熟悉，这里主要简单介绍下Zorder和HibertCurve两种Distribution。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxjT0zFoSlIYcic6ooZThT8SNo6M9EcgSfb4jVKHvibW9nYsicH6fo6aYUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果对于某个Iceberg表，有多个常用的过滤字段，我们使用Order By a，b，c对多个字段进行排序后，数据的聚集性对于a,b,c依次降低，data skipping效果也会依次下降，尤其是a的基数比较高的时候，很可能对只有b或c过滤条件的查询无法skip任何一个文件。&lt;/p&gt;&lt;p&gt;Zorder的做法就是将多个字段值的多维数据依照规则映射成一维数据，我们按照映射成的一维数据排序组织，这个一维数据按照大小顺序连接起来是一个嵌套的Z字型，所以被成为Zorder排序。&lt;/p&gt;&lt;p&gt;Zorder可以保证映射后的一维数据的顺序可以同时保证原始各个维度的聚集性，从而保证对于各个参与Zorder排序的过滤字段，都有比较好的Data Skipping效果。&lt;/p&gt;&lt;p&gt;针对不同数据类型和数据分布，Zorder的实现也是一个比较有挑战的事情，有兴趣的同学可以参考我们之前的一篇文章：https://zhuanlan.zhihu.com/p/354334895。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHax0P13mGALouLV8XmWTkHsC9ia6hudZ2dqzf9wHfYkfW8oSxdkicGibsgbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们是在文件间排序阶段支持Zorder，所以实际上我们需要这个嵌套Z字型的数据分布切成很多段，每一段对应的数据存储在一个文件中。&lt;/p&gt;&lt;p&gt;可以看到，Zorder有些连接线的跨度比较大，如果跨度大的连接线连结的两个点的数据被切分到了一个文件的话，这个文件在对应字段上的minmax值的范围就会很大，对应字段过滤条件很可能就没法跳过这个文件，导致data skipping概率降低。希伯特曲线和Zorder类似，好处是它不存在跨度很大的连接线，所以是比Zorder更优的一种多维字段排序方式。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxakX7xt9fdvt0qAT07CJwk0TMSBJibibC52oQxZDBEGRmgbDNn6TmM9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;这是我们一个具体的测试场景，用了star schema 1TB的数据集，总共1000个文件，可以看到，按照Zorder排序后，针对三个参与Zorder排序字段的等值过滤，都只需要扫描一百多个文件，可以skip掉80%以上的文件，而希伯特曲线排序后，需要扫描的文件数量有进一步的降低。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxw1rzw12iaE4IkhvFvM3sfM4UdB6icibib2voIolDJc50zRVOKcyFMgGB9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;除了数据排序分布，我们也在Iceberg支持的索引方面进行了增强，支持了多种索引，以应对不同的过滤条件和字段类型。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxiaPgibCG5WJ8Wzswcibms3OCMrDSxFmCvib91fjCCmRr253TXDM15ialA8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;BitMap索引可以支持范围过滤，并且多个过滤条件的bitmap可以求并，增加skip概率。但是bitmap的主要问题有两个，一个是对于每个基数值都存储一个bitmap代价太大了，二是范围查询时需要读取大量bitmap计算交并差，这大大限制了bitmap索引的应用场景，使用索引可能导致性能的逆优化。我们在这块也有一些探索，感兴趣的话可以参考：https://zhuanlan.zhihu.com/p/433622640。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxicl5x9fqjt6Ps0TUqm9zE0G09NOSOL6uAz506ricrGFhByCcJuFXtsicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;BloomRangeFilter是我们参考公开论文实现的一个类似BloomFilter但是支持Range过滤场景的索引，有False Positive的可能，但是需要的存储空间相比于BitMap这种精确索引大大减少，在我们实际测试中，一般可以达到我们优化后的Bitmap索引的十分之一大小。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxmsWzViaWY9OlbHibA6ia1VPFyiafGkMvrEm7Gtm1da9TG32vv95iciaXr3QQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;基于Iceberg支持了丰富的索引类型 ，以及通过数据排序分布提升数据聚集性，保证索引的效果，那么Trino是怎么使用Iceberg的索引的呢？&lt;/p&gt;&lt;p&gt;可以分成两个阶段，第一个阶段是Coordinator在获取InputSplit时，这个阶段使用存储在Iceberg表metadata文件中的相关索引信息，比如每个文件各字段的minmax值，skip掉的文件不会生成InputSplit。&lt;/p&gt;&lt;p&gt;第二个阶段是在Trino Worker接收到分配的task，处理Input Split中的数据时，首先根据文件读取文件对应的索引文件数据，判读是否可以skip当前文件。&lt;/p&gt;&lt;p&gt;我们生成的索引文件和数据文件是一一对应的，当索引大小 小于某个阈值时保存在表的metadata中，在阶段一时使用，当大于阈值时，保存在独立文件中，阶段二使用。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHax4G0OD9PzaKSZwjLaQ2oq52lVOFTEC6ZKxtbqIJP62OfeO2j7DcJkHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;在有Join的查询中，如何有效地Skip不需要访问的数据是一个很难解决的问题。对于典型的星型模型场景，影响性能的关键是扫描事实表的数据量，但是过滤条件一般是根据维度表中的维度字段过滤，Trino是没办法使用维度字段的过滤条件去skip事实表的文件的。&lt;/p&gt;&lt;p&gt;我们支持了在Iceberg表上定义虚拟的关联列，关联列相当于把维度表的维度字段打宽到事实表上，当然实际上不会真的存储，只是一个逻辑上的定义，然后用户就可以像对待原始的列一样对待关联列，可以基于关联列定义数据排序组织，可以基于关联列定义索引。关联列要求事实表和维度表满足一定的约束关系，也就是事实表和维度表Join后的结果相当于对事实表的打宽，事实表的行数没有增加也没有减少，称为Record-Preserved Join。&lt;/p&gt;&lt;p&gt;一般满足这种条件的是：事实表Left Join维度表，且维度表的Join key满足Unique Key的约束，或者，两表的join key满足PKFK的约束，那么事实表和维度表LEFT JOIN或者Inner Join都可以保证Record-Preserved Join。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxhVPZARNeb3pBrANnrgd7O1dFRIE6OJKMt6YAkicfDYpNQFxOJSAomYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们能够根据关联列定义数据排序组织和索引后，针对维度字段的过滤条件，通过添加一个Trino的优化器Rule，把符合条件的过滤条件就可以从维度表的TableScan中抽取下推到事实表的TableScan中，利用定义在事实表上该字段的索引数据判断是否可以Skip当前的事实表数据文件，从而使得星型模型的Data Skipping效果可以达到和大款表类似的效果，对于我们支持星型模型的业务场景，是一个非常大的提升。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxczpxynfX1OOQvBxPTFdVEYQgNuXtDXTqK41ueakDLMmPwJII7sHPWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过对于数据排序组织，索引和关联列的支持，Trino + Iceberg可以基本上做到文件级的只实际扫描SQL逻辑上需要的数据到引擎中参与计算，但是对于部分包含聚合算子的查询场景，可以SQL逻辑上就需要计算大量的数据，聚合成少量结果集返回给用户，这样的场景主要是需要通过预计算解决性能上的问题，通过预计算的结果直接响应查询，从而避免实际扫描计算大量的数据。&lt;/p&gt;&lt;p&gt;我们当前支持了直接通过Iceberg metadata中的数据直接响应用户表/分区级别的count/min/max聚合查询。对于更通用的预计算方案，还在开发过程中，如何实现高效的文件级别预计算存储和查询，如何利用部分文件预计算结果加速查询，如何解决预计算cube维度爆炸问题等，这是一个非常有意思而且有挑战的方向，我们后面有实际成果的时候到时会和大家在分享在这个方面的工作。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxhCttSv3Ib8J9X3zdfSbntK7p7gYE79mUwC4dbKE81TFZWU4BHQxoIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;B站的湖仓一体平台目前处在快速发展的阶段，这里和大家分享下当前的一些关键指标，我们的Trino集群大概是5376个core，每天有7万的查询量，总接入的数据量目前是2PB，通过数据排序/索引等广泛的应用，平均查询只需要扫描2GB的数据，总体P90的响应时间在2s以内，基本上达到了我们建设秒级响应的湖仓一体平台的目标。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxOKnThUQHKJAG3dakXC22rNODfxadnWpWubKB5FZIu2mOg0F3kI0U4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>439d6c78c6a2f388de7836375b4cd5fa</guid>
<title>自以为掌握的缓存数据库一致性问题，面试还是被问的一脸懵逼。。。</title>
<link>https://toutiao.io/k/8015c27</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;channels_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAADYIamL10ngAAAAstQy6ubaLX4KHWvLEZgBPE36JYewMtJuuDzNPgMIu--b1XCMH7p4OcfMqGtUPB&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzkzEHxDXTYd8JHib8K8XpwlpoianIKWtP7U6baDa91iaZFZtMzB1nT8oNTdytrfDJ3eIHNjyibZR5Ybh0g7M4ibdEK7w&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdUtAB1XoibI7cVsFZWG3u7Rcvoco4mk5Mu5BjxwZka2Zib6rsUr2bqxFHAkTFoiapZbicY&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM5nv7YHhmhvPsGGX04JCIgibK2x2Ru0TOY9HeZTGSIL1KQ/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08a1fc3d5c807ec30b07756771265bc6b6234fb9e05062ae69ab4@finder&quot; data-nickname=&quot;儒猿IT&quot; data-desc=&quot;你知道你连接的MySQL数据库到底能抗多大并发压力吗？如果MySQL数据库扛不住压力了，应该如何演进？#MySQL #数据库 #高并发 #分库分表 @微信时刻 &quot; data-nonceid=&quot;6688676945815912842&quot; data-type=&quot;video&quot; data-width=&quot;1624&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;文章来源：https://juejin.cn/post/7110120022848045092&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-0&quot;/&gt;&lt;h2 data-id=&quot;heading-0&quot;/&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;h2 data-id=&quot;heading-0&quot;&gt;&lt;span&gt;1、什么是数据库与缓存一致性&lt;/span&gt;&lt;/h2&gt;&lt;/li&gt;&lt;li&gt;&lt;h2 data-id=&quot;heading-1&quot;&gt;&lt;span&gt;2、缓存的使用策略&lt;/span&gt;&lt;/h2&gt;&lt;/li&gt;&lt;li&gt;&lt;h2 data-id=&quot;heading-13&quot;&gt;&lt;span&gt;3、旁路缓存下的一致性问题分析&lt;/span&gt;&lt;/h2&gt;&lt;/li&gt;&lt;li&gt;&lt;h2 data-id=&quot;heading-24&quot;&gt;&lt;span&gt;4、一致性解决方案有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5、总结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3GHDOauYyUGbiaHXGx1ib5UxkKzSNtpMzY5tbbGdibG7icBSxlH783x1YTF0icAv8MWrmanB4u5qjyKfmYo1dDf7YbA/640?wx_fmt=gif&quot; data-w=&quot;100&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;前言&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis 拥有高性能的数据读写功能，被我们广泛用在缓存场景，一是能提高业务系统的性能，二是为数据库抵挡了高并发的流量请求。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;把 Redis 作为缓存组件，需要防止出现以下的一些问题，否则可能会造成生产事故。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天跟大家一起深入探索&lt;strong&gt;缓存的工作机制和缓存一致性应对方案&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在本文正式开始之前，我觉得我们需要先取得以下两点的共识：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缓存必须要有过期时间；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;保证数据库跟缓存的最终一致性即可，不必追求强一致性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-0&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. 什么是数据库与缓存一致性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-0&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据一致性指的是：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缓存中存有数据，缓存的数据值 = 数据库中的值；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存中没有该数据，数据库中的值 = 最新值。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;反推缓存与数据库不一致：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;为何会出现数据一致性问题呢？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;把 Redis 作为缓存的时候，当数据发生改变我们需要双写来保证缓存与数据库的数据一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库跟缓存，毕竟是两套系统，如果要保证强一致性，势必要引入 &lt;/span&gt;&lt;code&gt;&lt;span&gt;2PC&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Paxos&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 等分布式一致性协议，或者分布式锁等等，这个在实现上是有难度的，而且一定会对性能有影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果真的对数据的一致性要求这么高，那引入缓存是否真的有必要呢？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-1&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. 缓存的使用策略&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-1&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在使用缓存时，通常有以下几种缓存使用策略用于提升系统性能：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;Cache-Aside Pattern&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（旁路缓存，业务系统常用）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;Read-Through Pattern&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;Write-Through Pattern&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Write-Behind Pattern&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-id=&quot;heading-2&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2.1 Cache-Aside (旁路缓存)&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;所谓「旁路缓存」，就是&lt;/span&gt;&lt;strong&gt;读取缓存、读取数据库和更新缓存的操作都在应用系统来完成&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;strong&gt;业务系统最常用的缓存策略&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-3&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2.1.1 读取数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3125845737483085&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSibvnozXfxPvYvuoN6DXHABE483Fxetpgk88d3otBPJvEk7Np89iajg86Q/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;2956&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;读取数据&lt;/strong&gt;逻辑如下:&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当应用程序需要从数据库读取数据时，先检查缓存数据是否命中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果缓存未命中，则查询数据库获取数据，同时将数据写到缓存中，以便后续读取相同数据会命中缓存，最后再把数据返回给调用者。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果缓存命中，直接返回。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时序图如下：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8597285067873304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSib8pZKv88lQLtHTb8HnXLAsecyaac2ibUzNsmOXmbWTQSHV9QkGQsKBDw/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;442&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-4&quot;&gt;&lt;strong&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缓存中仅包含应用程序实际请求的数据，有助于保持缓存大小的成本效益。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实现简单，并且能获得性能提升。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;实现的伪代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt; cacheKey = &lt;span&gt;&quot;公众号：码哥字节&quot;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;String&lt;/span&gt; cacheValue = redisCache.get(cacheKey)；&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;//缓存命中&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;if&lt;/span&gt; (cacheValue != &lt;span&gt;null&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;return&lt;/span&gt; cacheValue;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;//缓存缺失, 从数据库获取数据&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  cacheValue = getDataFromDB();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;// 将数据写到缓存中&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  redisCache.put(cacheValue)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;h4 data-id=&quot;heading-5&quot;&gt;&lt;strong&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;由于数据仅在缓存未命中后才加载到缓存中，因此初次调用的数据请求响应时间会增加一些开销，因为需要额外的缓存填充和数据库查询耗时。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-6&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2.1.2 更新数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;cache-aside&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 模式写数据时，如下流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31041524846834584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSibLNtGKtdzeBlKZ43LDZicibxIrXT8jcOQ50WW4xcF7HbgsUesHQ8mE2Ww/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;2938&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;写数据到数据库；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将缓存中的数据失效或者更新缓存数据；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;cache-aside&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 时，最常见的写入策略是直接将数据写入数据库，但是缓存可能会与数据库不一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们应该给缓存设置一个过期时间，这个是保证最终一致性的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果过期时间太短，应用程序会不断地从数据库中查询数据。同样，如果过期时间过长，并且更新时没有使缓存失效，缓存的数据很可能是脏数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最常用的方式是&lt;strong&gt;删除缓存使缓存数据失效&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;为啥不是更新缓存呢？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当缓存的更新成本很高，需要访问多张表联合计算，建议直接删除缓存，而不是更新缓存数据来保证一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在高并发场景下，可能会造成查询查到的数据是旧值，具体待会码哥会分析，大家别急。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-7&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2.2 Read-Through（直读）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;当缓存未命中，也是从数据库加载数据，同时写到缓存中并返回给应用系统。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然 &lt;/span&gt;&lt;code&gt;&lt;span&gt;read-through&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;cache-aside&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 非常相似，在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;cache-aside&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中&lt;strong&gt;应用系统负责&lt;/strong&gt;从数据库获取数据和填充缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;而 Read-Through 将获取数据存储中的值的责任转移到了缓存提供者身上。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0845771144278606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSibM4zyyHic37gJgrg17hibyRa6rG6rsthYUiczSh6ZnAdu1B5ibrdejLpWXg/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;402&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Read-Through 实现了关注点分离原则。代码只与缓存交互，由缓存组件来管理自身与数据库之间的数据同步。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-8&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2.3 Write-Through 同步直写&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;与 Read-Through 类似，发生写请求时，Write-Through 将写入责任转移到缓存系统，由缓存抽象层来完成缓存数据和数据库数据的更新&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;时序流程图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6843657817109144&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSibGdOOeGPO7hBfb9DarVoibI2rpKhFhTdrrpsadphRXBeKN9KAA9n9zPQ/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;339&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Write-Through&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的主要好处是应用系统的不需要考虑故障处理和重试逻辑，交给缓存抽象层来管理实现。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-9&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;优缺点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;单独直接使用该策略是没啥意义的，因为该策略要先写缓存，再写数据库，对写入操作带来了额外延迟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当&lt;/span&gt;&lt;code&gt;&lt;span&gt;Write-Through&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 与 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Read-Through&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 配合使用，就能成分发挥 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Read-Through&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的优势，同时还能保证数据一致性，不需要考虑如何将缓存设置失效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3132372214941022&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSibF6hW9Zbd0QPWDPFavLtt2YMXny2xJZCcId9Z1lTPaKOiayFkJZslw6w/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;763&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个策略颠倒了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Cache-Aside&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 填充缓存的顺序，并不是在缓存未命中后延迟加载到缓存，而是在&lt;strong&gt;数据先写缓存，接着由缓存组件将数据写到数据库&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-10&quot;&gt;&lt;strong&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h4 data-id=&quot;heading-11&quot;&gt;&lt;strong&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;不经常请求的数据也会写入缓存，从而导致缓存更大、成本更高。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-12&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2.4 Write-Behind&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个图一眼看去似乎与 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Write-Through&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 一样，其实不是的，&lt;strong&gt;区别在于最后一个箭头的箭头：它从实心变为线。&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这意味着缓存系统将&lt;strong&gt;异步更新数据库数据，应用系统只与缓存系统交互&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用程序不必等待数据库更新完成，从而提高应用程序性能，因为对数据库的更新是最慢的操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6843657817109144&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSibpAOEWHJnTOPQuobianVpKwU3jlEzcSQwXpric35viagmUEY4lruoGM49w/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;339&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种策略下，&lt;strong&gt;缓存与数据库的一致性不强，对一致性高的系统不建议使用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-13&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3. 旁路缓存下的一致性问题分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-13&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;业务场景用的最多的就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Cache-Aside&lt;/span&gt;&lt;/code&gt;&lt;span&gt; (旁路缓存) 策略，在该策略下，客户端对数据的读取流程是先读取缓存，如果命中则返回；未命中，则从数据库读取并把数据写到缓存中，所以&lt;strong&gt;读操作不会导致缓存与数据库的不一致。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;重点是写操作，数据库和缓存都需要修改，而两者就会存在一个先后顺序，可能会导致数据不再一致&lt;/strong&gt;。针对写，我们需要考虑两个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;将这两个问题排列组合，会出现四种方案：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;先更新缓存，再更新数据库；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;先更新数据库，再更新缓存；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;先删除缓存，再更新数据库；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先更新数据库，再删除缓存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来的分析大家不必死记硬背，关键在于在推演的过程中大家只需要考虑以下两个场景会不会带来严重问题即可：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;其中第一个操作成功，第二个失败会导致什么问题？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在高并发情况下会不会造成读取数据不一致？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;为啥不考虑第一个失败，第二个成功的情况呀？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;你猜？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然第一个都失败了，第二个就不用执行了，直接在第一步返回 50x 等异常信息即可，不会出现不一致问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;只有第一个成功，第二个失败才让人头痛，想要保证他们的原子性，就涉及到分布式事务的范畴了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-14&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3.1 先更新缓存，再更新数据库&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8254189944134078&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSibZN95o6MZ8T40pyKofr7pMyOLDzB73ASqgslsfZbnRScia84Sd8OmWCQ/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;716&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果先更新缓存成功，写数据库失败，就会导致缓存是最新数据，数据库是旧数据，那缓存就是脏数据了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之后，其他查询立马请求进来的时候就会获取这个数据，而这个数据数据库中却不存在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据库都不存在的数据，缓存并返回客户端就毫无意义了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;该方案直接 &lt;/strong&gt;&lt;strong&gt;&lt;code&gt;Pass&lt;/code&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-15&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3.2 先更新数据库，再更新缓存&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一切正常的情况如下：&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-16&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;更新缓存失败&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这时候我们来推断下，假如这两个操作的原子性被破坏：&lt;/span&gt;&lt;strong&gt;第一步成功，第二步失败&lt;/strong&gt;&lt;span&gt;会导致什么问题？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;会导致&lt;strong&gt;数据库是最新数据，缓存是旧数据，出现一致性问题。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该图我就不画了，与上一个图类似，对调下 Redis 和 MySQL 的位置即可。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-17&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;高并发场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;谢霸歌经常 996，腰酸脖子疼，bug 越写越多，想去按摩推拿放提升下编程技巧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;疫情影响，单子来之不易，高端会所的技师都争先恐后想接这一单，高并发啊兄弟们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在进店以后，前台会将顾客信息录入系统，执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;set xx的服务技师 = 待定&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的初始值表示目前无人接待保存到数据库和缓存中，之后再安排技师按摩服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8038793103448276&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSibGrARBjJNcRtKUQWWpJqBKEkx7DxtE41YTBL4YWV3CZ9ic7pBvzXLGjw/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;928&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;98 号技师先下手为强，向系统发送 &lt;/span&gt;&lt;code&gt;&lt;span&gt;set 谢霸歌的服务技师 = 98&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的指令写入数据库，这时候系统的网络出现波动，卡顿了，&lt;strong&gt;数据还没来得及写到缓存&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接下来，520 号技师也向系统发送 &lt;/span&gt;&lt;code&gt;&lt;span&gt;set 谢霸哥的服务技师 = 520&lt;/span&gt;&lt;/code&gt;&lt;span&gt;写到数据库中，并且也把这个数据写到缓存中了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这时候之前的 98 号技师的写缓存请求开始执行，顺利将数据 &lt;/span&gt;&lt;code&gt;&lt;span&gt;set 谢霸歌的服务技师 = 98&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 写到缓存中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.06451612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/01NCBYDP9ZfkwrnCoIlkXhdAZbvSQoo0P17WWyOtfcfypVW5ic2ibUZHEXIuYjH409ebVxiar8pn7dx5yHGpWWV8A/640?wx_fmt=png&quot; data-w=&quot;310&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后发现，数据库的值 = &lt;/span&gt;&lt;code&gt;&lt;span&gt;set 谢霸哥的服务技师 = 520&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而缓存的值= &lt;/span&gt;&lt;code&gt;&lt;span&gt;set 谢霸歌的服务技师 = 98&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;520 号技师在缓存中的最新数据被 98 号技师的旧数据覆盖了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，&lt;strong&gt;在高并发的场景中，多线程同时写数据再写缓存，就会出现缓存是旧值，数据库是最新值的不一致情况。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该方案直接 pass。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;如果第一步就失败，直接返回 50x 异常，并不会出现数据不一致。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-id=&quot;heading-18&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3.3 先删缓存，再更新数据库&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;按照「码哥」前面说的套路，假设第一个操作成功，第二个操作失败推断下会发生什么？&lt;/span&gt;&lt;span&gt;高并发场景下又会发生什么？&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;第二步写数据库失败&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;假设现在有两个请求：写请求 A，读请求 B。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;写请求 A 第一步先删除缓存成功，写数据到数据库失败，就会导致该次&lt;strong&gt;写数据丢失，数据库保存的是旧值&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着另一个读请 B 求进来，发现缓存不存在，从数据库读取旧数据并写到缓存中。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-20&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;高并发下的问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7346491228070176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSibh6ovF2kZLLOkLYNrCgp2yclllvKriaOOibKYmPx6Hl2sTSP9HPyLM4Rw/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;912&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;还是 98 号技师先下手为强，系统接收请求把缓存数据删除，当系统准备将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;set 肖菜鸡的服务技师 = 98&lt;/span&gt;&lt;/code&gt;&lt;span&gt;写到数据库的时候发生卡顿，来不及写入。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这时候，大堂经理向系统执行读请求，查下肖菜鸡有没有技师接待，方便安排技师服务，系统发现缓存中没数据，于是乎就从数据库读取到旧数据 &lt;/span&gt;&lt;code&gt;&lt;span&gt;set 肖菜鸡的服务技师 = 待定&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，并写到缓存中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这时候，原先卡顿的 98 号技师写数据 &lt;/span&gt;&lt;code&gt;&lt;span&gt;set 肖菜鸡的服务技师 = 98&lt;/span&gt;&lt;/code&gt;&lt;span&gt;到数据库的操作完成。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;这样子会出现缓存的是旧数据，在缓存过期之前无法读取到最数据。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;肖菜鸡本就被 98 号技师接单了，但是大堂经理却以为没人接待。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06451612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/01NCBYDP9ZfkwrnCoIlkXhdAZbvSQoo0P17WWyOtfcfypVW5ic2ibUZHEXIuYjH409ebVxiar8pn7dx5yHGpWWV8A/640?wx_fmt=png&quot; data-w=&quot;310&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;该方案 pass，因为第一步成功，第二步失败，会造成数据库是旧数据，缓存中没数据继续从数据库读取旧值写入缓存，造成数据不一致，还会多一次 cahche。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;不论是异常情况还是高并发场景，会导致数据不一致。miss。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-21&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3.4 先更新数据库，再删缓存&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;经过前面的三个方案，全都被 pass 了，分析下最后的方案到底行不行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照「套路」，分别判断异常和高并发会造成什么问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该策略可以知道，在写数据库阶段失败的话就直返返回客户端异常，不需要执行缓存操作了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以第一步失败不会出现数据不一致的情况。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-22&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;删缓存失败&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;重点在于第一步写最新数据到数据库成功，删除缓存失败怎么办？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以把这两个操作放在一个事务中，当缓存删除失败，那就把写数据库回滚。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;高并发场景下不合适，容易出现大事务，造成死锁问题。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;如果不回滚，那就出现数据库是新数据，缓存还是旧数据，数据不一致了，咋办？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我们要想办法让缓存删除成功，不然只能等到有效期失效那可不行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用重试机制。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如重试三次，三次都失败则记录日志到数据库，使用分布式调度组件 xxl-job 等实现后续的处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在高并发的场景下，&lt;strong&gt;重试最好使用异步方式&lt;/strong&gt;，比如发送消息到 mq 中间件，实现异步解耦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;亦或是利用 Canal 框架订阅 MySQL binlog 日志，监听对应的更新请求，执行删除对应缓存操作。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-23&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;高并发场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;再来分析下高并发读写会有什么问题……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6624649859943977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSib11vHIMauUM18OcvVNiaoehzQME19fIK7AzpOVJlYUEsGmNDysS5VShg/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;98 号技师先下手为强，接下肖菜鸡的这笔生意，数据库执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;set 肖菜鸡的服务技师 = 98&lt;/span&gt;&lt;/code&gt;&lt;span&gt;；还是网络卡顿了下，&lt;strong&gt;没来得及执行删除缓存操作&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主管 Candy 向系统执行读请求，查下肖菜鸡有没有技师接待，发现缓存中有数据 &lt;/span&gt;&lt;code&gt;&lt;span&gt;肖菜鸡的服务技师 = 待定&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，直接返回信息给客户端，主管以为没人接待。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;原先 98 号技师接单，由于卡顿没删除缓存的操作现在执行删除成功。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;读请求可能出现少量读取旧数据的情况，但是很快旧数据就会被删除，之后的请求都能获取最新数据，问题不大。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有一种比较极端的情况，缓存自动失效的时候又遇到了高并发读写的情况，假设这会有两个请求，一个线程 A 做查询操作，一个线程 B 做更新操作，那么会有如下情形产生：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0687645687645688&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSibLyZg6I2oajZwIKWx47dia2aIBicCt8I7BKofNpYbibfBjuLSpTC3717VA/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;858&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存的过期时间到期，缓存失效。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程 A 读请求读取缓存，没命中，则查询数据库得到一个旧的值（因为 B 会写新值，相对而言就是旧的值了），准备&lt;strong&gt;把数据写到缓存时发送网络问题卡顿了&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程 B 执行写操作，将新值写数据库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程 B 执行删除缓存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程 A 继续，从卡顿中醒来，把查询到的旧值写到入缓存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;码哥，这咋玩，还是出现了不一致的情况啊。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;不要慌，发生这个情况的概率微乎其微，发生上述情况的必要条件是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;步骤 （3）的写数据库操作要比步骤（2）读操作耗时短速度快，才可能使得步骤（4）先于步骤（5）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存刚好到达过期时限。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常 MySQL 单机的 QPS 大概 5K 左右，而 TPS 大概 1k 左右，（ps：Tomcat 的 QPS 4K 左右，TPS = 1k 左右）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库读操作是远快于写操作的（正是因为如此，才做读写分离），所以步骤（3）要比步骤（2）更快这个情景很难出现，同时还要配合缓存刚好失效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，在用旁路缓存策略的时候，对于写操作推荐使用：&lt;strong&gt;先更新数据库，再删除缓存。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-24&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4. 一致性解决方案有哪些？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-24&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;最后，&lt;strong&gt;针对 Cache-Aside (旁路缓存) 策略，写操作使用先更新数据库，再删除缓存&lt;/strong&gt;的情况下，我们来分析下数据一致性解决方案都有哪些？&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-25&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4.1 缓存延时双删&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果采用先删除缓存，再更新数据库如何避免出现脏数据？&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;采用延时双删策略。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;先删除缓存。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;写数据库。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;休眠 500 毫秒，再删除缓存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这样子最多只会出现 500 毫秒的脏数据读取时间。关键是这个休眠时间怎么确定呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;延迟时间的目的就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以我们需要自行评估项目的读数据业务逻辑的耗时，&lt;strong&gt;在读耗时的基础上加几百毫秒作为延迟时间即可&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-26&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4.2 删除缓存重试机制&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;缓存删除失败怎么办？比如延迟双删的第二次删除失败，那岂不是无法删除脏数据。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;使用重试机制，保证删除缓存成功。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如重试三次，三次都失败则记录日志到数据库并发送警告让人工介入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在高并发的场景下，&lt;strong&gt;重试最好使用异步方式&lt;/strong&gt;，比如发送消息到 mq 中间件，实现异步解耦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6453488372093024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSibXibDGmoqjrTpZSjEzRwt94ibRRC5wdPFCIH6msoRyCxQTDs0hEBozUEg/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;860&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第（5）步如果删除失败且未达到重试最大次数则将消息重新入队，直到删除成功，否则就记录到数据库，人工介入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该方案有个缺点，就是对业务代码中造成侵入，于是就有了下一个方案，启动一个专门订阅 数据库 binlog 的服务读取需要删除的数据进行缓存删除操作。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-27&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4.3 读取 binlog 异步删除&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5651840490797546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLZGq3FF9ZotNy0GKRVRRHSibHrhxolGF6Vm6yNdY6OT06yDQu5oseZBkzEsxLR4cOpzql4K5qRaAiaw/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1304&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;更新数据库；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据库会把操作信息记录在 binlog 日志中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用 canal 订阅 binlog 日志获取目标数据和 key；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存删除系统获取 canal 的数据，解析目标 key，尝试删除缓存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果删除失败则将消息发送到消息队列；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存删除系统重新从消息队列获取数据，再次执行删除操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-id=&quot;heading-28&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-28&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;缓存策略的最佳实践是 &lt;strong&gt;Cache Aside Pattern&lt;/strong&gt;。分别分为读缓存最佳实践和写缓存最佳实践。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;读缓存&lt;/strong&gt;最佳实践：先读缓存，命中则返回；未命中则查询数据库，再写到数据库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;写缓存&lt;/strong&gt;最佳实践：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在以上最佳实践下，为了尽可能保证缓存与数据库的一致性，我们可以采用延迟双删。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;防止删除失败，我们采用异步重试机制保证能正确删除，异步机制我们可以发送删除消息到 mq 消息中间件，或者利用 canal 订阅 MySQL binlog 日志监听写请求删除对应缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，如果我非要保证绝对一致性怎么办，先给出结论：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;没有办法做到绝对的一致性，这是由 CAP 理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于 CAP 中的 AP。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我们得委曲求全，可以去做到 BASE 理论中说的&lt;strong&gt;最终一致性&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实一旦在方案中使用了缓存，那往往也就意味着我们放弃了数据的强一致性，但这也意味着我们的系统在性能上能够得到一些提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所谓 tradeoff 正是如此。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAADYIamL10ngAAAAstQy6ubaLX4KHWvLEZgBPE36JYewMtJuuDzNPgMIu--b1XCMH7p4OcfMqGtUPB&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzkzEHxDXTYd8JHib8K8XpwlpoianIKWtP7U6baDa91iaZFZtMzB1nT8oNTdytrfDJ3eIHNjyibZR5Ybh0g7M4ibdEK7w&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=6xykWLEnztIVL4LP8icOcNicVnQs5DqPpjIt6mfhuFeuqBWTQfEvGqx0HBicsepNyVKhD8sS7W6vJk&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM5nv7YHhmhvPsGGX04JCIgibK2x2Ru0TOY9HeZTGSIL1KQ/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08a1fc3d5c807ec30b07756771265bc6b6234fb9e05062ae69ab4@finder&quot; data-nickname=&quot;儒猿IT&quot; data-desc=&quot;你知道你连接的MySQL数据库到底能抗多大并发压力吗？如果MySQL数据库扛不住压力了，应该如何演进？#MySQL #数据库 #高并发 #分库分表 @微信时刻 &quot; data-nonceid=&quot;6688676945815912842&quot; data-type=&quot;video&quot; data-width=&quot;1624&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21428571428571427&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/84QSpkgaj14GBzMnf1ibXkydLwCmhrWBooDwrdnlqYlsyB5PetG1T1oXxJ63G8TK58dqkDo7uzR7bKic50DxbTQQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;336&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6538461538461539&quot; data-w=&quot;52&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BXOuoE8lPAIR47zmQ1XOqSQszO2PjLgkgakpDZQSsUkLLnGszEu0eyGjvHNRqu6picb2kicC4lo95WZGiaxqibqW4A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;欢迎扫码加入儒猿技术交流群，每天晚上20:00都有Java面试、Redis、MySQL、RocketMQ、SpringCloudAlibaba、Java架构等技术答疑分享，更能跟小伙伴们一起交流技术&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;267&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;267&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLbPrUTW4zORxkXJU3pH9mPiawH9oZtZGKTkHyVL2wemkqNmPoJKDZlAt5ibgr2CibGkffw2ozqicds4gw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;396&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;41056&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;41056&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;94152&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-autoskip=&quot;1&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;另外推荐儒猿课堂的1元系列课程给您，欢迎加入一起学习~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;互联网Java工程师面试突击课&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295hjkFx86RFTZFibdBopicpMl5Scptaibp0pQAe5jUBMtXym9w4CncFBHsQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;SpringCloudAlibaba零基础入门到项目实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295NSLHaU5cHQTtyG2K5uK4iaA70v1g50BoQIRUVz4FBN1iahXdqc1M99Ww/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;亿级流量下的电商详情页系统实战项目&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295I9n8XXUWoEeuogklrbj2QN4JZ6cdgYeRys5CCsml2tkFfibLXdeqoFA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Kafka消息中间件内核源码精讲&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295yiaEcp1k5HBVycE8BGD0lGz5NZmKWmKXUtSBS7Jnm4FkTY8R5XFZkPw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;12个实战案例带你玩转Java并发编程&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295WWU9o0Pj51xAIa2qCs9xD2rdDIRLriaibePNSrWJVCknYn6b5lrF3CQQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Elasticsearch零基础入门到精通&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295QdxHC6HadPfaakPOo7DxxQpLH19lMZH0yAwRI3iajVXblNnwfMxBk9A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基于Java手写分布式中间件系统实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295r0mR5hhVpAlXTAZzlVvSg1dxegAaZrIZ9ftePV5QQQg2ibIZbiaA6CCg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基于ShardingSphere的分库分表实战课&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295hicEliaIKPfLpHqQAo4CdAorqyxd9HvqD8sADicO7wFHGJxNtRus6LlBA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c3e0da9860bf59a4975db0ae8921658e</guid>
<title>NSA 到底是什么样的怪物机构？</title>
<link>https://toutiao.io/k/x8bhwal</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;网络空间中的一些怪物~&lt;em&gt;&lt;span&gt;泰坦、霸主&lt;/span&gt;&lt;/em&gt;...它已经&lt;em&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;恐怖&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;到无法被语言形容...&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;设施&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;NSA总部的建筑面积为15公顷，位于华盛顿以北的马里兰州米德堡，在距巴尔的摩市华盛顿公园几百米远的森林中。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10mP0mPcz2iata1FGEqVbVuVtpPwwUh2SNQwau8DpiaBCxibI1q0YibhichHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6096345514950167&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10ou6hCInbCBicuLofiaQrHM6v6ofsqRpRrGiaIFjfM47iaOz6309AZbDMtw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;602&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;人才&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;据2013年美国预算草案透漏出的数据得知，NSA拥有雇员约2.1万人。NSA是全世界单独雇佣数学博士、计算机博士和语言学家最多的机构。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.297008547008547&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ109utYPRdgyoLMvXicMa1rQ3p1BEXVIOBX8C5wI72VhJmicEibiaJmib63X5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10QZOSj6x10piaRK8DfDVZRaibiacia4p7iaeIcKY0T5ruW43RKXg1GtLnGvQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;数据&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;2014年，NSA棱镜计划曝光前，几乎所有的美互联网巨头都是NSA的情报数据供应商...&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10pye66er4FWBmvia2Q5PAa3xep2bviaszgEqa9bQqJhYHbp0JDTGicLBVw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;460&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10au4nrZjDDKfsssCtMJnwLIKwzJvOq0IRricPia7VoCoweVVSpf89iaQWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;经费&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;2013年，斯诺登曾爆料NSA的预算是108亿美元；到&lt;/span&gt;&lt;span&gt;2016 年, 75岁的美国情报界领导人詹姆斯·克拉珀在退休前以国家情报计划的名义, 为NSA提交了539亿美元的预算申请…&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7497648165569144&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10uC7TvickZyOzUZI9tp01yDadKVWI2EZQ3fRFPTUzLG3Eicu9zDpyChsA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1063&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6675&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10gwOQ7s9H0ts2cy33ia9ZO4IUJj47Iu9xYibLHliaPIicgm6Q5X5Dt57icDg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;武器&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;em&gt;美国国防部曾定义了赛博空间能力术语:&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;cyberspace capability（赛博空间能力）- 某种电子设备或计算机程序，包括软件、硬件固件或硬件的任何组合，可以使用这类组合、集合在网络空间内或通过网络空间影响现实及物理空间，以产生预期的攻击破坏或操控效果。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;2013 年 12 月公开披露的49 页&lt;strong&gt;NSA ANT catalog(先进网络武器技术名册)&lt;/strong&gt;得知，NSA在手机、路由、服务器、移动通信网络、室内监控、USB接口、WIFI网络、防火墙、监控仪器、计算机终端等网络武器品类都拥有完备的设计和实现，NSA已经完整实现了美国防部描述的&lt;em&gt;赛博空间能力&lt;/em&gt;。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10gIBwRFxthYzzZZNmeiahWN1V2aZEzakjpmHOPibuzJIwIbkWcYHgicNEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10eq8h4YrexyeNKib33Vh69PjDkPrEB9kQQia5Sibics2JRN2VcqJZtQzSsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5770609318996416&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10s51Opcegeq8fAzy0v5ianuACVib6iaVVymsv9BLFOmmL73BzMQyHbibbkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.58203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10YPRFUIDgV7mic2vGIM6ePDCN3QBZ9bn9Pwiab74XnInF7iaJ9mG9r2vqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.34921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ103H92icshYE70S3JALlcaPu4vYA39PMB6UnyKzDj65iaM31ZPj7grJRXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.46328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10sxQ6slyB7Cl4jR0gMz3rTWBBXlaWzDicsGLeMDsQiaFrtF4Ocklwx1Rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10oVb9klPc9GFdbap00MM34NFJ6mA5H7HeRYia4o5I54Cj1nrI1DBGQrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10Hk3tLTcPKaCuuxEEicXmIXPiadURcp5sz3wNKCic4F9VGTp0p6pVBJhPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.58125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10ChqiaJNedtlovbYD4bvCeyBic6FB3OPrt7KYW7INb8tHWrgxF6cCejSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;感言&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;赛博空间中的每一个人，都可能是那些拥有高超网络空间攻防能力、巨量金钱和人才资源的恐怖怪物手中的操控木偶。等每一个人觉醒了安全意识，才会明白当年斯诺登的恐惧。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;斯诺登：我不希望看到，当我们终于决定挺身而出时，一切抵抗却是徒劳无功的…&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5537037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aff8CeTWGibAibjehDUG2Ulp7ShRhKZQ10ic8QbXZ8VBlKtP5iaX8icsGoaPDJ9NPkQxNRSA4ZAJmBL2RB1041dhGkg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.2725&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aff8CeTWGibASaIDrcB4HCs3oYQKhlYibUvuViaFWIxsO5ctfWibcN7L2g3eknzzbLhrEG32Jwso3FKeh9f187y61g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>