<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2481877ac2cff62af8595e54c1af3ece</guid>
<title>一个 Golang 版本 XSS 过滤模块</title>
<link>https://toutiao.io/k/dvqbquo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body entry-content container-lg&quot; itemprop=&quot;text&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://godoc.org/github.com/feiin/go-xss&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/5bb3441aa4a8749b7c48dff5c13111d8cbe9d48287e271daf903ba1aea68774e/68747470733a2f2f676f646f632e6f72672f6769746875622e636f6d2f666569696e2f676f2d7873733f7374617475732e737667&quot; alt=&quot;GoDoc&quot; data-canonical-src=&quot;https://godoc.org/github.com/feiin/go-xss?status.svg&quot;/&gt;&lt;/a&gt;
&lt;a href=&quot;https://travis-ci.org/feiin/go-xss&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/d9f09b6c5b5b400cce1292bd54b41d6f3a2cc24c3c31a8136fd229a08ef3722d/68747470733a2f2f7472617669732d63692e6f72672f666569696e2f676f2d7873732e7376673f6272616e63683d6d61696e&quot; alt=&quot;Build Status&quot; data-canonical-src=&quot;https://travis-ci.org/feiin/go-xss.svg?branch=main&quot;/&gt;&lt;/a&gt;
&lt;a href=&quot;https://goreportcard.com/report/github.com/feiin/go-xss&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/5a99ba2e6a459fad08c084351c013241ea0b4a1e0b6ecaed1a323a14d54e2357/68747470733a2f2f676f7265706f7274636172642e636f6d2f62616467652f6769746875622e636f6d2f666569696e2f676f2d787373&quot; alt=&quot;Go Report Card&quot; data-canonical-src=&quot;https://goreportcard.com/badge/github.com/feiin/go-xss&quot;/&gt;&lt;/a&gt;
&lt;a href=&quot;https://coveralls.io/github/feiin/go-xss?branch=main&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/0c70cbc425855c26a56d24d0f173db2f5073625220b9d6704ae2c5200ec0f3ef/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f666569696e2f676f2d7873732f62616467652e7376673f6272616e63683d6d61696e&quot; alt=&quot;Coverage Status&quot; data-canonical-src=&quot;https://coveralls.io/repos/github/feiin/go-xss/badge.svg?branch=main&quot;/&gt;&lt;/a&gt;
&lt;a href=&quot;https://github.com/feiin/go-xss/blob/main/LICENSE&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/1ac8ef5cc788f34924cd23002b2c5a759101a11390d796b0a8ba216284f4dd70/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f666569696e2f676f2d787373&quot; alt=&quot;GitHub license&quot; data-canonical-src=&quot;https://img.shields.io/github/license/feiin/go-xss&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;&lt;a id=&quot;user-content-go-xss-根据白名单过滤-html防止-xss-攻击&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#go-xss-根据白名单过滤-html防止-xss-攻击&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;go-xss 根据白名单过滤 HTML(防止 XSS 攻击)&lt;/h1&gt;
&lt;p&gt;go-xss is a module used to filter input from users to prevent XSS attacks&lt;/p&gt;
&lt;p&gt;go-xss是一个用于对用户输入的内容进行过滤，以避免遭受 XSS 攻击的模块（（&lt;a href=&quot;http://baike.baidu.com/view/2161269.htm&quot; rel=&quot;nofollow&quot;&gt;什么是 XSS 攻击？&lt;/a&gt;）。主要用于论坛、博客、网上商店等等一些可允许用户录入页面排版、格式控制相关的 HTML 的场景，xss模块通过白名单来控制允许的标签及相关的标签属性，另外还提供了一系列的接口以便用户扩展，比其他同类模块更为灵活。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/feiin/go-xss/blob/main/README.en.md&quot;&gt;English&lt;/a&gt; | 中文文档&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-特性&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#特性&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;白名单控制允许的 HTML 标签及各标签的属性&lt;/li&gt;
&lt;li&gt;通过自定义处理函数，可对任意标签及其属性进行处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-性能&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#性能&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;性能&lt;/h2&gt;
&lt;p&gt;speed: 24MB/s&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-安装&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#安装&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;go get -u github.com/feiin/go-xss

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-使用&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#使用&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;使用&lt;/h2&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; (
    &lt;span class=&quot;pl-s&quot;&gt;&quot;github.com/feiin/go-xss&quot;&lt;/span&gt;
)


&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;&amp;lt;a href=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;javascript:alert(/xss/)&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt; title=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;hi&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;&amp;gt;link&amp;lt;/a&amp;gt;&quot;&lt;/span&gt;

&lt;span class=&quot;pl-s1&quot;&gt;safeHtml&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;xss&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;FilterXSS&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt;,xss.&lt;span class=&quot;pl-smi&quot;&gt;XssOption&lt;/span&gt;{})&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; (
    &lt;span class=&quot;pl-s&quot;&gt;&quot;github.com/feiin/go-xss&quot;&lt;/span&gt;
)

&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;&amp;lt;a href=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;javascript:alert(/xss/)&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt; title=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;hi&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;&amp;gt;link&amp;lt;/a&amp;gt;&quot;&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;xss&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;NewXSS&lt;/span&gt;(xss.&lt;span class=&quot;pl-smi&quot;&gt;XssOption&lt;/span&gt;{})
&lt;span class=&quot;pl-s1&quot;&gt;safeHtml&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;x&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Process&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-自定义过滤规则options&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#自定义过滤规则options&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;自定义过滤规则（options)&lt;/h2&gt;
&lt;p&gt;在调用 &lt;code&gt;xss&lt;/code&gt; 进行过滤时，可通过options参数来设置自定义规则：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;&amp;lt;a href=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;javascript:alert(/xss/)&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt; title=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;hi&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;&amp;gt;link&amp;lt;/a&amp;gt;&quot;&lt;/span&gt;

&lt;span class=&quot;pl-s1&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; xss.&lt;span class=&quot;pl-smi&quot;&gt;XssOption&lt;/span&gt;{}
&lt;span class=&quot;pl-s1&quot;&gt;safeHtml&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;xss&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;FilterXSS&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt;,&lt;span class=&quot;pl-s1&quot;&gt;options&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不想每次都传入一个 options 参数，可以创建一个 XSS 实例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;&amp;lt;a href=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;javascript:alert(/xss/)&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt; title=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;hi&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;&amp;gt;link&amp;lt;/a&amp;gt;&quot;&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; xss.&lt;span class=&quot;pl-smi&quot;&gt;XssOption&lt;/span&gt;{}

&lt;span class=&quot;pl-s1&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;xss&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;NewXSS&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;options&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;safeHtml&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;x&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Process&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-白名单&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#白名单&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;白名单&lt;/h3&gt;
&lt;p&gt;通过 WhiteList 来指定，格式类型为：&lt;code&gt;map[string][]string&lt;/code&gt;。不在白名单上的标签将被过滤，不在白名单上的属性也会被过滤。以下是示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-c&quot;&gt;// 只允许a标签，该标签只允许href, title, target这三个属性&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;options&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;WhiteList&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;][]&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt; {
&lt;span class=&quot;pl-s&quot;&gt;&quot;a&quot;&lt;/span&gt;:{&lt;span class=&quot;pl-s&quot;&gt;&quot;href&quot;&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&quot;title&quot;&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&quot;target&quot;&lt;/span&gt;},
}
&lt;span class=&quot;pl-c&quot;&gt;// 使用以上配置后，下面的HTML&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;// &amp;lt;a href=&quot;#&quot; onclick=&quot;hello()&quot;&amp;gt;&amp;lt;i&amp;gt;大家好&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;// 将被过滤为&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;// &amp;lt;a href=&quot;#&quot;&amp;gt;大家好&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认白名单参考 &lt;code&gt;xss.GetDefaultWhiteList()&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-自定义匹配到标签时的处理方法&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#自定义匹配到标签时的处理方法&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;自定义匹配到标签时的处理方法&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;OnTag&lt;/code&gt; 来指定相应的处理函数。以下是详细说明：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;onTag&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;tag&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;TagOption&lt;/span&gt;) &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt; {
&lt;span class=&quot;pl-c&quot;&gt;// tag是当前的标签名称，比如&amp;lt;a&amp;gt;标签，则tag的值是&#x27;a&#x27;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// html是该标签的HTML，比如&amp;lt;a&amp;gt;标签，则html的值是&#x27;&amp;lt;a&amp;gt;&#x27;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// options是一些附加的信息，具体如下：&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;//   isWhite    boolean类型，表示该标签是否在白名单上&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;//   isClosing  boolean类型，表示该标签是否为闭合标签，比如&amp;lt;/a&amp;gt;时为true&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;//   position        integer类型，表示当前标签在输出的结果中的起始位置&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;//   sourcePosition  integer类型，表示当前标签在原HTML中的起始位置&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// 如果返回一个字符串，则当前标签将被替换为该字符串&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// 如果返回nil，则使用默认的处理方法：&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;//   在白名单上：  通过onTagAttr来过滤属性，详见下文&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;//   不在白名单上：通过onIgnoreTag指定，详见下文&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-自定义匹配到标签的属性时的处理方法&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#自定义匹配到标签的属性时的处理方法&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;自定义匹配到标签的属性时的处理方法&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;OnTagAttr&lt;/code&gt; 来指定相应的处理函数。以下是详细说明：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;OnTagAttr&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;tag&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;name&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;,&lt;span class=&quot;pl-s1&quot;&gt;isWhiteAttr&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;bool&lt;/span&gt;) &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt; {
&lt;span class=&quot;pl-c&quot;&gt;// tag是当前的标签名称，比如&amp;lt;a&amp;gt;标签，则tag的值是&#x27;a&#x27;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// name是当前属性的名称，比如href=&quot;#&quot;，则name的值是&#x27;href&#x27;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// value是当前属性的值，比如href=&quot;#&quot;，则value的值是&#x27;#&#x27;&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// isWhiteAttr是否为白名单上的属性&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// 如果返回一个字符串，则当前属性值将被替换为该字符串&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// 如果返回nil，则使用默认的处理方法&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;//   在白名单上：  调用safeAttrValue来过滤属性值，并输出该属性，详见下文&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;//   不在白名单上：通过onIgnoreTagAttr指定，详见下文&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-自定义匹配到不在白名单上的标签时的处理方法&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#自定义匹配到不在白名单上的标签时的处理方法&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;自定义匹配到不在白名单上的标签时的处理方法&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;OnIgnoreTag&lt;/code&gt; 来指定相应的处理函数。以下是详细说明：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;OnIgnoreTag&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;tag&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;TagOption&lt;/span&gt;) &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt; {
&lt;span class=&quot;pl-c&quot;&gt;// 参数说明与onTag相同&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// 如果返回非nil，则当前标签将被替换为该字符串&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// 如果返回nil，则使用默认的处理方法（通过escape指定，详见下文）&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-自定义匹配到不在白名单上的属性时的处理方法&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#自定义匹配到不在白名单上的属性时的处理方法&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;自定义匹配到不在白名单上的属性时的处理方法&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;OnIgnoreTagAttr&lt;/code&gt; 来指定相应的处理函数。以下是详细说明：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;OnIgnoreTagAttr&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;tag&lt;/span&gt;,&lt;span class=&quot;pl-s1&quot;&gt;name&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;,&lt;span class=&quot;pl-s1&quot;&gt;isWhiteAttr&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;bool&lt;/span&gt;) &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt; {
  &lt;span class=&quot;pl-c&quot;&gt;// 参数说明与onTagAttr相同&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// 如果返回一个字符串，则当前属性值将被替换为该字符串&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// 如果返回nil，则使用默认的处理方法（删除该属）&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-自定义-html-转义函数&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#自定义-html-转义函数&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;自定义 HTML 转义函数&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;EscapeHtml&lt;/code&gt; 来指定相应的处理函数。以下是默认代码 （不建议修改） ：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;EscapeHTML&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;regGT&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;ReplaceAllString&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;regLT&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;ReplaceAllString&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;html&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&quot;&amp;amp;lt;&quot;&lt;/span&gt;),&lt;span class=&quot;pl-s&quot;&gt;&quot;&amp;amp;gt;&quot;&lt;/span&gt;)
}&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-自定义标签属性值的转义函数&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#自定义标签属性值的转义函数&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;自定义标签属性值的转义函数&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;SafeAttrValue&lt;/code&gt; 来指定相应的处理函数。以下是详细说明：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;SafeAttrValue&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;tag&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;name&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt; {
&lt;span class=&quot;pl-c&quot;&gt;// 参数说明与onTagAttr相同（没有options参数）&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;// 返回一个字符串表示该属性值&lt;/span&gt;

}&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-自定义-css-过滤器&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#自定义-css-过滤器&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;自定义 CSS 过滤器&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-快捷配置&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#快捷配置&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;快捷配置&lt;/h2&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-去掉不在白名单上的标签&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#去掉不在白名单上的标签&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;去掉不在白名单上的标签&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;StripIgnoreTag&lt;/code&gt; 来设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;true：去掉不在白名单上的标签&lt;/li&gt;
&lt;li&gt;false：（默认），使用配置的escape函数对该标签进行转义
示例：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当设置 StripIgnoreTag = true时，以下代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;code:&amp;lt;script&amp;gt;alert(/xss/);&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;过滤后将输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;code:alert(/xss/);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-去掉不在白名单上的标签及标签体&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#去掉不在白名单上的标签及标签体&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;去掉不在白名单上的标签及标签体&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;StripIgnoreTagBody&lt;/code&gt; 来设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nil&lt;/code&gt;时：（默认），不特殊处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]string{}&lt;/code&gt;：(空数组) 去掉所有不在白名单上的标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]string{&quot;tag1&quot;, &quot;tag2&quot;}&lt;/code&gt;：仅去掉指定的不在白名单上的标签&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;当设置 &lt;code&gt;StripIgnoreTagBody = []string{&quot;script&quot;}时，以下代码&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;code:&amp;lt;script&amp;gt;alert(/xss/);&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;过滤后将输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;code:

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-去掉-html-备注&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#去掉-html-备注&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;去掉 HTML 备注&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;AllowCommentTag&lt;/code&gt; 来设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;true：不处理&lt;/li&gt;
&lt;li&gt;false：（默认），自动去掉 HTML 中的备注
示例：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当设置 &lt;code&gt;AllowCommentTag = false&lt;/code&gt; 时，以下代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;code:&amp;lt;!-- something --&amp;gt; END
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;过滤后将输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;code: END
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-应用实例&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#应用实例&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;应用实例&lt;/h2&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-允许标签以-data-开头的属性&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#允许标签以-data-开头的属性&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;允许标签以 data-开头的属性&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;&amp;lt;div a=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;1&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt; b=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;2&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt; data-a=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;3&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt; data-b=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;4&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;&amp;gt;hello&amp;lt;/div&amp;gt;&quot;&lt;/span&gt;;

&lt;span class=&quot;pl-s1&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;xss&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;FilterXSS&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt;,xss.&lt;span class=&quot;pl-smi&quot;&gt;XssOption&lt;/span&gt;{
&lt;span class=&quot;pl-c1&quot;&gt;OnIgnoreTagAttr&lt;/span&gt;: &lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;tag&lt;/span&gt;,&lt;span class=&quot;pl-s1&quot;&gt;name&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;,&lt;span class=&quot;pl-s1&quot;&gt;isWhiteAttr&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;bool&lt;/span&gt;) &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;len&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;name&lt;/span&gt;)&lt;span class=&quot;pl-c1&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;name&lt;/span&gt;[&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;pl-c1&quot;&gt;5&lt;/span&gt;] &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;data-&quot;&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;xss&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;EscapeAttrValue&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;)&lt;span class=&quot;pl-c1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;ret&lt;/span&gt;
}
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt;
},
})
&lt;span class=&quot;pl-s1&quot;&gt;fmt&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&quot;%s&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;convert to:&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;%s&quot;&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;html&lt;/span&gt;);&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div a=&quot;1&quot; b=&quot;2&quot; data-a=&quot;3&quot; data-b=&quot;4&quot;&amp;gt;hello&amp;lt;/div&amp;gt;
convert to:
&amp;lt;div data-a=&quot;3&quot; data-b=&quot;4&quot;&amp;gt;hello&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;允许名称以 x-开头的标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source := &quot;&amp;lt;x&amp;gt;&amp;lt;x-1&amp;gt;he&amp;lt;x-2 checked&amp;gt;&amp;lt;/x-2&amp;gt;wwww&amp;lt;/x-1&amp;gt;&amp;lt;a&amp;gt;&quot;;

html := xss.FilterXSS(source,xss.XssOption{
OnIgnoreTag: func(tag, html string, options xss.TagOption) *string {
if len(tag)&amp;gt;=2 &amp;amp;&amp;amp; tag[0:2] == &quot;x-&quot; {
return &amp;amp;html;
}
return nil
},
})
fmt.Printf(&quot;%s\nconvert to:\n%s&quot;, source, html);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;x&amp;gt;&amp;lt;x-1&amp;gt;he&amp;lt;x-2 checked&amp;gt;&amp;lt;/x-2&amp;gt;wwww&amp;lt;/x-1&amp;gt;&amp;lt;a&amp;gt;
convert to:
&amp;amp;lt;x&amp;amp;gt;&amp;lt;x-1&amp;gt;he&amp;lt;x-2 checked&amp;gt;&amp;lt;/x-2&amp;gt;wwww&amp;lt;/x-1&amp;gt;&amp;lt;a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-分析-html-代码中的图片列表&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#分析-html-代码中的图片列表&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;分析 HTML 代码中的图片列表&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;&amp;lt;img src=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;img1&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;&amp;gt;a&amp;lt;img src=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;img2&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;&amp;gt;b&amp;lt;img src=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;img3&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;&amp;gt;c&amp;lt;img src=&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;img4&lt;span class=&quot;pl-cce&quot;&gt;\&quot;&lt;/span&gt;&amp;gt;d&quot;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;list&lt;/span&gt; []&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;xss&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;FilterXSS&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt;,xss.&lt;span class=&quot;pl-smi&quot;&gt;XssOption&lt;/span&gt;{
&lt;span class=&quot;pl-c1&quot;&gt;OnTagAttr&lt;/span&gt;: &lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;tag&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;name&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt; ,&lt;span class=&quot;pl-s1&quot;&gt;isWhiteAttr&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;bool&lt;/span&gt;) &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;img&quot;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;src&quot;&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;list&lt;/span&gt;,&lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;)
}
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt;
},
})
&lt;span class=&quot;pl-s1&quot;&gt;fmt&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&quot;image list:&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;%s&quot;&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;strings&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Join&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;list&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&quot;,&quot;&lt;/span&gt;));&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-s1&quot;&gt;image&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;list&lt;/span&gt;:
&lt;span class=&quot;pl-s1&quot;&gt;img1&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;img2&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;img3&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;img4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-去除-html-标签只保留文本内容&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#去除-html-标签只保留文本内容&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;去除 HTML 标签（只保留文本内容）&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;&amp;lt;strong&amp;gt;hello&amp;lt;/strong&amp;gt;&amp;lt;script&amp;gt;alert(/xss/);&amp;lt;/script&amp;gt;end&quot;&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;xss&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;FilterXSS&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;source&lt;/span&gt;,xss.&lt;span class=&quot;pl-smi&quot;&gt;XssOption&lt;/span&gt;{
&lt;span class=&quot;pl-c1&quot;&gt;WhiteList&lt;/span&gt;:&lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;][]&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;{},  &lt;span class=&quot;pl-c&quot;&gt;// // empty, means filter out all tags&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;StripIgnoreTag&lt;/span&gt;:&lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;pl-c&quot;&gt;// filter out all HTML not in the whitelist&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;StripIgnoreTagBody&lt;/span&gt;:[]&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;{&lt;span class=&quot;pl-s&quot;&gt;&quot;script&quot;&lt;/span&gt;}, &lt;span class=&quot;pl-c&quot;&gt;// the script tag is a special case, we need&lt;/span&gt;
})
&lt;span class=&quot;pl-s1&quot;&gt;fmt&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&quot;text: %s&quot;&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;html&lt;/span&gt;);&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;text: helloend

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-inspirations&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#inspirations&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Inspirations&lt;/h2&gt;

&lt;h2&gt;&lt;a id=&quot;user-content-license&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#license&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;License&lt;/h2&gt;
&lt;p&gt;MIT&lt;/p&gt;
&lt;/article&gt;
      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>066e02a05cbdb11b34700efc69738bcc</guid>
<title>三万字，Spark 学习笔记</title>
<link>https://toutiao.io/k/wjp0vit</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;Spark 基础&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Spark特性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark使用简练优雅的Scala语言编写，基于Scala提供了交互式编程体验，同时提供多种方便易用的API。Spark遵循“一个软件栈满足不同应用场景”的设计理念，逐渐形成了一套完整的生态系统（包括 Spark提供内存计算框架、SQL即席查询（Spark  SQL）、流式计算（Spark  Streaming）、机器学习（MLlib）、图计算（Graph X）等），Spark可以部署在yarn资源管理器上，提供一站式大数据解决方案，可以同时支持批处理、流处理、交互式查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapReduce计算模型延迟高，无法胜任实时、快速计算的需求，因而只适用于离线场景，Spark借鉴MapReduce计算模式，但与之相比有以下几个优势（快、易用、全面）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Spark提供更多种数据集操作类型，编程模型比MapReduce更加灵活；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spark提供内存计算，将计算结果直接放在内存中，减少了迭代计算的IO开销，有更高效的运算效率。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spark基于DAG的任务调度执行机制，迭代效率更高；在实际开发中MapReduce需要编写很多底层代码，不够高效，Spark提供了多种高层次、简洁的API实现相同功能的应用程序，实现代码量比MapReduce少很多。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark作为计算框架只是取代了Hadoop生态系统中的MapReduce计算框架，它任需要HDFS来实现数据的分布式存储，Hadoop中的其他组件依然在企业大数据系统中发挥着重要作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spark的不足：&lt;/strong&gt;虽然Spark很快，但现在在生产环境中仍然不尽人意，无论扩展性、稳定性、管理性等方面都需要进一步增强；同时Spark在流处理领域能力有限，如果要实现亚秒级或大容量的数据获取或处理需要其他流处理产品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cloudera旨在让Spark流数据技术适用于80%的使用场合，就考虑到这一缺陷，在实时分析（而非简单数据过滤或分发）场景中，很多以前使用S4或Storm等流式处理引擎的实现已经逐渐被Kafka+Spark Streaming代替；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hadoop现在分三块HDFS/MR/YARN，Spark的流行将逐渐让MapReduce、Tez走进博物馆；Spark只是作为一个计算引擎比MR的性能要好，但它的存储和调度框架还是依赖于HDFS/YARN，Spark也有自己的调度框架，但不成熟，基本不可商用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Spark部署(on Yarn)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;YARN实现了一个集群多个框架”，即在一个集群上部署一个统一的资源调度管理框架，并部署其他各种计算框架，YARN为这些计算框架提供统一的资源调度管理服务，并且能够根据各种计算框架的负载需求调整各自占用的资源，实现集群资源共享和资源弹性收缩；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，YARN实现集群上的不同应用负载混搭，有效提高了集群的利用率；不同计算框架可以共享底层存储，避免了数据集跨集群移动 ；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用Spark on Yarn 模式部署，配置on yarn模式只需要修改很少配置，也不用使用启动spark集群命令，需要提交任务时候须指定在yarn上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark运行需要Scala语言，须下载Scala和Spark并解压到家目录，设置当前用户的环境变量（~/.bash_profile），增加SCALA_HOME和SPARK_HOME路径并立即生效；启动scala命令和spark-shell命令验证是否成功；Spark的配置文件修改按照官网教程不好理解，这里完成的配置参照博客及调试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark的需要修改两个配置文件：spark-env.sh和spark-default.conf，前者需要指明Hadoop的hdfs和yarn的配置文件路径及Spark.master.host地址，后者需要指明jar包地址；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spark-env.sh配置文件修改如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; JAVA_HOME=/home/stream/jdk1.8.0_144&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; SCALA_HOME=/home/stream/scala-2.11.12&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; HADOOP_HOME=/home/stream/hadoop-3.0.3&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; HADOOP_CONF_DIR=/home/stream/hadoop-3.0.3/etc/hadoop&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; YARN_CONF_DIR=/home/stream/hadoop-3.0.3/etc/hadoop&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; SPARK_MASTER_HOST=xx&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; SPARK_LOCAL_IP=xxx&lt;br/&gt;&lt;br/&gt;spark-default.conf配置修改如下：&lt;br/&gt;&lt;br/&gt;//增加jar包地址&lt;br/&gt;&lt;br/&gt;spark.yarn.jars=hdfs://1xxx/spark_jars/*&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该设置表明将jar地址定义在hdfs上，必须将~/spark/jars路径下所有的jar包都上传到hdfs的/spark_jars/路径(hadoop hdfs –put ~/spark/jars/*)，否则会报错无法找到编译jar包错误；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Spark启动和验证&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接无参数启动./spark-shell ，运行的是本地模式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动./spark-shell –master yarn，运行的是on yarn模式，前提是yarn配置成功并可用：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在hdfs文件系统中创建文件README.md，并读入RDD中，使用RDD自带的参数转换，RDD默认每行为一个值：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用./spark-shell --master  yarn启动spark 后运行命令：val textFile=sc.textFile(“README.md”)读取hdfs上的README.md文件到RDD，并使用内置函数测试如下，说明spark on yarn配置成功.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常见问题&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在启动spark-shell时候，报错Yarn-site.xml中配置的最大分配内存不足，调大这个值为2048M，需重启yarn后生效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置的hdfs地址冲突，hdfs的配置文件中hdfs-site.xml设置没有带端口，但是spark-default.conf中的spark.yarn.jars值带有端口，修改spark-default.conf的配置地址同前者一致：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Spark基本原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际应用中，大数据处理主要包括以下三个类型：复杂的批量数据处理：通常时间跨度在数十分钟到数小时之间；基于历史数据的交互式查询：通常时间跨度在数十秒到数分钟之间；基于实时数据流的数据处理：通常时间跨度在数百毫秒到数秒之间；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时存在以上场景需要同时部署多个组件，如:MapReduce/Impala/Storm，这样做难免会带来一些问题：不同场景之间输入输出数据无法做到无缝共享，通常需要进行数据格式的转换，不同的软件需要不同的开发和维护团队，带来了较高的使用成本，比较难以对同一个集群中的各个系统进行统一的资源协调和分配；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark的设计遵循“一个软件栈满足不同应用场景”的理念，逐渐形成了一套完整的生态系统，其生态系统包含了Spark Core、Spark SQL、Spark Streaming（ Structured Streaming）、MLLib和GraphX 等组件，既能够提供内存计算框架，也可以支持SQL即席查询、实时流式计算、机器学习和图计算等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且Spark可以部署在资源管理器YARN之上，提供一站式的大数据解决方案；因此，Spark所提供的生态系统足以应对上述三种场景，即批处理、交互式查询和流数据处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Spark概念/架构设计&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDD：是Resilient Distributed Dataset（弹性分布式数据集）的简称，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型 ；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DAG：是Directed Acyclic Graph（有向无环图）的简称，反映RDD之间的依赖关系 ；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Executor：是运行在工作节点（WorkerNode）的一个进程，负责运行Task ；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用（Application）：用户编写的Spark应用程序；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任务（ Task ）：运行在Executor上的工作单元 ；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作业（ Job ）：一个作业包含多个RDD及作用于相应RDD上的各种操作；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阶段（ Stage ）：是作业的基本调度单位，一个作业会分为多组任务，每组任务被称为阶段，或者也被称为任务集合，代表了一组关联的、相互之间没有Shuffle依赖关系的任务组成的任务集；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark运行架构包括集群资源管理器（Cluster Manager）、运行作业任务的工作节点（Worker Node）、每个应用的任务控制节点（Driver）和每个工作节点上负责具体任务的执行进程（Executor），资源管理器可以自带或使用Mesos/YARN；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个应用由一个Driver和若干个作业构成，一个作业由多个阶段构成，一个阶段由多个没有Shuffle关系的任务组成；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当执行一个应用时，Driver会向集群管理器申请资源，启动Executor，并向Executor发送应用程序代码和文件，然后在Executor上执行任务，运行结束后，执行结果会返回给Driver，或者写到HDFS或者其他数据库中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Spark运行流程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SparkContext对象代表了和一个集群的连接：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）首先为应用构建起基本的运行环境，即由Driver创建一个SparkContext，进行资源的申请、任务的分配和监控；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）资源管理器为Executor分配资源，并启动Executor进程；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）SparkContext根据RDD的依赖关系构建DAG图，DAG图提交给DAGScheduler解析成Stage，然后把一个个TaskSet提交给底层调度器TaskScheduler处理；Executor向SparkContext申请Task，Task Scheduler将Task发放给Executor运行，并提供应用程序代码；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）Task在Executor上运行，把执行结果反馈给TaskScheduler，然后反馈给DAGScheduler，运行完毕后写入数据并释放所有资源；&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;Spark RDD&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RDD概念/特性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;许多迭代式算法（比如机器学习、图算法等）和交互式数据挖掘工具，共同之处是不同计算阶段之间会重用中间结果， MapReduce框架把中间结果写入到稳定存储（如磁盘）中，带来大量的数据复制、磁盘IO和序列化开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDD就是为了满足这种需求而出现的，它提供了一个抽象的数据架构，开发者不必担心底层数据的分布式特性，只需将具体的应用逻辑表达为一系列转换处理，不同RDD之间的转换操作形成依赖关系，可以实现管道化，避免中间数据存储。一个RDD就是一个分布式对象集合，本质上是一个只读的分区记录集合，每个RDD可分成多个分区，每个分区就是一个数据集片段，并且一个RDD的不同分区可以被保存到集群中不同的节点上，从而可以在集群中的不同节点上进行并行计算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDD提供了一种高度受限的共享内存模型，即RDD是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集创建RDD，或者通过在其他RDD上执行确定的转换操作（如map、join和group by）而创建得到新的RDD。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDD提供了丰富的操作以支持常见数据运算，分“转换”（Transformation）和“动作”（Action）两种类型；RDD提供的转换接口都非常简单，都是类似map、filter、groupBy、join等粗粒度的数据转换操作，而不是针对某个数据项的细粒度修改（不适合网页爬虫），表面上RDD的功能很受限、不够强大，实际上RDD已经被实践证明可以高效地表达许多框架的编程模型（比如MapReduce、SQL、Pregel）；Spark用Scala语言实现了RDD的API，程序员可以通过调用API实现对RDD的各种操作&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDD典型的执行过程如下，这一系列处理称为一个Lineage（血缘关系），即DAG拓扑排序的结果：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RDD读入外部数据源进行创建；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RDD经过一系列的转换（Transformation）操作，每一次都会产生不同的RDD，供给下一个转换操作使用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后一个RDD经过“动作”操作进行转换，并输出到外部数据源&lt;strong&gt;优点：惰性调用、管道化、避免同步等待、不需要保存中间结果、操作简单；&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark采用RDD以后能够实现高效计算的原因主要在于：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）高容错性：血缘关系、重新计算丢失分区、无需回滚系统、重算过程在不同节点之间并行、只记录粗粒度的操作；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）中间结果持久化到内存：数据在内存中的多个RDD操作之间进行传递，避免了不必要的读写磁盘开销；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）存放的数据是Java对象：避免了不必要的对象序列化和反序列化；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RDD依赖关系&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark通过分析各个RDD的依赖关系生成了DAG，并根据RDD 依赖关系把一个作业分成多个阶段，阶段划分的依据是窄依赖和宽依赖，窄依赖可以实现流水线优化，宽依赖包含Shuffle过程，无法实现流水线方式处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;窄依赖表现为一个父RDD的分区对应于一个子RDD的分区或多个父RDD的分区对应于一个子RDD的分区；宽依赖则表现为存在一个父RDD的一个分区对应一个子RDD的多个分区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逻辑上每个RDD 操作都是一个fork/join（一种用于并行执行任务的框架），把计算fork 到每个RDD 分区，完成计算后对各个分区得到的结果进行join 操作，然后fork/join下一个RDD 操作；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDD Stage划分：Spark通过分析各个RDD的依赖关系生成了DAG，再通过分析各个RDD中的分区之间的依赖关系来决定如何划分Stage，具体方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在DAG中进行反向解析，遇到宽依赖就断开；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遇到窄依赖就把当前的RDD加入到Stage中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将窄依赖尽量划分在同一个Stage中，可以实现流水线计算；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RDD运行过程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述对RDD概念、依赖关系和Stage划分的介绍，结合之前介绍的Spark运行基本流程，总结一下RDD在Spark架构中的运行过程：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）创建RDD对象；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）SparkContext负责计算RDD之间的依赖关系，构建DAG；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）DAG Scheduler负责把DAG图分解成多个Stage，每个Stage中包含了多个Task，每个Task会被TaskScheduler分发给各个WorkerNode上的Executor去执行；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RDD创建&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDD的创建可以从从文件系统中加载数据创建得到，或者通过并行集合（数组）创建RDD。Spark采用textFile()方法来从文件系统中加载数据创建RDD，该方法把文件的URI作为参数，这个URI可以是本地文件系统的地址，或者是分布式文件系统HDFS的地址；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从文件系统中加载数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; val lines = sc.textFile(&lt;span&gt;&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从HDFS中加载数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; val lines = sc.textFile(&lt;span&gt;&quot;hdfs://localhost:9000/user/hadoop/word.txt&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（数组）上创建。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt;val array = Array(1,2,3,4,5)&lt;br/&gt;&lt;br/&gt;scala&amp;gt;val rdd = sc.parallelize(array)&lt;br/&gt;&lt;br/&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者从列表中创建：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt;val list = List(1,2,3,4,5)&lt;br/&gt;&lt;br/&gt;scala&amp;gt;val rdd = sc.parallelize(list)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RDD操作&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于RDD而言，每一次转换操作都会产生不同的RDD，供给下一个“转换”使用，转换得到的RDD是惰性求值的，也就是说，整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会发生真正的计算，开始从血缘关系源头开始，进行物理的转换操作；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的RDD转换操作，总结如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9522058823529411&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z2DApiaibzMicicOqmeSH8neNob7fheLeK3mqKD9ibibfMVa8oOg0EUC1lnNb4tnKy7NmptFZfTpKFv6V6Dnm2jf4uyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;544&quot;/&gt;filter(func)操作：筛选出满足函数func的元素，并返回一个新的数据集&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt;  val  lines =sc.textFile(file:///usr/&lt;span&gt;local&lt;/span&gt;/spark/mycode/rdd/word.txt)&lt;br/&gt;&lt;br/&gt;scala&amp;gt;  val  linesWithSpark=lines.filter(line =&amp;gt; line.contains(&lt;span&gt;&quot;Spark&quot;&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;map(func)操作：map(func)操作将每个元素传递到函数func中，并将结果返回为一个新的数据集&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; data=Array(1,2,3,4,5)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val  rdd1= sc.parallelize(data)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val  rdd2=rdd1.map(x=&amp;gt;x+10)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个实例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; val  lines = sc.textFile(&lt;span&gt;&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val  words=lines.map(line =&amp;gt; line.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;flatMap(func)操作：拍扁操作&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; val  lines = sc.textFile(&lt;span&gt;&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val  words=lines.flatMap(line =&amp;gt; line.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;groupByKey()操作：应用于(K,V)键值对的数据集时，返回一个新的(K, Iterable)形式的数据集；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;reduceByKey(func)操作：应用于(K,V)键值对的数据集返回新(K, V)形式数据集，其中每个值是将每个key传递到函数func中进行聚合后得到的结果：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;行动操作是真正触发计算的地方。Spark程序执行到行动操作时，才会执行真正的计算，这就是惰性机制，“惰性机制”是指，整个转换过程只是记录了转换的轨迹，并不会发生真正的计算，只有遇到行动操作时，才会触发“从头到尾”的真正的计算，常用的行动操作：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0610021786492374&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z2DApiaibzMicicOqmeSH8neNob7fheLeK3mH30Za5gT2x1ICyCZZfATCcL8hevia0Aguaygm6icTlCPf1sOhL6xCwlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;459&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RDD持久&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark RDD采用惰性求值的机制，但是每次遇到行动操作都会从头开始执行计算，每次调用行动操作都会触发一次从头开始的计算，这对于迭代计算而言代价是很大的，迭代计算经常需要多次重复使用同一组数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; val  list = List(&lt;span&gt;&quot;Hadoop&quot;&lt;/span&gt;,&lt;span&gt;&quot;Spark&quot;&lt;/span&gt;,&lt;span&gt;&quot;Hive&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val  rdd = sc.parallelize(list)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; println(rdd.count())  //行动操作，触发一次真正从头到尾的计算&lt;br/&gt;&lt;br/&gt;scala&amp;gt; println(rdd.collect().mkString(&lt;span&gt;&quot;,&quot;&lt;/span&gt;))  //行动操作，触发一次真正从头到尾的计算&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过持久化（缓存）机制避免这种重复计算的开销，可以使用persist()方法对一个RDD标记为持久化，之所以说“标记为持久化”，是因为出现persist()语句的地方，并不会马上计算生成RDD并把它持久化，而是要等到遇到第一个行动操作触发真正计算以后，才会把计算结果进行持久化，持久化后的RDD将会被保留在计算节点的内存中被后面的行动操作重复使用；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;persist()的圆括号中包含的是持久化级别参数，persist(MEMORY_ONLY)表示将RDD作为反序列化的对象存储于JVM中，如果内存不足，就要按照LRU原则替换缓存中的内容；persist(MEMORY_AND_DISK)表示将RDD作为反序列化的对象存储在JVM中，如果内存不足，超出的分区将会被存放在硬盘上；一般而言，使用cache()方法时，会调用persist(MEMORY_ONLY)，同时可以使用unpersist()方法手动地把持久化的RDD从缓存中移除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对上面的实例，增加持久化语句以后的执行过程如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; val  list = List(&lt;span&gt;&quot;Hadoop&quot;&lt;/span&gt;,&lt;span&gt;&quot;Spark&quot;&lt;/span&gt;,&lt;span&gt;&quot;Hive&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val  rdd = sc.parallelize(list)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; rdd.cache()  //会调用persist(MEMORY_ONLY)，但是，语句执行到这里，并不会缓存rdd，因为这时rdd还没有被计算生成&lt;br/&gt;&lt;br/&gt;scala&amp;gt; println(rdd.count()) //第一次行动操作，触发一次真正从头到尾的计算，这时上面的rdd.cache()才会被执行，把这个rdd放到缓存中&lt;br/&gt;&lt;br/&gt;scala&amp;gt; println(rdd.collect().mkString(&lt;span&gt;&quot;,&quot;&lt;/span&gt;)) //第二次行动操作，不需要触发从头到尾的计算，只需要重复使用上面缓存中的rdd&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RDD分区&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDD是弹性分布式数据集，通常RDD很大，会被分成很多个分区分别保存在不同的节点上，分区的作用：（1）增加并行度（2）减少通信开销。RDD分区原则是使得分区的个数尽量等于集群中的CPU核心（core）数目，对于不同的Spark部署模式而言（本地模式、Standalone模式、YARN模式、Mesos模式），都可以通过设置spark.default.parallelism这个参数的值，来配置默认的分区数目，一般而言：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地模式：默认为本地机器的CPU数目，若设置了local[N],则默认为N；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Standalone或YARN：在“集群中所有CPU核心数目总和”和2二者中取较大值作为默认值；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置分区的个数有两种方法：创建RDD时手动指定分区个数，使用reparititon方法重新设置分区个数；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建RDD时手动指定分区个数：在调用textFile()和parallelize()方法的时候手动指定分区个数即可，语法格式如 sc.textFile(path, partitionNum)，其中path参数用于指定要加载的文件的地址，partitionNum参数用于指定分区个数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; val  array = Array(1,2,3,4,5)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val  rdd = sc.parallelize(array,2)  //设置两个分区&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;reparititon方法重新设置分区个数：通过转换操作得到新 RDD 时，直接调用 repartition 方法即可，如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; val  data = sc.textFile(&lt;span&gt;&quot;file:///usr/local/spark/mycode/rdd/word.txt&quot;&lt;/span&gt;,2)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; data.partitions.size  //显示data这个RDD的分区数量&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val  rdd = data.repartition(1)  //对data这个RDD进行重新分区&lt;br/&gt;&lt;br/&gt;scala&amp;gt; rdd.partitions.size&lt;br/&gt;&lt;br/&gt;res4: Int = 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;Spark-shell批处理&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完成Spark部署后，使用spark-shell指令进入Scala交互编程界面，spark-shell默认创建一个sparkContext（sc），在spark-shell启动时候可以查看运行模式是on yarn还是local模式，使用交互式界面可以直接引用sc变量使用；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Spark-shell处理数据实例：读取HDFS文件系统中文件实现WordCount 单词计数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sc.textFile(&lt;span&gt;&quot;hdfs://172.22.241.183:8020/user/spark/yzg_test.txt&quot;&lt;/span&gt;).flatMap(_.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;)).map((_,1)).reduceByKey(_+_).collect()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，map((_,1)) 等同于map(x =&amp;gt; (x, 1))&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用saveAsText
File()函数可以将结果保存到文件系统中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;Scala及函数式编程&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark采用Scala语言编写，在开发中需要熟悉函数式编程思想，并熟练使用Scala语言，使用Scala进行Spark开发的代码量大大少于Java开发的代码量；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;函数式编程特性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数式编程属于声明式编程的一种，将计算描述为数学函数的求值，但函数式编程没有准确的定义，只是一系列理念，并不需要严格准守，可以理解为函数式编程把程序看做是数学函数，输入的是自变量，输出因变量，通过表达式完成计算，当前越来越多的命令式语言支持部分的函数式编程特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在函数式编程中，函数作为一等公民，就是说函数的行为和普通变量没有区别，可以作为函参进行传递，也可以在函数内部声明一个函数，那么外层的函数就被称作高阶函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数式编程的curry化：把接受多个参数的函数变换成接受一个单一参数的函数，返回接受余下的参数并且返回结果的新函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数式编程要求所有的变量都是常量（这里所用的变量这个词并不准确，只是为了便于理解），erlang是其中的典型语言，虽然许多语言支持部分函数式编程的特性，但是并不要求变量必须是常量。这样的特性提高了编程的复杂度，但是使代码没有副作用，并且带来了很大的一个好处，那就是大大简化了并发编程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中最常用的并发模式是共享内存模型，依赖于线程与锁，若代码编写不当，会发生死锁和竞争条件，并且随着线程数的增加，会占用大量的系统资源。在函数式编程中，因为都是常量，所以根本就不用考虑死锁等情况。为什么说一次赋值提高了编程的复杂度，既然所有变量都是常量，那么我们没办法更改一个变量的值，循环的意义也就不大，所以haskell与erlang中使用递归代替了循环。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Scala语法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Scala即可伸缩的语言（Scalable Language），是一种多范式的编程语言，类似于java的编程，设计初衷是要集成面向对象编程和函数式编程的各种特性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Scala函数地位：一等公民&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Scala中函数是一等公民，像变量一样既可以作为函参使用，也可以将函数赋值给一个变量；而且函数的创建不用依赖于类、或对象，在Java中函数的创建则要依赖于类、抽象类或者接口。Scala函数有两种定义：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Scala的函数定义规范化写法，最后一行代码是它的返回值：&lt;img data-ratio=&quot;0.3082706766917293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z2DApiaibzMicicOqmeSH8neNob7fheLeK3mgvDJUCu3f9b2X8r2ibCnBYhn5ribyWu5yB8zUkyhspLuQcgPbCYmH5vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;399&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;精简后函数定义可以只有一行：&lt;img data-ratio=&quot;0.12608695652173912&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z2DApiaibzMicicOqmeSH8neNob7fheLeK3mV4rrlA6dfa7ekhoA0MSRo46OAb1TYygbRIibATpVwgUhaQJ8Jvxlbibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;460&quot;/&gt;也可以直接使用val将函数定义成变量，表示定义函数addInt,输入参数有两个，分别为x,y,均为Int类型，返回值为两者的和，类型Int：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11494252873563218&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z2DApiaibzMicicOqmeSH8neNob7fheLeK3mPKVNrO1xpOwcecsoeNpe7Yu3zr89p6yxjTDXQ4aibibEH2zoexgaWFeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;435&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Scala匿名函数(函数字面量)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Scala中的匿名函数也叫做函数字面量，既可以作为函数的参数使用，也可以将其赋值给一个变量，在匿名函数的定义中“=&amp;gt;”可理解为一个转换器，它使用右侧的算法，将左侧的输入数据转换为新的输出数据，使用匿名函数后，我们的代码变得更简洁了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;val &lt;span&gt;test&lt;/span&gt; = (x:Int) =&amp;gt; x + 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Scala高阶函数&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Scala使用术语“高阶函数”来表示那些把函数作为参数或函数作为返回结果的方法和函数。比如常见的有map,filter,reduce等函数，它们可以接受一个函数作为参数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Scala闭包&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Scala中的闭包指的是当函数的变量超出它的有效作用域的时候，还能对函数内部的变量进行访问；Scala中的闭包捕获到的是变量的本身而不仅仅是变量的数值，当自由变量发生变化时，Scala中的闭包能够捕获到这个变化；如果自由变量在闭包内部发生变化，也会反映到函数外面定义的自由变量的数值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Scala部分应用函数&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部分应用函数只是在“已有函数”的基础上，提供部分默认参数，未提供默认参数的地方使用下划线替代，从而创建出一个“函数值”，在使用这个函数值（部分应用函数）的时候，只需提供下划线部分对应的参数即可；部分应用函数本质上是一种值类型的表达式,在使用的时候不需要提供所有的参数,只需要提供部分参数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Scala柯里化函数&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;scala中的柯里化指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程，新的函数返回一个以原有第二个参数作为参数的函数；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;def someAction(f:(Double)=&amp;gt;Double) = f(10)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5268096514745308&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z2DApiaibzMicicOqmeSH8neNob7fheLeK3mcQve4d9KQA2uIWbARFKzLyqDuYiaLbBeaHjkbyoG8BnyAaUHMryS1lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;只要满足：函数参数是一个double、返回值也是一个double，这个函数就可以作为f值；&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;Spark SQL&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Shark和Spark SQL&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Shark的出现，使得SQL-on-Hadoop的性能比Hive有了10-100倍的提高,但Shark的设计导致了两个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一是执行计划优化完全依赖于Hive，不方便添加新的优化策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二是因为Spark是线程级并行，而MapReduce是进程级并行，因此，Spark在兼容Hive的实现上存在线程安全问题，导致Shark不得不使用另外一套独立维护的打了补丁的Hive源码分支 ；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark SQL在Hive兼容层面仅依赖HiveQL解析、Hive元数据，也就是说，从HQL被解析成抽象语法树（AST）起，就全部由Spark SQL接管了。Spark SQL执行计划生成和优化都由Catalyst（函数式关系查询优化框架）负责 ；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;DataFrame和RDD&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark SQL增加了DataFrame（即带有Schema信息的RDD），使用户可以在Spark SQL中执行SQL语句，数据既可以来自RDD，也可以是Hive、HDFS、Cassandra等外部数据源，还可以是JSON格式的数据，Spark SQL目前支持Scala、Java、Python三种语言，支持SQL-92规范 ；&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;DataFrame的推出，让Spark具备了处理大规模结构化数据的能力，不仅比原有的RDD转化方式更加简单易用，且获得了更高的计算性能；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spark可轻松实现从MySQL到DataFrame的转化，且支持SQL查询；&lt;img data-ratio=&quot;0.5038402457757296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/z2DApiaibzMicicOqmeSH8neNob7fheLeK3mEiafM2VAMndibcV5Ve8USa4q6tot1EvZc8xZApYGamIJz4Uukgn4NAuw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;651&quot;/&gt;RDD是分布式的 Java对象的集合，但是，对象内部结构对于RDD而言却是不可知的；DataFrame是一种以RDD为基础的分布式数据集，提供了详细的结构信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDD就像一个屋子，找东西要把这个屋子翻遍才能找到；DataFrame相当于在你的屋子里面打上了货架，只要告诉他你是在第几个货架的第几个位置， DataFrame就是在RDD基础上加入了列，处理数据就像处理二维表一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DataFrame与RDD的主要区别在于，前者带schema元信息，即DataFrame表示的二维表数据集的每一列都带有名称和类型。这使得Spark SQL得以洞察更多的结构信息，从而对藏于DataFrame背后的数据源以及作用于DataFrame之上的变换进行了针对性的优化，最终达到大幅提升运行时效率的目标。反观RDD，由于无从得知所存数据元素的具体内部结构，Spark Core只能在stage层面进行简单、通用的流水线优化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;DataFrame的创建&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark2.0版本开始，Spark使用全新的SparkSession接口替代Spark1.6中的SQLContext及HiveContext接口来实现其对数据加载、转换、处理等功能。SparkSession实现了SQLContext及HiveContext所有功能；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SparkSession支持从不同的数据源加载数据，并把数据转换成DataFrame，支持把DataFrame转换成SQLContext自身中的表，然后使用SQL语句来操作数据。SparkSession亦提供了HiveQL以及其他依赖于Hive的功能的支持；可以通过如下语句创建一个SparkSession对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; import org.apache.spark.sql.SparkSession&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val spark=SparkSession.builder().getOrCreate()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建DataFrame前，为支持RDD转换为DataFrame及后续的SQL操作，需通过import语句（即import spark.implicits._）导入相应包，启用隐式转换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建DataFrame时，可使用spark.read操作从不同类型的文件中加载数据创建DataFrame，如：spark.read.json(&quot;people.json&quot;)：读取people.json文件创建DataFrame；在读取本地文件或HDFS文件时，要注意给出正确的文件路径；spark.read.csv(&quot;people.csv&quot;)：读取people.csv文件创建DataFrame；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读取hdfs上的json文件，并打印，json文件为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;Michael&quot;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;{&lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;Andy&quot;&lt;/span&gt;, &lt;span&gt;&quot;age&quot;&lt;/span&gt;:30}&lt;br/&gt;&lt;br/&gt;{&lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;Justin&quot;&lt;/span&gt;, &lt;span&gt;&quot;age&quot;&lt;/span&gt;:19}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读取代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import org.apache.spark.sql.SparkSession&lt;br/&gt;&lt;br/&gt;val spark=SparkSession.builder().getOrCreate()&lt;br/&gt;&lt;br/&gt;import spark.implicits._&lt;br/&gt;&lt;br/&gt;val df =spark.read.json(&lt;span&gt;&quot;hdfs://172.22.241.183:8020/user/spark/json_sparksql.json&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;df.show()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RDD转换DataFrame&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark官网提供了两种方法来实现从RDD转换得到DataFrame：① 利用反射来推断包含特定类型对象的RDD的schema，适用对已知数据结构的RDD转换；② 使用编程接口，构造一个schema并将其应用在已知的RDD上；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Spark-sql即席查询&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SparkSQL 的元数据的状态有两种：①  in_memory，用完了元数据也就丢了；② 通过hive保存，hive的元数据存在哪儿，它的元数据也就存在哪，SparkSQL数据仓库建立在Hive之上实现的，使用SparkSQL去构建数据仓库的时候，必须依赖于Hive。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark-sql命令行提供了即席查询能力，可以使用类sql方式操作数据源，效率高于hive，常用语句：https://www.cnblogs.com/BlueSkyyj/p/9640626.html；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spark-sql导入数据到数仓：https://www.cnblogs.com/chenfool/p/4502212.html；&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;Spark Streaming&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark Streaming是Spark Core扩展而来的一个高吞吐、高容错的实时处理引擎，同Storm的最大区别在于无法实现毫秒级计算，而Storm可以实现毫秒级响应，Spark Streaming 实现方式是批量计算，按照时间片对stream切割形成静态数据，并且基于RDD数据集更容易做高效的容错处理。Spark Streaming的输入和输出数据源可以是多种。Spark  Streaming 实时读取数据并将数据分为小批量的batch，然后在spark引擎中处理生成批量的结果集。Spark Streaming提供了称为离散流或DStream的高级抽象概念，它表示连续的数据流。DStreams既可以从Kafka、Flume等源的输入数据流创建，也可以通过在其他DStreams上应用高级操作创建。在内部DStream表示为RDD序列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里从一个例子开始介绍，StreamingContext是所有的流式计算的主要实体，创建含有两个执行线程的本地StreamingContext和1秒钟的batch，然后创建一个Dstream（lines）用于监听TCP端口，lines中的每一行就是一个RDD，flatMap函数将一个RDD分解成多个记录，是一对多的Dstream操作，这里使用空格将lines分解成单词，words被映射成(word, 1)对，随后进行词频统计，例子的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import org.apache.spark._&lt;br/&gt;&lt;br/&gt;import org.apache.spark.streaming._&lt;br/&gt;&lt;br/&gt;val conf = new SparkConf().setMaster(&lt;span&gt;&quot;local[2]&quot;&lt;/span&gt;).setAppName(&lt;span&gt;&quot;NetworkWordCount&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;val ssc = new StreamingContext(conf, Seconds(1))&lt;br/&gt;&lt;br/&gt;val lines = ssc.socketTextStream(&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;, 9999)&lt;br/&gt;&lt;br/&gt;val words = lines.flatMap(_.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;val pairs = words.map(word =&amp;gt; (word, 1))&lt;br/&gt;&lt;br/&gt;val wordCounts = pairs.reduceByKey(_ + _)&lt;br/&gt;&lt;br/&gt;wordCounts.print()&lt;br/&gt;&lt;br/&gt;ssc.start()&lt;br/&gt;&lt;br/&gt;ssc.awaitTermination()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Streaming 原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以参考官网教程：http://spark.apache.org/docs/latest/streaming-programming-guide.html，Spark Streaming提供了称为离散流或DStream的高级抽象，它表示连续的数据流，在内部DStream表示为RDD序列，每个RDD包含一定间隔的数据，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有对于DStream的操作都会相应地转换成对RDDs的操作，在上面的例子中，flatMap操作被应用到lines 中的每个RDD中生成了一组RDD（即words）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结编写Spark Streaming程序的基本步骤是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.通过创建输入DStream来定义输入源&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.通过对DStream应用转换操作和输出操作来定义流计算&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.用streamingContext.start()来开始接收数据和处理流程&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.通过streamingContext.awaitTermination()方法来等待处理结束（手动结束或因为错误而结束）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5.可以通过streamingContext.stop()来手动结束流计算进程&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;StreamingContext&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种创建StreamingContext的方式：通过SparkContext创建和通过SparkConf创建；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark conf创建：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;val conf = new SparkConf().setAppName(appName).setMaster(master);&lt;br/&gt;&lt;br/&gt;val ssc = new StreamingContext(conf, Seconds(1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;appName是用来在Spark UI上显示的应用名称。master是Spark、Mesos或Yarn集群的URL，或者是local[*]。batch interval可以根据你的应用程序的延迟要求以及可用的集群资源情况来设置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SparkContext创建：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;val sc = new SparkContext(conf)&lt;br/&gt;&lt;br/&gt;val ssc = new StreamingContext(sc, Seconds(1))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;输入DStreams和Receiver&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面的例子中lines就是从源得到的输入DStream，输入DStream对应一个接收器对象，可以从源接收消息并存储到Spark内存中进行处理。Spark Streaming提供两种streaming源：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基础源：直接可以使用streaming上下文API的源，比如files和socket；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高级源：通过引用额外实体类得到的Kafka，Flume源；可以在应用中创建使用多个输入DStreams来实现同时读取多种数据流，worker/executor 是持久运行的任务，因此它将占用一个分给该应用的core，因此Spark Streaming需要分配足够的core去运行接收器和处理接收的数据；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本地运行Spark Streaming程序时，不要使用“local”或“local[1]”作为主URL。这两者中的任何一个都意味着在本地运行任务只使用一个线程。如果使用基于receiver的输入DStream（如Kafka、Flume等），这表明将使用单个线程运行receiver，而不留下用于处理所接收数据的线程。因此在本地运行时，始终使用“local[n]”作为主URL，其中n必须大于运行的receiver数量，否则系统将接收数据，但不能处理它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka和Flume这类源需要外部依赖包，其中一些库具有复杂的依赖关系，Spark shell中没有这些高级源代码，因此无法在spark-shell中测试基于这些高级源代码的应用程序，但可以手动将包引入；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于可靠性的考虑，可以将数据源分为两类：可靠的接收器的数据被Receiver 接收后发送确认到源头（如Kafka ,Flume）并将数据存储在spark，不可靠的接收器不会向源发送确认。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;DStreams转换&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与RDD类似，转换操作允许修改来自输入DStream的数据，转换操作包括无状态转换操作和有状态转换操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无状态转换操作实例：下节spark-shell中“套接字流”词频统计采用无状态转换，每次统计都只统计当前批次到达的单词的词频，和之前批次无关，不会进行累计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有状态转换操作实例：滑动窗口转换操作和updateStateByKey操作；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些常见的转换如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;窗口操作&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次窗口在源DStream上滑动，窗口内的源RDD被组合/操作生成了窗口RDD，在图例中，过去3个时间单位的数据将被操作，并按2个时间单位滑动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何窗口操作都需要指定两个参数：窗口长度：窗口的持续时间（图中值是3）；滑动间隔：执行窗口操作的间隔（图中值是2）。这两个参数必须是源DStream的批处理间隔的倍数（图中值是1）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例说明窗口操作：希望通过每隔10秒在最近30秒数据中生成字数来扩展前面的示例。为此，我们必须在最近的30秒数据上对（word,1）的DStream键值对应用reduceByKey操作。这是使用reduceByKeyAndWindow操作完成的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;val windowedWordCounts = pairs.reduceByKeyAndWindow((a:Int,b:Int) =&amp;gt; (a + b), Seconds(30), Seconds(10))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有的滑动窗口操作都需要使用参数：windowLength（窗口长度）和slideInterval（滑动间隔），常见窗口操作总结如下，对应的含义可参照RDD的转换操作：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.670846394984326&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z2DApiaibzMicicOqmeSH8neNob7fheLeK3moFBT3tlT2JqdCXAxpUYAo7DaMIqoRgUKuNyBcWsrTez4yOTdsoz79w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Window：基于源DStream产生的窗口化的批数据计算得到新的Dstream；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;countByWindow: 返回DStream中元素的滑动窗口计数；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;reduceByWindow：返回一个单元素流。利用函数func聚集滑动时间间隔的流的元素创建这个单元素流。函数func必须满足结合律从而支持并行计算；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;reduceByKeyAndWindow(三参数)：应用到一个(K,V)键值对组成的DStream上时，会返回一个由(K,V)键值对组成的新的DStream。每一个key的值均由给定的reduce函数(func函数)进行聚合计算。注意：在默认情况下，这个算子利用了Spark默认的并发任务数去分组。可以通过numTasks参数的设置来指定不同的任务数；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;reduceByKeyAndWindow(四参数)：比上述reduceByKeyAndWindow（三参数）更高效的reduceByKeyAndWindow，每个窗口的reduce值是基于先前窗口的reduce值进行增量计算得到的；它会对进入滑动窗口的新数据进行reduce操作，并对离开窗口的老数据进行“逆向reduce”操作。但是，只能用于“可逆reduce函数”，即那些reduce函数都有一个对应的“逆向reduce函数”（以InvFunc参数传入）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;countByValueAndWindow：当应用到一个(K,V)键值对组成的DStream上，返回一个由(K,V)键值对组成的新的DStream。每个key的值都是它们在滑动窗口中出现的频率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;updateStateByKey：需要在跨批次之间维护状态时，必须使用updateStateByKey操作；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多流关联&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;窗口计算上join操作非常有用，在Spark Streaming中可以轻松实现不同类型的join，包括leftouterjoin、rightouterjoin和fulloterjoin。每个批处理间隔中stream1生成的RDD与stream2生成的RDD关联如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;val stream1: DStream[String, String] = ...&lt;br/&gt;&lt;br/&gt;val stream2: DStream[String, String] = ...&lt;br/&gt;&lt;br/&gt;val joinedStream = stream1.join(stream2)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Dstream的输出&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出操作允许将DStream的数据推送到外部系统，如数据库或files，由于输出操作触发所有DStream转换的实际执行（类似于RDD的操作），并允许外部系统使用转换后的数据，输出操作有以下几种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6486111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z2DApiaibzMicicOqmeSH8neNob7fheLeK3mBOgPmZxiaKQJFV5Z0ibniaMnNZtBv8OW2DMZN2ZuWJNtcCLibVP0ZYmSaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;在输出DStream中，Dstream.foreachRDD是一个功能强大的原语.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;DataFrame和SQL操作&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以轻松地对流数据使用DataFrames和SQL操作，但必须使用StreamingContext正在用的SparkContext创建SparkSession。下面例子使用DataFrames和SQL生成单词计数。每个RDD都转换为DataFrame，注册为临时表后使用SQL进行查询：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;val words: DStream[String] =&lt;br/&gt;&lt;br/&gt;words.foreachRDD { rdd =&amp;gt;&lt;br/&gt;&lt;br/&gt;val spark = SparkSession.builder.config(rdd.sparkContext.getConf).getOrCreate()&lt;br/&gt;&lt;br/&gt;import spark.implicits._&lt;br/&gt;&lt;br/&gt;val wordsDataFrame = rdd.toDF(&lt;span&gt;&quot;word&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;wordsDataFrame.createOrReplaceTempView(&lt;span&gt;&quot;words&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;val wordCountsDataFrame = spark.sql(&lt;span&gt;&quot;select word, count(*) as total from words group by word&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;wordCountsDataFrame.show()&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Spark-shell流处理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入spark-shell后就默认获得了的SparkConext，即sc，从SparkConf对象创建StreamingContext对象，spark-shell中创建StreamingContext对象如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; import org.apache.spark.streaming._&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val ssc = new StreamingContext(sc, Seconds(1))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是编写一个独立的Spark Streaming程序，而不是在spark-shell中运行，则需要通过如下方式创建StreamingContext对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import org.apache.spark._&lt;br/&gt;&lt;br/&gt;import org.apache.spark.streaming._&lt;br/&gt;&lt;br/&gt;val conf = new SparkConf().setAppName(&lt;span&gt;&quot;TestDStream&quot;&lt;/span&gt;).setMaster(&lt;span&gt;&quot;local[2]&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;val ssc = new StreamingContext(conf, Seconds(1))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件流&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件流可以读取本机文件，也可以读取读取HDFS上文件，如果部署的on yarn模式的Spark，则启动spark-shell默认读取HDFS上对应的: hdfs:xxxx/user/xx/ 下的文件；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; import org.apache.spark.streaming._&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val ssc = new StreamingContext(sc, Seconds(5))&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val lines = ssc.textFileStream(&lt;span&gt;&quot;hdfs://xxx/yzg_test.txt&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val Counts = lines.flatMap(_.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;)).map((_,1)).reduceByKey(_ + _)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; Counts.saveAsTextFiles(&lt;span&gt;&quot;hdfs://xxx/bendi&quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;scala&amp;gt; ssc.start()&lt;br/&gt;&lt;br/&gt;scala&amp;gt; ssc.awaitTermination()&lt;br/&gt;&lt;br/&gt;scala&amp;gt; ssc.stop()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码在spark-shell中运行后，每隔5秒读取hdfs上的文件并进行词频统计后写入到hdfs中的“bendi-时间戳”文件夹下，直到ssc.stop()；Counts.saveAsTextFiles(&quot;file://xxx/bendi&quot;))和Counts.print分别写本地和std输出；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Socket套接字流&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spark Streaming可以通过Socket端口实时监听并接收数据计算，步骤如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;driver端创建StreamingContext对象，启动上下文时依次创建JobScheduler和ReceiverTracker，并调用他们的start方法。ReceiverTracker在start方法中发送启动接收器消息给远程Executor，消息内部含有ServerSocket的地址信息。在executor一侧，由Receiver TrackerEndpoint终端接受消息，抽取消息内容，利用sparkContext结合消息内容创建ReceiverRDD对象，最后提交rdd给spark集群。在代码实现上，使用nc –lk 9999 开启 地址172.22.241.184主机的9999监听端口，并持续往里面写数据；使用spark-shell实现监听端口代码如下，输入源为socket源，进行简单的词频统计后，统计结果输出到HDFS文件系统；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scala&amp;gt; import org.apache.spark._&lt;br/&gt;&lt;br/&gt;scala&amp;gt; import org.apache.spark.streaming._&lt;br/&gt;&lt;br/&gt;scala&amp;gt; import org.apache.spark.storage.StorageLevel&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val ssc = new StreamingContext(sc, Seconds(5))&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val lines = ssc.socketTextStream(&lt;span&gt;&quot;172.22.241.184&quot;&lt;/span&gt;, 9999, StorageLevel.MEMORY_AND_DISK_SER)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val wordCounts = lines.flatMap(_.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;)).map((_,1)).reduceByKey(_ + _)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; wordCounts.saveAsTextFiles(&lt;span&gt;&quot;hdfs://xxx/bendi-socket&quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;scala&amp;gt; ssc.start()&lt;br/&gt;&lt;br/&gt;scala&amp;gt; ssc.awaitTermination()&lt;br/&gt;&lt;br/&gt;scala&amp;gt; ssc.stop()&lt;br/&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka流（窗口）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka和Flume等高级输入源需要依赖独立的库（jar文件），如果使用spark-shell读取kafka等高级输入源，需要将对应的依赖jar包放在spark的依赖文件夹lib下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据当前使用的kafka版本，适配所需要的spark-streaming-kafka依赖的版本，在maven仓库下载，地址如下：https://mvnrepository.com/artifact/org.apache.spark/spark-streaming-kafka_2.10/1.2.1&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将对应的依赖jar包放在CDH的spark的依赖文件夹lib下，通过引入包内依赖验证是否成功：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;scala&amp;gt; import org.apache.spark._&lt;br/&gt;&lt;br/&gt;scala&amp;gt; import org.apache.spark.streaming._&lt;br/&gt;&lt;br/&gt;scala&amp;gt; import org.apache.spark.streaming.kafka._&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val ssc = new StreamingContext(sc, Seconds(5))&lt;br/&gt;&lt;br/&gt;scala&amp;gt; ssc.checkpoint(&lt;span&gt;&quot;hdfs://usr/spark/kafka/checkpoint&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val zkQuorum = &lt;span&gt;&quot;172.22.241.186:2181&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val group = &lt;span&gt;&quot;test-consumer-group&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val topics = &lt;span&gt;&quot;yzg_spark&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val numThreads = 1&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val topicMap =topics.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;).map((_,numThreads.toInt)).toMap&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val lineMap = KafkaUtils.createStream(ssc,zkQuorum,group,topicMap)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val pair = lineMap.map(_._2).flatMap(_.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;)).map((_,1))&lt;br/&gt;&lt;br/&gt;scala&amp;gt; val wordCounts = pair.reduceByKeyAndWindow(_ + _,_ -_,Minutes(2),Seconds(10),2)&lt;br/&gt;&lt;br/&gt;scala&amp;gt; wordCounts.print&lt;br/&gt;&lt;br/&gt;scala&amp;gt; ssc.start&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;updateStateByKey操作&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Spark Streaming需要跨批次间维护状态时，就必须使用updateStateByKey操作。以词频统计为例，对于有状态转换操作而言，当前批次的词频统计是在之前批次的词频统计结果的基础上进行不断累加，所以最终统计得到的词频是所有批次的单词总的词频统计结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;val updateFunc = (values: Seq[Int], state: Option[Int]) =&amp;gt; {&lt;br/&gt;val currentCount = values.foldLeft(0)(_ + _)&lt;br/&gt;&lt;br/&gt;val previousCount = state.getOrElse(0)&lt;br/&gt;&lt;br/&gt;Some(currentCount + previousCount)&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import org.apache.spark._&lt;br/&gt;&lt;br/&gt;import org.apache.spark.streaming._&lt;br/&gt;&lt;br/&gt;import org.apache.spark.storage.StorageLevel&lt;br/&gt;&lt;br/&gt;val ssc = new StreamingContext(sc, Seconds(5))&lt;br/&gt;&lt;br/&gt;ssc.checkpoint(&lt;span&gt;&quot;hdfs:172.22.241.184:8020//usr/spark/checkpoint&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;val lines = ssc.socketTextStream(&lt;span&gt;&quot;172.22.241.184&quot;&lt;/span&gt;, 9999, StorageLevel.MEMORY_AND_DISK_SER)&lt;br/&gt;&lt;br/&gt;val wordCounts = lines.flatMap(_.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;)).map((_,1)).updateStateByKey[Int](updateFunc)&lt;br/&gt;&lt;br/&gt;wordCounts.saveAsTextFiles(&lt;span&gt;&quot;hdfs:172.22.241.184:8020//user/spark/bendi-socket&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;ssc.start()&lt;br/&gt;&lt;br/&gt;ssc.awaitTermination()&lt;br/&gt;&lt;br/&gt;ssc.stop()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;Streaming同Kafka交互&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Dstream创建&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于SparkStreaming实时计算框架实时地读取kafka中的数据然后进行计算，在spark1.3版本后kafkaUtils提供两种Dstream创建方法，一种为KafkaUtils.createDstream，另一种为KafkaUtils.createDirectStream。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KafkaUtils.createDstream方式&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其构造函数为KafkaUtils.createDstream(ssc,[zk], [consumer group id], [per-topic,partitions] )，使用receivers来接收数据，利用的是Kafka高层次的消费者api，对于所有的receivers接收到的数据将会保存在Spark executors中，然后通过Spark Streaming启动job来处理这些数据，默认会丢失，可启用WAL日志，它同步将接受到数据保存到分布式文件系统上比如HDFS。所以数据在出错的情况下可以恢复出来。&lt;img data-ratio=&quot;0.7411545623836127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z2DApiaibzMicicOqmeSH8neNob7fheLeK3mib7OUvyA6EARvvp0ChZgpQgln6hZCj5nmhUTzFF5zDvPIJLibTdVzQTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;537&quot;/&gt;A、创建一个receiver来对kafka进行定时拉取数据，ssc的RDD分区和Kafka的topic分区不是一个概念，故如果增加特定主消费的线程数仅仅是增加一个receiver中消费topic的线程数，并不增加spark的并行处理数据数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B、对于不同的group和topic可以使用多个receivers创建不同的DStream&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C、如果启用了WAL(spark.streaming.receiver.writeAheadLog.enable=true)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时需要设置存储级别(默认StorageLevel.MEMORY_AND_DISK_SER_2)，即KafkaUtils.createStream(….,StorageLevel.MEMORY_AND_DISK_SER)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KafkaUtils.createDirectStream方式&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在spark1.3之后，引入了Direct方式，不同于Receiver的方式，Direct方式没有receiver这一层，其会周期性的获取Kafka中每个topic的每个partition中的最新offsets，之后根据设定的maxRatePerPartition来处理每个batch。如图：&lt;img data-ratio=&quot;0.7015209125475285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z2DApiaibzMicicOqmeSH8neNob7fheLeK3mNbXgZeJJtTicIrrrcvbjCNYLicoOiak6hMbKbT5dls4YU3g7ChrTxHuYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;526&quot;/&gt;这种方法相较于Receiver方式的优势在于：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简化的并行：在Receiver的方式中我们提到创建多个Receiver之后利用union来合并成一个Dstream的方式提高数据传输并行度。而在Direct方式中，Kafka中的partition与RDD中的partition是一一对应的并行读取Kafka数据，这种映射关系也更利于理解和优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高效：在Receiver的方式中，为了达到0数据丢失需要将数据存入Write Ahead Log中，这样在Kafka和日志中就保存了两份数据，浪费！而第二种方式不存在这个问题，只要我们Kafka的数据保留时间足够长，我们都能够从Kafka进行数据恢复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;精确一次：在Receiver的方式中，使用的是Kafka的高阶API接口从Zookeeper中获取offset值，这也是传统的从Kafka中读取数据的方式，但由于Spark Streaming消费的数据和Zookeeper中记录的offset不同步，这种方式偶尔会造成数据重复消费。而第二种方式，直接使用了简单的低阶Kafka API，Offsets则利用Spark Streaming的checkpoints进行记录，消除了这种不一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方法缺点是它不会更新Zookeeper中的偏移量，因此基于Zookeeper的Kafka监视工具将不会显示进度。但是您可以在每个批处理中访问此方法处理的偏移量，并自行更新Zookeeper。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;位置策略&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参照官方的API文档地址：http://spark.apache.org/docs/latest/streaming-kafka-0-10-integration.html，位置策略是用来控制特定的主题分区在哪个执行器上消费的，在executor针对主题分区如何对消费者进行调度，并且位置的选择是相对的，位置策略有三种方案：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、PreferBrokers：首选kafka服务器，只有在kafka服务器和executor位于同一主机可以使用该策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、PreferConsistent：首选一致性，多数时候采用该方式，在所有可用的执行器上均匀分配kakfa的主题的所有分区，能够综合利用集群的计算资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、PreferFixed：首选固定模式，如果负载不均衡可以使用该策略放置在特定节点使用指定的主题分区；该配置是手动控制方案，若没有显式指定的分区仍然采用(2)方案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;消费策略&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者策略是控制如何创建和配制消费者对象或者如何对Kafka上的消息进行消费界定，比如t1主题的分区0和1，或者消费特定分区上的特定消息段。该类可扩展，自行实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、ConsumerStrategies.Assign：指定固定的分区集合；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;def Assign[K, V](&lt;br/&gt;&lt;br/&gt;      topicPartitions: Iterable[TopicPartition],&lt;br/&gt;&lt;br/&gt;      kafkaParams: collection.Map[String, Object],&lt;br/&gt;&lt;br/&gt;      offsets: collection.Map[TopicPartition, Long])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、ConsumerStrategies.Subscribe：允许消费订阅固定的主题集合；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、ConsumerStrategies.SubscribePattern：使用正则表达式指定感兴趣的主题集合。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;Spark Streaming开发&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IDEA作为常用的开发工具使用maven进行依赖包的统一管理，配置Scala的开发环境，进行Spark Streaming的API开发；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下载并破解IDEA，并加入汉化的包到lib，重启生效；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在IDEA中导入离线的Scala插件：需要确保当前win主机上已经下载安装Scala并设置环境变量，首先下载IDEA的Scala插件，无须解压，然后将其添加到IDEA中，具体为new---setting--plugins--&quot;输入scala&quot;--install plugin from disk；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Maven快捷键&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;shift&lt;/span&gt;键多次------查找类和插件；&lt;br/&gt;&lt;br/&gt;&lt;span&gt;shift&lt;/span&gt;+ctrl+enter-------结束当前行，自动补全分号；&lt;br/&gt;&lt;br/&gt;&lt;span&gt;shift&lt;/span&gt;+alter+s-----------setting设置&lt;br/&gt;&lt;br/&gt;alter+enter-----------补全抛出的异常&lt;br/&gt;&lt;br/&gt;alter+insert---------自动生成get、&lt;span&gt;set&lt;/span&gt;、构造函数等；&lt;br/&gt;&lt;br/&gt;Ctrl+X --------------删除当前行&lt;br/&gt;&lt;br/&gt;ctrl+r----------------替换&lt;br/&gt;&lt;br/&gt;ctrl+/----------------多行代码分行注释，每行一个注释符号&lt;br/&gt;&lt;br/&gt;ctrl+&lt;span&gt;shift&lt;/span&gt;+/---------多行代码注释在一个块里，只在开头和结尾有注释符号&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;任务提交&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新建maven工程：file--new--project--maven(选择quickstart框架模型新建)，groupId和ArtifactID用来区分该java工程；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;maven自动生成pom.xml配置文件，用于各种包的依赖和引入，如果使用maven打包，需要引入maven的打包插件：使用maven-compiler-plugin、maven-jar-plugin插件，并在prom.xml中增加指定程序入口的&lt;mainclass&gt;配置；具体可参照：https://blog.csdn.net/qq_17348297/article/details/79092383&lt;/mainclass&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将mainClass设置为HelloWorld（主类），点击右边窗口maven -&amp;gt; package，生成jar包，打包完成后使用spark-submit指令提交jar包并执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;spark-submit --class &lt;span&gt;&quot;JSONRead&quot;&lt;/span&gt; /usr/&lt;span&gt;local&lt;/span&gt;/spark/mycode/json/target/scala-2.11/json-project_2.11-1.0.jar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若有cannot find main class错误，需要删除-class xx.jar选项；若出现“Invalid signature file digest for Manifest main”错误，则运行zip -d xxx.jar  &#x27;META-INF/.SF&#x27;  &#x27;META-INF/.RSA&#x27;  &#x27;META-INF/*SF&#x27; 指令，删除所属jar包中.SF/.RSA/相关文件。任务yarn管理器查看任务运行情况；&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;Structured Streaming&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Spark2.x中，spark新开放了一个基于DataFrame的无下限的流式处理组件Structured Streaming，在过去使用streaming时一次处理是当前batch的所有数据，针对这波数据进行各种处理，如果要做一些类似pv，uv的统计，需要借助有状态的state的DStream，或者借助一些分布式缓存系统，如Redis，做一些类似Group by的操作Streaming是非常不便的，在面对复杂的流式处理场景时捉襟见肘，且无法支持基于event_time的时间窗口做聚合逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Structured Streaming中，把源源不断到来的数据通过固定的模式“追加”或者“更新”到无下限的DataFrame中。剩余的工作跟普通的DataFrame一样，可以去map、filter，也可以去groupby().count()，甚至还可以把流处理的dataframe跟其他的“静态”DataFrame进行join。另外，还提供了基于window时间的流式处理。总之，Structured Streaming提供了快速、可扩展、高可用、高可靠的流式处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Structured Streaming构建于sparksql引擎之上，可以用处理静态数据的方式去处理你的流计算，随着流数据的不断流入，Sparksql引擎会增量的连续不断的处理并且更新结果。可以使用DataSet/DataFrame的API进行 streaming aggregations, event-time windows, stream-to-batch joins等，计算的执行也是基于优化后的sparksql引擎。通过checkpointing and Write Ahead Logs该系统可以保证点对点，一次处理，容错担保。&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8a5d51c98acd02ccdc66ada61d5809d2</guid>
<title>可能是说的最分明的 IaaS, PaaS, FaaS, SaaS, MicroService, Serverless 了</title>
<link>https://toutiao.io/k/p2q8xl8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;&amp;#10;                col-lg-8 col-lg-offset-2&amp;#10;                col-md-10 col-md-offset-1&amp;#10;                post-container&quot;&gt;

&lt;h2 id=&quot;絮语&quot;&gt;絮语&lt;/h2&gt;
&lt;p&gt;如果说哪个行业最会起名字，那么互联网和软件行业称第二的话，估计没人敢称第一，比如什么复盘，赋能，组合拳，引爆点，泛用型，强化认知….
等等这些让你听了是耳濡目旋的，高大上，我完全不知道啥意思。其实在我看来都是新瓶装旧酒，换个马甲，包装了下、或者说就是不说人话，强行装X了。
今天我们来说说同样也是几个高大上的名词，但是他们其实很好理解，但又相互联系，所以经常让人傻傻分不清。&lt;/p&gt;

&lt;h2 id=&quot;云服务&quot;&gt;云服务&lt;/h2&gt;
&lt;p&gt;从以前还望而却步的云计算到现在我们哪哪都是云服务，云的概念已经从概念落到地上，说到云其实也是个不说人话的装X词，说白了就是我们以前和现在
不停使用的服务器罢了，云计算、云服务就是一种更优化的服务器功能，从只是个服务器硬件本身，升级到在这个硬件中集成了很多方便使用，或者开箱即用的
服务，不需要你知道怎么安装，怎么配置，你只要花钱买了，就开箱即用。即有硬件使用，也有服务提供，这就是云服务。如果云服务还有分类的话，那么就是
下面要说的几个既有区别又有联系的分类了，但是不管这些分类怎么变，名字怎么起，怎么高大上，其实在我看来，就是作为客户的你（软件开发者）花钱享受不同
服务，统统都是简化了你要做的事情，把复杂的事情简单了，花钱就行了。看着很憷人，其实很简单。&lt;/p&gt;

&lt;h2 id=&quot;iaas&quot;&gt;IaaS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基础设施服务，Infrastructure as a service&lt;/strong&gt;，如果把软件开发比作厨师做菜，那么IaaS就是他人提供了厨房，炉子，锅等基础东西，
你自己使用这些东西，自己根据不同需要做出不同的菜。&lt;/p&gt;

&lt;h2 id=&quot;paas&quot;&gt;PaaS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;平台服务，Platform as a service&lt;/strong&gt;，还是做菜比喻，比如我做一个黄焖鸡米饭，除了提供基础东西外，那么PaaS还给你提供了现成剁好的鸡肉，土豆，辣椒，
你只要把这些东西放在一起，加些调料，用个小锅子在炉子上焖个20分钟就好了。&lt;/p&gt;

&lt;h2 id=&quot;faas&quot;&gt;FaaS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;函数服务，Function as a Service&lt;/strong&gt;，同样是做黄焖鸡米饭，这次我只提供酱油，色拉油，盐，醋，味精这些调味料，其他我不提供，你自己根据不同口味是多放点盐，
还是多放点醋，你自己决定。&lt;/p&gt;

&lt;h2 id=&quot;saas&quot;&gt;SaaS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;软件服务，Software as a service&lt;/strong&gt;，同样还是做黄焖鸡米饭，这次是直接现成搞好的一个一个小锅的鸡，什么调料都好了，已经是个成品了，你只要贴个牌，直接卖出
去就行了，做多是在炉子上焖个20分钟。&lt;/p&gt;

&lt;h2 id=&quot;microservice&quot;&gt;MicroService&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;微服务，Micro service&lt;/strong&gt;，微服务是服务整体的细化，如果还是做黄焖鸡米饭，就好比一家供应商提供好了所有调料，一家供应商提供好了所有的鸡块等食材，你只要把这两
家供应商提供的东西做成黄焖鸡米饭就行了。&lt;/p&gt;

&lt;h2 id=&quot;serverless&quot;&gt;Serverless&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;无服务，Server less&lt;/strong&gt;，说是无，其实有，无服务就是一种没有感知的服务，你不需要知道它怎么实现的。如果还是做黄焖鸡米饭，无服务在这里可以比喻为买一袋已经调味好的调料包，你直接往黄焖鸡里倒
就行了，至于怎么调出的口味你不需要知道。&lt;/p&gt;

&lt;p&gt;下面就没有黄焖鸡了😄，我下面需要重点说说几个架构的实体&lt;/p&gt;

&lt;h2 id=&quot;serverless的历史&quot;&gt;Serverless的历史&lt;/h2&gt;
&lt;p&gt;Serverless的概念并不清晰，乍见之下，很容易让人混淆硬件服务器及软件上的服务与其所谓的“服务器”差别，在这里强调的所谓“无服务器”指的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;我们的代码不会明确地部署在某些特定的软件或者硬件的服务器上。
运行代码托管的环境是由例如阿里云或者腾讯云这样的云计算厂商所提供&lt;/code&gt;。其实这听上去又很像Paas,SaaS,FaaS,不错，所以他们之间也充满了联系。&lt;/p&gt;

&lt;h2 id=&quot;serverless-与-paas&quot;&gt;Serverless 与 PaaS&lt;/h2&gt;
&lt;p&gt;PaaS是平台即为服务，Serverless相当于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;平台&lt;/code&gt;提供了更加细粒度和碎片化的服务，从这个层次来说，Serverless=PaaS。&lt;/p&gt;

&lt;h2 id=&quot;serverless-与-saas&quot;&gt;Serverless 与 SaaS&lt;/h2&gt;
&lt;p&gt;SaaS是软件本身即为服务，Serverless相当于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;软件&lt;/code&gt;提供了更加细粒度和碎片化的服务，因为Serverless也是一种软件，从这个层次来说，Serverless=SaaS。&lt;/p&gt;

&lt;h2 id=&quot;serverless-与-faas&quot;&gt;Serverless 与 FaaS&lt;/h2&gt;
&lt;p&gt;FaaS是函数即为服务，Serverless相当于提供的更加细粒度和碎片化服务是一种&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;函数&lt;/code&gt;，从这个层次来说，Serverless=FaaS。&lt;/p&gt;

&lt;h2 id=&quot;serverless-与-microservice&quot;&gt;Serverless 与 MicroService&lt;/h2&gt;
&lt;p&gt;MicroService是微服务，是一种专注于单一责任与功能的小型服务，Serverless相当于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;更加细粒度和碎片化&lt;/code&gt;的单一责任与功能小型服务，他们都是一种特定的小型服务，
从这个层次来说，Serverless=MicroService。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这几个之间有这么多联系，但是从架构的定义范围也有个包含关系，PaaS &amp;gt; SaaS &amp;gt; FaaS &amp;gt; MicroService &amp;gt; Serverless&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;最后还有个-servicemesh&quot;&gt;最后还有个 ServiceMesh&lt;/h2&gt;
&lt;p&gt;ServiceMesh叫做服务网格，他是依存于MicroService微服务架构存在的，因为微服务之间需要通信，需要数据交换同步等操作。在没有ServiceMesh之前微服务的
通信，数据交换同步也存在，也有比较好的解决方案，如Spring Clould，OSS，Double这些，但他们有个最大的特点就是需要你写入代码中，而且需要深度的写
很多逻辑操作代码，这就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;侵入式&lt;/code&gt;。而ServiceMesh最大的特点是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;非侵入式&lt;/code&gt;，不需要你写特定代码，只是在云服务的层面即可享受微服务之间的通信，数据交换同步等操作，
这里的代表如，docker+K8s，istio，linkerd等。 &lt;br/&gt;
从这里你也可以看出，所有新出来的高大上的东西，都是在简化你的工作。以前可能需要你造轮子才可以，然后到用现成的轮子就可以，再到连轮子你都看不见花钱就可以了🙂。&lt;/p&gt;



                &lt;hr/&gt;

                


                
                
                
                
                
                &lt;p id=&quot;gitalk-container&quot;/&gt;
                
                
                
                
                
                

                

            &lt;/div&gt;  

    
        
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0357111b40fa7016f734ea0f7f02ff82</guid>
<title>珍爱生命，珍惜健康</title>
<link>https://toutiao.io/k/78bhd5y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h2&gt;引言&lt;/h2&gt;&lt;p&gt;原文链接：https://yunsonbai.top/2021/01/05/love-life/&lt;br/&gt;某多多事件的思考：不管你从事什么行业都希望你能珍爱生命，珍惜健康，爱惜自己的身体。&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;故事的起源&lt;/h2&gt;&lt;p&gt;最近这两天几乎被某多多的员工猝死事件刷了屏，各种感慨和惋惜，正是美好年华，未来有着无限的可能，然而却止住了前进的脚步，静静的去了别的世界。这值得我们思考，最近几年类似的事情层出不断，为什么一直会有？我们到底该怎么选择？&lt;/p&gt;&lt;h2&gt;该不该奋斗&lt;/h2&gt;&lt;p&gt;&lt;span&gt;这貌似是一句废话，怎么可能不奋斗呢？我们学习知识技能不就是为了更好的做事，创造更高的价值，收获更多的果实么？如果不奋斗何以实现我们的抱负和理想呢？在简单的说就是名和利，追逐这些是没有错的，它能激发人的创造力，能&lt;/span&gt;使&lt;span&gt;我们过上更好的生活，问题来了，怎么奋斗呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-backh=&quot;155&quot; data-backw=&quot;344&quot; data-ratio=&quot;0.45058139534883723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/C6nnRGnPbvxRdPm2DIiaic8mf2CRS2o2W3GbcslKwI2aUGB3phPqsCfFHGA94MticicpM4UzkrcGiaSvhu8ibXu8nyYn2SGdczb1iac/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;344&quot;/&gt;先从自身谈起，公司很多，工作方式也很多，我们努力的工作到底为了什么？是为了更好的生活的话，那你需要思考你的&lt;/span&gt;&lt;span&gt;工作方式，如果工作占据了一天60%的时间，甚至频繁的占据了你的休息时间，那么请问，你的生活在哪？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那如果是为了获得更多&lt;/span&gt;&lt;span&gt;的钱，生不生活无所谓，那接下来是没日没夜的干，看起来没有毛病，你干的多可能你就拿的多，只是可能，你首先需要弄明白你到底是拿到的空头支票还是实打实的支票。&lt;/span&gt;&lt;span&gt;另外，自己的身体要弄清楚，能不能抗的住没日没夜的工作呢？&lt;/span&gt;&lt;span&gt;即便你抗住了，从健康的角度讲，你的身体却承受了巨大的伤害，晚上正是养内脏，蓄精神的时候，你却让身体一直重负荷的工作，久而久之身体就埋下了”定时炸弹”，即便你拿到了实打实的支票，恐怕最后也不见得跟了你的姓。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当然还有为了更高的正义的理想，那个已经脱离了生活和身体的范畴，精神层面的高尚的收益是无价的，这些人是我们的榜样，但是这次这次只说普通打工者。&lt;/p&gt;&lt;p&gt;还是要找到适合自己的工作方式，还要折中合适的工作时间，钱与生命和健康比起来，还是要选择生命和健康，这两样都是不可逆的，钱也换不来的，我们要尽可能的在保证生命和健康的同时，更好的创造价值，不能以牺牲两者去获取收益，你即便拿到了收益，它也不一定属于你，快的话归了别人，慢的话归了医院。但是我们也不能不去奋斗，不努力，了解易经的人都知道这两句，否极泰来，乐极生悲，延伸出来就是什么事情都有到极点而向反向而变的道理，所以要适中，要热爱工作，还要热爱我们的生命和健康，身体是工作的本钱，是创造一切价值的根基。&lt;/p&gt;&lt;p&gt;&lt;span&gt;不管怎么说，我们人是活的，事物是死的如果活的人被死的事物羁绊住，那多可悲，毕竟很多条路能通罗马不是？我们的选择很重要，尽量让选择服务你的健康。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;请善待员工&lt;/h2&gt;&lt;p&gt;一个公司要发展，人是决定性因素。&lt;/p&gt;&lt;p&gt;该不该加班呢？还是要用易经的角度去看问题，世上没有绝对的事物，不能绝不加班，有些项目也好，想法也好，不抓紧时间干出来，很可能被超越，甚至整个公司走向没落，大河没水自然小河就干了。那就要加班，多多的加班，那更不行，人不是机器，长时间崩的太紧就会出问题，强度太大也会出问题，比如最近的某多多。&lt;/p&gt;&lt;p&gt;还是要适量、适中，两个人的活非要一个人去做，那这个人就会很累。高强度加班偶尔一次是可以理解的，持续作战的话，这个需要思考，你的员工受的住这种强度的工作么？他们可是人诶不是机器。&lt;/p&gt;&lt;p&gt;低强度持续加班也是无情的伤害了员工的健康，它会占据员工的生活时间，脑子里只会有工作，身心健康得不到保障，进而会影响身体健康。一周工作6天甚至7天，绝大部分时间都要加班，这就是压榨，员工会很累，企业为了效益，而累坏了员工。小河榨干了，大河迟早也会干。&lt;/p&gt;&lt;p&gt;真的就有这么多工作让员工加班么？非要在某个节日的最后时间想出创意然后没日没夜的加紧干么？非要让一两个人持续加班作战么？是不是需要调整人员，合理安排人员呢？&lt;/p&gt;&lt;p&gt;请企业善待自己的员工，给员工多一点自己的时间，早点下班不见得会减少效益，也许能更好的增收效益，员工有自己的时间，身心更健康，头脑更清晰，心态更乐观，效率肯定会增加，一个人总是昏昏沉沉的别说效率，还可能会造就很多问题拉慢效率，怎么可能持续发展呢？&lt;/p&gt;&lt;h2&gt;社会重视&lt;/h2&gt;&lt;p&gt;还是请社会上更多的人都能重视起来，大家联手解决现在的问题，能让企业和员工双赢。我在IT圈工作了有几年了，也不知道这股加班文化是从什么时候兴起的，这个行业不但有35周岁的担忧，还有充斥着各种加班文化，我不认为这个能持续下去，也不应该持续下去，应该找到一个合适的平衡点来平衡双方。&lt;/p&gt;&lt;p&gt;如果这种加班文化不能得到有效的改进，今天一个某多多，也许明天还会再出另外一个某多多，我们到底还要看到多少生命因为过劳而逝去，才能改正现在的工作方式，只能寄希望于社会，大家联起手来缓解或者解决这个问题。&lt;/p&gt;&lt;h2&gt;结语&lt;/h2&gt;&lt;p&gt;最后还是希望广大的工作者，珍爱自己的生命，珍惜自己的健康，不管你选择什么样的工作方式，请都别忘记这两样最宝贵的东西，请能灵活的处理健康和工作的矛盾，让我们的生命更灿烂，健康更持久。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f13a5c6c3f258b4c61999ca560e4516d</guid>
<title>Serverless 音视频转码：芒果 TV 落地实践（下）</title>
<link>https://toutiao.io/k/talunv3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Markdown__Wrapper-sbgo4h-0 kKEhyL markdown-body&quot;&gt;&lt;p&gt;在 &lt;a href=&quot;https://serverlesscloud.cn/best-practice/2021-01-08-serverless-mangguo&quot;&gt;《Serverless 音视频转码——芒果 TV 落地实践（上）》&lt;/a&gt;中，我们回顾了芒果 TV 吴坚强老师在 techo 大会的精彩分享，芒果TV 音视频编解码业务团队通过使用腾讯云 Serverless 音视频转码服务，成本降低 45% 以上，引起大家的广泛关注，小伙伴们都跃跃欲试！&lt;/p&gt;
&lt;p&gt;本文我们将带领大家一起使用云函数 + COS + CLS + FFmpeg 构建高可用、并行处理、实时日志、高度自定义的视频转码服务。我们在此提供了两种方案，您可以直接用转码应用，一键部署，也可以通过
用函数的长运行方案来自己处理。&lt;/p&gt;
&lt;h2 id=&quot;实现方案&quot;&gt;&lt;a href=&quot;#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88&quot; aria-label=&quot;实现方案 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;实现方案&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt; 使用官网的流式音视频转码，一键部署。查看&lt;a href=&quot;https://cloud.tencent.com/document/product/583/51451&quot;&gt;详情&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案二：&lt;/strong&gt; 利用云函数的异步执行机制，自主研发。查看&lt;a href=&quot;https://cloud.tencent.com/document/product/583/51519&quot;&gt;详情&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;流式音视频转码方案&quot;&gt;&lt;a href=&quot;#%E6%B5%81%E5%BC%8F%E9%9F%B3%E8%A7%86%E9%A2%91%E8%BD%AC%E7%A0%81%E6%96%B9%E6%A1%88&quot; aria-label=&quot;流式音视频转码方案 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;流式音视频转码方案&lt;/h2&gt;
&lt;p&gt;通过云函数创建 FFmpeg 任务进程，云函数进程与 FFmpeg 任务进程通过 pipe 和 FIFO 的方式进行数据传输。云函数进程中的两个任务线程分别接收 FFmpeg 任务进程向函数进程输出的 FFmpeg 日志流与转码后的文件流，从而实现流式读写 COS 和实时日志输出的转码应用场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://main.qcloudimg.com/raw/749ac11a39c98a1ffbf5bb6d4b758e5a.svg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;方案优势&quot;&gt;&lt;a href=&quot;#%E6%96%B9%E6%A1%88%E4%BC%98%E5%8A%BF&quot; aria-label=&quot;方案优势 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;方案优势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流式转码&lt;/strong&gt;
采用流式拉取源视频文件，流式上传转码文件的工作方式，突破了本地存储的限制，且不需要额外部署 CFS 等产品。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时日志&lt;/strong&gt;
视频转码过程中，可通过 CLS 日志实时查看转码进度。同时支持输出 FFmpeg 应用的完整日志。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;长时运行&lt;/strong&gt;
利用云函数的长时运行机制，支持 12h-24h 的运行时长，可覆盖大文件耗时较长的转码场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自定义参数&lt;/strong&gt;
支持用户自定义配置 FFmpeg 命令参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;前提条件&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 &lt;a href=&quot;https://cloud.tencent.com/document/product/1154/42990&quot;&gt;Serverlesss Framework&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;函数长时运行 &lt;a href=&quot;https://cloud.tencent.com/apply/p/hz85krvp8s8&quot;&gt;白名单申请&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;配置部署账号权限。参考 &lt;a href=&quot;https://cloud.tencent.com/document/product/1154/43006&quot;&gt;账号和权限配置&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;配置 &lt;a href=&quot;https://cloud.tencent.com/document/product/583/51451#.E8.BF.90.E8.A1.8C.E8.A7.92.E8.89.B2.3Ca-id.3D.22role.22.3E.3C.2Fa.3E&quot;&gt;运行角色&lt;/a&gt; 权限。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;操作步骤&quot;&gt;&lt;a href=&quot;#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4&quot; aria-label=&quot;操作步骤 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;操作步骤&lt;/h2&gt;
&lt;h3 id=&quot;1-下载转码应用&quot;&gt;&lt;a href=&quot;#1-%E4%B8%8B%E8%BD%BD%E8%BD%AC%E7%A0%81%E5%BA%94%E7%94%A8&quot; aria-label=&quot;1 下载转码应用 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;1. 下载转码应用&lt;/h3&gt;

&lt;p&gt;进入项目目录 &lt;code class=&quot;language-text&quot;&gt;transcode-app&lt;/code&gt;，将看到目录结构如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;transcode-app
|- .env  #环境配置
|- serverless.yml # 应用配置
|- log/ #log 日志配置
|  └── serverless.yml
└──transcode/  #转码函数配置
       |- src/
       |   |- ffmpeg   #转码 FFmpeg 工具
       |   └── index.py
       └── serverless.yml&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;log/serverless.yml&lt;/code&gt; 定义一个 CLS 日志集和主题，用于转码过程输出的日志保存，目前采用腾讯云 CLS 日志存储。每个转码应用将会根据配置的 CLS 日志集和主题去创建相关资源，CLS 的使用会产生计费，具体参考 &lt;a href=&quot;https://cloud.tencent.com/document/product/614/47116&quot;&gt;CLS 计费规则&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;transcode/serverless.yml&lt;/code&gt; 定义函数的基础配置及转码参数配置。&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;transcode/src/index.py&lt;/code&gt; 转码功能实现。&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;transcode/src/ffmpeg&lt;/code&gt; 转码工具 FFmpeg。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-配置环境变量和应用参数&quot;&gt;&lt;a href=&quot;#2-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E5%BA%94%E7%94%A8%E5%8F%82%E6%95%B0&quot; aria-label=&quot;2 配置环境变量和应用参数 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;2. 配置环境变量和应用参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;应用参数，文件 &lt;code class=&quot;language-text&quot;&gt;transcode-app/serverless.yml&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;#应用信息
app: transcodeApp # 您需要配置成您的应用名称
stage: dev # 环境名称，默认为 dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;环境变量，文件&lt;code class=&quot;language-text&quot;&gt;transcode-app/.env&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;REGION=ap-shanghai  # 应用创建所在区，目前只支持上海区
TENCENT_SECRET_ID=xxxxxxxxxxxx # 您的腾讯云sercretId
TENCENT_SECRET_KEY=xxxxxxxxxxxx # 您的腾讯云sercretKey&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;您可以登录腾讯云控制台，可以在 &lt;a href=&quot;https://console.cloud.tencent.com/cam/capi&quot;&gt;API 密钥管理&lt;/a&gt; 中获取 SecretId 和 SecretKey。&lt;/li&gt;
&lt;li&gt;如果您的账号为主账号，或者子账号具有扫码权限，也可以不配置 SercretId 与 SercretKey，直接扫码部署应用。更多详情参考 &lt;a href=&quot;https://cloud.tencent.com/document/product/1154/43006&quot;&gt;账号和权限配置&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;3-配置转码需要的参数信息&quot;&gt;&lt;a href=&quot;#3-%E9%85%8D%E7%BD%AE%E8%BD%AC%E7%A0%81%E9%9C%80%E8%A6%81%E7%9A%84%E5%8F%82%E6%95%B0%E4%BF%A1%E6%81%AF&quot; aria-label=&quot;3 配置转码需要的参数信息 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;3. 配置转码需要的参数信息&lt;/h3&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输出桶与函数建议配置在同一区域，跨区域配置应用稳定性及效率都会降低，并且会产生跨区流量费用。&lt;/li&gt;
&lt;li&gt;内存大小上限为3072MB，运行时长上限为43200s。如需调整，请 &lt;a href=&quot;https://console.cloud.tencent.com/workorder/category?level1_id=6&amp;amp;level2_id=668&amp;amp;source=0&amp;amp;data_title=%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%91%E5%87%BD%E6%95%B0%20SCF&amp;amp;step=1&quot;&gt;提交工单&lt;/a&gt; 申请配额调整。&lt;/li&gt;
&lt;li&gt;转码应用必须开启函数长时运行 asyncRunEnable: true。&lt;/li&gt;
&lt;li&gt;运行角色请根据 &lt;a href=&quot;https://cloud.tencent.com/document/product/583/51451#.E8.BF.90.E8.A1.8C.E8.A7.92.E8.89.B2.3Ca-id.3D.22role.22.3E.3C.2Fa.3E&quot;&gt;运行角色&lt;/a&gt; 创建并授权。&lt;/li&gt;
&lt;li&gt;示例配置的 FFmpeg 指令仅适用于 AVI 转码场景，详细介绍参考 &lt;a href=&quot;https://cloud.tencent.com/document/product/583/51451#ffmpeg-.E6.8C.87.E4.BB.A4.3Ca-id.3D.22ffmpeg.22.3E.3C.2Fa.3E&quot;&gt;FFmpeg 指令&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;4-部署项目&quot;&gt;&lt;a href=&quot;#4-%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE&quot; aria-label=&quot;4 部署项目 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;4. 部署项目&lt;/h3&gt;
&lt;p&gt;在 &lt;code class=&quot;language-text&quot;&gt;transcode-app&lt;/code&gt; 项目目录下，执行 &lt;code class=&quot;language-text&quot;&gt;sls deploy&lt;/code&gt; 部署项目。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;cd transcode-app &amp;amp;&amp;amp; sls deploy&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;5-上传视频文件&quot;&gt;&lt;a href=&quot;#5-%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6&quot; aria-label=&quot;5 上传视频文件 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;5. 上传视频文件&lt;/h3&gt;
&lt;p&gt;上传视频文件到已经配置好的cos桶指定路径，则会自动转码。本示例中是cos桶&lt;code class=&quot;language-text&quot;&gt;test-123456789.cos.ap-shanghai.myqcloud.com&lt;/code&gt;下的&lt;code class=&quot;language-text&quot;&gt;/video/inputs/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;转码成功后，文件将保存在您配置的输出桶路径中。本示例中是cos桶&lt;code class=&quot;language-text&quot;&gt;test-123456789.cos.ap-shanghai.myqcloud.com&lt;/code&gt;下的&lt;code class=&quot;language-text&quot;&gt;/video/outputs/&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-重新部署&quot;&gt;&lt;a href=&quot;#6-%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2&quot; aria-label=&quot;6 重新部署 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;6. 重新部署&lt;/h3&gt;
&lt;p&gt;如果需要调整转码配置，修改文件 &lt;code class=&quot;language-text&quot;&gt;transcode/serverless.yml&lt;/code&gt; 后，重新部署云函数即可：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;cd transcode &amp;amp;&amp;amp; sls deploy&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;监控与日志服务&quot;&gt;&lt;a href=&quot;#%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1&quot; aria-label=&quot;监控与日志服务 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;监控与日志服务&lt;/h2&gt;
&lt;p&gt;批量文件上传到 COS 会并行触发转码执行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;登录 &lt;a href=&quot;https://console.cloud.tencent.com/scf/index?rid=1&quot;&gt;云函数控制台&lt;/a&gt; 的【函数服务】页面中，单击函数名进入函数管理页面。&lt;/li&gt;
&lt;li&gt;单击【日志查询】，即可查看日志监控。
&lt;img src=&quot;https://main.qcloudimg.com/raw/366b8d44b84205d580af18703a1cd511.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;单击【函数管理】&amp;gt;【函数配置】，单击日志主题的链接，跳转至日志服务控制台。
&lt;img src=&quot;https://main.qcloudimg.com/raw/a86502f7ecc77473501ce654a23435de.jpg&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在日志服务控制台的【检索分析】页面中，选择日志集合日志主题，即可查看日志检索分析 。
&lt;img src=&quot;https://main.qcloudimg.com/raw/caca6a584b5abe864559379fac8f3346.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;借助函数异步运行能力自主研发方案&quot;&gt;&lt;a href=&quot;#%E5%80%9F%E5%8A%A9%E5%87%BD%E6%95%B0%E5%BC%82%E6%AD%A5%E8%BF%90%E8%A1%8C%E8%83%BD%E5%8A%9B%E8%87%AA%E4%B8%BB%E7%A0%94%E5%8F%91%E6%96%B9%E6%A1%88&quot; aria-label=&quot;借助函数异步运行能力自主研发方案 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;借助函数异步运行能力自主研发方案&lt;/h2&gt;
&lt;p&gt;在音视频转码、ETL 大体量数据处理、AI 推理等单任务重计算的场景下，函数的单实例运行时需要更多算力及更长时间的稳定运行。若函数的调用端长时间阻塞等待执行结果，不仅会持续占用调用方资源，还会对调用链路的稳定性产生较高要求。
云函数 SCF 提供了一种全新的函数运行机制，您可通过 SCF 提供的函数异步执行模式，提升执行超时时间上限和解决现有运行机制的问题。&lt;/p&gt;
&lt;h2 id=&quot;操作步骤-1&quot;&gt;&lt;a href=&quot;#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4-1&quot; aria-label=&quot;操作步骤 1 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;操作步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;登录 &lt;a href=&quot;https://console.cloud.tencent.com/scf/list?rid=16&amp;amp;ns=default&quot;&gt;云函数控制台&lt;/a&gt;，单击左侧导航栏的【函数服务】。&lt;/li&gt;
&lt;li&gt;在主界面上方选择期望创建函数的地域，并单击【新建】，进入函数创建流程。&lt;/li&gt;
&lt;li&gt;选择使用【空白函数】或选择使用【函数模板】来新建函数。&lt;/li&gt;
&lt;li&gt;在“函数配置”页面，展开【高级设置】，并勾选【异步执行】。&lt;/li&gt;
&lt;li&gt;单击【完成】即可创建函数。  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;运行机制原理&quot;&gt;&lt;a href=&quot;#%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86&quot; aria-label=&quot;运行机制原理 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;运行机制原理&lt;/h2&gt;
&lt;p&gt;函数启用异步执行后，通过同步（例如 API 网关）或异步（例如 COS、CKafka、Timer 等）调用端进行事件调用，函数将以异步执行模式响应事件。
即完成事件调度后立即返回事件的调用标识 RequestId，并结束调用操作，调用端无需阻塞等待。返回 RequestId 的同时，调用引擎将并行下发事件到函数运行时，开启函数逻辑执行。进入异步执行状态后，执行日志将实时上报至日志服务，提供对异步执行事件运行情况的实时反馈。其原理如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://main.qcloudimg.com/raw/36557e028090175f79b879ac0ad6f66b.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意事项：&lt;/p&gt;

&lt;/blockquote&gt;
&lt;h2 id=&quot;状态追踪原理&quot;&gt;&lt;a href=&quot;#%E7%8A%B6%E6%80%81%E8%BF%BD%E8%B8%AA%E5%8E%9F%E7%90%86&quot; aria-label=&quot;状态追踪原理 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;状态追踪原理&lt;/h2&gt;
&lt;p&gt;函数高级配置启用状态追踪后，针对异步执行的事件，将开始记录并上报事件响应的实时状态，并提供事件状态的统计、查询及终止等事件管理相关服务。其原理如下图所示：
&lt;img src=&quot;https://main.qcloudimg.com/raw/d06476734d27d3308783e78af85897a2.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关接口&quot;&gt;&lt;a href=&quot;#%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3&quot; aria-label=&quot;相关接口 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;相关接口&lt;/h2&gt;
&lt;p&gt;事件管理相关服务 API 通过云 API 的方式提供，详情参考&lt;a href=&quot;https://cloud.tencent.com/document/product/583/51519&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;温馨提示&quot;&gt;&lt;a href=&quot;#%E6%B8%A9%E9%A6%A8%E6%8F%90%E7%A4%BA&quot; aria-label=&quot;温馨提示 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;温馨提示&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;产生的事件状态数据仅保留3天，将以3天为时间窗口滑动清理。如需保留全部记录，则需要定期拉取并保存至自有存储。&lt;/li&gt;
&lt;li&gt;关闭状态追踪后，将停止提供异步执行事件相关记录、统计、查询、终止等事件管理相关服务，已产生的事件状态数据将在3天内清空。&lt;/li&gt;
&lt;li&gt;异步运行函数的事件调用 QPS 限制为并发数量的十分之一，超出部分将被限制，造成响应失败。&lt;/li&gt;
&lt;li&gt;由于请求 QPS 超限、账户欠费等原因，事件调用将由调度引擎直接返回对应异常，不会生成事件状态记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;
&lt;p&gt;欢迎访问：&lt;a href=&quot;https://serverlesscloud.cn/&quot;&gt;Serverless 中文网&lt;/a&gt;，您可以在 &lt;a href=&quot;https://serverlesscloud.cn/best-practice&quot;&gt;最佳实践&lt;/a&gt; 里体验更多关于 Serverless 应用的开发！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>