<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a10ca2916275cf4f58ef41197d271552</guid>
<title>QPS、并发数与限流保护漫聊</title>
<link>https://toutiao.io/k/943fu22</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;h2&gt;&lt;span&gt;1.引言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Google的网站可靠性工程师小组（SRE）定义了四个需要监控的关键指标。他们称之为“四个黄金信号”：延迟（Latency），流量（Traffic），错误（Errors）和饱和度（Saturation）。这些与微服务的RED度量密切相关：速率，错误和持续时间，以及关注利用率，饱和度和错误的USE方法。这四个信号应该是服务级别目标（SLO）的关键部分，因为它们对于提供高可用性的服务至关重要。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;流量（Traffic）&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;其中流量可以很多指标来衡量，比如QPS(每秒处理的请求数)、Inbound Bandwidth（输入带宽）、Outbound Bandwidth(输出带宽)等。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.Little&#x27;s law&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;QPS&lt;/code&gt;: query per second，每秒处理的请求数&lt;br/&gt;&lt;code&gt;RT&lt;/code&gt;: response time，平均响应时间或平均处理时间&lt;br/&gt;&lt;code&gt;Concurrent&lt;/code&gt;：并发数&lt;/p&gt;&lt;p&gt;&lt;code&gt;QPS&lt;/code&gt;、&lt;code&gt;RT&lt;/code&gt;、&lt;code&gt;Concurrent&lt;/code&gt;之间存在如下关系：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Concurrent&lt;/span&gt; = QPS * RT&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3508541392904074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7K8YaGnlhQgfoI1dFquLhId7Dzem2QibfGLFibM9iaZcUgYOpvKUanrDzmAibKZSNqVQgTia6CGRtqMFMbmo8cMkyWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot; title=&quot;单向公路&quot;/&gt;&lt;figcaption&gt;单向公路&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;某个服务可以被想象成一条单向高速公路。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每一个需要处理的请求或者任务可以想象成正在这条公路上行驶的汽车。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;汽车从入口驶入，到从出口驶出所需要的时间就是平均响应时间(&lt;code&gt;RT&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当前公路上的所有车辆数就是并发数(&lt;code&gt;Concurrent&lt;/code&gt;)，它一个瞬时值&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;车辆流速稳定后(从入口驶入和从出口驶出的速率 相同)，每秒从入口驶入的车辆数就是每秒处理的请求数(&lt;code&gt;QPS&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;3.定性分析&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;3.1  RT变大&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果服务处理任务的过程依赖其它服务，比如MySQL、或者第三方服务。如果第三方服务出现问题，处理时间变长（&lt;code&gt;RT&lt;/code&gt;变大），在&lt;code&gt;QPS&lt;/code&gt;不变的情况下，由Little&#x27;s law可知，&lt;code&gt;Concurrent&lt;/code&gt;会变大&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.2  QPS&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果客户端调用量突然增大，即&lt;code&gt;QPS&lt;/code&gt;增大，&lt;code&gt;RT&lt;/code&gt;不变的情况下，由Little&#x27;s law可知，&lt;code&gt;Concurrent&lt;/code&gt;也会变大&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.3 请求触达速率和请求完成速率不一致&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这种情况对于处理长作业的服务尤为明显。如果任务到达的快，处理的慢，那么通常只有2个结局，要么提交任务的时候，任务被直接拒绝，要么任务被扔在某个等待队列中，等待执行。在外部的用户看来，这些任务都是在并发执行中，可以看做是并发数。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4. 限流保护&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在很多服务中，针对每个请求，都会独立分配额外的资源。比如Golang的web框架在gin中，每个连接都会分配3个协程；MySQL会针对每个请求创建User Thread），如果并发数一直增大，则服务很可能会被OOM或者陷入某种假死状态。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Concurrent&lt;/span&gt; = QPS * RT&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;由于并发数受到2个变量&lt;code&gt;QPS&lt;/code&gt;和&lt;code&gt;RT&lt;/code&gt;的影响，&lt;code&gt;RT&lt;/code&gt;受到第三方服务的影响而不可控，因此仅对&lt;code&gt;QPS&lt;/code&gt;限制是无法保护服务的，还需要对&lt;code&gt;Concurrent&lt;/code&gt;进行限制。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;1.Little&#x27;s law&lt;br/&gt;2.QPS和并发数，这次给你说清楚&lt;br/&gt;3.QPS、TPS、RT、并发数、吞吐量理解和性能优化深入思考&lt;/p&gt;&lt;hr/&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.396078431372549&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/7K8YaGnlhQgfoI1dFquLhId7Dzem2QibfKd4FDYadKp1krngG4pVhGSDBou4y78X1FPh0W01Ttp4tTGSndJ051g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1020&quot; title=&quot;微信公众号&quot;/&gt;&lt;figcaption&gt;微信公众号&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5f5ca54544e4f208dfec9ba873d8785d</guid>
<title>浅谈基于 Web 的跨平台桌面应用开发</title>
<link>https://toutiao.io/k/p25ktss</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：京东物流 王泽知&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;近些年来，跨平台跨端一直是比较热门的话题，Write once, run anywhere，一直是我们开发者所期望的，跨平台方案的优势十分明显，对于开发者而言，可以做到一次开发，多端复用，一套代码就能够运行在不同设备上，这在很大程度上能够降低研发成本，同时能够在产品效能上做到快速验证和快速上线。如今跨端跨平台的优秀技术方案也比较多，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  移动端： React Native，Flutter，Weex；&lt;/li&gt;
&lt;li&gt;  小程序端： Taro，Uniapp；&lt;/li&gt;
&lt;li&gt;  桌面端： NW.js，Electron，Flutter for desktop，Tauri，Wails，&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今天我们聊聊桌面应用开发。&lt;/p&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;1 什么是跨平台&lt;/h1&gt;

&lt;p&gt;泛指编程语言、软件或硬件设备可以在多种操作系统或不同硬件架构的电脑上运作。一般来说，有这几种场景，分别是跨设备平台（如 PC 端和移动端），跨操作系统，（移动端中分Android，IOS，PC端中分 Windows，macOS，Linux），国内的小程序（微信，京东，百度，支付宝，字节跳动等等）&lt;/p&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;2 跨平台的技术方案&lt;/h1&gt;

&lt;p&gt;跨平台编程不是一件容易的事情，这是由于在不同平台之间，有许多小而复杂的差异，这都需要考虑周全，现在我们有了成熟的跨平台技术方案，能够减小开发者的开发成本及跨平台的难易程度。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  NW.js&lt;/li&gt;
&lt;li&gt;  Electron&lt;/li&gt;
&lt;li&gt;  Flutter for Desktop&lt;/li&gt;
&lt;li&gt;  Tauri&lt;/li&gt;
&lt;li&gt;  Wails&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c163e77adfdd4d1d9dd92893dd074edd%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;2.1 NW.js&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&quot;https://nwjs.io/&quot;&gt;https://nwjs.io/&lt;/a&gt;&lt;br/&gt;
GitHub：&lt;a href=&quot;https://github.com/nwjs/nw.js&quot;&gt;https://github.com/nwjs/nw.js&lt;/a&gt;&lt;br/&gt;
语言：Nodejs + 前端任意框架&lt;br/&gt;
代表项目：微信小程序 IDE，京东小程序 IDE&lt;/p&gt;

&lt;p&gt;NW.js（node-webkit ）是一个基于 Chromium 和 Node.js 的 Web 运行环境，可让你直接在 DOM 中调用 Node.js 模块，并可使用任何现有的 Web 技术来编写本地应用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f77b9dfd009482aad727d587816989e%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;2.2 Electron&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&quot;https://www.electronjs.org/&quot;&gt;https://www.electronjs.org/&lt;/a&gt;&lt;br/&gt;
GitHub：&lt;a href=&quot;https://github.com/electron/electron&quot;&gt;https://github.com/electron/electron&lt;/a&gt;&lt;br/&gt;
语言：Nodejs + 前端任意框架&lt;br/&gt;
代表项目：VSCode，百度小程序 IDE，京 ME，Facebook Message，&lt;/p&gt;

&lt;p&gt;Electron 的前身叫做 Atom-Shell，本来是 GitHub 发布开源编辑器 Atom 时一并发布的副产物，但是后来这个副产物的影响力远远的超过了 Atom 本身，于是便改名为一个独立专案，也就是现在的 Electron。Electron 的本质很简单，就是 Chromium + Node.js 的组合，两者之间透过 IPC 通讯。&lt;br/&gt;
类似于 NW.js，表面上，它们似乎非常相似，但是这两个项目有着本质上的区别，使得 Electron 和 NW.js 成为两个完全独立的产品。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  应用入口不同，NW.js 主入口是一个 HTML，Electron 中是 JavaScript，可操作性更强&lt;/li&gt;
&lt;li&gt;  Node 集成方式不同，在 NW.js 中网页中的 Node 需要通过给 Chromium 打补丁来实现，Electron 则是通过各个平台的消息循环与 libuv 的循环集成，避免了直接在 Chromium 上做改动&lt;/li&gt;
&lt;li&gt;  功能，支持的功能数量上有明显的差距，Electron 有着较大的社区及社区活跃度，大量成熟的 npm 功能模块。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/810220b7051947a3b09ca7e37e8618ab%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;2.3 Tauri&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&quot;https://tauri.app/&quot;&gt;https://tauri.app/&lt;/a&gt;&lt;br/&gt;
GitHub：&lt;a href=&quot;https://github.com/tauri-apps/tauri&quot;&gt;https://github.com/tauri-apps/tauri&lt;/a&gt;&lt;br/&gt;
语言：Rust + 前端任意框架&lt;br/&gt;
代表项目：仅有少量开源应用&lt;/p&gt;

&lt;p&gt;Tauri 是 2021年 JavaScript 明星项目（ &lt;a href=&quot;https://risingstars.js.org/2021/zh#section-all&quot;&gt;https://risingstars.js.org/2021/zh#section-all&lt;/a&gt; ）的最受欢迎项目中排名第5，在 stateofjs 2021 （ &lt;a href=&quot;https://2021.stateofjs.com/en-US/libraries/mobile-desktop/&quot;&gt;https://2021.stateofjs.com/en-US/libraries/mobile-desktop/&lt;/a&gt; ）中 满意度和关注度排名第1， 由于 Vite，esbuild，swc，Rome 等工具的大火，让基于 Go、Rust 的高效率构建类工具进入爆发期，加上 Bundleless 的构建体验，让 Rust、Go 成为前端开发者的又一扇门。由于 Tauri 的 Rust 背景，加上构建产物小，内存占用低，还是值得长期关注的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3e3e02fa6234cf1a7073458e386d41b%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;题外话：&lt;br/&gt;
Rust 前景还是非常不错的，如 Linux内核接纳 Rust，deno采用 Rust，微软拥抱Rust，fuchsia 的 Rust 代码占比超50%，Apple 在底层 all-in rust，连续6年的 stackoverflow 最受欢迎语言。就是学习门槛稍微有点高&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64fda74d86144ce08a0b865b39ffc77f%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;2.4 Wails&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&quot;https://wails.io/&quot;&gt;https://wails.io/&lt;/a&gt;&lt;br/&gt;
GitHub：&lt;a href=&quot;https://github.com/wailsapp/wails&quot;&gt;https://github.com/wailsapp/wails&lt;/a&gt;&lt;br/&gt;
语言：Go + 前端任意框架&lt;br/&gt;
代表项目：暂无&lt;/p&gt;

&lt;p&gt;Wails 是一个可让您使用 Go 和 Web 技术编写桌面应用的项目。&lt;br/&gt;
将它看作为 Go 的快并且轻量的 Electron 替代品。 您可以使用 Go 的灵活性和强大功能，结合丰富的现代前端，轻松的构建应用程序。与 Tauri 类似，Windows 上使用的是 Webview2。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c6934d2d24e4d6ca4e845a2efa1a665%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;2.5 Flutter for Desktop&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&quot;https://flutter.dev/multi-platform/desktop&quot;&gt;https://flutter.dev/multi-platform/desktop&lt;/a&gt;&lt;br/&gt;
GitHub：&lt;a href=&quot;https://github.com/flutter/flutter&quot;&gt;https://github.com/flutter/flutter&lt;/a&gt;&lt;br/&gt;
语言：Dart&lt;br/&gt;
代表项目：暂无&lt;/p&gt;

&lt;p&gt;从渲染原理看 Flutter 是 skia 自绘性能优于 Electron，但需要考虑下稳定性和生态。&lt;/p&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;3 跨平台的架构原理&lt;/h1&gt;

&lt;p&gt;本次我们讨论下用的最多的 Electron 和比较有前景的 Tauri 的架构原理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fdd03760f0744f4b98b1dd59c0b8746%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过 Web 技术写 UI，赋予了底层能力，达到跨平台的能力及体验。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;3.1 Chromium 多进程架构&lt;/h2&gt;

&lt;p&gt;大多数现代 Web 浏览器都为多进程架构，主要有浏览器主进程、渲染进程、插件进程、网络进程、GPU 进程，Chromium 也是如此。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;IPC = Inter-Process Communication 进程间通信&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8137f79fbd34f5284e7d4fe2ad80625%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Chromium 是 Chrome 的开源版，同时也是一个浏览器。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  主进程的 RenderProcessHost 和渲染进程的 RenderProcess 负责处理 IPC 事件&lt;/li&gt;
&lt;li&gt;  渲染进程的 RenderView，页面的展示就是在这里基于 Webkit 排版出来的&lt;/li&gt;
&lt;li&gt;  ResourceDispatcher 处理资源请求，当页面需要请求资源时，通过 ResourceDispather 创建一个请求 ID 转发到 IPC，在 Browser 进程中处理后返回&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;3.2 Electron 架构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50ae228de9634d3d91cd0f60fae3e17e%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  在每个进程中暴露了 Native API（Main Native API，Renderer Native API）&lt;/li&gt;
&lt;li&gt;  引入 Node.js&lt;/li&gt;
&lt;li&gt;  Web 技术实现 UI&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;3.3 Electron 进程模型&lt;/h1&gt;

&lt;p&gt;Electron 继承了来自 Chromium 的多进程架构，这使得此框架在架构上非常相似于一个现代的网页浏览器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为何采用多进程架构？&lt;/strong&gt;&lt;br/&gt;
网页浏览器是个极其复杂的应用程序。 除了显示网页内容的主要能力之外，他们还有许多次要的职责，例如：管理众多窗口 ( 或 标签页 ) 和加载第三方扩展。&lt;br/&gt;
在早期，浏览器通常使用单个进程来处理这些功能。 这种模式虽然能减小打开每个标签页的开销，但也同时意味着一个网站的崩溃或无响应会影响到整个浏览器。&lt;br/&gt;
为了解决这个问题，Chrome 团队决定让每个标签页在自己的进程中渲染， 从而限制了一个网页上的有误或恶意代码可能导致的对整个应用程序造成的伤害。 然后用单个浏览器进程控制这些标签页进程，以及整个应用程序的生命周期&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbe65de9e59748e3bed08d33d85f2e8b%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Electron 也是这样，作为应用开发者，控制着两种类型的进程，主进程和渲染进程。&lt;br/&gt;
主进程负责应用程序窗口管理，应用程序的生命周期，原生API等&lt;br/&gt;
渲染进程负责UI的展示，这部分我们可以选择任意前端框架 Vue、React、Svelte、Preact&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;3.4 Tauri 进程模型&lt;/h2&gt;

&lt;p&gt;Tauri 采用了一种类似 Electron 和大多数现代Web浏览器那样的多进程架构。包括主进程和 WebView进程，单个主进程管理一个或多个 WebView 进程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/404d8d1e3376435b808e469bdd2b25f7%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;3.5 进程间通信&lt;/h2&gt;

&lt;p&gt;Electron 的进程通信&lt;br/&gt;
渲染器进程 -&amp;gt; 主进程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  （单向）ipcRenderer.send API 发送消息，然后使用 ipcMain.on API 接收&lt;/li&gt;
&lt;li&gt;  （双向）ipcRenderer.invoke 与 ipcMain.handle 搭配使用来完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;4 实战 - 导航启动工具&lt;/h1&gt;

&lt;p&gt;为了对比 Electron 和 Tauri 差异性，分别用 Electron 和 Tauri 做一个简单的应用，导航启动器，类似 Alfred，Spotlight。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;4.1 功能描述&lt;/h2&gt;

&lt;p&gt;首先描述下这个应用的功能，启动应用后，通过快捷键 Ctrl/Command + K 唤起应用界面 - 一个输入框，在输入框输入关键词 git 会展示 git 相关的系统名称列表，选择后回车即可打开 github.com，相当于另类的书签。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;4.2 设计思路&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05cf6786f68049a1a717235896ccd2dc%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;4.3 项目结构及实现&lt;/h2&gt;

&lt;p&gt;这里 Electron 使用的是 Electron React Boilerplate 脚手架，使用 webpack 构建 UI 部分&lt;br/&gt;
Tauri 是使用官方的脚手架工具 - create-tauri-app，内置了 Vite，在前端框架上选了 React&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c436f6c756e4d64a818dfa5bdbc1fc3%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个导航启动器主要涉及的功能点有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 整个应用不展示关闭，最小化，最大化的按钮及整个菜单栏（menuBar），无边框窗口&lt;/li&gt;
&lt;li&gt; 视觉上整个应用是一个输入框，应用窗口的高度是根据网页内容的高度自适应&lt;/li&gt;
&lt;li&gt; 注册全局快捷键，显示应用，隐藏应用&lt;/li&gt;
&lt;li&gt; 监听按键，并使用默认浏览器打开链接&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;&lt;a href=&quot;&quot;/&gt;4.3.1 对于功能点一&lt;/h3&gt;

&lt;p&gt;Electron 是通过对主窗口初始化时修改配置，frame 设置成 false 可实现无边框窗口&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fc2d5261ebf495fa6f6b8a74c081568%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在 Tauri 中，实现无边框窗口有 3 种方式：通过 tauri.conf.json 配置，通过 Tauri 提供的 JS API - &lt;a href=&quot;https://github.com/tauri&quot; title=&quot;@tauri&quot;&gt;@tauri&lt;/a&gt;-apps/api，通过 Rust 原生修改 window；这里我们选用在 tauri.config.json 中配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f22e48d066143b4b842d9e3e40cb59e%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;&quot;/&gt;4.3.2 对于功能点二&lt;/h3&gt;

&lt;p&gt;输入框部分均由 React 实现，主要的差异在窗体根据内容高度动态调整窗体的高度，就是根据 document.body.offsetHeight 的高度去设置 mainWindow 的高度&lt;br/&gt;
在 Electron 中，可以在渲染进程中发 IPC 通知主进程去修改，主进程监听到消息后进行高度修改&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/269ca684c34d42f29cb3fecae74fc5f4%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在 Tauri 中，相对比较方便，对于常用的功能都封装了 JS API，也就是前面提到的 &lt;a href=&quot;https://github.com/tauri&quot; title=&quot;@tauri&quot;&gt;@tauri&lt;/a&gt;-apps/api，直接导入方法调用即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa1cfe86feeb4dcc8203b5b94433da02%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;&quot;/&gt;4.3.3 对于功能点三&lt;/h3&gt;

&lt;p&gt;注册全局快捷键，控制 mainWindow 的显示和隐藏&lt;br/&gt;
在 Electron 中，首先定义 registerGlobalShortcut 方法，在 app 启动后注册快捷键，主要是在主进程中操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e3942cf2f064475bd358b5d092c7585%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在 Tauri 中，得益于 JS API 的便利性，在渲染进程中就可以注册，因此只需要在 React 生命周期中执行注册&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1d0a6ea5747400db29b0b66a6018daa%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;&quot;/&gt;4.3.4 对于功能点四&lt;/h3&gt;

&lt;p&gt;方便演示，我们这里直接对 document.body 进行 onkeydown 监听，上下光标选择对应的选项，回车或点击使用默认浏览器打开对应的链接，这里两者的实现很相似&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ce3a5ba35d54b7e9efb4a5ceedb7449%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，主要功能已经完成，下一步进入看下如何打包多平台的应用。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;4.4 应用打包&lt;/h2&gt;

&lt;p&gt;Electron 中比较常见的有两种打包，electron-packager 和 electron-builder，electron-builder 的生态更好，我们这里选择 electron-builder。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2324d12d856456088120ccd30a1da2f%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Tauri 中则是内置在 cli 的打包方案，执行 yarn tauri build 即可&lt;/p&gt;

&lt;p&gt;同一应用对比，相同 React 版本，未使用 UI 框架&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98bb03747e214c939964856e237ac059%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44aee62efbcc4db4b40bce1b4ae3200f%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过以上数据对比基本与 Tauri 主页上的数值相符，较小的体积，内存占用小。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcbb3f1356624ff594ce7141236a6c9b%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;4.5 应用更新&lt;/h2&gt;

&lt;p&gt;两者都有对应的解决方案，具体内容可以看下官方文档，本文不做过多介绍。&lt;/p&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;5 总结&lt;/h1&gt;

&lt;p&gt;NW.js 的时代已经过去，考虑 NW.js 的可以优先 Electron。&lt;br/&gt;
Tauri 表现不错，前景看好。它解决了 Electron 现有的很多问题，带来了简单便捷的开发体验，也期待 Tauri 的 roadmap 中集成 Deno 作为应用的后端处理，这样就可以继续使用 JavaScript/TypeScrupt 来实现应用后端逻辑，新项目可以考虑使用，但是还有一些问题需要改进以及 Rust 的学习曲线曲折，有一定的学习成本。&lt;br/&gt;
Electron 目前仍是最多的选择，得益于自身庞大的社区，丰富的功能及工程实践，性能优化这部分比较考验开发者。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>722768488a2debb83d830a4cff4e5882</guid>
<title>Java 8已被弃用，全面拥抱Java17的时代来临！</title>
<link>https://toutiao.io/k/7eajny5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;👆&lt;/span&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;span&gt;博文视点Broadview&lt;/span&gt;&lt;span&gt;”，获取更多书讯&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05669291338582677&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;635&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nr1VNxfeqxVOw2nPJHVH4xeZibzPY5F4ibOuOZLMsUMrzIibGB6KMw7EurSKv6DkrtLzuhYdBa30A9Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;0.10027855153203342&quot; data-s=&quot;300,640&quot; data-type=&quot;gif&quot; data-w=&quot;1077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PW0wIHxgg3npgLu0khEqdibc8UNib9mUOF5Oic7ofxC1krfeqOz5wtoEWMiczOpKGic8QcQLLuSPHicTEZhBqib9LGTeA/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot;/&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;121695&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;新版任你发，我用 Java 8？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;醒醒啦同志们，时代正在发生改变！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从目前的一些消息来看，Java8 似乎正在退场。留给java 8用户的时间不多了……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; Spring  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring 6.0 11月隆重发布， 作为一大重要版本，直接宣布最低支持 Java 17 ！如果用户目前使用的是Java 8或Java 11，那么需要先升级 JDK~&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6240740740740741&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4YNr10rzF0yc4Q2yNH9Zot0ic4XOW4aqDtYmr9YBzpibK8lwicWCwfkBLLzRf7hzUCzTrUkwdHjbZXLLeVWyNKvpg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; Spring Boot &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同样也在11月份，Spring Boot 3.0正式发布，使用 Java 17作为最低版本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5224242424242425&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4YNr10rzF0yc4Q2yNH9Zot0ic4XOW4aqDicdJFLJjfK2nLRTVnx5zQgPoxjsKmJptKCozx3n5Q8W1K3iaWUZHibDZQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; Kafka &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自3.0版本开始 Apache Kafka 项目的所有组件都已弃用对 Java 8 的支持。计划在4.0时Java 8 将在讲被彻底移除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6481481481481481&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4YNr10rzF0yc4Q2yNH9Zot0ic4XOW4aqDyTtJA7E3NSBQ5NFwrEfVSibGCbJGHibicia27mWe5yWqv1yEcvLibzj3Sjg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; Jenkins &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从今年发布的 Jenkins 2.357 开始，Jenkins便已经需要 Java 11才能使用，已弃用 Java 8。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4YNr10rzF0yc4Q2yNH9Zot0ic4XOW4aqDEYnWEqPOurVtgR6yYn90lMSRv9F0NEMu00ycft4PjCWnlV065Zh8LA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更何况，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Java之父高斯林曾就公开建议赶紧升级到Java17，因为JDK17是一个比Java8更好的版本！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3490740740740741&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4YNr10rzF0yc4Q2yNH9Zot0ic4XOW4aqDeqFv4ydpaMff57A8siaxGfqQeiaBC8S3uOf9CDa6Idr3CnKUl5EicOGzA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;“对于那些仍然坚持使用 JDK8 的人，有一个包含所有最新更新和 CVE 防御的新 Corretto 版本。但是，请尽快离开 JDK8。JDK17 LTS 在各个方面都是一个巨大的飞跃。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;38806&quot;&gt;&lt;section&gt;&lt;section data-bcless=&quot;darken&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;那为什么是Java17呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Java 17 是 2021 年 9 月 14 日正式发布的，距今也已经有一年多了，是一个长期支持（LTS）版本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从 JDK 诞生到现在，还在长期支持的版本主要有 JDK 7、JDK 8 、JDK 11以及 JDK 1，JDK 17 将是继 Java 8 以来最重要的LTS版本，是 Java 社区八年努力的成果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;JAVA 17 带来的不仅仅是新功能。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;更快的 LTS 节奏和免费的 Oracle JDK 使其成为有史以来支持最好的现代版本！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4YNr10rzF0yc4Q2yNH9Zot0ic4XOW4aqDsf8oQV3vyibby9m19snnAloiaNUwRO6XVg94Rga4yRQFUSUJFUSkrRiaQ/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;549.204152249135&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.42890625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4YNr10rzF0yc4Q2yNH9Zot0ic4XOW4aqDlFOOyocBx8Oibic7ozD3fKib92FkskYPFB4ItwHGkhRcca8lCR2ib0WK2Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然大部分人现在还在用着 JDK 7/8，甚至 6，还在写着 JDK 5 的语法，现在随着 JDK 17+ 的免费，或者在未来的不久，JDK 8 会逐渐被替代，JDK 17+ 慢慢走上舞台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;全面拥抱 Java 17 还没有真的到来，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;但至少已经在路上了，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;作为程序员的我们应该做准备了！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;38806&quot;&gt;&lt;section&gt;&lt;section data-bcless=&quot;darken&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;《跟着李刚老师学Java》重磅更新&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;顺应时代发展，与Java学习者需求改变，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;博文视点学院王牌课程《跟着李刚老师学Java》，围绕Java17，迎来了重大增补！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7466666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4YNr10rzF0yO8rC0mSlibBdibo1EiaWicSIO1DIdlAFiccw6thfGrCArXs5bOnoxp6p8oIJrjUbcsLYyc22clIVslibw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;= 更新课程见如下课程编号 =&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.4890625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4YNr10rzF0yc4Q2yNH9Zot0ic4XOW4aqDSIphjDcGhkAm9YytbicaZeGRoJNPdkA45nbr1Hdrv7fyrh5BNcl92Sg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▊&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;从入门到就业，助力你的Java晋级之路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本课程不是普通的录播课，更不是单纯念PPT，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;是真实课堂教学，有互动，更有听课氛围。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;李刚老师在课程中现场编写程序，一步一步的告诉你，要做什么，为什么，怎么来，应怎么做，还能怎么做，让你完全明白这些Java体系的前世今生！更有课堂学生提问，会在大家普遍难以理解的地方做出解答，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;不需要自己事后研究，闭门造车。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;▊ &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;精研教学，成就你的长线发展&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;本次更新是课程上线后的第一次更新，也一定不是最后一次更新。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上一次的内容增补中，我们为已经入门、有进阶需求的同学增加了&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Java反射和Java模块化等&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;15节&lt;/span&gt;&lt;span&gt;高阶知识点讲解。我们相信随着技术的不断发展，学习需求的不断迭代，课程也将进行持续调整，做到——&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;一次订阅，持续收益！&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;▼&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;120659&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;课程升级，加量不加价&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;248期视频讲解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;超5000分钟干货输出&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在订阅只需 &lt;/span&gt;&lt;span&gt;&lt;strong&gt; 159元 ！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;▼扫码了解更多课程详情▼&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4YNr10rzF0yc4Q2yNH9Zot0ic4XOW4aqDicubicKdVK1n5uBNOgsj3CiaebFicHgWxj7qrSEgf7cb0XL0Msxw5U07aA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;▼&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;120659&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;书课搭配，效果更佳&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;课程配套图书&lt;/span&gt;&lt;span&gt;&lt;strong&gt;《疯狂Java讲义》&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是很多人的启蒙图书，历时十年沉淀，已经过无数Java学习者的反复验证，被包括北京大学在内的大量985、211高校的优秀教师引荐为参考资料或选作教材。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如今，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;这部十年原创经典也&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;基于稳定版本Java 17进行了彻底升级&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，并兼容了Java11/8！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;《疯&lt;/strong&gt;&lt;strong&gt;狂Java讲义（第6版）》重磅来袭！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7777777777777777&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4YNr10rzF0wHhx3ibQ2RrX8ibnE5e8IM7EG2KxxBJw1mRiax80nuUATbiakDDAur4fcPKgSV7a6Qbqc20PCRUV1zQQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，上册正在京东&lt;/span&gt;&lt;span&gt;&lt;strong&gt;五折优惠&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小伙伴们快快扫码抢购吧！&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; title=&quot;疯狂Java上二维码.png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4YNr10rzF0wHhx3ibQ2RrX8ibnE5e8IM7EHwYrRTHMSEvjmtmtet3RfSjicJgxLcwqlYice6DFo1toLROrYD8nlQdA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;发布：刘恩惠&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;审核：陈歆懿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;574&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;244&quot; data-ratio=&quot;0.4777777777777778&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;900-400_画板 1-1.png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3npgLu0khEqdibc8UNib9mUOFWz3Av7aEWkgib7uEOIIVCVonIgnJrUgibElFcvUXFAIMOvoxHX3gqU5g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>531467a4a0fd7e8a108f8d8a86150303</guid>
<title>PO、VO、DAO、BO、DTO、POJO 能分清吗？</title>
<link>https://toutiao.io/k/rwht8b6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;大家好，我是锋哥！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;《阿里巴巴Java开发规范》关于领域模型的部分介绍如下&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;分层领域模型规约:&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DO(Data Object):此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DTO(Data Transfer Object):数据传输对象，Service 或 Manager 向外传输的对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BO(Business Object):业务对象，由 Service 层输出的封装业务逻辑的对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;AO(ApplicationObject):应用对象，在Web层与Service层之间抽象的复用对象模型， 极为贴近展示层，复用度不高。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;VO(View Object):显示层对象，通常是 Web 向模板渲染引擎层传输的对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Query:数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;领域模型命名规约：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一、PO :(persistant object )，持久对象&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;可以看成是与数据库中的表相映射的java对象。&lt;/span&gt;&lt;span&gt;使用Hibernate来生成PO是不错的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;二、VO :(value object) ，值对象&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。&lt;/span&gt;&lt;span&gt;但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PO只能用在数据层，VO用在商业逻辑层和表示层。各层操作属于该层自己的数据对象，这样就可以降低各层之间的耦合，便于以后系统的维护和扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;三、DAO :(Data Access Objects) ，数据访问对象接口&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;DAO是Data Access Object数据访问接口，数据访问：&lt;/span&gt;&lt;span&gt;顾名思义就是与数据库打交道。&lt;/span&gt;&lt;span&gt;夹在业务逻辑与数据库资源中间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;J2EE开发人员使用数据访问对象（DAO）设计模式把底层的数据访问逻辑和高层的商务逻辑分开.实现DAO模式能够更加专注于编写数据访问代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DAO模式是标准的J2EE设计模式之一.开发人员使用这个模式把底层的数据访问操作和上层的商务逻辑分开.一个典型的DAO实现有下列几个组件：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一个DAO工厂类；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个DAO接口；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个实现DAO接口的具体类；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据传递对象（有些时候叫做值对象）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的DAO类包含了从特定的数据源访问数据的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;四、BO :(Business Object)，业务对象层&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;表示应用程序领域内“事物”的所有实体类。&lt;/span&gt;&lt;span&gt;这些实体类驻留在服务器上，并利用服务类来协助完成它们的职责。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;五、DTO Data Transfer Object数据传输对象&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;主要用于远程调用等需要大量传输对象的地方。&lt;/span&gt;&lt;span&gt;比如我们一张表有100个字段，那么对应的PO就有100个属性。&lt;/span&gt;&lt;span&gt;但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;六、POJO :(Plain Old Java Objects)，简单的Java对象&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;实际就是普通JavaBeans,使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接.其中有一些属性及其getter、setter方法的类,有时可以作为value object或dto(Data Transform Object)来使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;pre&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文章来&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;源：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;https://blog.csdn.net/Marsin_csdn/article/details/123956679&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/pre&gt;&lt;pre data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(167, 167, 167)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(63, 63, 63)&quot; data-style=&quot;letter-spacing: 0.544px; font-size: 16px; color: rgb(63, 63, 63); word-spacing: 1px; line-height: inherit;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;89429&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;pre data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(167, 167, 167)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(63, 63, 63)&quot; data-style=&quot;letter-spacing: 0.544px; font-size: 16px; color: rgb(63, 63, 63); word-spacing: 1px; line-height: inherit;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;89429&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;End&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;pre&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;pre mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;pre mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;span&gt;锋哥私房菜资源热门推荐&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxNTAwNjA4OQ==&amp;amp;mid=2247544462&amp;amp;idx=1&amp;amp;sn=e68b3cd4e914b918d0d9bfe5612a8c54&amp;amp;chksm=979c8068a0eb097e00ccd36812e72eeca3dbf61227fa072698745b9cc958efa1758960b03555&amp;amp;token=1541853692&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringSecurity+Vue权‍限系统(42讲) 震撼发布！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;SpringSecurity+Vue权限系统(42讲) 震撼发布！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxNTAwNjA4OQ==&amp;amp;mid=2247544465&amp;amp;idx=1&amp;amp;sn=08ab79d55988505ba4ccbe95ad23e047&amp;amp;chksm=979c8077a0eb0961088489499410d81f7bf71655e4a995f1729c6066e63316db4b52a0004785&amp;amp;token=1541853692&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;J‍ava微信小程序电商实战课程，高调发布...‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java微信小程序电商实战课程(95讲) 高调发布&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxNTAwNjA4OQ==&amp;amp;mid=2247544465&amp;amp;idx=1&amp;amp;sn=08ab79d55988505ba4ccbe95ad23e047&amp;amp;chksm=979c8077a0eb0961088489499410d81f7bf71655e4a995f1729c6066e63316db4b52a0004785&amp;amp;token=1541853692&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;J‍ava微信小程序电商实战课程，高调发布...‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;!&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4ODA3NTk0Nw==&amp;amp;mid=2247485947&amp;amp;idx=1&amp;amp;sn=e5a0d71eb30c35fc5342c7aa4f35984a&amp;amp;chksm=cf81ea3ff8f6632967d0991ff44ffcbb216f7b931a1681139d3b67b1a4468b4115c209242526&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot; ‍66套Java实战项目领取...‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;66套Java实战项目课程领取...&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(167, 167, 167)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(63, 63, 63)&quot; data-style=&quot;letter-spacing: 0.544px; font-size: 16px; color: rgb(63, 63, 63); word-spacing: 1px; line-height: inherit;&quot;&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;2022年粉丝福利 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;http://download.java1234.com/&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每月送 &lt;span&gt;666 &lt;/span&gt;套Java海量资源网站 &lt;span&gt;VIP会员&lt;/span&gt;，供大伙一起学Java&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果没加过锋哥微信的&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;加一下锋哥微信备注 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;VIP &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;即可开通&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;👇👇👇&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;242&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;238&quot; data-fileid=&quot;100045181&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9956140350877193&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3kMZppQa5zBFzRibB5ibWr7CyqtOhnyMguCXxrebicRkMb1LAfczVCdYF0WeBjRQZcgybOg7Lcjf9zggdAfqJQUAA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;228&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;👆长按上方二维码2秒,备注&lt;/span&gt;&lt;span&gt;vip&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;0.45454545454545453&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/7ibzJsmgW5wguO21SlkBAdxJgAicEOVCzDiaObyzEAEMTI527clib7gHvKfBtDu8MJZLwwEIVuVBmqfn01fmLDdTfQ/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;锋哥，前世界500强央企软件工程师，10年Java老司机，技术专家，资深Java讲师，小锋网络科技 光杠司令员，司令部：www.java1234.vip 每天坚持锻炼身体，坚持早睡早起，崇尚自由，平时喜欢带带Java学员 (已经成功指导2000+学员高薪就业)，喜欢搞搞Java技术自媒体，搞搞产品，后期继续研究主流技术，Python+大数据+人工智能等，每天进步一点，奥利给..&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b8792828f0f7948e335e29ad9e6c2add</guid>
<title>深入理解 Electron：VS Code 架构探索</title>
<link>https://toutiao.io/k/d6i4lic</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说起建立在Electron之上最出色且复杂的应用，那就不得不提到VSCode。VSCode 是一个基于 Electron 构建的跨平台代码编辑器，对于想要深入了解它的启动过程的开发者来说，这是一个非常有价值的学习过程。通过了解 VSCode 的启动过程，我们可以更好地理解 Electron 应用程序的启动流程，并学习如何在应用程序中加载、初始化和管理大量的代码模块和资源。此外，VSCode 启动过程中会涉及到各种与系统环境、用户配置和扩展安装有关的因素，深入研究这些方面可以让我们更好地优化应用程序的性能和用户体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解启动过程之前，我们先得对VSCode整个源码的架构有个大致的了解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;VSCode源码架构概述&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;vscode&lt;/code&gt;整体源码结构还是比较清晰的，重要目录如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;extensions/&lt;/code&gt;：包含默认安装的vscode扩展。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;product.json&lt;/code&gt;：描述vscode产品的配置文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;src/&lt;/code&gt;：包含vscode的源码，是最核心的目录。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;base/&lt;/code&gt;：提供通用的工具函数和用户界面构建块，可在其他层次中使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;platform/&lt;/code&gt;: 提供依赖注入支持和VSCode的基础服务，这些服务在多个层次之间共享，例如工作台和代码。不应包含编辑器或工作台特定的服务或代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;workbench/&lt;/code&gt;：托管 &quot;Monaco&quot; 编辑器、笔记本和自定义编辑器，并提供面板框架，如资源管理器、状态栏或菜单栏，利用 Electron 实现 VS Code 桌面应用程序和浏览器 API 提供 VS Code Web 版本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;code/&lt;/code&gt;：VSCode桌面应用程序的入口点，负责将所有内容拼合在一起，包括Electron主文件、共享进程和CLI。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;server/&lt;/code&gt;：远程开发的服务器应用程序的入口点，负责处理远程开发的相关服务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们之间的依赖关系如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9165571616294349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ta0Hx5vm0hMxAP2uxicHmm5H5H7JNGhic3OxvUFsSZBzrX68qPTMkfZicxiaUz8EDTtOwNkDTGFZsh77ybvhnzy5Qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1522&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是VS Code源码的核心组织架构。通过 &lt;code&gt;code&lt;/code&gt; 和 &lt;code&gt;server&lt;/code&gt; 作为入口，&lt;code&gt;workbench&lt;/code&gt; 作为主框架，而 &lt;code&gt;editor&lt;/code&gt;、&lt;code&gt;platform&lt;/code&gt; 和 &lt;code&gt;base&lt;/code&gt; 则成为这个庞大应用的基石。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于VSCode本身同时提供面向浏览器的版本和客户端的版本，所以在二级目录下整体的目录结构又是跟所支持的目标平台环境有关：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;common&lt;/code&gt;：只需要基本的JavaScript API，可以运行在所有其他目标环境中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;browser&lt;/code&gt;：需要Web API，例如DOM。可能使用&lt;code&gt;common&lt;/code&gt;中的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;node&lt;/code&gt;：需要Node.js API。可能使用&lt;code&gt;common&lt;/code&gt;中的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;electron-sandbox&lt;/code&gt;：需要浏览器API，如访问DOM，以及与Electron主进程通信的一小部分API（来自&lt;code&gt;src/vs/base/parts/sandbox/electron-sandbox/globals.ts&lt;/code&gt;）。可能使用&lt;code&gt;common&lt;/code&gt;、&lt;code&gt;browser&lt;/code&gt;和&lt;code&gt;electron-sandbox&lt;/code&gt;中的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;electron-main&lt;/code&gt;：需要Electron主进程API。可能使用&lt;code&gt;common&lt;/code&gt;和&lt;code&gt;node&lt;/code&gt;中的代码。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5917114351496546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ta0Hx5vm0hMxAP2uxicHmm5H5H7JNGhic3oRjoTn4zbIWedbIPFGNEj1bXV5TOuGph0sOqSibJLPicPKCnM68kenpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1303&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;入口文件解析&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VSCode作为Electron入口文件在&lt;code&gt;src/main.js&lt;/code&gt;中，这个文件主要做了以下几件事情：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;初始化应用程序：在引入了 electron 模块后，通过 electron.app 模块中的 ready 事件监听函数，在 Electron 框架准备好后，执行初始化应用程序的函数。初始化应用程序的过程包括：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;启用 ASAR 支持。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置用户数据路径。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注册自定义协议。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置本地化环境等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;监听app.onReady方法，调用startup方法启动应用。&lt;/section&gt;&lt;/li&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;startup&lt;/span&gt;(&lt;span&gt;codeCachePath, nlsConfig&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt; nlsConfig._languagePackSupport = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt; process.env[&lt;span&gt;&#x27;VSCODE_NLS_CONFIG&#x27;&lt;/span&gt;] = &lt;span&gt;JSON&lt;/span&gt;.stringify(nlsConfig);&lt;br/&gt; process.env[&lt;span&gt;&#x27;VSCODE_CODE_CACHE_PATH&#x27;&lt;/span&gt;] = codeCachePath || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Load main in AMD&lt;/span&gt;&lt;br/&gt; perf.mark(&lt;span&gt;&#x27;code/willLoadMainBundle&#x27;&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./bootstrap-amd&#x27;&lt;/span&gt;).load(&lt;span&gt;&#x27;vs/code/electron-main/main&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;  perf.mark(&lt;span&gt;&#x27;code/didLoadMainBundle&#x27;&lt;/span&gt;);&lt;br/&gt; });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码就是vscode的核心启动函数，主要是通过AMD的方式加载&lt;code&gt;electron-main/main&lt;/code&gt;这个入口。为什么要采用AMD呢？这可能跟VSCode的历史背景有关，也是目前VSCode的一个核心技术债，下面我们来详细说一说：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于VSCode中的AMD加载&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VS Code使用AMD（Asynchronous Module Definition）来加载JavaScript模块。AMD是一种异步的模块定义规范，它支持在浏览器环境下异步加载JavaScript模块，从而避免了页面加载时长时间等待所有模块都被下载和执行的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，VSCode最早期是先有浏览器版本的，而在ES Module出现之前，浏览器最受欢迎的模块加载方案就是AMD。我们稍微回顾一下模块化的历史发展（为了简化起见，就不提sea了）：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;IIFE模式（立即执行函数表达式）：在ES5时代，JavaScript没有官方的模块化机制，因此开发者通常使用IIFE来实现模块化。IIFE可以将一段代码封装到一个匿名函数中，避免全局变量的污染，从而实现基本的模块化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CommonJS规范：CommonJS是一个JavaScript模块化规范，主要用于服务器端，Node.js就是使用了CommonJS规范的模块化机制。CommonJS使用require()函数来引入模块，使用module.exports来导出模块。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AMD规范：AMD（Asynchronous Module Definition）是一个在浏览器端使用的JavaScript模块化规范，它的主要特点是异步加载模块，这样可以提高页面加载速度。AMD使用require.js库来实现模块化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ES6模块化：ES6是JavaScript的下一代标准，它在语言层面上提供了模块化机制。ES6模块化使用import语句来引入模块，使用export语句来导出模块。ES6模块化的好处是可以静态分析模块的依赖关系，从而实现更好的优化。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实VSCode使用AMD，除了有浏览器这一层的原因外，AMD本身可以带来一些特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AMD本身提供了define和require的模块化机制，可以将所有依赖bundle在一起，类似于Webpack，这样做能够很显著的提高性能（其实文件磁盘IO的开销在客户端应用当中并不小）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AMD相比CommonJS来说，是支持异步加载的，这样在加载的时候可以先不阻塞主线程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VSCode在Node环境中如何实现AMD的，让我们稍微深入分析一下（vscode专门实现了一个vscode-loader的仓库，用来实现CMD，做到了多端的统一模块化）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下&lt;code&gt;_createAndEvalScript&lt;/code&gt;的实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  private _createAndEvalScript(moduleManager: IModuleManager, &lt;span&gt;contents&lt;/span&gt;: string, &lt;span&gt;options&lt;/span&gt;: INodeVMScriptOptions, &lt;span&gt;callback&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;, &lt;span&gt;errorback&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;err: any&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;): INodeVMScript {&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; recorder = moduleManager.getRecorder();&lt;br/&gt;   recorder.record(LoaderEventType.NodeBeginEvaluatingScript, options.filename);&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; script = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._vm.Script(contents, options);&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; ret = script.runInThisContext(options);&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; globalDefineFunc = moduleManager.getGlobalAMDDefineFunc();&lt;br/&gt;   &lt;span&gt;let&lt;/span&gt; receivedDefineCall = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; localDefineFunc: IDefineFunc = &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt;&lt;/span&gt;function () {&lt;br/&gt;    receivedDefineCall = true;&lt;br/&gt;    return globalDefineFunc.apply(null, arguments);&lt;br/&gt;   };&lt;br/&gt;   localDefineFunc.amd = globalDefineFunc.amd;&lt;br/&gt;&lt;br/&gt;   ret.call(global, moduleManager.getGlobalAMDRequireFunc(), localDefineFunc, options.filename, this._path.dirname(options.filename));&lt;br/&gt;&lt;br/&gt;   recorder.record(LoaderEventType.NodeEndEvaluatingScript, options.filename);&lt;br/&gt;&lt;br/&gt;   if (receivedDefineCall) {&lt;br/&gt;    callback();&lt;br/&gt;   } else {&lt;br/&gt;    errorback(new Error(`Didn&#x27;t receive define call in ${options.filename}!`));&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   return script;&lt;br/&gt;  }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里面核心就是创建了一个_vm.Script，并且调用&lt;code&gt;runInThisContext&lt;/code&gt;执行，在调用vm时，其实就是在V8上创建了字节码，接下来供V8进行解析执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说这个步骤跟原生的require类似的话，那接下来对于file的处理应该就是最大的不同了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;private _readSourceAndCachedData(sourcePath: string, &lt;span&gt;cachedDataPath&lt;/span&gt;: string | &lt;span&gt;undefined&lt;/span&gt;, &lt;span&gt;recorder&lt;/span&gt;: ILoaderEventRecorder, &lt;span&gt;callback&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;err?: any, source?: string, cachedData?: Buffer, hashData?: Buffer&lt;/span&gt;) =&amp;gt;&lt;/span&gt; any): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (!cachedDataPath) {&lt;br/&gt;    &lt;span&gt;// no cached data case&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;._fs.readFile(sourcePath, { &lt;span&gt;encoding&lt;/span&gt;: &lt;span&gt;&#x27;utf8&#x27;&lt;/span&gt; }, callback);&lt;br/&gt;&lt;br/&gt;   } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// cached data case: read both files in parallel&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; source: string | &lt;span&gt;undefined&lt;/span&gt; = &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; cachedData: Buffer | &lt;span&gt;undefined&lt;/span&gt; = &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; hashData: Buffer | &lt;span&gt;undefined&lt;/span&gt; = &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; steps = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; step = &lt;span&gt;(&lt;span&gt;err?: any&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (err) {&lt;br/&gt;      callback(err);&lt;br/&gt;&lt;br/&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (--steps === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      callback(&lt;span&gt;undefined&lt;/span&gt;, source, cachedData, hashData);&lt;br/&gt;     }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;._fs.readFile(sourcePath, { &lt;span&gt;encoding&lt;/span&gt;: &lt;span&gt;&#x27;utf8&#x27;&lt;/span&gt; }, (err: any, &lt;span&gt;data&lt;/span&gt;: string) =&amp;gt; {&lt;br/&gt;     source = data;&lt;br/&gt;     step(err);&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;._fs.readFile(cachedDataPath, (err: any, &lt;span&gt;data&lt;/span&gt;: Buffer) =&amp;gt; {&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (!err &amp;amp;&amp;amp; data &amp;amp;&amp;amp; data.length &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      hashData = data.slice(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;      cachedData = data.slice(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;      recorder.record(LoaderEventType.CachedDataFound, cachedDataPath);&lt;br/&gt;&lt;br/&gt;     } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      recorder.record(LoaderEventType.CachedDataMissed, cachedDataPath);&lt;br/&gt;     }&lt;br/&gt;     step(); &lt;span&gt;// ignored: cached data is optional&lt;/span&gt;&lt;br/&gt;    });&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的核心点在于fs.readFile，这是个异步方法，而require内部用的是readFileSync，这也是AMD能实现异步加载的核心。另一部分是关于v8 cacheData的处理，这一点和require其实是类似的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，VSCode已经有将AMD迁移到ESM的计划，可以参考：https://github.com/microsoft/vscode/issues/160416&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;VSCode的依赖注入机制&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;private &lt;span&gt;async&lt;/span&gt; startup(): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Set the error handler early enough so that we are not getting the&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// default electron error dialog popping up&lt;/span&gt;&lt;br/&gt;  setUnexpectedErrorHandler(&lt;span&gt;&lt;span&gt;err&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.error(err));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Create services&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [instantiationService, instanceEnvironment, environmentMainService, configurationService, stateMainService, bufferLogService, productService, userDataProfilesMainService] = &lt;span&gt;this&lt;/span&gt;.createServices();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// Init services&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.initServices(environmentMainService, userDataProfilesMainService, configurationService, stateMainService, productService);&lt;br/&gt;   } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Show a dialog for errors that can be resolved by the user&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.handleStartupDataDirError(environmentMainService, productService, error);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; error;&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// Startup&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;await&lt;/span&gt; instantiationService.invokeFunction(&lt;span&gt;async&lt;/span&gt; accessor =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; logService = accessor.get(ILogService);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; lifecycleMainService = accessor.get(ILifecycleMainService);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; fileService = accessor.get(IFileService);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; loggerService = accessor.get(ILoggerService);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Create the main IPC server by trying to be the server&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// If this throws an error it means we are not the first&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// instance of VS Code running and so we would quit.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; mainProcessNodeIpcServer = &lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.claimInstance(logService, environmentMainService, lifecycleMainService, instantiationService, productService, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Write a lockfile to indicate an instance is running&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// (https://github.com/microsoft/vscode/issues/127861#issuecomment-877417451)&lt;/span&gt;&lt;br/&gt;    FSPromises.writeFile(environmentMainService.mainLockfile, &lt;span&gt;String&lt;/span&gt;(process.pid)).catch(&lt;span&gt;&lt;span&gt;err&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;     logService.warn(&lt;span&gt;`app#startup(): Error writing main lockfile: &lt;span&gt;${err.stack}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Delay creation of spdlog for perf reasons (https://github.com/microsoft/vscode/issues/72906)&lt;/span&gt;&lt;br/&gt;    bufferLogService.logger = loggerService.createLogger(URI.file(join(environmentMainService.logsPath, &lt;span&gt;&#x27;main.log&#x27;&lt;/span&gt;)), { &lt;span&gt;id&lt;/span&gt;: &lt;span&gt;&#x27;mainLog&#x27;&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt;: localize(&lt;span&gt;&#x27;mainLog&#x27;&lt;/span&gt;, &lt;span&gt;&quot;Main&quot;&lt;/span&gt;) });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Lifecycle&lt;/span&gt;&lt;br/&gt;    once(lifecycleMainService.onWillShutdown)(&lt;span&gt;&lt;span&gt;evt&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;     fileService.dispose();&lt;br/&gt;     configurationService.dispose();&lt;br/&gt;     evt.join(&lt;span&gt;&#x27;instanceLockfile&#x27;&lt;/span&gt;, FSPromises.unlink(environmentMainService.mainLockfile).catch(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;/* ignored */&lt;/span&gt; }));&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; instantiationService.createInstance(CodeApplication, mainProcessNodeIpcServer, instanceEnvironment).startup();&lt;br/&gt;   });&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;   instantiationService.invokeFunction(&lt;span&gt;this&lt;/span&gt;.quit, error);&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是VSCode启动代码（位于src/vs/code/electron-main/main.ts），它主要做了以下几件事情：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建各种服务：首先，VS Code创建一些服务实例来管理不同的任务和功能。通过尽可能延迟创建和初始化这些服务，VS Code可以减少启动时间。在这个过程中，VS Code还尽可能地减少I/O操作，例如，它会延迟创建日志服务，以避免不必要的写入到磁盘。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化服务：一旦创建了所有服务实例，VS Code会初始化这些服务以确保它们可以正确地工作。在这个过程中，VS Code会尝试读取用户设置和状态，但是它会尽可能地将这些操作延迟到需要时再进行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;启动：一旦所有服务都初始化完成，VS Code会开始启动主应用程序。在这个过程中，VS Code会尽可能地减少I/O操作，并使用缓存来避免不必要的模块加载和初始化。例如，在启动过程中，VS Code会尝试延迟创建IPC服务器，以避免不必要的通信开销。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生命周期管理：VS Code会在启动后立即处理生命周期管理。例如，它会立即创建一个IPC服务器，并写入一个锁文件，以指示当前有一个实例正在运行。这些任务是在启动过程中进行的，以确保它们尽可能地快速完成。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个流程中，其实最重要复杂的就是启动VSCode的依赖注入，它的核心实现位于vs/platform/instantiation：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个组件的核心概念是 &lt;code&gt;ServiceCollection&lt;/code&gt;，它是一组可被实例化的服务的集合。在启动 VS Code 时，VS Code 的主进程会创建一个 &lt;code&gt;ServiceCollection&lt;/code&gt; 对象，然后注册需要被实例化的服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同于Invesify等依赖注入库，VSCode的所有依赖实例都需要提前显示注册到&lt;code&gt;ServiceCollection&lt;/code&gt;中，最初的依赖可以在&lt;code&gt;createServices&lt;/code&gt;中找到：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;private createServices(): [IInstantiationService, IProcessEnvironment, IEnvironmentMainService, ConfigurationService, StateService, BufferLogger, IProductService, UserDataProfilesMainService] {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; services = &lt;span&gt;new&lt;/span&gt; ServiceCollection();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; disposables = &lt;span&gt;new&lt;/span&gt; DisposableStore();&lt;br/&gt;  process.once(&lt;span&gt;&#x27;exit&#x27;&lt;/span&gt;, () =&amp;gt; disposables.dispose());&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Product&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; productService = { &lt;span&gt;_serviceBrand&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt;, ...product };&lt;br/&gt;  services.set(IProductService, productService);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Environment&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; environmentMainService = &lt;span&gt;new&lt;/span&gt; EnvironmentMainService(&lt;span&gt;this&lt;/span&gt;.resolveArgs(), productService);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; instanceEnvironment = &lt;span&gt;this&lt;/span&gt;.patchEnvironment(environmentMainService); &lt;span&gt;// Patch `process.env` with the instance&#x27;s environment&lt;/span&gt;&lt;br/&gt;  services.set(IEnvironmentMainService, environmentMainService);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Logger&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; loggerService = &lt;span&gt;new&lt;/span&gt; LoggerMainService(getLogLevel(environmentMainService));&lt;br/&gt;  services.set(ILoggerMainService, loggerService);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; [&lt;span&gt;new&lt;/span&gt; InstantiationService(services, &lt;span&gt;true&lt;/span&gt;), instanceEnvironment, environmentMainService, configurationService, stateService, bufferLogger, productService, userDataProfilesMainService];&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，&lt;code&gt;serviceCollection&lt;/code&gt;的key是一个&lt;code&gt;Identifier&lt;/code&gt;，这实际上是一个装饰器，所有的&lt;code&gt;Identifier&lt;/code&gt;都是通过&lt;code&gt;createDecorator&lt;/code&gt;来创建的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createDecorator&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;(&lt;span&gt;serviceId: string&lt;/span&gt;): &lt;span&gt;ServiceIdentifier&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (_util.serviceIds.has(serviceId)) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; _util.serviceIds.get(serviceId)!;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; id = &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt;&lt;/span&gt;function (target: Function, key: string, index: number): any {&lt;br/&gt;  if (arguments.length !== 3) {&lt;br/&gt;   throw new Error(&#x27;@IServiceName-decorator can only be used to decorate a parameter&#x27;);&lt;br/&gt;  }&lt;br/&gt;  storeServiceDependency(id, target, index);&lt;br/&gt; };&lt;br/&gt;&lt;br/&gt; id.toString = () =&amp;gt; serviceId;&lt;br/&gt;&lt;br/&gt; _util.serviceIds.set(serviceId, id);&lt;br/&gt; return id;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用这个装饰器修饰成员变量的时候，会执行到&lt;code&gt;storeServiceDependency&lt;/code&gt;，将当前的信息存储在类上面，这样在后续进行依赖分析的时候，就可以读取到这些依赖相关的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在VSCode的编码实现中，我们会发现实现一个服务所需要的通用步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定义服务接口：首先需要定义服务接口，该接口定义了服务的 API，即服务能够提供哪些功能。接口通常放在 &lt;code&gt;vs/platform&lt;/code&gt; 文件夹下的一个子文件夹中，比如 &lt;code&gt;vs/platform/telemetry/common/telemetry&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定义与服务器同名的Identifier，比如&lt;code&gt;export const IProductService = createDecorator&amp;lt;IProductService&amp;gt;(&#x27;productService&#x27;);&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注册服务：其次需要在应用程序的入口处，即 &lt;code&gt;vs/code/electron-main/main.ts&lt;/code&gt; 中注册服务，并将其添加到容器中（以Identifier为key，实例或者SyncDescriptor实例作为value）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里提到了&lt;code&gt;SyncDescriptor&lt;/code&gt;，其实就是一个包装类，当我们不通过&lt;code&gt;new&lt;/code&gt;来手动创建实例时，就调用这个包装类交给&lt;code&gt;serviceCollection&lt;/code&gt;，由依赖注入机制帮助我们去实例化相关的依赖：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SyncDescriptor&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; readonly ctor: any;&lt;br/&gt; readonly staticArguments: any[];&lt;br/&gt; readonly supportsDelayedInstantiation: boolean;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;(ctor: new (...args: any[]) =&amp;gt; T, staticArguments: any[] = [], supportsDelayedInstantiation: boolean = false) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.ctor = ctor;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.staticArguments = staticArguments;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.supportsDelayedInstantiation = supportsDelayedInstantiation;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的注册方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;services.set(IRequestService, &lt;span&gt;new&lt;/span&gt; SyncDescriptor(RequestMainService, &lt;span&gt;undefined&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，在前面提到vscode本身是支持多目标环境的，所以&lt;code&gt;platform&lt;/code&gt;目录下的所有服务，都是分为&lt;code&gt;Node&lt;/code&gt;、&lt;code&gt;Electron-main&lt;/code&gt;、&lt;code&gt;common&lt;/code&gt;、&lt;code&gt;browser&lt;/code&gt;去实现的，它们之间有基本的继承关系，下图表示了三个最基础服务实现的继承关系：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;classDiagram&lt;br/&gt;class IProductService {&lt;br/&gt;&amp;lt;&amp;lt;interface&amp;gt;&amp;gt;&lt;br/&gt;_serviceBrand: undefined&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class IProductConfiguration {&lt;br/&gt;&amp;lt;&amp;lt;interface&amp;gt;&amp;gt;&lt;br/&gt;version: string;&lt;br/&gt;date?: string;&lt;br/&gt;quality?: string;&lt;br/&gt;commit?: string;&lt;br/&gt;nameShort: string;&lt;br/&gt;nameLong: string;&lt;br/&gt;...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;IProductConfiguration &amp;lt;|-- IProductService : extends&lt;br/&gt;IProductService &amp;lt;|.. ProductService : implements&lt;br/&gt;&lt;br/&gt;class IEnvironmentService {&lt;br/&gt;&amp;lt;&amp;lt;interface&amp;gt;&amp;gt;&lt;br/&gt;_serviceBrand: undefined;&lt;br/&gt;stateResource: URI；&lt;br/&gt;userRoamingDateHome: URI;&lt;br/&gt;untitledWorkspaceHome: URI;&lt;br/&gt;userDataSyncHome: URI;&lt;br/&gt;...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class INativeEnvironmentService {&lt;br/&gt;&amp;lt;&amp;lt;interface&amp;gt;&amp;gt;&lt;br/&gt;args: NativeParsedArgs;&lt;br/&gt;appRoot: string;&lt;br/&gt;machineSettingsResource: URI;&lt;br/&gt;extensionsPath: string;&lt;br/&gt;...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class IEnvironmentMainService {&lt;br/&gt;&amp;lt;&amp;lt;interface&amp;gt;&amp;gt;&lt;br/&gt;cachedLanguagesPath: string;&lt;br/&gt;backupHome: string;&lt;br/&gt;codeCachePath: string;&lt;br/&gt;useCodeCache: boolean;&lt;br/&gt;mainIPCHandle: string;&lt;br/&gt;...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class AbstractNativeEnvironmentService {&lt;br/&gt;&amp;lt;&amp;lt;abstract&amp;gt;&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;IEnvironmentService &amp;lt;|-- INativeEnvironmentService : extends&lt;br/&gt;INativeEnvironmentService &amp;lt;|-- IEnvironmentMainService : extends&lt;br/&gt;INativeEnvironmentService &amp;lt;|.. AbstractNativeEnvironmentService : implements&lt;br/&gt;AbstractNativeEnvironmentService &amp;lt;|-- NativeEnvironmentService : extends&lt;br/&gt;NativeEnvironmentService &amp;lt;|-- EnvironmentMainService : extends&lt;br/&gt;IEnvironmentMainService &amp;lt;|.. EnvironmentMainService : implements&lt;br/&gt;EnvironmentMainService --&amp;gt; ProductService&lt;br/&gt;&lt;br/&gt;class ILoggerService {&lt;br/&gt;&amp;lt;&amp;lt;interface&amp;gt;&amp;gt;&lt;br/&gt;_serviceBrand: undefined;&lt;br/&gt;createLogger(resource: URI, options?: ILoggerOptions): ILogger;&lt;br/&gt;getLogger(resource: URI): ILogger;&lt;br/&gt;onDidChangeLogLevel: Event&amp;lt;LogLevel&amp;gt;;&lt;br/&gt;setLogLevel(level: LogLevel): void;&lt;br/&gt;setLogLevel(resource: URI, level: LogLevel): void;&lt;br/&gt;getLogLevel(resource?: URI): LogLevel;&lt;br/&gt;onDidChangeVisibility: Event&amp;lt;[URI, boolean]&amp;gt;;&lt;br/&gt;setVisibility(resource: URI, visible: boolean): void;&lt;br/&gt;onDidChangeLoggers: Event&amp;lt;DidChangeLoggersEvent&amp;gt;;&lt;br/&gt;registerLogger(resource: ILoggerResource): void;&lt;br/&gt;deregisterLogger(resource: URI): void;&lt;br/&gt;getRegisteredLoggers(): Iterable&amp;lt;ILoggerResource&amp;gt;;&lt;br/&gt;getRegisteredLogger(resource: URI): ILoggerResource;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class ILoggerMainService {&lt;br/&gt;&amp;lt;&amp;lt;interface&amp;gt;&amp;gt;&lt;br/&gt;getOnDidChangeLogLevelEvent(windowId: number): Event&amp;lt;LogLevel&amp;gt;;&lt;br/&gt;getOnDidChangeVisibilityEvent(windowId: number): Event&amp;lt;[URI, boolean]&amp;gt;;&lt;br/&gt;getOnDidChangeLoggersEvent(windowId: number): Event&amp;lt;DidchangeLoggersEvent&amp;gt;;&lt;br/&gt;createLogger(resource: URI, options?: ILoggerOptions, windowId?: number): ILogger;&lt;br/&gt;registerLogger(resource: ILoggerResource, windowId?: number): void;&lt;br/&gt;getRegisteredLoggers(windowId?: number): ILoggerResource[];&lt;br/&gt;deregisterLoggers(windowId: number): void;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;ILoggerService &amp;lt;|.. AbstractLoggerService : implements&lt;br/&gt;AbstractLoggerService &amp;lt;|-- LoggerService : extends&lt;br/&gt;LoggerService &amp;lt;|-- LoggerMainService : extends&lt;br/&gt;ILoggerService &amp;lt;|.. AbstractLoggerService : implements&lt;br/&gt;ILoggerMainService &amp;lt;|.. LoggerMainService : implements&lt;br/&gt;ILoggerService &amp;lt;|-- ILoggerMainService : extends&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，在经过&lt;code&gt;instantiationService&lt;/code&gt;启动创建实例后，所有的依赖都会按照一定的顺序进行实例化，在VSCode的实现中，实际上是通过一个图的遍历算法来实现的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;private _createAndCacheServiceInstance&amp;lt;T&amp;gt;(id: ServiceIdentifier&amp;lt;T&amp;gt;, &lt;span&gt;desc&lt;/span&gt;: SyncDescriptor&amp;lt;T&amp;gt;, &lt;span&gt;_trace&lt;/span&gt;: Trace): T {&lt;br/&gt;&lt;br/&gt;  type Triple = { &lt;span&gt;id&lt;/span&gt;: ServiceIdentifier&amp;lt;any&amp;gt;; desc: SyncDescriptor&amp;lt;any&amp;gt;; _trace: Trace };&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; graph = &lt;span&gt;new&lt;/span&gt; Graph&amp;lt;Triple&amp;gt;(&lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; data.id.toString());&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; cycleCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; stack = [{ id, desc, _trace }];&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (stack.length) {&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; item = stack.pop()!;&lt;br/&gt;   graph.lookupOrInsertNode(item);&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// a weak but working heuristic for cycle checks&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (cycleCount++ &amp;gt; &lt;span&gt;1000&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CyclicDependencyError(graph);&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// check all dependencies for existence and if they need to be created first&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; dependency &lt;span&gt;of&lt;/span&gt; _util.getServiceDependencies(item.desc.ctor)) {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; instanceOrDesc = &lt;span&gt;this&lt;/span&gt;._getServiceInstanceOrDescriptor(dependency.id);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!instanceOrDesc) {&lt;br/&gt;     &lt;span&gt;this&lt;/span&gt;._throwIfStrict(&lt;span&gt;`[createInstance] &lt;span&gt;${id}&lt;/span&gt; depends on &lt;span&gt;${dependency.id}&lt;/span&gt; which is NOT registered.`&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// take note of all service dependencies&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;._globalGraph?.insertEdge(&lt;span&gt;String&lt;/span&gt;(item.id), &lt;span&gt;String&lt;/span&gt;(dependency.id));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (instanceOrDesc &lt;span&gt;instanceof&lt;/span&gt; SyncDescriptor) {&lt;br/&gt;     &lt;span&gt;const&lt;/span&gt; d = { &lt;span&gt;id&lt;/span&gt;: dependency.id, &lt;span&gt;desc&lt;/span&gt;: instanceOrDesc, &lt;span&gt;_trace&lt;/span&gt;: item._trace.branch(dependency.id, &lt;span&gt;true&lt;/span&gt;) };&lt;br/&gt;     graph.insertEdge(item, d);&lt;br/&gt;     stack.push(d);&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; roots = graph.roots();&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// if there is no more roots but still&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// nodes in the graph we have a cycle&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (roots.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!graph.isEmpty()) {&lt;br/&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CyclicDependencyError(graph);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; { data } &lt;span&gt;of&lt;/span&gt; roots) {&lt;br/&gt;    &lt;span&gt;// Repeat the check for this still being a service sync descriptor. That&#x27;s because&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// instantiating a dependency might have side-effect and recursively trigger instantiation&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// so that some dependencies are now fullfilled already.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; instanceOrDesc = &lt;span&gt;this&lt;/span&gt;._getServiceInstanceOrDescriptor(data.id);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (instanceOrDesc &lt;span&gt;instanceof&lt;/span&gt; SyncDescriptor) {&lt;br/&gt;     &lt;span&gt;// create instance and overwrite the service collections&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;const&lt;/span&gt; instance = &lt;span&gt;this&lt;/span&gt;._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);&lt;br/&gt;     &lt;span&gt;this&lt;/span&gt;._setServiceInstance(data.id, instance);&lt;br/&gt;    }&lt;br/&gt;    graph.removeNode(data);&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;this._getServiceInstanceOrDescriptor(id);&lt;br/&gt; }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个算法通过两层遍历，一层遍历生成一个有向图，第二层遍历为图的每个节点进行实例化的操作。使用图的数据结构可以清晰地看到依赖关系链路，并且能够快速识别出循环依赖问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，在使用层，依赖注入就变得十分简单：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Client&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;br/&gt;    @IModelService modelService: IModelService&lt;br/&gt;  ) {&lt;br/&gt;    &lt;span&gt;// use services&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CodeApplication的启动&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在经过&lt;code&gt;main&lt;/code&gt;的一系列依赖注入初始化后，最终启动的是&lt;code&gt;CodeApplication&lt;/code&gt;这个入口，它所依赖的服务都是在&lt;code&gt;main&lt;/code&gt;入口提前实例化好的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;constructor&lt;/span&gt;(&lt;br/&gt;  private readonly mainProcessNodeIpcServer: NodeIPCServer,&lt;br/&gt;  private readonly userEnv: IProcessEnvironment,&lt;br/&gt;  @IInstantiationService private readonly mainInstantiationService: IInstantiationService,&lt;br/&gt;  @ILogService private readonly logService: ILogService,&lt;br/&gt;  @IEnvironmentMainService private readonly environmentMainService: IEnvironmentMainService,&lt;br/&gt;  @ILifecycleMainService private readonly lifecycleMainService: ILifecycleMainService,&lt;br/&gt;  @IConfigurationService private readonly configurationService: IConfigurationService,&lt;br/&gt;  @IStateService private readonly stateService: IStateService,&lt;br/&gt;  @IFileService private readonly fileService: IFileService,&lt;br/&gt;  @IProductService private readonly productService: IProductService,&lt;br/&gt;  @IUserDataProfilesMainService private readonly userDataProfilesMainService: IUserDataProfilesMainService,&lt;br/&gt; ) {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.configureSession();&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.registerListeners();&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是每个参数的作用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;mainProcessNodeIpcServer&lt;/code&gt;: Node.js的IPC服务器，用于与主进程进行通信。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;userEnv&lt;/code&gt;: 用户环境，包括所有环境变量和命令行参数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;mainInstantiationService&lt;/code&gt;: 用于创建VSCode的实例化服务，可以通过它来创建和管理服务和对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;logService&lt;/code&gt;: 用于记录日志和诊断信息的服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;environmentMainService&lt;/code&gt;: 提供了许多与环境相关的功能，例如查找应用程序路径，读取配置文件等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;lifecycleMainService&lt;/code&gt;: 提供了应用程序生命周期的管理和控制功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;configurationService&lt;/code&gt;: 提供了应用程序配置的管理和控制功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;stateService&lt;/code&gt;: 提供了应用程序状态的管理和控制功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;fileService&lt;/code&gt;: 提供了与文件和文件系统相关的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;productService&lt;/code&gt;: 提供了与产品信息相关的功能，例如产品名称、版本号等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;userDataProfilesMainService&lt;/code&gt;: 提供了与用户数据配置文件相关的功能，例如创建、删除、查找配置文件等等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;code&gt;configureSession&lt;/code&gt;和&lt;code&gt;registerListeners&lt;/code&gt;用于应用启动前的初始化：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;configureSession&lt;/code&gt;设置一些 Electron 的 session 相关配置，包括一些webview访问的拦截安全设置，vscode自身支持的protocal访问等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;registerListeners&lt;/code&gt;注册了一系列主进程的事件监听，以及一些提早注册的IPC事件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终，整个应用的加载流程是调用&lt;code&gt;setup&lt;/code&gt;方法启动的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; startup(): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.logService.debug(&lt;span&gt;&#x27;Starting VS Code&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.logService.debug(&lt;span&gt;`from: &lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.environmentMainService.appRoot}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.logService.debug(&lt;span&gt;&#x27;args:&#x27;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.environmentMainService.args);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Make sure we associate the program with the app user model id&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// This will help Windows to associate the running program with&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// any shortcut that is pinned to the taskbar and prevent showing&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// two icons in the taskbar for the same app.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; win32AppUserModelId = &lt;span&gt;this&lt;/span&gt;.productService.win32AppUserModelId;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (isWindows &amp;amp;&amp;amp; win32AppUserModelId) {&lt;br/&gt;   app.setAppUserModelId(win32AppUserModelId);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Fix native tabs on macOS 10.13&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// macOS enables a compatibility patch for any bundle ID beginning with&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// &quot;com.microsoft.&quot;, which breaks native tabs for VS Code when using this&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// identifier (from the official build).&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Explicitly opt out of the patch here before creating any windows.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// See: https://github.com/microsoft/vscode/issues/35361#issuecomment-399794085&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (isMacintosh &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.configurationService.getValue(&lt;span&gt;&#x27;window.nativeTabs&#x27;&lt;/span&gt;) === &lt;span&gt;true&lt;/span&gt; &amp;amp;&amp;amp; !systemPreferences.getUserDefault(&lt;span&gt;&#x27;NSUseImprovedLayoutPass&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;boolean&#x27;&lt;/span&gt;)) {&lt;br/&gt;    systemPreferences.setUserDefault(&lt;span&gt;&#x27;NSUseImprovedLayoutPass&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;boolean&#x27;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; any);&lt;br/&gt;   }&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.logService.error(error);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Main process server (electron IPC based)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; mainProcessElectronServer = &lt;span&gt;new&lt;/span&gt; ElectronIPCServer();&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.lifecycleMainService.onWillShutdown(&lt;span&gt;&lt;span&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (e.reason === ShutdownReason.KILL) {&lt;br/&gt;    &lt;span&gt;// When we go down abnormally, make sure to free up&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// any IPC we accept from other windows to reduce&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// the chance of doing work after we go down. Kill&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// is special in that it does not orderly shutdown&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// windows.&lt;/span&gt;&lt;br/&gt;    mainProcessElectronServer.dispose();&lt;br/&gt;   }&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Resolve unique machine ID&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.logService.trace(&lt;span&gt;&#x27;Resolving machine identifier...&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; machineId = &lt;span&gt;await&lt;/span&gt; resolveMachineId(&lt;span&gt;this&lt;/span&gt;.stateService);&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.logService.trace(&lt;span&gt;`Resolved machine identifier: &lt;span&gt;${machineId}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Shared process&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { sharedProcess, sharedProcessReady, sharedProcessClient } = &lt;span&gt;this&lt;/span&gt;.setupSharedProcess(machineId);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Services&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; appInstantiationService = &lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.initServices(machineId, sharedProcess, sharedProcessReady);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Auth Handler&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;._register(appInstantiationService.createInstance(ProxyAuthHandler));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Transient profiles handler&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;._register(appInstantiationService.createInstance(UserDataProfilesHandler));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Init Channels&lt;/span&gt;&lt;br/&gt;  appInstantiationService.invokeFunction(&lt;span&gt;&lt;span&gt;accessor&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.initChannels(accessor, mainProcessElectronServer, sharedProcessClient));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Setup Protocol URL Handlers&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; initialProtocolUrls = appInstantiationService.invokeFunction(&lt;span&gt;&lt;span&gt;accessor&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.setupProtocolUrlHandlers(accessor, mainProcessElectronServer));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Signal phase: ready - before opening first window&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.lifecycleMainService.phase = LifecycleMainPhase.Ready;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Open Windows&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; appInstantiationService.invokeFunction(&lt;span&gt;&lt;span&gt;accessor&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.openFirstWindow(accessor, initialProtocolUrls));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Signal phase: after window open&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.lifecycleMainService.phase = LifecycleMainPhase.AfterWindowOpen;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Post Open Windows Tasks&lt;/span&gt;&lt;br/&gt;  appInstantiationService.invokeFunction(&lt;span&gt;&lt;span&gt;accessor&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.afterWindowOpen(accessor, sharedProcess));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Set lifecycle phase to `Eventually` after a short delay and when idle (min 2.5sec, max 5sec)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; eventuallyPhaseScheduler = &lt;span&gt;this&lt;/span&gt;._register(&lt;span&gt;new&lt;/span&gt; RunOnceScheduler(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;._register(runWhenIdle(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.lifecycleMainService.phase = LifecycleMainPhase.Eventually, &lt;span&gt;2500&lt;/span&gt;));&lt;br/&gt;  }, &lt;span&gt;2500&lt;/span&gt;));&lt;br/&gt;  eventuallyPhaseScheduler.schedule();&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;setup&lt;/code&gt;主要做了以下几件事情：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;记录应用程序的启动参数和应用程序根路径等信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建 Electron IPC 服务器。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建共享进程，并等待共享进程准备就绪。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注册代理认证和用户数据配置处理程序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;初始化通信通道。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置协议 URL 处理程序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;打开第一个窗口。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行打开窗口后的任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，等待一段时间，将应用程序的生命周期状态设置为 &lt;code&gt;Eventually&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里包含了VSCode启动的关键步骤，其中&lt;code&gt;IPC&lt;/code&gt;和&lt;code&gt;Channel&lt;/code&gt;、共享进程、窗口机制，都是非常重要的服务，限于篇幅，我们在后面的系列中进行展开分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后来看看打开窗口的实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;private &lt;span&gt;async&lt;/span&gt; openFirstWindow(accessor: ServicesAccessor, &lt;span&gt;initialProtocolUrls&lt;/span&gt;: IInitialProtocolUrls | &lt;span&gt;undefined&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;ICodeWindow[]&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; windowsMainService = &lt;span&gt;this&lt;/span&gt;.windowsMainService = accessor.get(IWindowsMainService);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; context = isLaunchedFromCli(process.env) ? OpenContext.CLI : OpenContext.DESKTOP;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; args = &lt;span&gt;this&lt;/span&gt;.environmentMainService.args;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// First check for windows from protocol links to open&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (initialProtocolUrls) {&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// Openables can open as windows directly&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (initialProtocolUrls.openables.length &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; windowsMainService.open({&lt;br/&gt;     context,&lt;br/&gt;     &lt;span&gt;cli&lt;/span&gt;: args,&lt;br/&gt;     &lt;span&gt;urisToOpen&lt;/span&gt;: initialProtocolUrls.openables,&lt;br/&gt;     &lt;span&gt;gotoLineMode&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;     &lt;span&gt;initialStartup&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;// remoteAuthority: will be determined based on openables&lt;/span&gt;&lt;br/&gt;    });&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// Protocol links with `windowId=_blank` on startup&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// should be handled in a special way:&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// We take the first one of these and open an empty&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// window for it. This ensures we are not restoring&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// all windows of the previous session.&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// If there are any more URLs like these, they will&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// be handled from the URL listeners installed later.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (initialProtocolUrls.urls.length &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; protocolUrl &lt;span&gt;of&lt;/span&gt; initialProtocolUrls.urls) {&lt;br/&gt;     &lt;span&gt;const&lt;/span&gt; params = &lt;span&gt;new&lt;/span&gt; URLSearchParams(protocolUrl.uri.query);&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (params.get(&lt;span&gt;&#x27;windowId&#x27;&lt;/span&gt;) === &lt;span&gt;&#x27;_blank&#x27;&lt;/span&gt;) {&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// It is important here that we remove `windowId=_blank` from&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// this URL because here we open an empty window for it.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;      params.delete(&lt;span&gt;&#x27;windowId&#x27;&lt;/span&gt;);&lt;br/&gt;      protocolUrl.originalUrl = protocolUrl.uri.toString(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;      protocolUrl.uri = protocolUrl.uri.with({ &lt;span&gt;query&lt;/span&gt;: params.toString() });&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; windowsMainService.open({&lt;br/&gt;       context,&lt;br/&gt;       &lt;span&gt;cli&lt;/span&gt;: args,&lt;br/&gt;       &lt;span&gt;forceNewWindow&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;forceEmpty&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;gotoLineMode&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;initialStartup&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;// remoteAuthority: will be determined based on openables&lt;/span&gt;&lt;br/&gt;      });&lt;br/&gt;     }&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; macOpenFiles: string[] = (&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt;&lt;/span&gt;global).macOpenFiles;&lt;br/&gt;  const hasCliArgs = args._.length;&lt;br/&gt;  const hasFolderURIs = !!args[&#x27;folder-uri&#x27;];&lt;br/&gt;  const hasFileURIs = !!args[&#x27;file-uri&#x27;];&lt;br/&gt;  const noRecentEntry = args[&#x27;skip-add-to-recently-opened&#x27;] === true;&lt;br/&gt;  const waitMarkerFileURI = args.wait &amp;amp;&amp;amp; args.waitMarkerFilePath ? URI.file(args.waitMarkerFilePath) : undefined;&lt;br/&gt;  const remoteAuthority = args.remote || undefined;&lt;br/&gt;  const forceProfile = args.profile;&lt;br/&gt;  const forceTempProfile = args[&#x27;profile-temp&#x27;];&lt;br/&gt;&lt;br/&gt;  // Started without file/folder arguments&lt;br/&gt;  if (!hasCliArgs &amp;amp;&amp;amp; !hasFolderURIs &amp;amp;&amp;amp; !hasFileURIs) {&lt;br/&gt;&lt;br/&gt;   // Force new window&lt;br/&gt;   if (args[&#x27;new-window&#x27;] || forceProfile || forceTempProfile) {&lt;br/&gt;    return windowsMainService.open({&lt;br/&gt;     context,&lt;br/&gt;     cli: args,&lt;br/&gt;     forceNewWindow: true,&lt;br/&gt;     forceEmpty: true,&lt;br/&gt;     noRecentEntry,&lt;br/&gt;     waitMarkerFileURI,&lt;br/&gt;     initialStartup: true,&lt;br/&gt;     remoteAuthority,&lt;br/&gt;     forceProfile,&lt;br/&gt;     forceTempProfile&lt;br/&gt;    });&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   // mac: open-file event received on startup&lt;br/&gt;   if (macOpenFiles.length) {&lt;br/&gt;    return windowsMainService.open({&lt;br/&gt;     context: OpenContext.DOCK,&lt;br/&gt;     cli: args,&lt;br/&gt;     urisToOpen: macOpenFiles.map(path =&amp;gt; (hasWorkspaceFileExtension(path) ? { workspaceUri: URI.file(path) } : { fileUri: URI.file(path) })),&lt;br/&gt;     noRecentEntry,&lt;br/&gt;     waitMarkerFileURI,&lt;br/&gt;     initialStartup: true,&lt;br/&gt;     // remoteAuthority: will be determined based on macOpenFiles&lt;br/&gt;    });&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  // default: read paths from cli&lt;br/&gt;  return windowsMainService.open({&lt;br/&gt;   context,&lt;br/&gt;   cli: args,&lt;br/&gt;   forceNewWindow: args[&#x27;new-window&#x27;] || (!hasCliArgs &amp;amp;&amp;amp; args[&#x27;unity-launch&#x27;]),&lt;br/&gt;   diffMode: args.diff,&lt;br/&gt;   mergeMode: args.merge,&lt;br/&gt;   noRecentEntry,&lt;br/&gt;   waitMarkerFileURI,&lt;br/&gt;   gotoLineMode: args.goto,&lt;br/&gt;   initialStartup: true,&lt;br/&gt;   remoteAuthority,&lt;br/&gt;   forceProfile,&lt;br/&gt;   forceTempProfile&lt;br/&gt;  });&lt;br/&gt; }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这里是根据&lt;code&gt;vscode&lt;/code&gt;传入不同的协议参数而打开不同状态的窗口，&lt;code&gt;vscode&lt;/code&gt;本身是支持很多协议参数的，比如说空窗口、文件夹、文件、合并窗口等。至此，我们的启动流程就结束了（暂时不深入workbench相关的分析）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;VSCode启动过程中的性能优化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在vscode中，所有被&lt;code&gt;perf.mark&lt;/code&gt;标记的打点可以通过一个task来查看：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.14108352144469527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ta0Hx5vm0hMxAP2uxicHmm5H5H7JNGhic3dUJjYyDicc5PpeicaRac1oUZqW4NHmdT8MoRYnUjNxCm9MyUvhtKcacA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1772&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行这个task可以得到一份性能测试报告：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;System Info&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Code: 1.75.1 (441438abd1ac652551dbe4d408dfcec8a499b8bf)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OS: win32(10.0.22621)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPUs: Apple Silicon(4 x 3200)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Memory(System): 7.99 GB(4.74GB free)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Memory(Process): 234.50 MB working set(182.02MB private, 2.90MB shared)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VM(likelihood): 100%&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Initial Startup: true&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Has 1 other windows&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Screen Reader Active: false&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Empty Workspace: false&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Performance Marks&lt;/span&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;What&lt;/th&gt;&lt;th&gt;Duration&lt;/th&gt;&lt;th&gt;Process&lt;/th&gt;&lt;th&gt;Info&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;start =&amp;gt; app.isReady&lt;/td&gt;&lt;td&gt;139&lt;/td&gt;&lt;td&gt;[main]&lt;/td&gt;&lt;td&gt;initial startup: true&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;nls:start =&amp;gt; nls:end&lt;/td&gt;&lt;td&gt;92&lt;/td&gt;&lt;td&gt;[main]&lt;/td&gt;&lt;td&gt;initial startup: true&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;require(main.bundle.js)&lt;/td&gt;&lt;td&gt;132&lt;/td&gt;&lt;td&gt;[main]&lt;/td&gt;&lt;td&gt;initial startup: true&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;start crash reporter&lt;/td&gt;&lt;td&gt;29&lt;/td&gt;&lt;td&gt;[main]&lt;/td&gt;&lt;td&gt;initial startup: true&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;serve main IPC handle&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;[main]&lt;/td&gt;&lt;td&gt;initial startup: true&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;create window&lt;/td&gt;&lt;td&gt;53&lt;/td&gt;&lt;td&gt;[main]&lt;/td&gt;&lt;td&gt;initial startup: true, state: 0ms, widget: 53ms, show: 0ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;app.isReady =&amp;gt; window.loadUrl()&lt;/td&gt;&lt;td&gt;235&lt;/td&gt;&lt;td&gt;[main]&lt;/td&gt;&lt;td&gt;initial startup: true&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;window.loadUrl() =&amp;gt; begin to require(workbench.desktop.main.js)&lt;/td&gt;&lt;td&gt;285&lt;/td&gt;&lt;td&gt;[main-&amp;gt;renderer]&lt;/td&gt;&lt;td&gt;NewWindow&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;require(workbench.desktop.main.js)&lt;/td&gt;&lt;td&gt;244&lt;/td&gt;&lt;td&gt;[renderer]&lt;/td&gt;&lt;td&gt;cached data: YES, node_modules took 0ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;wait for window config&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;[renderer]&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;init storage (global &amp;amp; workspace)&lt;/td&gt;&lt;td&gt;17&lt;/td&gt;&lt;td&gt;[renderer]&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;init workspace service&lt;/td&gt;&lt;td&gt;46&lt;/td&gt;&lt;td&gt;[renderer]&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;register extensions &amp;amp; spawn extension host&lt;/td&gt;&lt;td&gt;939&lt;/td&gt;&lt;td&gt;[renderer]&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;restore viewlet&lt;/td&gt;&lt;td&gt;45&lt;/td&gt;&lt;td&gt;[renderer]&lt;/td&gt;&lt;td&gt;workbench.view.explorer&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;restore panel&lt;/td&gt;&lt;td&gt;36&lt;/td&gt;&lt;td&gt;[renderer]&lt;/td&gt;&lt;td&gt;terminal&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;restore &amp;amp; resolve visible editors&lt;/td&gt;&lt;td&gt;293&lt;/td&gt;&lt;td&gt;[renderer]&lt;/td&gt;&lt;td&gt;1: workbench.editors.files.fileEditorInput&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;overall workbench load&lt;/td&gt;&lt;td&gt;563&lt;/td&gt;&lt;td&gt;[renderer]&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;workbench ready&lt;/td&gt;&lt;td&gt;1528&lt;/td&gt;&lt;td&gt;[main-&amp;gt;renderer]&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;renderer ready&lt;/td&gt;&lt;td&gt;874&lt;/td&gt;&lt;td&gt;[renderer]&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;shared process connection ready&lt;/td&gt;&lt;td&gt;1038&lt;/td&gt;&lt;td&gt;[renderer-&amp;gt;sharedprocess]&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extensions registered&lt;/td&gt;&lt;td&gt;2311&lt;/td&gt;&lt;td&gt;[renderer]&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时间的计算方法，我们可以在&lt;code&gt;workbench/contrib/performance/browser/previewEditor&lt;/code&gt;和&lt;code&gt;workbench/services/timer/browser/timerService&lt;/code&gt;中看到：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;private &lt;span&gt;async&lt;/span&gt; _computeStartupMetrics(): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;IStartupMetrics&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; initialStartup = &lt;span&gt;this&lt;/span&gt;._isInitialStartup();&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; startMark: string;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (isWeb) {&lt;br/&gt;   startMark = &lt;span&gt;&#x27;code/timeOrigin&#x27;&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   startMark = initialStartup ? &lt;span&gt;&#x27;code/didStartMain&#x27;&lt;/span&gt; : &lt;span&gt;&#x27;code/willOpenNewWindow&#x27;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; activeViewlet = &lt;span&gt;this&lt;/span&gt;._paneCompositeService.getActivePaneComposite(ViewContainerLocation.Sidebar);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; activePanel = &lt;span&gt;this&lt;/span&gt;._paneCompositeService.getActivePaneComposite(ViewContainerLocation.Panel);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; info: Writeable&amp;lt;IStartupMetrics&amp;gt; = {&lt;br/&gt;   &lt;span&gt;version&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;ellapsed&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(startMark, &lt;span&gt;&#x27;code/didStartWorkbench&#x27;&lt;/span&gt;),&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// reflections&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;isLatestVersion&lt;/span&gt;: &lt;span&gt;Boolean&lt;/span&gt;(&lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._updateService.isLatestVersion()),&lt;br/&gt;   &lt;span&gt;didUseCachedData&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._didUseCachedData(),&lt;br/&gt;   &lt;span&gt;windowKind&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._lifecycleService.startupKind,&lt;br/&gt;   &lt;span&gt;windowCount&lt;/span&gt;: &lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._getWindowCount(),&lt;br/&gt;   &lt;span&gt;viewletId&lt;/span&gt;: activeViewlet?.getId(),&lt;br/&gt;   &lt;span&gt;editorIds&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._editorService.visibleEditors.map(&lt;span&gt;&lt;span&gt;input&lt;/span&gt; =&amp;gt;&lt;/span&gt; input.typeId),&lt;br/&gt;   &lt;span&gt;panelId&lt;/span&gt;: activePanel ? activePanel.getId() : &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// timers&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;timers&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;ellapsedAppReady&lt;/span&gt;: initialStartup ? &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/didStartMain&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/mainAppReady&#x27;&lt;/span&gt;) : &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;ellapsedNlsGeneration&lt;/span&gt;: initialStartup ? &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willGenerateNls&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didGenerateNls&#x27;&lt;/span&gt;) : &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;ellapsedLoadMainBundle&lt;/span&gt;: initialStartup ? &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willLoadMainBundle&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didLoadMainBundle&#x27;&lt;/span&gt;) : &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;ellapsedCrashReporter&lt;/span&gt;: initialStartup ? &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willStartCrashReporter&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didStartCrashReporter&#x27;&lt;/span&gt;) : &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;ellapsedMainServer&lt;/span&gt;: initialStartup ? &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willStartMainServer&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didStartMainServer&#x27;&lt;/span&gt;) : &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;ellapsedWindowCreate&lt;/span&gt;: initialStartup ? &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willCreateCodeWindow&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didCreateCodeWindow&#x27;&lt;/span&gt;) : &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;ellapsedWindowRestoreState&lt;/span&gt;: initialStartup ? &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willRestoreCodeWindowState&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didRestoreCodeWindowState&#x27;&lt;/span&gt;) : &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;ellapsedBrowserWindowCreate&lt;/span&gt;: initialStartup ? &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willCreateCodeBrowserWindow&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didCreateCodeBrowserWindow&#x27;&lt;/span&gt;) : &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;ellapsedWindowMaximize&lt;/span&gt;: initialStartup ? &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willMaximizeCodeWindow&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didMaximizeCodeWindow&#x27;&lt;/span&gt;) : &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;ellapsedWindowLoad&lt;/span&gt;: initialStartup ? &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/mainAppReady&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/willOpenNewWindow&#x27;&lt;/span&gt;) : &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;ellapsedWindowLoadToRequire&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willOpenNewWindow&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/willLoadWorkbenchMain&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedRequire&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willLoadWorkbenchMain&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didLoadWorkbenchMain&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedWaitForWindowConfig&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willWaitForWindowConfig&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didWaitForWindowConfig&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedStorageInit&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willInitStorage&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didInitStorage&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedSharedProcesConnected&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willConnectSharedProcess&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didConnectSharedProcess&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedWorkspaceServiceInit&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willInitWorkspaceService&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didInitWorkspaceService&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedRequiredUserDataInit&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willInitRequiredUserData&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didInitRequiredUserData&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedOtherUserDataInit&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willInitOtherUserData&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didInitOtherUserData&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedExtensions&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willLoadExtensions&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didLoadExtensions&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedEditorRestore&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willRestoreEditors&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didRestoreEditors&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedViewletRestore&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willRestoreViewlet&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didRestoreViewlet&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedPanelRestore&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willRestorePanel&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didRestorePanel&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedWorkbench&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/willStartWorkbench&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didStartWorkbench&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedExtensionsReady&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(startMark, &lt;span&gt;&#x27;code/didLoadExtensions&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;ellapsedRenderer&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._marks.getDuration(&lt;span&gt;&#x27;code/didStartRenderer&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;code/didStartWorkbench&#x27;&lt;/span&gt;)&lt;br/&gt;   },&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// system info&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;platform&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;release&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;arch&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;totalmem&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;freemem&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;meminfo&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;cpus&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;loadavg&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;isVMLikelyhood&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;   initialStartup,&lt;br/&gt;   &lt;span&gt;hasAccessibilitySupport&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._accessibilityService.isScreenReaderOptimized(),&lt;br/&gt;   &lt;span&gt;emptyWorkbench&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;._contextService.getWorkbenchState() === WorkbenchState.EMPTY&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._extendStartupInfo(info);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; info;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的数据是我分配了4核8G的Windows虚拟机的数据，可以看到整个workbench的ready花了1528ms的时间，在这个配置的Windows机器上，可以说vscode已经在启动性能上做的十分出色了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;VSCode启动流程做了哪些性能优化&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;减少IO操作&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在启动过程中，如果进行大量的磁盘读写，会严重影响到启动性能。因此VSCode启用了&lt;code&gt;BufferLog&lt;/code&gt;的机制，把日志缓存在内存中的一个 Buffer 中，等到 Buffer 被写满了，或者过了一定时间间隔，才会将缓存中的日志写入到磁盘中的文件中。这种机制可以减少频繁的磁盘写入，提高性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主进程的入口中，我们会发现它创建了这个实例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Logger&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; loggerService = &lt;span&gt;new&lt;/span&gt; LoggerMainService(getLogLevel(environmentMainService));&lt;br/&gt;  services.set(ILoggerMainService, loggerService);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Log: We need to buffer the spdlog logs until we are sure&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// we are the only instance running, otherwise we&#x27;ll have concurrent&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// log file access on Windows (https://github.com/microsoft/vscode/issues/41218)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; bufferLogger = &lt;span&gt;new&lt;/span&gt; BufferLogger(loggerService.getLogLevel());&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; logService = disposables.add(&lt;span&gt;new&lt;/span&gt; LogService(bufferLogger, [&lt;span&gt;new&lt;/span&gt; ConsoleMainLogger(loggerService.getLogLevel())]));&lt;br/&gt;  services.set(ILogService, logService);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;延迟加载与Idle Until Urgent&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Idle Until Urgent这个概念源自于https://philipwalton.com/articles/idle-until-urgent/这篇文章，作者比较深入地分析了启动时加载性能和延迟加载策略的探讨，全部同步执行以及全部延迟加载都是在走极端，最好的方式是在将一些可被延迟的任务放在idle周期中去处理，在使用时能够尽可能快地拿到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是VScode的一个实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IdleValue&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; private readonly _executor: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt; private readonly _handle: IDisposable;&lt;br/&gt;&lt;br/&gt; private _didRun: boolean = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt; private _value?: T;&lt;br/&gt; private _error: unknown;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;(executor: () =&amp;gt; T) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;._executor = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;._value = executor();&lt;br/&gt;   } &lt;span&gt;catch&lt;/span&gt; (err) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;._error = err;&lt;br/&gt;   } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;._didRun = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;._handle = runWhenIdle(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._executor());&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; dispose(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;._handle.dispose();&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;get&lt;/span&gt; value(): T {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;._didRun) {&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;._handle.dispose();&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;._executor();&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;._error) {&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._error;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._value!;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;get&lt;/span&gt; isInitialized(): boolean {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._didRun;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;code&gt;runWhenIdle&lt;/code&gt;实际上是&lt;code&gt;requestIdleCallback&lt;/code&gt;的polyfill，如果不支持&lt;code&gt;requestIdleCallback&lt;/code&gt;，会退化为&lt;code&gt;setTimeout0&lt;/code&gt;，而&lt;code&gt;setTimeout0&lt;/code&gt;也是一种Polyfill，在支持&lt;code&gt;postMessage&lt;/code&gt;的情况下会使用&lt;code&gt;message&lt;/code&gt;回调以获得在nextTick的尽快执行，这些细节在这里就不进一步展开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在VSCode中，依赖注入的延迟机制正是通过IdleValue来实现的，整个实例对象其实是一个Proxy，可以理解为getter调用时和IdleValue启动时的竞速，如果在Idle周期内能够初始化，则可以拿到实例对象，否则就在getter时机再去初始化，这样能够保证主线程的最大性能，将时间分片交给更需要的任务来做。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;打包与压缩&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前详细分析了VSCode的AMD加载机制，实际上VSCode通过gulp将源代码进行了bundle和压缩，在主进程加载的时候避免了磁盘的多次读写，其实小文件磁盘读写会带来比较大的性能损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个实践可以在VSCode这次Talk中看到：https://www.youtube.com/watch?v=r0OeHRUCCb4：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5615696887686062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ta0Hx5vm0hMxAP2uxicHmm5H5H7JNGhic3koq5IlhYWFVSHNstsiaPXKMu6rjo4AECQdnMSpuEicy32v14ShcWkgVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1478&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到在Bundle和Minify之后，性能提速了近400ms，效果显著。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文通过对VSCode源码架构的梳理，重点探索了VSCode的启动流程，深入介绍了VSCode启动时所使用的技术和优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在VSCode的启动流程中，通过合理的使用依赖注入的Lazy Load和懒解析，大大缩短了启动时间。同时，VSCode还采用了ThrottledDelayer等技术，实现了Idle Until Urgent的特性，提高了用户体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，VSCode还通过BufferLogger等技术减少了IO操作，提升了启动速度和性能表现。在日志系统方面，VSCode使用ILoggerMainService和ILogService来进行日志记录，分别负责记录和输出日志信息，提高了系统的可维护性和可扩展性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说，VSCode的启动流程还是十分庞大和复杂的，虽然有着自己的技术债，但在measure和细节的优化方面，vscode有很多值得我们学习的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借用vscode分享的三句话来完成本文的小结，所谓的性能优化，无非就是在重复这样的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.436241610738255&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ta0Hx5vm0hMxAP2uxicHmm5H5H7JNGhic3cAgicHGfkFZ7Xka7WEwzmLyPF8eZQvYLJRXdicAMtcI2Syy6Lo8FIMnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1192&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>