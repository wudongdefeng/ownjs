<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>99d6451ffc372b98d6260ded8ff0ffe1</guid>
<title>2022下半年《软考-系统架构设计师》备考经验分享</title>
<link>https://toutiao.io/k/x5wunvt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6qtpUicKafdEOLib6cjO9Y3EuyQfDIARRMItv9ia1ficGBdUcpmSqDDEBuVj2g0QUsgWG6ib8MeM8zcVicV5yTj1O1IQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我参加了2022年11月份的《软考-系统架构设计师》考试，在一个多月的备考之中我总结了一些学习经验和答题技巧，现毫无保留的分享给大家，希望对报考的同学们有所帮助。彩蛋：关注我的公众号【劼哥舍】，回复“软考”即可获取我精心整理的学习资源。祝愿所有报考的同学们都逢考必过~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、为什么考&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软考，全称&lt;strong&gt;「计算机技术与软件专业技术资格（水平）考试」&lt;/strong&gt;，是由国家人力资源和社会保障部、工业和信息化部领导下的国家级考试，其目的是科学、公正地对全国计算机与软件专业技术人员进行职业资格、专业技术资格认定和专业技术水平测试。详细介绍可参见官网：www.ruankao.org.cn。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获得软考高级证书的好处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「职称评选」&lt;/strong&gt;：属于高级从业资格证，类似于注册会计师，此证书在国企和事业单位可以评职称（在互联网公司可能没用）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「积分落户」&lt;/strong&gt;：通过此证书评定高级职称后，可以以人才引进方式获得工作所在城市的户口，或者积分入户有加分；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「项目竞标」&lt;/strong&gt;：项目竞标是要看资质的，高级证书可以为公司投标加分；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「抵扣个税」&lt;/strong&gt;：拿证书的当年，可以一次性定额抵扣3600块钱的所得税；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我自己为什么参加软考呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「个人成长」&lt;/strong&gt;：通过备考，体系化的温习架构设计相关基础知识，实现一定程度的自我提升；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「免费培训」&lt;/strong&gt;：公司专门请了软考培训机构，每周组织两次内部培训和学习，备考更加轻松；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「小赚一笔」&lt;/strong&gt;：如果能拿到证书，拿证当年可以直接减税3600大洋，这可是国家实实在在补贴的真金白银啊~&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、要选哪科&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，软考有3个级别5个专业，很多同学在报名的时候不知道如何选择科目。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44731404958677684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6qtpUicKafdEOLib6cjO9Y3EuyQfDIARRMzJ3OCqyjGLAp9PaBe7BjonCwYzaxLoFpEicGFgXMYAUDL75QNu3ayZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;968&quot;/&gt;软考高级比中级的难度要大一些。中级考试为基础知识和应用技术两科，各科目考试时间均为2.5小时。高级考试主要多了论文，考试时间为2小时（将近要写3000字）。合格标准是各个科目都要求在45分以上(含45分)。中级合格率约为20-30%，高级合格率不到20%。我的建议是：不要报考初级，因为参加软考没有任何的门槛限制，没有必要一步一步考；中级和高级具体报哪一个，按个人技术储备的实际情况来选择，IT基础差一点的同学可以报项目管理方向。有3~5年后端经验的同学可以尝试高级资格，因为写论文还是需要一定的项目经验的积累。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、如何备考&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我自己报考的是系统架构设计师，下面主要介绍系统架构设计师的备考方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、核心考点及复习建议&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 计算机基础知识（20%)&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于计算机类科班的同学来说，这一部分主要就是在学校里学习的内容，主要包括：计算机组成与体系结构（计算机组成、指令系统、流水线技术、存储体系、总线等）、操作系统（进程与PV操作、存储管理、设备管理、文件管理等）、数据库系统（设计范式、关系代数、SQL、数据架构、并发控制等）、计算机网络（常见网络设备、常用协议、组网方式等）、嵌入式系统（嵌入式操作系统、多核处理等），每个部分基本就是学校里面所学知识的简化版。针对这一部分，有科班基础的同学可以看视频1.5倍速复习一轮，题目大部分就是送分题；如果是没有基础的同学，最好跟着视频多学几遍，这些都是程序员安家立命的根本。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 软件工程（25%）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一部分是很枯燥的理论性内容，主要包括：软件开发生命周期、软件开发过程模型（瀑布模型、螺旋模型、原型模型等）、需求管理、开发管理、软件系统设计 （易用性设计、设计模式）、软件系统建模（结构化设计、UML）、软件系统构建、软件测试（黑盒、白盒、回归、单元、集成、路径覆盖等）、项目管理 （关键路径）。其中，系统建模很可能会在案例分析题中出现。这一部分的概念枯燥并且不好记忆，建议反复观看资料学习。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 系统架构设计（35%）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一部分是系统架构师这个科目考察内容的重中之重，无论是选择题，还是案例分析题，还是论文，都会涉及该部分的内容。这一部分首先引出了软件架构的定义，紧接着讲如何从多个维度评价一个软件架构设计（质量属性、软件质量评估方法），为了达到软件系统设计的预期标准，如何通过一些架构模式（或叫架构风格）来实现整个架构的设计。并额外列举了一些派生的架构模式和现实系统中的架构设计案例，如MVC、 微服务架构、常用中间件等。这一部分的内容最少完整学习一遍，深刻理解每个章节的内容。这一部分很重要，很重要，很重要！这一部分除了固定题型的送分题，还有很发散的开放式问答。看完这一部分的内容，也基本上就知道怎么写论文了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4 信息化战略与规划 (9%）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一部分内容都是概念性并且十分抽象，主要涉及到企业信息化需要做什么怎么做。比如，企业内外部有信息系统的类型的信息系统，它们之间是如何进行系统集成的，如何进行系统迁移和系统迭代，信息系统如何支撑企业的发展，如何建设电子商务等。信息系统如何服务企业、个人、政府，这些概念虽然很抽象，但我认为这也是一个系统架构师应该掌握的知识，它站在一个宏观的视角回答了“为什么要做信息化、智能化”。这一部分建议深度学习，因为在论文中写项目的背景、价值的时候可能也会用到，要深刻理解之后再开始刷题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.5 信息安全&amp;amp;法律常识（5%)&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一部分内容是信息安全和法律常识的基础内容，信息安全包括：基础密码学（对称、非对称加解密、数字签名)、常用身份认证方案设计、访门控制方案设计、系统安全性设计等内容；法律常识包括：著作权、专利、商标、商业机密等概念，在选择题和论文中可能也会用到这一部分的知识点。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.6 数学&amp;amp;逻辑&amp;amp;英语 (6%)&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一部分内容是作为程序员最基本的要求，如果数学和逻辑不好，很难写出逻辑清晰工整优雅的代码。数学一般考离散数学、运筹学里面的东西，比如高考考过的线性规划、大学学过的图论，一般在考场上都能硬算出来，这一部分不建议复习，直接刷真题，边刷边了解一些算法。英语主要是计算机和软件的专业英语，会以5道完形填空的形式出现，英语很难在短时间内提高，只能鹏鹏运气了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、题型解析及解题技巧&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个考试分三个题型：选择题、案例题、论文题，每种题型一场考试，一天内考完。上午考选择题，下午考案例分析和论文。每种题型满分都为75分，达到45分及以上算合格。由于是资格性考试，而且通过后不区分等级，因此合格万岁。这个考试很大的一个难点，在于三个题型的分数要同时达到45分及以上。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 选择题&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考试时间120分钟，75道四选一单项选择题，每道题1分，主要考上面提到的知识点。解题技巧如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;直接选择法：对题中给出的4个选项，一看就能肯定其中的一个是正确的，可以直接得出正确选项。注意，必须有百分之百的把握才行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排除选择法：对题中给出的4个选项，一看就知其中的一个(或2个、3个)是错误的，在这种情况下，可以使用排除法，即排除错误的选项，剩下的为正确答案。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;估计选择法：在排除法中，如果最后还剩2个可能的选项，而对某题却一无所知时，也别放弃选择，在剩下的选项中随机选一个。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;因为选错了不扣分，所以选择题不要漏选，即使不能完全确定正确答案，每题也要都选出一个选项。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注意：对于有把握的题目要保证一次答对，不要想再次验证。对于吃不准的题目，可以根据经验先初步确定一个答案，做一个标记。在时间允许的情况下，可以回过头来重做这些做了标记的题目。切记不要在个别题上花费太多的时间，以免到最后没有时间完成剩余的题目。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 案例题&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考试时间90分钟，主要是问答题和填空题，总共五道大题，每道大题25分，第一题必答，二到五题四选二，选定的三题一共75分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一道大题比较固定，一般是软件架构评估。二到五题中，固定会有一道题是嵌入式系统设计（建议非嵌入式从业者直接放弃），除此之外还会有以下题型：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;软件系统建模（UML图填空、问答）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统数据库设计（DFD图填空、问答）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统架构整体设计（表格填空、架构图填空、问答）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Web系统架构设计（表格填空、架构图填空、问答）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单个场景详细设计：高可用设计、高性能设计、高可靠设计、微服务设计、可扩展性设计等（表格填空、架构图填空、问答）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中问答题一般有两种问法，一是概念问答类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;请说明什么是xxx，并指出它的作用与特点；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请说明A和B两种设计模式的区别和联系；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二是方案分析与选择类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;请指出选用xxx技术方案存在的问题，限200字以内；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项自组最终使用了xxx技术方案，请分析采用xxx技术方案的原因；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请分析N种技术方案的优势和劣势/适用场景，并确定使用哪个技术方案；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 论文题&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考试时间120分钟，考试形式是给出4道论文题目，只需要选其中一道题目来写，两个小时，手写在类似高考语文作文的答题卡上，摘要部分一般要写200字以上，正文部分一般要写2000字以上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;论文是软考高级中经常出现不合格的题型，不过只要你有实际的工作经验，有一定的理论基础，再进行了认真的准备，达到45分合格线并不是一件很困难的事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常来讲，论文给出的4道题目里面，一般有一道是最近两年比较火热的技术，如云原生、无服务架构、区块链等。其它三道题的出题方向很固定，频次大致从高到低主要包括：软件系统架构设计（架构评估、架构风格、微服务架构等）、软件系统建模、信息系统规划与集成、软件质量保证、软件高性能设计、软件可用性设计、软件安全性设计、需求管理、项目管理等；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想拿下论文，就必须要深入的准备一个项目，—般是自己平时工作中做的系统，从全局的角度来梳理这个系统的方方面面，然后针对不同题目从不同角度来描绘这个系统就行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;论文的结构可以直接套用以下模板，不同的题材，结构和框架可以相同，只需要替换内容就好了。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;交代自己做了项目，自己是做什么的 （一般是架构师）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我在这个项目里面，用到了哪些与题目相关的技术&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目很成功，客户很满意，老板很开心&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;正文（一般要写2000字以上）：&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;我在什么公司工作，什么职位（100字左右，注意数据脱敏，敏感信息可以用某某代替）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我做了什么项目，业务背景和产品设计是怎么样的（300字左右，同样注意数据脱敏）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;说说题目里面的技术或概念是什么（作为论点，300字左右)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目中是怎么体现题目中的技术的（作为论据，也是整篇论文的主体部分，1000字左右，举2到4个例子）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目取得了怎么样的结果，有哪些细小的可以改进的点（结论，400字左右）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户很满意，老板很开心，感叹人生，赞颂社会 (结尾，100字左右）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、备考策略及学习资源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我主要的复习方式是视频学习＋真题训练+论文仿写。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 视频学习&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;视频主要用于掌握基础知识，附带一些练习题，以巩固知识点的记忆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上午的选择题，完整的刷过一遍视频，然后再刷个10来套选择题真题，如果分数能达到60分以上的话，选择题这块应该就比较稳妥了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下午的案例题，比选择题要难一些，有较多的概念手写，所以学习视频中明确提到的五星考点，都要背下来才行，这个背太早可能就忘记了，可以先背一轮有个印象，然后考前一周再集中记忆。另外也要配合多刷题，历年的真题都做一遍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我自己的视频资源是公司请的培训机构讲的线上直播，虽然这课程不花钱就能听，但质量真的一般。后来我又在网上找了一些视频资源，比公司课程强太多，大家关注我微信公众号【劼哥舍】，回复“软考”即可获取我精心整理的学习资源。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 真题训练&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习完视频之后，就要拿分类练习题和真题来训练，在训练的过程中如发现模棱两可的知识点，可以再去反复刷视频的某个章节，力争把每个知识点都记住，软考需要记的概念性知识点还不少，特别是下午的案例题和论文，必须需要写出来大段准确概念或者某个架构方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刷题的话我推荐用&lt;strong&gt;「软考通APP」&lt;/strong&gt;，安卓和苹果都有同款APP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有历年真题、模拟测验、智能练习等功能，让我们非常灵活利用碎片时间来刷题。还有错题集、收藏夹等功能，让我们能够针对部分不熟悉或经常出错的知识点重点复习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过该APP也有2个问题，一是真题只更新到了19年（可以配合上面学习资料一起用），二是偶尔会弹广告（可以手动关闭不会强制看完），已经算是一款良心的学习APP，如果APP的作者能把最近两年的真题也更新进去就太完美了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7226666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6qtpUicKafdEOLib6cjO9Y3EuyQfDIARRMGrlxfk5W7FokavfuqaLuDhwibAlS0v8jRXD4mnXYZX7XibKy3cp7bQww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 论文仿写&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于论文的准备，建议先多看看别人的论文，然后自己至少仿写三篇不同主题的论文，重点写架构设计方向的主题，最后再准备一篇近期流行的技术，比如：云原生、区块链、Web3等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2个小时的论文书写时间非常紧张，如果没有经过考前特训，很多同学2个小时2500字抄都抄不完，更不要谈临场发挥直接写。所以每篇论文框架（摘要、开头、结尾）必须能熟练默写，要做到这3部分完全不用思考，提笔就能写至少800字，那么两千字的正文，你真正需要边思考边书写的内容就只有1200字，然后再把你准备的项目经验，结合题干套进正文里就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别需要注意的是，大家练习论文一定要拿格子本或者把答题卡打印出来练习，这样你才能习惯在答题卡上写字的感觉，避免临场书写习惯问题而手忙脚乱。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 我的经历&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始准备的时候，我觉得自己有点基础，没有复习就直接做了一套选择题的模拟题，结果惨不忍睹只拿了30多分。完整的做过一套真题才知道，选择题里陌生的知识点和概念特别多，如果不复习直接做的话，估计大部分题目都只能靠猜，后面就老老实实的开始刷视频来补基础。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;视频总时长在30个小时左右（除论文以外），我大概从9月下旬开始每天用上下班通勤时间1.5~2倍速刷视频，每天大概能看2个多小时，连着国庆假期一起把所有的视频全部刷完了。大家可以看到上图中的选择题刷题记录，从最开始的30分到能拿55分，这就是刷完视频的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;国庆之后就只剩不到一个月的备考时间（其中包含3个周末）。日常工作比较忙，抽不出大段的时间用来复习，只能拿通勤和休息时间来零碎做做选择题、翻翻错题集、背背不牢靠的知识点。然后充分利用周末，尽量推掉所有事情，完整的做一套选择题、案例题以及论文，然后针对错题进行复盘和针对性练习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在考试的前一周，我完整的练了2套选择题，按道理说选择题要练习到60分以后才比较稳妥，我自己训练得还不达标。作文又把摘要、开头、结尾专项练习了一遍，控制手写时间在半小时以内。然后刷了一些案例题查漏补缺，把不熟悉的知识点再背了背。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、考前必看&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、考前准备&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;前一天保证充分睡眠。睡眠不足的头脑里，充满了因疲倦而产生的不安的荷尔蒙。人的集中注意力是有限的。疲倦状态下熬夜用功，还不如聚精会神地学习一个小时的效果。考试前保持身体的最佳状态很重要。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下午的考试时间非常紧凑，第一场90分钟的案例题考完之后，休息20分钟（不允许出教室），紧接着就进入第二场120分钟的论文，整个下午连轴转非常消耗精力。建议中午至少小睡半小时，然后再两门考试之间喝一瓶红牛来保持精力。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以带个非电子表，防止考场没有钟，如果是在广州大学考的话，一般都会有电子钟。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、心态调整&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;进考场手机一定要关闭，免得被当成作弊嫌疑人。考试时不要有侥幸心理。网上有不少关于考试作弊的文章，千万不要信以为真，更不要以身试法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当遇到答不出来的题时，心里一定不要慌乱，可以把这类题留下暂时不做，先把会做的题做好，能做多少就做多少。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当题做得非常顺利时，心里不要太得意，因为越是看似容易的题目越是错的多，当然也不要逆向思维，觉得这题这么简单是不是做错了，要相信自己，说到底还是要审清题目的意思。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要受周围环境影响，当看到别人翻卷子时，觉得别人做了很多题，心里就开始着急，可以来点阿Q精神，也许是他不会做，先做下一页卷子呢。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当别人开始交卷时，也不要慌张，只要沉着冷静，认真回答每一个题目就可以了，千万不要感觉如果只剩下你一名考生多不好意思，因为监考人员是有责任陪你考完最后一分钟的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、答题注意&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;拿到答题卡第一件事儿是填涂好自己的姓名、准考证号等重要内容，然后再开始看题！注意：填涂都是用2B铅笔，而需要写字的地方一定要用墨水笔，千万别弄混。如果对填涂卡有什么不明白的地方，一定要举手问监考老师！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;答题顺序以有利于心态稳定为准。先易后难，先熟后生，稳扎稳打。而且一定要边答边填涂，不要等到最后一起涂！万一没时间了，你的客观题就没分了！记着，客观题的答案写在卷上是没分的，所以一定要填到答题卡！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;合理的安排时间。保证在能得分的地方绝不丢分，不易得分的地方争取得分。自己要时刻意识到，与其花十分钟去攻克一道分值为一分的选择题，不如花十分钟去攻克一道分值为十五分的大题。合理分配时间，才能最终取胜。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只要不扣分，尝试回答所有的问题，不要留下空白题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主观题答题的时候，如果发现错误，请不要使用涂改液等修改，因为阅卷老师可能会认为是在卷子上刻意做记号。如果发现错误，请用笔画个框圈起来，打个叉子即可，然后再找一块干净的地方重新写过，千万不要在原地改得乱七八糟！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;答题卡分两种，横版的和竖版的，所以不要和旁边的考生对题，作弊先不说，主要是答题卡不一样！只要填的时候按着题号填，就不会有问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;答题时尽量保持卷面整洁干净，老师改卷时不可能将无法辨认的试卷给高分，因为都看不清楚，当然也不会给高分。所以一定要注意卷面的书写工整。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、考完感想&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，来讲讲我自己这次考试的表现情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;选择题，考试的范围有点超出预期，虽然往年的真题我基本都刷了一遍，但还是有将近五分之一的题目是我完全没印象的（如鸿蒙操作系统的架构），学习群里的小伙伴在选择题上翻车的不在少数，我自己也没有太大把握选择题能过。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;案例题，第一题必选题是架构设计和质量属性相关的，比较容易写。第二题考的是数据流图和ER图，也还比较容易写。第三题是嵌入式直接跳过。第四题考的是数据库缓存技术，第五题考的是Web系统架构设计，这两题我都能写，第四题全是问答题可能答不准，第五题有填空题好答一点且分值更大，所以我选择了第五题作答。案例题我写得还比较顺利，也比较有把握。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;论文题，第一题是《基于构建的软件开发方法》，第二题是《论软件维护的方法及其应用》，第三题是《论区块链技术及应用》，第四题是《论湖仓一体架构及其应用》。我自己我准备过的题材有架构风格、架构评估、微服务架构，后面两题完全超纲了没法写，第一题ABSD我没有实际写过，整个ABSD的流程和具体步骤记不太清楚了，只能选第二题软件维护来写。因为是临场发挥的，所以花了较多的时间构思，导致后面时间很赶，算是卡着点凑够了字数，没有时间从头到尾整个通读一遍，感觉自己写得一般。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整体来讲，三门考试，案例题比较有把握，论文写得一般般，选择题不太行，这次考试不合格的概率较大，担心也没有用，老老实实等结果。如果这次没有过应该还会再考一次，毕竟准备过一次还算有点经验，下次备考也会更容易。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是我2022年备考系统架构设计师的全部过程，期望我的经验能带给大家一点帮助，最后祝愿所有报考软考的同学们逢考必过~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、引用参考&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;中国计算机职业技术资格网 https://www.ruankao.org.cn&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软考中级有用吗？https://www.zhihu.com/question/482212478&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软考应该如何选择合适的科目？https://zhuanlan.zhihu.com/p/494420154&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7c0781307af2c11d6f1a6d80958aa211</guid>
<title>初步探索 GraalVM：云原生时代 JVM 黑科技</title>
<link>https://toutiao.io/k/reuf2rd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h3&gt;1 云原生时代Java语言的困境&lt;/h3&gt;

&lt;p&gt;经过多年的演进，Java语言的功能和性能都在不断的发展和提高，诸如即时编译器、垃圾回收器等系统都能体现Java语言的优秀，但是想要享受这些功能带来的提升都需要一段时间的运行来达到最佳性能，总的来说Java是面向大规模、长时间使用的服务端应用而设计的。&lt;/p&gt;

&lt;p&gt;云原生时代，Java语言一次编译到处运行的优势不复存在，理论上使用容器化技术，所有语言都能部署上云，而无法脱离JVM的Java应用往往要面对JDK内存占用比应用本身还大的窘境；Java动态加载、卸载的特性也使得构建的应用镜像中有一半以上的无用代码和依赖这些都使得Java应用占用内存相当多。而启动时间长，性能达到峰值的时间长使得在Serverless等场景下无法与Go、Node.js等快速语言竞争。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/c8699532-ec69-4048-a43d-089487a16beb20220523153012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Java应用程序的运行生命周期示意图&lt;/p&gt;

&lt;h3&gt;2 GraalVM&lt;/h3&gt;

&lt;p&gt;面对云原生时代Java的不适，GraalVM或许是最好的解药。GraalVM是Oracle实验室推出的基于Java开发的开源高性能多语言运行时平台，它既可以在传统的 OpenJDK 上运行，也可以通过 AOT（Ahead-Of-Time）编译成可执行文件单独运行，甚至可以集成至数据库中运行。除此之外，它还移除了编程语言之间的边界，并且支持通过即时编译技术，将混杂了不同的编程语言的代码编译到同一段二进制码之中，从而实现不同语言之间的无缝切换。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/44f9fc49-0f83-4aa7-9637-a92e7b84257520220523153035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文主要简单从三个方面介绍GraalVM可以为我们带来的改变：&lt;/p&gt;

&lt;p&gt;1)基于Java的Graal Compiler的出现对学习和研究虚拟机代码编译技术有着不可估量的价值，相比C++编写的复杂无比的服务端编译器，不管是对编译器的优化还是学习的成本都大大的降低。&lt;br/&gt;
2)静态编译框架Substrate VM框架，为Java在云原生时代提供了与其他语言竞争的可能，大大的减少了Java应用占用内存，并且可以加快启动速度几十倍。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/e2c2e5bc-67ac-4a1f-8f85-38d559a7165420220523153055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3)以Truffle和Sulong为代表的中间语言解释器，开发者可以使用Truffle提供的API快速用Java实现一种语言的解释器，从而实现了在JVM平台上运行其他语言的效果，为Java世界带来了更多更有想象力的可能性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/80057bc7-0acc-44a4-b459-f599317573ba20220523153112.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
GraalVM多语言支持&lt;/p&gt;

&lt;h3&gt;3 GraalVM整体结构&lt;/h3&gt;

&lt;p&gt;graal&lt;br/&gt;
├── &lt;a href=&quot;http://CONTRIBUTING.md&quot;&gt;CONTRIBUTING.md&lt;/a&gt;&lt;br/&gt;
├── LICENSE&lt;br/&gt;
├── &lt;a href=&quot;http://README.md&quot;&gt;README.md&lt;/a&gt;&lt;br/&gt;
├── &lt;a href=&quot;http://SECURITY.md&quot;&gt;SECURITY.md&lt;/a&gt;&lt;br/&gt;
├── THIRD_PARTY_LICENSE.txt&lt;br/&gt;
├── bench-common.libsonnet&lt;br/&gt;
├── ci-resources.libsonnet&lt;br/&gt;
├── ci.hocon&lt;br/&gt;
├── ci.jsonnet&lt;br/&gt;
├── ci_includes&lt;br/&gt;
├── common-utils.libsonnet&lt;br/&gt;
├── common.hocon&lt;br/&gt;
├── common.json&lt;br/&gt;
├── common.jsonnet&lt;br/&gt;
├── compiler&lt;br/&gt;
├── docs&lt;br/&gt;
├── espresso&lt;br/&gt;
├── graal-common.json&lt;br/&gt;
├── java-benchmarks&lt;br/&gt;
├── regex&lt;br/&gt;
├── repo-configuration.libsonnet&lt;br/&gt;
├── sdk&lt;br/&gt;
├── substratevm&lt;br/&gt;
├── sulong&lt;br/&gt;
├── tools&lt;br/&gt;
├── truffle&lt;br/&gt;
├── vm&lt;br/&gt;
└── wasm&lt;/p&gt;

&lt;h4&gt;3.1 Compiler&lt;/h4&gt;

&lt;p&gt;Compiler子项目全称GraalVM编译器，是用Java语言编写的Java编译器。高编译效率、高输出质量、同时支持提前编译（AOT）和即时编译（JIT）、同时支持应用于包括HotSpot在内的不同虚拟机的编译器。&lt;/p&gt;

&lt;p&gt;与C2采用一样的中间表示形式（Sea of Nodes IR），后端优化上直接继承了大量来自于HotSpot的服务端编译器的高质量优化技术，是现在高校、研究院和企业编译研究实践的主要平台。&lt;/p&gt;

&lt;p&gt;Graal Compiler是GraalVM与HotSpotVM（从JDK10起）共同拥有的服务端即时编译器，是C2编译器未来的替代者。为了让 Java 虚拟机与编译器解耦，ORACLE引入了Java-Level JVM Compiler Interface(JVMCI)Jep 243 ：把编译器从虚拟机中抽离出来，并且可以通过接口与虚拟机交流（&lt;a href=&quot;https://openjdk.java.net/jeps/243%EF%BC%89&quot;&gt;https://openjdk.java.net/jeps/243）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/e30ce4ed-168f-4b1f-8bad-efcbf0e5c89e20220523153202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;具体来说，即时编译器与 Java 虚拟机的交互可以分为如下三个方面。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 响应编译请求；&lt;/li&gt;
&lt;li&gt; 获取编译所需的元数据（如类、方法、字段）和反映程序执行状态的 profile；&lt;/li&gt;
&lt;li&gt; 将生成的二进制码部署至代码缓存（code cache）里。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/404916e6-eb25-4664-b956-79533977fcb720220523153220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/8ed137af-c3f5-48b7-9d9f-db60a820aa8020220523153228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/04cacda7-a226-4c08-8be6-ed5b0e7df86120220523153238.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
oracle提供的编译时间差异示例&lt;/p&gt;

&lt;h4&gt;3.2 Substrate VM&lt;/h4&gt;

&lt;p&gt;Substrate VM提供了将Java程序静态编译为本地代码的编译工具链，包括了编译框架、静态分析工具、C++支持框架及运行时支持等。在程序运行前便将字节码转换为机器码&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 从指定的编译入口开始静态可达性分析，有效的控制了编译范围，解决了代码膨胀的问题；&lt;/li&gt;
&lt;li&gt; 实现了多种运行时优化例如：传统的java类是在第一次被用到时初始化的，之后每次调用时还要再检查是否初始化过，GraalVM将其优化为在编译时初始化；&lt;/li&gt;
&lt;li&gt; 无需在运行过程中耗费CPU资源来进行即时编译，而程序也能在启动一开始就达到理想的性能；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 静态分析是资源密集型计算，需要消耗大量CPU、内存和时间；&lt;/li&gt;
&lt;li&gt; 静态分析对反射、JNI、动态代理的分析能力非常有限，目前GraalVM只能通过额外配置的方式加以解决；&lt;/li&gt;
&lt;li&gt; Java序列化也有多项违反封闭性假设的动态特性：反射，JNI，动态类载入，目前GraalVM也需要通过额外配置解决，且不能处理所有序列化，例如Lambda对象的序列化，而且性能是JDK的一半；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/8b9fe70d-394a-413f-8b2a-0661e9de966420220523153524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/146bb0f6-922b-43c1-b103-6c5a61870d9820220523153535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;启动时长对比&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/52eccb3e-54ac-45b6-8145-5584c962262120220523153605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;占用内存对比&lt;/p&gt;

&lt;h4&gt;3.3 Truffle&lt;/h4&gt;

&lt;p&gt;我们知道一般编译器分为前端和后端，前端负责词法分析、语法分析、类型检查和中间代码生成，后端负责编译优化和目标代码生成。一种比较取巧的做法是将新语言编译成某种已知语言，如Scala、Kotlin可以编译成Java字节码，这样就可以直接享用JVM的JIT、GC等各项优化，这种做法都是针对的编译型语言。与之相对的，如JavaScript、Ruby、R、Python等解释型语言，它们依赖于解释执行器进行解析并执行，为了让这类解释型语言能够更高效的执行，开发人员通常需要开发虚拟机，并实现垃圾回收，即时编译等组件，让该语言在虚拟机中执行，如Google的V8引擎。如果能让这些语言也可以在JVM上运行并复用JVM的各种优化方案，将会减少许多重复造轮子的消耗。这也是Truffle项目的目标。&lt;/p&gt;

&lt;p&gt;Truffle是一个用Java编写的解释器实现框架。它提供了解释器的开发框架接口，可以帮助开发人员用Java为自己感兴趣的语言快速开发处语言解释器，目前已经实现并维护了JavaScript、Ruby、R、Python等语言。&lt;/p&gt;

&lt;p&gt;只需基于Truffle实现相关语言的词法分析器、语法分析器及针对语法分析所生成的抽象语法树（AST）的解释执行器，便可以运行在任何Java虚拟机上，享用JVM提供的各项运行时优化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/3bf7ab98-1d08-4ec6-857a-b372ef8b3b3320220523153644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;GraalVM多语言运行时性能加速比&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3.1 Partial Evaluation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Truffle的实现原理基于Partial Evaluation这一概念：假设程序prog为将输入转为输出&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/be74c015-469b-400d-a8a9-c3c6f05a5b2f20220523153742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其中Istatic为静态数据，在编译时已知常量，Idynamic为编译时未知数据，则可以将程序等价为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/c1c8c690-5a82-4c94-b668-4cd27535d2e220220523153754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;新程序prog_为prog的特化，他应该会比原程序更高效的执行，这个从prog转换到prog_的过程便称为Partial Evaluation。我们可以将Truffle预压的解释执行器当成prog，将某段由Truffle语言写的程序当做Istatic，并通过Partial Evaluation将prog转换到prog*。&lt;/p&gt;

&lt;p&gt;下面引用一个Oracle官方的例子来讲解，以下程序实现了读取参数以及参数相加的操作，需要实现读取三个参数相加：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/866697ec-1737-439e-b130-b72e5f7935a620220523153809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这段程序解析生成的AST为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sample = new Add(new Add(new Arg(0), new Arg(1)), new Arg(2));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/eb442cac-8bef-4940-9d5b-4dfcb9ef06f220220523153834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;经过Partial Evaluator 的不断进行方法内联最终会变成下述代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/8ade7d35-3837-4e2d-9676-9ab6e1fdee5b20220523153849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3.2 节点重写&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;节点重写是Truffle的另一项关键优化。&lt;/p&gt;

&lt;p&gt;在动态语言中许多变量的类型是在运行时才能确定的，以“加法”举例，符号+即可以表示整型相加也可以表示浮点型相加。Truffle的语言解释器会收集每个AST节点所代表的操作类型（profile），并且在编译时做出针对所收集到的profile进行优化，如：若收集到的profile显示这是一个整型加法操作，Truffle会在即时编译时将AST进行变形，将“+”视为整型加法。&lt;/p&gt;

&lt;p&gt;当然，这种优化也会有错误的时候，比如上述加法操作既有可能是整数加法也可能是字符串加法，此时若AST树已变形，那么我们只好丢弃编译后的机器代码，回退到AST解释执行。这种基于类型 profile 的优化，背后的核心就是基于假设的投机性优化，以及在假设失败时的去优化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/d8cae7cf-a934-46b8-b049-0b206fe7cebb20220523153910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在即时编译过后，如果运行过程中发现 AST 节点的实际类型和所假设的类型不同，Truffle 会主动调用 Graal 编译器提供的去优化 API，返回至解释执行 AST 节点的状态，并且重新收集 AST 节点的类型信息。之后，Truffle 会再次利用 Graal 编译器进行新一轮的即时编译。&lt;/p&gt;

&lt;p&gt;据统计，在 JavaScript 方法和 Ruby 方法中，80% 会在 5 次方法调用后稳定下来，90% 会在 7 次调用后稳定下来，99%会在 19 次方法调用之后稳定下来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/3d2255c2-ef21-4293-bc90-a3c9b2b5cae720220523155329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;3.4 Sulong&lt;/h4&gt;

&lt;p&gt;Sulong子项目是GraalVM为LLVM的中间语言bitcode提供的高新更运行时工具，是基于Truffle框架实现的bitcode解释器。Sulong为所有可以编译到LLVM bitcode的语言（如C，C++等）提供了在JVM中执行的解决方案。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/593f8615-539d-4bce-a069-71ced3ab1d5820220523155345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4 参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;  林子熠 《GraalVM与静态编译》；&lt;/li&gt;
&lt;li&gt;  周志明《深入理解Java虚拟机》；&lt;/li&gt;
&lt;li&gt;  Java Developer’s Introduction to GraalVM:-郑雨迪&lt;/li&gt;
&lt;li&gt;  Truffle/Graal：From Interpreters toOptimizing Compilers via Partial Evaluation:-Carnegie Mellon University&lt;/li&gt;
&lt;/ul&gt;

&lt;hr/&gt;

&lt;p&gt;作者：王子豪&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5c217855abd380973a2c6e65fced57d6</guid>
<title>互联网都在说降本增效，小红书技术团队是怎么做的？</title>
<link>https://toutiao.io/k/jo2jht5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icWCmhOp1iadiark4Ffibjc2VqB6OR2ojgBpsKWwgzPBgCuqucUIv8wdhCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;随着小红书业务的快速发展，资源消耗和成本压力显著增加。在降本增效的大背景下，我们建设了性能持续优化 &amp;amp; 追踪平台，来系统性辅助业务团队解决性能问题，在业务系统日常的演化过程中，持续跟进、追踪系统的性能退化并推动优化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前，这一平台已覆盖小红书搜索、推荐、广告的 S0 服务，运行两个多月以来，辅助业务团队存量优化超1万 CPU 核；发现性能退化超1万 CPU 核并跟进优化。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icdwLq2Btstqgt1uG6iblMDmmWUx6iajPPq62HrsyW9hNZ48km1pWOkBibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当前，小红书正处在快速发展期间，流量的快速上涨和业务的快速迭代，显著增加了资源消耗和成本压力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在存量的资源占用上，我们要求研发人员对应用做尽可能深度的性能优化。然而，&lt;strong&gt;研发人员在对自己的模块做性能优化时，往往缺少工具来辅助分析&lt;/strong&gt;，工具的合理选择、环境配置、使用方式等各个方面，都有较高的学习成本。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;另一方面，当前性能优化主要依靠个人经验进行逐个分析，缺乏通用化的机制&lt;/strong&gt;，经验较难在团队间共享。即使有人发现一个通用的性能问题，也很难衡量其涉及的模块和整体的优化空间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此外，&lt;strong&gt;小红书业务的日常迭代往往会带来增量的资源消耗，即性能退化。&lt;/strong&gt;特别是对于频繁迭代的模块，如一些推荐应用，每天进行发版且每个版本涉及十多次不同的提交。在这些提交中，可能会隐藏着一些性能退化点。显著的性能退化点会在性能压测中被发现，而更多的性能退化往往是微小的，比如一个 commit 带来了整体 CPU 1% 左右的占用，这样微小的退化是隐蔽的，通过常规压测等手段比较难以发现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着业务的迭代，日积月累下，多个微小的性能退化会导致应用整体性能的显著恶化，进而积重难返。经过一段时间的积累后，在排查这种问题时，面对动辄上百次的代码提交历史，开发同学很难排查出真正导致性能退化的提交是什么。最终只能以稳定性的名义增加资源扩容，这样的情况多次发生。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对此，我们尝试从整体上解决性能问题，设计开发了一套性能优化和持续追踪的平台，来辅助应用研发人员分析性能问题，同时在日常的业务系统演化过程中，持续跟进、追踪系统的性能退化并推动优化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icnJ5OCPPb4QUqhabYNx3cVgnibQjToVicwFFHruECYCpVzbummHkzHOOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们的目标是从整体上解决性能问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;问题主要聚焦在以下三个方面：&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;存量性能优化：&lt;/strong&gt;对应用进行全方位的深入分析、诊断、优化；优化的经验积累后，横向扩展，做到通用的优化&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;增量性能退化拦截：&lt;/strong&gt;业务迭代过程中，主动发现应用的增量资源占用，即性能退化&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;性能稳定性问题：&lt;/strong&gt;对一些突发的性能恶化导致的稳定性问题，快速定位原因&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;对应的总体技术思路：&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;分析手段：&lt;/strong&gt;基于 profiling 等采样手段，来对应用进行剖析&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;产品化：&lt;/strong&gt;做到平台化来提高易用性，研发人员可以尽可能低门槛、高效的使用；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;持续优化：&lt;/strong&gt;在机制上做到持续优化，将采样分析做到常态化、例行化，将性能优化、分析、防退化，融入到业务应用的日常迭代中，关注应用的每一个版本、每一次代码提交、每一个策略实验进行，持续追踪业务应用的性能表现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8iccY9icrrcO0Xs002FsEcoU4bd9HrlDib47zksu2QqUJOfZPsEibfbLA4vA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们的内部落地整体架构如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7220744680851063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icszEsgBP204RSpzEurickhH8bO0KrgpiahVBKfOevsqAF4icNyTq35Ymfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;752&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;核心思路是通过对业务进程进行持续性的采样、处理、存储，并基于采样数据做分析，来辅助性能优化和发现性能退化。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据采样上，我们用单机低频次持续采样，降低成本，减少对应用的影响。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在分析上，数据来自大数据存储，并从纵向、横向来对比分析：在纵向上，采用 merge + diff 分析，来发现退化点；在横向上，提供跨应用的通用查询能力，查询、分析函数粒度的资源占用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.1 数据采集、处理、存储&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.1.1. 数据采集&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;当前主要的数据采集方式是通过对进程进行 profiling，profiling 的原理是基于一定的频率对运行进程进行采样，来了解进程的特征。当前，profiling 支持从多个方面对程序进行采样分析，如 CPU、Memory、Thread、Lock、I/O 等。日常使用中，对 CPU 进行 profiling 的应用最为广泛。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一般的 CPU profiling 是 On-CPU，也就是 CPU 时间花费在哪些代码执行上。在 On-CPU 之外，还有 Off-CPU，指的是进程不在 CPU 上运行运行的时间，比如进程因为 IO、锁等原因处于等待，花费了时间。所以，Off-CPU 是对 On-CPU 的补充，整体关系如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6324074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8ic59P36SRqa9xwVdBiaTjcXvQdMaTN3DrSk6FWArSicdb0icKic5l4lLTD0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;根据应用的实际情况，综合的对 On-CPU、Off-CPU 进行采样，更为全面地了解程序的运行情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在多语言支持方面，当前我们支持 C++、JAVA、Golang 等主流语言：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;C++ 应用：&lt;/strong&gt;通过 Linux perf&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;JAVA 应用：&lt;/strong&gt;目前主流方案（如 IntelliJ IDEA 和阿里的 Arthas）是通过 Async-profiler 来实现 profiling。Async-profiler 是将 Perf 的堆栈追踪和 JDK 提供的 AsyncGetCallTrace 结合了起来，低开销的支持多种 Perf event。我们的方案里也借助了这个工具，并针对我们的需求进一步做了定制开发&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Golang 应用：&lt;/strong&gt;通过 Golang 内置的 pprof&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在采样形式上，我们支持定时、主动和条件触发三大形式。当前，小红书的线上应用基本开启了常态化、定时的 profiling&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;3.1.2 业务接入&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;采样的 agent 以 daemonset 方式部署，支持对物理机上的多个业务 pod 进行采样。对应用的采样开启、关闭是通过配置中心来下发。此外，支持更多的采样配置，如：单次采样的采样频率、采样时间配置；多次采样之间的采样周期；采样方式切换等。&lt;/p&gt;&lt;p&gt;因此，我们当前做到了业务无感知接入，接入在分钟级别生效。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.1.3 存储&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;在采样结束后，对采样后的数据进行解析、处理，如根据函数调用链统计 sample 数、过滤占比过低的函数调用链等。处理后，我们将数据进行存储，用于后续的分析。我们的存储方案选择的是 clickhouse，在存储 profiling 的数据之外，同时会把相关的环境变量信息一起存储，如应用名、应用版本、机房等。此外，采样后生成单 Pod 的火焰图，将火焰图压缩并保存在对象存储中，如腾讯云 cos。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;3.1.4 资源消耗&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在成本上，单次采样的持续时间一般不超过一分钟，多次采样之间的周期间隔是小时级别，因此对应用程序基本没有影响；单次 pod 单次采样，经处理并保存到 clickhouse 的数据在千行的规模。所以整体的项目成本基本是存储成本，即 clickhouse 和对象存储，都很便宜，整体近乎零成本。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.2 存量优化&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.2.1 目标&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;根据我们的观察和经验，一线研发同学对生产服务的诊断分析诉求长期是被压制的，主要原因在：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;公司出于安全需要，会对生产环境的网络和权限进行管控。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这导致一些诊断会非常麻烦，例如，小红书有一些系统采用了超大 Java Heap，如果要对此应用做堆分析需要的步骤：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;dump 堆到本机指定为止；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;传输 hprof 文件到指定跳板机；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;从跳板机下载 hprof 文件到本地；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;本地需要花数小时对 hprof 文件建索引，对于几十 GB 的堆，本地往往由于机器性能不够，最终可能还是无法完成分析； &lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt; 通过一些诊断工具，我们可以观测到很多系统运行指标，但对指标的解读往往需要很多经验和对业务的理解。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如运行 free 命令，我们可以得到系统的内存使用指标（free/buffer/cache）。然而这些指标到底意味着什么？对一个特定的应用，当前水位是否合理？这对使用者是有较高的基础和业务背景知识要求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于这些限制和不便，使得我们一线资深研发同学日常对性能的关注逐渐变少，而一些新同学更是望而却步。最终系统由于缺乏“体检”，既不能治于未病；又因缺乏对系统的足够认知，导致需要治疗时又无从下手。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为此，我们设定了一个小目标：把诊断变成一个日常触手可及的事：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt; 开箱即用：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们将一些常用的工具打包成一个工具箱，一键（或默认）安装到目标容器里；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;白屏化：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;所有操作都在网页上通过点击拖拽完成，研发同学不需要记住很多命令参数，同时对工具的输出做解析和解释；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt; 知识库：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;纵向上，我们会积累历史指标供参考。横向上，我们会总结一些共性的优化点供研发同学参考。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.2.2 工具&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;3.2.2.1 基础信息展示&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;这部分主要展示一些进程和环境相关的基础信息，OS、JVM、机器配置、启动参数、环境变量等。方便用户迅速了解一些应用的基本信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7219512195121951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icLHEpMibBeOozfB6bXk3icbVDWlJ3BFicwZHpiaGLyQkibxb8535cy74XDpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2050&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;3.2.2.2 运行时指标&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;这块主要涵盖一些秒级运行时的 Metrics（如 CPU 利用率，GC 信息），loaded class，线程池状态等。这块作为大盘指标的补充，在 agent 测内嵌了一个小型的时序数据库，直接在端上存储几个重要的秒级指标。帮助用户捕捉一些更细粒度的信号。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5246957766642806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icsu9Y1rKn2ic14n7CPibiagTB3vUwAszvZEfdGlSy8svcXtld9icTcxU2Kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2794&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;3.2.2.3 采样&amp;amp;分析&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;目前我们主要提供了针对 Java 的一些在线分析能力。对于 Java 程序，目前使用频率最高的是堆分析，用户可以在平台上一键触发 Heap dump，dump 文件生成后会自动上传到内部部署的 apache-jifa worker 上，用户可以在列表里面找到对应的入口，跳转到 jifa 页面去做详细的堆分析。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17929952953476216&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8ic08iblSbGeTDduFMO6jIh4phibRiclrGslJzJialPNjjFYhibOibv796IWf2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3826&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4558434690639873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icK5UJmxwMaEQUyPuxXgWq9ibWrADj9HA9PQ01qgz0bF5p3ZEgeGS616Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3782&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;同时，基于 profiling 工具，如 async-profler，用户可以一键生成 cpu、alloc 及 lock 的火焰图，并在线展示。通过这些火焰图，能很方便找到系统的一些热点，从而有针对性的去优化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.162375197057278&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icCTvibbibElQAEU0frSzeR0vylEjiaiaeLLIX5H0NtfeHFu8SbLQNNOicy3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3806&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.208355091383812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icFe125oZu6KzQEGl7d2c3d5MwicrL0Uico0xOgibYEDzuWXSUg6DtCBQWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3830&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.2.3 通用优化机制&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;在存量优化方面，我们的一个创新点就是通用优化机制。在对各应用进行常态化的 profiling 后，我们有了所有应用的性能原始数据，进一步的想法就是大数据检索：经过众多的性能优化 case 后，将常见的基础库和已知的通用性能问题抽象成规则库，从而可以匹配其在线上所有模块的消耗占比和整体占用核数，来发现更多优化空间，达到批量优化并且追踪优化的效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图所示，为线上一个基础库 SDK 在各个应用中的资源消耗情况，分别统计了 CPU 占比和对应的核数。在此基础上，批量的推动应用进行优化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48996350364963503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8ic9chBpYEndyo3jF5vxBnL6LRlkgLTzwzVoW1YcR1QA8VdOUnCCgZ4Lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.3 性能持续优化&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.3.1 总体思路&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;针对业务迭代过程中发生的性能退化，持续跟进、追踪。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总体的思路是：首先是发现性能退化点，精确到函数级别；并进一步关联、发现对应的变更事件(代码提交、算法实验等)；后续跟进整个性能退化的生命周期，推动优化，直到最终解决性能退化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3396778916544656&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icCVSEGicf2sZTQmAOKHXtJGZceGGoQFOJByr7KaARLEz7yae7ibLknBAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;683&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.3.2 发现&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;3.3.2.1 机制&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;首先是自动化巡检，即每天会定期检查接入的服务是否存在潜在性能退化，通过昨天和前天晚高峰性能数据，检查各应用是否有性能退化情况，并推送到相关企微群。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.872093023255814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icticIuDsbaNOH4RIk6R5j0UL3VpXvtVZTotTmUmdL5gfCkVDpiaJGWI8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1204&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;此外，通过接入 QA 流水线、上线平台等方式，在上线前、上线后回调，更早期拦截性能退化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;3.3.2.2 发现方式&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;通过性能数据 merge + diff 分析：根据查询条件，在将新版本和基准版本分别进行数据聚合后，进行对比；通过分析对比后的 diff，发现异常变化点并判断是否有性能退（精确到函数）。当前支持机房、版本和时间区间等多种条件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3991683991683992&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icxfNfFViczxpLFTDiasgZv4vs6bhIowiaUSrT30icNMcibTGSGDia91Ndhw3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2886&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;此外，为了衡量性能退化点的影响，将退化的程度与对应占用的 CPU 核数相关联，也可以让研发人员们了解对应退化点对于系统整体性能的影响，有更直观的感受。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;3.3.2.3. 退化点展示&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;火焰图是一种比较理想的展示函数调用关系的形式，同时也可以方便的定位其在整体中的位置。因此，我们通过定制化的差分火焰图，展示退化点对应的详细函数栈情况，并用颜色来标记、突出性能退化点，用不同的颜色来区分退化的程度；同时在火焰图上展示对应的 CPU 核数，来强化退化程度，增加火焰图的表达内容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此外，为了支持版本间消失的代码逻辑，使用了消失火焰图。这样，组合起来，可以展示两个版本之间函数栈的新增、修改、消失等场景。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在技术实现上，我们在开源的 flamescope（https://github.com/Netflix/flamescope）基础上定制开发，进行实时进行处理和渲染，根据需求可以灵活的支持各种应用场景。所有的火焰图和 diff 计算均从 clickhouse 中读取数据处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;线上的一个实际性能退化例子如下，其中差分火焰图中展示了退化点对应的函数调用、退化对应的 CPU 核数；消失火焰图展示了版本之间消失的代码逻辑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6223404255319149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8ic7uYjxwibec9rs4T6KybHfvOia86umMugp0gSXn4u8ZcxeclHicicMVLAyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1504&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5240101095197978&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8ict1MAy5BdHxBljKJBFw6l1uKxTSmoLQpHiblFFpnXSwV31mHP6sGJlAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2374&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.3.3 定位变更&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;在确定性能退化后，根据性能退化的情况（如退化的时间点、函数栈），检索应用对应的变更事件，如算法实验变更、配置中心下发变更、上线记录等。未来，会进一步尝试根据函数栈来管理 git 的提交情况，关联可能代码提交。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.3.4 持续追踪&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;为了方便追踪性能退化问题的进度，我们会把核实过的信息推送至内部风险平台来录入留痕，并且通过趋势图追踪优化情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5055944055944056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icXbSDXdsfWffmurredDFvu6H3VibPd9vCMCs2AydFibdFNTLPElEj3LVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2860&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如上图所示，这是一个线上应用性能退化的实际 case，通过函数调用链的 CPU 使用率趋势图可以看出性能退化发生的起始点，同时可以看出该性能退化是否得到了修复、何时修复，这样可以清晰的看到性能退化问题的过程，方便持续追踪性能问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;3.4 性能异常问题定位&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在采样的方式上，支持条件触发方式，即配置描述异常态的触发条件(比如 CPU 突涨等)，当满足条件时进行数据的采集和上报。再基于上述的 merge + diff 数据分析方法，将异常态和正常态的数据分别进行汇聚后，做对比分析，通过 diff 分析来定位出导致突涨的根因，同时关联对应的变更。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icic5EPVd9yr2WL6PQfOlgy2Yf4qw5Q193pBzJZV902R8sl608dWQFwvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;未来，我们希望能够去探索更多的&lt;strong&gt;性能优化手段&lt;/strong&gt;，如 PGO；以及基于 PMU 指标，探索&lt;strong&gt;“内存大页”等技术落地&lt;/strong&gt;&lt;span&gt;；同时，我们也希望能够&lt;/span&gt;收集&lt;strong&gt;更多的性能指标&lt;/strong&gt;&lt;span&gt;，如 walltime、cpu cache、mem bindwith 等，来覆盖更多的性能分析场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icnWHVPDvFiaRT1ot9VC4ibNBQWwbGAHL5YMfTlo36f5XzLglic8Uga5pvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;韩柏：技术部/可观测技术组&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小红书可观测技术工程师，毕业于上海交通大学，从事推荐架构、基础架构工作，在可观测、云原生、中间件、性能优化等方面有较为丰富的经验。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;小粟：技术部/可观测技术组&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小红书可观测技术工程师，毕业于西安交通大学，先后在推荐架构、云原生、可观测领域从事相关工作，现专注于通用日志体系的建设。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;苏星河：技术部/可观测技术组&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小红书可观测技术工程师，毕业于南京大学计算机系，之前在小红书供应链管理、大数据、推荐等诸多业务积累了丰富的经验，最近在专注JVM在线诊断及性能优化相关的工作。&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8ic1nTkTHVUPCPZktlo5JWL3FvyAgjasKnOhk2G17s1JdN4lJLYPQTUyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icAJXXKRJgqmRzNAIXqiaPpYrPZuaSguAezSmbhOoqcnWHDam9pOwGqGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;基础技术部/可观测技术组&lt;/strong&gt;致力于建设基础技术体系中稳定、高效、易用的可观测性技术体系，服务并支撑业务的稳定发展与敏捷迭代，打造国内一流的可观测性技术体系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;岗位：可观测性研发专家&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;岗位职责：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1. 负责可观测性技术体系研发工作，围绕 Metric/Log/Trace 三大支柱，从全栈领域展开可观测基础能力建设。&lt;/p&gt;&lt;p&gt;2. 负责可观测平台、全链路追踪、日志平台、计算引擎（流式分析、实时告警、时序检测等）、云原生可观测、AIOps 智能化运维、持续性能诊断等相关技术架构及产品设计。&lt;/p&gt;&lt;p&gt;3. 保障可观测性相关基础服务，在高并发环境下的高性能、高可用，推动技术、产品持续优化迭代。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;岗位要求：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1. 全日制统招本科及以上学历，3年及以上计算机相关工作经验；&lt;/p&gt;&lt;p&gt;2. 精通 Java 或 Go 语言，熟悉并发编程、序列化、存储压缩等，有扎实的编程基础；&lt;/p&gt;&lt;p&gt;3. 熟悉云原生可观测性体系的相关产品及组件，包括不仅限于：CAT、OpenTelemetry、SkyWalking、Prometheus、ELK 等，了解 Kubernetes 基本原理并能运用；&lt;/p&gt;&lt;p&gt;4. 熟悉基础技术（如通信、存储、MQ 等）开源组件，深入了解细节，掌握实现原理优先；&lt;/p&gt;&lt;p&gt;5. 善于发现、解决问题，善于总结、思考、跨团队协作，能吃苦耐劳；&lt;/p&gt;&lt;p&gt;6. 关注业界新技术，好奇求知，有强烈的责任心及抗压能力。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8ic1nTkTHVUPCPZktlo5JWL3FvyAgjasKnOhk2G17s1JdN4lJLYPQTUyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;添加小助手，了解更多内容&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;微信号 / REDtech01&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8249258160237388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vxnkL2N86Ivn8mb6eYBibvib6ibtiahwGo8icl5p5iabXKL3aEEswk4kUj6JTcymfN97mne1fOySePnnLHeY9CvGohmQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1011&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b3e5701a90a0ac2343daf64391bcb22a</guid>
<title>系统崩了，竟然是不规范打印日志的锅？</title>
<link>https://toutiao.io/k/rumhxhr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;利器一：规范先行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在你想启动规范化日志打印前，建议先制定一份日志打印规范，它可能无法面面俱到，但没有关系，它的目的仅是为了先突显日志打印规范的重要性，并且让这件事情能够正式进入正轨。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果组织中大部分都是Java应用，那么规范内容可以主要围绕Java应用来写，虽然无法覆盖所有开发语言，但其核心原则仍是可以借鉴的。另外，前期请务必不要将其复杂化，否则它将无法具备普适性，也无法被接受和传播。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;Java应用系统日志打印规范&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）Java日志框架&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用的Java日志框架可选择Log4j/Logback/Log4j2等，但为了避免后续更换日志框架所带来的额外改造成本，建议将接口层和实现层进行分离，将SLF4J作为接口层，将Log4j/Logback/Log4j2作为实现层，两者通过桥接的方式进行集成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）Java日志规范&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;规范一：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;【强制】级别只允许使用ERROR、WARN、INFO、DEBUG，定义如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;303&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.525&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8ZmkbbGSLx7NAHtFokYK7rAyg73aNUbria3od6qRBDiaZYbhL9iaKxQhUiaoQ18OY6OuiaxxDO8QgQWHCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;规范二：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;【强制】禁止使用Logback/Log4j2等的API，应使用SLF4J的API。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;规范三：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;【强制】在接口/方法的入口/出口处，打印请求及响应参数日志。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;规范四：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;【强制】ERROR级别日志需打印堆栈，而非ERROR级别日志则不需要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;规范五：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;【强制】禁止在代码循环体中直接打印非DEBUG级别的日志。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;规范六：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;【强制】禁止日志打印内容中仅打印特殊字符或数字的情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;规范七：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;【建议】日志内容中应包含关键特征类信息，例如：用户标识或流水号。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;规范八：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;【建议】应采用异步打印模式，且打印时建议关闭打印位置信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;规范九：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;【建议】日志打印若出现堵塞，建议至少丢弃INFO级别以上的日志。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;规范十：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;【建议】每条日志在语义上可独立被理解，减少上下文关联理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）Java日志字段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;691&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.195138888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8ZmkbbGSLx7NAHtFokYK7rA5gX5wswCBQ9IdrAdE6sAmcwyIt6SV70b6B9GtAvgTkS6o1BJNfT0hA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：位置信息包括类(class)/文件(file)/行号(line)/方法(method)，若打印位置信息，则对性能有所影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上仅是一些规范参考，你可以根据组织中的实际情况来进行调整，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;但规范仅仅只是规范，有了它并不代表你已达成目标&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，只能说明你已为日志打印规范化这件事，迈出了第一步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;利器二：服务至上&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当制定完应用系统日志打印规范后，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;请不要幻想有任何人会来自觉地遵守它&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，一是不知它的存在，二是他们无从下手，三是大家都挺“忙”的。我把它总结为六字真言，分别是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;“不知”、“不会”、“不想”&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我曾见过组织中的有些规范，特别是技术规范，在制定完成后就会被长久地封存起来，没有人知道，也没有人想知道。所以，要落实好规范，你还得构思一套战术才行。否则，那些无法落实的规范就和废纸毫无两样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在很多人眼里，可能会将规范视为是一种约束，而又错误地将约束理解为贬义词，从而避而远之。这种误解的发生，其原因并不出在他们本身，而更多的出在那些制定规范的人身上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有些规范制定者不但没有身在其中，甚至也没有去诠释规范所能带来的价值，而仅仅只是强行推行那份冷冰冰的规范，请问此时谁会乐意在不知其所以然的情况下，无缘无故地背上这沉重的“负担”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;你必须得为这份规范赋予更多的“温度”，而主动服务可能会是一种比较好的“升温”方式。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;但在行动前，切忌不要站在他们的对立面，并请做好放低姿态的觉悟，你要让对方深刻的意识到你和他们是同一阵营的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在发布规范后的初期，你可以尝试挑选几个日志打印情况最为糟糕的应用系统，扮演为“VIP私人助理”来与对方进一步传达规范内容及作用，并为他们逐一列举出当前存在的日志打印问题，以及这些问题会对系统造成哪些影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种方式不但能够避免仅用文字传达所产生的理解偏差，及时有效地为对方解答各种疑问，使他们能够更深一步地理解规范内容及作用，还能够让规范制定者更进一步地了解对方的顾虑及困难，并从同理心视角出发，为对方提供更好的建议及解决思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就这样5个、10个、15个应用系统......在精力有限的前提下逐步扩大辐射范围，事实证明，这种主动服务+循序渐进的方式对提升规范的接受度将会有所帮助。不过在过程中你&lt;/span&gt;&lt;strong&gt;&lt;span&gt;仍然需要不断回看规范的合理性及适用性，并对规范作出及时且有效的调整。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;利器三：度量为王&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当规范逐渐被更多的人接受后，你的使命并没有完成，而真正的考验才刚刚开始。一是接受并不代表整改，二是如何验证整改有效性，三是整改是否可持续性。如果这些问题都不在你的考虑范围内，那你可能会前功尽弃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若想要解决以上这些问题，借助度量或许会是一个不错的选择。管理大师德鲁克曾说过：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;“没有度量，就没有管理”&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，它同样适用于规范的落实工作，你可以根据日志打印规范来制定一些度量指标，并配套研发相应的度量工具平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过度量工具平台“可视化”和“自助化”的两种特性，让开发人员能够及时发现日志打印规范的问题，还能够让他们自主验证日志打印规范整改后的效果，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;从而让他们感受到一种“看得见”+“摸得着”的安全感。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，度量指标的设计将会尤其重要，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;往往一个不合理的指标，会让整个事情朝着预想中的反方向发展。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;所以，在初期并不建议你设计过多的度量指标，并建议从度量难度、影响程度、达成难度、可解释性四个方面进行综合性评估，以确定较为合理的指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下是当时初期选择的8个指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;362&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6264705882352941&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8ZmkbbGSLx7NAHtFokYK7rAJ3qVKoSGeOHlKjib9MjMq66wRcMqrr6oJDrLia23FU5bgSOQXwE8XTNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：以上仅列出指标，指标要求建议你可根据实际情况进行动态调整，但过高的指标要求会变得毫无意义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可能会有人提出，对于规模较大且日志条数较多的应用系统，是否可放宽指标要求，这听上去好像蛮有道理的，但我却并不这么认为。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;规模越大意味着所承载的职责和能力也就越大，一旦发生故障影响面也就越大，所以反倒更应该达到指标要求。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些指标虽然有一定的指导性，但似乎并不能满足开发人员的“胃口”，因为这些指标仍然无法直接暴露问题根源，也无法让他们可快速定位及明确优化方向。因此，你还得赋予指标一定的分析能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如：订单系统单日ERROR级别日志888条（占日志总量0.05%），（TOP1）90%在com.OrderService的第88行。（TOP2）10%在com.PayService的第188行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就这样，你可以逐步完善指标体系及配套的分析能力，但请在设计每一个指标时，遵循先进行系统现状摸排，再进行小范围试点运行，最后进行持续观测并调优，从而确保每一个指标的设计都具备一定的合理性和可解释性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下列出了一些指标，仅供参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;233&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40353460972017674&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8ZmkbbGSLx7NAHtFokYK7rAepyEw2JBXPGPxeTaXqpCPoqj8zB5Qmu6lbrVcd3mA7ByAbcyqXrDwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;197&quot; data-backw=&quot;578&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8ZmkbbGSLx7NAHtFokYK7rAD8gW0MfB4Raia8YNW6qrLZr6sBFVHR3DPzSiblf2gYW8b0ibOM7ufkWNQ/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;679&quot; data-cropy1=&quot;4.698961937716263&quot; data-cropy2=&quot;234.94809688581313&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3402061855670103&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8ZmkbbGSLx7NAHtFokYK7rADbCIIYfw5nVa547RngfIYjhHpiaGZxwsvzznLPeT2mWwGSHzIeeeialQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;679&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;308&quot; data-backw=&quot;578&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8ZmkbbGSLx7NAHtFokYK7rA4t3ndCsQiaUzHibvt2kf7Br0CfFGUBbicGzvVz4e6B5EgmVicdibdlmS0Nw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;679&quot; data-cropy1=&quot;3.524221453287197&quot; data-cropy2=&quot;365.3442906574394&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5331369661266568&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8ZmkbbGSLx7NAHtFokYK7rAPPcVFQSibCLBVG256tjuL18Vnice9uWFJUiaMDg2elLQg8rqiaHkHC2V1Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;679&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此之外，你还可以将不同应用系统的指标进行横向对比，并采用排行榜的形式在科技内部进行公开，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;它将会产生一种改变行为的驱动力，可以有效激发“想要赢”和“不想失败”的心理活动&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，这就好比某些产品也会采用排行榜的方式来激励用户一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过设计指标体系+研发度量平台+公开排行榜单这三个手段的组合，在一定程度上可以驱动开发人员持续性整改日志打印的问题。但万事无绝对，那些始终无动于衷的人依然会存在，不过请不要强行要求对方，毕竟有时候存在即合理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在最后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日志打印规范固然重要，但也请不要过分追捧，它的核心价值还是在于能够帮助开发人员更好地记录应用系统的“案发现场”，并可为应用系统提供可持续改进的“线索”。但请牢记，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;日志打印规范虽不是万能的，但没有日志打印规范却是万万不能的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;作者丨陈俊&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源丨公众号：技术奇妙物语（ID：gh_cfee2fb349bc）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dbaplus社群欢迎广大技术人员投稿，投稿邮箱：editor@dbaplus.cn&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36086956521739133&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YY6J547ZhgwY87vBia8l2ic7vAeqPaIJicV0RiacMHFOs2HBwzojCN94ROMWN3hCF1Z5DAwEaibibQSLxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1150&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zf2jiaBBH3vdgfP4A2rem5YEAHYH074dc4GibhojA5B3lLZrXLDRciaVnficveaHcAUCiaIPoDsTkAduA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4568500efca567687e4b23706c8524af</guid>
<title>保姆级教程！2 万字 + 30 张图搞懂 MySQL 是怎么加行级锁的？</title>
<link>https://toutiao.io/k/ajp0uzy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小林。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上周五我发了一篇「 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247522697&amp;amp;idx=1&amp;amp;sn=4cff90f9f10caa3db49912054e31fec3&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;MySQL 是怎么加锁？&lt;/a&gt;」的文章，当时这篇文章是重写了以前的文章，相比以前的文章多了 1w 字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;期间有位读者认真看完后，跟我反馈，希望再多解释下二级索引（非唯一索引）
的间隙锁具体可以防止哪些新记录插入，因为相比于主键索引的间隙锁，考虑的因素会比较多。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5313964386129335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VIje9l4m0QficgLJiaSXbbokeytnSsUibwZXnwsK1qkx8OmMN3bbChIUzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2134&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以后来，我就多补充了这部分内容，现在这篇文章可以说是保姆级别的教程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一补充，又多了好几千字&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/newemoji/Lol.png&quot; data-w=&quot;20&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2647058823529412&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VD0lXyRMSp7mp3yctDwibVBVPs9RSymkAypiaPiaW7yjJQKejW8nbwKRnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;340&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章内容比较长，大家可以耐心看下去，&lt;strong&gt;看完之后你会有一种突然被顿悟的感觉&lt;/strong&gt;，因为我自己写完这篇文章后，自己也被自己顿悟了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;正文&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是很多人都对 MySQL 加行级锁的规则搞的迷迷糊糊，对记录一会加的是 next-key 锁，一会加是间隙锁，一会又是记录锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;坦白说，确实还挺复杂的，但是好在我找点了点规律，也知道如何如何用命令分析加了什么类型的行级锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了说清楚这三件事情：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、&lt;span&gt;MySQL 是怎么加行级锁的？有什么规则？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;2、为什么 &lt;span&gt;MySQL 要这么加行级锁？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3、如何用&lt;/span&gt;&lt;span&gt;命令分析加了什么行级锁？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以&lt;strong&gt;我重写了这篇文章&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目录结构如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7259887005649717&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VsrNaicugF103Tph64micsXiaHOFf9HDAyrQTa0mkxJ8uaHOvUVYeKp6Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么 SQL 语句会加行级锁？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁，所以后面的内容都是基于 InnoDB 引擎 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在说 MySQL 是怎么加行级锁的时候，其实是在说 InnoDB 引擎是怎么加行级锁的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通的 select 语句是不会对记录加锁的，因为它属于快照读，是通过  MVCC（多版本并发控制）实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为&lt;strong&gt;锁定读&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//对读取的记录加共享锁(S型锁)&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; ... &lt;span&gt;lock&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;share&lt;/span&gt; &lt;span&gt;mode&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;//对读取的记录加独占锁(X型锁)&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; ... &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这两条语句必须在一个事务中，&lt;strong&gt;因为当事务提交了，锁就会被释放&lt;/strong&gt;，所以在使用这两条语句的时候，要加上 begin 或者 start transaction 开启事务的语句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)**。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//对操作的记录加独占锁(X型锁)&lt;br/&gt;updaet table .... where id = 1;&lt;br/&gt;&lt;br/&gt;//对操作的记录加独占锁(X型锁)&lt;br/&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3951048951048951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4Vs0sPeoaJXG5bd2Cn2I0Bh6PZNzXnvRJEOcPNkkCLC3QC0kWxvBWbzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;572&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;行级锁有哪些种类？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同隔离级别下，行级锁的种类是不同的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在读已提交隔离级别下，行级锁的种类只有记录锁，也就是仅仅把一条记录锁上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在可重复读隔离级别下，行级锁的种类除了有记录锁，还有间隙锁（目的是为了避免幻读），所以行级锁的种类主要有三类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Record Lock，记录锁，也就是仅仅把一条记录锁上；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，分别介绍这三种行级锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Record Lock&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，当一个事务执行了下面这条语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql &amp;gt; &lt;span&gt;begin&lt;/span&gt;;&lt;br/&gt;mysql &amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t_test &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务会对表中主键 id = 1 的这条记录加上 X 型的记录锁，如果这时候其他事务对这条记录进行删除或者更新操作，那么这些操作都会被阻塞。注意，其他事务插入一条 id = 1 的新记录并不会被阻塞，而是会报主键冲突的错误，这是因为主键有唯一性的约束。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46472019464720193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VQpBEfF80CMYJdUPM5UJAZr1SB4jmjQtJBaIAicNIdgSsOKlblafmCxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;411&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当事务执行 commit 后，事务过程中生成的锁都会被释放。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Gap Lock&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5620437956204379&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VPGsBgvz9ETftlIv7QQcbibGALUmrgwdLMzR2GiaURpkSdXwOibDTUcSwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;411&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，&lt;strong&gt;间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Next-Key Lock&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改和删除 id = 5 这条记录。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5620437956204379&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4Vs17AZBvc3ecPzDicbuBLuMFlSibuI0L9NgSW6b8nNibI3TkAHEFs0bdng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;411&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，next-key lock 即能保护该记录，又能阻止其他事务将新记录插入到被保护记录前面的间隙中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MySQL 是怎么加行级锁的？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;行级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;加锁的对象是索引，加锁的基本单位是 next-key lock&lt;/strong&gt;，它是由记录锁和间隙锁组合而成的，&lt;strong&gt;next-key lock 是前开后闭区间，而间隙锁是前开后开区间&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那到底是什么场景呢？总结一句，&lt;strong&gt;在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock  就会退化成退化成记录锁或间隙锁&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次会以下面这个表结构来进行实验说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`user`&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT,&lt;br/&gt;  &lt;span&gt;`name`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_unicode_ci &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`age`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  PRIMARY &lt;span&gt;KEY&lt;/span&gt; (&lt;span&gt;`id`&lt;/span&gt;),&lt;br/&gt;  &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;`index_age`&lt;/span&gt; (&lt;span&gt;`age`&lt;/span&gt;) &lt;span&gt;USING&lt;/span&gt; BTREE&lt;br/&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=&lt;span&gt;InnoDB&lt;/span&gt;  &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CHARSET&lt;/span&gt;=utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt;=utf8mb4_unicode_ci;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，id 是主键索引（唯一索引），age 是普通索引（非唯一索引），name 是普通的列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表中的有这些行记录：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5854700854700855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4V8J8YCibSU3MoTblc2yNEXtibq7vwu2CvbtY8AOUodAHDaQ0tr3n2E5zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;468&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次实验环境的 &lt;strong&gt;MySQL 版本是 8.0.26，隔离级别是「可重复读」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同版本的加锁规则可能是不同的，但是大体上是相同的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;唯一索引等值查询&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会&lt;strong&gt;退化成「记录锁」&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会&lt;strong&gt;退化成「间隙锁」&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下里用两个案例来说明。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、记录存在的情况&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设事务 A 执行了这条等值查询语句，查询的记录是「存在」于表中的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;begin&lt;/span&gt;;&lt;br/&gt;Query OK, 0 rows affected (0.00 sec)&lt;br/&gt;&lt;br/&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+--------+-----+&lt;/span&gt;&lt;br/&gt;| id | name   | age |&lt;br/&gt;+&lt;span&gt;----+--------+-----+&lt;/span&gt;&lt;br/&gt;|  1 | 路飞   |  19 |&lt;br/&gt;+&lt;span&gt;----+--------+-----+&lt;/span&gt;&lt;br/&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.02&lt;/span&gt; sec)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，事务 A 会为 id 为 1 的这条记录就会加上 &lt;strong&gt;X 型的记录锁&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4520547945205479&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VhrrgzjFUbDuxffBr3he4ltiacxo3D2GLia6tjSrnSxPsxUozfQ3hBYKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;511&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，如果有其他事务，对 id 为 1 的记录进行更新或者删除操作的话，这些操作都会被阻塞，因为更新或者删除操作也会对记录加 X 型的记录锁，而 X 锁和 X 锁之间是互斥关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，下面这个例子：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.667590027700831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VvibNDzmM59EqkAdyQBzapgX1hib4JHMTVcmZ7aHz2jU9bmeoVM35mUuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;722&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为事务 A 对 id = 1的记录加了 &lt;strong&gt;X 型的记录锁&lt;/strong&gt;，所以事务 B 在修改 id=1 的记录时会被阻塞，事务 C 在删除 id=1 的记录时也会被阻塞。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有什么命令可以分析加了什么锁？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过 &lt;code&gt;select * from performance_schema.data_locks\G;&lt;/code&gt; 这条语句，查看事务执行 SQL 过程中加了什么锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以前面的事务 A 作为例子，分析下下它加了什么锁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VlCiavt3yI0WpnIlDLfx1duhWYFfCvNOCGVhnFvTSwSdvaQfx7vT55Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看到，共加了两个锁，分别是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们重点关注行级锁，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果 LOCK_MODE 为 &lt;code&gt;X&lt;/code&gt;，说明是 next-key 锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 LOCK_MODE 为 &lt;code&gt;X, REC_NOT_GAP&lt;/code&gt;，说明是记录锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 LOCK_MODE 为 &lt;code&gt;X, GAP&lt;/code&gt;，说明是间隙锁；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，&lt;strong&gt;此时事务 A 在 id = 1 记录的主键索引上加的是记录锁，锁住的范围是 id 为 1 的这条记录。&lt;/strong&gt;这样其他事务就无法对 id 为 1 的这条记录进行更新和删除操作了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这里我们也可以得知，&lt;strong&gt;加锁的对象是针对索引&lt;/strong&gt;，因为这里查询语句扫描的 B+ 树是聚簇索引树，即主键索引树，所以是对主键索引加锁。将对应记录的主键索引加 记录锁后，就意味着其他事务无法对该记录进行更新和删除操作了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为什么唯一索引等值查询并且查询记录存在的场景下，该记录的索引中的 next-key lock 会退化成记录锁？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因就是在唯一索引等值查询并且查询记录存在的场景下，仅靠记录锁也能避免幻读的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幻读的定义就是，当一个事务前后两次查询的结果集，不相同时，就认为发生幻读。所以，要避免幻读就是避免结果集某一条记录被其他事务删除，或者有其他事务插入了一条新记录，这样前后两次查询的结果集就不会出现不相同的情况。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于主键具有唯一性，所以&lt;strong&gt;其他事务插入 id = 1 的时候，会因为主键冲突，导致无法插入 id = 1 的新记录&lt;/strong&gt;。这样事务 A 在多次查询  id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于对 id = 1 加了记录锁，&lt;strong&gt;其他事务无法删除该记录&lt;/strong&gt;，这样事务 A 在多次查询  id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、记录不存在的情况&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设事务 A 执行了这条等值查询语句，查询的记录是「不存在」于表中的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;begin&lt;/span&gt;;&lt;br/&gt;Query OK, 0 rows affected (0.00 sec)&lt;br/&gt;&lt;br/&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;Empty &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.03&lt;/span&gt; sec)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，通过 &lt;code&gt;select * from performance_schema.data_locks\G;&lt;/code&gt; 这条语句，查看事务执行 SQL 过程中加了什么锁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.976083707025411&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4V49gBTlWSicnEIhjIO7D90G8k1hzib5qVGA4Gic9DlicdTkVgdibHuQtVtAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1338&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看到，共加了两个锁，分别是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，&lt;strong&gt;此时事务 A 在 id = 5 记录的主键索引上加的是间隙锁，锁住的范围是 (1, 5)。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.530638852672751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VgqBttRLdShCXLTLhdiaFnA4eWohsicSw4cAaFHpNibiacE3Rez6vPEs9bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，如果有其他事务插入 id 值为 2、3、4 这一些记录的话，这些插入语句都会发生阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，如果其他事务插入的 id = 1 或者 id = 5 的记录话，并不会发生阻塞，而是报主键冲突的错误，因为表中已经存在 id = 1 和 id = 5 的记录了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，下面这个例子：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6161228406909789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VSdDibEltQrxhEFTxk3NiaxvuPOuqkgjZoel1yxhtIKrnag5SsbUpaQLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;521&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为事务 A 在 id = 5 记录的主键索引上加了范围为 (1, 5) 的 X 型间隙锁，所以事务 B 在插入一条 id 为 3 的记录时会被阻塞住，即无法插入 id = 3 的记录。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;间隙锁的范围&lt;code&gt;(1, 5)&lt;/code&gt; ，是怎么确定的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据我的经验，如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围「右边界」，此次的事务 A 的 LOCK_DATA 是 5。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后锁范围的「左边界」是表中 id 为 5 的上一条记录的 id 值，即 1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，间隙锁的范围&lt;code&gt;(1, 5)&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为什么唯一索引等值查询并且查询记录「不存在」的场景下，在索引树找到第一条大于该查询记录的记录后，要将该记录的索引中的 next-key lock 会退化成「间隙锁」？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因就是在唯一索引等值查询并且查询记录不存在的场景下，仅靠间隙锁就能避免幻读的问题。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么 id = 5 记录上的主键索引的锁不可以是 next-key lock？如果是 next-key lock，就意味着其他事务无法删除 id = 5 这条记录，但是这次的案例是查询 id = 2 的记录，只要保证前后两次查询 id = 2 的结果集相同，就能避免幻读的问题了，所以即使 id =5 被删除，也不会有什么影响，那就没必须加 next-key lock，因此只需要在 id = 5 加间隙锁，避免其他事务插入 id = 2 的新记录就行了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么不可以针对不存在的记录加记录锁？锁是加在索引上的，而这个场景下查询的记录是不存在的，自然就没办法锁住这条不存在的记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;唯一索引范围查询&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;范围查询和等值查询的加锁规则是不同的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当唯一索引进行范围查询时，&lt;strong&gt;会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会&lt;strong&gt;退化成记录锁&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，&lt;strong&gt;扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁&lt;/strong&gt;，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当条件值的记录在表中，如果是「小于」条件的范围查询，&lt;strong&gt;扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁&lt;/strong&gt;，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，通过几个实验，才验证我上面说的结论。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、针对「大于或者大于等于」的范围查询&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实验一：针对「大于」的范围查询的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设事务 A 执行了这条范围查询语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;begin&lt;/span&gt;;&lt;br/&gt;Query OK, 0 rows affected (0.00 sec)&lt;br/&gt;&lt;br/&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &amp;gt; &lt;span&gt;15&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-----------+-----+&lt;/span&gt;&lt;br/&gt;| id | name      | age |&lt;br/&gt;+&lt;span&gt;----+-----------+-----+&lt;/span&gt;&lt;br/&gt;| 20 | 香克斯    |  39 |&lt;br/&gt;+&lt;span&gt;----+-----------+-----+&lt;/span&gt;&lt;br/&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.01&lt;/span&gt; sec)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务 A 加锁变化过程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最开始要找的第一行是 id = 20，由于查询该记录不是一个等值查询（不是大于等于条件查询），所以对该主键索引加的是范围为  (15, 20] 的 next-key 锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于是范围查找，就会继续往后找存在的记录，虽然我们看见表中最后一条记录是 id = 20 的记录，但是实际在 Innodb 存储引擎中，会用一个特殊的记录来标识最后一条记录，该特殊的记录的名字叫 supremum pseudo-record ，所以扫描第二行的时候，也就扫描到了这个特殊记录的时候，会对该主键索引加的是范围为  (20, +∞] 的 next-key 锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;停止扫描。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以得知，事务 A 在主键索引上加了两个 X 型 的 next-key 锁：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7125140924464487&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VZ0dcGRVMibyO0UD103aQMqk1pGB0yyoksahjwxe3U9JSM5hJthXwfoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;887&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 id = 20 这条记录的主键索引上，加了范围为 (15, 20] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在特殊记录（ supremum pseudo-record）的主键索引上，加了范围为 (20, +∞] 的 next-key 锁，意味着其他事务无法插入 id 值大于 20 的这一些新记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以通过 &lt;code&gt;select * from performance_schema.data_locks\G;&lt;/code&gt; 这条语句来看看事务 A 加了什么锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下，我这里只截取了行级锁的内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8792613636363636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4Vvw0F1SiakriachD7Ff9Yicg8kv56mETnBxJ8aYsp6ibiclRIKmKtBqz6KMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1408&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图中的分析中，也可以得到&lt;strong&gt;事务 A 在主键索引上加了两个 X 型 的next-key 锁：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 id = 20 这条记录的主键索引上，加了范围为 (15, 20] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在特殊记录（ supremum pseudo-record）的主键索引上，加了范围为 (20, +∞] 的 next-key 锁，意味着其他事务无法插入 id 值大于 20 的这一些新记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实验二：针对「大于等于」的范围查询的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设事务 A 执行了这条范围查询语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;begin&lt;/span&gt;;&lt;br/&gt;Query OK, 0 rows affected (0.00 sec)&lt;br/&gt;&lt;br/&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &amp;gt;= &lt;span&gt;15&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-----------+-----+&lt;/span&gt;&lt;br/&gt;| id | name      | age |&lt;br/&gt;+&lt;span&gt;----+-----------+-----+&lt;/span&gt;&lt;br/&gt;| 15 | 乌索普    |  20 |&lt;br/&gt;| 20 | 香克斯    |  39 |&lt;br/&gt;+&lt;span&gt;----+-----------+-----+&lt;/span&gt;&lt;br/&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务 A 加锁变化过程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最开始要找的第一行是 id = 15，由于查询该记录是一个等值查询（等于 15），所以该主键索引的 next-key 锁会&lt;strong&gt;退化成记录锁&lt;/strong&gt;，也就是仅锁住 id = 15 这一行记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 20，于是对该主键索引加的是范围为  (15, 20] 的 next-key 锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接着扫描到第三行的时候，扫描到了特殊记录（ supremum pseudo-record），于是对该主键索引加的是范围为  (20, +∞] 的 next-key 锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;停止扫描。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以得知，事务 A 在主键索引上加了三个 X 型 的锁，分别是：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6956031567080045&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VfQo70icyFUyU5AekFg8jk8icuB4kdY9RGRexTC8LsSsj1ZmY9S6x89ug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;887&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 id = 15 这条记录的主键索引上，加了记录锁，范围是 id = 15 这一行记录；意味着其他事务无法更新或者删除 id = 15 的这一条记录；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 id = 20 这条记录的主键索引上，加了 next-key 锁，范围是  (15, 20] 。意味着其他事务即无法更新或者删除 id = 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在特殊记录（ supremum pseudo-record）的主键索引上，加了 next-key 锁，范围是  (20, +∞] 。意味着其他事务无法插入 id 值大于 20 的这一些新记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以通过 &lt;code&gt;select * from performance_schema.data_locks\G;&lt;/code&gt; 这条语句来看看事务 A 加了什么锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下，我这里只截取了行级锁的内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.039348710990502&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VhoUaiaIicZvicmicNTLQ3yUXRmt1ZpxwkgMGmrSIl9MNaNRAXHErWuicaXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1474&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面这个实验，我们证明了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;针对「大于等于」条件的唯一索引范围查询的情况下， 如果条件值的记录存在于表中，那么由于查询该条件值的记录是包含一个等值查询的操作，所以该记录的索引中的 next-key 锁会&lt;strong&gt;退化成记录锁&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、针对「小于或者小于等于」的范围查询&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实验一：针对「小于」的范围查询时，查询条件值的记录「不存在」表中的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设事务 A 执行了这条范围查询语句，注意查询条件值的记录（id 为 6）并不存在于表中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;begin&lt;/span&gt;;&lt;br/&gt;Query OK, 0 rows affected (0.00 sec)&lt;br/&gt;&lt;br/&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &amp;lt; &lt;span&gt;6&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+--------+-----+&lt;/span&gt;&lt;br/&gt;| id | name   | age |&lt;br/&gt;+&lt;span&gt;----+--------+-----+&lt;/span&gt;&lt;br/&gt;|  1 | 路飞   |  19 |&lt;br/&gt;|  5 | 索隆   |  21 |&lt;br/&gt;+&lt;span&gt;----+--------+-----+&lt;/span&gt;&lt;br/&gt;3 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务 A 加锁变化过程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最开始要找的第一行是 id = 1，于是对该主键索引加的是范围为  (-∞, 1] 的 next-key 锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，所以对该主键索引加的是范围为  (1, 5] 的 next-key 锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于扫描到的第二行记录（id = 5），满足 id &amp;lt; 6 条件，而且也没有达到终止扫描的条件，接着会继续扫描。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扫描到的第三行是 id = 10，该记录不满足 id &amp;lt; 6 条件的记录，所以 id = 10 这一行记录的锁会&lt;strong&gt;退化成间隙锁&lt;/strong&gt;，于是对该主键索引加的是范围为  (5, 10) 的间隙锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于扫描到的第三行记录（id = 10），不满足 id &amp;lt; 6 条件，达到了终止扫描的条件，于是停止扫描。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的分析中，可以得知事务 A 在主键索引上加了三个 X 型的锁：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6901565995525727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VWZbZR5fjJOTxxYDWXrcGYkriaNw4LM57hTgYz60L1NSicXPDibT26ENOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 id = 1 这条记录的主键索引上，加了范围为  (-∞, 1] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 id = 5 这条记录的主键索引上，加了范围为  (1, 5] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 5 的这一条记录，同时也无法插入 id 值为 2、3、4 的这一些新记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 id = 10 这条记录的主键索引上，加了范围为 (5, 10) 的间隙锁，意味着其他事务无法插入 id 值为 6、7、8、9 的这一些新记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以通过 &lt;code&gt;select * from performance_schema.data_locks\G;&lt;/code&gt; 这条语句来看看事务 A 加了什么锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下，我这里只截取了行级锁的内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.17621776504298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VQFfbkLszf3o4w9kxFdDRNnR5NJIYibCcUj83UvgW0ctCWusYugkLSDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图中的分析中，也可以得知事务 A 在主键索引加的三个锁，就是我们前面分析出那三个锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这次范围查询的条件是「小于」，但是查询条件值的记录不存在于表中（ id 为 6 的记录不在表中），所以如果事务 A 的范围查询的条件改成 &amp;lt;= 6 的话，加的锁还是和范围查询条件为 &amp;lt; 6 是一样的。大家自己也验证下这个结论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，&lt;strong&gt;针对「小于或者小于等于」的唯一索引范围查询，如果条件值的记录不在表中，那么不管是「小于」还是「小于等于」的范围查询，扫描到终止范围查询的记录时，该记录中索引的 next-key 锁会退化成间隙锁，其他扫描的记录，则是在这些记录的索引上加 next-key 锁&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实验二：针对「小于等于」的范围查询时，查询条件值的记录「存在」表中的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设事务 A 执行了这条范围查询语句，注意查询条件值的记录（id 为 5）存在于表中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;begin&lt;/span&gt;;&lt;br/&gt;Query OK, 0 rows affected (0.00 sec)&lt;br/&gt;&lt;br/&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &amp;lt;= &lt;span&gt;5&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+--------+-----+&lt;/span&gt;&lt;br/&gt;| id | name   | age |&lt;br/&gt;+&lt;span&gt;----+--------+-----+&lt;/span&gt;&lt;br/&gt;|  1 | 路飞   |  19 |&lt;br/&gt;|  5 | 索隆   |  21 |&lt;br/&gt;+&lt;span&gt;----+--------+-----+&lt;/span&gt;&lt;br/&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务 A 加锁变化过程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最开始要找的第一行是 id = 1，于是对该记录加的是范围为  (-∞, 1] 的 next-key 锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，于是对该记录加的是范围为  (1, 5] 的 next-key 锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于主键索引具有唯一性，不会存在两个 id = 5 的记录，所以不会再继续扫描，于是停止扫描。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的分析中，可以得到&lt;strong&gt;事务 A 在主键索引上加了 2 个 X 型的锁&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5391498881431768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4Vqw5rRckU3XVicsDj2OkibQRmI80Sa0redTjymb1LC7x2n0N7880h2lGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 id = 1 这条记录的主键索引上，加了范围为  (-∞, 1] 的 next-key 锁。意味着其他事务即无法更新或者删除 id = 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 id = 5 这条记录的主键索引上，加了范围为  (1, 5] 的 next-key 锁。意味着其他事务即无法更新或者删除 id = 5 的这一条记录，同时也无法插入 id 值为 2、3、4 的这一些新记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以通过 &lt;code&gt;select * from performance_schema.data_locks\G;&lt;/code&gt; 这条语句来看看事务 A 加了什么锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下，我这里只截取了行级锁的内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8619718309859155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VfnbkAEJXBrAic6Gdzse4807bCBWCYLLib2FTick9Ulj42J3Sgg1evaibKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1420&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图中的分析中，可以得到事务 A 在主键索引上加了两个 X 型 next-key 锁，分别是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 id = 1 这条记录的主键索引上，加了范围为  (-∞, 1] 的 next-key 锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 id = 5 这条记录的主键索引上，加了范围为(1, 5 ] 的 next-key 锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实验三：再来看针对「小于」的范围查询时，查询条件值的记录「存在」表中的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果事务 A 的查询语句是小于的范围查询，且查询条件值的记录（id 为 5）存在于表中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &amp;lt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务 A 加锁变化过程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最开始要找的第一行是 id = 1，于是对该记录加的是范围为  (-∞, 1] 的 next-key 锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，该记录是第一条不满足 id &amp;lt; 5 条件的记录，于是**该记录的锁会退化为间隙锁，锁范围是 (1,5)**。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于找到了第一条不满足 id &amp;lt; 5 条件的记录，于是停止扫描。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以得知，此时&lt;strong&gt;事务 A 在主键索引上加了两种 X 型锁：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6812080536912751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VHHAxGic69WKjReHlA0hrwXZOhjbUeiakUg9DoCK96zYmQQBiaKhJUdiaoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在 id = 1 这条记录的主键索引上，加了范围为  (-∞, 1] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在 id = 5 这条记录的主键索引上，加了范围为 (1,5) 的间隙锁，意味着其他事务无法插入 id 值为 2、3、4 的这一些新记录。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以通过 &lt;code&gt;select * from performance_schema.data_locks\G;&lt;/code&gt; 这条语句来看看事务 A 加了什么锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下，我这里只截取了行级锁的内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9188790560471977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4V0iaE0bjUrZdWqIjGdylYDm36sLDeIxuB1W0gLMnBNfS9HCicNpEHMqZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1356&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图中的分析中，可以得到事务 A 在主键索引上加了 &lt;strong&gt;X 型的范围为  (-∞, 1] 的 next-key 锁，和 X 型的范围为 (1, 5) 的间隙锁&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，通过前面这三个实验，可以得知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在针对「小于或者小于等于」的唯一索引（主键索引）范围查询时，存在这两种情况会将索引的 next-key 锁会退化成间隙锁的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当条件值的记录「不在」表中时，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的主键索引中的 next-key 锁会&lt;strong&gt;退化成间隙锁&lt;/strong&gt;，其他扫描到的记录，都是在这些记录的主键索引上加 next-key 锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当条件值的记录「在」表中时：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果是「小于」条件的范围查询，扫描到终止范围查询的记录时，该记录的主键索引中的 next-key 锁会&lt;strong&gt;退化成间隙锁&lt;/strong&gt;，其他扫描到的记录，都是在这些记录的主键索引上，加 next-key 锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的主键索引中的 next-key 锁「不会」退化成间隙锁，其他扫描到的记录，都是在这些记录的主键索引上加 next-key 锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;非唯一索引等值查询&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们用非唯一索引进行等值查询的时候，&lt;strong&gt;因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是&lt;strong&gt;非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的  next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当查询的记录「不存在」时，&lt;strong&gt;扫描到第一条不符合条件的二级索引记录，该二级索引的  next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下里用两个实验来说明。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、记录不存在的情况&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实验一：针对非唯一索引等值查询时，查询的值不存在的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来说说非唯一索引等值查询时，查询的记录不存在的情况，因为这个比较简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设事务 A 对非唯一索引（age）进行了等值查询，且表中不存在 age = 25 的记录。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;begin&lt;/span&gt;;&lt;br/&gt;Query OK, 0 rows affected (0.00 sec)&lt;br/&gt;&lt;br/&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; age = &lt;span&gt;25&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;Empty &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务 A 加锁变化过程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定位到第一条不符合查询条件的二级索引记录，即扫描到 age = 39，于是**该二级索引的  next-key 锁会退化成间隙锁，范围是 (22, 39)**。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;停止查询&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务 A 在 age = 39 记录的二级索引上，加了 X 型的间隙锁，范围是  (22, 39)。意味着其他事务无法插入 age 值为 23、24、25、26、....、38 这些新记录。不过对于插入 age = 22 和 age = 39 记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，会在后面说。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32456140350877194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VnicoNicj0v5ek4Dp7nYSX4PGgLrCPKvhxkMsXPY50db0CSXfpC7jtpEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1254&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以通过 &lt;code&gt;select * from performance_schema.data_locks\G;&lt;/code&gt; 这条语句来看看事务 A 加了什么锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下，我这里只截取了行级锁的内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5237341772151899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VluuiaGUALib72Ric5638NSapiaHYTpIl58ibibr1VyFW9ERkkeGnsficPUzRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1264&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图的分析，可以看到，事务 A 在 age = 39 记录的二级索引上（INDEX_NAME: index_age  ），加了范围为 (22, 39) 的 X 型间隙锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果有其他事务插入了 age 值为 23、24、25、26、....、38 这些新记录，那么这些插入语句都会发生阻塞。不过对于插入 age = 39 记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，接下来我们就说！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当有一个事务持有二级索引的间隙锁 (22, 39) 时，什么情况下，可以让其他事务的插入 age = 22 或者 age = 39 记录的语句成功？又是什么情况下，插入  age = 22 或者 age = 39 记录时的语句会被阻塞？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先要清楚，什么情况下插入语句会发生阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;插入语句在插入一条记录之前，需要先定位到该记录在 B+树 的位置，如果插入的位置的下一条记录的索引上有间隙锁，才会发生阻塞&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分析二级索引的间隙锁是否可以成功插入记录时，我们要先要知道二级索引树是如何存放记录的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二级索引树是按照二级索引值（age列）按顺序存放的，在相同的二级索引值情况下， 再按主键 id 的顺序存放。知道了这个前提，我们才能知道执行插入语句的时候，插入的位置的下一条记录是谁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于前面的实验，事务 A 是在 age = 39 记录的二级索引上，加了 X 型的间隙锁，范围是  (22, 39)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插入 age = 22 记录的成功和失败的情况分别如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当其他事务插入一条 age = 22，id = 3 的记录的时候，在二级索引树上定位到插入的位置，而&lt;strong&gt;该位置的下一条是 id = 10、age = 22 的记录，该记录的二级索引上没有间隙锁，所以这条插入语句可以执行成功&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当其他事务插入一条 age = 22，id = 12 的记录的时候，在二级索引树上定位到插入的位置，而&lt;strong&gt;该位置的下一条是 id = 20、age = 39 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插入 age = 39 记录的成功和失败的情况分别如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当其他事务插入一条 age = 39，id = 3 的记录的时候，在二级索引树上定位到插入的位置，而&lt;strong&gt;该位置的下一条是 id = 20、age = 39 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当其他事务插入一条 age = 39，id = 21 的记录的时候，在二级索引树上定位到插入的位置，而&lt;strong&gt;该位置的下一条记录不存在，也就没有间隙锁了，所以这条插入语句可以插入成功&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，&lt;strong&gt;当有一个事务持有二级索引的间隙锁 (22, 39) 时，插入 age = 22 或者 age = 39 记录的语句是否可以执行成功，关键还要考虑插入记录的主键值，因为「二级索引值（age列）+主键值（id列）」才可以确定插入的位置，确定了插入位置后，就要看插入的位置的下一条记录是否有间隙锁，如果有间隙锁，就会发生阻塞，如果没有间隙锁，则可以插入成功&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了这个结论之后，我们再回过头看，非唯一索引等值查询时，查询的记录不存在时，执行&lt;code&gt;select * from performance_schema.data_locks\G;&lt;/code&gt; 输出的结果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5324074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VNbqcdKZGdiaBFnpgWUCocJ9gBRyMeRPnUlKvQFexmZwTfZnzXrfquyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;432&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面分析输出结果的时候，我说的结论是：「&lt;em&gt;事务 A 在 age = 39 记录的二级索引上（INDEX_NAME: index_age  ），加了范围为 (22, 39) 的 X 型间隙锁&lt;/em&gt;」。这个结论其实还不够准确，因为只考虑了 LOCK_DATA 第一个数值（39），没有考虑 LOCK_DATA 第二个数值（20）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那 &lt;code&gt;LOCK_DATA：39，20&lt;/code&gt; 是什么意思？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;LOCK_DATA 第一个数值，也就是 39， 它代表的是 age 值。从前面我们也知道了，LOCK_DATA 第一个数值是 next-key 锁和间隙锁&lt;strong&gt;锁住的范围的右边界值&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LOCK_DATA 第二个数值，也就是 20， 它代表的是 id 值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以 LOCK_DATA 要多显示一个数值（ID值），是因为针对「当某个事务持有非唯一索引的 (22, 39) 间隙锁的时候，其他事务是否可以插入 age = 39 新记录」的问题，还需要考虑插入记录的 id 值。而 &lt;strong&gt;LOCK_DATA 的第二个数值，就是说明在插入 age = 39 新记录时，哪些范围的 id 值是不可以插入的&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此， &lt;code&gt;LOCK_DATA：39，20&lt;/code&gt; + &lt;code&gt;LOCK_MODE : X, GAP&lt;/code&gt; 的意思是，事务 A 在 age = 39 记录的二级索引上（INDEX_NAME: index_age ），加了 age 值范围为 (22, 39) 的 X 型间隙锁，**同时针对其他事务插入 age 值为 39 的新记录时，不允许插入的新记录的 id 值小于 20 **。如果插入的新记录的 id 值大于 20，则可以插入成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我们无法从&lt;code&gt;select * from performance_schema.data_locks\G;&lt;/code&gt; 输出的结果分析出「在插入 age =22 新记录时，哪些范围的 id 值是可以插入成功的」，这时候就&lt;strong&gt;得自己画出二级索引的 B+ 树的结构，然后确定插入位置后，看下该位置的下一条记录是否存在间隙锁，如果存在间隙锁，则无法插入成功，如果不存在间隙锁，则可以插入成功&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、记录存在的情况&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实验二：针对非唯一索引等值查询时，查询的值存在的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设事务 A 对非唯一索引（age）进行了等值查询，且表中存在 age = 22 的记录。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;begin&lt;/span&gt;;&lt;br/&gt;Query OK, 0 rows affected (0.00 sec)&lt;br/&gt;&lt;br/&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; age = &lt;span&gt;22&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+--------+-----+&lt;/span&gt;&lt;br/&gt;| id | name   | age |&lt;br/&gt;+&lt;span&gt;----+--------+-----+&lt;/span&gt;&lt;br/&gt;| 10 | 山治   |  22 |&lt;br/&gt;+&lt;span&gt;----+--------+-----+&lt;/span&gt;&lt;br/&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务 A 加锁变化过程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;由于不是唯一索引，所以肯定存在值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，最开始要找的第一行是 age = 22，于是对该二级索引记录加上范围为 (21, 22] 的 next-key 锁。同时，因为 age = 22 符合查询条件，于是对 age = 22 的记录的主键索引加上记录锁，即对 id = 10 这一行加记录锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接着继续扫描，扫描到的第二行是 age = 39，该记录是第一个不符合条件的二级索引记录，所以该二级索引的  next-key 锁会&lt;strong&gt;退化成间隙锁&lt;/strong&gt;，范围是 (22, 39)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;停止查询。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，事务 A 对主键索引和二级索引都加了 X 型的锁：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4437799043062201&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VYvtIQInzPuW7T1T6LVw3wVZJv13DAicFxXuqnc8llVSoXChQlXiaopCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;836&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主键索引：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 id = 10 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 10 的这一行记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;二级索引（非唯一索引）：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 age = 22 这条记录的二级索引上，加了范围为 (21, 22] 的 next-key 锁，意味着其他事务无法更新或者删除 age = 22 的这一些新记录，不过对于插入 age = 20 和 age = 21 新记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，会在后面说。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 age = 39 这条记录的二级索引上，加了范围 (22, 39) 的间隙锁。意味着其他事务无法插入 age 值为 23、24、..... 、38 的这一些新记录。不过对于插入 age = 22 和 age = 39 记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，会在后面说。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以通过 &lt;code&gt;select * from performance_schema.data_locks\G;&lt;/code&gt; 这条语句来看看事务 A 加了什么锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下，我这里只截取了行级锁的内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1851851851851851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VmAm2LcnLCUskPaiaiczMEWZSNXqr1T5B1lia6wJGWtvicn6GK4Ix4V34yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1512&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图的分析，可以看到，事务 A 对二级索引（INDEX_NAME: index_age ）加了两个 X 型锁，分别是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 age = 22 这条记录的二级索引上，加了范围为 (21, 22] 的 next-key 锁，意味着其他事务无法更新或者删除 age = 22 的这一些新记录，针对是否可以插入 age = 21 和 age = 22 的新记录，分析如下：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;是否可以插入 age = 21 的新记录，还要看插入的新记录的 id 值，&lt;strong&gt;如果插入 age = 21 新记录的 id 值小于 5，那么就可以插入成功&lt;/strong&gt;，因为此时插入的位置的下一条记录是 id = 5，age = 21 的记录，该记录的二级索引上没有间隙锁。&lt;strong&gt;如果插入 age = 21 新记录的 id 值大于 5，那么就无法插入成功&lt;/strong&gt;，因为此时插入的位置的下一条记录是 id = 20，age = 39 的记录，该记录的二级索引上有间隙锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否可以插入 age = 22 的新记录，还要看插入的新记录的 id 值，从 &lt;code&gt;LOCK_DATA : 22, 10&lt;/code&gt; 可以得知，其他事务插入 age 值为 22 的新记录时，&lt;strong&gt;如果插入的新记录的 id 值小于 10，那么插入语句会发生阻塞；如果插入的新记录的 id 大于 10，还要看该新记录插入的位置的下一条记录是否有间隙锁，如果没有间隙锁则可以插入成功，如果有间隙锁，则无法插入成功&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;在 age = 39 这条记录的二级索引上，加了范围 (22, 39) 的间隙锁。意味着其他事务无法插入 age 值为 23、24、..... 、38 的这一些新记录，针对是否可以插入 age = 22 和 age = 39 的新记录，分析如下：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;是否可以插入 age = 22 的新记录，还要看插入的新记录的 id 值，&lt;strong&gt;如果插入 age = 22 新记录的 id 值小于 10，那么插入语句会被阻塞，无法插入&lt;/strong&gt;，因为此时插入的位置的下一条记录是 id = 10，age = 22 的记录，该记录的二级索引上有间隙锁（ age = 22 这条记录的二级索引上有 next-key 锁）。&lt;strong&gt;如果插入 age = 21 新记录的 id 值大于 10，也无法插入&lt;/strong&gt;，因为此时插入的位置的下一条记录是 id = 20，age = 39 的记录，该记录的二级索引上有间隙锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否可以插入 age = 39 的新记录，还要看插入的新记录的 id 值，从 &lt;code&gt;LOCK_DATA : 39, 20&lt;/code&gt; 可以得知，其他事务插入 age 值为 39 的新记录时，&lt;strong&gt;如果插入的新记录的 id 值小于 20，那么插入语句会发生阻塞，如果插入的新记录的 id 大于 20，则可以插入成功&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，事务 A  还对主键索引（INDEX_NAME: PRIMARY ）加了X 型的记录锁：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 id = 10 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 10 的这一行记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为什么这个实验案例中，需要在二级索引索引上加范围 (22, 39) 的间隙锁？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要找到这个问题的答案，我们要明白 MySQL 在可重复读的隔离级别场景下，为什么要引入间隙锁？其实&lt;strong&gt;是为了避免幻读现象的发生&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这个实验案例中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; age = &lt;span&gt;22&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果事务 A 不在二级索引索引上加范围 (22, 39) 的间隙锁，只在二级索引索引上加范围为 (21, 22] 的 next-key 锁的话，那么就会有幻读的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我也说过，在非唯一索引上加了范围为 (21, 22] 的 next-key 锁，是无法完全锁住 age  = 22 新记录的插入，因为对于是否可以插入 age = 22 的新记录，还要看插入的新记录的 id 值，从 &lt;code&gt;LOCK_DATA : 22, 10&lt;/code&gt; 可以得知，其他事务插入 age 值为 22 的新记录时，如果插入的新记录的 id 值小于 10，那么插入语句会发生阻塞，&lt;strong&gt;如果插入的新记录的 id 值大于 10，则可以插入成功&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，只在二级索引索引（非唯一索引）上加范围为 (21, 22] 的 next-key 锁，其他事务是有可能插入 age 值为 22 的新记录的（比如插入一个 age = 22，id = 12 的新记录），那么如果事务 A 再一次查询 age = 22 的记录的时候，前后两次查询 age = 22 的结果集就不一样了，这时就发生了幻读的现象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么当在 age = 39 这条记录的二级索引索引上加了范围为 (22, 39) 的间隙锁后，其他事务是无法插入一个 age = 22，id = 12 的新记录，因为当其他事务插入一条 age = 22，id = 12 的新记录的时候，在二级索引树上定位到插入的位置，而该位置的下一条是 id = 20、age = 39 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功，这样就避免幻读现象的发生&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，为了避免幻读现象的发生，就需要在二级索引索引上加范围 (22, 39) 的间隙锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;非唯一索引范围查询&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于&lt;strong&gt;非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况&lt;/strong&gt;，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就带大家简单分析一下，事务 A 的这条范围查询语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;begin&lt;/span&gt;;&lt;br/&gt;Query OK, 0 rows affected (0.00 sec)&lt;br/&gt;&lt;br/&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; age &amp;gt;= &lt;span&gt;22&lt;/span&gt;  &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-----------+-----+&lt;/span&gt;&lt;br/&gt;| id | name      | age |&lt;br/&gt;+&lt;span&gt;----+-----------+-----+&lt;/span&gt;&lt;br/&gt;| 10 | 山治      |  22 |&lt;br/&gt;| 20 | 香克斯    |  39 |&lt;br/&gt;+&lt;span&gt;----+-----------+-----+&lt;/span&gt;&lt;br/&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.01&lt;/span&gt; sec)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务 A 的加锁变化：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最开始要找的第一行是 age = 22，虽然范围查询语句包含等值查询，但是这里不是唯一索引范围查询，所以是不会发生退化锁的现象，因此对该二级索引记录加 next-key 锁，范围是 (21, 22]。同时，对 age = 22 这条记录的主键索引加记录锁，即对 id = 10 这一行记录的主键索引加记录锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于是范围查询，接着继续扫描已经存在的二级索引记录。扫面的第二行是 age = 39 的二级索引记录，于是对该二级索引记录加 next-key 锁，范围是 (22, 39]，同时，对 age = 39 这条记录的主键索引加记录锁，即对 id = 20 这一行记录的主键索引加记录锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虽然我们看见表中最后一条二级索引记录是 age = 39 的记录，但是实际在 Innodb 存储引擎中，会用一个特殊的记录来标识最后一条记录，该特殊的记录的名字叫 supremum pseudo-record ，所以扫描第二行的时候，也就扫描到了这个特殊记录的时候，会对该二级索引记录加的是范围为  (39, +∞] 的 next-key 锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;停止查询&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，事务 A 对主键索引和二级索引都加了 X 型的锁：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46232626188734455&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZceY2jjakaLcWiapUB3Qbh4VhkgPficSUgJJAwemSFQiaxeRVibtnicUS2L4U7GdXdWHwUkghiamZpqRUYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1367&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主键索引（id 列）：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 id = 10 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 10 的这一行记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 id = 20 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 20 的这一行记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;二级索引（age 列）：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 age = 22 这条记录的二级索引上，加了范围为 (21, 22] 的 next-key 锁，意味着其他事务无法更新或者删除 age = 22 的这一些新记录，不过对于是否可以插入 age = 21 和 age = 22 的新记录，还需要看新记录的 id 值，有些情况是可以成功插入的，而一些情况则无法插入，具体哪些情况，我们前面也讲了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 age = 39 这条记录的二级索引上，加了范围为 (22, 39] 的 next-key 锁，意味着其他事务无法更新或者删除 age = 39 的这一些记录，也无法插入 age 值为 23、24、25、...、38 的这一些新记录。不过对于是否可以插入 age = 22 和 age = 39 的新记录，还需要看新记录的 id 值，有些情况是可以成功插入的，而一些情况则无法插入，具体哪些情况，我们前面也讲了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在特殊的记录（supremum pseudo-record）的二级索引上，加了范围为 (39, +∞] 的 next-key 锁，意味着其他事务无法插入 age 值大于 39 的这些新记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在 age &amp;gt;= 22  的范围查询中，明明查询 age = 22 的记录存在并且属于等值查询，为什么不会像唯一索引那样，将 age = 22 记录的二级索引上的 next-key 锁退化为记录锁？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 age 字段是非唯一索引，不具有唯一性，所以如果只加记录锁（记录锁无法防止插入，只能防止删除或者修改），就会导致其他事务插入一条 age = 22 的记录，这样前后两次查询的结果集就不相同了，出现了幻读现象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;没有加索引的查询&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的案例，我们的查询语句都有使用索引查询，也就是查询记录的时候，是通过索引扫描的方式查询的，然后对扫描出来的记录进行加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不只是锁定读查询语句不加索引才会导致这种情况，update 和 delete 语句如果查询条件不加索引，那么由于扫描的方式是全表扫描，于是就会对每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，&lt;strong&gt;在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了&lt;/strong&gt;，这是挺严重的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我以 &lt;strong&gt;MySQL 8.0.26&lt;/strong&gt; 版本，在可重复读隔离级别之下，做了几个实验，让大家了解了唯一索引和非唯一索引的行级锁的加锁规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里总结下，  MySQL 行级锁的加锁规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唯一索引等值查询：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会&lt;strong&gt;退化成「记录锁」&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会&lt;strong&gt;退化成「间隙锁」&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非唯一索引等值查询：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后&lt;strong&gt;在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当查询的记录「不存在」时，&lt;strong&gt;扫描到第一条不符合条件的二级索引记录，该二级索引的  next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非唯一索引和主键索引的范围查询的加锁规则不同之处在于：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;唯一索引在满足一些条件的时候，索引的 next-key lock 退化为间隙锁或者记录锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非唯一索引范围查询，索引的 next-key lock 不会退化为间隙锁和记录锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实理解 MySQL 为什么要这样加锁，主要要以避免幻读角度去分析，这样就很容易理解这些加锁的规则了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一件很重要的事情，在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，&lt;strong&gt;如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了&lt;/strong&gt;，这是挺严重的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就说到这啦， 我们下次见啦！&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODAzNDg4NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfTwwjfpJhXgIrYMgtVcLhQQBVb02clZfKicbxaibSTNJqXe9Zu8ydiavZKJWJAIhKcnD9hBuKU92JZQ/0?wx_fmt=png&quot; data-nickname=&quot;小林coding&quot; data-alias=&quot;CodingLin&quot; data-signature=&quot;专注图解计算机基础，让天下没有难懂的八股文！刷题网站：xiaolincoding.com&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>