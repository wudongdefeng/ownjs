<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e21ecf963913e5d2182f43cef1bdba9d</guid>
<title>肝完这篇稳定性建设万字总结，谁还吐槽我线上不稳定！</title>
<link>https://toutiao.io/k/dn42nvi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzkwOTIxNDQ3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YRIaicYx5pzj5Cxwick8DamnOgbTJu96QTibKyHEDZt1815yOV1r27oZ6HgoYTEYWYLRz4jIV4iasHgg/0?wx_fmt=png&quot; data-nickname=&quot;dbaplus社群&quot; data-alias=&quot;dbaplus&quot; data-signature=&quot;围绕Database、BigData、AIOps的企业级专业社群。资深大咖、技术干货，每天精品原创文章推送，每周线上技术分享，每月线下技术沙龙，每季度Gdevops&amp;amp;DAMS行业大会.&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;俗话说“缺啥补啥”。想起写这么一篇文章，不是因为自己和团队稳定性建设做得有多好，相反，最近经常被吐槽线上不“稳定”......&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回想当年，作者在某度第一个项目中，从0到1撸了一个多月的码（检索模块c/c++）。后面QA测试N轮，硬是没能提出几(yi)个有效bug，线上似乎也没啥动静。现在却被人指责稳定性做得不好，这事儿看起来不能忍。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;“稳定”这个词，从用户到ZF机关，一线研发到大老板，大家似乎都会经常提及。不过作者发现，他们所谓的稳定性，也不见得就是一回事。网上搜了搜，没看到有什么公认的定义，系统论述这个话题的文档也不多，讲实战的倒是不少。本文中，作者试图做个相对“系统”的论述，重点讨论“服务稳定性”是什么，应该如何建设。作者之前经历绝大部分时间都在做后端开发，能力和视野所限，难免会偏服务端。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;相比于“系统性”，很多优秀的程序员都只喜欢听所谓的“干货”。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在“系统性”和“干货”之间不断地纠结中，作者艰难地完成了本文。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;全文基本没什么新鲜玩意，很多都是老生常谈，也借鉴了非常多的来源。作者只是努力整理并重新组织在了一起。因为来源太庞杂，我就没法一一例举相关出处，如有侵权，请联系作者删除。这里一并谢过执导过我，帮助过我和分享自己的知识到互联网的所有大佬们！&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;我们都在聊什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;“稳定性”其实还挺难定义的。让我们先看几个英文单词：Availability, Reliability, Stability。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经常被翻译成可用性。看到这个单词，相信大部分人脑子里应该都会呈现很多个9。看图1，4个9的稳定性意味着一年宕机时间不能超过53min，其实是非常难的。可用性这个概念关注的是系统故障时长。实际上，我们平常会更关注这个宕机时间如何定义的。很多人说自己服务可用性是99.99%，不要轻易相信。你去帮他review下，会惊喜地发现，他可以通过宕机时间本身的定义任意调整这个值。所以如果是上下游关系，还是先把这个指标定义清楚再聊别的会比较好。常见的定义举例：影响核心功能(e.g.下单)成功率20%以上所持续时间等等。这里的X%还挺重要的。后面的讨论中，我们可以依据这个百分比，设计我们的灰度方案等。以免发布个小流量，还搞出P0，不合适。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;432&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.7602956705385427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8Yia7via7jDqYC2FtDdAZHibgVob5obDpAZVYgqcJ0ly0icWOAXJ9bBAO8aZyA2dSnr32iafDCsZQarqHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;947&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1 &lt;/span&gt;&lt;span&gt;N个9的稳定性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经常被翻译成可靠性。相对于可用性，可靠性关注的可能会更泛一些。在服务化的场景下，大家会经常提到SLA。SLA是对一个服务可靠程度的相对量化的约定。其中就可以包括服务可用时长、接口响应时间(如99分位)、错误率、集群吞吐率等等。SLA建议尽量用书面形式提供，并且服务提供方和调用方一同签字画押。一般还有配套的奖惩措施才能工作的更好。签字画押，是为了后面少扯皮。很多时候，处理线上事故总是没有事故定责时候来的令人紧张刺激。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果下游没有提供明确的SLA，我们就得自己根据历史数据猜测下游各项指标，以便写出还算合理的代码，比如超时时间、重试次数、限流大小等等都跟下游服务能力密切相关。当然下游也是动态的，如果对方都无法提供明确的SLA，那其实大家都挺难的。咱们自己提供的服务，最好都有明确的量化指标，随时提供给上游。如果给不出来，说明我们对自己服务还不够了解，没有足够的掌控能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是内部系统，老板还会经常关注线上问题数量和等级分布等。处理P0事故紧不紧张？这些都是在努力量化一个系统的可靠程度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般翻译成稳定性。通常是指一个系统如果输入保持不变，输出也不会随着时间发生变化。但是这个稳定性，大概不是我们经常在讨论的稳定性。你会发现歪果大佬们一般讨论“稳定性”的时候喜欢用Reliability，而国内大佬们却喜欢用“稳定性”。yy一下，这很可能又是个中国特色的表述了。大概来自于前辈们对我dang“维稳工作”的深刻印象。你会发现我们所谓的“稳定性建设”跟传统意义上的“维稳工作”基本思路是惊人一致的。监控，隔离，应急处置，特殊事件保障，演练，宣传培训等等，请各位客官自行发挥想象力...只是互联网环境下，我们不太可能期待“输入不变”。而是，在输入经常不确定，且系统在不停地迭代的情况下，确保新老输入都能在预期的时间内得到令用户满意的结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者认为，其实概念可能也没那么重要。“稳定性”这个词儿似乎也很贴切，有点中国特色挺好。稳定性建设的关键是，我们得找到一套大家都认可的指标来衡量他。对于相对独立的服务，作者推荐用SLA去约定一个服务的稳定性，并尽最大努力达成这个承诺。对于服务提供方，SLA不仅是一个承诺，更是对自身量化的要求。&lt;strong&gt;当我们都不敢做出承诺的时候，又何谈稳定性建设，&lt;/strong&gt;何谈责任与成长？至于怎么定义一个“服务”，一是看业务边界，二是看组织架构。很多时候组织架构决定系统架构，而SLA制定过程也跟组织架构密不可分。对于终端团队，我们可以在SLA基础上做一些扩展，比如增加一些体验相关指标。有时候个别后端服务挂了，可以做到对用户无感，反而APP经常crash那可能是个灾难。所以，稳定性也得分层去看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）Dickerson的可靠性层次模型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实作者之前也没听过该大佬。为了准备这边文章无意中搜到的。他据说是前谷哥SRE团队成员。然后后人在谷哥SRE电子书中引述了相关模型。大佬也是借鉴了马斯洛需求层次模型。马老师的这个模型中表示，想得到上一层的满足，你得先保证其下一层已经得到了很好的满足，否则容易“出事儿”。比如，当我们都没饭吃了，哪儿还会去关心哪个行业更卷呢？当然当我们很好地实现了某一层，那下一层需求就会是我们最大的动力来源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;372&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.6557377049180327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8Yia7via7jDqYC2FtDdAZHibgV64NiaYtJ8ic5MhsLXN2IYvC9t1N0Nn9dFdAORURmpcJW3iaCgEu00UkWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1098&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2 马斯洛需求层次&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考M老师的模型，D大佬提出了他的稳定性层次模型，以便帮助SRE团队更好的保障系统稳定性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;492&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.8664259927797834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8Yia7via7jDqYC2FtDdAZHibgV1icib9lztic6EM5kHskIS7SV0SgrhrpVriaiaMWEhgwtyicBGhNbibqTU2TPA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;831&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3 Dickerson可靠新层次模型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在D的模型中，他从SRE的视角出发，将稳定性建设也分了7层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）本文讨论框架&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可能大部分国内互联网公司没有真正的SRE团队。即使有这样的团队，据我所知他们可能更关注一些更宏观的稳定性建设。日常的服务级别的线上稳定性保障，一般都是由研发团队主要负责的(一般是事故主要责任方)。因此本文中从一个一线研发团队视角出发，去讨论稳定性建设该如何做。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事实上不管是R&amp;amp;D还是SRE团队，要关注的问题是相同的，只是视角略有不同。既然上面铺垫了这么多，作者也参考D大佬的层次模型，引出下面的稳定性框架图（向大佬们致敬）。当然所谓框架，也没什么新意，更多是方便我后续组织文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;412&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.7258064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8Yia7via7jDqYC2FtDdAZHibgVAuZgemF1bGrokYAxypsUhgtMMPBfJkdjaNIt0FO4SJewPDjPSMUOZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;992&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4 本文讨论的稳定性建设框架&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在上图的框架下，虽然也有分层，但跟D不同，作者认为没有谁比谁重要或者上层强依赖下层关系。只是为了讨论方便可以分层去看。传说中的“既要也要还要”，总是那么的“正确”。我们很难在这些层次上进行取舍，只能说都很重要。作为一个R&amp;amp;D工程师，我们需要时刻关注所有这些方面的问题，最多可以根据自己团队当前状况和急迫程度判断优先级。下面会逐个去讨论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;稳定性建设该如何做&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为篇幅和视野限制，本文无法求全，也不太可能非常深入。如果能抛砖引玉，作者就很开心了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、梳理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;梳理其实可以没有，理想情况是我们对自己的系统一直都非常熟悉，知道他是怎么工作的，目前他还存在什么问题。但现实可能是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那我们需要梳理什么呢？这个其实没有标准答案，得看系统和团队当前情况而定。下图针对一般情况罗列了一些常见的梳理项。可以根据实际情况进行增减。这也适用于我们快速去熟悉一个新接手的系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;766&quot; data-backw=&quot;568&quot; data-ratio=&quot;1.3486111111111112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8Yia7via7jDqYC2FtDdAZHibgVOcPPOy7kbmxCKgynFxAYwo1icWJNhCQfxZG129dkfo6iaziaDvnp641JQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5 梳理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;梳理的过程很多时候都不是一个人可以完成的。我们需要协调很多人参与进来，并进行集中串讲，共同分析等。不要一梳理就梳理几个月。类似迭代开发，我们也可以逐步去梳理，甚至还需要跌带着去做。当一个团队人员流动比较大时，新人串讲也是挺好的一个时机。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一个相对理想的梳理工作完成之后，我们大概能知道当前系统现状是什么，有哪些稳定性隐患。很多时候知道隐患在哪里，比排除和优化更重要。剩下的就是按优先级排期逐一解决了。梳理本身也会帮助我们重新审视自己的系统，加深对他的理解。这对于后续迭代开发，线上问题跟进等都有莫大的好处。所以，当觉得自己团队没事儿干的时候(往往都是错觉)，可以让大家多去梳理(串讲)一遍自己的系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一步，还有个重要产出是：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;哪些业务指标是需要重点关注的，核心接口有哪些。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这部分在下一节中会重点讨论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、监控&amp;amp;Trace&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）监控&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;监控大家应该都不陌生。在上文中我们也梳理出来了当前服务核心指标和核心接口都有哪些(新项目应该是在设计阶段就应该定义好)。我们需要重点围绕这些指标和接口进行监控建设。监控主要目标是当服务异常时，我们能第一时间感知，以便尽早介入，尽快止损。另外，通过合理的监控设计，我们还可能尽量的缩小问题范围，帮助我们定位问题根因。缺失有效监控，我们就是个瞎子，每天都掉坑也是正常的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;监控大致可以分成三层去看，本文只讨论业务层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;144&quot; data-backw=&quot;568&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25289017341040465&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Yia7via7jDqYC2FtDdAZHibgVWMUkapnJ4BHG28zOMOBGviavp7v2eIMjfX7WUFNecQONvibDqunlxonA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;692&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个经常不被重视，但他却是最重要的。我们应该首先站在业务视角去看到底应该关注哪些指标，然后再去想办法监控这些指标。既然说是业务指标，肯定就跟业务本身有关了，所以各个系统可能都不一样。举例，对于一个订单系统，那么我们关注的核心指标可能有：下单量、成单量、取消量、超时未支付量等等。然后我们想办法对这些指标进行准实时监控。当这些指标有明显异常，可以即刻发出告警。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当业务数据较为稀疏时，秒级监控可能经常会误告警，我们可以适当把时间窗口拉长一点看，比如降级为分钟级监控。甚至我们可以根据业务高峰期等自动调整监控周期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里核心是如何定义好一个指标。当指标定义明确，以咱们的聪明才智相信总能有办法监控他，并且总能找到一些报警策略(不行上AI)，使其足够灵敏，误报警概率也还能接受。常见的监控手段包括基于log和数据库binlog的监控。极端一点的情况，我们可能需要在业务代码里单独为这些指标打log(记文本或写库)。所以说，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;监控设计也是系统设计的必要组成部分，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;最好前期就考虑好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接口监控应该不用我多说。重点就那三个指标，QPS、延迟和错误率。这里错误率的统计，对于错误码规范有要求以外，其他基本都是标配。做细致一点，需要对接口调用方单独做监控。比如接口QPS突然飙升，我们需要尽快知道到底是哪个来源。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下游可能是服务提供方、也可能是个中间件。中间件一般都有单独团队维护，他们会提供通用的监控大盘等。业务方要做的更多是从自己的视角看这些被依赖方他的实际运行情况如何。因为绝大部分依赖都是通过RPC进行的，所以类似接口监控，我们需要关注下游调用成功率，响应时间等等。当然如果下游都提供了监控大盘，可以考虑把两者合并一下，找起来方便。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;呈现很多时候都挺重要的，就像如果有人PPT写得好，你不能否认他其他方面也大概率比咱更优秀。为了看起来方便，我们需要分层去建设监控大盘。每个大盘也不能太大了。大盘在线上走查，上线回归等场景必不可少。这里没什么新鲜的，把分层设计好就差不多了，不啰嗦了。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）告警&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;告警策略其实可以复杂到很多大佬都在谈AI了。常见的就是同比异常、环比异常、超阈值等。策略核心就是在召回和准确性之间各种折中。作者的观点是宁可误报，不能漏报。误报得多了，我们自然就有动力去优化了。至于告警方式，传统的，电话、短信为主，钉钉、email为辅。报警内容一定要尽量多的带一些具体指标项和数据等(注意信息安全，运营商你们懂得)，以便我们快速判断问题严重性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多时候，我们报警策略本身可能也会不稳定，也可能设计得不够灵敏。这时候就要求我们去主动去巡视。比如上完线，都去看看大盘是否有异常，值班同学每天定时扫几眼(尤其高峰时)。当然机器和服务太多了，无法人肉去看大盘时，也可以搞一些自动巡视脚本提效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）Trace&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他可以有个高大上的名字“根因分析系统”。通过监控，我们知道系统有问题了，这个还不够。当我们及时止损之后，应该抓紧定位根因。trace系统一般依赖系统日志采集，并通过二次索引，提供快速的查询线上问题和统计分析的能力。通过trace，我们除了追踪单个请求链，还可以生成系统整体拓扑，系统热点分析，整个链路性能分析等等。这里log设计和规范是最关键的。如果系统里的logid(traceid)都还没打通，团队都不知道spanid是个啥的话，那工具其实也可能还不重要。当然最好是这些都在框架层面就解决了，没必要让每个程序员都关注他们的存在(除定位问题时候以外)。最终，trace还是需要有个强大的配套工具支持的。这个数据量可能会很大(降级为采样？)，分析效率又很关键，没有好用的工具，全靠写脚本很多时候都不现实。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、应急处置 &amp;amp; Case Study&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）应急处置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说白了就是线上问题处理。因为每个系统设计和现状，甚至每次遇到的问题都不一样，所以很难搞出一套通用的机制或方法论。这里只是简单聊一聊一些思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;① 责任人&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当线上有问题，我们首先得有明确的责任人去跟进。如果是监控告警发现的问题，那么谁收到告警，谁就应该是那个责任人(不怕多，就怕没人跟)。“首问责任制”听过的朋友大概也能知道我在哪儿被蹂躏过了....其他情况，通过值班机制等保证每个关键时间段(比如高峰期)，都有明确的人能及时跟进。每个团队情况不同，可以自行设计。这个值班人可能是研发，可能是SRE，也可能是个技术支持之类的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;② 判断影响面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为责任人，首先要做到遇事不慌，快速判断影响面。看核心业务大盘是否受影响。影响了核心业务，那就立刻需要升级处理。紧急问题应立即通报。如果业务大盘影响不大，那其他报警叫得再欢，咱们其实也不虚(再论监控的重要性)。一般问题，可以考虑进一步确认影响，或者直接跳到“找根因”环节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;③ 通报&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要明确紧急问题通报范围，让更多的人参与进来协助处理紧急状况。其中至少要包含自己leader。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;④ 止损&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通报后，紧急事件应优先考虑止损。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;唯一共同点是，每次事故原因，起初看起来都很迷，最后定位后都很傻X，而且总是惊人的相似。所以&lt;/span&gt;&lt;strong&gt;&lt;span&gt;应急预案，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;需要平时积累，现场去想，大概率就迟了。预案主要是依据历史事故和架构师们的经验，不断积累的过程。每个业务不同的故障预案都不同。上面止损里简单描述了集中常见故障及处理预案。作者想强调的是，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;预案不应该只是文本，而应该是经过验证的(演练过)极简操作步骤，最好是已经工具化(e.g. XX脚本)的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;⑤ 找根因&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们有效止损之后，应该把精力放在寻找跟因上。如果发现无法快速止损，也别太执着了，至少可以分一部分人力找根因了。定位问题，有时候看起来是一门玄学，大神一出马，往往很快就能破案。而且你会发现，大神总是那几个人。他们为什么比咱快呢？我想，首先肯定不是因为他代码写得好，也不见得有咱写得多(某些人眼里的“技术牛”)。而是，他对系统更熟悉，他了解系统整体架构，知道哪里是一些脆弱环节，容易出问题，上下游依赖情况怎么样，哪个下游比咱还不靠谱；他经常去听各种复盘，知道类似的问题之前出现过，是什么原因导致的；他对各种工具更熟悉，比如trace，监控系统等，所以效率更高。慢慢的他们就形成了一套自己的方法论，甚至可以从现象猜测出几个最可能的原因，然后去逐一验证。可见，平时积累非常重要，要对自己所用的框架，所负责的模块上下游都要做到尽可能多的了解，甚至去多读一读他们的源码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线上如果有稳定复现的环境，可以下线一台服务器专门定位问题。如果线上无法快速定位，可以考虑线下复现。所以&lt;/span&gt;&lt;strong&gt;&lt;span&gt;线下镜像环境&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;也是很重要的。一方面，可以用于平时线下测试，当线上有问题时候，也可以用来复现问题。能复现的问题，其实就没什么难度了。最后，大家一定要相信，没有什么问题是无法定位的，事实也是如此。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多时候无法定位，都是缺少关键日志，所以要养成各种异常分支都需要打个日志的好习惯，我们开始时候不要怕日志多，告警多，等我们无法容忍的时候总会有人去优化他。但是一旦少日志，没告警的时候就欲哭无泪了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根因找到之后，我们需要上线验证，并统计和修复损失了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）Case Study&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实是一种特殊的复盘。每次的线上问题，都是我们成本最高的一次学习机会。所以，一定要珍惜，要认真对待。相信大家也经常做，所以具体复盘模板这些就不用我多说了，相信每个公司都有自己的一套。几个tips：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）不要把Case Study搞成批斗大会。虽然定责很重要，但是不用太纠结这个。我们得有一套相对客观的定责标准，省得有人纠结这个。比如之前我们就约定线上事故由源头负主要责任(很多时候是全部)，什么上游保护下游，上游限流没生效，上游没合理重试这些都是额(che)外(dan)的。还是得想方设法保证自己不挂，挂了就得认。我们更多要去想怎么从失败中学习，不断完善自己的系统。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我能想得到唯一需要我们保护的下游可能是MySQL，因为他实在太老，太脆弱了，可得对她温柔一点。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）围绕根因要多去想是否还有其他类似隐患，要真正做到举一反三，比如排查其他模块是否有类似问题，比如拉上上下游关联系统一起看怎么全链路优化，比如故障期间产品提示等是否可以更友好一点等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）对于发现的问题要做好保护：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、测试&amp;amp;发布&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）测试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;质量跟稳定性很多时候都是划等号的。质量保障是整个软件工程核心活动，是研发人员的职业底线。对于工程团队，如果这个底线没守住，那其他努力都将变得黯淡无光。我们必然要竭尽全力，让问题在上线发布前就发现并解决了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;测试如此重要，以至于国内很多互联网公司都有专职的QA团队。当然，即使有了QA团队，测试工作也并非全部由该团队完全负责。研发人员要对自己编写的代码负全部责任，有没有QA团队都一样。设有QA团队，有提测这些额外的流程，更多是为了再多一层保障。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者没有实际研究过QA团队自己是如何定位并规划他们团队的工作的，所以以下都是站在研发角度讲的，理解有偏差的请见谅。因为测试相关话题太大了，这里只是简单罗列一些常见的测试类型。至于怎么做，如何算做得好这个估计得再好好学习学习才行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;① 单元测试（Unit Testing）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指单个函数、模块或功能级的测试，属于&lt;strong&gt;白盒测试。&lt;/strong&gt;一般都是由研发人员自己完成。敏捷团队应该都了解测试驱动开发(TDD)。在一些传统软件行业，如通信领域等可靠性要求较高的单位可能工作的会相对好一些。互联网领域，尤其其中做上层业务开发的，真正把TDD用得好的并不多。不过一些思想值得我们时刻参考。要想把单测写好，维护好其实并不那么容易。首先，写出来的代码，得对测试友好。这对于编码能力是有一定要求的。往往抱怨单测很浪费时间的，大概率是代码抽象，尤其接口层面设计，分层这些没有做好的那些人。另外，测试用例需要维护，是有成本的。甚至测试用例的代码量会远远大于业务代码。不过要知道自动化测试用例，不是为了一次功能测试而编写的，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;更多是一个文档和一种保护。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;保护测试好的代码不会被后人轻易破坏。他可以反复、全自动执行，所以叠加起来的价值可以很大。有了自动化测试用例，我们就可以在每次代码变更时候，都可以自动跑一下这些case。这个属于check in build的一部分。因为case数量会越积累越多，我们为了不影响开发效率，可以把这些case分成快速的和全量的。快的是每次check in都会执行(check in build)，慢的可以是天级执行(daily build)。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;② 集成测试（Integration Testing）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指将已经完成了单元测试的模块等组合起来测试，比如接口测试，某个流程测试等等。他一般针对某个功能点(特性)进行测试，通常属于&lt;strong&gt;黑盒测试。&lt;/strong&gt;研发内部的联调测试，QA的大部分测试工作，都属于这个范畴。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;③ 系统测试（System Testing）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指从交付角度(用户视角)进行的更宏观的测试。操作系统适配测试，低端机适配测试，弱网测试，安全测试，性能测试，压力测试等等，都可以归为系统测试大类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;④ 回归测试（Regression Testing）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当系统有变更时，我们通过回归测试保证原有功能都没有被破坏。一般分为线上和线下，而且希望这部分自动化程度越高越好。靠人工去做回归测试将必然是个悲惨的故事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;⑤ 冒烟测试（Smoke Testing）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;据说是最早做板子的前辈们，在设计好一块板子之后先通电看看会不会哪里冒烟。如果冒烟就说明根本没必要进行任何其他测试了，直接回炉重造。在软件行业，一般指的QA团队的准入测试吧。一般要求他能自动运行，且速度要快一些。冒烟没通过，直接打回提测流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;⑥ α测试（Alpha Testing）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般是指客户侧在正式交付前的验证测试。不过互联网行业很少提这个了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;⑦ β测试（Beta Testing）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将产品交付给少部分用户，然后进行实际场景应用，并收集反馈。我们一般叫小流量测试或灰度测试了，换了个名字。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;⑧ 压力测试（Stress Testing）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;测试一些临界压力情况下的系统表现。比如系统最大同时在线的用户数，最大支持的输入大小，模拟用户恶意下单等等。一般是针对系统级的全流程测试。当然如果某个接口很重要，有时候也会说做接口压测，实际上就跟下面的性能测试有点混淆了，不过这个不重要。在to C场景，压测是非常重要的，如果有一套成熟的压测体系，那恭喜你，至少心里会踏实很多。当然搞一套有效的压测体系，我们也需要不小的投入。可能会面临的几个挑战：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;⑨ 性能测试（Performance Testing）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如某个接口的单机性能，集群性能等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;⑩ 故障演练（Recovery testing）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;模拟各种故障，比如下游宕机，数据库离线等等，然后看系统表现是否跟设计一致。可以认为是系统级的异常测试。Recovery testing还会关注当故障恢复后，系统是否可以自动复原。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有很多名词，有的作者也没接触过，就不再发散了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）发布&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;据不完全、不可靠统计，70%以上的线上事故是由代码变更(包括配置)引起的。可见把测试好的代码发布上线是一个非常高风险的事情。为了尽量降低这个风险，人们搞出了各种各样的灰度策略和机制。他的本质是：1）开发和测试人员没能测到的问题，就让更多的用户帮我们测试(众测)；2）为了控制影响面，需要逐步放量，争取在最小的影响面下发现问题。下面简单介绍下常见的几种灰度方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;① 金丝雀发布&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;矿工的故事大家应该都听过了，不再赘述。其实很多时候我们所谓的灰度发布，基本就是等价于金丝雀发布了。通常我们会把集群分成几个集群，典型的预发布、小流量和全量集群(当然可以有更多级)。然后，逐步放量。其中预发布一般不对外，我们把代码上到预发布环境，通过自动化回归脚本+人肉，进行新老功能的回归。如果有内测环节那就更好了，找一些公司内部的用户帮忙验证一下。到小流量环境是要有真实的公网流量的。我们一定要预留足够的时间来收集反馈。当然具体时间是根据版本大小和厂子现状定的。收集反馈最核心就是之前建好的监控大盘了。如果能收集真实的用户反馈那就更好了。VoC自动检测，其实也算监控一种吧。比如直播系统，用户刷屏“卡”“卡死”...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;金丝雀发布估计是用的最多的一种发布方式。其核心是制定一套分流机制。最简单就是在router层按流量随机分流了。如果你的服务只跟流量本身有关（典型的就是不用登录的场景，如百度搜索），那用服务器灰度就够了。1台，10%，100%...如果想根据用户分流(要求一个用户要不用旧版服务，要不就用新版的)，那么就得需要一些设计，典型的是在HTTP头里增加一些分流标识等。如果再复杂的分流策略，那么就得自己搞个gateway了。有集中存储的时候，比如MySQL，那么存储层面要不要也分开，也是个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端在各大应用市场的发布策略，一般也都属于这一类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;② 蓝绿发布&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很少用。大致思想是搞两套集群，蓝色是老的，新的是绿的。起初流量指向蓝的，等把代码部署到绿的，验证ok之后把流量指向绿的。下一轮发布，把颜色交换一下。好处是回滚快，成本就是多了100%的冗余。可以做细一点，比如类似滚动发布，每一轮(比如10%)都走蓝绿，到下一轮时就回收蓝色当绿色。这样就只需要10%的冗余了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;③ 影子发布&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;核心是流量复制。老版本依然保持服务，新版本部署到新环境后，把老版本的流量copy到新版本(可以是部分流量)，然后验证新版本的功能。我们做了一轮纯粹的技术重构后，对比新老版本结果是否一致，经常这么玩。如果机器资源不太够，也可以通过代码开关进行相关验证。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;④ A/B测试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多策略模块喜欢A/B。其部署可能都在一个集群，只是策略插件有多分，我们通过程序开关控制不同的用户走不同策略，然后对比不同策略的效果。A/B可以很复杂，也可以认为是金丝雀的一种吧。不展开了，还有专门做ToB的A/B系统的单位，可见其复杂度和价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）CI/CD&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;聊到DevOps，都会说到这两个概念。这两个单词分别是Continuous Integration和Continuous Delivery的缩写。其核心是通过一对自动化的工具和流程，使得我们迭代开发和发布变得更高效，更有保障。话题有点大，不讨论了，附一张图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;158&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.27734375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8Yia7via7jDqYC2FtDdAZHibgVCJKhu0DTMdCKj4Mic6YgPbpuIsQH9nFdQlroAvwn8ACxboucFiae4plw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图6 典型的CI/CD流程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、设计开发&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;软件设计和开发，应该是我们最熟悉的了。不过这次咱们从稳定性视角再去看一看。很多事情在设计开发阶段考虑好，才是ROI最高的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;软件设计也是个很大的概念。什么是一个好的设计？估计不会有什么明确的答案。但是一个糟糕的设计，会导致我们迭代成本越来越高，稳定性保障变得异常困难 。前辈大佬们基于自己的实践经验，概括了一些大家耳熟能详的设计原则。我们遵循这些原则，不见得能解决所有问题，但是可以规避很多可能的大坑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;① KISS(Keep It Simple, Stupid)原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;爱因斯坦讲过：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;如果你不能简单的解释它，说明你还没有足够的理解它。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;某度的“简单可依赖”似乎也是在强调这个事情。只有它足够“简单”，它才更“可依赖”的。简单在软件工程里意味着：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了简单我们：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;② YAGNI(You Ain’t Gonna Need It)原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;意思是，如果一个事情你不是今天就需要，那大概率就是你不需要的。我们总希望自己能高瞻远瞩，一劳永逸，偶尔还想秀一秀技术。但事实是，我们不管是产品功能，还是代码实现，总是有很多无用或者很少用到的东西(2/8定律)。多余的这部分反而是更容易出错且维护成本更高的（因为团队对这部分更陌生，且升级迭代时经常忽略这部分）。所以我们要尽量杜绝过度设计，包括画蛇添足，过于超前等等。很多时候识别真正现在就需要的东西，还是有点难度的。作者认为，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所谓前瞻性设计，更多是在思考和调研阶段要尽量考虑周全，想好各种异常和未来扩展性需求。而真正实现的时候，做取舍才能体现架构师真正的实力。很多时候我们倡导提供简单直接的实现，然后做好兜底。兜底可以很暴力，只要他发生的频率不高，很多时候都是可以接受的。等我们无法容忍的时候，就有动力优化了。敏捷开发中有很多这方面的思考：我们持续交付那些优先级高的最小集合。让系统先跑起来，然后根据用户(可能是甲方)实际使用反馈再决策需要增加哪些特性或哪些体验需要优化。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;③ DRY(Don’t Repeat Yourself)原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;顾名思义，要以Ctrl C/Ctrl V为耻。我们应该尽最大努力杜绝重复代码。提高代码复用，对于开发、维护效率至关重要。更重要的是，我们不该把测试等额外的精力浪费在重复测试几乎相同的代码上。为了减少重复，我们自然会对自己的代码做更多的分层、抽象、局部重构等，使得每段代码，每个函数他的职责会越来越明确，单一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;④ SOLID原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大名鼎鼎，大家应该都非常熟悉了。针对面向对象场景，大佬们(一说是Robert J. Martin，即Uncle Bob首次提出的，应该不全是他的)总结出了五条原则，目的是让代码可维护性更高，更好理解，更容易扩展，避免随着代码量的增加代码越来越复杂。从稳定性角度，遵循SOLID原则，也会使得我们的代码变更更加可控，影响面不会被无限放大。这几个原则实在太出名了，请各位客观自行查阅相关资料吧。附图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;734&quot; data-backw=&quot;568&quot; data-ratio=&quot;1.2930555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8Yia7via7jDqYC2FtDdAZHibgVEPcoEYubdPmqdxlJEFI9tyXSZAMZ3xXqGpBCibwEyuYK1ApOgZZvaqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7 SOLID原则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;⑤ IDEALS原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式系统，尤其是微服务盛行的今天，有人觉得也应该有类似SOLID的一些准则，用来指导整体微服务架构设计和实现。2020年时候，InfoQ上有位大佬提出了IDEALS的概念，目前看影响肯定没有SOLID那么大，但可以对我们带来一些启发。遵循这些原则，虽然不能解决所有问题，但是可以让我们的设计和技术选型有据可依，至少不会跑太偏。下面大致解释下概念：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IDEALS是以下几个单词的首字母拼接：Interface segregation, Deployability (is on you), Event-driven, Availability over consistency, Loose coupling, Single responsibility。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;希望通过面向不同的客户、不同的应用场景提供单独的接口，减少不同客户之间的改动影响到其他客户。这里最典型的一个问题是web和移动APP是否要提供独立的接口？BFF(Backend for Frontends)就是非常典型的一个设计模式，可以自行了解下。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中文翻译不一定准确，仅供参考。微服务架构使得线上部署单元变多了，所以如何更高效的发布和监控变得更加重要。这里好的工具对效率的提升至关重要。下面几类技术和工具，兴许都能用得上：容器化(Docker+k8s)、Service Mesh(Istio含Envoy)、API Gateway(提供协议转换、接口路由、安全控制、熔断、限流、配额管理、流量监控等等能力，部分能力逐渐在被Service Mesh和开发框架，如Spring Cloud等代替。Kong/tyk)，Serverless(各云厂商提供的云函数FaaS)，监控工具(Prometheus/Grafana，还可以关注laiwei老师的Open Falcon和最新的Nightingale)，日志采集(其实很多监控方案都自带了采集能力，ELK/splunk)，链路追踪(Zipkin/Jaeger)，DevOps(文化+工具+实践)，灰度发布，IaC(Infrastructure as Code)，CI/CD(Jenkins/Argo CD/Flux)。如果你有个非常靠谱的基础架构或运维团队，那么以上其实更多是关注如何使用就好了。如果没有或你就是那个团队成员，恭喜你，在微服务和云原生的冲击下，这块更新换代还是比较快的，要学习掌握的真不少。关键这些都是一些基础设施，对稳定性和易用性要求都极高。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然他不等价于异步模式，但他们密不可分。微服务架构中，鼓励大家大量使用基于消息的异步通信。这是调用方和服务提供方之间比较彻底的解耦方式。一方面，可以做到消峰，高并发情况下，也不会因为下游服务处理能力导致拒绝服务；另一方面，消费方可以根据消息量灵活扩缩容，而且还给你留了一定的反应时间。目前MQ中间件基本都已经很成熟了，一般场景下甚至丢消息都不用太考虑，只有增加一些兜底措施就好。另外，MQ的可用性一般都远高于业务服务，所以也不用担心引入他带来的稳定性损失。只要对于响应时间没有特别敏感，原则上能异步就异步。挑战可能是对于业务本身的事件驱动的抽象，前端的体验设计和MQ本身的规划和管理上吧。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在大部分互联网场景下，我们更注重可用性，而对于一致性，降级为了追求最终一致性。CAP原理相信大家都非常熟悉了，而且这个话题有点大。这里就当做是一种常识吧。Command Query Responsibili&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;y Segregation (CQRS) 可以了解下，附一张原图：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;372&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.6551410373066424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8Yia7via7jDqYC2FtDdAZHibgVzSZ1ObibuCVjYdM1BgEibLSdzomO0PJhlpBjypgVnwGUaia0wQOfaF7Wg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1099&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图8 CQRS&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解耦带来的好处应该不用解释了。具体解耦方式也有多种。这里核心不是怎么解，而是怎么发现。比如一个模块本来很简单，后来由两个团队共同维护，那可能这两个团队分工合作就有耦合了，可以考虑拆分。如果一个系统足够简单，数据量也不大，非得搞个CQRS，全异步那也只是在徒增烦恼，不见得能真的体会到“解耦”的好处。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类似SOLID里的S，他强调的是服务内部要高内聚。很容易理解，但是可能很难把握。服务分的太粗，就逐渐退化成单体应用了。如果拆的特别细碎，部署运维会是个问题，另外还会额外增加一些RPC代价。个人一些简单原则(只要纠结，肯定都能找到一个反例，仅供参考)：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个微服务，尽量对应一个数据库。这里，如果某种场景必须要有事务保证，那相关操作必然得在一个服务。不过建议尽量减少大事务，而是追求最终一致性，上面有讨论；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果业务场景中，绝大部分请求，都会涉及多个同一层“模块”(分层是另一个维度，不算)，那这些“模块”就放到一个服务吧，除非有很强的拆开的理由。这里如果用DDD描述可能更容易理解。不过作者对DDD理解不够深入，不敢提；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;组织架构决定系统架构，不同团队维护的，就想办法从代码层面拆清楚；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果拆开目前没有引入无法接受的成本，那么就先拆开吧。合并，一般都会比拆分成本更小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;拆分过程可能比结果更重要。能把一个看起来凌乱的事情抽象成多个相对独立的事务的组合，必然会降低其复杂度。如果考虑运维成本等，可以先只是逻辑拆分，物理上可以是一个包，一个节点。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）开发&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开发过程其实真正写码的时间也很少，这里强调的更多是一些局部设计和编码过程中要避免的一些坑。当然我们编写出来的代码质量才是最终决定系统运行情况的根本保障。各大厂应该都会有一些开发手册等。其中最出名的应该是《阿里巴巴java开发手册》了，作者认为没有之一。手册中自称愿景是“码出高效，码出质量”。很显然通过此类手册，我们希望一方面能规范一些开发过程，另外，也通过一些基础的保障和警示，提高程序员编码质量。其中每一条规约后面，可能都深藏着无数深坑和历史上在此坑掉下去的大侠们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们也可以从稳定性角度制定类似规范。我们要做的是不断完善自己的开发规范同时，应该根据团队实际遇到的一些问题，复盘的线上事故等来不断沉淀自己团队的一些相应的规范和禁忌。线上事故是我们缴的最贵的学费，不要轻易浪费他。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有规范是一方面，更重要的是执行。这块可能更多是依赖一线leader的执行力和管理能力了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、工具&amp;amp;文化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;这俩放一起，其实没那么生硬。有一种文化叫“工具文化”~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实前面聊了很多工具相关的事情了。这些工具包括一些开源项目或商业软件，也可能是团队自研小工具等等。我们经常讲&lt;/span&gt;&lt;strong&gt;&lt;span&gt;能依靠工具就不要依赖流程，能建立流程就不要依赖人的主动性。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;合理使用工具，让一切能自动化的自动化，一方面是提高执行效率，另一方面降低人为引入的失误风险。一些常规，繁琐或容易出错的事情，我们就应该考虑建设相对应的工具。比如一些环境搭建，代码检查，自动化测试和CI/CD流程等都可以完全交给工具去完成。除此之外，线上trace，debug，兜底操作等都依赖工具支持。还可以例举很多场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为一名优秀的工程师，咱们能自己动手提升自身工作效率，降低犯错的概率，为什么不多去努力呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相反，如果工具层面欠缺太多，那就该咬咬牙把这块能力先补上吧。比如，日志采集和监控，CI/CD，如果没有很好的工具支撑，那我们就需要(反复地)做很多额外的事情，而且随着系统演进和团队壮大，这部分工作量都是成倍的增长的。我们就该尽早重视这部分建设。一些小团队创业型团队，这部分反而往往被忽略，不被重视。看起来组织永远没人力投入，实际上过段时间去统计，你就会发现总的额外投入往往要比工具本身上的投入要大好多倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;稳定性建设是个无底洞，如果没有很好地提效工具，那么ROI就会越来越低。如果你想说服你老板加大在稳定性方面的投入，那不得不去讲ROI。工具虽然不是全部提效手段，但肯定是最重要的一个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）文化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们通篇都在讲稳定性可以怎么怎么保障，看似很系统。实际情况是，很多时候所谓稳定性建设可能都只是有一阵风，吹过之后似乎什么也没留下。系统在不断迭代，人员也会不停流动，如果没有一个好的文化传承，我们其实无法保证这块的持续投入和效果。那怎么建设一个团队的稳定性文化呢？其实这话题可能是我一万个最不擅长的事情之一了。不过既然提出来了，就简单分享下此刻的一些认知吧。参考HR部门关于企业文化建设的思路：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先，提炼它。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;文化一般都希望能提炼成一两句话，让团队朗朗上口。这样才能更好的传播和传承。我自己团队，用一句话强调稳定性的重要性：稳定性是我们的底线。意思是，如果稳定性没有做好，做再多拔高的事情，其实也都可能会归零。我们不要求一切都以稳定性为前提(很多时候迭代压力会极端的大)，但是要明确意识到，稳定性不管什么时候都是我们的底线，要时刻提醒自己是不是做的足够好了。至少要做到在当时那个环境下充分评估稳定性风险，并保证最大程度的投入。如果因为一些交付时间等原因，做了一些妥协，那一定要在接下来最快的时间内把稳定性欠债还上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;其次，运营好。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;文化是需要运营的。作者认为比较实用的一些运营方式有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）建立明确的奖惩措施。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;比如线上事故得有些具体惩罚措施。可以是物质的，也可能是更柔和的。当然做得好的，要多去鼓励，多去传播。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）识别关键人员，并加以引导。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;让更多的人帮助自己推广相关理念和要求。比如每个小组的leader，一些核心开发人员。他们在一线，很多时候他们说的话更有感染力。所以一定要先跟这些人员达成一致，并让他们一方面身体力行；另一方面，作为稳定性文化的坚定传播者，帮助组织共同传承和发扬光大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）洗脑式宣贯。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们要不停的讲一些稳定性方面的意识和实操层面要关注的事情(比如监控设计和发布设计都是系统设计阶段要考虑的)。稳定性宣贯有个特别好的时机，那就是线上出故障时，我们一般都会组织复盘或case study。那这时候所有的稳定性主张都可以重新再review下。看我们哪里做得好，哪些点没做到位。只要坚持高质量的复盘和case study，就可以在团队内部不断强化相关意识。而且问题越多，力度越大。问题不多时候有稍微放一放不见得一定是坏事。当然系统不可能没有问题的，这个度就得管理者自己拿捏了。小道cr问题，qa发现的bug等等只要想强调，就可以组织case study。这里复盘再稍微罗嗦下的是：一方面，复盘时不一定都是全员可以参加，所以复盘结论的通晒就很重要了(不要藏着掖着)；另一方面，复盘容易，闭环往往都不是很理想，所以应该更多的去关注闭环效果。其中就可以review下文化，意识层面的改进项。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再者，把它融入到其他文化建设中，形成更广泛的传播。稳定性文化单独拿出来，其实有可能只是一个点。但是像工程师文化，新人融(xi)入(nao)，这些都是我们经常会去讲，会去做的。那么作为喜欢追求极致的工程师们，能够容忍自己开发的系统有缺陷吗？至少应该以此为耻吧？新入职培训和熟悉业务阶段，是否可以专门设置相关课程？作为一个新人，至少应该看一看组织历史上都犯过哪些错误吧？不断沉淀一些相关案例，让成员们定期多去关注这些案例。自然就可以从中吸取一些教训，尤其哪些重复犯的错误，都应该被深深地记住。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在后面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;稳定性建设至关重要。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务稳定性对于公司口碑，甚至是对其直接的商业利益都有重大影响。历史上血淋淋的宕机事件、安全事故比比皆是。不知这背后又有多少猿类内心和肉体上留下了挥之不去的烙印。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;稳定性建设，对于系统设计，团队协同效率，程序员自身修养都提出了更高的要求。所以只要坚持投入，对于系统稳定性提升，团队整体战斗力提升和成员个人成长都是大有裨益的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;稳定性建设不好做，需要耐心。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）稳定性建设很多时候都是在做保底线的事情。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这就意味着，不出问题甲方(用户、老板、合作伙伴)基本没有人能感受到。他们关注到你的时候，大概率线上已经出了事故。所以，想得到大家的欣赏还是挺难的，如果想长期从事相关工作，得做好吃土的准备。不过一般很少有人专门做稳定性建设，更多是在自己开发交付过程中不断完善系统，使其更让人放心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）稳定性建设投入总是没保障。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们总是(尤其是在业务初期)着急的开发着新的特性，迭代效率基本就是个无法妥协的事情。如果不咬牙坚持，付出额外的努力，根本就没法坚持。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）稳定性建设涉及软件开发整个生命周期。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;想每个环节同时都做到理想状态几乎不可能。所以也意味着他是个慢功夫，甚至刚开始时候很容易犯左倾冒进主义错误，后期又无法坚持长期斗争。从上到下得有耐心才可能做得更好。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;作者丨itegel&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源丨网址：https://zhuanlan.zhihu.com/p/552491334&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dbaplus社群欢迎广大技术人员投稿，投稿邮箱：&lt;/span&gt;&lt;span&gt;editor@dbaplus.cn&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c73478fd08a272fccff26c5d4b012bcd</guid>
<title>优质网站同好者周刊（第 099 期）</title>
<link>https://toutiao.io/k/xkcwohh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&quot;&gt;&lt;code&gt;机器学习&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%A1%86%E6%9E%B6&quot;&gt;&lt;code&gt;框架&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E6%BA%90&quot;&gt;&lt;code&gt;开源&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;An open source machine learning framework that accelerates the path from research prototyping to production deployment.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/pytorch.org.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - PyTorch | From Research To Production&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://pytorch.org/&quot;&gt;PyTorch&lt;/a&gt; ，一种开源&lt;a href=&quot;https://nicelinks.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&quot;&gt;机器学习&lt;/a&gt;框架，可加速从研究原型设计到生产部署的过程（类似框架有：&lt;a href=&quot;https://nicelinks.site/post/60631f14bffb5e532f3be248&quot;&gt;TensorFlow&lt;/a&gt; 等）。PyTorch 是一个 Python 包，提供两个高级功能：1）具有强大 GPU 加速功能的 Python 中的张量和动态神经网络；2）建立在基于磁带的 autograd 系统上的深度神经网络；其主要特性和功能有：&lt;/p&gt;&lt;h3 id=&quot;生产就绪&quot;&gt;&lt;a href=&quot;#%E7%94%9F%E4%BA%A7%E5%B0%B1%E7%BB%AA&quot; aria-label=&quot;生产就绪 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;生产就绪&lt;/h3&gt;&lt;p&gt;使用 TorchScript 在 eager 模式和图形模式之间无缝转换，并使用 TorchServe 加速生产路径。&lt;/p&gt;&lt;h3 id=&quot;分布式训练&quot;&gt;&lt;a href=&quot;#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83&quot; aria-label=&quot;分布式训练 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;分布式训练&lt;/h3&gt;&lt;p&gt;torch.distributed 后端支持研究和生产中的可扩展分布式训练和性能优化。&lt;/p&gt;&lt;h3 id=&quot;强大的生态系统&quot;&gt;&lt;a href=&quot;#%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F&quot; aria-label=&quot;强大的生态系统 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;强大的生态系统&lt;/h3&gt;&lt;p&gt;丰富的工具和库生态系统扩展了 PyTorch 并支持计算机视觉、NLP 等领域的开发。&lt;/p&gt;&lt;h3 id=&quot;云支持&quot;&gt;&lt;a href=&quot;#%E4%BA%91%E6%94%AF%E6%8C%81&quot; aria-label=&quot;云支持 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;云支持&lt;/h3&gt;&lt;p&gt;PyTorch 在主要的云平台上得到很好的支持，提供无摩擦的开发和轻松的扩展。&lt;/p&gt;&lt;p&gt;您可以重用您最喜欢的 Python 包，例如 NumPy、SciPy 和 Cython，以在需要时扩展 PyTorch。&lt;a href=&quot;https://nicelinks.site/redirect?url=https://pytorch.org/&quot;&gt;PyTorch&lt;/a&gt; 在 &lt;a href=&quot;https://github.com/pytorch/pytorch&quot;&gt;Github 开源&lt;/a&gt;，截止目前（2023 年 01 月 05 日）已有 61K+ Star，如果您对 PyTorch 或机器学习感兴趣，可移步官网或开源仓库以了解更多。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63b6b8c21653425ab90b4b34&quot;&gt;倾城之链 - PyTorch | From Research To Production&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%B9%B3%E5%8F%B0&quot;&gt;&lt;code&gt;平台&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;&lt;code&gt;Web开发&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/JavaScript&quot;&gt;&lt;code&gt;JavaScript&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Meteor is an open-source platform for web, mobile, and desktop used by over half a million developers around the globe. Meteor makes shipping Javascript applications efficient and scalable. Sign up for your free Meteor Cloud account today!&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.meteor.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Meteor Software: A Platform to Build, Host, Deploy and Scale Full-Stack Javascript Applications&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.meteor.com/&quot;&gt;Meteor&lt;/a&gt; 是一个开源平台，用于在 Javascript 或 TypeScript 中无缝构建和部署 Web、移动和桌面应用程序；它是一个用于构建&lt;strong&gt;现代&lt;/strong&gt;Web 应用程序的&lt;strong&gt;超简单环境&lt;/strong&gt;。&lt;strong&gt;为什么选择 Meteor.js&lt;/strong&gt;？官方给出以下理由：&lt;/p&gt;&lt;h3 id=&quot;集成您已经使用的技术&quot;&gt;&lt;a href=&quot;#%E9%9B%86%E6%88%90%E6%82%A8%E5%B7%B2%E7%BB%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF&quot; aria-label=&quot;集成您已经使用的技术 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;集成您已经使用的技术&lt;/h3&gt;&lt;p&gt;使用开箱即用的流行框架和工具。专注于构建功能，而不是自己配置不同的组件。&lt;/p&gt;&lt;h3 id=&quot;为任何设备构建应用程序&quot;&gt;&lt;a href=&quot;#%E4%B8%BA%E4%BB%BB%E4%BD%95%E8%AE%BE%E5%A4%87%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F&quot; aria-label=&quot;为任何设备构建应用程序 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;为任何设备构建应用程序&lt;/h3&gt;&lt;p&gt;无论您是为 Web、iOS、Android 还是桌面开发，都可以使用相同的代码，为您的用户提供无缝更新体验。&lt;/p&gt;&lt;h3 id=&quot;github-上的-43200-多个星和-508000-多个独立安装&quot;&gt;&lt;a href=&quot;#github-%E4%B8%8A%E7%9A%84-43200-%E5%A4%9A%E4%B8%AA%E6%98%9F%E5%92%8C-508000-%E5%A4%9A%E4%B8%AA%E7%8B%AC%E7%AB%8B%E5%AE%89%E8%A3%85&quot; aria-label=&quot;github 上的 43200 多个星和 508000 多个独立安装 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;GitHub 上的 43,200 多个星和 508,000 多个独立安装&lt;/h3&gt;&lt;p&gt;历经十余年研发，深受行业巨头信赖。Meteor.js 是一个成熟的开源平台，允许您高效地构建和扩展，以便为数百万用户提供服务。&lt;/p&gt;&lt;p&gt;Meteor.js 可与 &lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot;&gt;React&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/62a9c2ad90509e23cea772c0&quot;&gt;Svelte&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/5b1a221c0526c920d6dfaada&quot;&gt;Vue&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/62692add77f8270876fcb3dc&quot;&gt;MongoDB&lt;/a&gt;、CORDOVA、npm 等结合，以快速构建出色的应用程序；如果您对其感兴趣，可移步至 &lt;a href=&quot;https://github.com/meteor/meteor&quot;&gt;Meteor Github 开源仓库&lt;/a&gt;，从而了解更多。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63b6b5cb1653425ab90b4a35&quot;&gt;倾城之链 - Meteor Software: A Platform to Build, Host, Deploy and Scale Full-Stack Javascript Applications&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85&quot;&gt;&lt;code&gt;独立开发者&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%88%86%E4%BA%AB&quot;&gt;&lt;code&gt;分享&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%81%9A%E5%90%88&quot;&gt;&lt;code&gt;聚合&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;独立开发变现人物志、产品周刊、工具集。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.ezindie.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - 让小产品的变现更简单 - ezindie.com&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.ezindie.com/&quot;&gt;ezindie.com&lt;/a&gt; ，收录独立开发变现人物志、产品周刊、工具集的网站；旨在为感兴趣朋友带来关于独立开发变现相关的技术、工具、交流等，彼此促进成长，快速落地各自的产品，实现持续盈利。&lt;/p&gt;&lt;p&gt;副业收入（以及被动收入、睡后收入）这几年越来越热，人们一方面想增加自己的收入，又不知道如何去做，而做小众市场的产品可以满足特定人群需求，也能给自己带来可观的收入，更重要的是持续性收入， 作者希望 ezindie.com 能为做自己产品的人们提供一些帮助，而做小产品都会涉及整个过程的 7 个步骤，每个步骤下都有相应的工具和方法：💡 想法、🛠 构建、🚀 发布、🌱 增长、💰 变现、🤖 自动化。&lt;/p&gt;&lt;p&gt;Easy Indie，让小产品的独立变现更简单，如果对&lt;strong&gt;副业收入&lt;/strong&gt;或 Easy Indie 感兴趣，不妨移步 &lt;a href=&quot;https://www.ezindie.com/about&quot;&gt;关于 Easy Indie&lt;/a&gt; 以了解更多。就笔者视角来看，于绝大多数人，努力工作，不能形成&lt;strong&gt;复利&lt;/strong&gt;；所带来的收入，越发辛苦、难以积累；而且面临的挑战、风险和竞争与日俱增。根据自己的兴趣，在合适行业的细分领域，去打造副业、缔造产品乃至创业，在当前时代，与整个人生来讲，或许是更可取的选择。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63b666751653425ab90b471c&quot;&gt;倾城之链 - 让小产品的变现更简单 - ezindie.com&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%A1%86%E6%9E%B6&quot;&gt;&lt;code&gt;框架&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/JavaScript&quot;&gt;&lt;code&gt;JavaScript&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;&lt;code&gt;Web开发&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;A rugged, minimal framework for composing behavior directly in your markup.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/alpinejs.dev.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Alpine.js | Your new, lightweight, JavaScript framework.&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://alpinejs.dev/&quot;&gt;Alpine.js&lt;/a&gt; 一款新的、轻量级的、强大的 JavaScript 框架；它是一个坚固的、最小的工具，用于直接在您的标记中组合行为。你可以把它想象成现代网络的 jQuery，放入脚本标签即可开始。&lt;/p&gt;&lt;p&gt;Alpine 是&lt;strong&gt;15 个属性&lt;/strong&gt;、&lt;strong&gt;6 个属性&lt;/strong&gt;和&lt;strong&gt;2 个方法&lt;/strong&gt;的集合，通过很低的成本提供了与 Vue 或 React 这类大型框架相近的&lt;strong&gt;响应式&lt;/strong&gt;和&lt;strong&gt;声明式&lt;/strong&gt;特性。你可以继续操作 DOM，并在需要的时候使用 Alpine.js；您可以将其理解为 JavaScript 版本的  &lt;a href=&quot;%5Bhttps://tailwindcss.com/%5D(https://nicelinks.site/post/5fd20cb4c06d6302c1907ec7)&quot;&gt;Tailwind&lt;/a&gt;。Alpine.js 的语法几乎完全借用自  &lt;a href=&quot;https://vuejs.org/&quot;&gt;Vue&lt;/a&gt; （并用  &lt;a href=&quot;https://angularjs.org/&quot;&gt;Angular&lt;/a&gt;  的语法做了些扩展）；如果您对这款框架感兴趣。可移步至该项目 &lt;a href=&quot;https://github.com/alpinejs/alpine&quot;&gt;Github 开源仓库&lt;/a&gt;，以便了解更多。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63b55fdc1653425ab90b40d9&quot;&gt;倾城之链 - Alpine.js | Your new, lightweight, JavaScript framework.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E8%AF%97%E8%AF%8D&quot;&gt;&lt;code&gt;诗词&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E4%BA%BA%E6%96%87&quot;&gt;&lt;code&gt;人文&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%8F%91%E7%8E%B0&quot;&gt;&lt;code&gt;发现&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;诗词汇是一个中国传统文化数字平台，收集并整理了历史上各朝代的诗词名句和典籍名著.详细的注释翻译，诗词古文一读就懂.诗词汇致力于让更多的人爱上诗词古文，传承国学经典.&quot;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.shicihui.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - 诗词汇-收集诗词名句-经典名著-传承国学经典&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.shicihui.com/&quot;&gt;诗词汇&lt;/a&gt; 是一个中国传统文化数字平台，收集并整理了历史上各朝代的诗词名句、典籍名著、详细的注释、翻译、鉴赏、创作背景；此外还会根据诗文，提供有&lt;strong&gt;猜你喜欢&lt;/strong&gt;模块儿。&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.shicihui.com/&quot;&gt;诗词汇&lt;/a&gt; 有分为：&lt;code&gt;推荐&lt;/code&gt;、&lt;code&gt;名句&lt;/code&gt;、&lt;code&gt;诗词&lt;/code&gt;、&lt;code&gt;诗人&lt;/code&gt;、&lt;code&gt;古籍&lt;/code&gt; 等，除了网站之外，提供有 APP（Android、iOS），助您发现诗词之美。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63b192821653425ab90b245e&quot;&gt;倾城之链 - 诗词汇-收集诗词名句-经典名著-传承国学经典&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;长太息以掩涕兮，哀民生之多艰。&lt;br/&gt;余虽好修姱以鞿羁兮，謇朝谇而夕替。&lt;br/&gt;既替余以蕙纕兮，又申之以揽茝。&lt;br/&gt;亦余心之所善兮，虽九死其犹未悔。&lt;br/&gt;怨灵修之浩荡兮，终不察夫民心。&lt;br/&gt;── 先秦 · 屈原 《离骚》&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d24c48adf2f12708174c7dc7a2151460</guid>
<title>cfox：面向以太坊开发者的 shell</title>
<link>https://toutiao.io/k/76rn6kw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-header&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;cfox：面向以太坊开发者的 shell&lt;/h1&gt;
&lt;p class=&quot;meta&quot;&gt;胡键 Posted at — Dec 31, 2022
&lt;span class=&quot;meta&quot; id=&quot;busuanzi_container_page_pv&quot;&gt;阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;/&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;markdown&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/cfox&quot;&gt;cfox 的第一个版本&lt;/a&gt;终于在元旦前发布了！&lt;/p&gt;
&lt;p&gt;简单来讲，正如其 README 中所言，&lt;a href=&quot;https://github.com/DTeam-Top/cfox&quot;&gt;cfox&lt;/a&gt; 是一个面向以太坊开发者的 shell，提供了以太坊开发中一些可能会用到的命令集合，而且这个集合还在不断地增长。&lt;/p&gt;
&lt;p&gt;典型的特色命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nonce&lt;/code&gt;，用来检查一个 wallet 是否被阻塞&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cancel&lt;/code&gt; / &lt;code&gt;push&lt;/code&gt;，用来取消和加速被阻塞的 transaction&lt;/li&gt;
&lt;li&gt;&lt;code&gt;peek&lt;/code&gt;，用于查看合约的元数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;query&lt;/code&gt;，用于查询合约发出的任意事件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;upload&lt;/code&gt;，用于将数据上传至 IPFS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于如何上手使用，&lt;a href=&quot;https://github.com/DTeam-Top/cfox&quot;&gt;READM&lt;/a&gt; 已经写得比较清楚了，按蘭山师兄的说法：典型的中式表达，所以相信阅读起来应该不会有大的问题，这里就不再赘述。&lt;/p&gt;
&lt;p&gt;除了依赖 ethers，cfox 还用到了其他第三方的服务，如 morails 和 nft.storage，对于后者，代码覆盖了典型的使用场景：&lt;/p&gt;

&lt;p&gt;因此，除了作为 shell，cfox 代码本身从某种程度上也可以作为开发者常用库的 cookbook 来参考，目前主要就是：ethers 和 nft.storage。&lt;/p&gt;
&lt;p&gt;最后，如果您想提供支持或帮助，不妨考虑以下方式之一或全部 😄。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加 ⭐️&lt;/li&gt;
&lt;li&gt;转发&lt;/li&gt;
&lt;li&gt;考虑购买 ethers 相关的微信付费文章：

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;

&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1724c20a45a037607e79d4699ce4fa20</guid>
<title>Go module</title>
<link>https://toutiao.io/k/w777qf3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;哈喽，大家好啊。一般编程语言都会提供依赖库管理工具，例如python的pip、node.js的npm，java的maven，rust的cargo，Go语言也有提供自己的依赖库管理工具，Go语言在1.11提出了Go mod，每次版本或多或少都会对go.mod进行改进优化，go mod也越来越好，当前大多数公司都使用go mod来管理依赖库，所以本文我们一起来入门go mod（参考资料文末给出）；&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go Modules发展史&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;go get阶段&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;起初Go语言在1.5之前没有依赖管理工具，若想引入依赖库，需要执行go get命令将代码拉取放入GOPATH/src目录下，作为GOPATH下的全局依赖，这也就意味着没有版本控制及隔离项目的包依赖；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;vendor阶段&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决隔离项目的包依赖问题，Go1.5版本推出了vendor机制，环境变量中有一个GO15VENDOREXPERIMENT需要设置为1，该环境变量在Go1.6版本时变成默认开启，目前已经退出了历史舞台；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vendor其实就是将原来放在GOPATH/src的依赖包放到工程的vendor目录中进行管理，不同工程独立地管理自己的依赖包，相互之间互不影响，原来是包共享的模式，通过vendor这种机制进行隔离，在项目编译的时候会先去vendor目录查找依赖，如果没有找到才会再去GOPATH目录下查找；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：保证了功能项目的完整性，减少了下载依赖包，直接使用vendor就可以编译&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：仍然没有解决版本控制问题，go get仍然是拉取最新版本代码；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;社区管理工具&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多优秀的开发者在这期间也都实现了不错的包依赖管理工具，例如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;godep：https://github.com/tools/godep&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;govendor：https://github.com/kardianos/govendor&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;glide：https://github.com/Masterminds/glide&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dep：https://github.com/golang/dep&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dep应该是其中最成功的，得到了Go语言官方的支持，该项目也被放到了https://github.com/golang/dep，但是为什么dep没有称为官宣的依赖工具呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实因为随着Russ Cox 与 Go 团队中的其他成员不断深入地讨论，发现 dep 的一些细节似乎越来越不适合 Go，因此官方采取了另起 proposal 的方式来推进，其方案的结果一开始先是释出 vgo，最终演变为我们现在所见到的 Go modules;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;go modules&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go modules是Russ Cox推出来的，发布于Go1.11，成长于Go1.12，丰富于Go1.13，正式于Go1.14推荐在生产上使用，几乎后续的每个版本都或多或少的有一些优化，在Go1.16引入go mod retract、在Go1.18引入go work工作区的概念，这些我们在本文都会介绍到；&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go Modules知识点&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;GO111MODULE环境变量&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个环境变量是Go Modules的开关，主要有以下参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;auto：只在项目包含了go.mod文件时启动go modules，在Go1.13版本中是默认值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;on：无脑启动Go Modules，推荐设置，Go1.14版本以后的默认值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;off：禁用Go Modules，一般没有使用go modules的工程使用；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我现在使用的Go版本是1.19.3，默认GO111MODULE=on，感觉该变量也会像GO15VENDOREXPERIMENT最终推出系统环境变量的舞台；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;GOPROXY&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该环境变量用于设置Go模块代理，Go后续在拉取模块版本时能够脱离传统的VCS方式从镜像站点快速拉取，GOPROXY的值要以英文逗号分割，默认值是&lt;code&gt;https://proxy.golang.org,direct&lt;/code&gt;，但是该地址在国内无法访问，所以可以使用&lt;code&gt;goproxy.cn&lt;/code&gt;来代替(七牛云配置)，设置命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; env -w GOPROXY=GOPROXY=https:&lt;span&gt;//goproxy.cn,direct&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以使用其他配置，例如阿里配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; env -w GOPROXY=https:&lt;span&gt;//mirrors.aliyun.com/goproxy/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该环境变量也可以关闭，可以设置为&quot;off&quot;，禁止Go在后续操作中使用任何Go module proxy；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的配置中我们用逗号分割后面的值是&lt;code&gt;direct&lt;/code&gt;，它是什么意思呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;direct&lt;/code&gt;为特殊指示符，因为我们指定了镜像地址，默认是从镜像站点拉取，但是有些库可能不存在镜像站点中，&lt;code&gt;direct&lt;/code&gt;可以指示Go回源到模块版本的源地址去抓取，比如github，当go module proxy返回404、410这类错误时，其会自动尝试列表中的下一个，遇见&lt;code&gt;direct&lt;/code&gt;时回源地址抓取；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;GOSUMDB&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该环境变量的值是一个Go checksum database，用于保证Go在拉取模块版本时拉取到的模块版本数据未经篡改，若发现不一致会中止，也可以将值设置为&lt;code&gt;off&lt;/code&gt;即可以禁止Go在后续操作中校验模块版本；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是Go checksum database?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go checksum database主要用于保护Go不会从任何拉到被篡改过的非法Go模块版本，详细算法机制可以看一下：https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md#proxying-a-checksum-database&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GOSUMDB的默认值是&lt;code&gt;sum.golang.org&lt;/code&gt;，默认值与自定义值的格式不一样，默认值在国内是无法访问，这个值我们一般不用动，因为我们一般已经设置好了GOPROXY，goproxy.cn支持代理&lt;code&gt;sum.golang.org&lt;/code&gt;;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GOSUMDB的值自定义格式如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;格式 1：&lt;code&gt;&amp;lt;SUMDB_NAME&amp;gt;+&amp;lt;PUBLIC_KEY&amp;gt;&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;格式 2：&lt;code&gt;&amp;lt;SUMDB_NAME&amp;gt;+&amp;lt;PUBLIC_KEY&amp;gt; &amp;lt;SUMDB_URL&amp;gt;&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;GONOPROXY/GONOSUMDB/GOPRIVATE&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三个环境变量放在一起说，一般在项目中不经常使用，这三个环境变量主要用于私有模块的拉取，在GOPROXY、GOSUMDB中无法访问到模块的场景中，例如拉取git上的私有仓库；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GONOPROXY、GONOSUMDB的默认值是GOPRIVATE的值，所以我们一般直接使用GOPRIVATE即可，其值也是可以设置多个，以英文逗号进行分割；例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go env -w GOPRIVATE=&lt;span&gt;&quot;github.com/asong2020/go-localcache,git.xxxx.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以使用通配符的方式进行设置，对域名设置通配符号，这样子域名就都不经过Go module proxy和Go checksum database;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;全局缓存&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go mod download会将依赖缓存到本地，缓存的目录是&lt;code&gt;GOPATH/pkg/mod/cache&lt;/code&gt;、&lt;code&gt;GOPATH/pkg/sum&lt;/code&gt;，这些缓存依赖可以被多个项目使用，未来可能会迁移到&lt;code&gt;$GOCACHE&lt;/code&gt;下面；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;go clean -modcache&lt;/code&gt;清理所有已缓存的模块版本数据；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go Modules命令&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用&lt;code&gt;go help mod&lt;/code&gt;查看可以使用的命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; help mod&lt;br/&gt;Go mod provides access to operations on modules.&lt;br/&gt;&lt;br/&gt;Note that support &lt;span&gt;for&lt;/span&gt; modules is built into all the &lt;span&gt;go&lt;/span&gt; commands,&lt;br/&gt;not just &lt;span&gt;&#x27;go mod&#x27;&lt;/span&gt;. For example, day-to-day adding, removing, upgrading,&lt;br/&gt;and downgrading of dependencies should be done using &lt;span&gt;&#x27;go get&#x27;&lt;/span&gt;.&lt;br/&gt;See &lt;span&gt;&#x27;go help modules&#x27;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; an overview of module functionality.&lt;br/&gt;&lt;br/&gt;Usage:&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; mod &amp;lt;command&amp;gt; [arguments]&lt;br/&gt;&lt;br/&gt;The commands are:&lt;br/&gt;&lt;br/&gt;        download    download modules to local cache&lt;br/&gt;        edit        edit &lt;span&gt;go&lt;/span&gt;.mod from tools or scripts&lt;br/&gt;        graph       &lt;span&gt;print&lt;/span&gt; module requirement graph&lt;br/&gt;        init        initialize &lt;span&gt;new&lt;/span&gt; module in current directory&lt;br/&gt;        tidy        add missing and remove unused modules&lt;br/&gt;        vendor      &lt;span&gt;make&lt;/span&gt; vendored &lt;span&gt;copy&lt;/span&gt; of dependencies&lt;br/&gt;        verify      verify dependencies have expected content&lt;br/&gt;        why         explain why packages or modules are needed&lt;br/&gt;&lt;br/&gt;Use &lt;span&gt;&quot;go help mod &amp;lt;command&amp;gt;&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; more information about a command.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;命令&lt;/th&gt;&lt;th&gt;作用&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;go mod init&lt;/td&gt;&lt;td&gt;生成go.mod文件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;go mod download&lt;/td&gt;&lt;td&gt;下载go.mod文件中指明的所有依赖放到全局缓存&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;go mod tidy&lt;/td&gt;&lt;td&gt;整理现有的依赖，添加缺失或移除不使用的modules&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;go mod graph&lt;/td&gt;&lt;td&gt;查看现有的依赖结构&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;go mod edit&lt;/td&gt;&lt;td&gt;编辑go.mod文件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;go mod vendor&lt;/td&gt;&lt;td&gt;导出项目所有的依赖到vendor目录&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;go mod verify&lt;/td&gt;&lt;td&gt;校验一个模块是否被篡改过&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;go mod why&lt;/td&gt;&lt;td&gt;解释为什么需要依赖某个模块&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;go.mod文件&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go.mod是启用Go modules的项目所必须且最重要的文件，其描述了当前项目的元信息，每个go.mod文件开头符合包含如下信息：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;module&lt;/strong&gt;：用于定义当前项目的模块路径（突破$GOPATH路径）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go&lt;/strong&gt;：当前项目Go版本，目前只是标识作用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;require&lt;/strong&gt;：用设置一个特定的模块版本&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;exclude&lt;/strong&gt;：用于从使用中排除一个特定的模块版本&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;replace&lt;/strong&gt;：用于将一个模块版本替换为另外一个模块版本，例如chromedp使用golang.org/x/image这个package一般直连是获取不了的，但是它有一个github.com/golang/image的镜像，所以我们要用replace来用镜像替换它&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;restract&lt;/strong&gt;：用来声明该第三方模块的某些发行版本不能被其他模块使用，在Go1.16引入&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例子：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5502439024390244&quot; data-type=&quot;png&quot; data-w=&quot;1025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwB9ucZqffkXfBWDt3LBkAKaGmVsXLNWVGMKmwahHvJ1diaLwOtiaZa8ljcAtE8CNCr8MEjrtAQXs6hmA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;image-20230102181623314&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们分模块详细介绍一下各部分；&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;module path&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go.mod文件的第一行是module path，采用仓库+module name的方式定义，例如上面的项目：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;module github.com/asong2020/&lt;span&gt;go&lt;/span&gt;-localcache&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为Go module遵循语义化版本规范2.0.0，所以如果工程的版本已经大于2.0.0，按照规范需要加上major的后缀，module path改成如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;module github.com/asong2020/&lt;span&gt;go&lt;/span&gt;-localcache/v2&lt;br/&gt;module github.com/asong2020/&lt;span&gt;go&lt;/span&gt;-localcache/v3&lt;br/&gt;......&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;go version&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go.mod文件的第二行是go version，其是用来指定你的代码所需要的最低版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;1.19&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这一行不是必须的，目前也只是标识作用，可以不写；&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;require&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;require用来指定该项目所需要的各个依赖库以及他们的版本，从上面的例子中我们看到版本部分有不同的写法，还有注释，接下来我们来解释一下这部分；&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;indirect注释&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;github.com/davecgh/&lt;span&gt;go&lt;/span&gt;-spew v1&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt; &lt;span&gt;// indirect&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下场景才会添加indirect注释：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当前项目依赖包A，但是A依赖包B，但是A的go.mod文件中缺失B，所以在当前项目go.mod中补充B并添加indirect注释&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前项目依赖包A，但是依赖包A没有go.mod文件，所以在当前项目go.mod中补充B并添加indirect注释&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前项目依赖包A，依赖包A又依赖包B，当依赖包A降级不在依赖B时，这个时候就会标记indirect注释，可以执行go mod tidy移除该依赖；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go1.17版本对此做了优化，indirect 的 module 将被放在单独 require 块的，这样看起来更加清晰明了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;incompatible标记&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在项目中会看到有一些库后面添加了incompatible标记：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;github.com/dgrijalva/jwt-&lt;span&gt;go&lt;/span&gt; v3&lt;span&gt;.2&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;+incompatible&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jwt-go这个库就是这样的，这是因为jwt-go的版本已经大于2了，但是他们的module path仍然没有添加v2、v3这样的后缀，不符合Go的module管理规范，所以go module把他们标记为incompatible，不影响引用；&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;版本号&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go module拉取依赖包本质也是go get行为，go get主要提供了以下命令：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;命令&lt;/th&gt;&lt;th&gt;作用&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;go get&lt;/td&gt;&lt;td&gt;拉取依赖，会进行指定性拉取（更新），并不会更新所依赖的其它模块。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;go get -u&lt;/td&gt;&lt;td&gt;更新现有的依赖，会强制更新它所依赖的其它全部模块，不包括自身。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;go get -u -t ./...&lt;/td&gt;&lt;td&gt;更新所有直接依赖和间接依赖的模块版本，包括单元测试中用到的。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go get拉取依赖包取决于依赖包是否有发布的tags：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;拉取的依赖包没有发布tags&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;默认取主分支最近一次的commit的commit hash，生成一个伪版本号&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;拉取的依赖包有发布tags&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果只有单个模块，那么就取主版本号最大的那个tag&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有多个模块，则推算相应的模块路径，取主版本号最大的那个tag&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有发布的tags：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;github.com/alecthomas/template v0&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;-20190718012654&lt;/span&gt;-fb15b899a751&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;v0.0.0&lt;/strong&gt;：根据commit的base version生成的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果没有base version，那么就是vx.0.0的形式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果base version是一个预发版本，那么就是vx.y.z-pre.0的形式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果base version是一个正式发布的版本，那么它就patch号加1，就是vx.y.(z+1)-0的形式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;20190718012654&lt;/strong&gt;：是这次提交的时间，格式是&lt;code&gt;yyyyMMddhhmmss&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;fb15b899a751&lt;/strong&gt;：是这个版本的commit id，通过这个可以确定这个库的特定的版本&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;github.com/beego/bee v1&lt;span&gt;.12&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;replace&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;replace用于解决一些错误的依赖库的引用或者调试依赖库；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景举例：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例1：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发离不开第三方库，大部分场景都可以满足我们的需要，但是有些时候我们需要对依赖库做一些定制修改，依赖库修改后，我们想引起最小的改动，就可以使用replace命令进行重新引用，调试也可以使用replace进行替换，Go1.18引入了工作区的概念，调试可以使用work进行代替，后面会介绍；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例2：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang.org/x/crypto库一般我们下载不下来，可以使用replace引用到github.com/golang/crypto：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; mod edit -replace golang.org/x/crypto=github.com/golang/crypto@v0&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;-20160511215533&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;f3b11f56072&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;exclude&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于跳过某个依赖库的版本，使用场景一般是我们知道某个版本有bug或者不兼容，为了安全起可以使用exclude跳过此版本；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;exclude (&lt;br/&gt; &lt;span&gt;go&lt;/span&gt;.etcd.io/etcd/client/v2 v2&lt;span&gt;.305&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;-rc&lt;span&gt;.0&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;retract&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个特性是在Go1.16版本中引入，用来声明该第三方模块的某些发行版本不能被其他模块使用；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景：发生严重问题或者无意发布某些版本后，模块的维护者可以撤回该版本，支持撤回单个或多个版本；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种场景以前的解决办法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维护者删除有问题版本的tag，重新打一个新版本的tag；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用者发现有问题的版本tag丢失，手动介入升级，并且不明真因；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入retract后，维护者可以使用retract在go.mod中添加有问题的版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 严重bug...&lt;/span&gt;&lt;br/&gt;retract (&lt;br/&gt;  v0&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;br/&gt;  v0&lt;span&gt;.2&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新发布新版本后，在引用该依赖库的使用执行go list可以看到 版本和&quot;严重bug...&quot;的提醒；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该特性的主要目的是将问题更直观的反馈到开发者的手中；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;go.sum文件&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go.sun文件也是在go mod init阶段创建，go.sum的介绍文档偏少，我们一般也很少关注go.sum文件，go.sum主要是记录了所有依赖的module的校验信息，内容如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2837988826815642&quot; data-type=&quot;png&quot; data-w=&quot;895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwB9ucZqffkXfBWDt3LBkAKaGMic7QjrETw0ysX7yhVBK0icPWbPnDZHTM79CibVAjhdo4ZUVnA62ACzLQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;image-20230102193717816&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面我们可以看到主要是有两种形式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中module是依赖的路径，version是依赖的版本号。hash是以&lt;code&gt;h1:&lt;/code&gt;开头的字符串，hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;h1 hash 和 go.mod hash两者要不同时存在，要不就是只存在go.mod hash，当Go认为肯定用不到某个版本的时候就会省略它的h1 hash，就只有go.mod hash；&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go Modules在项目中使用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用go modules的一个前置条件是Go语言版本大于等于Go1.11；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们要检查环境变量GO111MODULE是否开启，执行&lt;code&gt;go env&lt;/code&gt;查看：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go env&lt;/span&gt;&lt;br/&gt;GO111MODULE=off&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行如下命令打开go mod：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go env -w GO111MODULE=on&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们随意创建一个项目：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ mkdir -p asong/demo&lt;br/&gt;$ cd asong/demo&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行go mod init初始化该项目：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go mod init github.com/asong/demo&lt;/span&gt;&lt;br/&gt;go: creating new go.mod: module github.com/asong/demo&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们在demo目录下创建main.go文件，写下如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; cache &lt;span&gt;&quot;github.com/asong2020/go-localcache&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c, err := cache.NewCache()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; key := &lt;span&gt;&quot;asong&quot;&lt;/span&gt;&lt;br/&gt; value := []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;公众号：Golang梦工厂&quot;&lt;/span&gt;)&lt;br/&gt; err = c.Set(key, value)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; entry, err := c.Get(key)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;get value is %s\n&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;(entry))&lt;br/&gt;&lt;br/&gt; err = c.Delete(key)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后执行&lt;strong&gt;go mod tidy&lt;/strong&gt;命令：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21380243572395127&quot; data-type=&quot;png&quot; data-w=&quot;739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwB9ucZqffkXfBWDt3LBkAKaGwib8pgWpneW7co6HibayC1kNiaVdkibibQtoqQ2RHl7Pj0lvS06xpayGYkQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;image-20230102202521167&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自动根据main.go文件更新依赖，我们再看一下go.mod文件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32991803278688525&quot; data-type=&quot;png&quot; data-w=&quot;488&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwB9ucZqffkXfBWDt3LBkAKaG8dRBEDxJaWqDlrdiaZdmibMJRD6OnX12wxv82wBzDhGagJS6lfuRsDgw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;image-20230102202600643&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是在项目对go.mod的简单使用；&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;go1.18新特性：工作区&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作区用来解决什么问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景1：我们有时在本地会对一些三方依赖库进行特制修改，然后想在项目修改依赖库引用到本地进行调试，这时我们可以使用replace做替换，这样就可以在本地进行开发联调，这样虽然可以解决问题，但是会存在问题，因为是在项目的go.mod文件直接修改的，如果误传到远程仓库，会影响到其他开发同学；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景2：我们在本地开发了一些依赖库，这时想在本地测试一下，还未发到远程仓库，那么我们在其他项目中引入该依赖库后，执行&lt;code&gt;go mod tidy&lt;/code&gt;就会报远程库没有找到的问题，所以就必须要把依赖库先推送到远程，在引用调试；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是这些问题，Go语言在Go1.18正式增加了&lt;code&gt;go work&lt;/code&gt;工作区的概念，其实就是将N个Go Module组成一个Go Work，工作区的读取优先级是最高的，执行&lt;code&gt;go help work&lt;/code&gt;可以查看go work提供的功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go &lt;span&gt;help&lt;/span&gt; work&lt;/span&gt;&lt;br/&gt;Usage:&lt;br/&gt;&lt;br/&gt;        go work &amp;lt;command&amp;gt; [arguments]&lt;br/&gt;&lt;br/&gt;The commands are:&lt;br/&gt;&lt;br/&gt;        edit        edit go.work from tools or scripts&lt;br/&gt;        init        initialize workspace file&lt;br/&gt;        sync        sync workspace build list to modules&lt;br/&gt;        use         add modules to workspace file&lt;br/&gt;&lt;br/&gt;Use &quot;go help work &amp;lt;command&amp;gt;&quot; for more information about a command.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行&lt;code&gt;go work init&lt;/code&gt;命令初始化一个新的工作区，在项目中生成一个go.work文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;1.18&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 多模块添加&lt;/span&gt;&lt;br/&gt;use (...)&lt;br/&gt;&lt;br/&gt;replace XXXXX =&amp;gt; XXXX v1&lt;span&gt;.4&lt;/span&gt;&lt;span&gt;.5&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go.work文件与go.mod文件语法一致，go.work支持三个指令：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;go：声明go版本号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;use：声明应用所依赖模块的具体文件路径，路径可以是绝对路径或相对路径，即使路径是当前应用目录外也可&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;replace：声明替换某个模块依赖的导入路径，优先级高于 go.mod 中的 replace 指令；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以针对上述场景，我们使用go work init命令在项目中对本地依赖库进行关联即可解决，后续我们只需要在git配置文件中添加go.work文件不推送到远程即可；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以在编译时通过&lt;code&gt;-workfile=off&lt;/code&gt;指令禁用工作区模式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go build -workfile=offf .&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go.work的推出主要是用于在本地调试，不会因为修改go.mod引入问题；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考文献&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在大小公司的项目应该都已经在使用&lt;code&gt;Go Modules&lt;/code&gt;进行依赖包管理了，虽然&lt;code&gt;Go Modules&lt;/code&gt;相比于Maven、npm还不是很完善，但也在不断地进行优化，变得越来越好，如果你现在项目还没有使用&lt;code&gt;go modules&lt;/code&gt;，可以准备将项目迁移到go mod了，推荐你使用；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weuitheme=&quot;light&quot; data-id=&quot;MzkyNzI1NzM5NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwB96zTfSmymj9jWokyhvSIXMRcLRAfFJsrB4uz6HBsml4T6iaia3yyCSB4aicX97icT7xBUCgw4O1PsKFQ/0?wx_fmt=png&quot; data-nickname=&quot;Golang梦工厂&quot; data-alias=&quot;AsongDream&quot; data-signature=&quot;asong是一名后端程序员，目前就职于一家电商公司，专注于Golang技术，定期分享Go语言、MySQL、Redis、Elasticsearch、计算机基础、微服务架构设计、面试等知识。这里不仅有技术，还有故事！&quot; data-from=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>374ae7d84ba69ffcc0efe190b2cf0adc</guid>
<title>Spring Boot + Disruptor = 王炸！！</title>
<link>https://toutiao.io/k/srqunta</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;pre data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;blog.csdn.net/buertianci/article/details/105327031&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;strong&gt;&lt;span&gt;01、背景&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;工作中遇到项目使用Disruptor做消息队列,对你没看错,不是Kafka,也不是rabbitmq;Disruptor有个最大的优点就是快,还有一点它是开源的哦,下面做个简单的记录.&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;strong&gt;&lt;span&gt;02、Disruptor介绍&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Disruptor 是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）。基于 Disruptor 开发的系统单线程能支撑每秒 600 万订单，2010 年在 QCon 演讲后，获得了业界关注。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Disruptor是一个开源的Java框架，它被设计用于在生产者—消费者（producer-consumer problem，简称PCP）问题上获得尽量高的吞吐量（TPS）和尽量低的延迟。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从功能上来看，Disruptor 是实现了“队列”的功能，而且是一个有界队列。那么它的应用场景自然就是“生产者-消费者”模型的应用场合了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Disruptor是LMAX在线交易平台的关键组成部分，LMAX平台使用该框架对订单处理速度能达到600万TPS，除金融领域之外，其他一般的应用中都可以用到Disruptor，它可以带来显著的性能提升。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;其实Disruptor与其说是一个框架，不如说是一种设计思路，这个设计思路对于存在“并发、缓冲区、生产者—消费者模型、事务处理”这些元素的程序来说，Disruptor提出了一种大幅提升性能（TPS）的方案。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Disruptor的github主页：https://github.com/LMAX-Exchange/disruptor&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;03、Disruptor 的核心概念&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;先从了解 Disruptor 的核心概念开始，来了解它是如何运作的。下面介绍的概念模型，既是领域对象，也是映射到代码实现上的核心对象。&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;04、Ring Buffer&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;如其名，环形的缓冲区。曾经 RingBuffer 是 Disruptor 中的最主要的对象，但从3.0版本开始，其职责被简化为仅仅负责对通过 Disruptor 进行交换的数据（事件）进行存储和更新。在一些更高级的应用场景中，Ring Buffer 可以由用户的自定义实现来完全替代。&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;05、Sequence Disruptor&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;通过顺序递增的序号来编号管理通过其进行交换的数据（事件），对数据(事件)的处理过程总是沿着序号逐个递增处理。一个 Sequence 用于跟踪标识某个特定的事件处理者( RingBuffer/Consumer )的处理进度。&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;虽然一个 AtomicLong 也可以用于标识进度，但定义 Sequence 来负责该问题还有另一个目的，那就是防止不同的 Sequence 之间的CPU缓存伪共享(Flase Sharing)问题。（注：这是 Disruptor 实现高性能的关键点之一，网上关于伪共享问题的介绍已经汗牛充栋，在此不再赘述）。&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;06、Sequencer&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Sequencer 是 Disruptor 的真正核心。此接口有两个实现类 SingleProducerSequencer、MultiProducerSequencer ，它们定义在生产者和消费者之间快速、正确地传递数据的并发算法。&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;07、Sequence Barrier&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;用于保持对RingBuffer的 main published Sequence 和Consumer依赖的其它Consumer的 Sequence 的引用。Sequence Barrier 还定义了决定 Consumer 是否还有可处理的事件的逻辑。&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;08、Wait Strategy&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;定义 Consumer 如何进行等待下一个事件的策略。（注：Disruptor 定义了多种不同的策略，针对不同的场景，提供了不一样的性能表现）&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;09、Event&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;在 Disruptor 的语义中，生产者和消费者之间进行交换的数据被称为事件(Event)。它不是一个被 Disruptor 定义的特定类型，而是由 Disruptor 的使用者定义并指定。&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;10、EventProcessor&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;EventProcessor 持有特定消费者(Consumer)的 Sequence，并提供用于调用事件处理实现的事件循环(Event Loop)。&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;11、EventHandler&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Disruptor 定义的事件处理接口，由用户实现，用于处理事件，是 Consumer 的真正实现。&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;12、Producer&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;即生产者，只是泛指调用 Disruptor 发布事件的用户代码，Disruptor 没有定义特定接口或类型。&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6650124069478908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/x0kXIOa6owUlvriaxVbDfZ33vIniamiaytU1D3qKsXNEzsCkhrOrQUAatDZItHBURbtflKM4sVAMEZ3vzy4nkCibiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;806&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;13、案例-demo&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;通过下面8个步骤,你就能将Disruptor Get回家啦：&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;1、添加po&lt;span&gt;m.xml依赖&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;com.lmax&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;disruptor&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;3.3.4&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、消息体Model&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 消息体&lt;br/&gt; */&lt;br/&gt;@Data&lt;br/&gt;public class MessageModel {&lt;br/&gt;    private String message;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、构造EventFactory&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class HelloEventFactory implements EventFactory&amp;lt;MessageModel&amp;gt; {&lt;br/&gt;    @Override&lt;br/&gt;    public MessageModel &lt;span&gt;&lt;span&gt;newInstance&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; new MessageModel();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、构造EventHandler-消费者&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Slf4j&lt;br/&gt;public class HelloEventHandler implements EventHandler&amp;lt;MessageModel&amp;gt; {&lt;br/&gt;    @Override&lt;br/&gt;    public void onEvent(MessageModel event, long sequence, boolean endOfBatch) {&lt;br/&gt;        try {&lt;br/&gt;            //这里停止1000ms是为了确定消费消息是异步的&lt;br/&gt;            Thread.sleep(1000);&lt;br/&gt;            log.info(&lt;span&gt;&quot;消费者处理消息开始&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (event != null) {&lt;br/&gt;                log.info(&lt;span&gt;&quot;消费者消费的信息是：{}&quot;&lt;/span&gt;,event);&lt;br/&gt;            }&lt;br/&gt;        } catch (Exception e) {&lt;br/&gt;            log.info(&lt;span&gt;&quot;消费者处理消息失败&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        log.info(&lt;span&gt;&quot;消费者处理消息结束&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、构造BeanManager&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 获取实例化对象&lt;br/&gt; */&lt;br/&gt;@Component&lt;br/&gt;public class BeanManager implements ApplicationContextAware {&lt;br/&gt;&lt;br/&gt;    private static ApplicationContext applicationContext = null;&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {&lt;br/&gt;        this.applicationContext = applicationContext;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public static ApplicationContext &lt;span&gt;&lt;span&gt;getApplicationContext&lt;/span&gt;&lt;/span&gt;() { &lt;span&gt;return&lt;/span&gt; applicationContext; }&lt;br/&gt;&lt;br/&gt;    public static Object getBean(String name) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; applicationContext.getBean(name);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public static &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; clazz) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; applicationContext.getBean(clazz);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6、构造MQManager&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Configuration&lt;br/&gt;public class MQManager {&lt;br/&gt;&lt;br/&gt;    @Bean(&lt;span&gt;&quot;messageModel&quot;&lt;/span&gt;)&lt;br/&gt;    public RingBuffer&amp;lt;MessageModel&amp;gt; &lt;span&gt;&lt;span&gt;messageModelRingBuffer&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        //定义用于事件处理的线程池， Disruptor通过java.util.concurrent.ExecutorSerivce提供的线程来触发consumer的事件处理&lt;br/&gt;        ExecutorService executor = Executors.newFixedThreadPool(2);&lt;br/&gt;&lt;br/&gt;        //指定事件工厂&lt;br/&gt;        HelloEventFactory factory = new HelloEventFactory();&lt;br/&gt;&lt;br/&gt;        //指定ringbuffer字节大小，必须为2的N次方（能将求模运算转为位运算提高效率），否则将影响效率&lt;br/&gt;        int bufferSize = 1024 * 256;&lt;br/&gt;&lt;br/&gt;        //单线程模式，获取额外的性能&lt;br/&gt;        Disruptor&amp;lt;MessageModel&amp;gt; disruptor = new Disruptor&amp;lt;&amp;gt;(factory, bufferSize, executor,&lt;br/&gt;                ProducerType.SINGLE, new BlockingWaitStrategy());&lt;br/&gt;&lt;br/&gt;        //设置事件业务处理器---消费者&lt;br/&gt;        disruptor.handleEventsWith(new HelloEventHandler());&lt;br/&gt;&lt;br/&gt;        // 启动disruptor线程&lt;br/&gt;        disruptor.start();&lt;br/&gt;&lt;br/&gt;        //获取ringbuffer环，用于接取生产者生产的事件&lt;br/&gt;        RingBuffer&amp;lt;MessageModel&amp;gt; ringBuffer = disruptor.getRingBuffer();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ringBuffer;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7、构造Mqservice和实现类-生产者&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface DisruptorMqService {&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 消息&lt;br/&gt;     * @param message&lt;br/&gt;     */&lt;br/&gt;    void sayHelloMq(String message);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;@Slf4j&lt;br/&gt;@Component&lt;br/&gt;@Service&lt;br/&gt;public class DisruptorMqServiceImpl implements DisruptorMqService {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private RingBuffer&amp;lt;MessageModel&amp;gt; messageModelRingBuffer;&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void sayHelloMq(String message) {&lt;br/&gt;        log.info(&lt;span&gt;&quot;record the message: {}&quot;&lt;/span&gt;,message);&lt;br/&gt;        //获取下一个Event槽的下标&lt;br/&gt;        long sequence = messageModelRingBuffer.next();&lt;br/&gt;        try {&lt;br/&gt;            //给Event填充数据&lt;br/&gt;            MessageModel event = messageModelRingBuffer.get(sequence);&lt;br/&gt;            event.setMessage(message);&lt;br/&gt;            log.info(&lt;span&gt;&quot;往消息队列中添加消息：{}&quot;&lt;/span&gt;, event);&lt;br/&gt;        } catch (Exception e) {&lt;br/&gt;            log.error(&lt;span&gt;&quot;failed to add event to messageModelRingBuffer for : e = {},{}&quot;&lt;/span&gt;,e,e.getMessage());&lt;br/&gt;        } finally {&lt;br/&gt;            //发布Event，激活观察者去消费，将sequence传递给改消费者&lt;br/&gt;            //注意最后的publish方法必须放在finally中以确保必须得到调用；如果某个请求的sequence未被提交将会堵塞后续的发布操作或者其他的producer&lt;br/&gt;            messageModelRingBuffer.publish(sequence);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8、构造测试类及方法&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@Slf4j&lt;br/&gt;@RunWith(SpringRunner.class)&lt;br/&gt;@SpringBootTest(classes = DemoApplication.class)&lt;br/&gt;public class DemoApplicationTests {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private DisruptorMqService disruptorMqService;&lt;br/&gt;    /**&lt;br/&gt;     * 项目内部使用Disruptor做消息队列&lt;br/&gt;     * @throws Exception&lt;br/&gt;     */&lt;br/&gt;    @Test&lt;br/&gt;    public void sayHelloMqTest() throws Exception{&lt;br/&gt;        disruptorMqService.sayHelloMq(&lt;span&gt;&quot;消息到了，Hello world!&quot;&lt;/span&gt;);&lt;br/&gt;        log.info(&lt;span&gt;&quot;消息队列已发送完毕&quot;&lt;/span&gt;);&lt;br/&gt;        //这里停止2000ms是为了确定是处理消息是异步的&lt;br/&gt;        Thread.sleep(2000);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;测试运行结果&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2020-04-05 14:31:18.543  INFO 7274 --- [           main] c.e.u.d.d.s.Impl.DisruptorMqServiceImpl  : record the message: 消息到了，Hello world!&lt;br/&gt;2020-04-05 14:31:18.545  INFO 7274 --- [           main] c.e.u.d.d.s.Impl.DisruptorMqServiceImpl  : 往消息队列中添加消息：MessageModel(message=消息到了，Hello world!)&lt;br/&gt;2020-04-05 14:31:18.545  INFO 7274 --- [           main] c.e.utils.demo.DemoApplicationTests      : 消息队列已发送完毕&lt;br/&gt;2020-04-05 14:31:19.547  INFO 7274 --- [pool-1-thread-1] c.e.u.d.disrupMq.mq.HelloEventHandler    : 消费者处理消息开始&lt;br/&gt;2020-04-05 14:31:19.547  INFO 7274 --- [pool-1-thread-1] c.e.u.d.disrupMq.mq.HelloEventHandler    : 消费者消费的信息是：MessageModel(message=消息到了，Hello world!)&lt;br/&gt;2020-04-05 14:31:19.547  INFO 7274 --- [pool-1-thread-1] c.e.u.d.disrupMq.mq.HelloEventHandler    : 消费者处理消息结束&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;14、总结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;其实 生成者 -&amp;gt; 消费者 模式是很常见的，通过一些消息队列也可以轻松做到上述的效果。不同的地方在于，Disruptor 是在内存中以队列的方式去实现的，而且是无锁的。&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;这也是 Disruptor 为什么高效的原因。&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;往期肝货整理&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>