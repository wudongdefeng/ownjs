<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>915293a7acc43cd55fc0a77637291615</guid>
<title>有些技术原理你完全看不懂</title>
<link>https://toutiao.io/k/rww5ta2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;上一篇文章写了 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247503600&amp;amp;idx=1&amp;amp;sn=4f59f1a127c793c9b478b2622b16e909&amp;amp;chksm=c2c5b45df5b23d4b964ef64713a035d4bdd680414a1a2e21d4b36173624352738012e521254c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;为什么 JVM 叫做基于栈的 RISC 虚拟机&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;为什么 JVM 叫做基于栈的 RISC 虚拟机&lt;/a&gt;，看评论里不少人反馈一脸懵逼。&lt;/p&gt;&lt;p&gt;但我相信应该也有不少读者会觉得我整篇文章都在讲废话。&lt;/p&gt;&lt;p&gt;为什么会有这么两极分化的差异呢？&lt;/p&gt;&lt;p&gt;因为如果你知道什么是 ISA，并且把 x86、arm 等指令集都了解过，并且切实感受到了 RISC 和 CISC 指令集的区别，同时也知道基于栈的和基于寄存器的指令集的区别。那么整篇文章就除了标题外全都是废话了。&lt;/p&gt;&lt;p&gt;但如果这些你都不了解的话，那么标题就是天书，整篇文章看下来也只能明白个马马虎虎，除非你把我里面提到的所有手册和源码都浏览过。&lt;/p&gt;&lt;p&gt;所以为什么底层的这些知识非常重要，它能让你秒懂一个技术的原理，而且还能比别人理解得更透彻，上篇文章就是个很好的例子。&lt;/p&gt;&lt;p&gt;------&lt;/p&gt;&lt;p&gt;在咱们国家，计算机底层的教育是十分不重视的，整个环境也不太乐观，大部分人急功近利，只想尽快掌握到能直接提升薪资的上层技术。&lt;/p&gt;&lt;p&gt;同时，网上充斥大量的二手三手四手的博客，被那些专门研究搜索引擎的网站占据了半壁江山。&lt;/p&gt;&lt;p&gt;在公司，也动不动就讲业务价值，把没有的说成有的，把别人的说成自己的，欺骗业务，欺骗自己，还引以为傲。&lt;/p&gt;&lt;p&gt;------&lt;/p&gt;&lt;p&gt;算了，不说这些了。&lt;/p&gt;&lt;p&gt;曾经我因为寻找一手资料而苦恼，一搜就被一大堆二手信息覆盖掉了。&lt;/p&gt;&lt;p&gt;当然，这一部分锅要百度来背，用谷歌搜索一手技术资料会好很多。&lt;/p&gt;&lt;p&gt;于是，我给自己建立了一个一手资料索引的 Github，并且按照顺序自底向上排列了起来。&lt;/p&gt;&lt;p&gt;https://github.com/sunym1993/computer-all&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8993288590604027&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRBv2yqAtAQwK0lGwcPYiaLbiaygKBmUpXBL4QhfQaPz2BHKicYyQfGxWTNv00y8f6doB4L9YCyibv9Ow/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;对，名字起得有点大，叫&lt;strong&gt;关于计算机的一切&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;我希望这里成为我今后学习技术或分享技术的唯一资料入口，这里会保留所有最原汁原味的一手信息，包括手册、官方文档、源码，以及个别非常优质的对一手资料进行简化、格式化、结构化，而不是自行理解和篡改的网站或博客。&lt;/p&gt;&lt;p&gt;当然这个小天地才刚刚开始建立，也非常需要大家的智慧来一起进行完善！&lt;/p&gt;&lt;p&gt;------&lt;/p&gt;&lt;p&gt;有同学觉得，读手册是不是太浪费时间了，直接百度找个博客能快速把知识点学会。&lt;/p&gt;&lt;p&gt;不，暂且不说知识体系的系统性问题，就光拿一个知识点来说，网上博客你看了一圈又一圈，写成啥样的都有，尤其是需要严谨性的一些底层技术，到头来还不如花点时间看看手册。&lt;/p&gt;&lt;p&gt;比如我之前搞不懂 GNU C 和 ANSI C 的关系，网上搜一圈后你会发现更加一头雾水，还得忙着辨别真伪。&lt;/p&gt;&lt;p&gt;但只要你打开 GNU C 的手册，开头就把这个问题说的一清二楚。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.24863174354964818&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1279&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRBv2yqAtAQwK0lGwcPYiaLbiaOdk5gKhZVtu2GcxNF0tRibSUicIILaVuqak8uueTN9qJ2nd2Jrqk3Zg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果对这些抽象的描述无法具象化，那么只需要手册再翻一页，看一下具体例子就明白了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3559479553903346&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRBv2yqAtAQwK0lGwcPYiaLbgmNCY31mXFs27iccRwMSazO3SM3l6Zib965LW8t63m9Kxs1TlTJwnWsA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;------&lt;/p&gt;&lt;p&gt;再比如上篇文章里讲的，JVM 执行引擎在执行字节码的时候，一种是用古老的字节码解释器，用纯&quot;软件&quot;的方式来模拟执行，效率很低，另一种是用模板解释器，将每个字节码指令都映射为一个函数，直接写入机器码来执行，可针对不同 CPU 体系结构进行优化，效率很高。&lt;/p&gt;&lt;p&gt;这句话你背面试八股文的时候一定听过，而且你可能觉得挺高大上的，但如果你看过源码之后再理解这句话，就觉得它很可笑。&lt;/p&gt;&lt;p&gt;用纯软件的方式模拟执行的字节码解释器，就是用一个 topOfStack 数组来实现所谓的操作数栈，压一个值数组的一个指针就往后挪一下，弹一个值那就往前挪一下，就操作个数组嘛~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2833333333333333&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRCDApAzMVibJOWhf2PMibTGPxvhicPmdSvV3gJewiaQrMnTzAIelLxxx5qjj4bkMUx5CsZzAsVVRp8LA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;模板解释器将每个字节码指令都映射为一个函数，就是按每个字节码来命名一个函数。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2465753424657534&quot; data-w=&quot;876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXQYN0k6YY3WeicZEbQYiaMO0vuhdgbnWcnZ7ERYezC4hFrUYo0GVYMoqTo2MWbgc1LS5TUrxN1Z8w2w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;直接写入机器码就是查各种 CPU 的手册，拼好二进制的值写进去。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20797413793103448&quot; data-w=&quot;928&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRCDApAzMVibJOWhf2PMibTGPscsnfCMLIewFGKGEQsm5EYYqbkkAll1WEPyR8aZXGzEmrGy8gkZqGQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;所谓查手册，就和人家的接口说明文档一样，那可比公司里别人写的接口文档好看多啦~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41574074074074074&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRCDApAzMVibJOWhf2PMibTGPfdNSw1RtWKoUBSlHKt5CPI7IGaHdVnV1T73y0ro9q4uQDvDPu4HsUg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;不同 CPU 就是不同的 .cpp 文件，分布在不同文件夹下面，简单粗暴，每个都是查手册写二进制数值，辛苦一点罢了。除非你是专门搞这些指令集的，比如把 OpenJDK 改造一下让它适配龙芯 CPU，那可能是个工程量很大的活，但原理很简单。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32213740458015266&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRBv2yqAtAQwK0lGwcPYiaLbibmIibzh3TZibzouoPRib8aEOpb4qbGVlOMIBkyuWwKrctLK1bgHmiamhmA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;里面的 x86 就是我们常用的 Intel x86 CPU 嘛~&lt;/p&gt;&lt;p&gt;看到了这些底层的本质，你还觉得刚刚那句话高大上么？呵呵。&lt;/p&gt;&lt;p&gt;------&lt;/p&gt;&lt;p&gt;好啦，最后希望大家能够尊重技术，重视底层，养成查阅一手资料的好习惯。&lt;/p&gt;&lt;p&gt;老读者可能也发现了我文章的变化，从一开始的破玩意风格文章，变成现在的从一手资料里找论据并推理类型的文章。&lt;/p&gt;&lt;p&gt;我觉得，这样类型的文章并不代表会失去生动和形象，它反而能让你更容易理解到技术的本质，至于如何把它写的更生动，更易读，这就是我要努力的方向了，但这条路准没错。&lt;/p&gt;&lt;p&gt;最后，希望大家和我一起共建这块小天地，关于计算机的一切，靠你们啦~&lt;/p&gt;&lt;p&gt;https://github.com/sunym1993/computer-all&lt;/p&gt;&lt;p&gt;下方&lt;strong&gt;阅读原文&lt;/strong&gt;可以直接跳转过去。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0MjE3NDE0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRVh3YhnV9yvZK9TGpSsFykUQPtHm4TuNAOUOr5qtPyZlg4DNciaYWiasRx1Fgt6UFTDjaK9qc08Llw/0?wx_fmt=png&quot; data-nickname=&quot;低并发编程&quot; data-alias=&quot;dibingfa&quot; data-signature=&quot;生活也同样如此&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d96fff8258668e4ed57cf6a8d8b3ba53</guid>
<title>Java 字符串 split 的一个反直觉陷阱</title>
<link>https://toutiao.io/k/dv65u05</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article fmt article-content &quot;&gt;&lt;p&gt;最近生产环境遇到一个奇怪的数组下标越界报错，如下图代码所示，我们可以肯定的是 &lt;code&gt;fieldName&lt;/code&gt; 变量不为空（不是空字符串，也不是 &lt;code&gt;null&lt;/code&gt;），但是代码执行到读取 &lt;code&gt;names[0]&lt;/code&gt; 变量的时候，抛出了一个 &lt;strong&gt;数组下标越界&lt;/strong&gt; （&lt;code&gt;java.lang.ArrayIndexOutOfBoundsException&lt;/code&gt;） 的异常。&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912345&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;异常信息如下图所示&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912346&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;问题很简单，我们对一个字符串执行 &lt;code&gt;split&lt;/code&gt; 方法之后，以过往其它编程语言（Go、PHP、Javascript、Dart 等）的使用经验来看，即使字符串为空，即使没有匹配到分隔符，在返回值数组中也会包含一个当前字符串的值。但是这里却抛出了 &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;，难道 &lt;code&gt;split&lt;/code&gt; 方法的返回值可能为空数组？&lt;/p&gt;&lt;p&gt;最终经过排查发现，在上述代码段中，当 &lt;code&gt;fieldName&lt;/code&gt; 的值为 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 的时候，我们访问 &lt;code&gt;names[0]&lt;/code&gt; 就会抛出 &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;，为什么会这样呢？&lt;/p&gt;&lt;p&gt;本文将会持续修正和更新，最新内容请参考我的 &lt;a href=&quot;https://link.segmentfault.com/?enc=bgMEGr%2BjxSNJ3YOMolHXsA%3D%3D.httwjFxqDZQml65dpc9jKd5T7jF7JuwiNelue%2Bs%2B3qQ%3D&quot; rel=&quot;nofollow&quot;&gt;GITHUB&lt;/a&gt; 上的 &lt;a href=&quot;https://link.segmentfault.com/?enc=66Ha7CAMrHZQGFxdCpDAFw%3D%3D.ythCQfNMbLABJ57o9hifk%2FdNZXi9C2kei5mqMXi3JkSXSdl5ysvnSP5cr7tmLLKV&quot; rel=&quot;nofollow&quot;&gt;程序猿成长计划&lt;/a&gt; 项目，欢迎 Star，更多精彩内容请 &lt;a href=&quot;https://link.segmentfault.com/?enc=HjlveqFo1D6ZsJL4Qjnd7w%3D%3D.xUIx%2BxP7RwhUmoluR%2FD6mYBqyJwX%2BMQky67%2B14H8drk%3D&quot; rel=&quot;nofollow&quot;&gt;follow me&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;问题&lt;/h2&gt;&lt;p&gt;在 Java 中，如果执行下面这段代码，直觉上你认为会输出什么？&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;String str = &quot;~&quot;;
String []arr = str.split(&quot;~&quot;);

System.out.println(arr.length);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你有其他编程语言的经验，可能直觉上会觉得这里输出的应该是 &lt;strong&gt;2&lt;/strong&gt;，但是遗憾的是，这里输出的是 &lt;strong&gt;0&lt;/strong&gt;，变量 &lt;code&gt;arr&lt;/code&gt; 是个空数组。&lt;/p&gt;&lt;p&gt;这里不禁怀疑自己之前的记忆是不是有偏差，于是我又使用其它语言来尝试复现这个问题。&lt;/p&gt;&lt;h2&gt;不同语言中 split 的行为&lt;/h2&gt;&lt;p&gt;我总结了一个表格，说明了不用语言不同的行为，这里对比的是执行 &lt;code&gt;split&lt;/code&gt; 函数/方法后返回数组的长度：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;语言\函数&lt;/th&gt;&lt;th&gt;&lt;code&gt;&quot;&quot;.split(&quot;&quot;)&lt;/code&gt;&lt;/th&gt;&lt;th&gt;&lt;code&gt;&quot;~&quot;.split(&quot;~&quot;)&lt;/code&gt;&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;&lt;code&gt;&quot;~~&quot;.split(&quot;~&quot;)&lt;/code&gt;&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;&lt;code&gt;&quot;&quot;.split(&quot;~&quot;)&lt;/code&gt;&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;&lt;code&gt;&quot;~123&quot;.split(&quot;~&quot;)&lt;/code&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Javascript&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PHP&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Dart&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Golang&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Scala&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;Javascript&lt;/h3&gt;&lt;p&gt;首先是 Javascript，在浏览器的控制台上直接执行，得到了下面的结果&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&quot;&quot;.split(&quot;&quot;)
&quot;~&quot;.split(&quot;~&quot;)
&quot;~~&quot;.split(&quot;~&quot;)
&quot;&quot;.split(&quot;~&quot;)
&quot;~123&quot;.split(&quot;~&quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912347&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;跟我的直觉是一致的，同样的情况，这里返回的是 &lt;strong&gt;2&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;PHP&lt;/h3&gt;&lt;p&gt;在 PHP 中，我使用了 &lt;code&gt;mb_split&lt;/code&gt; 函数，该函数用于对多字节字符串进行分割&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912348&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;执行结果如下&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912349&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;执行结果跟我的直觉也是一致的，同样的情况，这里返回的是 &lt;strong&gt;2&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;Dart&lt;/h3&gt;&lt;p&gt;然后是 Google 的 Dart，这是一门主要用于使用 Flutter 来开发跨平台应用的编程语言，代码如下&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;dart&quot;&gt;void main() {
    print(&quot;&quot;.split(&#x27;&#x27;).length); // 0
    print(&quot;~&quot;.split(&#x27;~&#x27;).length); // 2
    print(&quot;~~&quot;.split(&#x27;~&#x27;).length); // 3
    print(&quot;&quot;.split(&#x27;~&#x27;).length); // 1
    print(&quot;~123&quot;.split(&#x27;~&#x27;).length); // 2
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912350&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;同样，&lt;code&gt;&quot;~&quot;.split(&quot;~&quot;)&lt;/code&gt; 也是返回了两个值。&lt;/p&gt;&lt;h3&gt;Golang&lt;/h3&gt;&lt;p&gt;在 Golang 中，执行结果依旧是符合直觉的，返回的是 &lt;strong&gt;2&lt;/strong&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;go&quot;&gt;package main

import(
    &quot;strings&quot;
    &quot;fmt&quot;
)

func main() {
    printStrs(strings.Split(&quot;&quot;, &quot;&quot;)) // 0 []
    printStrs(strings.Split(&quot;~&quot;, &quot;~&quot;)) // 2 [&quot;&quot;, &quot;&quot;, ]
    printStrs(strings.Split(&quot;~~&quot;, &quot;~&quot;)) // 3 [&quot;&quot;, &quot;&quot;, &quot;&quot;, ]
    printStrs(strings.Split(&quot;&quot;, &quot;~&quot;)) // 1 [&quot;&quot;, ]
    printStrs(strings.Split(&quot;~123&quot;, &quot;~&quot;)) // 2 [&quot;&quot;, &quot;123&quot;, ]
}

func printStrs(s []string) {
    fmt.Print(len(s), &quot; [&quot;)
    for _, item := range s {
        fmt.Printf(`&quot;%s&quot;, `, item)
    }

    fmt.Print(&quot;]\n&quot;)
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912351&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;h3&gt;Scala&lt;/h3&gt;&lt;p&gt;然后，我又尝试了 Scala，发现在 Scala 中， &lt;code&gt;split&lt;/code&gt; 的行为有些不一样了。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;&quot;&quot;.split(&quot;&quot;).length
&quot;~&quot;.split(&quot;~&quot;).length
&quot;~~&quot;.split(&quot;~&quot;).length
&quot;&quot;.split(&quot;~&quot;).length
&quot;~123&quot;.split(&quot;~&quot;).length&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912352&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;代码 &lt;code&gt;&quot;~&quot;.split(&quot;~&quot;)&lt;/code&gt; 返回的是 &lt;strong&gt;空数组&lt;/strong&gt;，与在 Java 中我们遇到的问题如出一辙。&lt;/p&gt;&lt;h3&gt;Java&lt;/h3&gt;&lt;p&gt;最后，我又用 Java 执行了同样的代码&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package example;
import org.junit.Test;

public class ExampleTest {
  @Test
  public void testSplit() {
    printStrings(&quot;&quot;.split(&quot;&quot;)); // 1 [&quot;&quot;, ]
    printStrings(&quot;~&quot;.split(&quot;~&quot;)); // 0 []
    printStrings(&quot;~~&quot;.split(&quot;~&quot;)); // 0 []
    printStrings(&quot;&quot;.split(&quot;~&quot;)); // 1 [&quot;&quot;, ]
    printStrings(&quot;~123&quot;.split(&quot;~&quot;)); // 2 [&quot;&quot;, &quot;123&quot;, ]
  }
  
  private void printStrings(String[] strings) {
    System.out.print(strings.length + &quot; [&quot;);
    for (String str : strings) {
      System.out.printf(&quot;\&quot;%s\&quot;, &quot;, str);
    }
    System.out.println(&quot;]&quot;);
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912353&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;结果与 Scala 是一致的，同时也解释了为什么我们会遇到 &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; 的问题。&lt;/p&gt;&lt;h2&gt;原因&lt;/h2&gt;&lt;p&gt;翻阅了 Java 的 API 文档，发现原来 Java 中的 &lt;code&gt;split&lt;/code&gt; 方法确实跟其它语言是不一样的，这一点我们特别容易忽略&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912354&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果分隔符表达式与字符串不匹配，则返回原始字符串作为数组的唯一值，这也就解释了&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&quot;&quot;.split(&quot;&quot;) // 1 [&quot;&quot;]
&quot;&quot;.split(&quot;~&quot;) // 1 [&quot;&quot;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果分隔符表单式与字符串的开始字符就已经匹配了，则返回值中第一个元素会被设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&quot;~123&quot;.split(&quot;~&quot;) // 2 [&quot;&quot;, &quot;123&quot;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果 &lt;code&gt;limit&lt;/code&gt; 参数为 &lt;strong&gt;0&lt;/strong&gt;，也就是 &lt;code&gt;split(String regex)&lt;/code&gt; 方法，则匹配结果末尾的所有空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; 都会被丢弃，也就解释了下面两段代码&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&quot;~&quot;.split(&quot;~&quot;) // 0 []
&quot;~~&quot;.split(&quot;~&quot;) // 0 []&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912355&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;然后我又翻阅了 Scala 的官方文档，Scala 和 Java 的行为是一致的。&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912356&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;在 Java 中使用字符串的 &lt;code&gt;split&lt;/code&gt; 方法，一般情况下的行为是和其他编程语言是一致的，但在一些边界条件下，也有一些不一致的地方，这一点是我们应该注意的，这也提醒了我们，不要想当然的认为不同语言，同名函数（方法）的功能是完全一致的，当我们遇到一些奇奇怪怪的问题时，多看官方文档才是硬道理。&lt;/p&gt;&lt;p&gt;本文将会持续修正和更新，最新内容请参考我的 &lt;a href=&quot;https://link.segmentfault.com/?enc=%2BqD1BHT8y58S%2Fah7Lnn3nA%3D%3D.qao2i7b4QmDPDMHacsCCM6Cj6fNhyfhTobCU7%2B9Oou4%3D&quot; rel=&quot;nofollow&quot;&gt;GITHUB&lt;/a&gt; 上的 &lt;a href=&quot;https://link.segmentfault.com/?enc=2OurG%2FjL8JsVrSm82H2Btg%3D%3D.LpI%2FvYxdOY5eJiVvelYkjPSVu6nl96WXoSXCtDJzSVW%2BujeUqqd3Oby0UkiSnb1V&quot; rel=&quot;nofollow&quot;&gt;程序猿成长计划&lt;/a&gt; 项目，欢迎 Star，更多精彩内容请 &lt;a href=&quot;https://link.segmentfault.com/?enc=nSY%2F9ieKl%2B67t6zSqlXhNQ%3D%3D.VWHJre%2BwPI%2FrFlO6chvzHSl6p%2Fl0%2FQFgirUMp79r428%3D&quot; rel=&quot;nofollow&quot;&gt;follow me&lt;/a&gt;。&lt;/p&gt;&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8af3f782735b7683576d3229e642be64</guid>
<title>CentOS 下安装 Docker 极简教程</title>
<link>https://toutiao.io/k/t9yi9em</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;关于 Java、PHP、其他编程语言……或安全、或码农、或技术、或总结！学习交流，共同进步！码农 up to you，码农UP2U!&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;早期文章&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        上篇文章通过 Vagrant 给 VirtualBox 安装了 CentOS，这篇再整理一下在 CentOS 下安装 Docker。Vagrant + VirtualBox + Docker 来搭建开发环境是很方便的，不过机器性能不高的话会很卡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2459016393442623&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwtjkRulU9ibyGWmthOxbo86D6olNnT89mIwdwGicloBjqFHic9SmdDEwibdib0LyQQnAVicItPDVsm9KFWlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1037&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.卸载系统中的docker&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        首先来卸载一下当前的 docker，当然系统中可能没有。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo yum remove docker \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docker-client \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docker-client-latest \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docker-common \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docker-latest \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docker-latest-logrotate \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docker-logrotate \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docket-engine&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Failed to set locale, defaulting to C&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Loaded plugins: fastestmirror&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker-client&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker-client-latest&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker-common&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker-latest&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker-latest-logrotate&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker-logrotate&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docket-engine&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Packages marked for removal&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.安装对应的依赖环境和镜像地址&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        安装yum-utils，它属于是yum的一个扩展工具。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo yum install -y yum-utils&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Complete!&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        然后呢，添加 Docker 的资源库。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo yum-config-manager \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; --add-repo \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; https://download.docker.com/linux/centos/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Failed to set locale, defaulting to C&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Loaded plugins: fastestmirror&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;adding repo from: https://download.docker.com/linux/centos/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;grabbing file https://download.docker.com/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;repo saved to /etc/yum.repos.d/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        官网的速度可能较慢，这里也可以添加阿里云的资源库。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo yum-config-manager \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; --add-repo \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Failed to set locale, defaulting to C&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Loaded plugins: fastestmirror&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;adding repo from: http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;grabbing file http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;repo saved to /etc/yum.repos.d/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.安装 Docker&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        这里通过 yum 安装 docker-ce、docker-ce-cli 和 containerd.io。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo yum install -y docker-ce docker-ce-cli containerd.io&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Failed to set locale, defaulting to C&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Loaded plugins: fastestmirror&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Loading mirror speeds from cached hostfile&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * base: mirror.lzu.edu.cn&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * extras: mirrors.ustc.edu.cn&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * updates: mirrors.ustc.edu.cn&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker-ce-stable                                                                                                     | 3.5 kB  00:00:00     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(1/2): docker-ce-stable/7/x86_64/updateinfo                                                                          |   55 B  00:00:00     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(2/2): docker-ce-stable/7/x86_64/primary_db                                                                          |  88 kB  00:00:00     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Complete!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其中 docker-ce 是 Docker 的社区版，专门用于开发人员和小团队创建基于容器的应用。比如，我们现在就是在搭建开发环境。docker-ce-cli 相当于是个命令行工具。&lt;/span&gt;&lt;span&gt;&lt;span&gt;containerd.io 是 一个守护进程&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.启动 Docker 并查看运行中的容器&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        启动 docker 直接使用 systemctl 或者 service 即可启动。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo systemctl start docker&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo docker ps&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        通过 docker ps 命令可以查看运行中的容器，当然了，我们这里只是刚刚安装了 Docker，不会有运行中的容器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.查看 Docker 版本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        查看 Docker 的版本，其实就类似于我们安装完 JDK 并配置完 JDK 的环境变量以后，通过 java -version 来验证一下安装和配置是否正确。我们通过 docker version 来查看 Docker 是否安装成功。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[root@localhost ~]# docker version&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Client: Docker Engine - Community&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Version:           20.10.21&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; API version:       1.41&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Go version:        go1.18.7&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Git commit:        baeda1f&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Built:             Tue Oct 25 18:04:24 2022&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; OS/Arch:           linux/amd64&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Context:           default&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Experimental:      true&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Server: Docker Engine - Community&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Engine:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Version:          20.10.21&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  API version:      1.41 (minimum version 1.12)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Go version:       go1.18.7&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Git commit:       3056208&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Built:            Tue Oct 25 18:02:38 2022&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  OS/Arch:          linux/amd64&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Experimental:     false&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; containerd:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Version:          1.6.10&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  GitCommit:        770bd0108c32f3fb5c73ae1264f7e503fe7b2661&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; runc:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Version:          1.1.4&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  GitCommit:        v1.1.4-0-g5fd4c4d&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; docker-init:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Version:          0.19.0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  GitCommit:        de40ad0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        其实此时执行 docker version 有些多此一举，因为我们在上一步启动 Docker 后执行了 docker ps 命令，就相当于验证 Docker 是否启动成功了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6.设置开机自启动&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        最后呢，让 Docker 每次开机自动运行。因为我们是开发环境，虚拟机用完就关机了，下次启动虚拟机，让 Docker 跟着启动对于我们开发来说更方便一些。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[root@localhost ~]&lt;span class=&quot;code-snippet__meta&quot;&gt;# systemctl enable docker&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        好啦，Docker 的安装就到这了！一个很简单的教程！！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0712962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthBDooApBDUM9yqM6BWHMOaJyrXzMxqibI7B90xNgZswWSVSatF56vMAicAA56UmJkc2rQlDUARycYQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【mongo】 下载 SpringBoot 整合操作 MongoDB 的文档。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;cisp知识整理&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;】 下载 CISP 读书笔记。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复【java开发手册】获取《Java开发手册》黄山版。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;关于 Java、PHP、其他编程语言……或安全、或码农、或技术、或总结！学习交流，共同进步！码农 up to you，码农UP2U!&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JHWsQdz8yVn3MVh22hia7NFoPyNJz4ZI7XUnMa9xM50TJRqPkWf7BRibQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>000af248a4fd15f412ee83d9ccbea8c0</guid>
<title>SpringBoot 使用 Feign  无废话 All-in-one 指南</title>
<link>https://toutiao.io/k/y5lw3yh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;庾信平生最萧瑟，&lt;span&gt;暮年诗赋动江关&lt;/span&gt;&lt;/p&gt;&lt;p&gt;欢迎关注【架构染色】交流学习&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开篇&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Feign 是声明式、模板化的 HTTP 客户端， 可以帮助我们更快捷、优雅地调用 HTTP API；Spring Cloud 为 Feign 添加了 Spring MVC 的注解支持，并整合了 Ribbon 和 Eureka 来为使用 Feign 时提供负载均衡；在 Spring Cloud 中使用 Feign 是非常容易的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇主要介绍 SpringBoot 中要玩转 Feign 需要掌握的如添加 pom 依赖、客户端注解启用、切换底层 HttpClient、配置数据压缩、调整日志级别、定制配置、配置的优先级机制、增加拦截器以及拦截器的追加机制等知识。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、使用 Feign 的示例&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 添加依赖&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;!--openfein的依赖--&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-openfeign&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.1.3.RELEASE&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 启用 Feign&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 SpringBoot 的启用类上添加注解&lt;code&gt;@EnableFeignClients&lt;/code&gt;，&lt;code&gt;@EnableFeignClients&lt;/code&gt;用于开启 Feign，会自动扫描&lt;code&gt;@FeignClient&lt;/code&gt;标注的 FeignClient 接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@SpringBootApplication&lt;br/&gt;@EnableFeignClients&lt;br/&gt;@EnableWeb&lt;br/&gt;public class FeignApplication {&lt;br/&gt;    public static void main(String[] args) {&lt;br/&gt;        SpringApplication.run(FeignApplication.class,args);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 编写 FeignClient 接口&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@FeignClient(&lt;br/&gt;        name = &lt;span&gt;&quot;demo-service&quot;&lt;/span&gt;,&lt;br/&gt;        url = &lt;span&gt;&quot;http://localhost:8080/feign/server/&quot;&lt;/span&gt;,&lt;br/&gt;        configuration = FeignInterceptor.class,&lt;br/&gt;        fallback = TestService.DefaultFallback.class&lt;br/&gt;)&lt;br/&gt;public interface TestService {&lt;br/&gt;&lt;br/&gt;    @RequestMapping(value = &lt;span&gt;&quot;/getError/{id}&quot;&lt;/span&gt;, method = RequestMethod.GET)&lt;br/&gt;    public String getError(@RequestParam(&lt;span&gt;&quot;id&quot;&lt;/span&gt;) Integer id);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    @RequestMapping(value = &lt;span&gt;&quot;/get1&quot;&lt;/span&gt;, method = RequestMethod.GET)&lt;br/&gt;    public String get1();&lt;br/&gt;&lt;br/&gt;    @RequestMapping(value = &lt;span&gt;&quot;/get2/{param}&quot;&lt;/span&gt;, method = RequestMethod.GET)&lt;br/&gt;    public String get2(@RequestParam(&lt;span&gt;&quot;param&quot;&lt;/span&gt;) String param);&lt;br/&gt;&lt;br/&gt;    @RequestMapping(value = &lt;span&gt;&quot;/post1&quot;&lt;/span&gt;, method = RequestMethod.POST)&lt;br/&gt;    public FeignDemo post1(@RequestBody FeignDemo demo);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4 编写对应的服务端&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@RestController&lt;br/&gt;@RequestMapping(&lt;span&gt;&quot;/feign/server&quot;&lt;/span&gt;)&lt;br/&gt;public class FeignServerController {&lt;br/&gt;&lt;br/&gt;    @GetMapping(&lt;span&gt;&quot;/get1&quot;&lt;/span&gt;)&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;get1&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;get1&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    @GetMapping(&lt;span&gt;&quot;/get2/{para}&quot;&lt;/span&gt;)&lt;br/&gt;    public String get2(@PathVariable(&lt;span&gt;&quot;para&quot;&lt;/span&gt;) String para){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; para;&lt;br/&gt;    }&lt;br/&gt;    @PostMapping(&lt;span&gt;&quot;/post1&quot;&lt;/span&gt;)&lt;br/&gt;    public FeignDemo  post1(@RequestBody FeignDemo demo) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; demo;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class FeignDemo {&lt;br/&gt;    private String name;&lt;br/&gt;    private Integer age;&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getName&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setName(String name) {&lt;br/&gt;        this.name = name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public Integer &lt;span&gt;&lt;span&gt;getAge&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setAge(Integer age) {&lt;br/&gt;        this.age = age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;toString&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;FeignDemo{&quot;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;name=&#x27;&quot;&lt;/span&gt; + name + &lt;span&gt;&#x27;\&#x27;&lt;/span&gt;&lt;span&gt;&#x27; +&lt;br/&gt;                &quot;, age=&quot; + age +&lt;br/&gt;                &#x27;&lt;/span&gt;}&lt;span&gt;&#x27;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.5 调用 FeignClient&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@RunWith(SpringJUnit4ClassRunner.class)&lt;br/&gt;@SpringBootTest(classes = {FeignApplication.class},webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)&lt;br/&gt;@ActiveProfiles(&lt;span&gt;&quot;dev,feign&quot;&lt;/span&gt;)&lt;br/&gt;public class FeignClientTest {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private TestService testService;&lt;br/&gt;&lt;br/&gt;    @Test&lt;br/&gt;    public void &lt;span&gt;&lt;span&gt;testFallback&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        testService.getError(1);&lt;br/&gt;    }&lt;br/&gt;    @Test&lt;br/&gt;    public void &lt;span&gt;&lt;span&gt;testGet1&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        System.out.println(testService.get1());&lt;br/&gt;        System.out.println(testService.get2(&lt;span&gt;&quot;abc&quot;&lt;/span&gt;));&lt;br/&gt;        System.out.printf(&lt;span&gt;&quot;..&quot;&lt;/span&gt;);&lt;br/&gt;        FeignDemo feignDemo = new FeignDemo();&lt;br/&gt;        feignDemo.setName(&lt;span&gt;&quot;name&quot;&lt;/span&gt;);&lt;br/&gt;        feignDemo.setAge(1);&lt;br/&gt;        System.out.println(testService.post1(feignDemo));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;@Component&lt;br/&gt;    public class DefaultFallback implements TestService {&lt;br/&gt;&lt;br/&gt;        @Override&lt;br/&gt;        public String getError(@RequestParam(&lt;span&gt;&quot;id&quot;&lt;/span&gt;) Integer id){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        @Override&lt;br/&gt;        public String &lt;span&gt;&lt;span&gt;get1&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        @Override&lt;br/&gt;        public String get2(String param) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        @Override&lt;br/&gt;        public FeignDemo post1(FeignDemo demo) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、如何切换 Client&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Feign 中自带的是 HttpURLConnection，这个 client 健壮性差，可替换为成熟的 Apache HttpClient 或 OkHttp 来进行网络请求。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 使用 Apache 的 HTTP Client&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Apache 的 &lt;code&gt;httpclient&lt;/code&gt; 替换 Feign 中默认的 client。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.1 添加依赖&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!--httpclient的依赖，因为选择了使用httpclient--&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.httpcomponents&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;httpclient&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.github.openfeign&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;feign-httpclient&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;10.4.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.2 配置启用&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置中添加如下信息，表示启用&lt;code&gt;httpclient&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;feign:&lt;br/&gt;  httpclient:&lt;br/&gt;    enabled: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 使用 OkHttp&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.1 添加依赖&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Feign 中使用&lt;code&gt;OkHttp&lt;/code&gt;作为网络请求框架，则只需要在 pom 文件中加上&lt;code&gt;feign-okhttp&lt;/code&gt;的依赖，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.github.openfeign&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;feign-okhttp&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;10.2.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.2 配置启用&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;feign:&lt;br/&gt;  okhttp:&lt;br/&gt;    enabled: &lt;span&gt;true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、如何修改日志级别&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发送和接收请求的时候，其内部将日志的打印输出定义成了四个等级，对应的详情如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;级别&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;NONE&lt;/td&gt;&lt;td&gt;不做任何记录&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BASIC&lt;/td&gt;&lt;td&gt;仅记录请求方法和 URL 以及响应状态代码和执行时间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;HEADERS&lt;/td&gt;&lt;td&gt;记录基本信息以及请求和响应标头&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FULL&lt;/td&gt;&lt;td&gt;记录请求和响应的标题，正文和元数据&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 通过配置文件修改日志级别&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意需要指定接口的全限定名&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;logging:&lt;br/&gt;  level:&lt;br/&gt;    com.zto.titans.test.feign.service.TestService : DEBUG&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 通过配置类修改日志级别&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FooConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    Logger.&lt;span&gt;Level &lt;span&gt;feignLoggerLevel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Logger.Level.FULL;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个一看即懂，不再废话。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、如何实现数据压缩&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以分别对 HTTP 通信的&lt;code&gt;request&lt;/code&gt;和&lt;code&gt;response&lt;/code&gt;设置是否启用 GZIP 压缩，配置方法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;feign:&lt;br/&gt;    compression:&lt;br/&gt;        request:&lt;br/&gt;            enabled: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;            mime-types: text/xml,application/xml,application/json &lt;span&gt;# 配置压缩支持的MIME TYPE&lt;/span&gt;&lt;br/&gt;            min-request-size: 2048  &lt;span&gt;# 配置压缩数据大小的下限&lt;/span&gt;&lt;br/&gt;        response:&lt;br/&gt;            enabled: &lt;span&gt;true&lt;/span&gt; &lt;span&gt;# 配置响应GZIP压缩&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、FeignClient 的配置以及配置的优先级机制&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有 2 种途径设置 FeignClient 的配置，通过自定义配置类来设置配置和在配置文件中设置，其中配置文件方式有点特殊，它里边可以指定全局配置对所有 FeignClient 有效，也可以为特定名称的 FeignClient 设置专属的配置。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 通过自定义配置类来定制配置&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;实现一个配置类&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class TestConfiguration {&lt;br/&gt;    @Bean&lt;br/&gt;    Logger.Level &lt;span&gt;&lt;span&gt;feignLoggerLevel&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Logger.Level.FULL;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将配置类 &lt;code&gt;TestConfiguration&lt;/code&gt; 指定给&lt;code&gt;configuration&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@FeignClient(&lt;br/&gt;        name = &lt;span&gt;&quot;test-service&quot;&lt;/span&gt;,&lt;br/&gt;        configuration = {FeignInterceptor2.class,TestConfiguration.class}&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 在配置文件中设置全局配置&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;feign.client.config.&lt;strong&gt;default&lt;/strong&gt;.xxx ，这个&lt;code&gt;default意为&lt;/code&gt;全局的配置属性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;feign:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;client:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;config:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;default:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;connectTimeout:&lt;/span&gt; &lt;span&gt;5000&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;readTimeout:&lt;/span&gt; &lt;span&gt;5000&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;loggerLevel:&lt;/span&gt; &lt;span&gt;basic&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 在配置文件中设置专属配置&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;feign.client.config.&lt;strong&gt;feignName&lt;/strong&gt;.xxx , 给名字为&lt;strong&gt;feignName&lt;/strong&gt;的&lt;code&gt;FeignClient&lt;/code&gt;指定专属的配置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;feign:&lt;br/&gt;  client:&lt;br/&gt;    config:&lt;br/&gt;      feignName:&lt;br/&gt;        connectTimeout: 5000&lt;br/&gt;        readTimeout: 5000&lt;br/&gt;        loggerLevel: full&lt;br/&gt;        errorDecoder: com.example.SimpleErrorDecoder&lt;br/&gt;        retryer: com.example.SimpleRetryer&lt;br/&gt;        requestInterceptors:&lt;br/&gt;          - com.example.FooRequestInterceptor&lt;br/&gt;          - com.example.BarRequestInterceptor&lt;br/&gt;        decode404: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;        encoder: com.example.SimpleEncoder&lt;br/&gt;        decoder: com.example.SimpleDecoder&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.4 理解配置的优先级与拦截器的追加原则&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从&lt;code&gt;org.springframework.cloud.openfeign.FeignClientFactoryBean#configureFeign&lt;/code&gt;中可以确认以上 3 种配置的优先级：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;configureUsingConfiguration(context, builder); // 1&lt;br/&gt;configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()),builder); //2&lt;br/&gt;configureUsingProperties(properties.getConfig().get(this.contextId),builder);//3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第 1 类为通过自定义配置类来指定配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第 2 类为在配置文件中的&lt;code&gt;feign.client.config.default.xxx&lt;/code&gt;设置全局配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第 3 类为在配置文件中的&lt;code&gt;feign.client.config.feignName.xxx&lt;/code&gt;设置专属配置&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.4.1 优先级的效果&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;配置文件里的专属配置&lt;/strong&gt; -覆盖-&amp;gt; &lt;strong&gt;配置文件里的全局配置&lt;/strong&gt; -覆盖-&amp;gt; &lt;strong&gt;配置类的配置&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.4.2 追加的原则&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;RequestInterceptor&lt;/code&gt; 是拦截器，可以在发送前做一些处理，比如统一添加&lt;code&gt;header&lt;/code&gt;信息。每一类中的&lt;code&gt;requestInterceptors&lt;/code&gt;可以存储多个拦截器，拦截器并非覆盖的效果，而是链式追加的效果；从执行顺序来看优先级是：1 &amp;gt; 2 &amp;gt; 3，即先执行 &lt;strong&gt;配置类中指定的拦截器&lt;/strong&gt;，然后是 &lt;strong&gt;配置文件中指定的全局拦截器&lt;/strong&gt;，最后是&lt;strong&gt;配置文件中指定的专属拦截器&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需特别注意：&lt;code&gt;RequestInterceptor&lt;/code&gt; 的实现类（例如 RI-A，RI-B）上如果添加了&lt;code&gt;@Component&lt;/code&gt;注解，就都会被扫描识别到，并被追加到第一类的&lt;code&gt;requestInterceptors&lt;/code&gt;列表中；倘若不小心 RI-A 还在第 2 类中又被指定了，则还会将拦截器 RI-A 追加在第二类的&lt;code&gt;requestInterceptors&lt;/code&gt;列表中，结果是会 RI-A 总计会执行 2 次；若也在第三类中指定 RI-A，则 RI-A 也在其列表中追加，结果是 RI-A 总计会执行 3 次。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.4.3 拦截器的效果验证&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以一个实例来验证说明效果&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;class FeignInterceptor implements RequestInterceptor {&lt;br/&gt;    @Override&lt;br/&gt;    public void apply(RequestTemplate requestTemplate) {&lt;br/&gt;        requestTemplate.header(&lt;span&gt;&quot;user&quot;&lt;/span&gt;, &lt;span&gt;&quot;myuser1&quot;&lt;/span&gt;);&lt;br/&gt;        requestTemplate.header(&lt;span&gt;&quot;password&quot;&lt;/span&gt;, &lt;span&gt;&quot;mypassword&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;class FeignInterceptor1 implements RequestInterceptor {&lt;br/&gt;    @Override&lt;br/&gt;    public void apply(RequestTemplate requestTemplate) {&lt;br/&gt;        requestTemplate.header(&lt;span&gt;&quot;user1&quot;&lt;/span&gt;, &lt;span&gt;&quot;myuser1&quot;&lt;/span&gt;);&lt;br/&gt;        requestTemplate.header(&lt;span&gt;&quot;password1&quot;&lt;/span&gt;, &lt;span&gt;&quot;mypassword1&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;class FeignInterceptor2 implements RequestInterceptor {&lt;br/&gt;    @Override&lt;br/&gt;    public void apply(RequestTemplate requestTemplate) {&lt;br/&gt;        requestTemplate.header(&lt;span&gt;&quot;user2&quot;&lt;/span&gt;, &lt;span&gt;&quot;myuser2&quot;&lt;/span&gt;);&lt;br/&gt;        requestTemplate.header(&lt;span&gt;&quot;password2&quot;&lt;/span&gt;, &lt;span&gt;&quot;mypassword2&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@FeignClient(&lt;br/&gt;        name = &lt;span&gt;&quot;test-service&quot;&lt;/span&gt;,&lt;br/&gt;        url = &lt;span&gt;&quot;http://localhost:8080/feign/server/&quot;&lt;/span&gt;,&lt;br/&gt;        configuration = {FeignInterceptor.class,TestConfiguration.class},&lt;br/&gt;        fallback = TestService.DefaultFallback.class&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;default&lt;/code&gt; 指定了一个，&lt;code&gt;test-service&lt;/code&gt;里指定一个&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;feign:&lt;br/&gt;  httpclient:&lt;br/&gt;    enabled: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  okhttp:&lt;br/&gt;    enabled: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  client:&lt;br/&gt;    config:&lt;br/&gt;      default:&lt;br/&gt;        connectTimeout: 5000&lt;br/&gt;        readTimeout: 5000&lt;br/&gt;        &lt;span&gt;#loggerLevel: none&lt;/span&gt;&lt;br/&gt;        requestInterceptors:&lt;br/&gt;          - com.zto.titans.test.feign.service.FeignInterceptor1&lt;br/&gt;      &lt;span&gt;test&lt;/span&gt;-service:&lt;br/&gt;        &lt;span&gt;#loggerLevel: basic&lt;/span&gt;&lt;br/&gt;        requestInterceptors:&lt;br/&gt;          - com.zto.titans.test.feign.service.FeignInterceptor2&lt;br/&gt;logging:&lt;br/&gt;  level:&lt;br/&gt;    com.zto.titans.test.feign.service.TestService : DEBUG&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据追加逻辑，最终执行的顺序是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;FeignInterceptor&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FeignInterceptor1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FeignInterceptor2&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇主要介绍 SpringBoot 中要玩转 Feign 需要掌握的如添加 pom 依赖、客户端注解启用、切换底层 HttpClient、配置数据压缩、调整日志级别、定制配置、配置的优先级机制、增加拦截器以及拦截器的追加机制等知识，以实例 + 效果的方式帮读者去高效全面检并深入的理解它们。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5ad9c16291f95f00dcb58fd8a5770337</guid>
<title>运维累了：该故障自愈出场了</title>
<link>https://toutiao.io/k/kcex2fq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;markdown编辑器&quot; data-website=&quot;https://markdown.com.cn/editor&quot;&gt;&lt;h1 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;背景&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;最近晚上23:00甚至是凌晨总收到告警通知：磁盘可用量低于20%，这个时候不得不爬起来处理告警。当然这里要提醒大家：对于小问题，运维也绝不要抱着侥幸的心理，因为只有痛过才知道。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;磁盘类告警只是我们诸多告警中的冰山一角，虽然我们有值班人员甚至是运维团队支撑，但是也不能因为这种小问题就分散注意力，这时我们就需要考虑如何通过自动化实现。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;针对这种情况，我们通常会想到以下几点：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在告警机器上设置定时任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;编写脚本压缩日志或清理磁盘空间；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;这种方案虽然可行，但是试想下：如果我们管理的是上千台机器且目录结构混乱，那么我们面临的将是上千个脚本及定时任务，这个工作量是非常大的。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;运维累都是有原因的，此时就可以轮到&lt;code&gt;故障自愈&lt;/code&gt;出场了。&lt;/p&gt;&lt;h1 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;故障自愈&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.51484375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2LInUvibx8lFyys2keX9q0uO7Qsu6jj8yZRmiaxUIQyG4Yk50oaLysQvLSXqhIibZ4EoRVNQGu4fticqyjmDHr1y8w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;如图所示，对于生产故障，运维标准的处理流程是收到告警、登录跳板机、故障处理、故障恢复，整个过程都是通过人工手动处理。而故障自愈则是接受监控平台的告警定位，匹配预设的故障处理流程，进而通过自动化手段实现故障的自动恢复。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;在认识故障自愈后，我们需要考虑的就是如何让运维管理的生产环境更广泛的接入故障自愈，而不是只针对单一的机器或某一类故障。因此在正式接入故障自愈前，我们还有很多的工作要做。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0307692307692307&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2LInUvibx8lFyys2keX9q0uO7Qsu6jj8yOQAcNwNby5MSH4kmebG4YRU3Leic9pnfqia7FX2RbhF0WTZskFhsxXHA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;1.前提&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;为满足故障自愈通过自动化手段处理故障，我们必须提前制定一系列的流程规范：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;目录管理规范&lt;/section&gt;&lt;section&gt;标准的目录结构，接入故障自愈后可以用一套自动化脚本管理所有文件资源；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用标准规范&lt;/section&gt;&lt;section&gt;标准应用规范，接入故障自愈后可以用一套自动化脚本管理所有应用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;监控告警规范&lt;/section&gt;&lt;section&gt;标准的监控告警规范，通过告警通知，无论是运维团队或自愈平台，都能通过告警通知更快速的定位问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标准的故障处理流程&lt;/section&gt;&lt;section&gt;标准的故障处理流程，不仅可以帮助我们更快速的解决问题，而且可以帮助我们建立起运维团队的知识库；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;这些流程规范不仅是故障自愈，也是我们日常运维工作过程中需要持续关注的，这也意味着这些基础性的工作是多么的重要。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span data-remoteid=&quot;c1657981276357&quot; data-cacheurl=&quot;https://imgkr.cn-bj.ufileos.com/15fdfb3c-b350-4da9-928e-5f8c506ec325.png&quot;/&gt;&lt;span&gt;2.监控平台&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;监控平台作为整个故障自愈的源头，必须满足快速准确定位故障的要求，因此就需要在多个维度提供可靠的监控。&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;硬件监控维度&lt;/section&gt;&lt;section&gt;此类监控故障自愈一般无法接入，仅作为辅助手段帮我们及时发现问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基础监控维度&lt;/section&gt;&lt;section&gt;基础监控主要是对CPU、内存、磁盘等资源使用情况进行监控，接入故障自愈后可发送占用资源的top10进程及自定义的磁盘清理策略；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用监控维度&lt;/section&gt;&lt;section&gt;应用监控主要是对应用状态进行监控，如健康检查、端口、其他自定义告警，接入故障自愈后可对应用进行重启；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;中间件维度&lt;/section&gt;&lt;section&gt;中间件维度主要是对集群的健康状态进行监控，如eureka instance、rabbitmq集群各节点服务、redis集群各节点服务等，接入故障自愈后可对各节点的服务进行处理；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;当然根据监控平台的维度和粒度，我们可以将更多的故障场景接入故障自愈，这个随着我们运维经验的增多会不断丰富。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span data-remoteid=&quot;c1657981276358&quot; data-cacheurl=&quot;https://imgkr.cn-bj.ufileos.com/15fdfb3c-b350-4da9-928e-5f8c506ec325.png&quot;/&gt;&lt;span&gt;3.故障自愈平台&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span data-remoteid=&quot;c1657981276359&quot; data-cacheurl=&quot;https://imgkr.cn-bj.ufileos.com/cdf294d0-6361-4af9-85e2-0913f0eb609b.png&quot;/&gt;（1）多告警源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;故障自愈的源头是监控平台，因此我们希望故障自愈平台不能是只针对某一特定的监控平台，因此它一定是多源的，这也符合当今监控工具的发展趋势。新的业务、系统和场景会催生新的监控需求，企业未来监控一定是多种监控产品并存，构建功能可持续成长的监控平台才能适应满足运维监控需求。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;当今主流的监控工具如下：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Zabbix&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Nagios&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Open Falcon&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Prometheus&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;当然除了满足与监控工具对接，还要兼具REST API等方式接入。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span data-remoteid=&quot;c1657981276360&quot; data-cacheurl=&quot;https://imgkr.cn-bj.ufileos.com/cdf294d0-6361-4af9-85e2-0913f0eb609b.png&quot;/&gt;（2）统一数据源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;试想一个场景，通过监控平台发送的告警通知，我们可以快速定位到业务、应用、IP，那么故障自愈平台如何接入这些资源呢？因此我们就需要一个统一的数据源，为监控平台、故障自愈平台等上层应用提供可靠的权威数据源，此时&lt;code&gt;CMDB&lt;/code&gt;就可以担任如此重要的角色。&lt;/p&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;在 ITIL 体系里，CMDB 是构建其它流程的基石，为应用提供了各种运维场景的配置数据服务。它是企业 IT 管理体系的核心，通过提供配置管理服务，以数据和模型相结合映射应用间的关系，保证数据的准确和一致性；并以整合的思路推进，最终面向应用消费，发挥配置服务的价值。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;CMDB的建设是一个非常痛苦的过程，虽然我们是站在巨人的肩膀上直接使用其能力进行纳管资源，但其实也是走了很多弯路的：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;运维团队内部的认可&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按部门、角色对基础设施的职责划分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMDB的管理规范&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMDB如何按组织架构对环境、部门、业务、应用等情况划分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何更合适的纳管物理机、虚拟机、网络设备、数据库、中间件等资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMDB如何为架构提供数据支撑&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;以上这些问题也只是在使用推广阶段我们所遇到的，因此在很多情况下CMDB都从&lt;code&gt;万众期待&lt;/code&gt;走向了&lt;code&gt;置之不理&lt;/code&gt;，但“拨开云雾见天日，守得云开见月明”，随着我们不遗余力的尝试与调整，CMDB 最终还是抗下了所有，发挥了它真正的价值。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span data-remoteid=&quot;c1657981276361&quot; data-cacheurl=&quot;https://imgkr.cn-bj.ufileos.com/cdf294d0-6361-4af9-85e2-0913f0eb609b.png&quot;/&gt;（3）故障处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;有了统一的数据源，剩下的操作就是如何进行故障处理了，此时就需求故障自愈平台能够远程执行脚本。在日常运维工作中，我们一般通过以下几种方式：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Ansible、SaltStack等自动化运维工具&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;中控机通过ssh远程执行命令&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;以上是我们通常使用的手段，但是还有更高级或更优雅的方式供我们参考：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;集成CMDB的统一作业平台&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Jenkins流水线参数化构建&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;当然了，“不管黑猫白猫，能捉老鼠的就是好猫”，只要是适合当下运维能力的任何方式都可以。不要一味的追求高大上，给我们带来其他额外的工作负担。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span data-remoteid=&quot;c1657981276362&quot; data-cacheurl=&quot;https://imgkr.cn-bj.ufileos.com/cdf294d0-6361-4af9-85e2-0913f0eb609b.png&quot;/&gt;（4）结果通知&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;无论最终的故障处理是否成功，我们都需要知道结果来决定是否要人工干预，因此我们希望处理结果能够对接多种渠道通知，如：&lt;/p&gt;&lt;h1 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38235294117647056&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2LInUvibx8lFyys2keX9q0uO7Qsu6jj8yPUQgW7TT11u2ttjkDFqznzO6uwA51Hz13j1xeCvWgwCMvda2teDJFg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;从上图我们可以看到，故障自愈虽然可以帮助我们解决很多问题，但其也只是问题处理过程中的一个环节，例如&lt;code&gt;例行维护&lt;/code&gt;期间我们需要做到不触发故障自愈，否则还可能引起一些不必要的问题。因此，故障自愈还需和其他组件做好密切的对接，这就通过运维管理人员进行调度了。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;最后需要明确的是，故障自愈只是运维过程中的一种手段而已，如何将其更广泛的应用还需运维本身去脚踏实地的去实践摸索。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;strong&gt;是的，“罗马不是一天建成的”，当你看到此文时我已经经历了整个运维体系从无到有的建设过程，这些都是宝贵的财富，遂以文章将经历过的点滴记录下来。如果你感兴趣，可从以下链接中找到不同阶段的痕迹。&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;57&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;58&quot; data-fileid=&quot;100020427&quot; data-ratio=&quot;0.09907407407407408&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6v7SZOYzqNdvNNiakGiaRUk8QINC7kBDrRHu7zicKhlaia6TqRlTGkABnq2oPL506oAdQoFibPmWv8BatffhUMbc8Ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>