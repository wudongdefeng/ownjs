<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9128b8646bcc1b462a1234ce45bd6af8</guid>
<title>Flink 创始人团队二次收购案！阿里恐成冤大头！</title>
<link>https://toutiao.io/k/rfc7ab5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4138486312399356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Buj6EMgMp7TPlPYZJbZHe6C9uvmko9ACWm7I77SzXpcjibkzvIC0icC4Kchjuiad1ibgq5IDw5rM27LWzzvcWP8EgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1242&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大数据开源商业化领域近日有一个爆炸性新闻，“Confluent 收购 Immerok”，字越少事越大，先给大家简单科普一下 Confluent 和 Immerok 这两家公司，Confluent 是掌控 Apache Kafka 社区的&lt;span&gt;大数据&lt;span&gt;开源&lt;/span&gt;&lt;/span&gt;商业化公司，Immerok 是 Apache Flink 创始人团队二次创业创办的公司。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说这件事之前又不得不提一下那家由 Apache Flink 创始人第一次创业创办的公司 Ververica，没错，正是前几年阿里巴巴花了 &lt;span&gt;9000 万&lt;/span&gt;&lt;span&gt;欧元&lt;/span&gt;收购的那家德国公司，但是被阿里收购后，Flink 创始人团队成员于22年初都陆续离职了。&lt;/span&gt;&lt;span&gt;更魔幻的是这帮人离职后竟然直接创办了 Immerok 这家公司，而 Immerok 主要做的事情和 Ververica 无比相似，相当于 Flink 创始人团队另起炉灶和阿里对着干，这件事背后的隐情谁也不知道，但是吃瓜群众都有一个大大的问号 “没有竞业协议吗？&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;span&gt;”。&lt;/span&gt;&lt;span&gt;阿里这一次无疑是哑巴吃黄莲有苦说不出，9000 万欧元最终买到的可能只有 Flink 社区的主导权。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面说的这些事情是发生在22年初， Immerok 这家公司也是在那个时候成立的，然而仅仅不到一年的时间，这家初创公司就被 Confluent 收购了，这一操作让吃瓜群众再一次傻眼，不得不佩服 Apache Flink 创始人团队整活和整钱的能力，也不得不佩服阿里把一把好牌打得稀烂的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;话说回阿里收购 &lt;/span&gt;&lt;span&gt;Verve&lt;/span&gt;&lt;span&gt;rica 之后， Flink 表面上好像发展得还不错，阿里自研的 Alink 合并到了主分支，国内越来越多公司用上了 Flink，阿里云的 Flink 生意看似也做的风声水起。&lt;/span&gt;&lt;span&gt;但是这只是在国内小打小闹，Ververica 应该有更大的目标才对，他对标的应该是国外有大数据第一股之称的 Databricks（Apache Spark 背后的大数据商业公司，百亿美元市值），从近几年在国际上不温不火的表现来看，阿里这些年做的无疑是失败的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外说到 kafka 大家也很容易想到另外一家做流计算的公司 StreamNative（Apache Plusar 背后的商业公司），这起收购案也会给 &lt;span&gt;StreamNative &lt;/span&gt;带来一些压力，可能会加快流计算领域的布局，但是这并不算是致命的威胁，因为毕竟做 Flink 商业化且做的不错的公司可不止创始人团队那一家。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再说回 Confluent 收购 Immerok 的事情，猜测一下，大概率是做 Kafka和Flink的深度集成，两把流数据处理领域的利刃结合，不知道会擦出什么样的火花，可以预知的是动作肯定不会小，毕竟收编的可不是普通的 Flink PMC。&lt;/span&gt;&lt;span&gt;如果有大动作的话，那&lt;/span&gt;&lt;span&gt;和阿里的 Flink 团队对社区的发展方向势必会出现分歧，社区走向就会变得扑朔迷离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然一般来说创始人团队对开源社区的话语权是最大的，但是对于 Flink 来说，毕竟之前和阿里做了一笔交易，名义上已经是把主导权卖给了阿里巴巴，创始人们个个也都赚得盆满钵满，现在再转过头来阿里对着干，在道德上和舆论上其实都很难占到上风。&lt;/span&gt;&lt;span&gt;而且争夺 Apache Flink 社区掌控权这件事，无论成功与否都会对 Flink 社区造成了很大的内耗和伤害。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实这种事件在开源领域并不少见，就比如大家熟悉的 facebook 主导开的源项目 Presto，是三位创始人（史称 presto 三巨头）在 facebook 工作时开源的，但是他们对 Presto 的发展方向并不满意，因为方向实际上是被 facebook 的需求所掌控的，所以最终他们三离职后创办了 Starburst 这家公司，关键是这家公司并不是做 &lt;span&gt;P&lt;/span&gt;&lt;span&gt;resto &lt;/span&gt;的商业化，而是另起炉灶，从 &lt;span&gt;P&lt;/span&gt;&lt;span&gt;resto&lt;/span&gt; fork 出来一个分支，创建了 &lt;span&gt;Trino&lt;/span&gt; 项目，以这种方式让 &lt;span&gt;P&lt;/span&gt;&lt;span&gt;resto&lt;/span&gt; 朝自己想要的方向发展。&lt;/span&gt;&lt;span&gt;目前来看，虽然 star、fork 这些数量比不上 &lt;span&gt;P&lt;/span&gt;&lt;span&gt;resto&lt;/span&gt;，但是 &lt;span&gt;Trino&lt;/span&gt; 的社区活跃度已经超过了 presto。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Trino 这个剧本，会不会被 Flink 创始人团队拿到，也许现在最担心这件事发生的就是阿里了，作为吃瓜群众也无法得知 Flink 创始人团队离职的原因是不是对目前阿里主导的社区发展方向感到失望，如果是的话，走上和trino类似的道路也不是不可能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说实话社区的分裂对用户来说并不是一件好事，多了选择和学习的成本。&lt;/span&gt;&lt;span&gt;对开源社区来说也不是一件好事，无法集中火力干好一件事。&lt;/span&gt;&lt;span&gt;但是为了利益，这样的案例总是层出不穷，只希望能给后面的开源商业化公司提个醒，不要走上类似阿里这样的冤种大道。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzU0Njg1MjUzMg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Buj6EMgMp7Q9lib8r8ib6YDoHjo1MclTpEZwj5icC5keLDCmrxCx4xpXbkpds9GWZknicdrIKH9FTRO3ojQ6DU34ng/0?wx_fmt=png&quot; data-nickname=&quot;Apache Bigdata Projects&quot; data-alias=&quot;simon_bigdata&quot; data-signature=&quot;本账号由多位 Apache 项目的 Committer 和 PMC Member 共同维护&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;更多精彩原创干货 欢迎持续关注&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3384d7817aca40c1d5b39326f6e74241</guid>
<title>如何实现一个完美的深拷贝库？</title>
<link>https://toutiao.io/k/ovs9s4b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;👆&lt;/span&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;span&gt;博文视点Broadview&lt;/span&gt;&lt;span&gt;”，获取更多书讯&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nr1VNxfeqxVOw2nPJHVH4xeZibzPY5F4ibOuOZLMsUMrzIibGB6KMw7EurSKv6DkrtLzuhYdBa30A9Q/640?wx_fmt=png&quot; data-ratio=&quot;0.05669291338582677&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;lodash里的cloneDeep函数可以用来解决深拷贝的场景，但你有没有思考过lodash里的cloneDeep函数是如何实现的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然我们可以直接使用lodash，但是学习深拷贝函数的实现原理仍然是非常有意义的，深拷贝也是一道非常经典的前端面试题，其可以考察面试者的很多方面，比如基本功、代码能力、逻辑能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深拷贝看似简单，但要想实现一个完美的深拷贝却并不容易，通过笔者的面试考察经验来看 ，只有 50%的人能够实现基础版本，能实现完美版本的竟然不到1%，这是因为深拷贝存在很多坑，比如：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;你知道使用JSON.stringify来实现深拷贝是有bug的吗？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;你会使用循环实现深拷贝吗？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;如果拷贝的对象存在循环引用该怎么破解？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果你回答不上来上面的问题，那么继续往下阅读吧，本文将破解深拷贝的谜题，由浅入深，环环相扣，总共涉及4种深拷贝方式，每种方式都有自己的特点和个性。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;深拷贝 VS 浅拷贝&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;开始之前先科普一下什么是深拷贝，和深拷贝有关系的另一&lt;span&gt;个&lt;/span&gt;术语——浅拷贝又是什么意思呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实深拷贝和浅拷贝都是针对引用类型来说的，JS中的变量类型分为值类型（基本类型）和引用类型；对值类型进行复制操作会对值进行一份拷贝，而对引用类型赋值，则会进行地址的拷贝，最终两个变量指向同一份数据。示例代码如下。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;// 引用类型指向同一份数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a = {&lt;span&gt;c&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; b = a;&lt;br/&gt;a.c = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a.c, b.c); &lt;span&gt;// 2, 2 全是2，a b指向同一份数据&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;引用类型会导致a和b指向同一份数据，此时如果对其中一个进行修改，就会影响到另外一个，有时这可能不是我们想要的结果，如果对这种现象不清楚的话，还可能造成不必要的bug。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;最简单的深拷贝&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;深拷贝的问题其实可以分解成两个问题：浅拷贝+递归。什么意思呢？假设我们有如下数据：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; a1 = {&lt;span&gt;b&lt;/span&gt;: {&lt;span&gt;c&lt;/span&gt;: {&lt;span&gt;d&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;}};&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;使用递归实现深拷贝的示例代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;clone&lt;/span&gt;(&lt;span&gt;source&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; target = {};&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; source) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (source.hasOwnProperty(i)) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; source[i] === &lt;span&gt;&#x27;object&#x27;&lt;/span&gt;) {&lt;br/&gt;                target[i] = clone(source[i]); &lt;span&gt;// 注意这里&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                target[i] = source[i];&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; target;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;大部分人都能写出上面的代码，但如果问上面的代码有什么问题的话，就很少有人答得上来了。聪明的你能找到问题吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实上面的代码问题太多了，比如：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;没有对参数做检验&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;判断是否对象的逻辑不够严谨&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;没有考虑数组的兼容&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其实这三个都是小问题，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;递归方法最大的问题在于爆栈，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;当数据的层次很深时就会栈溢出。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面的代码可以生成指定深度和每层广度的代码，这段代码我们后面还会再次用到。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createData&lt;/span&gt;(&lt;span&gt;deep, breadth&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; data = {};&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; temp = data;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; deep; i++) {&lt;br/&gt;        temp = temp[&lt;span&gt;&#x27;data&#x27;&lt;/span&gt;] = {};&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; breadth; j++) {&lt;br/&gt;            temp[j] = j;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; data;&lt;br/&gt;}&lt;br/&gt;createData(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;); &lt;span&gt;// 1层深度，每层有3个数据 {data: {0: 0, 1: 1, 2: 2}}&lt;/span&gt;&lt;br/&gt;createData(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;); &lt;span&gt;// 3层深度，每层有0个数据 {data: {data: {data: {}}}}&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;当clone层级很深的时候就会出现栈溢出，但数据的广度不会造成溢出。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;clone(createData(&lt;span&gt;1000&lt;/span&gt;)); &lt;span&gt;// ok&lt;/span&gt;&lt;br/&gt;clone(createData(&lt;span&gt;10000&lt;/span&gt;)); &lt;span&gt;// Maximum call stack size exceeded&lt;/span&gt;&lt;br/&gt;clone(createData(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;100000&lt;/span&gt;)); &lt;span&gt;// ok 广度不会溢出&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;其实大部分情况下不会出现这么深层级的数据，&lt;strong&gt;&lt;span&gt;但这种方式还有一个致命的问题，就是循环引用。&lt;/span&gt;&lt;/strong&gt;比如：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; a = {};&lt;br/&gt;a.a = a;&lt;br/&gt;clone(a) &lt;span&gt;// Maximum call stack size exceeded 直接死循环了有没有，/(ㄒoㄒ)/~~&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;关于循环引用的问题，&lt;span&gt;有两种&lt;/span&gt;解决思路：&lt;span&gt;一种是循环检测，一种是暴力破解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于循环检测大家可以自己思考下；关于暴力破解，我们会在下面的内容中进行详细讲解。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;一行代码的深拷贝&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;有些同学可能见过用系统自带的JSON来做深拷贝的例子，下面来看一下代码实现：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;cloneJSON&lt;/span&gt;(&lt;span&gt;source&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;JSON&lt;/span&gt;.parse(&lt;span&gt;JSON&lt;/span&gt;.stringify(source));&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;其实我第一次见到这个方法的时候由衷表示佩服，利用工具达到目的是非常聪明的做法！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面来测试一下cloneJSON有没有溢出的问题，看起来cloneJSON内部也是使用递归的方式：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;cloneJSON(createData(&lt;span&gt;10000&lt;/span&gt;)); &lt;span&gt;// Maximum call stack size exceeded&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;既然使用了递归，那么为什么存在循环引用时，并没有因为死循环而导致栈溢出呢？原来是JSON.stringify内部做了循环引用的检测，正是我们上面提到破解循环引用的第一种方法：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;循环检测&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; a = {};&lt;br/&gt;a.a = a;&lt;br/&gt;cloneJSON(a) &lt;span&gt;// Uncaught TypeError: Converting circular structure to JSON&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;破解递归爆栈&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;其实破解递归爆栈的方法有两条路：第一种方法是消除尾递归，但在这个例子中行不通；第二种方法就是干脆不用递归，改用循环。当我提出用循环来实现时，基本上90%的前端都是写不出来代码的，下面来介绍一下实现思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举个例子，假设有如下的数据结构：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; a = {&lt;br/&gt;    &lt;span&gt;a1&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;a2&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;b1&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;b2&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;c1&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;其实只要把数据横过来看，就非常明显地发现&lt;span&gt;这就是树！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;    a&lt;br/&gt;  /   \&lt;br/&gt; a1   a2        &lt;br/&gt; |    / \         &lt;br/&gt; 1   b1 b2     &lt;br/&gt;     |   |        &lt;br/&gt;     1  c1&lt;br/&gt;         |&lt;br/&gt;         1&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;用循环遍历一棵树需要借助一个栈，当栈为空时就遍历完了，栈里面会存储下一个需要拷贝的节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先我们往栈里放入种子数据，&lt;/span&gt;&lt;code&gt;&lt;span&gt;key&lt;/span&gt;&lt;/code&gt;&lt;span&gt;用来存储一个父元素的子元素拷贝对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后遍历当前节点下的子元素，如果是对象，就放到栈里，否则直接拷贝。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;cloneLoop&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; root = {};&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; loopList = [{ &lt;span&gt;parent&lt;/span&gt;: root, &lt;span&gt;key&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt;, &lt;span&gt;data&lt;/span&gt;: x }];&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(loopList.length) {&lt;br/&gt;        &lt;span&gt;// 深度优先&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; node = loopList.pop();&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; parent = node.parent;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; key = node.key;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; data = node.data;&lt;br/&gt;        &lt;span&gt;// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; res = parent;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; key !== &lt;span&gt;&#x27;undefined&#x27;&lt;/span&gt;) {&lt;br/&gt;            res = parent[key] = {};&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt; data) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (data.hasOwnProperty(k)) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; data[k] === &lt;span&gt;&#x27;object&#x27;&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;// 下一次循环&lt;/span&gt;&lt;br/&gt;                    loopList.push({ &lt;span&gt;parent&lt;/span&gt;: res, &lt;span&gt;key&lt;/span&gt;: k, &lt;span&gt;data&lt;/span&gt;: data[k] });&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    res[k] = data[k];&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;改用循环后，再也不会出现爆栈的问题了，但是对于循环引用依然无力应对！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;破解循环引用&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;有没有一种办法可以破解循环引用呢？别着急，我们先来看另一个问题，上面的三种方法都存在的一个问题就是引用丢失，这在某些情况下也许是不能接受的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举个例子，假如一个对象a下面的两个键值都引用同一个对象b，经过深拷贝后，a的两个键值会丢失引用关系，从而变成两个不同的对象o(╯□╰)o：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; b = {};&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a = {&lt;span&gt;a1&lt;/span&gt;: b, &lt;span&gt;a2&lt;/span&gt;: b};&lt;br/&gt;a.a1 === a.a2 &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; c = clone(a);&lt;br/&gt;c.a1 === c.a2 &lt;span&gt;// false&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;如果我们发现一个新对象就把这个对象和它的拷贝存下来，每次拷贝对象前，都先看一下这个对象是不是已经拷贝过了，如果拷贝过了，就不需要拷贝了，直接用原来的，这样我们就能够保留引用关系了✧(≖ ◡ ≖✿)嘿嘿~~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是代码怎么写呢？o(╯□╰)o&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;别急，往下看！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实和循环的代码大体一样，不一样的地方我用&lt;/span&gt;&lt;code draggable=&quot;true&quot;&gt;&lt;span&gt;// ==========&lt;/span&gt;&lt;/code&gt;&lt;span&gt;标注出来了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引入一个数组&lt;/span&gt;&lt;code&gt;&lt;span&gt;uniqueList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;用来存储已经拷贝的数组，每次循环遍历时，先判断对象是否在&lt;/span&gt;&lt;code&gt;&lt;span&gt;uniqueList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中了，如果在的话就不执行拷贝逻辑了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;find&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是&lt;span&gt;一个&lt;/span&gt;抽象的函数，其实就是遍历&lt;/span&gt;&lt;code&gt;&lt;span&gt;uniqueList&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;// 保持引用关系&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;cloneForce&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(loopList.length) {&lt;br/&gt;        &lt;span&gt;// =============&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 数据已经存在&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; uniqueData = find(uniqueList, data);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (uniqueData) {&lt;br/&gt;            parent[key] = uniqueData.target;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;; &lt;span&gt;// 中断本次循环&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 数据不存在&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 保存源数据，在拷贝数据中对应的引用&lt;/span&gt;&lt;br/&gt;        uniqueList.push({ &lt;span&gt;source&lt;/span&gt;: data, &lt;span&gt;target&lt;/span&gt;: res });&lt;br/&gt;        &lt;span&gt;// =============&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt; data) {&lt;br/&gt;            // 省略代码&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;find&lt;/span&gt;(&lt;span&gt;arr, item&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; arr.length; i++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (arr[i].source === item) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; arr[i];&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;下面来验证一下效果：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; b = {};&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a = {&lt;span&gt;a1&lt;/span&gt;: b, &lt;span&gt;a2&lt;/span&gt;: b};&lt;br/&gt;a.a1 === a.a2 &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; c = cloneForce(a);&lt;br/&gt;c.a1 === c.a2 &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;接下来再说一下如何破解循环引用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;等一下，上面的代码好像可以破解循环引用，赶紧验证一下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; a = {};&lt;br/&gt;a.a = a;&lt;br/&gt;&lt;br/&gt;cloneForce(a)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;惊不惊喜，(*^__^*) 嘻嘻……&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看起来完美的&lt;/span&gt;&lt;code&gt;&lt;span&gt;cloneForce&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是不是就没有问题呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;cloneForce&lt;/span&gt;&lt;/code&gt;&lt;span&gt;有两个问题：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;性能对比&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;上面的内容还是有点难度的，下面我们来点更有难度的，对比一下不同方法的性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来做实验。通过数据可以看出影响性能的原因有两个：一个是深度，一个是每层的广度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们采用固定一个变量，只让一个变量变化的方式来测试性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;测试的方法是在指定的时间内计算深拷贝执行的次数，次数越多，证明性能越好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面的&lt;/span&gt;&lt;code&gt;&lt;span&gt;runTime&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是测试代码的核心片段。在下面的例子中，我们可以测试在2秒内运行&lt;/span&gt;&lt;code&gt;&lt;span&gt;clone(createData(500, 1)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的次数。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;runTime&lt;/span&gt;(&lt;span&gt;fn, time&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; stime = &lt;span&gt;Date&lt;/span&gt;.now();&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;Date&lt;/span&gt;.now() - stime &amp;lt; time) {&lt;br/&gt;        fn();&lt;br/&gt;        count++;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt;}&lt;br/&gt;runTime(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{ clone(createData(&lt;span&gt;500&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;)) }, &lt;span&gt;2000&lt;/span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;下面来做第一个测试，将广度固定在100，深度由小到大变化，记录1秒内执行的次数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;table data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;深度&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;clone&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;cloneJSON&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;cloneLoop&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;cloneForce&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;500&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;351&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;212&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;338&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;372&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;174&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;104&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;175&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;143&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1500&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;116&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;67&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;112&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;82&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;2000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;92&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;50&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;88&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;69&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;将上面的数据做成表格可以发现一些规律：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;随着深度变小，相互之间的差异在变小&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;clone和cloneLoop的差别并不大&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;cloneLoop &amp;gt; cloneForce &amp;gt; cloneJSON&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6175925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/otfIrRhFJ9pibquVUfUn2c9tHaH24QmQialwEialdBOH8AibU7rPY84znJtOriciaLzyyFdiaVmmkTufpibqCd67djGH3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来分析一下各个方法的时间复杂度问题，对于各个方法要做的相同的事情，这里就不计算了，比如循环判断是否为对象等。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;clone时间 = 创建递归函数 + 每个对象处理时间&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;cloneJSON时间 = 循环检测 + 每个对象处理时间 * 2 （递归转字符串 + 递归解析）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;cloneLoop时间 = 每个对象处理时间&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;cloneForce时间 = 判断对象是否在缓存中 + 每个对象处理时间&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;cloneJSON的速度只有clone的50%。这很容易理解，因为其会多进行一次递归时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;由于&lt;/span&gt;cloneForce要判断对象是否在缓存中，因此会导致速度变慢。我们来计算一下判断逻辑的时间复杂度，假设对象的个数是n，则其时间复杂度为O(n2)，对象的个数越多，cloneForce的速度会越慢。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;1 + 2 + 3 ... + n = n^2/2 - 1&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;关于clone和cloneLoop这里有一点问题，看起来实验结果和推理结果不一致，其中必有蹊跷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来做第二个测试，将深度固定在10000，广度固定为0，记录2秒内执行的次数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;table data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;宽度&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;clone&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;cloneJSON&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;cloneLoop&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;cloneForce&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;13400&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;3272&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;14292&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;989&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;排除宽度的干扰，来看看深度对各个方法的影响：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;随着对象的增多，cloneForce的性能低下凸显&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;cloneJSON的性能也大打折扣，这是因为循环检测占用了很多时间&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;cloneLoop的性能高于clone，可以看出递归新建函数的时间和循环对象比起来可以忽略不计&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面我们来测试一下cloneForce的性能极限，这次我们测试运行指定次数需要的时间：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; data1 = createData(&lt;span&gt;2000&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data2 = createData(&lt;span&gt;4000&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data3 = createData(&lt;span&gt;6000&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data4 = createData(&lt;span&gt;8000&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data5 = createData(&lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;cloneForce(data1)&lt;br/&gt;cloneForce(data2)&lt;br/&gt;cloneForce(data3)&lt;br/&gt;cloneForce(data4)&lt;br/&gt;cloneForce(data5)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;通过测试发现，其时间成指数级增长，当对象个数大于万级别，就会有300ms以上的延迟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5981481481481481&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/otfIrRhFJ9pibquVUfUn2c9tHaH24QmQiahxiazC43OG4FlkxoGCGTP15qbNzDFnD6ULWySNn4AakjfR9Ix4Ub2vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;尺有所短，寸有所长，无关乎好坏优劣，其实每种方法都有自己的优缺点和适用场景，人尽其才，物尽其用，方是真理！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面对各种方法进行对比，希望给大家提供一些帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;table data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;clone&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;cloneJSON&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;cloneLoop&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;cloneForce&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;难度&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;☆☆&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;☆&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;☆☆☆&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;☆☆☆☆&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;兼容性&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;ie6&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;ie8&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;ie6&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;ie6&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;循环引用&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;一层&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;不支持&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;一层&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;栈溢出&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;会&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;会&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;不会&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;不会&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;保持引用&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;适合场景&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;一般数据拷贝&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;一般数据拷贝&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;层级很多&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;保持引用关系&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;7&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;本文出自&lt;/span&gt;&lt;strong&gt;&lt;span&gt;《现代JavaScript库开发：原理、技术与实战》&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;一书！&lt;/span&gt;&lt;/p&gt;&lt;p data-autoskip=&quot;1&quot;&gt;&lt;span&gt;如今，本书已全面上线,如果你也想开发属于自己的JavaScript库，提升开发技能，精进自身开发技术，一定不可以错过本书哦~~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如今，本书已全面上线，如果你也想开发属于自己的JavaScript库，提升开发技能，精进自身开发技术，一定不可以错过本书哦~~&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-templateid=&quot;list&quot; data-traceid=&quot;2238cea2-d47c-4246-badc-13b8a8842a0d&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;101_13596805&quot; data-appuin=&quot;2395946309&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:106,&amp;quot;pid&amp;quot;:&amp;quot;101_13596805&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;2395946309&amp;quot;,&amp;quot;trace_id&amp;quot;:&amp;quot;2238cea2-d47c-4246-badc-13b8a8842a0d&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;101_13596805&amp;quot;,&amp;quot;source_id&amp;quot;:2,&amp;quot;source_name&amp;quot;:&amp;quot;京东&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://pcm-img.zhls.qq.com/productcenter-de367983--1018824-1304792925532496268/67511430429122022/2953f1ec9afa07dbbcc57e3c55f5b941.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;现代JavaScript库开发：原理、技术与实战&amp;quot;,&amp;quot;current_price&amp;quot;:10800,&amp;quot;first_category_id&amp;quot;:&amp;quot;106&amp;quot;,&amp;quot;product_label_name_list&amp;quot;:[&amp;quot;京东配送&amp;quot;],&amp;quot;select_tag_name_list&amp;quot;:[],&amp;quot;templateId&amp;quot;:&amp;quot;list&amp;quot;,&amp;quot;appuin&amp;quot;:&amp;quot;2395946309&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;3.5044359949302915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3mRiba3fGiaybyUnHlhpoaoCROQo3B1zGIpRlG4nG2Ia11ZyNg1G0j1blfulsyUWppqMyH30xYcOPgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.4302030456852792&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3mRiba3fGiaybyUnHlhpoaoCR0DGy2qlGSZfxcHKbTHpf9ypicDkCE0vlM9gqJJvLib7QUrCnqSibK8sJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;788&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;149&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;149&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kodicZy1F2uW4ic5JbbFGtA4ZcTlzlt5P8zD2H6r2kmW93IPy32frib5yukeKvehRLAj3scLWuuokog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot; data-width=&quot;149px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;粉丝专享五折优惠，快快扫码抢购吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;发布：刘恩惠&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;审核：陈歆懿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Puv74VHDtgNjyJbpQvt1gicgSpjrlpDy6BheYoAmtjiaF7cdIuPkuUlFkw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1920&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;29.8961937716263&quot; data-ratio=&quot;0.01574074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Pu8DQL5f0FQIuDZC87yrAuNLy4frEdlMeWkthrlzczb0RbMOBQCAwDrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;如果喜欢本文&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;欢迎&lt;/span&gt; &lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;留言&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享至朋友圈&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 三连&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;92644&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt; &lt;strong&gt;热文推荐 &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;574&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;244&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3m3jibtjia3lCrCvUY6N19QMZ3FjCcpuHouXkdLicQVUiaLicgR8cgSbk7RA8G427GKowhbEvVefuJp53g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▼点击阅读原文，了解本书详情~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3fe44bb5097b84afe4629174ea578339</guid>
<title>从  Linux零拷贝深入了解 Linux-I/O</title>
<link>https://toutiao.io/k/8zrjc3s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10084033613445378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe95czZhnamWia6rvd1aenicicPiasMmUOHHu1wyeNicNJsWGa4syzF2PoOAePZEYtZX8jicbEDRPW3KsUlOw/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; data-w=&quot;1071&quot;/&gt;&lt;/span&gt;&lt;span&gt;导言 | 本文邀请到腾讯CSIG后台开发工程师kevineluo从文件传输场景以及零拷贝技术深究Linux I/O的发展过程、优化手段以及实际应用。&lt;span&gt;I/O相关的各类优化已经深入到了日常开发者接触到的语言、中间件以及数据库的方方面面。通过了解和学习相关技术和思想，&lt;span&gt;开发者&lt;/span&gt;能对日后自己的程序设计以及性能优化上有所启发。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FiaZYIGick0nWJJXC1lSLI8zy2asbcicfNgvgJXexvB9rOnicPxbKFdEibPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;存储器是计算机的核心部件之一，在完全理想的状态下，存储器应该要同时具备以下三种特性：&lt;/span&gt;&lt;span&gt;第一，速度足够快&lt;/span&gt;&lt;span&gt;：存储器的&lt;/span&gt;&lt;span&gt;存取速度应当快于CPU执行一条指令，这样CPU的效&lt;/span&gt;&lt;span&gt;率才不会&lt;/span&gt;&lt;span&gt;受限于存储器；&lt;/span&gt;&lt;span&gt;第二，容量足够大：容量能够存储计算机所需的&lt;/span&gt;&lt;span&gt;全部数据；&lt;/span&gt;&lt;span&gt;第三，价格&lt;/span&gt;&lt;span&gt;足&lt;/span&gt;&lt;span&gt;够便宜：价格低廉，所有类型的计算机都能配备。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是现实往往是残酷的，我们目前的计算机技术无法同时满足上述的三个条件，于是现代计算机的存储器设计采用了一种分层次的结构：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.255&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wVJq9Txsf1ffOhQEEGlUJo6FrmdNqxRx3dcbIJkhRwG4FFErX358Oxog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从顶至底，现代计算机里的存储器类型分别有：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;寄存器、高速缓存、主存和磁盘&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，这些存储器的速度逐级递减而容量逐级递增。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;存取速度最快的是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;寄存器&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，因为寄存器的制作材料和CPU是相同的，所以速度和CPU一样快，CPU访问寄存器是没有时延的，然而因为价格昂贵，因此容量也极小，一般32位的CPU配备的寄存器容量是32✖️32Bit，64位的 CPU则是64✖️64Bit，不管是32位还是64位，寄存器容量都小于1KB，且寄存器也必须通过软件自行管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二层是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;高速缓存&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，也即我们平时了解的CPU高速缓存L1、L2、L3，一般 L1是每个CPU独享，L3是全部CPU共享，而L2则根据不同的架构设计会被设计成独享或者共享两种模式之一，比如Intel的多核芯片采用的是共享L2模式而AMD的多核芯片则采用的是独享L2模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三层则是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;主存&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，也即主内存，通常称作随机访问存储器（Random Access Memory,RAM）。是与CPU直接交换数据的内部存储器。它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时资料存储介质。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至于&lt;/span&gt;&lt;strong&gt;&lt;span&gt;磁盘&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;则是图中离用户最远的一层了，读写速度相差内存上百倍；另一方面自然针对磁盘操作的优化也非常多，如零拷贝、direct I/O、异步I/O等等，这些优化的目的都是为了提高系统的吞吐量；另外操作系统内核中也有磁盘高速缓存区、PageCache、TLB等，可以有效的减少磁盘的访问次数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现实情况中，大部分系统在由小变大的过程中，最先出现瓶颈的就是I/O，尤其是在现代网络应用从CPU密集型转向了I/O密集型的大背景下，I/O越发成为大多数应用的性能瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统的Linux操作系统的标准I/O接口是基于数据拷贝操作的，即I/O操作会导致数据在操作系统内核地址空间的缓冲区和用户进程地址空间定义的缓冲区之间进行传输。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;设置缓冲区最大的好处是可以减少磁盘I/O的操作&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，如果所请求的数据已经存放在操作系统的高速缓冲存储器中，那么就不需要再进行实际的物理磁盘I/O操作；然而传统的Linux I/O在数据传输过程中的数据拷贝操作深度依赖CPU，也就是说I/O过程需要CPU去执行数据拷贝的操作，因此导致了极大的系统开销，限制了操作系统有效进行数据传输操作的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这篇文章就从文件传输场景，以及&lt;/span&gt;&lt;strong&gt;&lt;span&gt;零拷贝&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;技术深究Linux I/O的发展过程、优化手段以及实际应用。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9F812pnpTVKsrLmlcKHlIuuBvuwqeIqmOLOsD9nTpkow7FlAh45LKRLA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;需要了解的词&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DMA：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;DMA，全称Direct Memory Access，即直接存储器访问，是为了避免CPU在磁盘操作时承担过多的中断负载而设计的；在磁盘操作中，CPU可将总线控制权交给DMA控制器，由DMA输出读写命令，直接控制RAM与I/O接口进行DMA传输，无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场过程，使得CPU的效率大大提高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;MMU：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Memory Management Unit—内存管理单元，主要实现：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;竞争访问保护管理需求&lt;/span&gt;&lt;span&gt;：需要严格的访问保护，动态管理哪些内存页/段或区，为哪些应用程序所用。这属于资源的竞争访问管理需求；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高效的翻译转换管理需求：需要实现快速高效的映射翻译转换，否则系统的运行效率将会低下；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高效的虚实&lt;/span&gt;&lt;span&gt;内存交换需求：需要在实际的虚拟内存与物理内存进行内存页/段交换过程中快速高效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Page Cache：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;为了避免每次读写文件时，都需要对硬盘进行读写操作，Linux 内核使用页缓存（Page Cache）机制来对文件中的数据进行缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6171428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wV9fZKCpcpOY0avGW6rNkJFKic7KhibgN4Yu855ibRDgYiccCKDhSAQ1kEvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，由于读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;PageCache 使用了「预读功能」&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，假设read方法每次只会读32KB的字节，虽然read刚开始只会读0～32KB的字节，但内核会把其后面的32～64KB也读取到PageCache，这样后面读取32～64KB的成本就很低，如果在32～64KB淘汰出PageCache 前，有进程读取到它了，收益就非常大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;虚拟内存：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在计算机领域有一句如同摩西十诫般神圣的哲言：&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&quot;，从内存管理、网络模型、并发调度甚至是硬件架构，都能看到这句哲言在闪烁着光芒，而虚拟内存则是这一哲言的完美实践之一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虚拟内存为每个进程提供了一个&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一致的、私有且连续完整的内存空间&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;；所有现代操作系统都使用虚拟内存，使用虚拟地址取代物理地址，主要有以下几点好处：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一点，利用上述的第一条特性可以优化，可以把&lt;/span&gt;&lt;strong&gt;&lt;span&gt;内核空间和用户空间的虚拟地址映射到同一个物理地址&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，这样在I/O操作时就不需要来回复制了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2367256637168142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wVK1oEoebrAVIWXLP8mwxiaEEtFwYibRw9oneDjW2Eraw9zwzk9Vmdt0iaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;904&quot;/&gt;&lt;span&gt;第二点&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;多个虚拟内存可以指向同一个物理地址；&lt;/span&gt;&lt;span&gt;第三点，虚拟内存空间可以远远大于物理内存空间；&lt;/span&gt;&lt;span&gt;第四点，应&lt;/span&gt;&lt;span&gt;用层面可管理连续的内存空间，减少出错。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;NFS&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;文件系统：网络文件系统是FreeBSD支持的文件系统中的一种，也被称为NFS；NFS允许一个系统在网络上与它人共享目录和文件，通过使用 NFS，用户和程序可以象访问本地文件一样访问远端系统上的文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Copy-on-write&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;写入时复制（Copy-on-write，COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;如果调用者没有修改该资源，就不会有副本（private copy）被创建&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，因此多个调用者只是读取操作时可以共享同一份资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9Fl62j5eylelCcZwNOEv5HRg9xicSj2KIwvdQMPbwiau3eqyIUpKbjQ6nA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;为什么要有DMA&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在没有DMA技术前，I/O的过程是这样的：&lt;/span&gt;&lt;span&gt;首先，&lt;/span&gt;&lt;span&gt;CP&lt;/span&gt;&lt;span&gt;U发出对应的指令给磁盘控制器，然后返回；&lt;/span&gt;&lt;span&gt;其次，磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断；最后，&lt;/span&gt;&lt;span&gt;CPU收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间CPU是被阻塞的状态，无法执行其他任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.587135377711294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wV7gFianlh5zKgINwIjvo4LtKfbVbDcjT6Qe9nOJdgANbo2wwl27ke8BQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1337&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整个数据的传输过程，都要需要CPU亲自参与拷贝数据，而且这时CPU是被阻塞的；简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用CPU来搬运的话，肯定忙不过来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;计算机科学家们发现了事情的严重性后，于是就发明了DMA技术，也就是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;直接内存访问（Direct Memory Access）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;技术。&lt;/span&gt;&lt;span&gt;简单理解就是，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在进行I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给DMA控制器，而 CPU不再参与任何与数据搬运相关的事情，这样CPU就可以去处理别的事务&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体流程如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46944444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wVI3tPk68kl2czZgaOYgAlXV7pyFFFUcdW4aSfxZbZmIBbrC4McOgJNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，用户进程调用read方法，向操作系统发出I/O请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；其次，&lt;/span&gt;&lt;span&gt;操作系统收到请求后，进一步将I/O请求发送DMA，释放CPU；再次，DMA进一步将I/O请求发送给磁盘；从次，磁盘收到DMA的I/O请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向DMA发起中断信号，告知自己缓冲区已满；最后，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;DMA收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用CPU，CPU依然可以执行其它事务&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;；另外，当DMA读取了足够多的数据，就会发送中断信号给CPU；除此之外，CPU收到中断信号，将数据从内核拷贝到用户空间，系统调用返回。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在有了DMA后，整个数据传输的过程，CPU不再参与与磁盘交互的数据搬运工作，而是全程由DMA完成，但是CPU在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要CPU来告诉DMA控制器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;早期DMA只存在在主板上，如今由于I/O设备越来越多，数据传输的需求也不尽相同，所以每个I/O设备里面都有自己的DMA控制器。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;47&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FPB6mZB01WGXHsGUE2UYENHAJNeKa8y0qwiajZdfHR5lvk4rjnrQabwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;strong&gt;&lt;span&gt;传统文件传输的缺陷&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有了DMA后，我们的磁盘I/O就一劳永逸了吗？并不是的；拿我们比较熟悉的下载文件举例，服务端要提供此功能，比较直观的方式就是：将磁盘中的文件读出到内存，再通过网络协议发送给客户端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体的I/O工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的I/O接口从磁盘读取或写入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码通常如下，一般会需要两个系统调用：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;read&lt;/span&gt;(file, tmp_buf, len)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;socket&lt;/span&gt;, tmp_buf, len)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;代码很简单，虽然就两行代码，但是这里面发生了不少的事情：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5664556962025317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wVatfWDYmv53K3CL7jTicdF1htjUGH1PVBuSS1iaq4W53njYaGJTiaYszHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1896&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这其中有：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;4次用户态与内核态的上下文切换&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;两次系统调用read()和write()中，每次系统调用都得先从&lt;/span&gt;&lt;strong&gt;&lt;span&gt;用户态切换到内核态&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，等内核完成任务后，再从内核态切换回用户态；&lt;/span&gt;&lt;strong&gt;&lt;span&gt;上下文切换&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的成本并不小，一次切换需要耗时几十纳秒到几微秒，在高并发场景下很容易成为性能瓶颈。（参考&lt;/span&gt;&lt;strong&gt;&lt;span&gt;线程切换和协程切换的成本差别&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4次数据拷贝&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;两次由DMA完成拷贝，另外两次则是由CPU完成拷贝；我们只是搬运一份数据，结果却搬运了4次，过多的数据拷贝无疑会消耗额外的资源，大大降低了系统性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，要想提高文件传输的性能，就需要减少&lt;/span&gt;&lt;strong&gt;&lt;span&gt;用户态与内核态的上下文切换&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;和&lt;/span&gt;&lt;strong&gt;&lt;span&gt;内存拷贝&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的次数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何优化传统文件传输——&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;减少「用户态与内核态的上下文切换」：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而一次系统调用必然会发生2次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;减少「数据拷贝」次数：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;前面提到，传统的文件传输方式会历经4次数据拷贝；但很明显的可以看到：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;从内核的读缓冲区拷贝到用户的缓冲区&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;和&lt;/span&gt;&lt;strong&gt;&lt;span&gt;从用户的缓冲区里拷贝到socket的缓冲区」&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这两步是没有必要的。&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为在下载文件，或者说广义的文件传输场景中，我们并不需要在用户空间对数据进行&lt;/span&gt;&lt;strong&gt;&lt;span&gt;再加工&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，所以数据并不需要回到用户空间中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9F9gEWETfj769ZEnnF4YHYbm1UBFpYldG1ibl6E9owa0M3yRB40WtEqLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;零拷贝&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;那么&lt;/span&gt;&lt;strong&gt;&lt;span&gt;零拷贝&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;技术就应运而生了，它就是为了解决我们在上面提到的场景——跨过与用户态交互的过程，直接将数据从文件系统移动到网络接口而产生的技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1）零拷贝实现原理&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;零拷贝技术实现的方式通常有3种：&lt;/span&gt;&lt;span&gt;mmap+wr&lt;/span&gt;&lt;span&gt;ite、&lt;/span&gt;&lt;span&gt;sendfile、&lt;/span&gt;&lt;span&gt;splice。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在前面我们知道，read()系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了省去这一步，我们可以用mmap()替换read()系统调用函数，伪代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;buf = mmap(file, len)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;write(sockfd, buf, len)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;mmap的函数原型如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;mmap&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *addr, &lt;span class=&quot;code-snippet__keyword&quot;&gt;size_t&lt;/span&gt; length, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; prot, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; flags, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;code-snippet__keyword&quot;&gt;off_t&lt;/span&gt; offset)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;mmap()系统调用函数会在调用进程的虚拟地址空间中创建一个新映射，直接把内核缓冲区里的数据「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;映射&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6154545454545455&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wVCaarECoIc8jWrgL48libQX17cDerswwpEPZ1wibR6B79oXvr5yicg06Tw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体过程如下：&lt;/span&gt;&lt;span&gt;首先，应用进程调用了mmap()后，DMA会把磁盘的数据拷贝到内核的缓冲区里，应用进程跟操作系统内核「共享」这个缓冲区；&lt;/span&gt;&lt;span&gt;其次，应用进程再调用write()，操作系统直接将内核缓冲区的数据拷贝到 socket缓冲区中，这一切都发生在内核态，由CPU来搬运数据；&lt;/span&gt;&lt;span&gt;最后，把内核的socket缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由DMA搬运的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;通过使用mmap()来代替read()，可以减少一次数据拷贝的过程。&lt;/span&gt;&lt;span&gt;但这还不是最理想的零拷贝，因为仍然需要通过CPU把内核缓冲区的数据拷贝到socket缓冲区里，且仍然需要4次上下文切换，因为系统调用还是2次&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Linux内核版本2.1中，提供了一个专门发送文件的系统调用函数sendfile()如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;ssize_t&lt;/span&gt; sendfile(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; out_fd, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; in_fd, &lt;span class=&quot;code-snippet__keyword&quot;&gt;off_t&lt;/span&gt; *offset, &lt;span class=&quot;code-snippet__keyword&quot;&gt;size_t&lt;/span&gt; count);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，它可以替代前面的read()和write()这两个系统调用，这样就可以减少一次系统调用，也就减少了2次上下文切换的开销。&lt;/span&gt;&lt;span&gt;其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到socket缓冲区里，不再拷贝到用户态，这样就只有2次上下文切换，和3次数据拷贝。&lt;/span&gt;&lt;span&gt;如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6236363636363637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wVGqRBQLgFtqxsaOYVs8yKA3KwqhHibpROr6Qy9459Wkh4yjEYQ237UJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;带有scatter/gather的sendfile 方式：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Linux 2.4内核进行了优化，提供了带有scatter/gather的sendfile操作，这个操作可以把最后一次CPU COPY去除。其原理就是在内核空间Read BUffer和Socket Buffer不做数据复制，而是将Read Buffer的内存地址、偏移量记录到相应的Socket Buffer中，这样就不需要复制。其本质和虚拟内存的解决方法思路一致，就是内存地址的记录。&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可以在你的Linux系统通过下面这个命令，查看网卡是否支持scatter-gather特性：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; ethtool -k eth0 | grep scatter-gather&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;scatter-gather: on&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;于是，从Linux内核2.4版本开始起，对于支持网卡支持SG-DMA技术的情况下，sendfile()系统调用的过程发生了点变化，具体过程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一步，通过DMA将磁盘上的数据拷贝到内核缓冲区里；&lt;/span&gt;&lt;span&gt;第二步，缓冲区描述符和数据长度传到socket缓冲区，这样网卡的SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到socket缓冲区中，这样就减少了一次数据拷贝。&lt;/span&gt;&lt;span&gt;所以，这个过程之中，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;只进行了2次数据拷贝&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5913793103448276&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wVLd8w8YkJvcfvgoIibwaFJuliaO5cHHMPMjQexzBX1FzyqFf4VGXn5NBw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1160&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;splice调用和sendfile非常相似，用户应用程序必须拥有两个已经打开的文件描述符，一个表示输入设备，一个表示输出设备。与sendfile不同的是，splice允许任意两个文件互相连接，而并不只是文件与socket进行数据传输。对于从一个文件描述符发送数据到socket这种特例来说，一直都是使用sendfile系统调用，而splice一直以来就只是一种机制，它并不仅限于sendfile的功能。也就是说&lt;/span&gt;&lt;span&gt;&lt;strong&gt;sendfile是splice的一个子集&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;splice()是基于Linux的管道缓冲区(pipe buffer)机制实现的，所以splice()的两个入参文件描述符要求必须有一个是管道设备。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用splice()完成一次磁盘文件到网卡的读写过程如下&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，用户进程调用pipe()，从用户态陷入内核态；创建匿名单向管道，pipe()返回，上下文从内核态切换回用户态；&lt;/span&gt;&lt;span&gt;其次，用户进程调用splice()，从用户态陷入内核态；&lt;/span&gt;&lt;span&gt;再次，DMA控制器将数据从硬盘拷贝到内核缓冲区，从管道的写入端&quot;拷贝&quot;进管道，splice()返回，上下文从内核态回到用户态；&lt;/span&gt;&lt;span&gt;从次，用户进程再次调用splice()，从用户态陷入内核态；&lt;/span&gt;&lt;span&gt;最后，内核把数据从管道的读取端拷贝到socket缓冲区，DMA控制器将数据从socket缓冲区拷贝到网卡；&lt;/span&gt;&lt;span&gt;另外，splice()返回，上下文从内核态切换回用户态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.57&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wVXzErsS5by2XQiaPQPMLPFzuAiaX1Fa6NGrM9qz0rVoxQhRHiaAE6uTiatw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Linux2.6.17版本引入了splice，而在Linux 2.6.23版本中，sendfile机制的实现已经没有了，但是其API及相应的功能还在，只不过API及相应的功能是利用了splice机制来实现的。&lt;/span&gt;&lt;span&gt;和sendfile不同的是，splice不需要硬件支持。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FibDz8VdeMtTPP6QGg7Qg03rhEzsPz8nRZlEVnmBdT96EyJFHfMz0iavQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;strong&gt;&lt;span&gt;零拷贝的实际应用&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1）Kafka&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;事实上，Kafka这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I/O的吞吐率，这也是Kafka在处理海量数据为什么这么快的原因之一。&lt;/span&gt;&lt;span&gt;如果你追溯Kafka文件传输的代码，你会发现，最终它调用了Java NIO库里的 transferTo方法：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Overridepublic&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;transferFrom&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(FileChannel fileChannel, &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; position, &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; count)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; fileChannel.transferTo(position, count, socketChannel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果Lin&lt;/span&gt;&lt;span&gt;ux系统支持sendfile()系统调用，那么transferTo()实际上最后就会使用到sendfile()系统调用函数。&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2）Nginx&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;Nginx也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;http&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;sendfile&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;on&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe97wd1kjBtWzys9nG2SWzoiabw5V7EdjQsD9xVByPSSQwIdCa4YpoKGZCP5ZbMK6SBl0eqVapQznw0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;大文件传输场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1）零拷贝还是最优选吗&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在大文件传输的场景下，零拷贝技术并不是最优选择；因为在零拷贝的任何一种实现中，都会有「DMA将数据从磁盘拷贝到内核缓存区——Page Cache」这一步，但是，在传输大文件（GB级别的文件）的时候，PageCache会不起作用，那就白白浪费DMA多做的一次数据拷贝，造成性能的降低，即使使用了PageCache的零拷贝也会损失性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是因为在大文件传输场景下，每当用户访问这些大文件的时候，内核就会把它们载入PageCache中，PageCache空间很快被这些大文件占满；且由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来2个问题：&lt;/span&gt;&lt;span&gt;PageCache由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到PageCache，于是这样磁盘读写的性能就会下降了；&lt;/span&gt;&lt;span&gt;PageCache中的大文件数据，由于没有享受到缓存带来的好处，但却耗费DMA多拷贝到PageCache一次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2）异步I/O+direct I/O&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;那么大文件传输场景下我们该选择什么方案呢？让我们先来回顾一下我们在文章开头介绍DMA时最早提到过的同步I/O：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.587135377711294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wV7gFianlh5zKgINwIjvo4LtKfbVbDcjT6Qe9nOJdgANbo2wwl27ke8BQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1337&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;同步&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;体现在当进程调用read方法读取文件时，进程实际上会阻塞在 read方法调用，因为要等待磁盘数据的返回，并且我们当然不希望进程在读取大文件时被阻塞，对于阻塞的问题，可以用异步I/O来解决，即：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5986787778695293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wVicaCTswibZkXpTdK4n3bicwS8tPcib4yHp7R4L2jmgSpIm2sRHqkSrGEVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1211&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它把读操作分为两部分：&lt;/span&gt;&lt;span&gt;前半部分，内核向磁盘发起读请求，但是可以&lt;/span&gt;&lt;strong&gt;&lt;span&gt;不等待数据就位就返回&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，于是进程此时可以处理其他任务；&lt;/span&gt;&lt;span&gt;后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;通知&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，再去处理数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而且，我们可以发现，异步I/O并没有涉及到PageCache；使用异步I/O就意味着要绕开PageCache，因为填充PageCache的过程在内核中必须阻塞。&lt;/span&gt;&lt;span&gt;所以异步I/O中使用的是direct I/O（对比使用PageCache的buffer I/O），这样才能不阻塞进程，立即返回。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;direct I/O应用场景常见的两种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一种，应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache再次缓存，减少额外的性能损耗。在MySQL数据库中，可以通过参数设置开启direct I/O，默认是不开启；&lt;/span&gt;&lt;span&gt;第二种，传输大文件的时候，由于大文件难以命中PageCache缓存，而且会占满PageCache导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用`direct I/O。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，由于direct I/O绕过了PageCache，就无法享受内核的这两点的优化：&lt;/span&gt;&lt;span&gt;内核的I/O调度算法会缓存尽可能多的I/O请求在PageCache中，最后「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;合并&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」成一个更大的I/O请求再发给磁盘，这样做是为了减少磁盘的寻址操作；&lt;/span&gt;&lt;span&gt;内核也会「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;预读&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」后续的I/O请求放在PageCache中，一样是为了减少对磁盘的操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际应用中也有类似的配置，在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式传输：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;location&lt;/span&gt; /video/ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attribute&quot;&gt;sendfile&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;on&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attribute&quot;&gt;aio&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;on&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attribute&quot;&gt;directio&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1024m&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;当文件大小大于directio值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3）使用direct I/O需要注意的点&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;首先，贴一下我们的Linus(Linus Torvalds)对O_DIRECT的评价：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&quot;The thing that has always disturbed me about O_DIRECT is that the whole interface is just stupid, and was probably designed by a deranged monkey on some serious mind-controlling substances.&quot; —Linus&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;一般来说能引得Linus开骂的东西，那是一定有很多坑的。&lt;/span&gt;&lt;span&gt;在Linux的man page中我们可以看到O_DIRECT下有一个Note，这里我就不贴出来了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结一下其中需要注意的点如下：&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一点，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;地址对齐限制。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;O_DIRECT会带来强制的地址对齐限制，这个对齐的大小也跟文件系统/存储介质相关，并且当前没有不依赖文件系统自身的接口提供指定文件/文件系统是否有这些限制的信息&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Linux 2.6以前，总传输大小、用户的对齐缓冲区起始地址、文件偏移量必须都是逻辑文件系统的数据块大小的倍数，这里说的数据块(block)是一个逻辑概念，是文件系统捆绑一定数量的连续扇区而来，因此通常称为 “文件系统逻辑块”，可通过以下命令获取：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;blockdev&lt;/span&gt; --getss&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Linux2.6以后对齐的基数变为物理上的存储介质的sector size扇区大小，对应物理存储介质的最小存储粒度，可通过以下命令获取：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;blockdev&lt;/span&gt; --getpbsz&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;带来这个限制的原因也很简单，内存对齐这件小事通常是内核来处理的，而&lt;/span&gt;&lt;strong&gt;&lt;span&gt;O_DIRECT&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;绕过了内核空间，那么内核处理的所有事情都需要用户自己来处理，后台回复“Linux I/O”获取详细解释。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二点，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;O_DIRECT 平台不兼容。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这应该是大部分跨平台应用需要注意到的点，O_DIRECT本身就是Linux中才有的东西，在语言层面/应用层面需要考虑这里的兼容性保证，比如在Windows下其实也有类似的机制FILE_FLAG_NO_BUFFERIN用法类似；再比如macOS下的F_NOCACHE虽然类似O_DIRECT，但实际使用中也有差距。&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第三点&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;不要并发地运行 fork 和 O_DIRECT I/O。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果O_DIRECT I/O中使用到的内存buffer是一段私有的映射（虚拟内存），如任何使用上文中提到过的mmap并以MAP_PRIVATE flag 声明的虚拟内存，那么相关的O_DIRECT I/O（不管是异步 I/O / 其它子线程中的 I/O）都必须在调用fork系统调用前执行完毕；否则会造成数据污染或产生未定义的行为&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下情况这个限制不存在：&lt;/span&gt;&lt;span&gt;相关的内存buffer是使用shmat分配或是使&lt;/span&gt;&lt;span&gt;用mmap以MAP_SHARED flag声明的；&lt;/span&gt;&lt;span&gt;相关的内存buffer是使用madvise以MADV_DONTFORK声明的（注意这种方式下该内存buffer在子进程中不可用）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第四点，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;避免对同一文件混合使用 O_DIRECT 和普通 I/O。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在应用层需要避免对同一文件（&lt;/span&gt;&lt;strong&gt;&lt;span&gt;尤其是对同一文件的相同偏移区间内&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;）混合使用O_DIRECT和普通I/O；即使我们的文件系统能够帮我们处理和保证这里的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一致性问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，总体来说整个I/O吞吐量也会比单独使用某一种I/O方式要小。&lt;/span&gt;&lt;span&gt;同样的，应用层也要避免对同一文件混合使用direct I/O和mmap。&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第五点，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;NFS 协议下的 O_DIRECT&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;虽然NFS文件系统就是为了让用户像访问本地文件一样去访问网络文件，但O_DIRECT在NFS文件系统中的表现和本地文件系统不同，比较老版本的内核或是魔改过的内核可能并不支持这种组合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是因为在NFS协议中并不支持传递&lt;/span&gt;&lt;strong&gt;&lt;span&gt;flag参数&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;到服务器，所以O_DIRECT I/O实际上只绕过了本地客户端的Page Cache，但服务端/同步客户端仍然会对这些I/O进行cache。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当客户端请求服务端进行I/O同步来保证O_DIRECT的同步语义时，一些服务器的性能表现不佳（尤其是当这些I/O很小时）；还有一些服务器干脆设置为&lt;/span&gt;&lt;strong&gt;&lt;span&gt;欺骗客户端&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，直接返回客户端「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;数据已写入存储介质&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」，这样就可以一定程度上避免I/O同步带来的性能损失，但另一方面，当服务端断电时就无法保证未完成I/O同步的数据的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;数据完整性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;了。&lt;/span&gt;&lt;span&gt;Linux的NFS客户端也没有上面说过的地址对齐的限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4）在 Golang 中使用 direct I/O&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;direct io必须要满足3种对齐规则：io偏移扇区对齐，长度扇区对齐，内存 buffer 地址扇区对齐；前两个还比较好满足，但是分配的内存地址仅凭原生的手段是无法直接达成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先对比一下c语言，libc库是调用posix_memalign 直接分配出符合要求的内存块，但Golang中要怎么实现呢？&lt;/span&gt;&lt;span&gt;在Golang中，io的buffer其实就是字节数组，自然是用make来分配，如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;buffer := &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;4096&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;但buffer中的data字节数组首地址并不一定是对齐的。&lt;/span&gt;&lt;span&gt;方法也很简单，就是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;先分配一个比预期要大的内存块，然后在这个内存块里找对齐位置&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;；这是一个任何语言皆通用的方法，在 Go 里也是可用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，我现在需要一个4096大小的内存块，要求地址按照 512 对齐，可以这样做：&lt;/span&gt;&lt;span&gt;先分配4096+512大小的内存块，假设得到的内存块首地址是 p1；&lt;/span&gt;&lt;span&gt;然后在[p1, p1+512] 这个地址范围找，一定能找到512对齐的地址p2；&lt;/span&gt;&lt;span&gt;返回 p2，用户能正常使用 [p2, p2+4096] 这个范围的内存块而不越界。&lt;/span&gt;&lt;span&gt;以上就是基本原理了，具体实现如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;alignment&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(block []&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;, AlignSize &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;uintptr&lt;/span&gt;(unsafe.Pointer(&amp;amp;block[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;])) &amp;amp; &lt;span class=&quot;code-snippet__keyword&quot;&gt;uintptr&lt;/span&gt;(AlignSize&lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AlignedBlock&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(BlockSize &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; []&lt;span class=&quot;code-snippet__title&quot;&gt;byte&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   block := &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;, BlockSize+AlignSize)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   a := alignment(block, AlignSize)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   offset := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; a != &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      offset = AlignSize - a&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   block = block[offset : offset+BlockSize]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; BlockSize != &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      a = alignment(block, AlignSize)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; a != &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         log.Fatal(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Failed to align block&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; block&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;所以，通过以上AlignedBlock函数分配出来的内存一定是 512 地址对齐的，唯一的缺点就是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在分配较小内存块时对齐的额外开销显得比较大&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;开源实现：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Github上就有开源的Golang direct I/O实现：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;ncw/directio&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;使用也很简单，&lt;/span&gt;&lt;span&gt;O_DIRECT模式打开文件：&lt;/span&gt;&lt;/h5&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fp, err := directio.OpenFile(file, os.O_RDONLY, &lt;span class=&quot;code-snippet__number&quot;&gt;0666&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读数据：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;buffer := directio.AlignedBlock(directio.BlockSize)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;_, err := io.ReadFull(fp, buffer)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe97wd1kjBtWzys9nG2SWzoiabWMmQ9biaEIlibqKMMFiaJldegzc8CcAf2gdqKkx15PCU8nUDdElvnibV5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;内核缓冲区和用户缓冲区之间的传输优化&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;到目前为止，我们讨论的zero-copy技术都是基于减少甚至是避免用户空间和内核空间之间的CPU数据拷贝的，虽然有一些技术非常高效，但是大多都有适用性很窄的问题，比如 sendfile()、splice() 这些，效率很高，但是都只适用于那些用户进程&lt;/span&gt;&lt;strong&gt;&lt;span&gt;不需要再处理数据&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的场景，比如静态文件服务器或者是直接转发数据的代理服务器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面提到过的虚拟内存机制和mmap等都表明，通过在不同的虚拟地址上重新映射页面可以实现在用户进程和内核之间虚拟复制和共享内存；因此如果要在实现在用户进程内处理数据（这种场景比直接转发数据更加常见）之后再发送出去的话，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;用户空间和内核空间的数据传输就是不可避免的&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，既然避无可避，那就只能选择优化了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两种优化用户空间和内核空间数据传输的技术：&lt;/span&gt;&lt;span&gt;动态重映射与写时拷贝 (Copy-on-Write)、&lt;/span&gt;&lt;span&gt;缓冲区共享(Buffer Sharing)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1）写时拷贝 (Copy-on-Write)&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;前面提到过过利用内存映射(mmap)来减少数据在用户空间和内核空间之间的复制，通常用户进程是对共享的缓冲区进行同步阻塞读写的，这样不会有&lt;/span&gt;&lt;strong&gt;&lt;span&gt;线程安全&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;问题，但是很明显这种模式下效率并不高，而提升效率的一种方法就是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;异步地对共享缓冲区进行读写&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，而这样的话就必须引入保护机制来避免&lt;/span&gt;&lt;strong&gt;&lt;span&gt;数据冲突&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;问题，COW(Copy on Write) 就是这样的一种技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;COW是一种建立在虚拟内存重映射技术之上的技术，因此它需要 MMU 的硬件支持，MMU会记录当前哪些内存页被标记成只读，当有进程尝试往这些内存页中写数据的时候，MMU 就会抛一个异常给操作系统内核，内核处理该异常时为该进程分配一份物理内存并复制数据到此内存地址，重新向 MMU 发出执行该进程的写操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图为COW在Linux中的应用之一：fork/clone，fork出的子进程共享父进程的物理空间，当父子进程&lt;/span&gt;&lt;strong&gt;&lt;span&gt;有内存写入操作时&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，read-only内存页发生中断，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;将触发的异常的内存页复制一份&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;(其余的页还是共享父进程的)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7563025210084033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatwBdF9wMkW8xQCnxEdD3wVKek37k9qwFDwkqdjcTrdKm6A1TUUwUFIKzPCjPJJ8oZj3ZxGOw8qOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1428&quot;/&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;局限性：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;COW这种零拷贝技术比较适用于那种&lt;/span&gt;&lt;strong&gt;&lt;span&gt;多读少写从而使得COW事件发生较少的场景&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，而在其它场景下反而可能造成负优化，因为COW事件所带来的系统开销要远远高于一次CPU拷贝所产生的。&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，在实际应用的过程中，为了避免频繁的内存映射，可以重复使用同一段内存缓冲区，因此，你不需要在只用过一次共享缓冲区之后就解除掉内存页的映射关系，而是重复循环使用，从而提升性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但这种内存页映射的持久化并不会减少由于页表往返移动/换页和TLB flush所带来的系统开销，因为每次接收到COW事件之后对内存页而进行加锁或者解锁的时候，内存页的只读标志 (read-ony) 都要被更改为 (write-only)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;COW的实际应用——&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;Redis的持久化机制：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Redis作为典型的内存型应用，一定是有内核缓冲区和用户缓冲区之间的传输优化的。&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis的持久化机制中，如果采用bgsave或者bgrewriteaof 命令，那么会 fork 一个子进程来将数据存到磁盘中。总体来说&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Redis的读操作是比写操作多的（在正确的使用场景下），因此这种情况下使用COW可以减少 fork() 操作的阻塞时间&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;语言层面的应用&lt;/span&gt;&lt;/strong&gt;&lt;/h6&gt;&lt;p&gt;&lt;span&gt;写时复制的思想在很多语言中也有应用，相比于传统的深层复制，能带来很大性能提升；比如C++98标准下的 std::string 就采用了写时复制的实现：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; y = x;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;y += &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;, World!&quot;&lt;/span&gt;;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;Golang中的string,slice也使用了类似的思想，在复制/切片等操作时都不会改变底层数组的指向，变量共享同一个底层数组，仅当进行append / 修改等操作时才可能进行真正的copy（append时如果超过了当前切片的容量，就需要分配新的内存）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2）缓冲区共享(Buffer Sharing)&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;从前面的介绍可以看出，传统的Linux I/O接口，都是基于复制/拷贝的：数据需要在操作系统内核空间和用户空间的缓冲区之间进行拷贝。在进行I/O操作之前，用户进程需要预先分配好一个内存缓冲区，使用read()系统调用时，内核会将从存储器或者网卡等设备读入的数据拷贝到这个用户缓冲区里。而使用write()系统调用时，则是把&lt;/span&gt;&lt;span&gt;&lt;strong&gt;用户内存缓冲区的数据拷贝至内核缓冲区&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了实现这种传统的I/O模式，Linux必须要在每一个I/O操作时都进行内存虚拟映射和解除。这种内存页重映射的机制的效率严重受限于缓存体系结构、MMU地址转换速度和TLB命中率。如果能够避免处理I/O请求的虚拟地址转换和TLB刷新所带来的开销，则有可能极大地提升I/O性能。而缓冲区共享就是用来解决上述问题的一种技术（说实话我觉得有些套娃的味道了）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;操作系统内核开发者们实现了一种叫fbufs的缓冲区共享的框架，也即快速缓冲区（Fast Buffers）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，使用一个fbuf缓冲区作为数据传输的最小单位。使用这种技术需要调用新的操作系统API，用户区和内核区、内核区之间的数据都必须严格地在fbufs这个体系下进行通信。fbufs为每一个用户进程分配一个 buffer pool，里面会储存预分配(也可以使用的时候再分配)好的 buffers，这些buffers会被同时映射到用户内存空间和内核内存空间。fbufs只需通过一次虚拟内存映射操作即可创建缓冲区，有效地消除那些由存储一致性维护所引发的大多数性能损耗。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;共享缓冲区技术的实现需要&lt;/span&gt;&lt;span&gt;&lt;strong&gt;依赖于用户进程、操作系统内核、以及I/O子系统(设备驱动程序，文件系统等)之间协同工作&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。比如，设计得不好的用户进程容易就会修改已经发送出去的fbuf从而污染数据，更要命的是这种问题很难debug。虽然这个技术的设计方案非常精彩，但是它的门槛和限制却不比前面介绍的其他技术少：首先会对操作系统API造成变动，需要使用新的一些API调用，其次还需要设备驱动程序配合改动，还有由于是内存共享，内核需要很小心谨慎地实现对这部分共享的内存进行数据保护和同步的机制，而这种并发的同步机制是非常容易出bug的从而又增加了内核的代码复杂度，等等。因此这一类的技术还远远没有到发展成熟和广泛应用的阶段，目前大多数的实现都还处于实验阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe97wd1kjBtWzys9nG2SWzoiabqT4VBv3lNNiay4vP8Bnic3lnws0QSJ5WNc8ZiablIdxD7MXJn4Gxk9fDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从早期的I/O到DMA，解决了阻塞CPU的问题；而为了省去I/O过程中不必要的上下文切换和数据拷贝过程，零拷贝技术就出现了。&lt;/span&gt;&lt;span&gt;所谓的零拷贝(Zero-copy)技术，就是完完全全不需要在内存层面拷贝数据，省去CPU搬运数据的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;零拷贝技术的文件传输方式相比传统文件传输的方式，减少了2次上下文切换和数据拷贝次数&lt;/span&gt;&lt;strong&gt;&lt;span&gt;，只需要2次上下文切换和数据拷贝次数，就可以完成文件的传输，而且2次的数据拷贝过程，都不需要通过CPU，2次都是由DMA来搬运&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;总体来看，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;零拷贝技术至少可以把文件传输的性能提高一倍以上&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，以下是各方案详细的成本对比：&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.48164464023494863&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96ljvIP4ibXCT25tCxrBGy3KhHmichRYekicodamgzibAhopMiawdJfGaeeNibaYZVXK9ROMpzX9rCfDBMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;零拷贝技术是基于PageCache的，PageCache会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I/O调度算法实现了I/O合并与预读，这也是顺序读比随机读性能好的原因之一；这些优势，进一步提升了零拷贝的性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但当面对大文件传输时，不能使用零拷贝，因为可能由于PageCache被大文件占据，导致「热点」小文件无法利用到PageCache的问题，并且大文件的缓存命中率不高，这时就需要使用「异步I/O+direct I/O」的方式；&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在使用direct I/O时也需要注意许多的坑点&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，毕竟连Linus也会被O_DIRECT &#x27;disturbed&#x27;到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而在更广泛的场景下，我们还需要注意到内&lt;/span&gt;&lt;strong&gt;&lt;span&gt;核缓冲区和用户缓冲区之间的传输优化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，这种方式侧重于在用户进程的缓冲区和操作系统的页缓存之间的CPU 拷贝的优化，延续了以往那种传统的通信方式，但更灵活。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;I/O相关的各类优化自然也已经深入到了日常我们接触到的语言、中间件以及数据库的方方面面，通过了解和学习这些技术和思想，也能对日后自己的程序设计以及性能优化上有所启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你可能感兴趣的腾讯工程师作品&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M6IC6IoU4PwMicRZB4dKAVUhfw1GR9CJvqeqIWic50hQeGiaVgjY4oK8BXrMNsMra2MQ3f4LAlLKT6ibW9GdTvibUtg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;24&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2&quot; data-w=&quot;24&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sPQicVg8nzU0ceHDyC83Jm2vibsTbUia3blLRW1z0KUrw4OIV2eOibRmEWfWJYVXuyN6TOno2sLg9ZU7meG4uAY2jg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247570280&amp;amp;idx=1&amp;amp;sn=2d6a13b5a9965c7dc064c2457b7affd2&amp;amp;chksm=eaa9c938ddde402e7f662ae4c10305a276d2e1abc4c457024681b128a8bdced3501f5c631be9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;由浅入深读透vue源码：diff算法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;由浅入深读透vue源码：diff算法&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247569534&amp;amp;idx=1&amp;amp;sn=a89d76deaae4d9d8ecaae27706772ed3&amp;amp;chksm=eaa9ca2eddde4338f09e279eec39963711e714dd4142f2d3d9569faadffb5cb84f8f220ec951&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;优雅应对故障：QQ音乐怎么做高可用架构体系？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;优雅应对故障：QQ音乐怎么做高可用架构体系？&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568983&amp;amp;idx=1&amp;amp;sn=fee3d132d2e61d92d5e69fe3f9e4e86c&amp;amp;chksm=eaa9d407ddde5d1124f55ee09135b2b714dddd4aca5c0c3fd9510671f074a6d714b130b60e38&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PB 级数据秒级分析：腾讯云原生湖仓DLC 架构揭秘&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;PB 级数据秒级分析：腾讯云原生湖仓DLC 架构揭秘&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;| &lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568678&amp;amp;idx=1&amp;amp;sn=d02ba2da9fe835b7c18650def3124d1c&amp;amp;chksm=eaa9d776ddde5e605f2d3220fda2f54ab28ba0a612b16f3ba61ce044d18b402a031ccaed1847&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;详解全网最快Go泛型跳表【内附源码】&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;详解全网最快Go泛型跳表【内附源码】&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术盲盒：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568617&amp;amp;idx=1&amp;amp;sn=d3409583764c4877964765a6b774b1de&amp;amp;chksm=eaa9d6b9ddde5faff511c416033948f76b056b209df76c6eb12adfea3f618422297b9b11895b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;前端&lt;/a&gt;&lt;span&gt;&lt;strong&gt;｜&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568512&amp;amp;idx=1&amp;amp;sn=5a2e887c0ac511e9a4fe5cd68a388e48&amp;amp;chksm=eaa9d6d0ddde5fc6376f1ffcc6e7b050fefded23d5b24c5f7b801885f509df06cd53d99f0a45&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;后端&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;｜&lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568656&amp;amp;idx=1&amp;amp;sn=98f7033418fc1fd7d019eeb18008b616&amp;amp;chksm=eaa9d740ddde5e56aa0b7df55dc2f70c65f329d37246453c2b3316356f3f84cc9f87eb6b8db4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;AI与算法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;AI与算法&lt;/a&gt;&lt;strong&gt;&lt;span&gt;｜&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568672&amp;amp;idx=1&amp;amp;sn=85e4b3e1c46289058398b216edb40941&amp;amp;chksm=eaa9d770ddde5e669cfaa25c37887ae058c433e4296ca04f8ff5373184bc76d4420f1d2049a7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运维｜&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;运维&lt;strong&gt;&lt;span&gt;｜&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568677&amp;amp;idx=1&amp;amp;sn=e95255553777c53d38cb1e64c1c16432&amp;amp;chksm=eaa9d775ddde5e633a75d20eb484181c0e03cb6f8237a4141c599e4f13ad3af6748c5e8d1a9a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;工程师文化&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;工程师文化&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;后台回复“&lt;/span&gt;&lt;span&gt;Linux I/O&lt;/span&gt;&lt;span&gt;&lt;span&gt;”，&lt;/span&gt;&lt;span&gt;领本文作者推荐资料。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5294117647058824&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/FBfnpCtdk5Ua19DY7eDCCw2Ib0OB5dRiclmhic9dsa8hk0M6mcNLn6oE88gJNz6hVhZGcvgbJyicQSuBsfr7ppw4w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;68&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8e9301e073076ba12941a59917688bce</guid>
<title>支付系统就该这么设计（万能通用），稳的一批！</title>
<link>https://toutiao.io/k/wcj32rn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>07a9f73ea53ed4353c368280be6dfc70</guid>
<title>带你透析认识 Seata 分布式事务服务的原理和流程（1）</title>
<link>https://toutiao.io/k/o87ktyv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;
        
        
                &lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h2&gt;&lt;a id=&quot;_0&quot;/&gt;分布式事务的背景&lt;/h2&gt; 
&lt;p&gt;随着业务的不断发展，单体架构已经无法满足我们的需求，分布式微服务架构逐渐成为大型互联网平台的首选，但所有使用分布式微服务架构的应用都必须面临一个十分棘手的问题，那就是“分布式事务”问题。&lt;/p&gt; 
&lt;p&gt;在分布式微服务架构中，几乎所有业务操作都需要多个服务协作才能完成。对于其中的某个服务而言，它的数据一致性可以交由其自身数据库事务来保证，但从整个分布式微服务架构来看，其全局数据的一致性却是无法保证的。&lt;/p&gt; 
&lt;h2&gt;&lt;a id=&quot;Seata_6&quot;/&gt;Seata是什么？&lt;/h2&gt; 
&lt;p&gt;Seata 是一个分布式事务处理框架，也是一款开源的分布式事务解决方案，由阿里巴巴和蚂蚁金服共同开源的分布式事务解决方案，能够在微服务架构下提供高性能且简单易用的分布式事务服务，致力于提供高性能和简单易用的分布式事务服务。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Seata_10&quot;/&gt;Seata相关资料&lt;/h3&gt; 
 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/973ef9dce6abf74fdb6cd47410d1e651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/9c9f43cc053ef7141243b4c092bd23c8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Seata_20&quot;/&gt;Seata的发展历程&lt;/h3&gt; 
&lt;p&gt;阿里巴巴作为国内最早一批进行应用分布式（微服务化）改造的企业，很早就遇到微服务架构下的分布式事务问题，阿里巴巴对于分布式事务问题先后发布了以下解决方案：&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;2014 年，阿里中间件团队发布 TXC（Taobao Transaction Constructor），为集团内应用提供分布式事务服务。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;2016 年，TXC 在经过产品化改造后，以 GTS（Global Transaction Service） 的身份登陆阿里云，成为当时业界唯一一款云上分布式事务产品。在阿云里的公有云、专有云解决方案中，开始服务于众多外部客户。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;2019 年起，基于 TXC 和 GTS 的技术积累，阿里中间件团队发起了开源项目 Fescar（Fast &amp;amp; EaSy Commit And Rollback, FESCAR），和社区一起建设这个分布式事务解决方案。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;2019 年 fescar 被重命名为了seata（simple extensiable autonomous transaction architecture）。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;TXC、GTS、Fescar以及seata一脉相承，为解决微服务架构下的分布式事务问题交出了一份与众不同的答卷。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;&lt;a id=&quot;_34&quot;/&gt;事务相关概念&lt;/h3&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;事务&lt;/strong&gt;：由一组操作构成的可靠、独立的工作单元，事务具备 ACID 的特性，即原子性、一致性、隔离性和持久性。&lt;/li&gt;&lt;/ul&gt; 
&lt;h4&gt;&lt;a id=&quot;_38&quot;/&gt;分布式事务的相关概念&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;分布式事务的基本原则可以理解成&lt;strong&gt;一个包含了若干个分支事务的全局事务&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b97cae9d3276d7c59e293e42e57ffc4f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;分布式事务主要涉及以下概念&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;本地事务&lt;/strong&gt;：本地事务由本地资源管理器（通常指数据库管理系统 DBMS，例如 MySQL、Oracle 等）管理，严格地支持 ACID 特性，高效可靠。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;全局事务&lt;/strong&gt;：全局事务指的是一次性操作多个资源管理器完成的事务，由一组分支事务组成。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;分支事务&lt;/strong&gt;：在分布式事务中，就是一个受全局事务管辖和协调的本地事务。&lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e03085ff4124cb8a1b8e24f3ccbb2b13.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;注意：本地事务不具备分布式事务的处理能力，隔离的最小单位受限于资源管理器，即本地事务只能对自己数据库的操作进行控制，对于其他数据库的操作则无能为力&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h5&gt;&lt;a id=&quot;_54&quot;/&gt;全局事务&lt;/h5&gt; 
&lt;p&gt;全局事务的职责是协调其管辖的各个分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个满足 ACID特性的本地事务。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Seata_58&quot;/&gt;Seata的运作原理&lt;/h3&gt; 
&lt;p&gt;Seata对分布式事务的协调和控制，主要是通过XID和3个核心组件实现的。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;XID_62&quot;/&gt;XID&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;XID是全局事务唯一标识，可以在服务的调用链路中传递，绑定到服务的事务上下文中&lt;/strong&gt;。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;_66&quot;/&gt;核心组件&lt;/h4&gt; 
&lt;p&gt;Seata定义了3个核心组件&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;TC（Transaction Coordinator）&lt;/strong&gt;：事务协调器，它是事务的协调者（这里指的是 Seata服务器），主要负责维护全局事务和分支事务的状态，&lt;strong&gt;驱动全局事务提交或回滚&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;TM（Transaction Manager）&lt;/strong&gt;：事务管理器，它是事务的发起者，负责定义全局事务的范围，并根据TC&lt;strong&gt;维护的全局事务和分支事务状态&lt;/strong&gt;，做出&lt;strong&gt;开始事务、提交事务、回滚事务的决议&lt;/strong&gt;。&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/c544335082b933942db46c86ba3ca7c3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;RM（Resource Manager）&lt;/strong&gt;：资源管理器，它是资源的管理者（这里可以将其理解为各服务使用的数据库）。它负责管理分支事务上的资源，向TC注册分支事务，汇报分支事务状态，驱动分支事务的提交或回滚。&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/a0685cf0e082c8550bae9fa4a7327fc8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;以上三个组件相互协作，TC 以 Seata 服务器（Server）形式独立部署，TM 和 RM 则是以 Seata Client的形式集成在微服务中运行。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Seata_81&quot;/&gt;Seata的运行流程&lt;/h3&gt; 
&lt;p&gt;Seata 的整体工作流程如下&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b99dc8c12e3266876a15963f524466ba.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;TM向TC申请开启一个全局事务，全局事务创建成功后，TC会针对这个全局事务生成一个全局唯一的XID；&lt;/li&gt;&lt;li&gt;XID 通过服务的调用链传递到其他服务;&lt;/li&gt;&lt;li&gt;RM向TC注册一个分支事务，并将其纳入XID对应全局事务的管辖；&lt;/li&gt;&lt;li&gt;TM根据TC收集的各个分支事务的执行结果，向TC发起全局事务提交或回滚决议；&lt;/li&gt;&lt;li&gt;TC调度XID下管辖的所有分支事务完成提交或回滚操作。&lt;/li&gt;&lt;/ol&gt; 
&lt;h3&gt;&lt;a id=&quot;Seata_93&quot;/&gt;Seata的事务模式&lt;/h3&gt; 
&lt;p&gt;目前Seata为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案，可以快速有效地对分布式事务进行控制。&lt;/p&gt; 
&lt;p&gt;在这四种事务模式中使用最多，最方便的就是 AT 模式。与其他事务模式相比，AT 模式可以应对大多数的业务场景，且基本可以做到无业务入侵，开发人员能够有更多的精力关注于业务逻辑开发。&lt;/p&gt; 
&lt;h2&gt;&lt;a id=&quot;Seata_99&quot;/&gt;Seata最后结论&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;接下来会针对于Seata的每种事务模式进行实战指南。&lt;/p&gt; 
&lt;/blockquote&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>