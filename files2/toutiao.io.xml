<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5df0838a8f7ffe03731e8dfbda83736b</guid>
<title>【程序员日记】---当“微服务”遇到了“电饼铛“</title>
<link>https://toutiao.io/k/w41l6kb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：京东物流 赵勇萍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;之后的日子里，我可能会陆陆续续写一写跟编程技术感悟相关的文章，一来可以梳理一下对技术和工作的思考，二来也可以记录一下技术成长的的过程。&lt;/p&gt;

&lt;p&gt;换个叫法的话，就叫做程序员日记吧。&lt;/p&gt;

&lt;h1&gt;电饼铛&lt;/h1&gt;

&lt;p&gt;今天就从电饼铛说起。&lt;/p&gt;

&lt;p&gt;上周，我家的电饼铛坏了，原因可能是清洗过后线路短路导致的。那个老式电饼铛确实用了好些年，且功能单一，基本上除了开关键，再也没有什么可以按钮的地方了，不过老妈却一直用的很顺手。&lt;/p&gt;

&lt;p&gt;而对我来说，这确实个好消息，终于可以换一个好电饼铛了。于是在网上买了一个七百多的苏泊尔的电饼铛，这一下子感觉高大上了许多，很多内置模式，可以支持煎蛋，煎饼，炸鸡翅等多种模式，对温控的把握也十分精准。&lt;/p&gt;

&lt;p&gt;不过，对于我老妈来说，她并没有显得多兴奋，我将使用说明一一教给她用，但老妈最终只选择一种用法：打开开关，选择自定义模式，一切都靠经验去判断电饼铛的温度和对食材的感觉，其他所有的内置模式，对她老人家来说，好像确实是多余的。&lt;/p&gt;

&lt;p&gt;对此，我有点陷入沉思，总觉得有一种似曾相识的感觉。 仔细思考，其实这种情况在编程过程中屡见不鲜。其实这不就是我们微服务架构中经常会遇到的一种情况么....&lt;/p&gt;

&lt;p&gt;好的，接下来，如果把我和我老妈的上述行为抽象为代码，可以写成如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;老妈做煎蛋：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 *老妈做煎鸡蛋
 */
public class MainApplicaiton{
    /**
     *电饼铛
     */
    @Resource
    private DianBingCheng dianBingCheng;
    /**
     *老妈的判断服务类
     */
    @Resource
    private MotherCheckService matherCheckService;
    /**
     * 老妈的行为服务 
     */

    private MotherBehaviorService MotherBehaviorService;

    public void execute() {
        //打开电饼铛
        MotherBehaviorService.Open(dianBingCheng);
        //检查温度
        matherCheckService.CheckTemperature(dianBingChengAggregate);
        //开始煎鸡蛋
        MotherBehaviorService.fryEggs();
        //检查是否熟了
        matherCheckService.CheckRipe()；
        //完成，关机盛盘
        matherService.complete();
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;我做煎蛋：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MainApplicaiton {
    /**
     * 电饼铛聚合根
     */
     @Resource
     private DianBingChengAggregateRoot dianBingChengAggregate;

     public void execute() {
        //开机
        dianBingChengAggregate.open();
        //煎蛋模式
        dianBingChengAggregate.fryEggs();
        //完成，关机盛盘
        dianBingChengAggregate.complete();
     }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家可以看出这两者的实现区别，我们有时候需要思考一下，我不就是处理一个日常特别简单的事情，一定要引入那么多的服务类么？&lt;/p&gt;

&lt;h1&gt;贫血模型和充血模型&lt;/h1&gt;

&lt;p&gt;可能大家感觉出来了，这两种实现，就是领域驱动设计中典型的贫血模式和充血模式。这里不得不先说一下贫血模型和充血模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;贫血模型是事务脚本模式&lt;/strong&gt;。对于程序员来说，脚本呢肯定是要比写设计说明书要快的多了。比如，我们要设计一个订单流程，包括下单，取消，售后，拆单等情况下的订单流转，那么我们就就会任选一个Service类，写一个方法就能搞定，而这时，原来的那个order类中，就会非常非常的“清爽”，里面全是GET方法和Set方法，没有任何行为。而很多人喜欢给这个order类一个定义，叫OrderDomain，订单领域模型。当然我更喜欢叫这种模型为DB模型，是面向数据库的，而不是面向领域业务的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而充血模型是才是典型的领域模型模式&lt;/strong&gt;。他实现起来相对复杂，但这种复杂也是相对的，还是上面的例子，我们会在Order这个对象中放入响应的动作行为的方法，例如我们更新订单状态不会用setStatus（）这种方法，而会封装类似orderCancel()，orderComplete()的这种业务行为方法，当然这种方式会让这个类略显“复杂”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结一句话，真正的领域模型会把数据和行为聚合在一起，形成聚合根，对外提供基于行为的方法，而非脚本化的增删改查。只有这样才能够更好的对微服务进行拆分。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果仅是贫血模型其实不是对系统架构危害最大的，想我们已经很熟悉的MVC，通过贫血模型也可以写出复杂的高效快捷的系统。&lt;/p&gt;

&lt;p&gt;但是，有一种危害就会很大了：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;就像好多同学用这面向对象的语言，写着面向过程的代码一样，很多同学喜欢用冠以领域驱动设计的噱头，却写着MVC式的“面向数据库编程”， 它最大的问题是你引入了领域模型设计的所有成本，但却没有带来任何一丝的收益&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;只有当你充分使用了面向对象设计来组织复杂业务逻辑之后，才能抵消这种成本。如果将所有行为都写入一个一个的Service类，领域是被割裂的，那最终你会得到一组事务处理脚本，从而错过了领域模型带来的好处，而且当业务足够复杂时，你将会得到一堆爆炸的事务处理脚本。&lt;/p&gt;

&lt;p&gt;此外，你还会发现，&lt;/p&gt;

&lt;p&gt;本来属于一个领域的能力，却被散落在了工程的各个角落。这样一来，根本无法形成一个可复用的能力。&lt;/p&gt;

&lt;p&gt;当然有同学也会提出疑问：“&lt;em&gt;我的业务场景中领域之间其实关系比较紧密，我会经常遇到会触发同时跟不同领域行为相关的业务，在这种情况下，我就通过一个个的Service扩展，这就是一种显而易见的解决方案呀~~&lt;/em&gt; ”&lt;/p&gt;

&lt;p&gt;其实有这种想法的同学，主要是对领域驱动设计理解不深刻的，同时又对传统的MVC框架开发根深蒂固。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其实领域驱动设计早已给出它的最佳实践，那就是领域事件&lt;/strong&gt;。而面向事件的编程思想对于后端来说，是一种非常高效和优秀的思想。通过领域事件，我们可以实现领域之间的解耦，同时也维护了领域模型的独立性和数据一致性。而关于领域事件又是一个很大的话题，以后有机会再聊。&lt;/p&gt;

&lt;h1&gt;思考&lt;/h1&gt;

&lt;p&gt;在我们每个人的大脑里，对于一件事，如果没有概念和理解的话，我们会有意识的躲避那件事，或者用自己熟悉的概念去套用。微服务，DDD，中台这些词汇，恰恰是这样的概念。这是有了这些概念，才让我们不断的努力去学习它，思考他，钻研他。&lt;/p&gt;

&lt;p&gt;在微服务和DDD这波浪潮里，很多同学都想用这些概念来包装自己，就像我面试过的很多候选者，他们中的很多都在简历中写了精通领域驱动设计，同时也能说出一些聚合根，实体，值对象等概念，但是实际落地就变成了贫血模式的代码。&lt;/p&gt;

&lt;p&gt;所以，对于程序员来说，最核心的能力并不是你会几种语言，会几个架构或者几个名词概念，而是理解那些概念并转化成自己的编程思想。&lt;/p&gt;

&lt;p&gt;同时，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;勇于创新和敢于推翻自己的已有认知，也是一名程序员能否有一直前进的动力的前提&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>46636e73e1ef4a498e973f7f3fc4a759</guid>
<title>【云原生 • Docker】用故事给老板讲 Docker 核心原理</title>
<link>https://toutiao.io/k/n0gu9r4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;白话Docker核心原理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Docker是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Docker使用Google公司推出的Go语言进行开发实现，基于操作系统内核中Cgroup(资源控制)、Namespace(资源隔离)与OverlayFS(数据存储)等技术，实现了基于操作系统层面的虚拟化技术。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解的早就理解了这句话核心本质，不理解的给他这么一解释还是云里雾里。那我们先不急于搞懂&lt;code&gt;Docker&lt;/code&gt;是什么，说到&lt;code&gt;Docker&lt;/code&gt;容器，就不得不说下虚拟机(&lt;code&gt;Virtual Machine&lt;/code&gt;)，&lt;code&gt;Docker&lt;/code&gt;容器和虚拟机又有什么区别呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Docker vs 虚拟机&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟机对于我们开发者是个再熟悉不过的概念，比如我们经常使用&lt;code&gt;VMware Workstation&lt;/code&gt;搭建虚拟操作系统部署应用，使用&lt;code&gt;JVM&lt;/code&gt;虚拟机运行&lt;code&gt;Java&lt;/code&gt;应用等，如下图，&lt;strong&gt;「通常使用虚拟机管理器作为中间转换层，可以屏蔽底层操作系统或硬件设备差异」&lt;/strong&gt;，比如上层虚拟机操作系统(&lt;code&gt;Guest OS&lt;/code&gt;)执行程序或&lt;code&gt;Java&lt;/code&gt;程序运行等，&lt;strong&gt;「这个中间件转换层就像翻译家一样，将上层执行的指令解释翻译成下层操作系统对应的指令进行执行」&lt;/strong&gt;。&lt;/p&gt;&lt;img data-ratio=&quot;0.7308730873087309&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb33ewbjgnbpvAvFus7FlbfUUU9gvs6QpoLMZwYEDq7gic24mIRxLw0LNZOONmeiaRKdmVxLQvEkZmbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1111&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如Java世界中吹嘘的&quot;一次编译，到处运行&quot;，&lt;strong&gt;「虚拟机本质上通过中间件转换层屏蔽了底层差异，模拟出一个新环境，实现与平台无关，达到与外界隔离的目的，这就是虚拟机实现虚拟化的核心思想」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从虚拟机架构实现上可以看出，其存在一个很大问题：所有的指令都必须经过虚拟机管理器这个中间转换层翻译解释才能在真实操作系统上运行，这就意味着虚拟机会存在性能损耗。另外，为了模拟一个&lt;code&gt;Linux&lt;/code&gt;环境上运行的应用，需要使用VMware运行部署一个宿主机(&lt;code&gt;Guest OS&lt;/code&gt;)，再在宿主机上运行应用，宿主机本身占用好几个G的存储空间、400-500MB+内存空间，现在微服务架构动不动就是10+、100+个应用组件需要部署，那这些组件都需要做隔离部署使用虚拟机方式无疑是致命的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述说的虚拟机存在性能问题和资源浪费造成了虚拟机对细粒度的环境隔离有点力不从心，而这又与当前流行的微服务架构场景下，系统被拆分成几十、上百个微服务应用组件需要独立部署存在冲突。&lt;code&gt;Docker&lt;/code&gt;推崇的是一种轻量级容器的结构，即一个应用一个容器。所以，Docker一出来就被推向巅峰，那它又是如何搞定虚拟机隔离存在的问题的呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Docker容器核心技术&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Docker&lt;/code&gt;容器中进程是直接运行在底层操作系统上，没有中间转换层，所以也就不存在性能损耗的问题。关键那它是如何做到隔离的呢？&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0333863275039745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb33ewbjgnbpvAvFus7FlbfU5Bdibc67Jmr1k7YJiaeWTlKNmglW6944RNu6QjdNcSx40NsuePZ7qryQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;629&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「这里就引出了支撑&lt;code&gt;Docker&lt;/code&gt;容器的两大内核技术：Namespace和Cgroups（Control Groups）」&lt;/strong&gt;。Namespace主要是用来进行&lt;strong&gt;「资源隔离」&lt;/strong&gt;，对于那些计算型资源，比如&lt;code&gt;CPU&lt;/code&gt;、内存、磁盘IO等不能进行隔离的资源，这时就需要采用&lt;code&gt;Cgroups&lt;/code&gt;进行&lt;strong&gt;「资源限制」&lt;/strong&gt;，防止有些资源消耗较大的容器，将整个物理机器的硬件资源(&lt;code&gt;CPU&lt;/code&gt;, &lt;code&gt;Memory&lt;/code&gt;、磁盘IO等) 占满，进而影响其它进程性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Namespace&lt;/code&gt;和&lt;code&gt;Cgroups&lt;/code&gt;这两个技术都是&lt;code&gt;Linux&lt;/code&gt;内核本身支持的功能，&lt;code&gt;Docker&lt;/code&gt;如果只使用这两大技术也不可能造就出道即巅峰的火热程度，&lt;code&gt;Docker&lt;/code&gt;创新点恰恰是引入镜像概念，并使用联合文件系统(&lt;code&gt;UnionFS&lt;/code&gt;)技术很好的实现了镜像分层，这样就可以将应用部署介质、依赖环境配置文件以及操作系统二进制文件进行分层叠加构建出应用运行时文件系统环境。&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8917631041524847&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb33ewbjgnbpvAvFus7FlbfUzqw3DdsUPP2rr0z3rIycibiaq4r35g6N8RErnPolibH3c3PnJ0jO1ygGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1469&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;镜像包含一个基础镜像(&lt;code&gt;Base Image&lt;/code&gt;)，这个一般包含操作系统介质，比如&lt;code&gt;centos&lt;/code&gt;、&lt;code&gt;debian&lt;/code&gt;，但是它只包括使用的操作系统二进制文件，并没有包括内核相关，所以，它的体积远远小于部署整个操作系统占用的空间，比如一个&lt;code&gt;centos&lt;/code&gt;基础镜像大概只有&lt;code&gt;70-80MB&lt;/code&gt;。另外，镜像分层设计进一步减少存储占用，比如现在100+应用组件都是基于&lt;code&gt;centos&lt;/code&gt;基础镜像部署，实际部署时只需要拉取一份centos基础镜像，就像搭积木一样，将每一层使用的文件进行组合叠加，最终构建出程序运行时完整的目录结构。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;白话核心技术关系&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「&lt;code&gt;Docker&lt;/code&gt;容器技术火热的背后，其实是&lt;code&gt;Namespace&lt;/code&gt;、&lt;code&gt;Cgroups&lt;/code&gt;和&lt;code&gt;UnionFS&lt;/code&gt;三大技术创新的结合，造就出了&lt;code&gt;Docker&lt;/code&gt;这种现象级产品」&lt;/strong&gt;。下面用个比较形象的比喻来帮助你理解三大技术关系：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、正常程序启动时直接运行在操作系统上，使用&lt;code&gt;Docker&lt;/code&gt;启动程序时，也是直接运行在操作系统上，但是&lt;code&gt;Docker&lt;/code&gt;引擎在启动程序时会给程序套一个立方体壳（见下图）；&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.87627365356623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb33ewbjgnbpvAvFus7FlbfULxtEtEbrlR94icIrDy1QQwtictIRRJXV1aDQMZFVYUcaY4A9SibJ4hpwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;687&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、这个立方体壳前后左右四个面使用&lt;code&gt;Namespace&lt;/code&gt;资源隔离技术打造，这样就给&lt;code&gt;Docker&lt;/code&gt;容器中进程和其它进程隔离开来，给容器中进程造成一种运行在一个独立环境中的假象（见下图）；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、这个立方体壳的上面这个面使用&lt;code&gt;Cgroups&lt;/code&gt;资源限制技术打造，避免程序壮大生长出来抢占其它进程的资源，进而影响其它进程性能，这样就给盖盖上加上了一个紧箍咒，再牛逼的程序也会把你死死的限制住（见下图）；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、最后再来看下这个立方体壳剩下的最下面这个面，其采用&lt;code&gt;UnionFS&lt;/code&gt;技术打造，构建出容器中进程运行时文件系统根基。将操作系统二进制指令、依赖配置文件、程序介质等通过镜像分层叠加构建出程序运行时看到的整个文件系统环境；比如宿主机是&lt;code&gt;Debian系统&lt;/code&gt;，但是基础镜像是&lt;code&gt;CentOS环境&lt;/code&gt;，容器中进程看到的是&lt;code&gt;CentOS系统&lt;/code&gt;，而不是&lt;code&gt;Debian系统&lt;/code&gt;，同时将&lt;code&gt;yum install&lt;/code&gt;安装的依赖介质也通过镜像打包进来，容器中进程就不需要关注宿主机上到底有没有安装该依赖介质等等，这样容器中进程看到是一个拥有程序运行时完整介质，并与宿主机操作系统隔离开的独立操作系统（见下图）；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、所以，程序运行在三大核心技术创造的立方体壳壳中，被蒙蔽双眼傻乎乎的以为运行在一个独立计算机环境中，看不到外界程序运行情况，也影响不到外界程序的运行。&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8699186991869918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb33ewbjgnbpvAvFus7FlbfUtUdT8th3FcG6FCXKXQloIF28oJAKdBB8yFeF0h96EOLmTktORwYV8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;如何查看Docker进程在宿主机上的PID？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Docker&lt;/code&gt;容器中的进程是直接运行在宿主机上，可以通过&lt;code&gt;docker inspect container&lt;/code&gt;查看到&lt;code&gt;Docker&lt;/code&gt;容器中进程在宿主机上对应的PID信息（见下图）：&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37018425460636517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb33ewbjgnbpvAvFus7FlbfUeMnWdlKdmicGXxblJbg1Dp9p0jeHMa0hoNSGXOV07u3SrcS1QukCuVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1791&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;宿主机上&lt;code&gt;ps -ef&lt;/code&gt;查看下容器进程信息：&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09461538461538462&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb33ewbjgnbpvAvFus7FlbfULqqiaFeamQgtia4EuqbccibYqlSmiaT76ich3cy8ICicnyvheVZXhPaAky3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1300&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为，这里运行的是一个&lt;code&gt;nginx&lt;/code&gt;容器，所以宿主机上看到对应的是&lt;code&gt;nginx&lt;/code&gt;主进程，同时该进程创建了两个&lt;code&gt;nginx worker&lt;/code&gt;子进程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Docker容器缺陷&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「高性能、轻便是容器相较于虚拟机最大的优势，容器本质上是一种特殊的进程。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，有利就有弊，基于&lt;code&gt;Namespace&lt;/code&gt;的资源隔离和&lt;code&gt;Cgroups&lt;/code&gt;的资源限制都不是那么彻底，因为容器之间底层还是共享使用宿主机的&lt;code&gt;Linux&lt;/code&gt;内核，尽管你可以在容器里使用不同版本的操作系统文件，比如&lt;code&gt;CentOS&lt;/code&gt;或者&lt;code&gt;Ubuntu&lt;/code&gt;，但这并不能改变共享宿主机内核的事实。这意味着，如果你要在&lt;code&gt;Windows&lt;/code&gt;宿主机上运行&lt;code&gt;Linux&lt;/code&gt;容器，或者在低版本的&lt;code&gt;Linux&lt;/code&gt;宿主机上运行高版本的&lt;code&gt;Linux&lt;/code&gt;容器，都是行不通的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，在&lt;code&gt;Linux&lt;/code&gt;内核中，有很多资源和对象是不能被&lt;code&gt;Namespace&lt;/code&gt;化的，最典型的例子就是：时间。这就意味着，如果你的容器中的程序修改了时间，整个宿主机的时间都会被随之修改，这显然不符合用户的预期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，跟&lt;code&gt;Namespace&lt;/code&gt;的情况类似，&lt;code&gt;Cgroups&lt;/code&gt;对资源的限制能力也有很多不完善的地方，这里最常见的是&lt;code&gt;/proc &lt;/code&gt;文件系统的问题。&lt;code&gt;Linux&lt;/code&gt;下的&lt;code&gt;/proc&lt;/code&gt;目录存储的是记录当前内核运行状态的一系列特殊文件，用户可以通过访问这些文件，查看系统以及当前正在运行的进程的信息，比如&lt;code&gt;CPU&lt;/code&gt;使用情况、内存占用率等，这些文件也是&lt;code&gt;top&lt;/code&gt;指令查看系统信息的主要数据来源。但是，你如果在容器里执行&lt;code&gt;top&lt;/code&gt;指令，就会发现，它显示的信息居然是宿主机的&lt;code&gt;CPU&lt;/code&gt;和内存数据，而不是当前容器的数据。造成这个问题的原因就是，Docker引擎在启动进程时直接将宿主机&lt;code&gt;/proc&lt;/code&gt;下很多文件挂载到&lt;code&gt;Docker&lt;/code&gt;容器上。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>939da9846ddac6f63b1dc72ce127c217</guid>
<title>大型 SaaS 系统的数据范围权限设计与实现</title>
<link>https://toutiao.io/k/auix62l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;点击上方“&lt;/span&gt;&lt;span&gt;芋道源码&lt;/span&gt;&lt;span&gt;”，选择“&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247486188&amp;amp;idx=3&amp;amp;sn=f160d91ea23e5113e6077c500a2e30c4&amp;amp;chksm=fa49755dcd3efc4bf4f566fbbbf74c191d0b79f2d3222fd211bc52d80b5ef127f52b1158ed71&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;设为星标&lt;/a&gt;”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;管她前浪，还是后浪？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;能浪的浪，才是好浪！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每天 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;10:33&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 更新文章，每天掉亿点点头发...&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-mpa-template-id=&quot;692363&quot; data-mpa-category=&quot;fav&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;源码精品专栏&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;来源：blog.csdn.net/u011066470/article/details/118003386&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;来源：blog.csdn.net/u011066470/&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;来源：blog.csdn.net/u011066470/article/details/118003386&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;article/details/118003386&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;toB 的系统，除了普通的权限管理之外，往往还需要数据范围权限。本文介绍一种，简单的易实现的 Saas 多租户数据范围权限系统的简单设计与实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一般说权限的时候是在说&lt;strong&gt;「功能权限和数据权限」&lt;/strong&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;功能权限指用&lt;strong&gt;「户登陆系统后能看到什么模块，能看到哪些页面」&lt;/strong&gt; ，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而数据权限指的&lt;strong&gt;「是用户在某个模块里能看到几条数据，能看到哪些数据」&lt;/strong&gt; 。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Boot + MyBatis Plus + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://github.com/YunaiV/ruoyi-vue-pro&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在企业系统中，通过配置用户的功能权限可以解决不同的人分管不同业务的需求，基于RBAC模型，RBAC（Role Based Access Control)模型，它的中文是基于角色的访问控制，主要是将功能组合成角色，再将角色分配给用户，也就是说&lt;strong&gt;「角色是功能的合集。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;企业A一共有12个功能，需要创建100个用户，这些用户中有管财务的、有管人事的、有管销售的等等。如果不引入RBAC模型，我们需要每创建一个用户就要分配一次功能，至少（每个用户只有一个功能）操作100次，如果人数增加到1000甚至10000，并且一个用户可能会有多个功能的时候，操作会非常繁琐，如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7917121046892039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXdF3wYM8iauAmvpfrSeNiabZdMibjudSw967ujl3Qibqweu9ictYVNTg9SVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;917&quot;/&gt;&lt;figcaption&gt;为何要基于RBAC&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过多次操作发现：分配给某些人的功能都是相同的，比如分配给A、B等10个用户的功能都是客户管理、订单管理及供应商管理这几个模块，那是不是可以把这几个功能模块打成一个包整体分给需要的用户呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个包就叫做角色。由于角色和功能的对应关系相对固定，给用户分配权限的时候只分配角色即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1962962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXKLSlxlwVXpnmasjP58ULvAQKG3yicO8D79KrQwd07qbpfNSGmGoXzFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;为何要基于RBAC&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;解耦用户和功能，降低操作错误率；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;降低功能权限分配的繁琐程度。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5544973544973545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXicf9NVU1TCaIKSOKV5vxpuwWSNcRwOvpzeL71QmxPtMjjrAQibPJNv5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;figcaption&gt;为何要基于RBAC&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;功能的粒度从粗到细一般分为：&lt;strong&gt;「模块级-&amp;gt;页面级-&amp;gt;接口级（接口级的功能权限指的是哪个角色能调用哪些接口）。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从后台角度：为了系统安全，代码肯定都会实现到接口级。那我们做粒度选择的意义是什么？当然是为用户降本增效。只是粒度越粗，用户操作越简单，灵活性却越低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们常用的优先级顺序是查看&lt;strong&gt;「详情&amp;gt;查看列表&amp;gt;增加、删除、编辑、其他操作按钮」&lt;/strong&gt; 。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Cloud Alibaba + Gateway + Nacos + RocketMQ + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://github.com/YunaiV/yudao-cloud&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据权限解决的是用户能看到多少数据量和什么数据的问题，例如A和B两个用户都能看到销售模块，但A能看到320条数据，B只能看到100条数据，且A能看到的320条数据中包含着B能看到的100条数据，这些都是由数据权限决定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据权限一般和企业的组织架构相关，而组织架构分为树状和扁平状的（还有更复杂组织架构，此处暂不做说明）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5539647577092511&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBX8R75fg74daT7vsOE4bVWDIqpfKzqVziar6FATdcGcibRETfZnvcaE64Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;figcaption&gt;数据权限和什么有关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「数据权限主要和组织架构有关」&lt;/strong&gt; ，组织架构中树状架构较为复杂，需要统一或者分模块的定义层级间数据共享问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据权限定义过程中如果出现同一结点下的【用户间层级问题（上下级）】需要回到功能权限的【角色定义】去解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「数据权限的控制是通过部门的菜单展示来实现的。」&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户添加时候，选择部门的下拉框&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6886792452830188&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXK8zXKvMmtTBqM52X8e8tFKOYbmLyPC21YSANOsce8oXK8Zw5xEXERA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;部门管理的列表&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5425925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXbDN6mWXKS0wvxa7gsc9A7omzMOabOTUbGxF5V79tD9MPKv4XibtuuXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;部门管理的列表&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;角色管理，新增弹框页面，选择部门的树状菜单&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7085852478839177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXN7pFJq6k8sRaFuwPX1v4eJecfEdItGVPtNEqgrMojv5XIodm0kGpqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;827&quot;/&gt;&lt;figcaption&gt;角色管理&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46111111111111114&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXMHf5gV2JlPRT10eFqk4NSX7ovpKt111yiaHCsZW1gmenGCaicgicyiaRow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46574074074074073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXyv9uxDX4afIjo1LQ2fVMa5Me6Xl9B8j0TWRL39HVy14YHCVqLfDhnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46938775510204084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXhJNQI2hujlBmkPia23xYSnsPB5zd2urqmnOTCXOMLpzHLM3SNRX1feQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1029&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在commonDataService类中的getCurrUserDataDeptIds()方法，获取当前登录用户的部门数据ids列表&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.662962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXfVsND605BqmrpnHUalAFS49icKDQ3nhccaWbXYkUgQblfqwj4XslKsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前登录用户id为超级管理员，则加载全部菜单信息，如下图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2544529262086514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXjDO2qWLQW1JQXnmh7BC38KRDMJjGDCwwu3BXBolHKuaO6sBYkHzT0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前登录用户id不为超级管理员，通过用户id，获取sys_role_dpet,sys_user_role这两张表进行关联（&lt;strong&gt;「已拥有制定部门的权利且未占用」&lt;/strong&gt; ），获取该登录用户所属的部门id&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2462962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXiceLSBdj7UEiasBAME9PhYzllMOLJdPCvLH8w8RMdxG8BG10hjOWaaEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据权限用户已经分配且已经拥有的部门（&lt;strong&gt;「已拥有制定部门的权利且已占用」&lt;/strong&gt; ），&lt;strong&gt;「作用是选择了一个一级部门，那么一级部门所包含的二级部门，三级部门等也要赋值给用户，也就是说拥有的部门下面还有子部门，那么也具有该部门以及子部门的拥有权，使用递归算法全部遍历获得。」&lt;/strong&gt; 如下图所示&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6796296296296296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBX7ILzWuXlGuXJQvMib9Rrn1iacYX4xJVS2eXqjaj3D9dapEmqO3dhYTFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29907407407407405&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBX9wg3jB0X8CvHOv8tqbBtNCcRZoFSH0pkhJfqIrVWIynNGX2u1cdelA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29347826086956524&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXIibscnyicciaHbLuXT9CIQcX6MtLxABBHzmCTx7ZicKKxVfkzocVLUnY2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;736&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;将当前登录用户所拥有的部门id通过逗号进行拼接&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7285429141716567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXBUK8hUfWd5khEOTt5HseyicwLr6ruSJ4lZDlQ2eNXl4UlnebUO8AFzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样调用的是SysDepartController中的depart/list的方法，逻辑见2.3节&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3851851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXdp4a1OUc9afiaXykq5kH0xXuIZVDZMRkzxJJL1HrRqHvhia3O1nL3QcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7408184679958028&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXKpueflzibYmVABZn87B8GcGu0IXrFwcYUcjLtCBOkuVQGbMxz0gCpkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;953&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样调用的是SysDepartController中的depart/list的方法，逻辑见2.3节&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9383490073145245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXPGO8AAjacIrxwgKkwHP85vKnM0PicgEeuuVKe4oZ0CAhjpRiaz0ZticKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;957&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37433155080213903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXc9STbEBDIicN5B86jCZSpRWspzNcSXlptJ4k3ic4cWTKxTXDhGqKCHOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;935&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;例如用户debug用户的角色为操作权限角色，分配部门为开发一部下面的测试部门&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5027777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXeKkrjMDEDY7GNDqlPjCa46pMIzCagjRNKFicCV7cDZfMtXzRvJJESgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用超级管理员，给操作权限角色分配数据权限，这里选择新分配一个开发二部下面的测试部，如下图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5130260521042084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBXfp3C2kg5ibIBwVc60p7cicNwNItp2xzAbI3fsFfrxkBwEWeERxMOdKqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;998&quot;/&gt;&lt;figcaption&gt;数据权限&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用debug用户登录查询&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35555555555555557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdzP4RB0gHjCicFWPBBbuIBX3ZShDaibOW2RHD8DaGckX7ibHjEqjQSgSOxJo6DXPYrDecu2eVVuAtIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;用户登录查询&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于数据范围权限的设计与实现，你有什么好的方案？欢迎留言评论！&lt;/p&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;hr/&gt;&lt;p&gt;欢迎加入我的知识星球，一起探讨架构，交流源码。加入方式，&lt;strong&gt;&lt;span&gt;长按下方二维码噢&lt;/span&gt;&lt;/strong&gt;：&lt;/p&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdCCyC6MQeHl5kNZu4u5Jdqic3MFibq3YUUtnydwWhibCBQmfOUAzRMHv3HyDD6NwsfFvtzx1eEVK1KA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;已在知识星球更新源码解析如下：&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0722222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdCa89KZ4Ls04tTqXvgxWVian1HZ76BOz52l4pkqX0IMicM14rRFyiaO0vQENMOufUhDVVtPiadDdoKjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0324074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdCa89KZ4Ls04tTqXvgxWViaExAeJx1CZeSaJ9qxh0X70s4JGjIVVlT5ZqBGu51YTedMNfO49DKb6g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7212962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdCa89KZ4Ls04tTqXvgxWViaCibrYIXNgebWPd5g7Or9dcToN660aLAEJEhz4wLpBBiaFhejsaGDGd2g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdCa89KZ4Ls04tTqXvgxWVia4qmv743xvlia1HYmqCDPBLpo3HXtw8Hmo76GkGK5wCqvicAKxd9ET3ow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近更新《芋道 SpringBoot 2.X 入门》系列&lt;/span&gt;&lt;span&gt;，已经 101 余篇，覆盖了 &lt;/span&gt;&lt;span&gt;MyBatis、Redis、MongoDB、ES、分库分表、读写分离、SpringMVC、Webflux、权限、WebSocket、Dubbo、RabbitMQ、RocketMQ、Kafka、性能测试等等内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;提供近 3W 行&lt;span&gt;代码&lt;/span&gt;的 SpringBoot 示例，以及超 4W 行代码的电商微服务项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;获取方式：点“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”，关注公众号并回复 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;666&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 领取，更多内容陆续奉上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(167, 167, 167)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(63, 63, 63)&quot; data-style=&quot;letter-spacing: 0.544px; font-size: 16px; color: rgb(63, 63, 63); word-spacing: 1px; line-height: inherit;&quot; class=&quot;js_darkmode__91&quot;&gt;&lt;p data-style=&quot;margin-right: 0.5em; margin-left: 0.5em; font-family: 微软雅黑; white-space: normal; color: rgb(0, 0, 0); letter-spacing: 0px; word-spacing: 2px; text-align: right;&quot; class=&quot;js_darkmode__100&quot; data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(230, 230, 230)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(0, 0, 0)&quot;&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(255, 41, 65)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(255, 41, 65)&quot;&gt;&lt;strong data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(255, 41, 65)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(255, 41, 65)&quot;&gt;文章有帮助的话，在看，转发吧。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;margin-right: 0.5em; margin-left: 0.5em; font-family: 微软雅黑; white-space: normal; color: rgb(0, 0, 0); letter-spacing: 0px; word-spacing: 2px; text-align: right;&quot; class=&quot;js_darkmode__101&quot; data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(230, 230, 230)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(0, 0, 0)&quot;&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(255, 41, 65)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(255, 41, 65)&quot;&gt;&lt;strong data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(255, 41, 65)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(255, 41, 65)&quot;&gt;谢谢支持哟 (*^__^*）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9be1d417e9b9862d22cf37cf34a7796e</guid>
<title>GRPC 是跨语言的，为何偏偏在 go 语言上这么火？</title>
<link>https://toutiao.io/k/5dsfu3s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;span class=&quot;RichText ztext CopyrightRichText-richText css-1g0fqss&quot; options=&quot;[object Object]&quot; itemprop=&quot;text&quot;&gt;&lt;h2 data-first-child=&quot;&quot;&gt;0 前言&lt;/h2&gt;&lt;p data-pid=&quot;Y9BfpoLt&quot;&gt;未来几周想和大家一起开启 grpc 领域的探索之旅. 由于 grpc 涉及的信息量很大，我会拆成多篇内容，每次聚焦于一些小的主题，和大家持续交流探讨. 本文是其中第一篇，会谈及以下内容：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;drtCROZw&quot;&gt;使用 grpc 的背景介绍&lt;/li&gt;&lt;li data-pid=&quot;p-HBgZKm&quot;&gt;展示 grpc-go 的基本用法&lt;/li&gt;&lt;li data-pid=&quot;NoIaE0QF&quot;&gt;grpc-go 服务端源码走读&lt;/li&gt;&lt;li data-pid=&quot;IVp2a1ig&quot;&gt;grpc-go 拦截器的使用介绍&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;HDP6zAcr&quot;&gt;本文内容的目录树结构如下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-b763886b3c06b661a21ca228aa39732c_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3675&quot; data-rawheight=&quot;1771&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-b763886b3c06b661a21ca228aa39732c_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3675&quot; data-rawheight=&quot;1771&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-b763886b3c06b661a21ca228aa39732c_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-b763886b3c06b661a21ca228aa39732c_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;1 背景介绍&lt;/h2&gt;&lt;h2&gt;1.1 rpc&lt;/h2&gt;&lt;p data-pid=&quot;9mqIXO3t&quot;&gt;rpc，全称 remote process call（远程过程调用），是微服务架构下的一种通信模式. 这种通信模式下，一台服务器在调用远程机器的接口时，能够获得像调用本地方法一样的良好体验.&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-eb9c9340449ab6ccd1e68c5ce4e9f320_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1460&quot; data-rawheight=&quot;837&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-eb9c9340449ab6ccd1e68c5ce4e9f320_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1460&quot; data-rawheight=&quot;837&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-eb9c9340449ab6ccd1e68c5ce4e9f320_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-eb9c9340449ab6ccd1e68c5ce4e9f320_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;r5Cjifqc&quot;&gt;rpc 通常对标的是 restful 风格的 http 调用方式，下面开放地聊聊个人眼中 rpc 相较于 http 的优势所在：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;ETiPaoSL&quot;&gt;rpc 调用基于 sdk 方式，调用方法和出入参协议固定，stub 文件本身还能起到接口文档的作用，很大程度上优化了通信双方约定协议达成共识的成本.&lt;/li&gt;&lt;li data-pid=&quot;ulpoQEcH&quot;&gt;rpc 在传输层协议 tcp 基础之上，可以由实现框架自定义填充应用层协议细节，理论上存在着更高的上限&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;z85JfVsN&quot;&gt;事物往往具有多面性，一些优点在转换视角后可能也会成为对应的劣势，因此从另一个角度看，rpc 相较于 http 存在如下缺点：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;ZcNmW3C6&quot;&gt;基于 sdk 方式调用，灵活度低、开发成本高，更多地适合用于系统内部模块间的通信交互，不适合对外&lt;/li&gt;&lt;li data-pid=&quot;OMb5Gu5m&quot;&gt;用户自定义实现应用层协议，下限水平也很不稳定&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;1.2 grpc-go&lt;/h2&gt;&lt;p data-pid=&quot;JNioOJ2L&quot;&gt;rpc 领域中的一座大山是 google 的开源框架 grpc，框架本身基于 C++ 实现，但对应于几个主流语言也有相应的实现版本.&lt;/p&gt;&lt;p data-pid=&quot;MtZD1Mvb&quot;&gt;我的主语言是 golang，因此，今天我会和大家一起聊聊 grpc-go 的有关内容.&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-3abb9fd48431923b18274c09237cf63f_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1941&quot; data-rawheight=&quot;1232&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-3abb9fd48431923b18274c09237cf63f_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1941&quot; data-rawheight=&quot;1232&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-3abb9fd48431923b18274c09237cf63f_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-3abb9fd48431923b18274c09237cf63f_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;60Okuagk&quot;&gt;grpc-go 是基于 go 语言实现的 grpc 框架，要知道 go 语言本身也是 google 实现的，因此 golang 和 grpc 都是 google 的亲儿子，两者的契合度也是没得说，敬请诸位放心食用。&lt;/p&gt;&lt;p data-pid=&quot;o3VyiVso&quot;&gt;grpc-go 以 HTTP2 作为应用层协议，使用 protobuf （下文可能简称 pb）作为数据序列化协议以及接口定义语言。&lt;/p&gt;&lt;p data-pid=&quot;Ztk1UPcO&quot;&gt;protobuf 开源地址为：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/protocolbuffers/protobuf-go&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/protocolbuff&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ers/protobuf-go&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; 后续我们会单开一个篇章，和大家聊聊 protobuf 的底层实现原理，此处暂且按下不表.&lt;/p&gt;&lt;p data-pid=&quot;RxNkRVH5&quot;&gt;最后，晒一下 grpc-go 项目的开源地址：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/grpc/grpc-go&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/grpc/grpc-go&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-3e300a32a4b90efed453efecc883dc48_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2858&quot; data-rawheight=&quot;1613&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-3e300a32a4b90efed453efecc883dc48_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2858&quot; data-rawheight=&quot;1613&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-3e300a32a4b90efed453efecc883dc48_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-3e300a32a4b90efed453efecc883dc48_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;2 grpc-go 使用教程&lt;/h2&gt;&lt;p data-pid=&quot;YDT0a7Lz&quot;&gt;开扒框架源码之前，首先向大家简单介绍一下 grpc-go 的基本使用方法.&lt;/p&gt;&lt;h2&gt;2.1 前置准备&lt;/h2&gt;&lt;p data-pid=&quot;Qal7XR1K&quot;&gt;首先需要把依赖的 grpc-go 插件提前安装好，分为如下几步：&lt;/p&gt;&lt;p data-pid=&quot;XjysOwlV&quot;&gt;&lt;b&gt;（1）安装 grpc&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;go get google.golang.org/grpc@latest&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;GG80BNqn&quot;&gt;&lt;b&gt;（2）安装 protocol buffer&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;5TcT8IN0&quot;&gt;根据操作系统型号，下载安装好对应版本的 protobuf 应用：&lt;/p&gt;&lt;p data-pid=&quot;w4nqSsVc&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/google/protobuf/releases&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/google/proto&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;buf/releases&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-pid=&quot;uz4zUb1-&quot;&gt;需要将 protobuf 执行文件所在的目录添加到环境变量 $PATH 当中.&lt;/p&gt;&lt;p data-pid=&quot;XpPl86zG&quot;&gt;安装完成后，可以通过查看 protobuf 版本指令，校验安装是否成功&lt;/p&gt;&lt;p data-pid=&quot;sHVpq2nw&quot;&gt;&lt;b&gt;（3）安装 protobuf -&amp;gt; pb.go 插件&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;y9qdaeOQ&quot;&gt;该插件的作用是，能够基于 .proto 文件一键生成 _pb.go 文件，对应内容为通信请求/响应参数的对象模型.&lt;/p&gt;&lt;p data-pid=&quot;scIzhNav&quot;&gt;go install 指令默认会将插件安装到 $GOPATH/bin 目录下. 需要确保 $GOPATH/bin 路径有被添加到环境路径 $PATH 当中.&lt;/p&gt;&lt;p data-pid=&quot;v0LAY5lN&quot;&gt;安装完成后，可以通过查看插件版本指令，校验安装是否成功&lt;/p&gt;&lt;p data-pid=&quot;e7SPYyNj&quot;&gt;&lt;b&gt;（4）安装 protobuf -&amp;gt; grpc.pb.go 插件&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;W9NkmAt0&quot;&gt;该插件的作用是，能够基于 .proto 文件生成 _grpc.pb.go，对应内容为通信服务框架代码.&lt;/p&gt;&lt;p data-pid=&quot;Qo4-8wtd&quot;&gt;安装完成后，可以通过查看插件版本指令，校验安装是否成功&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;protoc-gen-go-grpc --version&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;2.2 pb 桩文件&lt;/h2&gt;&lt;p data-pid=&quot;XPDmSvi_&quot;&gt;&lt;b&gt;（1）编写 protobuf 文件&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;syntax = &quot;proto3&quot;; // 固定语法前缀


option go_package = &quot;.&quot;;  // 指定生成的Go代码在你项目中的导入路径


package pb; // 包名


// 定义服务
service HelloService {
    // SayHello 方法
    rpc SayHello (HelloReq) returns (HelloResp) {}
}


// 请求消息
message HelloReq {
    string name = 1;
}


// 响应消息
message HelloResp {
    string reply = 1
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;z7p4d6t3&quot;&gt;该文件以 .proto 作为后缀，扮演着 grpc 客户端与服务端通信交互的接口定义语言（DDL）的角色.&lt;/p&gt;&lt;p data-pid=&quot;xo9rvJux&quot;&gt;protobuf 的细节内容与底层原理，后续我们单开章节再作介绍，此处能理解其基本用法即可.&lt;/p&gt;&lt;p data-pid=&quot;ZVyjXavb&quot;&gt;上述内容中，抛开前置的固定语法标识外，分为三个核心部分：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;O7U8R2M7&quot;&gt;定义业务处理服务 HelloService，声明业务方法的名称（SayHello）以及出入参协议（HelloReq/HelloResp）&lt;/li&gt;&lt;li data-pid=&quot;s0ePQKto&quot;&gt;遵循 protobuf 的风格，分别声明出入参的类型定义：HelloReq 和 HelloResp，其中分别包含了字符串类型的成员字段 name 和 reply&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;C17cffEe&quot;&gt;&lt;b&gt;（2）生成 pb.go 文件&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;SMpx_9lO&quot;&gt;通过使用插件，可以在 .proto 文件基础上，一键生成对应的 go 代码.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;protoc --go_out=. --go-grpc_out=. pb/hello.proto&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;owY77tVY&quot;&gt;--go_out：指定 pb.go 文件的生成位置&lt;/p&gt;&lt;p data-pid=&quot;R_JpV6Uc&quot;&gt;--go-grpc_out：指定 grpc.pb.go 文件的生成位置&lt;/p&gt;&lt;p data-pid=&quot;8R8rYpZO&quot;&gt;pb/hello.proto：这是指定了 .proto 文件的所在位置&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;7kmJPfxF&quot;&gt;执行上述指令后，会生成 pb.go 和 grpc.pb.go 两个文件.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// ...
package proto


import (
    protoreflect &quot;google.golang.org/protobuf/reflect/protoreflect&quot;
    protoimpl &quot;google.golang.org/protobuf/runtime/protoimpl&quot;
    reflect &quot;reflect&quot;
    sync &quot;sync&quot;
)


// ...
// 请求消息
type HelloReq struct {
    state         protoimpl.MessageState
    sizeCache     protoimpl.SizeCache
    unknownFields protoimpl.UnknownFields
    Name string `protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`
    Age  int32  `protobuf:&quot;varint,2,opt,name=age,proto3&quot; json:&quot;age,omitempty&quot;`
}


// ...
// 响应消息
type HelloResp struct {
    state         protoimpl.MessageState
    sizeCache     protoimpl.SizeCache
    unknownFields protoimpl.UnknownFields
    
    Reply string `protobuf:&quot;bytes,1,opt,name=reply,proto3&quot; json:&quot;reply,omitempty&quot;`
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;KUcGJe9-&quot;&gt;上述代码展示了 pb.go 文件中的内容，核心是基于 .proto 定义的出入参协议，生成对应的 golang 类定义代码.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;package proto


import (
    context &quot;context&quot;
    grpc &quot;google.golang.org/grpc&quot;
    codes &quot;google.golang.org/grpc/codes&quot;
    status &quot;google.golang.org/grpc/status&quot;
)


// 基于 .proto 文件生成的客户端框架代码
// 客户端 interface
type HelloServiceClient interface {
    // SayHello 方法
    SayHello(ctx context.Context, in *HelloReq, opts ...grpc.CallOption) (*HelloResp, error)
}


// 客户端实现类
type helloServiceClient struct {
    cc grpc.ClientConnInterface
}


// 客户端构造器函数
func NewHelloServiceClient(cc grpc.ClientConnInterface) HelloServiceClient {
    return &amp;amp;helloServiceClient{cc}
}


// 客户端请求入口
func (c *helloServiceClient) SayHello(ctx context.Context, in *HelloReq, opts ...grpc.CallOption) (*HelloResp, error) {
    out := new(HelloResp)
    err := c.cc.Invoke(ctx, &quot;/pb.HelloService/SayHello&quot;, in, out, opts...)
    if err != nil {
        return nil, err
    }
    return out, nil
}


// 服务端注册入口
func RegisterHelloServiceServer(s grpc.ServiceRegistrar, srv HelloServiceServer) {
    s.RegisterService(&amp;amp;HelloService_ServiceDesc, srv)
}


// 服务端业务方法框架代码
func _HelloService_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
    in := new(HelloReq)
    if err := dec(in); err != nil {
        return nil, err
    }
    if interceptor == nil {
        return srv.(HelloServiceServer).SayHello(ctx, in)
    }
    info := &amp;amp;grpc.UnaryServerInfo{
        Server:     srv,
        FullMethod: &quot;/pb.HelloService/SayHello&quot;,
    }
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {
        return srv.(HelloServiceServer).SayHello(ctx, req.(*HelloReq))
    }
    return interceptor(ctx, in, info, handler)
}


// 服务端业务处理服务描述符
var HelloService_ServiceDesc = grpc.ServiceDesc{
    ServiceName: &quot;pb.HelloService&quot;,
    HandlerType: (*HelloServiceServer)(nil),
    Methods: []grpc.MethodDesc{
        {
            MethodName: &quot;SayHello&quot;,
            Handler:    _HelloService_SayHello_Handler,
        },
    },
    Streams:  []grpc.StreamDesc{},
    Metadata: &quot;proto/hello.proto&quot;,
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;E4uVDA2y&quot;&gt;上述代码展示了 grpc.pb.go 文件中的内容，核心内容包括：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;8HP7tua0&quot;&gt;基于 .proto 文件生成了客户端的桩代码，后续作为用户使用 grpc 客户端模块的 sdk 入口.&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-d34de5d04c0829c1d207f3cd94bd2cf3_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1720&quot; data-rawheight=&quot;211&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-d34de5d04c0829c1d207f3cd94bd2cf3_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1720&quot; data-rawheight=&quot;211&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-d34de5d04c0829c1d207f3cd94bd2cf3_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-d34de5d04c0829c1d207f3cd94bd2cf3_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;OnUDwz2h&quot;&gt;基于 .proto 文件生成了服务端的服务注册桩代码，后续作为用户使用 grpc 服务端模块的 sdk 入口&lt;/li&gt;&lt;li data-pid=&quot;5Ptu3OsJ&quot;&gt;基于 .proto 文件生成了业务处理服务（pb.HelloService）的描述符，每个描述符内部会建立基于方法名（SayHello）到具体处理函数（_HelloService_SayHello_Handler）的映射关系&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;2.3 服务端&lt;/h2&gt;&lt;p data-pid=&quot;G3k4oHQC&quot;&gt;服务端启动代码示例如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;package main


import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;net&quot;


    &quot;github.com/grpc_demo/proto&quot;


    &quot;google.golang.org/grpc&quot;
)


// 业务处理服务
type HelloService struct {
    proto.UnimplementedHelloServiceServer
}


// 实现具体的业务方法逻辑
func (s *HelloService) SayHello(ctx context.Context, req *proto.HelloReq) (*proto.HelloResp, error) {
    return &amp;amp;proto.HelloResp{
        Reply: fmt.Sprintf(&quot;hello name: %s&quot;, req.Name),
    }, nil
}


func main() {
    // 创建 tcp 端口监听器
    listener, err := net.Listen(&quot;tcp&quot;, &quot;:8093&quot;)
    if err != nil {
        panic(err)
    }


    // 创建 grpc server
    server := grpc.NewServer()
    // 将自定义的业务处理服务注册到 grpc server 中
    proto.RegisterHelloServiceServer(server, &amp;amp;HelloService{})
    // 运行 grpc server
    if err := server.Serve(listener); err != nil {
        panic(err)
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li data-pid=&quot;DkExnJCy&quot;&gt;预声明业务处理服务 HelloService，实现好桩文件中定义的业务处理方法 SayHello&lt;/li&gt;&lt;li data-pid=&quot;JysrmsyC&quot;&gt;调用 net.Listen 方法，创建 tcp 端口监听器&lt;/li&gt;&lt;li data-pid=&quot;lsZLaGWm&quot;&gt;调用 grpc.NewServer 方法，创建一个 grpc server 对象&lt;/li&gt;&lt;li data-pid=&quot;_JC00S7e&quot;&gt;调用桩文件中预生成好的注册方法 proto.RegisterHelloServiceServer，将 HelloService 注册到 grpc server 对象当中&lt;/li&gt;&lt;li data-pid=&quot;m-8NouSN&quot;&gt;运行 server.Serve 方法，监听指定的端口，真正启动 grpc server，&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;2.4 客户端&lt;/h2&gt;&lt;p data-pid=&quot;D_lTQPoB&quot;&gt;客户端启动代码示例如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import (
    &quot;context&quot;
    &quot;fmt&quot;


    &quot;github.com/grpc_demo/proto&quot;


    &quot;google.golang.org/grpc&quot;
    &quot;google.golang.org/grpc/credentials/insecure&quot;
)


func main() {
    // 通过指定地址，建立与 grpc 服务端的连接
    conn, err := grpc.Dial(&quot;localhost:8093&quot;, grpc.WithTransportCredentials(insecure.NewCredentials()))
    // ...
    // 调用 .grpc.pb.go 文件中预生成好的客户端构造器方法，创建 grpc 客户端
    client := proto.NewHelloServiceClient(conn)
  
    // 调用 .grpc.pb.go 文件预生成好的客户端请求方法，使用 .pb.go 文件中预生成好的请求参数作为入参，向 grpc 服务端发起请求
    resp, err := client.SayHello(context.Background(), &amp;amp;proto.HelloReq{
        Name: &quot;xiaoxuxiansheng&quot;,
    })
    // ...
    // 打印取得的响应参数
    fmt.Printf(&quot;resp: %+v&quot;, resp)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;ZLXz77Yk&quot;&gt;客户端代码中完成的核心步骤包括：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;u-CLfygP&quot;&gt;调用 grpc.Dial 方法，与指定地址的 grpc 服务端建立连接&lt;/li&gt;&lt;li data-pid=&quot;vDyP8QeY&quot;&gt;调用桩文件中的方法 proto.NewHelloServiceClient，创建 pb 文件预声明好的 grpc 客户端对象&lt;/li&gt;&lt;li data-pid=&quot;AQy5ogUI&quot;&gt;调用 client.SayHello 方法，发送 grpc 请求，并处理响应结果&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;3 服务端&lt;/h2&gt;&lt;h2&gt;3.1 核心数据结构&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-10c9b2d942978a3a687453e08cbf841d_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3812&quot; data-rawheight=&quot;987&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pica.zhimg.com/v2-10c9b2d942978a3a687453e08cbf841d_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3812&quot; data-rawheight=&quot;987&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pica.zhimg.com/v2-10c9b2d942978a3a687453e08cbf841d_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-10c9b2d942978a3a687453e08cbf841d_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;1NUZFTy8&quot;&gt;在 grpc 服务端领域，自上而下有着三个层次分明的结构：server-&amp;gt;service-&amp;gt;method&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;O-sMdbpD&quot;&gt;最高级别是 server，是对整个 grpc 服务端的抽象&lt;/li&gt;&lt;li data-pid=&quot;mQhdUwc2&quot;&gt;一个 server 下可以注册挂载多个业务服务 service&lt;/li&gt;&lt;li data-pid=&quot;iZxww1Pd&quot;&gt;一个 service 下存在多个业务处理方法 method&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;AgCi3Dkv&quot;&gt;&lt;b&gt;（1）server&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;type Server struct {
    // 配置项
    opts serverOptions
    // 互斥锁保证并发安全
    mu  sync.Mutex 
    // tcp 端口监听器池
    lis map[net.Listener]bool
    // ...
    // 连接池
    conns    map[string]map[transport.ServerTransport]bool
    serve    bool
    cv       *sync.Cond          
    // 业务服务映射管理  
    services map[string]*serviceInfo // service name -&amp;gt; service info
    // ...
    serveWG            sync.WaitGroup 
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;DGG7TDU8&quot;&gt;Server 类是对 grpc 服务端的代码实现，其中通过一个名为 services 的 map，记录了由服务名到具体业务服务模块的映射关系.&lt;/p&gt;&lt;p data-pid=&quot;GK3CSu1x&quot;&gt;&lt;b&gt;（2）serviceInfo&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;type serviceInfo struct {
    // 业务服务类
    serviceImpl interface{
    // 业务方法映射管理  
    methods     map[string]*MethodDesc
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;vQGWwPCS&quot;&gt;serviceInfo 是某一个具体的业务服务模块，其中通过一个名为 methods 的 map 记录了由方法名到具体方法的映射关系.&lt;/p&gt;&lt;p data-pid=&quot;SuTC4J43&quot;&gt;&lt;b&gt;（3）MethodDesc&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;type MethodDesc struct {
    MethodName string
    Handler    methodHandler
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;6ZaJranS&quot;&gt;MethodDesc 是对方法的封装，其中的字段 Handler 是真正的业务处理方法.&lt;/p&gt;&lt;p data-pid=&quot;oBqHShas&quot;&gt;&lt;b&gt;（4）methodHandler&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;type methodHandler func(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor UnaryServerInterceptor) (interface{}, error)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;kMLKqYo5&quot;&gt;methodsHandler 是业务处理方法的类型，其中几个关键入参的含义分别是：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;bhgmOzjm&quot;&gt;srv：业务处理方法从属的业务服务模块&lt;/li&gt;&lt;li data-pid=&quot;CzcADPK5&quot;&gt;dec：进行入参 req 反序列化的闭包函数&lt;/li&gt;&lt;li data-pid=&quot;p_Lx4GX2&quot;&gt;interceptor：业务处理方法外部包裹的拦截器方法&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;3.2 创建 server&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func NewServer(opt ...ServerOption) *Server {
    opts := defaultServerOptions
    for _, o := range extraServerOptions {
        o.apply(&amp;amp;opts)
    }
    for _, o := range opt {
        o.apply(&amp;amp;opts)
    }
    s := &amp;amp;Server{
        lis:      make(map[net.Listener]bool),
        opts:     opts,
        conns:    make(map[string]map[transport.ServerTransport]bool),
        services: make(map[string]*serviceInfo),
        quit:     grpcsync.NewEvent(),
        done:     grpcsync.NewEvent(),
        czData:   new(channelzData),
    }
    chainUnaryServerInterceptors(s)
    //...
    s.cv = sync.NewCond(&amp;amp;s.mu)
    // ...   
    return s
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;TR2ZZNXg&quot;&gt;grpc.NewServer 方法中会创建 server 实例，并调用 chainUnaryServerInterceptors 方法，将一系列拦截器 interceptor 成链，并注入到 ServerOption 当中. 有关拦截器的内容，放在本文第 4 章再作展开.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func chainUnaryServerInterceptors(s *Server) {


    interceptors := s.opts.chainUnaryInts
    if s.opts.unaryInt != nil {
        interceptors = append([]UnaryServerInterceptor{s.opts.unaryInt}, s.opts.chainUnaryInts...)
    }


    var chainedInt UnaryServerInterceptor
    if len(interceptors) == 0 {
        chainedInt = nil
    } else if len(interceptors) == 1 {
        chainedInt = interceptors[0]
    } else {
        chainedInt = chainUnaryInterceptors(interceptors)
    }
    
    s.opts.unaryInt = chainedInt
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;3.3 注册 service&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-4539ddc98cad05e360cdace864b47309_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1517&quot; data-rawheight=&quot;217&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-4539ddc98cad05e360cdace864b47309_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1517&quot; data-rawheight=&quot;217&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-4539ddc98cad05e360cdace864b47309_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-4539ddc98cad05e360cdace864b47309_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;SsIll62M&quot;&gt;创建好 grpc server 后，接下来通过使用桩代码中预生成好的 RegisterXXXServer 方法，业务处理服务 service 模块注入到 server 当中.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func RegisterHelloServiceServer(s grpc.ServiceRegistrar, srv HelloServiceServer) {
    s.RegisterService(&amp;amp;HelloService_ServiceDesc, srv)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (s *Server) RegisterService(sd *ServiceDesc, ss interface{}) {
    // ...
    s.register(sd, ss)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (s *Server) register(sd *ServiceDesc, ss interface{}) {
    s.mu.Lock()
    defer s.mu.Unlock()
    // ...
    info := &amp;amp;serviceInfo{
        serviceImpl: ss,
        methods:     make(map[string]*MethodDesc),
        streams:     make(map[string]*StreamDesc),
        mdata:       sd.Metadata,
    }
    for i := range sd.Methods {
        d := &amp;amp;sd.Methods[i]
        info.methods[d.MethodName] = d
    }
    // ...
    s.services[sd.ServiceName] = info
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;hFoBgKXi&quot;&gt;注册过程会经历 RegisterHelloServiceServer-&amp;gt;Server.RegisterService -&amp;gt; Server.register 的调用链路，把 service 的所有方法注册到 serviceInfo 的 methods map 当中，然后将 service 封装到 serviceInfo 实例中，注册到 server 的 services map 当中&lt;/p&gt;&lt;h2&gt;3.4 运行 server&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (s *Server) Serve(lis net.Listener) error {
    // ...


    var tempDelay time.Duration // how long to sleep on accept failure
    for {
        rawConn, err := lis.Accept()
        if err != nil {
            // ...
        }
        // ...
        s.serveWG.Add(1)
        go func() {
            s.handleRawConn(lis.Addr().String(), rawConn)
            s.serveWG.Done()
        }()
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pica.zhimg.com/50/v2-3f4fbcb65c1607ae613bcba33b515df2_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;938&quot; data-rawheight=&quot;1115&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-3f4fbcb65c1607ae613bcba33b515df2_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;938&quot; data-rawheight=&quot;1115&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-3f4fbcb65c1607ae613bcba33b515df2_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pica.zhimg.com/50/v2-3f4fbcb65c1607ae613bcba33b515df2_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;qI0Mw1TP&quot;&gt;grpc server 运行的流程，核心是基于 for 循环实现的主动轮询模型，每轮会通过调用 net.Listener.Accept 方法，基于 IO 多路复用 epoll 方式，阻塞等待 grpc 请求的到达.&lt;/p&gt;&lt;p data-pid=&quot;4SM0JCn0&quot;&gt;每当有新的连接到达后，服务端会开启一个 goroutine，调用对应的 Server.handleRawConn 方法对请求进行处理.&lt;/p&gt;&lt;h2&gt;3.5 处理请求&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (s *Server) handleRawConn(lisAddr string, rawConn net.Conn) {
    // ...
    st := s.newHTTP2Transport(rawConn)
    // ...
    go func() {
        s.serveStreams(st)
        s.removeConn(lisAddr, st)
    }()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-e1e467b062fa6d4999ea15f874684817_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1657&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-e1e467b062fa6d4999ea15f874684817_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1657&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-e1e467b062fa6d4999ea15f874684817_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-e1e467b062fa6d4999ea15f874684817_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;MQh0D0m1&quot;&gt;在 Server.handleRawConn 方法中，会基于原始的 net.Conn 封装生成一个 HTTP2Transport，然后开启 goroutine 调用 Server.serveStream 方法处理请求.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (s *Server) serveStreams(st transport.ServerTransport) {
    var wg sync.WaitGroup


    var roundRobinCounter uint32
    st.HandleStreams(func(stream *transport.Stream) {
        go func() {
            defer wg.Done()
            s.handleStream(st, stream, s.traceInfo(st, stream))
        }()
    }, func(ctx context.Context, method string) context.Context {
        // ...
    })
    wg.Wait()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) {
    sm := stream.Method()
    // ...
    pos := strings.LastIndex(sm, &quot;/&quot;)
    
    service := sm[:pos]
    method := sm[pos+1:]


    srv, knownService := s.services[service]
    if knownService {
        if md, ok := srv.methods[method]; ok {
            s.processUnaryRPC(t, stream, srv, md, trInfo)
            return
        }
        if sd, ok := srv.streams[method]; ok {
            s.processStreamingRPC(t, stream, srv, sd, trInfo)
            return
        }
    }
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, info *serviceInfo, md *MethodDesc, trInfo *traceInfo) (err error) {
    // ...
    d, err := recvAndDecompress(&amp;amp;parser{r: stream}, stream, dc, s.opts.maxReceiveMessageSize, payInfo, decomp)
    // ...
    df := func(v interface{}) error {
        if err := s.getCodec(stream.ContentSubtype()).Unmarshal(d, v); err != nil {
           // ...
        }
        // ...
    }
    ctx := NewContextWithServerTransportStream(stream.Context(), stream)
    reply, appErr := md.Handler(info.serviceImpl, ctx, df, s.opts.unaryInt)
    // ...


    if err := s.sendResponse(t, stream, reply, cp, opts, comp); err != nil {
        // ...
    }
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-c220c0e7ae720c5cc0d9cb3027125742_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2335&quot; data-rawheight=&quot;998&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-c220c0e7ae720c5cc0d9cb3027125742_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2335&quot; data-rawheight=&quot;998&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-c220c0e7ae720c5cc0d9cb3027125742_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-c220c0e7ae720c5cc0d9cb3027125742_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;VC_waGR5&quot;&gt;接下来一连建立了 Server.serveStreams -&amp;gt; http2Server.HandleStreams -&amp;gt; http2Server.operateHeaders -&amp;gt; http2Server.handleStream -&amp;gt; Server.processUnaryRPC 的方法调用链：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;u5F5RwxC&quot;&gt;在 Server.handleStream 方法中，会拆解来自客户端的请求路径 ${service}/${method}，通过&quot;/&quot; 前段得到 service 名称，通过 &quot;/&quot; 后端得到 method 名称，并分别映射到对应的业务服务和业务方法&lt;/li&gt;&lt;li data-pid=&quot;KdLV8eM7&quot;&gt;在 Server.processUnaryRPC 方法中，会通过 recvAndDecompress 读取到请求内容字节流，然后通过闭包函数 df 封装好反序列请求参数的逻辑，继而调用 md.Handler 方法处理请求，最终通过 Server.sendResponse 方法将响应结果进行返回&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func _HelloService_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
    in := new(HelloReq)
    if err := dec(in); err != nil {
        return nil, err
    }
    if interceptor == nil {
        return srv.(HelloServiceServer).SayHello(ctx, in)
    }
    info := &amp;amp;grpc.UnaryServerInfo{
        Server:     srv,
        FullMethod: &quot;/pb.HelloService/SayHello&quot;,
    }
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {
        return srv.(HelloServiceServer).SayHello(ctx, req.(*HelloReq))
    }
    return interceptor(ctx, in, info, handler)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;lMsjAA6O&quot;&gt;以本文介绍的 helloService 为例，客户端调用 SayHello 方法后，服务端对应的 md.Handler 正是 .proto 文件生成的位于 .grpc.pb.go 文件中的桩方法 _HelloService_SayHello_Handler.&lt;/p&gt;&lt;p data-pid=&quot;Iyk5zb3X&quot;&gt;在该桩方法内部中，包含的执行步骤如下：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;VkWYdMTc&quot;&gt;调用闭包函数 dec，将请求内容反序列化到请求入参 in 当中&lt;/li&gt;&lt;li data-pid=&quot;Qjzsrpjy&quot;&gt;将业务处理方法 HelloServiceServer.SayHello 闭包封装到一个 UnaryHandler 当中&lt;/li&gt;&lt;li data-pid=&quot;473aoFI-&quot;&gt;调用 intercetor 方法，分别执行拦截器和 handler 的处理逻辑&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;4 拦截器&lt;/h2&gt;&lt;p data-pid=&quot;40Rcc3Qe&quot;&gt;有关 grpc 中拦截器 interceptor 部分的内容理解起来比较费脑，我们单开一章来展开聊聊.&lt;/p&gt;&lt;h2&gt;4.1 原理介绍&lt;/h2&gt;&lt;p data-pid=&quot;KbSWoJyW&quot;&gt;拦截器的作用，是在执行核心业务方法的前后，创造出一个统一的切片，来执行所有业务方法锁共有的通用逻辑. 此外，我们还能够通过这部分通用逻辑的执行结果，来判断是否需要熔断当前的执行链路，以起到所谓的”拦截“效果.&lt;/p&gt;&lt;p data-pid=&quot;gBAtAiBa&quot;&gt;有关 grpc 拦截器的内容，其实和 gin 框架中的 handlersChain 是异曲同工的. 在我之前分享的文章 ”解析 Gin 框架底层原理“ 的第 5 章内容中有作详细介绍，大家不妨引用对比，以此来触类旁通，加深理解.&lt;/p&gt;&lt;p data-pid=&quot;B1hbuuGf&quot;&gt;下面我们看看 grpc 中对于一个拦截器函数的具体定义：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;type UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;8IX9P85q&quot;&gt;其中几个入参的含义分别为：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;TnfhJt2a&quot;&gt;req：业务处理方法的请求参数&lt;/li&gt;&lt;li data-pid=&quot;6NsTCzWs&quot;&gt;info：当前所属的业务服务 service&lt;/li&gt;&lt;li data-pid=&quot;4CrtNyUn&quot;&gt;handler：真正的业务处理方法&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;2X_xWy7a&quot;&gt;因此一个拦截器函数的使用模式应该是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;var myInterceptor1 = func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
    // 前处理校验
    if err := preLogicCheck();err != nil{
       // 前处理校验不通过，则拦截，不调用业务方法直接返回
       return nil,err 
    }
    
     // 前处理校验通过，正常调用业务方法
     resp, err = handle(ctx,req)
     if err != nil{
         return nil,err 
     }
     
      // 后置处理校验
      if err := postLogicCheck();err != nil{
         // 后置处理校验不通过，则拦截结果，包装错误返回
         return nil,err 
      }
      
      // 正常返回结果
      return resp,nil 
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;4.2 拦截器链&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pica.zhimg.com/50/v2-3cf5229939d702ea9ecd39d915c60730_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1285&quot; data-rawheight=&quot;909&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-3cf5229939d702ea9ecd39d915c60730_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1285&quot; data-rawheight=&quot;909&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-3cf5229939d702ea9ecd39d915c60730_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pica.zhimg.com/50/v2-3cf5229939d702ea9ecd39d915c60730_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func chainUnaryInterceptors(interceptors []UnaryServerInterceptor) UnaryServerInterceptor {
    return func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (interface{}, error) {
        return interceptors[0](ctx, req, info, getChainUnaryHandler(interceptors, 0, info, handler))
    }
}


func getChainUnaryHandler(interceptors []UnaryServerInterceptor, curr int, info *UnaryServerInfo, finalHandler UnaryHandler) UnaryHandler {
    if curr == len(interceptors)-1 {
        return finalHandler
    }
    return func(ctx context.Context, req interface{}) (interface{}, error) {
        return interceptors[curr+1](ctx, req, info, getChainUnaryHandler(interceptors, curr+1, info, finalHandler))
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;wstaPd04&quot;&gt;首先，chainUnaryInterceptors 方法会将一系列拦截器 interceptor 成链，并返回首枚interceptor 供 ServerOption 接收设置.&lt;/p&gt;&lt;p data-pid=&quot;eK9gLOfN&quot;&gt;其中，拦截器成链的关键在于 getChainUnaryHandler 方法中，其中会闭包调用拦截器数组的首枚拦截器函数，接下来依次用下一枚拦截器对业务方法 handler 进行包裹，封装成一个新的 ”handler“ 供当前拦截器使用.&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pica.zhimg.com/50/v2-71a5d1eadee67d7a730eda67e24182a4_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2107&quot; data-rawheight=&quot;969&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-71a5d1eadee67d7a730eda67e24182a4_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2107&quot; data-rawheight=&quot;969&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-71a5d1eadee67d7a730eda67e24182a4_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pica.zhimg.com/50/v2-71a5d1eadee67d7a730eda67e24182a4_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;4.3 操作实践&lt;/h2&gt;&lt;p data-pid=&quot;zNuv36TS&quot;&gt;下面展示一下 grpc 拦截器链的实操例子.&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;QcrBrgPF&quot;&gt;依次声明拦截器1 myInterceptor1 和 拦截器2 myInterceptor2，会在调用业务方法 handler 前后分别打印一行内容&lt;/li&gt;&lt;li data-pid=&quot;3s8wyyfz&quot;&gt;在创建 grpc server 时，将两个拦截器基于 option 注入&lt;/li&gt;&lt;li data-pid=&quot;XD-qVE4-&quot;&gt;通过客户端请求服务端，通过输出日志观察拦截器运行效果&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;var myInterceptor1 = func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
    fmt.Printf(&quot;interceptor1 preprocess, req: %+v\n&quot;, req)
    resp, err = handler(ctx, req)
    fmt.Printf(&quot;interceptor1 postprocess, req: %+v\n&quot;, resp)
    return
}


var myInterceptor2 = func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
    fmt.Printf(&quot;interceptor2 preprocess, req: %+v\n&quot;, req)
    resp, err = handler(ctx, req)
    fmt.Printf(&quot;interceptor2 postprocess, resp: %+v\n&quot;, resp)
    return
}


func (s *Server) SayHello(ctx context.Context, req *proto.HelloReq) (*proto.HelloResp, error) {
    fmt.Println(&quot;core handle logic......&quot;)
    return &amp;amp;proto.HelloResp{
        Reply: fmt.Sprintf(&quot;hello name: %s&quot;, req.Name),
    }, nil
}


func main() {
    listener, err := net.Listen(&quot;tcp&quot;, &quot;:8093&quot;)
    if err != nil {
        panic(err)
    }


    server := grpc.NewServer(grpc.ChainUnaryInterceptor(myInterceptor1, myInterceptor2))
    proto.RegisterHelloServiceServer(server, &amp;amp;Server{})


    if err := server.Serve(listener); err != nil {
        panic(err)
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-82ded9b086505bf0455e62c4368d7700_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1360&quot; data-rawheight=&quot;351&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-82ded9b086505bf0455e62c4368d7700_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1360&quot; data-rawheight=&quot;351&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-82ded9b086505bf0455e62c4368d7700_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-82ded9b086505bf0455e62c4368d7700_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;5 展望&lt;/h2&gt;&lt;p data-pid=&quot;WEVHnoTN&quot;&gt;本文向大家引入了 grpc-go 框架，介绍了其基本用法，和大家一起梳理了服务端运行的核心方法链路. 实际上，本文内容仅仅是 grpc 领域中的冰山一角，更多细节如序列化协议、服务注册/发现、负载均衡等内容，留待后续的篇章和大家再作分享探讨.&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;KALiduPA&quot;&gt;文末小广告：&lt;/p&gt;&lt;p data-pid=&quot;XgpxgtyL&quot;&gt;欢迎老板们关注我的个人公众号：小徐先生的编程世界&lt;/p&gt;&lt;p data-pid=&quot;3O9KTEAd&quot;&gt;我会不定期更新个人纯原创的&lt;a href=&quot;https://www.zhihu.com/search?q=%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2846169717%7D&quot; class=&quot;internal&quot;&gt;编程技术&lt;/a&gt;博客，技术栈以 go 语言为主，让我们一起点亮更多的编程技能树吧！&lt;/p&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>55093012b7db776aee5c8709f5a8cc51</guid>
<title>关于 OLTP、OLAP、HTAP 的一点点思考</title>
<link>https://toutiao.io/k/xnvsgza</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最早出现的数据库是OLTP数据库，上层应用对数据库的主要需求可以概况为增删改查（INSERT, UPDATE, DELETE, SELECT）。典型的产品比如Oracle、MySQL、PostgreSQL等。后来随着信息化程度的提高以及数据量的增加，企业有了对数据进行分析的需求，比如聚合等，由此诞生了OLAP型数据库。典型的产品比如Greenplum、ClickHouse等。再后来，出现了HTAP的概念，实际上，不存在纯粹的HTAP数据库，更多的是AP数据库不断增强TP处理能力，比如Greenplum，可参考论文《Greenplum: A Hybrid Database for Transactional and Analytical Workloads》 ，TP数据库不断增强AP处理能力比如TiDB，可参考论文：《TiDB: A Raft-based HTAP Database》。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里说不存在纯粹的HTAP数据库，并不是说没有，或者HTAP没有意义，而是说，HTAP想要同时达到TP以及AP的能力非常难。事实上，HTAP是非常有意义的，这里引用一段Greenplum论文中的描述：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;First, HTAP can reduce the waiting time of new data analysis tasks significantly, as there is no ETL transferring delay.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Second, HTAP systems can also reduce the overall business cost in terms of hardware and administration.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两点都有巨大的商业价值：实时分析能力的增加，成本的降低，效率的提升。值得数据库厂商朝着这个目标去努力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现有阶段实现HTAP的困难在于，目前基本不存在从零开始设计的HTAP数据库，大都是从TP向HTAP，AP向HTAP去走，这就存在问题了，TP数据库为了在其在事务型业务的性能，针对性的做了很多设计，比如执行计划缓存，索引，行存等，而在AP场景中，执行计划缓存没什么意义，索引的重要性下降，更多情况是全表扫描，列存相对行存在AP场景更有优势。所以要同时在两个方向都取得最佳的性能，难度是非常大的。即使是从零开始设计HTAP也是非常难以取舍的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个产品如果强调通用性，其某一单一方向往往难以达到极致。同理，HTAP的设计使得其难以在TP或者AP方向取得极致。ClickHouse就是一个典型，完全围绕AP场景设计，在单一方向取得极致。所以不存在谁更先进，谁是传统的，谁是未来，它们各自有其优势领域，由用户决定那个更适合自己的业务场景，既能满足业务需求同时综合成本最低。这里岔开一个话题，就是成本问题，商业数据库的用户必然面对成本问题，在同等性能指标或相差不大情况下，谁的成本低（这里的成本低不单指售价，也包括用户的全周期使用运维成本）谁的技术就更有优势，谁就更有机会在激烈的市场竞争中存活下来。一句话概括就是用最低的成本为用户解决问题，低成本本身就是一种技术优势。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库最终的发展，其引领方向的并不是数据库本身，而是数据库上层的应用业务需求。只要有上层应用业务需求的需要，这个方向就是对的，毕竟数据库就是拿来给业务用的。未来的业务应用一定是丰富的，业务需求也不再是单一的，所以未来的数据库也一定是各有特色（关系数据库、时序数据库、图数据库、向量数据库、多模数据库、NoSQL数据库、分布式数据库、分析型数据库、HTAP数据库、云原生数据库......），很难出现一款数据库包打天下的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在TP、AP越来越成熟，竞争越来越激烈的情况下，向HTAP发展也是个很不错的方向。最后，希望国产数据库的未来越来越好，做出有世界影响力的产品。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>