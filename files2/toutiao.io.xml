<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ddd9ef3f1b5c49d139e4ba7fd56e06b9</guid>
<title>全网最全的权限系统设计方案（图解）</title>
<link>https://toutiao.io/k/lozkmee</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1 为什么需要权限管理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常工作中权限的问题时时刻刻伴随着我们，程序员新入职一家公司需要找人开通各种权限，比如网络连接的权限、编码下载提交的权限、监控平台登录的权限、运营平台查数据的权限等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在很多时候我们会觉得这么多繁杂的申请给工作带来不便，并且如果突然想要查一些数据，发现没有申请过权限，需要再走审批流程，时间拉得会很长。那为什么还需要这么严格的权限管理呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，一家支付公司有运营后台，运营后台可以查到所有的商户信息，法人代表信息，交易信息以及费率配置信息，如果我们把这些信息不加筛选都给到公司的每一个小伙伴，那么跑市场的都可以操作商家的费率信息，如果一个不小心把费率改了会造成巨大的损失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又比如商户的信息都是非常隐秘的，有些居心不良的小伙伴把这些信息拿出来卖给商家的竞争对手，会给商家造成严重的不良后果。虽然这么做都是个别人人为的过错，但是制度上如果本身这些信息不开放出来就能在很大程度上避免违法乱纪的事情发生了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来讲&lt;strong&gt;权限管理是公司数据安全的重要保证，针对不同的岗位，不同的级别看到的数据是不一样的，操作数据的限制也是不一样的。&lt;/strong&gt;比如涉及到资金的信息只开放给财务的相关岗位，涉及到配置的信息只开放给运营的相关岗位，这样各司其职能避免很多不必要的安全问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如何让各个岗位的人在系统上各司其职，就是权限管理要解决的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2 权限模型&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 权限设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从业务分类上来讲权限可以分为数据查看权限，数据修改权限等，对应到系统设计中有页面权限、菜单权限、按钮权限等。菜单也分一级菜单、二级菜单甚至三级菜单，以csdn文章编辑页面左侧菜单栏为例是分了两级菜单。菜单对应的页面里又有很多按钮，我们在设计的时候最好把权限设计成树形结构，这样在申请权限的时候就可以一目了然的看到菜单的结构，需要哪些权限就非常的明了了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.563302752293578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7nn7wjVKBrX4icyVY40flLXqTVFQFjMTNx72QPVsseZ3mdrFPpwM8C1g/640?wx_fmt=png&amp;amp;random=0.3869801465108955&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照这个架构，按钮的父级是二级菜单，二级菜单的父级是一级菜单，这样用户申请权限的时候非常清晰的看到自己需要哪些权限。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 为什么需要角色&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;权限结构梳理清晰之后，需要思考怎么把权限分配给用户，用户少的情况下，可以直接分配，一个用户可以有多个权限，统一一个权限可以被多个用户拥有，用户-权限的模型结构如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25984251968503935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq73HUxp4kSjepVXIibazxT1kcOnuZxf1jTL4mwLQwgYyX512p28fzOmNg/640?wx_fmt=png&amp;amp;random=0.12281593247417089&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;这种模型能够满足权限的基本分配能力，但是随着用户数量的增长，这种模型的弊端就凸显出来了，每一个用户都需要去分配权限，非常的浪费管理员的时间和精力，并且用户和权限杂乱的对应关系会给后期带来巨大的维护成本。用户-权限对应关系图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8726708074534162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7mNU34iciasyLzPxZ0EMspjJ9sY47UyhSAl0MoQ2ukttkMrX7rzgf6SKw/640?wx_fmt=png&amp;amp;random=0.379500115530764&quot; data-type=&quot;png&quot; data-w=&quot;644&quot;/&gt;这种对应关系在用户多的情况下基本无法维护了。其实很多用户负责同一个业务模块所需要的权限是一样的，这样的话我们是不是可以借助第三个媒介，把需要相同的权限都分配给这个媒介，然后用户和媒介关联起来，用户就拥有了媒介的权限了。这就是经典的RBAC模型，其中媒介就是我们通常所说的角色。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 权限模型的演进&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.1 RBAC模型&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了角色之后可以把权限分配给角色，需要相同权限的用户和角色对应起来就可以了，一个权限可以分配给多个角色，一个角色可以拥有多个权限，同样一个用户可以分配多个角色，一个角色也可以对应多个用户，对应模型如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17224080267558528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq70Pp3ia1T0qWCpcO3hoibptmXtfMFmuLV5R0pKdZpBibHLE6c5htVDUcUA/640?wx_fmt=png&amp;amp;random=0.7805500510170766&quot; data-type=&quot;png&quot; data-w=&quot;1196&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是经典的RBAC模型了（role-based-access-control），在这里面角色起到了桥梁左右，连接了用户和权限的关系，每个角色可以拥有多个权限，每个用户可以分配多个角色，这样用户就拥有了多个角色的多个权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时因为有角色作为媒介，大大降低了错综复杂的交互关系，比如一家有上万人的公司，角色可能只需要几百个就搞定了，因为很多用户需要的权限是一样的，分配一样的角色就可以了。这种模型的对应关系图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46864686468646866&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7SyN9SrzXEnBS0RDBVicmt3PlGDvovzf05C1ulRyVadO9oD6hYHbtP6A/640?wx_fmt=png&amp;amp;random=0.2863653075923056&quot; data-type=&quot;png&quot; data-w=&quot;1212&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户和角色，角色和权限都是多对多的关系，这种模型是最通用的权限管理模型，节省了很大的权限维护成本， 但是实际的业务千变万化，权限管理的模型也需要根据不同的业务模型适当的调整，比如一个公司内部的组织架构是分层级的，层级越高权限越大，因为层级高的人不仅要拥有自己下属拥有的权限，二期还要有一些额外的权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RBAC模型可以给不同层级的人分配不同的角色，层级高的对应角色的权限就多，这样的处理方式可以解决问题，但是有没有更好的解决办法呢，答案肯定是有的，这就引出&lt;strong&gt;角色继承的RBAC模型&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.2 角色继承的RBAC模型&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;角色继承的RBAC模型又称RBAC1模型。每个公司都有自己的组织架构，比如公司里管理财务的人员有财务总监、财务主管、出纳员等，财务主管需要拥有但不限于出纳员的权限，财务总监需要拥有但不限于财务主管的权限，像这种管理关系向下兼容的模式就需要用到角色继承的RBAC模型。&lt;strong&gt;角色继承的RBAC模型的思路是上层角色继承下层角色的所有权限，并且可以额外拥有其他权限。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模型如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7605363984674329&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7Vz5WxDUJECmsqerotwzqLJXTVm2HDRkZGhc6OIfBmiaJiagYjiapXBFnQ/640?wx_fmt=png&amp;amp;random=0.01075333932726652&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;从模型图中可以看出下级角色拥有的权限，上级角色都拥有，并且上级角色可以拥有其他的权限。角色的层级关系可以分为两种，一种是下级角色只能拥有一个上级角色，但是上级角色可以拥有多个下级角色，这种结构用图形表示是一个树形结构，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5091911764705882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7vTkqibyicXmfwX5eQCzCFabxibpGUa2NG1LtAE55js6Gms3yPKxbSlHzg/640?wx_fmt=png&amp;amp;random=0.9664950058278607&quot; data-type=&quot;png&quot; data-w=&quot;1088&quot;/&gt;还有一种关系是下级角色可以拥有多个上级角色，上级角色也可以拥有多个下级角色，这种结构用图形表示是一个有向无环图，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5064456721915286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7BD3bNkYP7mqzTYEVhia1UJMiaokMSAlWdmobLACVu5CyItAWxrH1Cpsw/640?wx_fmt=png&amp;amp;random=0.04259729352510133&quot; data-type=&quot;png&quot; data-w=&quot;1086&quot;/&gt;树形图是我们比较常用的，因为一个用户一般情况下不会同时有多个直属上级，比如财务部只能有一个财务总监，但是可以有多个财务主管和收纳员。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.3 带约束的RBAC模型&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带约束的RBAC模型又成RBAC2模型。在实际工作中，为了安全的考虑会有很多约束条件，比如财务部里同一个人不能即是会计又是审核员，跟一个人同一时间不能即是运动员又是裁判员是一个道理的，又比如财务部的审核员不能超过2个，不能1个也没有。因为角色和权限是关联的，所以我们做好角色的约束就可以了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;常见的约束条件有：角色互斥、基数约束、先决条件约束等。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;角色互斥：&lt;/strong&gt; 如果角色A和角色B是互斥关系的话，那么一个用户同一时间不能即拥有角色A，又拥有角色B，只能拥有其中的一个角色。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如我们给一个用户赋予了会计的角色就不能同时再赋予审核员的角色，如果想拥有审核员的角色就必须先去掉会计的角色。假设提交角色和审核角色是互质的，我们可以用图形表示：&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3898989898989899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7ZpUKnW9qWjqtpmH9pOic9ye6hAjz1IEFaSarNTwZTGbqibFva5ly7ODg/640?wx_fmt=png&amp;amp;random=0.5303696963485485&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;strong&gt;基数约束：&lt;/strong&gt; 同一个角色被分配的用户数量可以被限制，比如规定拥有超级管理员角色的用户有且只有1个；用户被分配的角色数量也需要被限制，角色被分配的权限数量也可以被限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;先决条件约束：&lt;/strong&gt;用户想被赋予上级角色，首先需要拥有下级角色，比如技术负责人的角色和普通技术员工角色是上下级关系，那么用户想要用户技术负责人的角色就要先拥有普通技术员工的角色。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 用户划分&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.4.1 用户组&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建角色是为了解决用户数量大的情况下，用户分配权限繁琐以及用户-权限关系维护成本高的问题。抽象出一个角色，把需要一起操作的权限分配给这个角色，把角色赋予用户，用户就拥有了角色上的权限，这样避免了一个个的给用户分配权限，节省了大量的资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的如果有一批用户需要相同的角色，我们也需要一个个的给用户分配角色，比如一个公司的客服部门有500多个人，有一天研发部研发了一套查询后台数据的产品，客服的小伙伴都需要使用，但是客服由于之前并没有统一的一个角色给到所有的客服小伙伴，这时候需要新加一个角色，把权限分配给该角色，然后再把角色一个个分配给客服人员，这时候会发现给500个用户一个个添加角色非常的麻烦。但是客服人员又有共同的属性，所以我们可以创建一个用户组，所有的客服人员都属于客服用户组，把角色分配给客服用户组，这个用户组下面的所有用户就拥有了需要的权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RBAC模型添加用户组之后的模型图如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44676409185803756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7AOXjfzkg6ayvFhyqFepD2iaTibyFXBlQwd0NeZn6OGQCkgCrJdMo7a0Q/640?wx_fmt=png&amp;amp;random=0.7284421954870555&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;很多朋友会问，用户组和角色有什么区别呢？简单的来说，&lt;strong&gt;用户组是一群用户的组合，而角色是用户和权限之间的桥梁。&lt;/strong&gt; 用户组把相同属性的用户组合起来，比如同一个项目的开发、产品、测试可以是一个用户组，同一个部门的相同职位的员工可以是一个用户组， 一个用户组可以是一个职级，可以是一个部门，可以是一起做事情的来自不同岗位的人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户可以分组，权限也可以分组，权限特别多的情况下，可以把一个模块的权限组合起来成为一个权限组，权限组也是解决权限和角色对应关系复杂的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们定义权限的时候一级菜单、二级菜单、按钮都可以是权限，一个一级菜单下面有几十个二级菜单，每个二级菜单下面又有几十个按钮，这时候我们把权限一个个分配给角色也是非常麻烦的，可以采用分组的方法把权限分组，然后把分好的组赋予角色就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给权限分组也是个技术活，需要理清楚权限之间的关系，比如支付的运营后台我们需要查各种信息，账务的数据、订单的数据、商户的数据等等，这些查询的数据并不在一个页面，每个页面也有很多按钮，我们可以把这几个页面以及按钮对应的权限组合成一个权限组赋予角色。加入权限组之后的RBAC模型如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44258872651356995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7Nv23yWO5UqQ1pJfFZ91ibRRz9ebKWcECWctygzdANx1zvHFatVPRiaMw/640?wx_fmt=png&amp;amp;random=0.3565732072391419&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;实际工作中我们很少给权限分组，给用户分组的场景会多一些，有的时候用户组也可以直接和权限关联，这个看实际的业务场景是否需要，权限模型没有统一的，业务越复杂业务模型会约多样化。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.4.2 组织&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个公司都有自己的组织架构，很多时候权限的分配可以根据组织架构来划分。因为同一个组织内的小伙伴使用的大部分权限是一样的。如下所示一个公司的组织架构图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5008210180623974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7dbXNuYRGZNcaZib6H7oG4AgiaheboEicZStGr81tbUC5qOaiaJObnmONYw/640?wx_fmt=png&amp;amp;random=0.4545984963546068&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot;/&gt;按照这个组织架构，每一个组织里的成员使用的基础权限很可能是一样的，比如人力资源都需要看到人才招聘的相关信息，市场推广都需要看到行业分析的相关信息，按照组织来分配角色会有很多优势：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实现权限分配的自动化：&lt;/strong&gt; 和组织关系打通之后，按照组织来分配角色，如果有新入职的用户，被划分在某个组织下面之后，会自动获取该组织下所有的权限，无需人工分配。又比如有用户调岗，只需要把组织关系调整就可以了，权限会跟着组织关系自动调整，也无需人工干预。这么做首先需要把权限和组织关系打通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;控制数据权限：&lt;/strong&gt; 把角色关联到组织，组织里的成员只能看到本组织下的数据，比如市场推广和大客定制，市场推广针对的是零散的客户，大可定制针对的是有一定体量的客户，相互的数据虽然在一个平台，但是只能看自己组织下的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加入组织之后的RBAC模型如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4425531914893617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7lWt5ia70uWdoanLr5bhpA1vd8Mva67aEbFdiafTTPck10snrWwncNr7A/640?wx_fmt=png&amp;amp;random=0.43082287972094635&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;用户可以在多个组织中，因为组织也有层级结构，一个组织里只可以有多个用户，所以用户和组织的关系是多对多的关系，组织和角色的关系是一对一的关系。这个在工作中可以根据实际情况来确定对应关系。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.4.3 职位&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个组织下面会有很多职位，比如财务管理会有财务总监、财务主管、会计、出纳员等职位，每个职位需要的权限是不一样的，可以像组织那样根据职位来分配不同的角色，由于一个人的职位是固定的，所以用户跟职位的对应关系时一对一的关系，职位跟角色的对应关系可以是多对多的关系。加入职位的RBAC模型如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4451476793248945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7kcXicbH94aqTjw4aRwMysbxhPvEwDnBicYYIZ551WZm4ib50Kfv38D7CA/640?wx_fmt=png&amp;amp;random=0.8327855836170899&quot; data-type=&quot;png&quot; data-w=&quot;948&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.5 理想的RBAC模型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RBAC模型根据不同业务场景的需要会有很多种演变，实际工作中业务是非常复杂的，权限分配也是非常复杂的，想要做出通用且高效的模型很困难。我们把RBAC模型的演变汇总起来会是一个支撑大数据量以及复杂业务的理想的模型。把RBAC、RBAC1、RBAC2、用户组、组织、职位汇总起来的模型如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4702517162471396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7fzPfV1Lno8roOmeJ4gd3CKsr0iclcsviaTkJlIia3xLtn7gooooEs1vfA/640?wx_fmt=png&amp;amp;random=0.7807457219448579&quot; data-type=&quot;png&quot; data-w=&quot;1748&quot;/&gt;按照这个模型基本上能够解决所有的权限问题，其中的对应关系可以根据实际的业务情况来确定，一般情况下，组织和职位是一对多的关系，特殊情况下可以有多对多的情况，需要根据实际情况来定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想的RBAC模型并不是说我们一开始建权限模型就可以这么做，而是数据体量、业务复杂度达到一定程度之后可以使用这个模型来解决权限的问题，如果数据量特别少，比如刚成立的公司只有十几个人，那完全可以用用户-权限模型，都没有必要使用RBAC模型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3 权限系统表设计&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 标准RBAC模型表设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标准RBAC模型的表是比较简单了，要表示&lt;code&gt;用户-角色-权限&lt;/code&gt;三者之前的关系，首先要创建用户表、角色表、权限表，用户和角色是多对多的关系，角色和权限是多对多的关系，需要再创建两章关系表，分别是用户-角色关系表和角色-权限关系表。这六张表的ER图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4920886075949367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7kgfe8UC7IVzSzSzqO6fn3SAZ7vw1l7PYiaNXCcTd5JajrEsseJpIAmw/640?wx_fmt=png&amp;amp;random=0.5719574040529976&quot; data-type=&quot;png&quot; data-w=&quot;1264&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 理想RBAC模型表设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想的RBAC模型是标准RBAC模型经过多次扩展得到的，表结构也会比较复杂，因为要维护很多关系，如下图所示是理想的RBAC模型的ER图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5965417867435159&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7icQjj6sPTuvRdUAjKc9icrkV7tQNwuic8HWOf2cfTGz7RwZBfzbjfuUcA/640?wx_fmt=png&amp;amp;random=0.021794103728019598&quot; data-type=&quot;png&quot; data-w=&quot;2082&quot;/&gt;这里面需要强调的是角色互斥表，互斥的关系可以放在角色上，也可以放在权限上，看实际工作的需求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4 结语&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从易到难非常详细的介绍了权限模型的设计，在工作中需要根据实际情况来定义模型，千人以内的公司使用RBAC模型是完全够用的，没有必要吧权限模型设计的过于复杂。模型的选择要根据具体情况，比如公司体量、业务类型、人员数量等。总之最适合自己公司的模型就是最好的模型，权限模式和设计模式是一样的，都是为了更好的解决问题，不要为了使用模型而使用模型。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>83a5b260c1357d19c1fcf67438e4cf07</guid>
<title>麻了，代码改成多线程，竟有9大问题</title>
<link>https://toutiao.io/k/1lggdyi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;文末留言送书啦！！！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们为了提升接口的性能，会把之前&lt;code&gt;单线程同步&lt;/code&gt;执行的代码，改成&lt;code&gt;多线程异步&lt;/code&gt;执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：查询用户信息接口，需要返回用户基本信息、积分信息、成长值信息，而用户、积分和成长值，需要调用不同的接口获取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果查询用户信息接口，&lt;code&gt;同步调用&lt;/code&gt;三个接口获取数据，会非常耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就非常有必要把三个接口调用，改成&lt;code&gt;异步调用&lt;/code&gt;，最后&lt;code&gt;汇总结果&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如：注册用户接口，该接口主要包含：写用户表，分配权限，配置用户导航页，发通知消息等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该用户注册接口包含的业务逻辑比较多，如果在接口中同步执行这些代码，该接口响应时间会非常慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时就需要把业务逻辑梳理一下，划分：&lt;code&gt;核心逻辑&lt;/code&gt;和&lt;code&gt;非核心逻辑&lt;/code&gt;。这个例子中的核心逻辑是：写用户表和分配权限，非核心逻辑是：配置用户导航页和发通知消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然&lt;code&gt;核心逻辑&lt;/code&gt;必须在接口中&lt;code&gt;同步执行&lt;/code&gt;，而&lt;code&gt;非核心逻辑&lt;/code&gt;可以&lt;code&gt;多线程异步&lt;/code&gt;执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要使用多线程的业务场景太多了，使用多线程异步执行的好处不言而喻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我要说的是，如果多线程没有使用好，它也会给我们带来很多意想不到的问题，不信往后继续看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天跟大家一起聊聊，代码改成多线程调用之后，带来的9大问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.获取不到返回值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你通过直接继承&lt;code&gt;Thread&lt;/code&gt;类，或者实现&lt;code&gt;Runnable&lt;/code&gt;接口的方式去创建&lt;code&gt;线程&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，恭喜你，你将没法获取该线程方法的返回值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用线程的场景有两种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不需要关注线程方法的返回值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要关注线程方法的返回值。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分业务场景是不需要关注线程方法返回值的，但如果我们有些业务需要关注线程方法的返回值该怎么处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询用户信息接口，需要返回用户基本信息、积分信息、成长值信息，而用户、积分和成长值，需要调用不同的接口获取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5012285012285013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWkq5XlVQMkYdPXkCsRcT1QFBCIrAKapkFNx1jEiaRObHA0Im1rz2yYNvRfMdmhGppAqjfgsbvLZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;在Java8之前可以通过实现&lt;code&gt;Callable&lt;/code&gt;接口，获取线程返回结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java8以后通过&lt;code&gt;CompleteFuture&lt;/code&gt;类实现该功能。我们这里以CompleteFuture为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserInfo &lt;span&gt;getUserInfo&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; UserInfo userInfo = &lt;span&gt;new&lt;/span&gt; UserInfo();&lt;br/&gt;    CompletableFuture userFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteUserAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteBonusAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteGrowthAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();&lt;br/&gt;&lt;br/&gt;    userFuture.get();&lt;br/&gt;    bonusFuture.get();&lt;br/&gt;    growthFuture.get();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userInfo;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;温馨提醒一下，这两种方式别忘了使用线程池。示例中我用到了executor，表示自定义的线程池，为了防止高并发场景下，出现线程过多的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，&lt;code&gt;Fork/join&lt;/code&gt;框架也提供了执行任务并返回结果的能力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.数据丢失&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以注册用户接口为例，该接口主要包含：写用户表，分配权限，配置用户导航页，发通知消息等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中：写用户表和分配权限功能，需要在一个事务中同步执行。而剩余的配置用户导航页和发通知消息功能，使用多线程异步执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表面上看起来没问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果前面的写用户表和分配权限功能成功了，用户注册接口就直接返回成功了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果后面异步执行的配置用户导航页，或发通知消息功能失败了，怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWkq5XlVQMkYdPXkCsRcT14NOSxPsEFpU4ARFqEhZbMHZZmJECbmkkDZSJ8hx92sA1dicX1c7GveQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;672&quot;/&gt;该接口前面明明已经提示用户成功了，但结果后面又有一部分功能在多线程异步执行中失败了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时该如何处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，你可以做&lt;code&gt;失败重试&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果重试了一定的次数，还是没有成功，这条请求数据该如何处理呢？如果不做任何处理，该数据是不是就丢掉了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止数据丢失，可以用如下方案：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用mq异步处理。在分配权限之后，发送一条mq消息，到mq服务器，然后在mq的消费者中使用多线程，去配置用户导航页和发通知消息。如果mq消费者中处理失败了，可以自己重试。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用job异步处理。在分配权限之后，往任务表中写一条数据。然后有个job定时扫描该表，然后配置用户导航页和发通知消息。如果job处理某条数据失败了，可以在表中记录一个重试次数，然后不断重试。但该方案有个缺点，就是实时性可能不太高。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.顺序问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你使用了多线程，就必须接受一个非常现实的问题，即&lt;code&gt;顺序问题&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如之前代码的执行顺序是：a,b,c，改成多线程执行之后，代码的执行顺序可能变成了：a,c,b。（这个跟cpu调度算法有关）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;a&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;c&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    thread1.start();&lt;br/&gt;    thread2.start();&lt;br/&gt;    thread3.start();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a&lt;br/&gt;c&lt;br/&gt;b&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，来自灵魂的一问：如何保证线程的顺序呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即线程启动的顺序是：a,b,c，执行的顺序也是：a,b,c。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1703296703296704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWkq5XlVQMkYdPXkCsRcT12moFAiaOLH2D345zeSLOHsyNdW3BU8AYYbRpudZhU3yCqEg6fGJ2EDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;364&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 join&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;类的&lt;code&gt;join&lt;/code&gt;方法它会让主线程等待子线程运行结束后，才能继续运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;a&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;c&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    thread1.start();&lt;br/&gt;    thread1.join();&lt;br/&gt;    thread2.start();&lt;br/&gt;    thread2.join();&lt;br/&gt;    thread3.start();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果永远都是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 newSingleThreadExecutor&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用JDK自带的&lt;code&gt;Excutors&lt;/code&gt;类的&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;方法，创建一个&lt;code&gt;单线程&lt;/code&gt;的&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;    ExecutorService executorService = Executors.newSingleThreadExecutor();&lt;br/&gt;&lt;br/&gt;    Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;a&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;c&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    executorService.submit(thread1);&lt;br/&gt;    executorService.submit(thread2);&lt;br/&gt;    executorService.submit(thread3);&lt;br/&gt;&lt;br/&gt;    executorService.shutdown();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果永远都是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;Excutors&lt;/code&gt;类的&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;方法创建的单线程的线程池，使用了&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;作为队列，而此队列按 &lt;code&gt;FIFO&lt;/code&gt;（先进先出）排序元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加到队列的顺序是a,b,c，则执行的顺序也是a,b,c。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.3 CountDownLatch&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        CountDownLatch latch1 = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        CountDownLatch latch2 = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        CountDownLatch latch3 = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; TestRunnable(latch1, latch2, &lt;span&gt;&quot;a&quot;&lt;/span&gt;));&lt;br/&gt;        Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; TestRunnable(latch2, latch3, &lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;        Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; TestRunnable(latch3, latch3, &lt;span&gt;&quot;c&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;        thread1.start();&lt;br/&gt;        thread2.start();&lt;br/&gt;        thread3.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestRunnable&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CountDownLatch latch1;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CountDownLatch latch2;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String message;&lt;br/&gt;&lt;br/&gt;    TestRunnable(CountDownLatch latch1, CountDownLatch latch2, String message) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.latch1 = latch1;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.latch2 = latch2;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.message = message;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            latch1.await();&lt;br/&gt;            System.out.println(message);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        latch2.countDown();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果永远都是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，使用&lt;code&gt;CompletableFuture&lt;/code&gt;的&lt;code&gt;thenRun&lt;/code&gt;方法，也能多线程的执行顺序，在这里就不一一介绍了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.线程安全问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然使用了线程，伴随而来的还&lt;span&gt;会&lt;/span&gt;有线程安全问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如现在有这样一个需求：用多线程执行查询方法，然后把执行结果添加到一个list集合中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;User&amp;gt; list = Lists.newArrayList();&lt;br/&gt; dataList.stream()&lt;br/&gt;     .map(data -&amp;gt; CompletableFuture&lt;br/&gt;          .supplyAsync(() -&amp;gt; query(list, data), asyncExecutor)&lt;br/&gt;         ));&lt;br/&gt;CompletableFuture.allOf(futureArray).join();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;CompletableFuture&lt;/code&gt;异步多线程执行query方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;query&lt;/span&gt;&lt;span&gt;(List&amp;lt;User&amp;gt; list, UserEntity condition)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   User user = queryByCondition(condition);&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(Objects.isNull(user)) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;   list.add(user);&lt;br/&gt;   UserExtend userExtend = queryByOther(condition);&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(Objects.nonNull(userExtend)) {&lt;br/&gt;      user.setExtend(userExtend.getInfo());&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在query方法中，将获取的查询结果添加到list集合中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果list会出现线程安全问题，有时候会少数据，当然也不一定是必现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为&lt;code&gt;ArrayList&lt;/code&gt;是&lt;code&gt;非线程安全&lt;/code&gt;的，没有使用&lt;code&gt;synchronized&lt;/code&gt;等关键字修饰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;集合，代替普通的&lt;code&gt;ArrayList&lt;/code&gt;集合，CopyOnWriteArrayList是一个线程安全的机会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需一行小小的改动即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;User&amp;gt; list Lists.newCopyOnWriteArrayList();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;温馨的提醒一下，这里创建集合的方式，用了google的collect包。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.ThreadLocal获取数据异常&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道&lt;code&gt;JDK&lt;/code&gt;为了解决线程安全问题，提供了一种用空间换时间的新思路：&lt;code&gt;ThreadLocal&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的核心思想是：共享变量在每个&lt;code&gt;线程&lt;/code&gt;都有一个&lt;code&gt;副本&lt;/code&gt;，每个线程操作的都是自己的副本，对另外的线程没有影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        threadLocal.set(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        doSamething();&lt;br/&gt;        Integer integer = threadLocal.get();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal在普通中线程中，的确能够获取正确的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在真实的业务场景中，一般很少用&lt;code&gt;单独的线程&lt;/code&gt;，绝大多数，都是用的&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，在线程池中如何获取&lt;code&gt;ThreadLocal&lt;/code&gt;对象生成的数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果直接使用普通ThreadLocal，显然是获取不到正确数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先试试&lt;code&gt;InheritableThreadLocal&lt;/code&gt;，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    InheritableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;    ExecutorService executorService = Executors.newSingleThreadExecutor();&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第一次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第二次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第一次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第二次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这个例子中使用了单例线程池，固定线程数是1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次submit任务的时候，该线程池会自动创建一个线程。因为使用了InheritableThreadLocal，所以创建线程时，会调用它的init方法，将父线程中的inheritableThreadLocals数据复制到子线程中。所以我们看到，在主线程中将数据设置成6，第一次从线程池中获取了正确的数据6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，在主线程中又将数据改成7，但在第二次从线程池中获取数据却依然是6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为第二次submit任务的时候，线程池中已经有一个线程了，就直接拿过来复用，不会再重新创建线程了。所以不会再调用线程的init方法，所以第二次其实没有获取到最新的数据7，还是获取的老数据6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;，它并非JDK自带的类，而是阿里巴巴开源jar包中的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下pom文件引入该jar包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;transmittable-thread-local&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.11.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;compile&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码调整如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    TransmittableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; TransmittableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;    ExecutorService ttlExecutorService = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    ttlExecutorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第一次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;    ttlExecutorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第二次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第一次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第二次从线程池中获取数据：&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到，使用了TransmittableThreadLocal之后，第二次从线程中也能正确获取最新的数据7了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nice。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你仔细观察这个例子，你可能会发现，代码中除了使用&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;类之外，还使用了&lt;code&gt;TtlExecutors.getTtlExecutorService&lt;/code&gt;方法，去创建&lt;code&gt;ExecutorService&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是非常重要的地方，如果没有这一步，&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;在线程池中共享数据将不会起作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;code&gt;ExecutorService&lt;/code&gt;对象，底层的submit方法会&lt;code&gt;TtlRunnable&lt;/code&gt;或&lt;code&gt;TtlCallable&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以TtlRunnable类为例，它实现了&lt;code&gt;Runnable&lt;/code&gt;接口，同时还实现了它的run方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Map&amp;lt;TransmittableThreadLocal&amp;lt;?&amp;gt;, Object&amp;gt; copied = (Map)&lt;span&gt;this&lt;/span&gt;.copiedRef.get();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (copied != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (!&lt;span&gt;this&lt;/span&gt;.releaseTtlValueReferenceAfterRun || &lt;span&gt;this&lt;/span&gt;.copiedRef.compareAndSet(copied, (Object)&lt;span&gt;null&lt;/span&gt;))) {&lt;br/&gt;        Map backup = TransmittableThreadLocal.backupAndSetToCopied(copied);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.runnable.run();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            TransmittableThreadLocal.restoreBackup(backup);&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;TTL value reference is released after run!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的主要逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;把当时的ThreadLocal做个备份，然后将父类的ThreadLocal拷贝过来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行真正的run方法，可以获取到父类最新的ThreadLocal数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从备份的数据中，恢复当时的ThreadLocal数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想进一步了解ThreadLocal的工作原理，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247494889&amp;amp;idx=1&amp;amp;sn=db15e438326c8e297eef739ec190971b&amp;amp;chksm=c0e83401f79fbd17143734d5dbb509f020553772e162d5895de8c8039d79a3cff8633bcf4bb8&amp;amp;token=1106409335&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;ThreadLocal夺命11连问&lt;/a&gt;》&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.OOM问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，使用多线程可以提升代码执行效率，但也不是绝对的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一些耗时的操作，使用多线程，确实可以提升代码执行效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但线程不是创建越多越好，如果线程创建多了，也可能会导致&lt;code&gt;OOM&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Caused by: &lt;br/&gt;java.lang.OutOfMemoryError: unable to create &lt;span&gt;new&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; thread&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;JVM&lt;/code&gt;中创建一个线程，默认需要占用&lt;code&gt;1M&lt;/code&gt;的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果创建了过多的线程，必然会导致内存空间不足，从而出现OOM异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，如果使用线程池的话，特别是使用固定大小线程池，即使用&lt;code&gt;Executors.newFixedThreadPool&lt;/code&gt;方法创建的线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该线程池的&lt;code&gt;核心线程数&lt;/code&gt;和&lt;code&gt;最大线程数&lt;/code&gt;是一样的，是一个固定值，而存放消息的队列是&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该队列的最大容量是&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，也就是说如果使用固定大小线程池，存放了太多的任务，有可能也会导致OOM异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.OutOfMemeryError:Java heap space&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.CPU使用率飙高&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有做过excel数据导入功能，需要将一批excel的数据导入到系统中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每条数据都有些业务逻辑，如果单线程导入所有的数据，导入效率会非常低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是改成了多线程导入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果excel中有大量的数据，很可能会出现CPU使用率飙高的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，如果代码出现死循环，cpu使用率会飚的很多高。因为代码一直在某个线程中循环，没法切换到其他线程，cpu一直被占用着，所以会导致cpu使用率一直高居不下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而多线程导入大量的数据，虽说没有死循环代码，但由于多个线程一直在不停的处理数据，导致占用了cpu很长的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也会出现cpu使用率很高的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;Thread.sleep&lt;/code&gt;休眠一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在线程中处理完一条数据，休眠10毫秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然CPU使用率飙高的原因很多，多线程处理数据和死循环只是其中两种，还有比如：频繁GC、正则匹配、频繁序列化和反序列化等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面我会写一篇介绍CPU使用率飙高的原因的专题文章，感兴趣的小伙伴，可以关注一下我后续的文章。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.事务问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            roleService.doOtherThing();&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子中，我们可以看到&lt;code&gt;事务方法&lt;/code&gt;add中，调用了事务方法doOtherThing，但是&lt;code&gt;事务方法&lt;/code&gt;doOtherThing是在另外一个&lt;code&gt;线程&lt;/code&gt;中调用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样会导致两个方法不在同一个线程中，获取到的&lt;code&gt;数据库连接&lt;/code&gt;不一样，从而是两个不同的&lt;code&gt;事务&lt;/code&gt;。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是&lt;code&gt;数据源&lt;/code&gt;，value是&lt;code&gt;数据库连接&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Map&amp;lt;Object, Object&amp;gt;&amp;gt; resources =&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; NamedThreadLocal&amp;lt;&amp;gt;(&lt;span&gt;&quot;Transactional resources&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们说的&lt;code&gt;同一个事务&lt;/code&gt;，其实是指&lt;code&gt;同一个数据库连接&lt;/code&gt;，只有拥有同一个数据库连接才能同时&lt;code&gt;提交&lt;/code&gt;和&lt;code&gt;回滚&lt;/code&gt;。如果在不同的&lt;code&gt;线程&lt;/code&gt;，拿到的&lt;code&gt;数据库连接&lt;/code&gt;肯定是不一样的，所以是不同的事务。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所以不要在事务中开启另外的线程，去处理业务逻辑，这样会导致事务失效。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.导致服务挂掉&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用多线程会导致服务挂掉，这不是危言耸听，而是确有其事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在有这样一种业务场景：在mq的消费者中需要调用订单查询接口，查到数据之后，写入业务表中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来是没啥问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;突然有一天，mq生产者跑了一个批量数据处理的job，导致mq服务器上堆积了大量的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，mq消费者的处理速度，远远跟不上mq消息的生产速度，导致的结果是出现了大量的消息堆积，对用户有很大的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，mq消费者改成&lt;code&gt;多线程&lt;/code&gt;处理，直接使用了&lt;code&gt;线程池&lt;/code&gt;，并且&lt;code&gt;最大线程数&lt;/code&gt;配置成了20。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样调整之后，消息堆积问题确实得到了解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但带来了另外一个更严重的问题：订单查询接口并发量太大了，有点扛不住压力，导致部分节点的服务直接挂掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5266821345707656&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWkq5XlVQMkYdPXkCsRcT1uhx7xe5SaRncT0IhIGSDXpWvpqNOrZqKYS533UG8DftiaUuX3v3cbcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;为了解决问题，不得不临时加服务节点。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在mq的消费者中使用多线程，调用接口时，一定要评估好接口能够承受的最大访问量，防止因为压力过大，而导致服务挂掉的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6091816cb071d7a6acc8584e9ca3c808</guid>
<title>高效能团队的Java研发规范(进阶版)</title>
<link>https://toutiao.io/k/nud1jt6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body mt-4&quot;&gt;
        &lt;p&gt;目前大部分团队是使用的阿里巴巴Java开发规范，不过在日常开发中难免遇到覆盖不到的场景，本文在阿里巴巴Java开发规范基础上，补充一些常用的规范，用于提升代码质量及增强代码可读性。&lt;/p&gt;
&lt;h1 id=&quot;%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6&quot; tabindex=&quot;-1&quot;&gt;编程规约&lt;/h1&gt;
&lt;h2 id=&quot;1%E3%80%81%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C&quot; tabindex=&quot;-1&quot;&gt;1、基础类型及操作&lt;/h2&gt;
&lt;h3 id=&quot;%EF%BC%881%EF%BC%89%E8%BD%AC%E6%8D%A2&quot; tabindex=&quot;-1&quot;&gt;（1）转换&lt;/h3&gt;
&lt;h5 id=&quot;%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&quot; tabindex=&quot;-1&quot;&gt;基本类型转换&lt;/h5&gt;
&lt;p&gt;String类型转数字：使用apache common-lang3包中的工具类NumberUtils，优势：可设置默认值，转换出错时返回默认值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;NumberUtils.toInt(&quot;1&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拆箱：包装类转化为基本类型的时候，需要判定null，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-&quot;&gt;Integer numObject = param.get(0);
int num = numObject != null ? numObject : 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&quot; tabindex=&quot;-1&quot;&gt;对象类型转换&lt;/h5&gt;
&lt;p&gt;使用MapStruct工具，转换类后缀Convertor，所有转换操作都在转换类中操作，禁止在业务代码中编写大量set代码。&lt;/p&gt;
&lt;h3 id=&quot;%EF%BC%882%EF%BC%89%E5%88%A4%E6%96%AD&quot; tabindex=&quot;-1&quot;&gt;（2）判断&lt;/h3&gt;
&lt;h5 id=&quot;%E6%9E%9A%E4%B8%BE%E5%88%A4%E5%AE%9A&quot; tabindex=&quot;-1&quot;&gt;枚举判定&lt;/h5&gt;
&lt;p&gt;使用枚举判等，而非枚举对应的数字。因为枚举更直观，方便查看代码及调试，数字容易出错。&lt;/p&gt;
&lt;h5 id=&quot;%E5%88%A4%E7%A9%BA&quot; tabindex=&quot;-1&quot;&gt;判空&lt;/h5&gt;
&lt;p&gt;各种对象的判空：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-&quot;&gt;//对象判空&amp;amp;非空
Objects.isNull()
Objects.nonNull()

//String判空&amp;amp;非空
StringUtils.isEmpty()   //可匹配null和空字符串
StringUtils.isNotEmpty()
StringUtils.isBlank()   //可匹配null、空字符串、多个空白字符
StringUtils.isNotBlank()

//集合判空&amp;amp;非空
CollectionUtils.isEmpty()
CollectionUtils.isNotEmpty()

//Map判空&amp;amp;非空
MapUtils.isEmpty()
MapUtils.isNotEmpty()
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;%E6%96%AD%E8%A8%80&quot; tabindex=&quot;-1&quot;&gt;断言&lt;/h5&gt;
&lt;p&gt;使用Guava里的Preconditions工具类，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-&quot;&gt;//如果是空则抛异常
Preconditions.checkNotNull()
//通用判断
Preconditions.checkArgument()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;2%E3%80%81%E9%9B%86%E5%90%88%E5%A4%84%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;2、集合处理&lt;/h2&gt;
&lt;h3 id=&quot;%EF%BC%881%EF%BC%89map%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C&quot; tabindex=&quot;-1&quot;&gt;（1）Map快捷操作&lt;/h3&gt;
&lt;p&gt;推荐：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//如果值不存在则计算
map.computeIfAbsent(&quot;key&quot;,k-&amp;gt; execValue(k));
//默认值
map.getOrDefault(&quot;key&quot;, DEFAULT_VALUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//如果值不存在则计算
String v = map.get(&quot;key&quot;);
if(v == null){
    v = execValue(&quot;key&quot;);
    map.put(&quot;key&quot;, v);
}
//默认值
map.containsKey(&quot;key&quot;) ? map.get(&quot;key&quot;) : DEFAULT_VALUE
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%EF%BC%882%EF%BC%89%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1&quot; tabindex=&quot;-1&quot;&gt;（2）创建对象&lt;/h3&gt;
&lt;p&gt;构造方法或Builder模式，超过3个参数对象创建使用Builder模式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//Java11+:
List.of(1, 2, 3)  
Set.of(1, 2, 3)
Map.of(&quot;a&quot;, 1)

//Java8中不可变集合（需引入Guava）
ImmutableList.of(1,2,3)
ImmutableSet.of(1,2,3)
ImmutableMap.of(&quot;key&quot;,&quot;value&quot;)
//多值情况
ImmutableMap.builder()
    .put(&quot;key&quot;, &quot;value&quot;)
    .put(&quot;key2&quot;, &quot;value2&quot;)
    .build()

//Java8中可变集合（需引入Guava）
Lists.newArrayList(1, 2, 3)
Sets.newHashSet(1, 2, 3)
Maps.newHashMap(&quot;key&quot;, &quot;value&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;new ArrayList&amp;lt;&amp;gt;(){{
   add(1);
   add(2);
}};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%EF%BC%883%EF%BC%89%E9%9B%86%E5%90%88%E5%B5%8C%E5%A5%97&quot; tabindex=&quot;-1&quot;&gt;（3）集合嵌套&lt;/h3&gt;
&lt;p&gt;集合里的值如果是基础类型必须加上注释，说明集合里存的是什么，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//返回值: Map(key: 姓名, value: List(商品))
Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; res;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;超过2层集合对象封装必须封装成自定义类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//推荐
Map&amp;lt;String, List&amp;lt;Node&amp;gt;&amp;gt; res;

@Value
public static class Node {
    /**
    * 备注说明字段
    */
    String name;
    /**
    * 备注说明字段2
    */
    List&amp;lt;Integer&amp;gt; subjectIds;
}

//反例
Map&amp;lt;String, List&amp;lt;Pair&amp;lt;String, List&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt;&amp;gt; res;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;%E5%BC%82%E5%B8%B8%E5%8F%8A%E6%97%A5%E5%BF%97&quot; tabindex=&quot;-1&quot;&gt;异常及日志&lt;/h1&gt;
&lt;h2 id=&quot;1%E3%80%81%E5%BC%82%E5%B8%B8&quot; tabindex=&quot;-1&quot;&gt;1、异常&lt;/h2&gt;
&lt;p&gt;关于异常及错误码的思考，请参考笔者的另一篇文章：&lt;a href=&quot;https://lesofn.com/archives/errorcode-design&quot; target=&quot;_blank&quot;&gt;错误码设计思考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;异常除了抛异常还有一种场景，即：上层发起多个必要调用，某些可能失败，需要上层自行决定处理策略，推荐使用vavr中的Either类，Either使用建议：通常我们使用左值表示异常，而右值表示正常调用后的返回结果，即: Either&amp;lt;Throwable, Data&amp;gt;&lt;/p&gt;
&lt;h2 id=&quot;2%E3%80%81%E6%97%A5%E5%BF%97&quot; tabindex=&quot;-1&quot;&gt;2、日志&lt;/h2&gt;
&lt;h3 id=&quot;%EF%BC%881%EF%BC%89%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6&quot; tabindex=&quot;-1&quot;&gt;（1）日志文件&lt;/h3&gt;
&lt;p&gt;根据日志等级一般分为4个日志文件即可：debug.log、info.log、warn.log、error.log；&lt;/p&gt;
&lt;p&gt;如有特殊需求可根据场景单独建文件，比如请求日志：request.log、gc日志：gc.log等。&lt;/p&gt;
&lt;h3 id=&quot;%EF%BC%882%EF%BC%89%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E9%83%BD%E8%A6%81%E6%9C%89%E8%BF%BD%E8%B8%AA%E5%AD%97%E6%AE%B5&quot; tabindex=&quot;-1&quot;&gt;（2）所有用户日志都要有追踪字段&lt;/h3&gt;
&lt;p&gt;追踪字段包括：traceId、userId等，推荐使用MDC，常用的日志框架：Log4j、Logback都支持。&lt;/p&gt;
&lt;h3 id=&quot;%EF%BC%883%EF%BC%89%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96&quot; tabindex=&quot;-1&quot;&gt;（3）日志清理及持久化&lt;/h3&gt;
&lt;p&gt;本地日志根据磁盘大小，必须设置日志保存天数，否则有硬盘满风险；&lt;/p&gt;
&lt;p&gt;分布式环境为了方便查询，需要将日志采集到ES中查询；&lt;/p&gt;
&lt;p&gt;重要日志：比如审计日志、B端操作日志需要持久保存，一般是保存到Hive中；&lt;/p&gt;
&lt;h1 id=&quot;%E5%B7%A5%E5%85%B7%E7%AF%87&quot; tabindex=&quot;-1&quot;&gt;工具篇&lt;/h1&gt;
&lt;h2 id=&quot;1%E3%80%81json&quot; tabindex=&quot;-1&quot;&gt;1、JSON&lt;/h2&gt;
&lt;p&gt;推荐：使用Gson或Jackson；&lt;/p&gt;
&lt;p&gt;不推荐：Fastjson。Fastjson爆出的漏洞多。&lt;/p&gt;
&lt;h2 id=&quot;2%E3%80%81%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2&quot; tabindex=&quot;-1&quot;&gt;2、对象转换&lt;/h2&gt;
&lt;p&gt;推荐：MapStruct，根据注解编译成Java代码，没有反射，速度快；行为可预测，可查看编译后的Java代码查看转换逻辑；&lt;/p&gt;
&lt;p&gt;不推荐：BeanUtils、Dozer等。需要反射，行为不可预测，需要测试；&lt;/p&gt;
&lt;p&gt;不推荐：超过3个字段手动转换；&lt;/p&gt;
&lt;h2 id=&quot;3%E3%80%81%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;3、模板代码&lt;/h2&gt;
&lt;p&gt;推荐：Lombok，减少代码行数，提升开发效率，自动生成Java代码，没有性能损耗；&lt;/p&gt;
&lt;p&gt;不推荐：手动生成大量set、get方法；&lt;/p&gt;
&lt;h2 id=&quot;4%E3%80%81%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C&quot; tabindex=&quot;-1&quot;&gt;4、参数校验&lt;/h2&gt;
&lt;p&gt;推荐：hibernate Validation、spring-boot-starter-validation，可通过注解自动实现参数拦截；&lt;/p&gt;
&lt;p&gt;不推荐：每个入口（比如Controller）都copy大量重复的校验逻辑；&lt;/p&gt;
&lt;h2 id=&quot;5%E3%80%81%E7%BC%93%E5%AD%98&quot; tabindex=&quot;-1&quot;&gt;5、缓存&lt;/h2&gt;
&lt;p&gt;推荐：Spring Cache，通过注解控制缓存逻辑，适合常用的加缓存场景。&lt;/p&gt;
&lt;h1 id=&quot;%E8%AE%BE%E8%AE%A1%E7%AF%87&quot; tabindex=&quot;-1&quot;&gt;设计篇&lt;/h1&gt;
&lt;h2 id=&quot;1%E3%80%81%E6%AD%A3%E5%90%91%E8%AF%AD%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;1、正向语义&lt;/h2&gt;
&lt;p&gt;正向语义的好处在于使代码容易理解。 比如：&lt;strong&gt;if(judge()){…}&lt;/strong&gt;，很容易理解，即：判定成功则执行代码块。&lt;/p&gt;
&lt;p&gt;相反，如果是负向语义，思维还要转换一下，一般用于方法前置的参数校验。&lt;/p&gt;
&lt;p&gt;正向语义的应用场景有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法定义：方法名推荐：canPass、checkParam，返回true代表成功。 不推荐：比如isInvalidParam返回true代表失败，增加理解成本；&lt;/li&gt;
&lt;li&gt;Lambda表达式：filter 操作符中返回true是可以通过的元素；&lt;/li&gt;
&lt;li&gt;if和三目运算符：&lt;strong&gt;condition ?  doSomething() : doSomething2()&lt;/strong&gt; , 条件判定后紧跟的是判定成功后执行的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-&quot;&gt;if (!judge()) {
   doSomething2()
} else {
   doSomething()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;2%E3%80%81%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;2、防御式编程&lt;/h2&gt;
&lt;h3 id=&quot;%EF%BC%881%EF%BC%89%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C&quot; tabindex=&quot;-1&quot;&gt;（1）外部数据校验&lt;/h3&gt;
&lt;p&gt;外部传过来数据都需要校验，一般分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据流入：用户Http请求、RPC请求、MQ消费者等&lt;/li&gt;
&lt;li&gt;数据依赖：依赖的第三方RPC、数据库等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是数据流入，一定要首先校验数据合法性再往下执行，推荐hibernate Validation这类工具，可以很方便的做数据校验&lt;/p&gt;
&lt;p&gt;数据是数据依赖，一定要考虑各种网络、限流、背压等场景，做好熔断、降级保障。推荐建立防腐层，将第三方的限界上下文语义转换为当前上下文语义，避免理解上的歧义；&lt;/p&gt;
&lt;h3 id=&quot;%EF%BC%882%EF%BC%89null%E5%A4%84%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;（2）Null处理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于强依赖，没有返回值不行（比如查询数据库）：直接抛异常；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要反馈给上层处理：&lt;/p&gt;
&lt;p&gt;（1）可能返回null的场景：使用Optional；&lt;/p&gt;
&lt;p&gt;（2）上层需要感知信息异常信息：使用vavr中的Either；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可降级：&lt;/p&gt;
&lt;p&gt;（1）返回值是默认值：集合类返回，数字返回0或-1，字符串返回空字符串，其他场景自定义&lt;/p&gt;
&lt;p&gt;集合默认值：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Collections.emptyList()  //空List
Collections.emptySet()   //空Set
Collections.emptyMap()   //空Map
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;本文总结了Java开发常用的高级规范，暂时想到这么多，对文章中观点感兴趣，欢迎留言或加微信交流。&lt;/p&gt;
&lt;p&gt;作者博客链接：&lt;a href=&quot;https://lesofn.com/archives/java-coding-standard&quot; target=&quot;_blank&quot;&gt;Java研发规范(进阶版)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者简介：李少锋，美团Java技术专家，专注分享软件研发实践、架构思考。欢迎关注公共号：&lt;strong&gt;Java研发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B0%8F_1607785087313.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多精彩文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lesofn.com/archives/errorcode-design&quot; target=&quot;_blank&quot;&gt;错误码设计思考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lesofn.com/archives/threadpool-advance&quot; target=&quot;_blank&quot;&gt;Java线程池进阶&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lesofn.com/archives/mvn-to-ddd-architecture&quot; target=&quot;_blank&quot;&gt;从MVC到DDD的架构演进&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lesofn.com/archives/ping-tai-hua-jian-she-si-lu-qian-tan&quot; target=&quot;_blank&quot;&gt;平台化建设思路浅谈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lesofn.com/archives/gou-jian-ke-hui-gun-de-ying-yong-ji-shang-xian-checklist-shi-jian&quot; target=&quot;_blank&quot;&gt;构建可回滚的应用及上线checklist实践&lt;/a&gt;&lt;/p&gt;

    &lt;/article&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>44cc1c28679b1dbdb4e00c4bef9585af</guid>
<title>抓到Netty一个Bug，顺带来透彻地聊一下Netty是如何高效接收网络连接的</title>
<link>https://toutiao.io/k/3vfg8nb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本系列Netty源码解析文章基于 &lt;strong&gt;4.1.56.Final&lt;/strong&gt;版本&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个高性能网络通讯框架来说，最最重要也是最核心的工作就是如何高效的接收客户端连接，这就好比我们开了一个饭店，那么迎接客人就是饭店最重要的工作，我们要先把客人迎接进来，不能让客人一看人多就走掉，只要客人进来了，哪怕菜做的慢一点也没关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者就来为大家介绍下netty这块最核心的内容，看看netty是如何高效的接收客户端连接的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图为笔者在一个月黑风高天空显得那么深邃遥远的夜晚，闲来无事，于是捧起Netty关于如何接收连接这部分源码细细品读的时候，意外的发现了一个影响Netty接收连接吞吐的一个Bug。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5056451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaaNC5fjKg3IMlryAfebMyBHAWFicnubdnwnXTTHq3yyg2wIr6NPq9oPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;issue讨论.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是笔者就在Github提了一个&lt;span&gt;?&lt;/span&gt;Issue#11708，阐述了下这个Bug产生的原因以及导致的结果并和Netty的作者一起讨论了下修复措施。如上图所示。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Issue#11708：https://github.com/netty/netty/issues/11708&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里先不详细解释这个Issue，也不建议大家现在就打开这个Issue查看，笔者会在本文的介绍中随着源码深入的解读慢慢的为大家一层一层地拨开迷雾。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以在文章的开头把这个拎出来，笔者是想让大家带着怀疑，审视，欣赏，崇敬，敬畏的态度来一起品读世界顶级程序员编写的代码。由衷的感谢他们在这一领域做出的贡献。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，问题抛出来后，我们就带着这个疑问来开始本文的内容吧~~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7701612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaYswibX4udEqDRckSCoqEWgDicedibRoE1SLdqD56zxJqxCj5LfCWPbFNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;文章概要.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前文回顾&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照老规矩，再开始本文的内容之前，我们先来回顾下前边几篇文章的概要内容帮助大家梳理一个框架全貌出来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;笔者这里再次想和读者朋友们强调的是本文可以独立观看，并不依赖前边系列文章的内容，只是大家如果对相关细节部分感兴趣的话，可以在阅读完本文之后在去回看相关文章。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边的系列文章中，笔者为大家介绍了驱动Netty整个框架运转的核心引擎Reactor的创建，启动，运行的全流程。从现在开始Netty的整个核心框架就开始运转起来开始工作了，本文要介绍的主要内容就是Netty在启动之后要做的第一件事件：监听端口地址，高效接收客户端连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《聊聊Netty那些事儿之从内核角度看IO模型》&lt;/a&gt;一文中，我们是从整个网络框架的基石IO模型的角度整体阐述了下Netty的IO线程模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而Netty中的Reactor正是IO线程在Netty中的模型定义。Reactor在Netty中是以Group的形式出现的，分为:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主Reactor线程组也就是我们在启动代码中配置的&lt;code&gt;EventLoopGroup bossGroup&lt;/code&gt;,main reactor group中的reactor主要负责监听客户端连接事件，高效的处理客户端连接。也是本文我们要介绍的重点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从Reactor线程组也就是我们在启动代码中配置的&lt;code&gt;EventLoopGroup workerGroup&lt;/code&gt;，sub reactor group中的reactor主要负责处理客户端连接上的IO事件，以及异步任务的执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们得出Netty的整个IO模型如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.567741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNialDtXCOD5vvVGh56FT2yKauwTch6oYbrn1icPuYKaqY8nPibicWv66sQfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;netty中的reactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们讨论的重点就是MainReactorGroup的核心工作上图中所示的步骤1，步骤2，步骤3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在从整体上介绍完Netty的IO模型之后，我们又在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《Reactor在Netty中的实现(创建篇)》&lt;/a&gt;中完整的介绍了Netty框架的骨架主从Reactor组的搭建过程，阐述了Reactor是如何被创建出来的，并介绍了它的核心组件如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0638516992790936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaRn9ZX4dJLJdyxSEEXojs5lEmPNiaBfstFOG95KMGibJed4vo3xMhnE6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;971&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;thread&lt;/code&gt;即为Reactor中的IO线程，主要负责监听IO事件，处理IO任务，执行异步任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;selector&lt;/code&gt;则是JDK NIO对操作系统底层IO多路复用技术实现的封装。用于监听IO就绪事件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;taskQueue&lt;/code&gt;用于保存Reactor需要执行的异步任务，这些异步任务可以由用户在业务线程中向Reactor提交，也可以是Netty框架提交的一些自身核心的任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;scheduledTaskQueue&lt;/code&gt;则是保存Reactor中执行的定时任务。代替了原有的时间轮来执行延时任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;tailQueue&lt;/code&gt;保存了在Reactor需要执行的一些尾部收尾任务，在普通任务执行完后 Reactor线程会执行尾部任务，比如对Netty 的运行状态做一些统计数据，例如任务循环的耗时、占用物理内存的大小等等&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在骨架搭建完毕之后，我们随后又在在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;》一文中介绍了&lt;strong&gt;本文的主角服务端NioServerSocketChannel的创建，初始化，绑定端口地址，向main reactor注册监听&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的完整过程&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7161290322580646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaMNnpeQav9HykpMEYenDPdshUtLBMicYHd5F9HwloOsE6FfLVtGW0XRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor启动后的结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor如何处理OP_ACCEPT事件将会是本文的主要内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自此Netty框架的main reactor group已经启动完毕，开始准备监听OP_accept事件，当客户端连接上来之后，OP_ACCEPT事件活跃，main reactor开始处理OP_ACCEPT事件接收客户端连接了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而netty中的IO事件分为：OP_ACCEPT事件，OP_READ事件，OP_WRITE事件和OP_CONNECT事件，netty对于IO事件的监听和处理统一封装在Reactor模型中，这四个IO事件的处理过程也是我们后续文章中要单独拿出来介绍的，本文我们聚焦OP_ACCEPT事件的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而为了让大家能够对IO事件的处理有一个完整性的认识，笔者写了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484087&amp;amp;idx=1&amp;amp;sn=0c065780e0f05c23c8e6465ede86cba0&amp;amp;chksm=ce77c4f0f9004de63be369a664105708bc5975b52993f4a6df223caed34cc1ef6185a16acd75&amp;amp;token=997171731&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《一文聊透Netty核心引擎Reactor的运转架构》&lt;/a&gt;这篇文章，在文章中详细介绍了Reactor线程的整体运行框架。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6088709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiavrDh48SPMAM6BFPzvme6iceQT8aibcKY54GLfSOm2F7yCqynlkI9HkOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor线程运行时结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Reactor线程会在一个死循环中996不停的运转，在循环中会不断的轮询监听Selector上的IO事件，当IO事件活跃后，Reactor从Selector上被唤醒转去执行IO就绪事件的处理，在这个过程中我们引出了上述四种IO事件的处理入口函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processSelectedKey&lt;/span&gt;&lt;span&gt;(SelectionKey k, AbstractNioChannel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取Channel的底层操作类Unsafe&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!k.isValid()) {&lt;br/&gt;            ......如果SelectionKey已经失效则关闭对应的Channel......&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//获取IO就绪事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; readyOps = k.readyOps();&lt;br/&gt;            &lt;span&gt;//处理Connect事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; ops = k.interestOps();&lt;br/&gt;                &lt;span&gt;//移除对Connect事件的监听，否则Selector会一直通知&lt;/span&gt;&lt;br/&gt;                ops &amp;amp;= ~SelectionKey.OP_CONNECT;&lt;br/&gt;                k.interestOps(ops);&lt;br/&gt;                &lt;span&gt;//触发channelActive事件处理Connect事件&lt;/span&gt;&lt;br/&gt;                unsafe.finishConnect();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//处理Write事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_WRITE) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                ch.unsafe().forceFlush();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;             &lt;span&gt;//处理Read事件或者Accept事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != &lt;span&gt;0&lt;/span&gt; || readyOps == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                unsafe.read();&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (CancelledKeyException ignored) {&lt;br/&gt;            unsafe.close(unsafe.voidPromise());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者将会为大家重点介绍&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的处理入口函数&lt;code&gt;unsafe.read()&lt;/code&gt;的整个源码实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端连接完成三次握手之后，main reactor中的selector产生&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;活跃，main reactor随即被唤醒，来到了&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的处理入口函数开始接收客户端连接。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Main Reactor处理OP_ACCEPT事件&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9774193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaWfVAUiaQYd2Sebxwzf9VCWLhcbIISY1nBSug2YiaVEPewXhib8D8EUk2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;OP_ACCEPT事件活跃.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;Main Reactor&lt;/code&gt;轮询到&lt;code&gt;NioServerSocketChannel&lt;/code&gt;上的&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;就绪时，Main Reactor线程就会从&lt;code&gt;JDK Selector&lt;/code&gt;上的阻塞轮询API&lt;code&gt;selector.select(timeoutMillis)&lt;/code&gt;调用中返回。转而去处理&lt;code&gt;NioServerSocketChannel&lt;/code&gt;上的&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioEventLoop&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SingleThreadEventLoop&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processSelectedKey&lt;/span&gt;&lt;span&gt;(SelectionKey k, AbstractNioChannel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();&lt;br/&gt;        ..............省略.................&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; readyOps = k.readyOps();&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;               ..............处理OP_CONNECT事件.................&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_WRITE) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;              ..............处理OP_WRITE事件.................&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != &lt;span&gt;0&lt;/span&gt; || readyOps == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//本文重点处理OP_ACCEPT事件&lt;/span&gt;&lt;br/&gt;                unsafe.read();&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (CancelledKeyException ignored) {&lt;br/&gt;            unsafe.close(unsafe.voidPromise());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;处理IO就绪事件的入口函数&lt;code&gt;processSelectedKey&lt;/code&gt;中的参数&lt;code&gt;AbstractNioChannel ch&lt;/code&gt;正是Netty服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;。因为此时的执行线程为main reactor线程，而main reactor上注册的正是netty服务端NioServerSocketChannel负责监听端口地址，接收客户端连接。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过&lt;code&gt;ch.unsafe()&lt;/code&gt;获取到的NioUnsafe操作类正是NioServerSocketChannel中对底层JDK NIO ServerSocketChannel的Unsafe底层操作类。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;Unsafe接口&lt;/code&gt;是Netty对Channel底层操作行为的封装，比如NioServerSocketChannel的底层Unsafe操作类干的事情就是&lt;code&gt;绑定端口地址&lt;/code&gt;，&lt;code&gt;处理OP_ACCEPT事件&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们看到，Netty将&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;处理的入口函数封装在&lt;code&gt;NioServerSocketChannel&lt;/code&gt;里的底层操作类Unsafe的&lt;code&gt;read&lt;/code&gt;方法中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaVwgSgt5AkddHoicEO9er6tOogNfpjVyMysiaZeHCCTBRolMRpG5NDs2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而NioServerSocketChannel中的Unsafe操作类实现类型为&lt;code&gt;NioMessageUnsafe&lt;/code&gt;定义在上图继承结构中的&lt;code&gt;AbstractNioMessageChannel父类中&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们到&lt;code&gt;NioMessageUnsafe#read&lt;/code&gt;方法中来看下Netty对&lt;code&gt;OP_ACCPET事件&lt;/code&gt;的具体处理过程：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 接收客户端连接核心流程框架总览&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是按照老规矩，先从整体上把整个OP_ACCEPT事件的逻辑处理框架提取出来，让大家先总体俯视下流程全貌，然后在针对每个核心点位进行各个击破。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5717741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaDjWPOibC4yyvicZOQROz0VprRQdxN0scINPgOrCAVGxL1bUoV6ia4YJXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;接收客户端连接.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor线程是在一个&lt;code&gt;do...while{...}&lt;/code&gt;循环read loop中不断的调用JDK NIO &lt;code&gt;serverSocketChannel.accept()&lt;/code&gt;方法来接收完成三次握手的客户端连接&lt;code&gt;NioSocketChannel&lt;/code&gt;的，并将接收到的客户端连接NioSocketChannel临时保存在&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中，后续会服务端NioServerSocketChannel的pipeline中通过ChannelRead事件来传递，最终会在ServerBootstrapAcceptor这个ChannelHandler中被处理初始化，并将其注册到Sub Reator Group中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的read loop循环会被限定只能读取&lt;strong&gt;16次&lt;/strong&gt;，当main reactor从NioServerSocketChannel中读取客户端连接NioSocketChannel的次数达到&lt;strong&gt;16次&lt;/strong&gt;之后，无论此时是否还有客户端连接都不能在继续读取了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484087&amp;amp;idx=1&amp;amp;sn=0c065780e0f05c23c8e6465ede86cba0&amp;amp;chksm=ce77c4f0f9004de63be369a664105708bc5975b52993f4a6df223caed34cc1ef6185a16acd75&amp;amp;token=997171731&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《一文聊透Netty核心引擎Reactor的运转架构》&lt;/a&gt;一文中提到，netty对reactor线程压榨的比较狠，要干的事情很多，除了要监听轮询IO就绪事件，处理IO就绪事件，还需要执行用户和netty框架本省提交的异步任务和定时任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里的main reactor线程不能在read loop中无限制的执行下去，因为还需要分配时间去执行异步任务，不能因为无限制的接收客户端连接而耽误了异步任务的执行。所以这里将read loop的循环次数限定为16次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果main reactor线程在read loop中读取客户端连接NioSocketChannel的次数已经满了16次，即使此时还有客户端连接未接收，那么main reactor线程也不会再去接收了，而是转去执行异步任务，当异步任务执行完毕后，还会在回来执行剩余接收连接的任务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6088709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiavrDh48SPMAM6BFPzvme6iceQT8aibcKY54GLfSOm2F7yCqynlkI9HkOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor线程运行时结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor线程退出read loop循环的条件有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在限定的16次读取中，已经没有新的客户端连接要接收了。退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从NioServerSocketChannel中读取客户端连接的次数达到了16次，无论此时是否还有客户端连接都需要退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是Netty在接收客户端连接时的整体核心逻辑，下面笔者将这部分逻辑的核心源码实现框架提取出来，方便大家根据上述核心逻辑与源码中的处理模块对应起来，还是那句话，这里只需要总体把握核心处理流程，不需要读懂每一行代码，笔者会在文章的后边分模块来各个击破它们。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//存放连接建立后，创建的客户端SocketChannel&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Object&amp;gt; readBuf = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;//必须在Main Reactor线程中执行&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;assert&lt;/span&gt; &lt;span&gt;eventLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;.&lt;span&gt;inEventLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//注意下面的config和pipeline都是服务端ServerSocketChannel中的&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; ChannelConfig config = config();&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; ChannelPipeline pipeline = pipeline();&lt;br/&gt;            &lt;span&gt;//创建接收数据Buffer分配器（用于分配容量大小合适的byteBuffer用来容纳接收数据）&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//在接收连接的场景中，这里的allocHandle只是用于控制read loop的循环读取创建连接的次数。&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();&lt;br/&gt;            allocHandle.reset(config);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;boolean&lt;/span&gt; closed = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            Throwable exception = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;//底层调用NioServerSocketChannel-&amp;gt;doReadMessages 创建客户端SocketChannel&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;&lt;br/&gt;                        &lt;span&gt;//已无新的连接可接收则退出read loop&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            closed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;//统计在当前事件循环中已经读取到得Message数量（创建连接的个数）&lt;/span&gt;&lt;br/&gt;                        allocHandle.incMessagesRead(localRead);&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;span&gt;//判断是否已经读满16次&lt;/span&gt;&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                    exception = t;&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; size = readBuf.size();&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i ++) {&lt;br/&gt;                    readPending = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;//在NioServerSocketChannel对应的pipeline中传播ChannelRead事件&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//初始化客户端SocketChannel，并将其绑定到Sub Reactor线程组中的一个Reactor上&lt;/span&gt;&lt;br/&gt;                    pipeline.fireChannelRead(readBuf.get(i));&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//清除本次accept 创建的客户端SocketChannel集合&lt;/span&gt;&lt;br/&gt;                readBuf.clear();&lt;br/&gt;                allocHandle.readComplete();&lt;br/&gt;                &lt;span&gt;//触发readComplete事件传播&lt;/span&gt;&lt;br/&gt;                pipeline.fireChannelReadComplete();&lt;br/&gt;                ....................省略............&lt;br/&gt;            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                ....................省略............&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里首先要通过断言&lt;code&gt;assert eventLoop().inEventLoop()&lt;/code&gt;确保处理接收客户端连接的线程必须为Main Reactor 线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而main reactor中主要注册的是服务端NioServerSocketChannel，主要负责处理&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;，所以当前main reactor线程是在NioServerSocketChannel中执行接收连接的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里我们通过&lt;code&gt;config()&lt;/code&gt;获取到的是NioServerSocketChannel的属性配置类&lt;code&gt;NioServerSocketChannelConfig&lt;/code&gt;,它是在Reactor的启动阶段被创建出来的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt;&lt;span&gt;(ServerSocketChannel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//父类AbstractNioChannel中保存JDK NIO原生ServerSocketChannel以及要监听的事件OP_ACCEPT&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, channel, SelectionKey.OP_ACCEPT);&lt;br/&gt;        &lt;span&gt;//DefaultChannelConfig中设置用于Channel接收数据用的buffer-&amp;gt;AdaptiveRecvByteBufAllocator&lt;/span&gt;&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioServerSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, javaChannel().socket());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理这里通过&lt;code&gt;pipeline()&lt;/code&gt;获取到的也是NioServerSocketChannel中的&lt;code&gt;pipeline&lt;/code&gt;。它会在NioServerSocketChannel向main reactor注册成功之后被初始化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2814516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaLCnvGuX5Vnkyf8vov0T9bwuSrXAQAKQWoCQjzhgBbkfQ52iaDe6282Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;ServerChannelPipeline完整结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边提到main reactor线程会被限定只能在read loop中向NioServerSocketChannel读取16次客户端连接，所以在开始read loop之前，我们需要创建一个能够保存记录读取次数的对象，在每次read loop循环之后，可以根据这个对象来判断是否结束read loop。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个对象就是这里的 &lt;code&gt;RecvByteBufAllocator.Handle allocHandle&lt;/code&gt;专门用于统计read loop中接收客户端连接的次数，以及判断是否该结束read loop转去执行异步任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当这一切准备就绪之后，main reactor线程就开始在&lt;code&gt;do{....}while(...)&lt;/code&gt;循环中接收客户端连接了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 read loop中通过调用&lt;code&gt;doReadMessages函数&lt;/code&gt;接收完成三次握手的客户端连接，底层会调用到JDK NIO ServerSocketChannel的accept方法，从内核全连接队列中取出客户端连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回值&lt;code&gt;localRead&lt;/code&gt;表示接收到了多少客户端连接，客户端连接通过accept方法只会一个一个的接收，所以这里的&lt;code&gt;localRead&lt;/code&gt;正常情况下都会返回&lt;code&gt;1&lt;/code&gt;，当&lt;code&gt;localRead &amp;lt;= 0&lt;/code&gt;时意味着已经没有新的客户端连接可以接收了，本次main reactor接收客户端的任务到这里就结束了，跳出read loop。开始新的一轮IO事件的监听处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SocketChannel &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; ServerSocketChannel serverSocketChannel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; AccessController.doPrivileged(&lt;span&gt;new&lt;/span&gt; PrivilegedExceptionAction&amp;lt;SocketChannel&amp;gt;() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; SocketChannel &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; serverSocketChannel.accept();&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (PrivilegedActionException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; (IOException) e.getCause();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会将接收到的客户端连接占时存放到&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//存放连接建立后，创建的客户端SocketChannel&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Object&amp;gt; readBuf = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用&lt;code&gt;allocHandle.incMessagesRead&lt;/code&gt;统计本次事件循环中接收到的客户端连接个数，最后在read loop末尾通过&lt;code&gt;allocHandle.continueReading&lt;/code&gt;判断是否达到了限定的16次。从而决定main reactor线程是继续接收客户端连接还是转去执行异步任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor线程退出read loop的两个条件：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在限定的16次读取中，已经没有新的客户端连接要接收了。退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从NioServerSocketChannel中读取客户端连接的次数达到了16次，无论此时是否还有客户端连接都需要退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当满足以上两个退出条件时，main reactor线程就会退出read loop，由于在read loop中接收到的客户端连接全部暂存在&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中,随后开始遍历readBuf，在NioServerSocketChannel的pipeline中传播ChannelRead事件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                &lt;span&gt;int&lt;/span&gt; size = readBuf.size();&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i ++) {&lt;br/&gt;                    readPending = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;//NioServerSocketChannel对应的pipeline中传播read事件&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor.channelRead&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//初始化客户端SocketChannel，并将其绑定到Sub Reactor线程组中的一个Reactor上&lt;/span&gt;&lt;br/&gt;                    pipeline.fireChannelRead(readBuf.get(i));&lt;br/&gt;                }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终pipeline中的ChannelHandler(ServerBootstrapAcceptor)会响应ChannelRead事件，并在相应回调函数中初始化客户端NioSocketChannel，并将其注册到Sub Reactor Group中。此后客户端NioSocketChannel绑定到的sub reactor就开始监听处理客户端连接上的读写事件了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty整个接收客户端的逻辑过程如下图步骤1，2，3所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.567741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNialDtXCOD5vvVGh56FT2yKauwTch6oYbrn1icPuYKaqY8nPibicWv66sQfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;netty中的reactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上内容就是笔者提取出来的整体流程框架，下面我们来将其中涉及到的重要核心模块拆开，一个一个详细解读下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. RecvByteBufAllocator简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Reactor在处理对应Channel上的IO数据时，都会采用一个&lt;code&gt;ByteBuffer&lt;/code&gt;来接收Channel上的IO数据。而本小节要介绍的RecvByteBufAllocator正是用来分配ByteBuffer的一个分配器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得这个&lt;code&gt;RecvByteBufAllocator&lt;/code&gt;在哪里被创建的吗？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)》&lt;/a&gt;一文中，在介绍&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的创建过程中提到，对应Channel的配置类NioServerSocketChannelConfig也会随着NioServerSocketChannel的创建而创建。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt;&lt;span&gt;(ServerSocketChannel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, channel, SelectionKey.OP_ACCEPT);&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioServerSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, javaChannel().socket());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建&lt;code&gt;NioServerSocketChannelConfig&lt;/code&gt;的过程中会创建&lt;code&gt;RecvByteBufAllocator&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DefaultChannelConfig&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;(channel, &lt;span&gt;new&lt;/span&gt; AdaptiveRecvByteBufAllocator());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们看到NioServerSocketChannel中的RecvByteBufAllocator实际类型为&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;，顾名思义，这个类型的RecvByteBufAllocator可以根据Channel上每次到来的IO数据大小来自适应动态调整ByteBuffer的容量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于服务端NioServerSocketChannel来说，它上边的IO数据就是客户端的连接，它的长度和类型都是固定的，所以在接收客户端连接的时候并不需要这样的一个ByteBuffer来接收，我们会将接收到的客户端连接存放在&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于客户端NioSocketChannel来说，它上边的IO数据时客户端发送来的网络数据，长度是不定的，所以才会需要这样一个可以根据每次IO数据的大小来自适应动态调整容量的ByteBuffer来接收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么看起来这个RecvByteBufAllocator和本文的主题不是很关联，因为在接收连接的过程中并不会怎么用到它，这个类笔者还会在后面的文章中详细介绍，之所以这里把它拎出来单独介绍是因为它和本文开头提到的Bug有关系，这个Bug就是由这个类引起的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 RecvByteBufAllocator.Handle的获取&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中，我们是通过NioServerSocketChannel中的unsafe底层操作类来获取RecvByteBufAllocator.Handle的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractUnsafe&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Unsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; RecvByteBufAllocator.&lt;span&gt;Handle &lt;span&gt;recvBufAllocHandle&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (recvHandle == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                recvHandle = config().getRecvByteBufAllocator().newHandle();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; recvHandle;&lt;br/&gt;        }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到最终会在NioServerSocketChannel的配置类NioServerSocketChannelConfig中获取到&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultChannelConfig&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ChannelConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//用于Channel接收数据用的buffer分配器  类型为AdaptiveRecvByteBufAllocator&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; RecvByteBufAllocator rcvBufAllocator;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;中会创建自适应动态调整容量的ByteBuffer分配器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AdaptiveRecvByteBufAllocator&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;DefaultMaxMessagesRecvByteBufAllocator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Handle &lt;span&gt;newHandle&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HandleImpl(minIndex, maxIndex, initial);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HandleImpl&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MaxMessageHandle&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                  .................省略................&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;code&gt;newHandle&lt;/code&gt;方法返回的具体类型为&lt;code&gt;MaxMessageHandle&lt;/code&gt;，这个&lt;code&gt;MaxMessageHandle&lt;/code&gt;里边保存了每次从&lt;code&gt;Channel&lt;/code&gt;中读取&lt;code&gt;IO数据&lt;/code&gt;的容量指标，方便下次读取时分配合适大小的&lt;code&gt;buffer&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次在使用&lt;code&gt;allocHandle&lt;/code&gt;前需要调用&lt;code&gt;allocHandle.reset(config);&lt;/code&gt;重置里边的统计指标。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MaxMessageHandle&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ExtendedHandle&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; ChannelConfig config;&lt;br/&gt;        &lt;span&gt;//每次事件轮询时，最多读取16次&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxMessagePerRead;&lt;br/&gt;        &lt;span&gt;//本次事件轮询总共读取的message数,这里指的是接收连接的数量&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; totalMessages;&lt;br/&gt;        &lt;span&gt;//本次事件轮询总共读取的字节数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; totalBytesRead;&lt;br/&gt;&lt;br/&gt;       &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reset&lt;/span&gt;&lt;span&gt;(ChannelConfig config)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.config = config;&lt;br/&gt;            &lt;span&gt;//默认每次最多读取16次&lt;/span&gt;&lt;br/&gt;            maxMessagePerRead = maxMessagesPerRead();&lt;br/&gt;            totalMessages = totalBytesRead = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;maxMessagePerRead&lt;/strong&gt;：用于控制每次read loop里最大可以循环读取的次数，默认为16次，可在启动配置类&lt;code&gt;ServerBootstrap&lt;/code&gt;中通过&lt;code&gt;ChannelOption.MAX_MESSAGES_PER_READ&lt;/code&gt;选项设置。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ServerBootstrap b = &lt;span&gt;new&lt;/span&gt; ServerBootstrap();&lt;br/&gt;b.group(bossGroup, workerGroup)&lt;br/&gt;  .channel(NioServerSocketChannel&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;  .&lt;span&gt;option&lt;/span&gt;(&lt;span&gt;ChannelOption&lt;/span&gt;.&lt;span&gt;MAX_MESSAGES_PER_READ&lt;/span&gt;, 自定义次数)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;totalMessages&lt;/strong&gt;：用于统计read loop中总共接收的连接个数，每次read loop循环后会调用&lt;code&gt;allocHandle.incMessagesRead&lt;/code&gt;增加记录接收到的连接个数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;incMessagesRead&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; amt)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            totalMessages += amt;&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;totalBytesRead&lt;/strong&gt;：用于统计在read loop中总共接收到客户端连接上的数据大小，这个字段主要用于sub reactor在接收客户端NioSocketChannel上的网络数据用的，本文我们介绍的是main reactor接收客户端连接，所以这里并不会用到这个字段。这个字段会在sub reactor每次读取完NioSocketChannel上的网络数据时增加记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lastBytesRead&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; bytes)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            lastBytesRead = bytes;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (bytes &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                totalBytesRead += bytes;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MaxMessageHandler中还有一个非常重要的方法就是在每次read loop末尾会调用&lt;code&gt;allocHandle.continueReading()&lt;/code&gt;方法来判断读取连接次数是否已满16次，来决定main reactor线程是否退出循环。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                  &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;//底层调用NioServerSocketChannel-&amp;gt;doReadMessages 创建客户端SocketChannel&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            closed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;//统计在当前事件循环中已经读取到得Message数量（创建连接的个数）&lt;/span&gt;&lt;br/&gt;                        allocHandle.incMessagesRead(localRead);&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1879032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiadlS4S4GAOnWGfc4cAFuhpziasUfsEWHxBfh3nKvLNvBAFAWEAP2sJibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红框中圈出来的两个判断条件和本文主题无关，我们这里不需要关注，笔者会在后面的文章详细介绍。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;totalMessages &amp;lt; maxMessagePerRead&lt;/code&gt;：在本文的接收客户端连接场景中，这个条件用于判断main reactor线程在read loop中的读取次数是否超过了16次。如果超过16次就会返回false，main reactor线程退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;totalBytesRead &amp;gt; 0&lt;/code&gt;：用于判断当客户端NioSocketChannel上的OP_READ事件活跃时，sub reactor线程在read loop中是否读取到了网络数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上内容就是RecvByteBufAllocator.Handle在接收客户端连接场景下的作用，大家这里仔细看下这个&lt;code&gt;allocHandle.continueReading()&lt;/code&gt;方法退出循环的判断条件，再结合整个&lt;code&gt;do{....}while(...)&lt;/code&gt;接收连接循环体，感受下是否哪里有些不对劲？Bug即将出现~~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9494949494949495&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNia73S7DDn065yic2ibMIJ2CB70d9VuqkWqj9ydiaAk4yDaKbHZ5Z3rlfQfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;198&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 啊哈！！Bug ! !&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18333333333333332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNia1WWpXwfWKkgmhBW2wuBConIInzvqErmKhCjykxao8tPMQq4aMzRMWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;netty不论是在本文中处理接收客户端连接的场景还是在处理接收客户端连接上的网络数据场景都会在一个&lt;code&gt;do{....}while(...)&lt;/code&gt;循环read loop中不断的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时也都会利用在上一小节中介绍的&lt;code&gt;RecvByteBufAllocator.Handle&lt;/code&gt;来记录每次read loop接收到的连接个数和从连接上读取到的网络数据大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从而在read loop的末尾都会通过&lt;code&gt;allocHandle.continueReading()&lt;/code&gt;方法判断是否应该退出read loop循环结束连接的接收流程或者是结束连接上数据的读取流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是用于接收客户端连接的main reactor也好还是用于接收客户端连接上的网络数据的sub reactor也好，它们的运行框架都是一样的，只不过是具体分工不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以netty这里想用统一的&lt;code&gt;RecvByteBufAllocator.Handle&lt;/code&gt;来处理以上两种场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;RecvByteBufAllocator.Handle&lt;/code&gt;中的&lt;code&gt;totalBytesRead&lt;/code&gt;字段主要记录sub reactor线程在处理客户端NioSocketChannel中OP_READ事件活跃时，总共在read loop中读取到的网络数据，而这里是main reactor线程在接收客户端连接所以这个字段并不会被设置。totalBytesRead字段的值在本文中永远会是&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以无论同时有多少个客户端并发连接到服务端上，在接收连接的这个read loop中永远只会接受一个连接就会退出循环，因为&lt;code&gt;allocHandle.continueReading()方法&lt;/code&gt;中的判断条件&lt;code&gt;totalBytesRead &amp;gt; 0&lt;/code&gt;永远会返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                  &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;//底层调用NioServerSocketChannel-&amp;gt;doReadMessages 创建客户端SocketChannel&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            closed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;//统计在当前事件循环中已经读取到得Message数量（创建连接的个数）&lt;/span&gt;&lt;br/&gt;                        allocHandle.incMessagesRead(localRead);&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;而netty的本意是在这个read loop循环中尽可能多的去接收客户端的并发连接，同时又不影响main reactor线程执行异步任务。但是由于这个Bug，main reactor在这个循环中只执行一次就结束了。这也一定程度上就影响了netty的吞吐&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们想象下这样的一个场景，当有16个客户端同时并发连接到了服务端，这时NioServerSocketChannel上的&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;活跃，main reactor从Selector上被唤醒，随后执行&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioEventLoop&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SingleThreadEventLoop&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; selectCnt = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; { &lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; strategy;&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());&lt;br/&gt;                    &lt;span&gt;switch&lt;/span&gt; (strategy) {&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.CONTINUE:                  &lt;br/&gt;                          ............省略.........&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.BUSY_WAIT:&lt;br/&gt;&lt;br/&gt;                          ............省略.........&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.SELECT:&lt;br/&gt;                            ............监听轮询IO事件.........&lt;br/&gt;                    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                    ............省略.........&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                ............处理IO就绪事件.........&lt;br/&gt;                ............执行异步任务.........&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是由于这个Bug的存在，main reactor在接收客户端连接的这个read loop中只接收了一个客户端连接就匆匆返回了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;      &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        .........省略...........&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;     }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后根据下图中这个Reactor的运行结构去执行异步任务，随后绕一大圈又会回到&lt;code&gt;NioEventLoop#run&lt;/code&gt;方法中重新发起一轮OP_ACCEPT事件轮询。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6088709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiavrDh48SPMAM6BFPzvme6iceQT8aibcKY54GLfSOm2F7yCqynlkI9HkOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor线程运行时结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于现在还有15个客户端并发连接没有被接收，所以此时Main Reactor线程并不会在&lt;code&gt;selector.select()&lt;/code&gt;上阻塞，最终绕一圈又会回到&lt;code&gt;NioMessageUnsafe#read&lt;/code&gt;方法的&lt;code&gt;do{.....}while()&lt;/code&gt;循环。在接收一个连接之后又退出循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来我们可以在一次read loop中把这16个并发的客户端连接全部接收完毕的，因为这个Bug，main reactor需要不断的发起OP_ACCEPT事件的轮询，绕了很大一个圈子。&lt;strong&gt;同时也增加了许多不必要的selector.select()系统调用开销&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5056451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaaNC5fjKg3IMlryAfebMyBHAWFicnubdnwnXTTHq3yyg2wIr6NPq9oPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;issue讨论.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时大家在看这个&lt;span&gt;?&lt;/span&gt;Issue#11708中的讨论是不是就清晰很多了~~&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Issue#11708：https://github.com/netty/netty/issues/11708&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 Bug的修复&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;笔者在写这篇文章的时候，Netty最新版本是4.1.68.final，这个Bug在4.1.69.final中被修复。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3870967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiamkpfIdsVEQRQibNvxZYJJiaTQFHvmuiasd23LH4hjLazv0W1sibvr46nkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于该Bug产生的原因正是因为服务端NioServerSocketChannel（用于监听端口地址和接收客户端连接）和 客户端NioSocketChannel（用于通信）中的Config配置类混用了同一个ByteBuffer分配器&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;而导致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在新版本修复中专门为服务端ServerSocketChannel中的Config配置类引入了一个新的ByteBuffer分配器&lt;code&gt;ServerChannelRecvByteBufAllocator&lt;/code&gt;，专门用于服务端ServerSocketChannel接收客户端连接的场景。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29596774193548386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiav3Ks04F9n6vSaQ7UXVue9wPbIFbqyNQagBs7wgxicohYqZswtWNc8uA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23548387096774193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaC96ubib29hOP3CibOSE7tonFMkgTib9Hr0yiauIyZV5RuJic5GUQ38Fl9xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;ServerChannelRecvByteBufAllocator&lt;/code&gt;的父类&lt;code&gt;DefaultMaxMessagesRecvByteBufAllocator&lt;/code&gt;中引入了一个新的字段&lt;code&gt;ignoreBytesRead&lt;/code&gt;，用于表示是否忽略网络字节的读取，在创建服务端Channel配置类NioServerSocketChannelConfig的时候，这个字段会被赋值为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2701612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaQJG8bYicxmmJ7mia8kjSvVTUaKeod0A0iaOczCRVgav7GibyTbDCD4AP4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当main reactor线程在read loop循环中接收客户端连接的时候。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;      &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        .........省略...........&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;     }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在read loop循环的末尾就会采用从&lt;code&gt;ServerChannelRecvByteBufAllocator&lt;/code&gt;中创建的&lt;code&gt;MaxMessageHandle#continueReading&lt;/code&gt;方法来判断读取连接次数是否超过了16次。由于这里的&lt;code&gt;ignoreBytesRead == true&lt;/code&gt;这回我们就会忽略&lt;code&gt;totalBytesRead == 0&lt;/code&gt;的情况，从而使得接收连接的read loop得以继续地执行下去。在一个read loop中一次性把16个连接全部接收完毕。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1588709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiabJdRFibbDhoULfxwyl3njuSGPmiaw9KwAtB7hicggEYHwcUbMZe4BibEDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是对这个Bug产生的原因，以及发现的过程，最后修复的方案一个全面的介绍，因此笔者也出现在了netty 4.1.69.final版本发布公告里的thank-list中。哈哈，真是令人开心的一件事情~~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaEtpEzZGwchbkWicibbjCuOujhoHFk1GrxibqAKnfVkticFu04DQX8XyWkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上对netty接收客户端连接的全流程分析和对这个Bug来龙去脉以及修复方案的介绍，大家现在一定已经理解了整个接收连接的流程框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来笔者就把这个流程中涉及到的一些核心模块在单独拎出来从细节入手，为大家各个击破~~~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. doReadMessages接收客户端连接&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;ServerSocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;doReadMessages&lt;/span&gt;&lt;span&gt;(List&amp;lt;Object&amp;gt; buf)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        SocketChannel ch = SocketUtils.accept(javaChannel());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                buf.add(&lt;span&gt;new&lt;/span&gt; NioSocketChannel(&lt;span&gt;this&lt;/span&gt;, ch));&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;            logger.warn(&lt;span&gt;&quot;Failed to create a new channel from an accepted socket.&quot;&lt;/span&gt;, t);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                ch.close();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Throwable t2) {&lt;br/&gt;                logger.warn(&lt;span&gt;&quot;Failed to close a socket.&quot;&lt;/span&gt;, t2);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过&lt;code&gt;javaChannel()&lt;/code&gt;获取封装在Netty服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;中的&lt;code&gt;JDK 原生 ServerSocketChannel&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; ServerSocketChannel &lt;span&gt;javaChannel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (ServerSocketChannel) &lt;span&gt;super&lt;/span&gt;.javaChannel();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过&lt;code&gt;JDK NIO 原生&lt;/code&gt;的&lt;code&gt;ServerSocketChannel&lt;/code&gt;的&lt;code&gt;accept方法&lt;/code&gt;获取&lt;code&gt;JDK NIO 原生&lt;/code&gt;客户端连接&lt;code&gt;SocketChannel&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SocketChannel &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; ServerSocketChannel serverSocketChannel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; AccessController.doPrivileged(&lt;span&gt;new&lt;/span&gt; PrivilegedExceptionAction&amp;lt;SocketChannel&amp;gt;() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; SocketChannel &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; serverSocketChannel.accept();&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (PrivilegedActionException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; (IOException) e.getCause();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一步就是我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《聊聊Netty那些事儿之从内核角度看IO模型》&lt;/a&gt;介绍到的调用&lt;code&gt;监听Socket&lt;/code&gt;的&lt;code&gt;accept方法&lt;/code&gt;，内核会基于&lt;code&gt;监听Socket&lt;/code&gt;创建出来一个新的&lt;code&gt;Socket&lt;/code&gt;专门用于与客户端之间的网络通信这个我们称之为&lt;code&gt;客户端连接Socket&lt;/code&gt;。这里的&lt;code&gt;ServerSocketChannel&lt;/code&gt;就类似于&lt;code&gt;监听Socket&lt;/code&gt;。&lt;code&gt;SocketChannel&lt;/code&gt;就类似于&lt;code&gt;客户端连接Socket&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们在创建&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的时候，会将&lt;code&gt;JDK NIO 原生&lt;/code&gt;的&lt;code&gt;ServerSocketChannel&lt;/code&gt;设置为&lt;code&gt;非阻塞&lt;/code&gt;，所以这里当&lt;code&gt;ServerSocketChannel&lt;/code&gt;上有客户端连接时就会直接创建&lt;code&gt;SocketChannel&lt;/code&gt;，如果此时并没有客户端连接时&lt;code&gt;accept调用&lt;/code&gt;就会立刻返回&lt;code&gt;null&lt;/code&gt;并不会阻塞。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt;&lt;span&gt;(Channel parent, SelectableChannel ch, &lt;span&gt;int&lt;/span&gt; readInterestOp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(parent);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.ch = ch;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.readInterestOp = readInterestOp;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//设置Channel为非阻塞 配合IO多路复用模型&lt;/span&gt;&lt;br/&gt;            ch.configureBlocking(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;          ..........省略.............&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 创建客户端NioSocketChannel&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;ServerSocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;doReadMessages&lt;/span&gt;&lt;span&gt;(List&amp;lt;Object&amp;gt; buf)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        SocketChannel ch = SocketUtils.accept(javaChannel());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                buf.add(&lt;span&gt;new&lt;/span&gt; NioSocketChannel(&lt;span&gt;this&lt;/span&gt;, ch));&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;          .........省略.......&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里会根据&lt;code&gt;ServerSocketChannel&lt;/code&gt;的&lt;code&gt;accept&lt;/code&gt;方法获取到&lt;code&gt;JDK NIO 原生&lt;/code&gt;的&lt;code&gt;SocketChannel&lt;/code&gt;（用于底层真正与客户端通信的Channel），来创建Netty中的&lt;code&gt;NioSocketChannel&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioByteChannel&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;SocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioSocketChannel&lt;/span&gt;&lt;span&gt;(Channel parent, SocketChannel socket)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(parent, socket);&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, socket.socket());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;的过程其实和之前讲的创建服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;大体流程是一样的，我们这里只对客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;和服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;在创建过程中的不同之处做一个对比。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;具体细节部分大家可以在回看下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;一文中关于&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的创建的详细细节。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 对比NioSocketChannel与NioServerSocketChannel的不同&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1：Channel的层次不同&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们介绍Reactor的创建文章中，我们提到Netty中的&lt;code&gt;Channel&lt;/code&gt;是具有层次的。由于客户端NioSocketChannel是在main reactor接收连接时在服务端NioServerSocketChannel中被创建的，所以在创建客户端NioSocketChannel的时候会通过构造函数指定了parent属性为&lt;code&gt;NioServerSocketChanel&lt;/code&gt;。并将&lt;code&gt;JDK NIO 原生&lt;/code&gt;的&lt;code&gt;SocketChannel&lt;/code&gt;封装进Netty的客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在Reactor启动过程中创建&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的时候&lt;code&gt;parent属性&lt;/code&gt;指定是&lt;code&gt;null&lt;/code&gt;。因为它就是顶层的&lt;code&gt;Channel&lt;/code&gt;，负责创建客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt;&lt;span&gt;(ServerSocketChannel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, channel, SelectionKey.OP_ACCEPT);&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioServerSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, javaChannel().socket());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2：向Reactor注册的IO事件不同&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端NioSocketChannel向Sub Reactor注册的是&lt;code&gt;SelectionKey.OP_READ事件&lt;/code&gt;，而服务端NioServerSocketChannel向Main Reactor注册的是&lt;code&gt;SelectionKey.OP_ACCEPT事件&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioByteChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;AbstractNioByteChannel&lt;/span&gt;&lt;span&gt;(Channel parent, SelectableChannel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(parent, ch, SelectionKey.OP_READ);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;ServerSocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt;&lt;span&gt;(ServerSocketChannel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//父类AbstractNioChannel中保存JDK NIO原生ServerSocketChannel以及要监听的事件OP_ACCEPT&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, channel, SelectionKey.OP_ACCEPT);&lt;br/&gt;        &lt;span&gt;//DefaultChannelConfig中设置用于Channel接收数据用的buffer-&amp;gt;AdaptiveRecvByteBufAllocator&lt;/span&gt;&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioServerSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, javaChannel().socket());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3: 功能属性不同造成继承结构的不同&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6935483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaibVzdgIkicOvZJL9oNdgkTWsJTKwwKr71mN9DiaY16VzdQ1dmHtguRxOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;NioSocketChannel.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7596774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaJhrEYzibyhX4xH6g502Qobny1kJrRNvgo7j0duvaw9HC2f5eXQPqoTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;NioServerSocketChannel.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;继承的是&lt;code&gt;AbstractNioByteChannel&lt;/code&gt;，而服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;继承的是&lt;code&gt;AbstractNioMessageChannel&lt;/code&gt;。它们继承的这两个抽象类一个前缀是&lt;code&gt;Byte&lt;/code&gt;，一个前缀是&lt;code&gt;Message&lt;/code&gt;有什么区别吗？？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;主要处理的是服务端与客户端的通信，这里涉及到接收客户端发送来的数据，而&lt;code&gt;Sub Reactor线程&lt;/code&gt;从&lt;code&gt;NioSocketChannel&lt;/code&gt;中读取的正是网络通信数据单位为&lt;code&gt;Byte&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;主要负责处理&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;，创建用于通信的客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;。这时候客户端与服务端还没开始通信，所以&lt;code&gt;Main Reactor线程&lt;/code&gt;从&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的读取对象为&lt;code&gt;Message&lt;/code&gt;。这里的&lt;code&gt;Message&lt;/code&gt;指的就是底层的&lt;code&gt;SocketChannel&lt;/code&gt;客户端连接。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是&lt;code&gt;NioSocketChannel&lt;/code&gt;与&lt;code&gt;NioServerSocketChannel&lt;/code&gt;创建过程中的不同之处，后面的过程就一样了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在AbstractNioChannel 类中封装JDK NIO 原生的&lt;code&gt;SocketChannel&lt;/code&gt;，并将其底层的IO模型设置为&lt;code&gt;非阻塞&lt;/code&gt;，保存需要监听的IO事件&lt;code&gt;OP_READ&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt;&lt;span&gt;(Channel parent, SelectableChannel ch, &lt;span&gt;int&lt;/span&gt; readInterestOp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(parent);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.ch = ch;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.readInterestOp = readInterestOp;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//设置Channel为非阻塞 配合IO多路复用模型&lt;/span&gt;&lt;br/&gt;            ch.configureBlocking(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为客户端NioSocketChannel创建全局唯一的&lt;code&gt;channelId&lt;/code&gt;，创建客户端NioSocketChannel的底层操作类&lt;code&gt;NioByteUnsafe&lt;/code&gt;，创建pipeline。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;AbstractChannel&lt;/span&gt;&lt;span&gt;(Channel parent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.parent = parent;&lt;br/&gt;        &lt;span&gt;//channel全局唯一ID machineId+processId+sequence+timestamp+random&lt;/span&gt;&lt;br/&gt;        id = newId();&lt;br/&gt;        &lt;span&gt;//unsafe用于底层socket的读写操作&lt;/span&gt;&lt;br/&gt;        unsafe = newUnsafe();&lt;br/&gt;        &lt;span&gt;//为channel分配独立的pipeline用于IO事件编排&lt;/span&gt;&lt;br/&gt;        pipeline = newChannelPipeline();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在NioSocketChannelConfig的创建过程中，将NioSocketChannel的RecvByteBufAllocator类型设置为&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DefaultChannelConfig&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;(channel, &lt;span&gt;new&lt;/span&gt; AdaptiveRecvByteBufAllocator());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在Bug修复后的版本中服务端NioServerSocketChannel的RecvByteBufAllocator类型设置为&lt;code&gt;ServerChannelRecvByteBufAllocator&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终我们得到的客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;结构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaW2k5wARibzQC47D0ricxafnVibibz8usyYO8DIiagJObUwYIu1vS6fGW08A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;NioSocketChannel.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. ChannelRead事件的响应&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5717741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaDjWPOibC4yyvicZOQROz0VprRQdxN0scINPgOrCAVGxL1bUoV6ia4YJXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;接收客户端连接.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边介绍接收连接的整体核心流程框架的时候，我们提到main reactor线程是在一个&lt;code&gt;do{.....}while(...)&lt;/code&gt;循环read loop中不断的调用&lt;code&gt;ServerSocketChannel#accept&lt;/code&gt;方法来接收客户端的连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当满足退出read loop循环的条件有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在限定的16次读取中，已经没有新的客户端连接要接收了。退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从NioServerSocketChannel中读取客户端连接的次数达到了16次，无论此时是否还有客户端连接都需要退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor就会退出read loop循环，此时接收到的客户端连接NioSocketChannel暂存与&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Object&amp;gt; readBuf = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        ........省略.........&lt;br/&gt;                        &lt;span&gt;//底层调用NioServerSocketChannel-&amp;gt;doReadMessages 创建客户端SocketChannel&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        ........省略.........&lt;br/&gt;                        allocHandle.incMessagesRead(localRead);&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                    exception = t;&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; size = readBuf.size();&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i ++) {&lt;br/&gt;                    readPending = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                    pipeline.fireChannelRead(readBuf.get(i));&lt;br/&gt;                }&lt;br/&gt;                &lt;br/&gt;                  ........省略.........&lt;br/&gt;            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                  ........省略.........&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后main reactor线程会遍历&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中的NioSocketChannel，并在NioServerSocketChannel的pipeline中传播ChannelRead事件。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaLcRXsic4tugeyCbo2ZjSLhNtU09WGLEicbhFmqJBY7BDibKss8j2BTKibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;传播ChannelRead事件.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终&lt;code&gt;ChannelRead事件&lt;/code&gt;会传播到&lt;code&gt;ServerBootstrapAcceptor&lt;/code&gt;中，这里正是Netty处理客户端连接的核心逻辑所在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ServerBootstrapAcceptor&lt;/code&gt;主要的作用就是初始化客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;，并将客户端NioSocketChannel注册到&lt;code&gt;Sub Reactor Group&lt;/code&gt;中，并监听&lt;code&gt;OP_READ事件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ServerBootstrapAcceptor 中会初始化客户端NioSocketChannel的这些属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：从Reactor组&lt;code&gt;EventLoopGroup childGroup&lt;/code&gt;，用于初始化&lt;code&gt;NioSocketChannel&lt;/code&gt;中的&lt;code&gt;pipeline&lt;/code&gt;用到的&lt;code&gt;ChannelHandler childHandler&lt;/code&gt;，以及&lt;code&gt;NioSocketChannel&lt;/code&gt;中的一些&lt;code&gt;childOptions&lt;/code&gt;和&lt;code&gt;childAttrs&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServerBootstrapAcceptor&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ChannelInboundHandlerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; EventLoopGroup childGroup;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ChannelHandler childHandler;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;ChannelOption&amp;lt;?&amp;gt;, Object&amp;gt;[] childOptions;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;AttributeKey&amp;lt;?&amp;gt;, Object&amp;gt;[] childAttrs;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;channelRead&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx, Object msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; Channel child = (Channel) msg;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//向客户端NioSocketChannel的pipeline中&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//添加在启动配置类ServerBootstrap中配置的ChannelHandler&lt;/span&gt;&lt;br/&gt;            child.pipeline().addLast(childHandler);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//利用配置的属性初始化客户端NioSocketChannel&lt;/span&gt;&lt;br/&gt;            setChannelOptions(child, childOptions, logger);&lt;br/&gt;            setAttributes(child, childAttrs);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;/**&lt;br/&gt;                 * 1：在Sub Reactor线程组中选择一个Reactor绑定&lt;br/&gt;                 * 2：将客户端SocketChannel注册到绑定的Reactor上&lt;br/&gt;                 * 3：SocketChannel注册到sub reactor中的selector上，并监听OP_READ事件&lt;br/&gt;                 * */&lt;/span&gt;&lt;br/&gt;                childGroup.register(child).addListener(&lt;span&gt;new&lt;/span&gt; ChannelFutureListener() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;operationComplete&lt;/span&gt;&lt;span&gt;(ChannelFuture future)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (!future.isSuccess()) {&lt;br/&gt;                            forceClose(child, future.cause());&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                forceClose(child, t);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是在这里，netty会将我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;的启动示例程序中在ServerBootstrap中配置的客户端NioSocketChannel的所有属性（child前缀配置）初始化到NioSocketChannel中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;EchoServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PORT = Integer.parseInt(System.getProperty(&lt;span&gt;&quot;port&quot;&lt;/span&gt;, &lt;span&gt;&quot;8007&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// Configure the server.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//创建主从Reactor线程组&lt;/span&gt;&lt;br/&gt;        EventLoopGroup bossGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        EventLoopGroup workerGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; EchoServerHandler serverHandler = &lt;span&gt;new&lt;/span&gt; EchoServerHandler();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            ServerBootstrap b = &lt;span&gt;new&lt;/span&gt; ServerBootstrap();&lt;br/&gt;            b.group(bossGroup, workerGroup)&lt;span&gt;//配置主从Reactor&lt;/span&gt;&lt;br/&gt;             .channel(NioServerSocketChannel&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)//配置主&lt;span&gt;Reactor&lt;/span&gt;中的&lt;span&gt;channel&lt;/span&gt;类型&lt;br/&gt;             .&lt;span&gt;option&lt;/span&gt;(&lt;span&gt;ChannelOption&lt;/span&gt;.&lt;span&gt;SO_BACKLOG&lt;/span&gt;, 100)//设置主&lt;span&gt;Reactor&lt;/span&gt;中&lt;span&gt;channel&lt;/span&gt;的&lt;span&gt;option&lt;/span&gt;选项&lt;br/&gt;             .&lt;span&gt;handler&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;LoggingHandler&lt;/span&gt;(&lt;span&gt;LogLevel&lt;/span&gt;.&lt;span&gt;INFO&lt;/span&gt;))//设置主&lt;span&gt;Reactor&lt;/span&gt;中&lt;span&gt;Channel&lt;/span&gt;-&amp;gt;&lt;span&gt;pipline&lt;/span&gt;-&amp;gt;&lt;span&gt;handler&lt;/span&gt;&lt;br/&gt;             .&lt;span&gt;childHandler&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;ChannelInitializer&lt;/span&gt;&amp;lt;&lt;span&gt;SocketChannel&lt;/span&gt;&amp;gt;() &lt;/span&gt;{&lt;span&gt;//设置从Reactor中注册channel的pipeline&lt;/span&gt;&lt;br/&gt;                 &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                 &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initChannel&lt;/span&gt;&lt;span&gt;(SocketChannel ch)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                     ChannelPipeline p = ch.pipeline();&lt;br/&gt;                     &lt;span&gt;//p.addLast(new LoggingHandler(LogLevel.INFO));&lt;/span&gt;&lt;br/&gt;                     p.addLast(serverHandler);&lt;br/&gt;                 }&lt;br/&gt;             });&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// Start the server. 绑定端口启动服务，开始监听accept事件&lt;/span&gt;&lt;br/&gt;            ChannelFuture f = b.bind(PORT).sync();&lt;br/&gt;            &lt;span&gt;// Wait until the server socket is closed.&lt;/span&gt;&lt;br/&gt;            f.channel().closeFuture().sync();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// Shut down all event loops to terminate all threads.&lt;/span&gt;&lt;br/&gt;            bossGroup.shutdownGracefully();&lt;br/&gt;            workerGroup.shutdownGracefully();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上示例代码中通过ServerBootstrap配置的NioSocketChannel相关属性，会在Netty启动并开始初始化&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的时候将&lt;code&gt;ServerBootstrapAcceptor&lt;/code&gt;的创建初始化工作封装成&lt;code&gt;异步任务&lt;/code&gt;，然后在&lt;code&gt;NioServerSocketChannel&lt;/code&gt;注册到&lt;code&gt;Main Reactor&lt;/code&gt;中成功后执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServerBootstrap&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractBootstrap&lt;/span&gt;&amp;lt;&lt;span&gt;ServerBootstrap&lt;/span&gt;, &lt;span&gt;ServerChannel&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ................省略................&lt;br/&gt;&lt;br/&gt;        p.addLast(&lt;span&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;Channel&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initChannel&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Channel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;final&lt;/span&gt; ChannelPipeline pipeline = ch.pipeline();&lt;br/&gt;                ................省略................&lt;br/&gt;                ch.eventLoop().execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                        pipeline.addLast(&lt;span&gt;new&lt;/span&gt; ServerBootstrapAcceptor(&lt;br/&gt;                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在经过&lt;code&gt;ServerBootstrapAccptor#chanelRead回调&lt;/code&gt;的处理之后，此时客户端NioSocketChannel中pipeline的结构为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32661290322580644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNia6cNkLIW571QH74LhkCfFpibJSm1cwDQTQBcxClKehQVGRR3ibdP9Ea5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;客户端channel pipeline初始结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会将初始化好的客户端NioSocketChannel向Sub Reactor Group中注册，并监听&lt;code&gt;OP_READ事件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图中的步骤3所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.567741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNialDtXCOD5vvVGh56FT2yKauwTch6oYbrn1icPuYKaqY8nPibicWv66sQfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;netty中的reactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 向SubReactorGroup中注册NioSocketChannel&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                childGroup.register(child).addListener(&lt;span&gt;new&lt;/span&gt; ChannelFutureListener() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;operationComplete&lt;/span&gt;&lt;span&gt;(ChannelFuture future)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (!future.isSuccess()) {&lt;br/&gt;                            forceClose(child, future.cause());&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端NioSocketChannel向Sub Reactor Group注册的流程完全和服务端NioServerSocketChannel向Main Reactor Group注册流程一样。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于服务端NioServerSocketChannel的注册流程，笔者已经在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;一文中做出了详细的介绍，对相关细节感兴趣的同学可以在回看下。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里笔者在带大家简要回顾下整个注册过程并着重区别对比客户端NioSocetChannel与服务端NioServerSocketChannel注册过程中不同的地方。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 从Sub Reactor Group中选取一个Sub Reactor进行绑定&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MultithreadEventLoopGroup&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MultithreadEventExecutorGroup&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;EventLoopGroup&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ChannelFuture &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; next().register(channel);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; EventExecutor &lt;span&gt;next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; chooser.next();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 向绑定的Sub Reactor上注册NioSocketChannel&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SingleThreadEventLoop&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SingleThreadEventExecutor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;EventLoop&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ChannelFuture &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//注册channel到绑定的Reactor上&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; register(&lt;span&gt;new&lt;/span&gt; DefaultChannelPromise(channel, &lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ChannelFuture &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; ChannelPromise promise)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ObjectUtil.checkNotNull(promise, &lt;span&gt;&quot;promise&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//unsafe负责channel底层的各种操作&lt;/span&gt;&lt;br/&gt;        promise.channel().unsafe().register(&lt;span&gt;this&lt;/span&gt;, promise);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; promise;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当时我们在介绍&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的注册过程时，这里的&lt;code&gt;promise.channel()&lt;/code&gt;为&lt;code&gt;NioServerSocketChannel&lt;/code&gt;。底层的unsafe操作类为&lt;code&gt;NioMessageUnsafe&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;此时这里的&lt;code&gt;promise.channel()&lt;/code&gt;为&lt;code&gt;NioSocketChannel&lt;/code&gt;。底层的unsafe操作类为&lt;code&gt;NioByteUnsafe&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(EventLoop eventLoop, &lt;span&gt;final&lt;/span&gt; ChannelPromise promise)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            ..............省略....................&lt;br/&gt;            &lt;span&gt;//此时这里的eventLoop为Sub Reactor&lt;/span&gt;&lt;br/&gt;            AbstractChannel.&lt;span&gt;this&lt;/span&gt;.eventLoop = eventLoop;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;/**&lt;br/&gt;             * 执行channel注册的操作必须是Reactor线程来完成&lt;br/&gt;             *&lt;br/&gt;             * 1: 如果当前执行线程是Reactor线程，则直接执行register0进行注册&lt;br/&gt;             * 2：如果当前执行线程是外部线程，则需要将register0注册操作 封装程异步Task 由Reactor线程执行&lt;br/&gt;             * */&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (eventLoop.inEventLoop()) {&lt;br/&gt;                register0(promise);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    eventLoop.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                            register0(promise);&lt;br/&gt;                        }&lt;br/&gt;                    });&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                    ..............省略....................&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意此时传递进来的EventLoop eventLoop为Sub Reactor&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但此时的执行线程为&lt;code&gt;Main Reactor线程&lt;/code&gt;，并不是Sub Reactor线程（此时还未启动）&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里的&lt;code&gt;eventLoop.inEventLoop()&lt;/code&gt;返回的是&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2532258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiazIA5weroZkxOLyqsUBrN8Q1XP3NM5vBsFVdZXIGz1Il7FPprdZ4TNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;else分支&lt;/code&gt;中向绑定的Sub Reactor提交注册&lt;code&gt;NioSocketChannel&lt;/code&gt;的任务。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当注册任务提交后，此时绑定的&lt;code&gt;Sub Reactor线程&lt;/code&gt;启动。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.3 register0&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们又来到了Channel注册的老地方&lt;code&gt;register0方法&lt;/code&gt;。在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;中我们花了大量的篇幅介绍了这个方法。这里我们只对比&lt;code&gt;NioSocketChannel&lt;/code&gt;与&lt;code&gt;NioServerSocketChannel&lt;/code&gt;不同的地方。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register0&lt;/span&gt;&lt;span&gt;(ChannelPromise promise)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                ................省略..................&lt;br/&gt;                &lt;span&gt;boolean&lt;/span&gt; firstRegistration = neverRegistered;&lt;br/&gt;                &lt;span&gt;//执行真正的注册操作&lt;/span&gt;&lt;br/&gt;                doRegister();&lt;br/&gt;                &lt;span&gt;//修改注册状态&lt;/span&gt;&lt;br/&gt;                neverRegistered = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                registered = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                pipeline.invokeHandlerAddedIfNeeded();&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (isActive()) {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (firstRegistration) {&lt;br/&gt;                        &lt;span&gt;//触发channelActive事件&lt;/span&gt;&lt;br/&gt;                        pipeline.fireChannelActive();&lt;br/&gt;                    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (config().isAutoRead()) {&lt;br/&gt;                        beginRead();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                 ................省略..................&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 &lt;code&gt;doRegister()方法&lt;/code&gt;将NioSocketChannel注册到Sub Reactor中的&lt;code&gt;Selector&lt;/code&gt;上。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doRegister&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; selected = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (CancelledKeyException e) {&lt;br/&gt;                ...............省略...............&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是Netty客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;与JDK NIO 原生 SocketChannel关联的地方。此时注册的&lt;code&gt;IO事件&lt;/code&gt;依然是&lt;code&gt;0&lt;/code&gt;。目的也是只是为了获取NioSocketChannel在Selector中的&lt;code&gt;SelectionKey&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时通过&lt;code&gt;SelectableChannel#register&lt;/code&gt;方法将Netty自定义的NioSocketChannel（这里的this指针）附着在SelectionKey的attechment属性上，完成Netty自定义Channel与JDK NIO Channel的关系绑定。这样在每次对Selector进行IO就绪事件轮询时，Netty 都可以从 JDK NIO Selector返回的SelectionKey中获取到自定义的Channel对象（这里指的就是NioSocketChannel）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42258064516129035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaBHZIoOsiaAmdqQxwtXvIIgHxoYrpp2AeUMs5qEla9BoHU4wkg4Sgjqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;channel与SelectionKey对应关系.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后调用&lt;code&gt;pipeline.invokeHandlerAddedIfNeeded()&lt;/code&gt;回调客户端NioSocketChannel上pipeline中的所有ChannelHandler的&lt;code&gt;handlerAdded方法&lt;/code&gt;，此时&lt;code&gt;pipeline&lt;/code&gt;的结构中只有一个&lt;code&gt;ChannelInitializer&lt;/code&gt;。最终会在&lt;code&gt;ChannelInitializer#handlerAdded&lt;/code&gt;回调方法中初始化客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;的&lt;code&gt;pipeline&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32661290322580644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNia6cNkLIW571QH74LhkCfFpibJSm1cwDQTQBcxClKehQVGRR3ibdP9Ea5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;客户端channel pipeline初始结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChannelInitializer&lt;/span&gt;&amp;lt;&lt;span&gt;C&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Channel&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ChannelInboundHandlerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;handlerAdded&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ctx.channel().isRegistered()) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (initChannel(ctx)) {&lt;br/&gt;                &lt;span&gt;//初始化工作完成后，需要将自身从pipeline中移除&lt;/span&gt;&lt;br/&gt;                removeState(ctx);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initChannel&lt;/span&gt;&lt;span&gt;(C ch)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于对Channel中pipeline的详细初始化过程，对细节部分感兴趣的同学可以回看下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时客户端NioSocketChannel中的pipeline中的结构就变为了我们自定义的样子，在示例代码中我们自定义的&lt;code&gt;ChannelHandler&lt;/code&gt;为&lt;code&gt;EchoServerHandler&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32661290322580644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaTdUsySmibYW5g2lI0f8hN484CkfWrAjns8jib4vPJfrta5gpuxH5lyvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;客户端channel pipeline结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Sharable&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;EchoServerHandler&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ChannelInboundHandlerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;channelRead&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx, Object msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ctx.write(msg);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;channelReadComplete&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        ctx.flush();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;exceptionCaught&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx, Throwable cause)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// Close the connection when an exception is raised.&lt;/span&gt;&lt;br/&gt;        cause.printStackTrace();&lt;br/&gt;        ctx.close();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端NioSocketChannel中的pipeline初始化完毕后，netty就开始调用&lt;code&gt;safeSetSuccess(promise)方法&lt;/code&gt;回调&lt;code&gt;regFuture&lt;/code&gt;中注册的&lt;code&gt;ChannelFutureListener&lt;/code&gt;，通知客户端NioSocketChannel已经成功注册到Sub Reactor上了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;               childGroup.register(child).addListener(&lt;span&gt;new&lt;/span&gt; ChannelFutureListener() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;operationComplete&lt;/span&gt;&lt;span&gt;(ChannelFuture future)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (!future.isSuccess()) {&lt;br/&gt;                            forceClose(child, future.cause());&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在服务端NioServerSocketChannel注册的时候我们会在listener中向Main Reactor提交&lt;code&gt;bind绑定端口地址任务&lt;/code&gt;。但是在&lt;code&gt;NioSocketChannel&lt;/code&gt;注册的时候，只会在&lt;code&gt;listener&lt;/code&gt;中处理一下注册失败的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Sub Reactor线程通知ChannelFutureListener注册成功之后，随后就会调用&lt;code&gt;pipeline.fireChannelRegistered()&lt;/code&gt;在客户端NioSocketChannel的pipeline中传播&lt;code&gt;ChannelRegistered事件&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaAGdSxbwsoLP3mhiaKahLtKrMRdE9IXvMOyxgInz5UweSSrv8H9HwNKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;传播ChannelRegister事件.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里笔者重点要强调下&lt;/strong&gt;，在之前介绍NioServerSocketChannel注册的时候，我们提到因为此时NioServerSocketChannel并未绑定端口地址，所以这时的NioServerSocketChannel并未激活，这里的&lt;code&gt;isActive()&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;。&lt;code&gt;register0方法&lt;/code&gt;直接返回。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;服务端NioServerSocketChannel判断是否激活的标准为端口是否绑定成功。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;ServerSocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isActive&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; isOpen() &amp;amp;&amp;amp; javaChannel().socket().isBound();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;判断是否激活的标准为是否处于&lt;code&gt;Connected状态&lt;/code&gt;。那么显然这里肯定是处于&lt;code&gt;connected状态&lt;/code&gt;的。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isActive&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SocketChannel ch = javaChannel();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ch.isOpen() &amp;amp;&amp;amp; ch.isConnected();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;NioSocketChannel&lt;/code&gt;已经处于&lt;code&gt;connected状态&lt;/code&gt;，这里并不需要绑定端口，所以这里的&lt;code&gt;isActive()&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;           &lt;span&gt;if&lt;/span&gt; (isActive()) {&lt;br/&gt;                    &lt;span&gt;/**&lt;br/&gt;                     * 客户端SocketChannel注册成功后会走这里，在channelActive事件回调中注册OP_READ事件&lt;br/&gt;                     * */&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (firstRegistration) {&lt;br/&gt;                        &lt;span&gt;//触发channelActive事件&lt;/span&gt;&lt;br/&gt;                        pipeline.fireChannelActive();&lt;br/&gt;                    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (config().isAutoRead()) {&lt;br/&gt;                        .......省略..........&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后调用&lt;code&gt;pipeline.fireChannelActive()&lt;/code&gt;在NioSocketChannel中的pipeline传播&lt;code&gt;ChannelActive事件&lt;/code&gt;，最终在&lt;code&gt;pipeline&lt;/code&gt;的头结点&lt;code&gt;HeadContext&lt;/code&gt;中响应并注册&lt;code&gt;OP_READ事件&lt;/code&gt;到&lt;code&gt;Sub Reactor&lt;/code&gt;中的&lt;code&gt;Selector&lt;/code&gt;上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaaDWO56Rib0H2YViadZkbq3WErIBg6duwk22WMHcnt41ZWlS9WTtaYbcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;传播ChannelActive事件.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractChannel&lt;/span&gt; &lt;/span&gt;{ {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doBeginRead&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        ..............省略................&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; interestOps = selectionKey.interestOps();&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * 1：ServerSocketChannel 初始化时 readInterestOp设置的是OP_ACCEPT事件&lt;br/&gt;         * 2：SocketChannel 初始化时 readInterestOp设置的是OP_READ事件&lt;br/&gt;         * */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((interestOps &amp;amp; readInterestOp) == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//注册监听OP_ACCEPT或者OP_READ事件&lt;/span&gt;&lt;br/&gt;            selectionKey.interestOps(interestOps | readInterestOp);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意这里的&lt;code&gt;readInterestOp&lt;/code&gt;为客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;在初始化时设置的&lt;code&gt;OP_READ事件&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，Netty中的&lt;code&gt;Main Reactor&lt;/code&gt;接收连接的整个流程，我们就介绍完了，此时Netty中主从Reactor组的结构就变为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5040322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiabSEUJ3uzXNIS7OGAbpeQ3ib7ZoCM6RlzjglPlzJ4Pud3L0oWSzN0iaAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;主从Reactor组完整结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们介绍了&lt;code&gt;NioServerSocketChannel&lt;/code&gt;处理客户端连接事件的整个过程。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接收连接的整个处理框架。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;影响Netty接收连接吞吐的Bug产生的原因，以及修复的方案。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建并初始化客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;初始化&lt;code&gt;NioSocketChannel&lt;/code&gt;中的&lt;code&gt;pipeline&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;向&lt;code&gt;Sub Reactor&lt;/code&gt;注册的过程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中我们也对比了&lt;code&gt;NioServerSocketChannel&lt;/code&gt;与&lt;code&gt;NioSocketChannel&lt;/code&gt;在创建初始化以及后面向&lt;code&gt;Reactor&lt;/code&gt;注册过程中的差异之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;接收完毕并向&lt;code&gt;Sub Reactor&lt;/code&gt;注册成功后，那么接下来&lt;code&gt;Sub Reactor&lt;/code&gt;就开始监听注册其上的所有客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;的&lt;code&gt;OP_READ事件&lt;/code&gt;，并等待客户端向服务端发送网络数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面&lt;code&gt;Reactor&lt;/code&gt;的主角就该变为&lt;code&gt;Sub Reactor&lt;/code&gt;以及注册在其上的客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下篇文章，我们将会讨论Netty是如何接收网络数据的~~~~ 我们下篇文章见~~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ca1a6b2ff285b2bf1b94e7297035e382</guid>
<title>前端怎么样限制用户截图？</title>
<link>https://toutiao.io/k/80umzng</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;&lt;span&gt;前端阳光&lt;/span&gt;&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;加群&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，加入技术交流群交流群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/FaeDdIfeuq7LZw2cf0EBOhKF8W5kl3nzvRJnjf7rTnWnt4Kfpv5XyTXM6UaxUHniaH4PaJK7q1AicMiarW25qbibiag/0?wx_fmt=png&quot; data-cropx1=&quot;-0.29488005852616783&quot; data-cropx2=&quot;1670.985396758083&quot; data-cropy1=&quot;17.301038062283737&quot; data-cropy2=&quot;1169.5501730103806&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FaeDdIfeuq7LZw2cf0EBOhKF8W5kl3nzDM395V81rQsfH3zxwJLYdDtWwFibCOr4pkOMguMqOAOouk92MkfBj1Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做后台系统，或者版权比较重视的项目时，产品经常会提出这样的需求：能不能禁止用户截图？有经验的开发不会直接拒绝产品，而是进行引导。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先了解初始需求是什么？是内容数据过于敏感，严禁泄漏。还是内容泄漏后，需要溯源追责。不同的需求需要的方案也不同。来看看就限制用户截图，有哪些脑洞？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;有哪些脑洞&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;v站和某乎上的大佬给出了不少脑洞，我又加了点思路。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.基础方案，阻止右键保存和拖拽。&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案是最基础，当前可只能阻拦一些小白用户。如果是浏览器，分分钟调出控制台，直接找到图片url。还可以直接ctrl+p，进入打印模式，直接保存下来再裁减。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.失焦后加遮罩层&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案有点意思，看敏感信息时，必须鼠标点在某个按钮上，照片才完整显示。如果失去焦点图片显示不完整或者直接遮罩盖住。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.高速动态马赛克&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案是可行的，并且在一些网站已经得到了应用，在视频或者图片上随机插像素点，动态跑来跑去，对客户来说，每一时刻屏幕上显示的都是完整的图像，靠用户的视觉残留看图或者视频。即时手机拍照也拍不完全。实际应用需要优化的点还是挺多的。比如用手机录像就可以看到完整内容，只是增加了截图成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一个知乎上的方案效果。（原地址）：https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F417108591%2Fanswer%2F1450568587&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2311475409836066&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FaeDdIfeuq7LZw2cf0EBOhKF8W5kl3nzuREQ7l2eNYwICb4ZZOevxWhMQH33EzWRSlUHgLR8QnBOdRyTz2oe0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;610&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;正经需求vs方案&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实限制用户截图这个方案本身就不合理，除非整个设备都是定制的，在软件上阉割截图功能。为了这个需求添加更复杂的功能对于一些安全性没那么高的需求来说，有点本末倒置了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;下面聊聊正经方案：&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于后台系统敏感数据或者图片，主要是担心泄漏出去，可以采用斜45度七彩水印，想要完全去掉几乎不可能，就是观感比较差。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于图片版权，可以使用现在主流的盲水印，之前看过腾讯云提供的服务，当然成本比较高，如果版权需求较大，使用起来效果比较好。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;视频方案，tiktok下载下来的时候会有一个水印跑来跑去，当然这个是经过处理过的视频，非原画，画质损耗也比较高。Netflix等视频网站采用的是服务端权限控制，走的视频流，每次播放下载加密视频，同时获得短期许可，得到许可后在本地解密并播放，一旦停止播放后许可失效。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，除了类似于Android提供的截图API等底层功能，其他的功能实现都不完美。即使是底层控制了，一样可以拍照录像，没有完美的方案。不过还是可以做的相对安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还有什么新思路吗？有的话咱评论区见，欢迎点赞收藏关注，感谢！.&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者：正经程序员
链接：https://juejin.cn/post/7127829348689674253&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7727272727272727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/D7MJlTPSSr6Oa72xMxnt7RPsQtO1D57IAib9HJAvDCTkxtAqwY6KZACpmdKNmDicNjb0hKiaicZIx1F1gnibbJ0Zmmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;44&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;93731&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;优秀文章汇总：https://github.com/Sunny-lucking/blog&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;内推：https://www.yuque.com/peigehang/kb&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section label=&quot;Copyright © 2016 playhudong All Rights Reserved.&quot; donone=&quot;shifuMouseDownPayStyle(&#x27;shifu_t_042&#x27;)&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;技术交流群&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89226&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;我组建了技术交流群，里面有很多 大佬，欢迎进来交流、学习、共建。回复 &lt;strong&gt;加群 &lt;/strong&gt;即可。&lt;/span&gt;&lt;span&gt;&lt;span&gt;后台回复「&lt;/span&gt;&lt;strong&gt;电子书&lt;/strong&gt;&lt;span&gt;」即可免费获取&lt;strong&gt; 27本&lt;/strong&gt; 精选的前端电子书！回复&lt;strong&gt;内推&lt;/strong&gt;，可内推各厂内推码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;173&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;173&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FaeDdIfeuq5vzFgUpy4cXLtZB2KCu9eJCczNsLMiaFYVmbV2F6TVJKh4Kjl9ErKxWERyFOyv9AtNmepkLPjVvJw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt; “分享、点赞&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;在看” 支持一波👍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>