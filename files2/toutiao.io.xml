<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e2235b2e708d6955b6fdb537037cae34</guid>
<title>面试官：web 实时推送消息，有哪些方案？</title>
<link>https://toutiao.io/k/y66h60p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;大家好，我是君哥。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我有一个朋友～&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做了一个小破站，现在要实现一个站内信web消息推送的功能，对，就是下图这个小红点，一个很常用的功能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08426270136307311&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSibqlHGN5Qicqj3F2p4MeqIw7tYdzic8cuicibrjF20Tm1ZzZiaOkF1I79RHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;807&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过他还没想好用什么方式做，这里我帮他整理了一下几种方案，并简单做了实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6847946725860156&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSiaAu7jichUzILqRym4eQLia8et2DUSGsF4KUgcTSGOgp6Ysj7y5mCKmrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;901&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是消息推送（push）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息推送(&lt;code&gt;push&lt;/code&gt;)通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备APP进行的主动消息推送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息推送一般又分为&lt;code&gt;web端消息推送&lt;/code&gt;和&lt;code&gt;移动端消息推送&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3170940170940171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSOj5s7qmxYIQzsVhUC880L0rQ10kRnicamw1K8kM1Nk3Uvt1du6wRS5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的这种属于移动端消息推送，web端消息推送常见的诸如站内信、未读邮件数量、监控报警数量等，应用的也非常广泛。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2620320855614973&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSfvGO7yweiaM1w7hsCVqE1ncKlwRib2LCy8FC8KztefosDiap30yIQ0RMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1122&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，只要触发某个事件（主动分享了资源或者后台主动推送消息），web页面的通知小红点就会实时的&lt;code&gt;+1&lt;/code&gt;就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42444444444444446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSia0ibhpec9FQ9ibMSw4uibQBibfECW8RBWiaaykIeRGw5UeoRXPcySy8hU3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息推送无非是推（&lt;code&gt;push&lt;/code&gt;）和拉（&lt;code&gt;pull&lt;/code&gt;）两种形式，下边我们逐个了解下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;短轮询&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轮询(&lt;code&gt;polling&lt;/code&gt;)应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为&lt;code&gt;短轮询&lt;/code&gt;和&lt;code&gt;长轮询&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;短轮询很好理解，指定的时间间隔，由浏览器向服务器发出&lt;code&gt;HTTP&lt;/code&gt;请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单的JS定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;setInterval(() =&amp;gt; {&lt;br/&gt;  // 方法请求&lt;br/&gt;  messageCount().&lt;span&gt;then&lt;/span&gt;((res) =&amp;gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (res.code === 200) {&lt;br/&gt;          this.messageCount = res.data&lt;br/&gt;      }&lt;br/&gt;  })&lt;br/&gt;}, 1000);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7565011820330969&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSj5ibCJZ7QSJl1ew8wseq5FQRt1icOHiawzKmM11suvkzxOreib8tesG52w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;846&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;长轮询&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如&lt;code&gt;Nacos&lt;/code&gt;和&lt;code&gt;apollo&lt;/code&gt;配置中心，消息队列&lt;code&gt;kafka&lt;/code&gt;、&lt;code&gt;RocketMQ&lt;/code&gt;中都有用到长轮询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNTM4NzAyNg==&amp;amp;mid=2247494748&amp;amp;idx=1&amp;amp;sn=2cccdbc6269ea01e75012340af1496ef&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Nacos配置中心交互模型是push还是pull？&lt;/a&gt;一文中我详细介绍过&lt;code&gt;Nacos&lt;/code&gt;长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我使用&lt;code&gt;apollo&lt;/code&gt;配置中心实现长轮询的方式，应用了一个类&lt;code&gt;DeferredResult&lt;/code&gt;，它是在&lt;code&gt;servelet3.0&lt;/code&gt;后经过Spring封装提供的一种异步请求机制，直意就是延迟结果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5174193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLShESibst1xEBuynGicCSDCFaMIUZBJy6AQMnIMJmxH16W8pby9Ryhteag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1550&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DeferredResult&lt;/code&gt;可以允许容器线程快速释放占用的资源，不阻塞请求线程，以此接受更多的请求提升系统的吞吐量，然后启动异步工作线程处理真正的业务逻辑，处理完成调用&lt;code&gt;DeferredResult.setResult(200)&lt;/code&gt;提交响应结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下边我们用长轮询来实现消息推送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为一个ID可能会被多个长轮询请求监听，所以我采用了&lt;code&gt;guava&lt;/code&gt;包提供的&lt;code&gt;Multimap&lt;/code&gt;结构存放长轮询，一个key可以对应多个value。一旦监听到key发生变化，对应的所有长轮询都会响应。前端得到非请求超时的状态码，知晓数据变更，主动查询未读消息数接口，更新页面数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Controller&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/polling&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PollingController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 存放监听某个Id的长轮询集合&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 线程同步结构&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Multimap&amp;lt;String, DeferredResult&amp;lt;String&amp;gt;&amp;gt; watchRequests = Multimaps.synchronizedMultimap(HashMultimap.create());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 公众号：程序员小富&lt;br/&gt;     * 设置监听&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(path = &lt;span&gt;&quot;watch/{id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; DeferredResult&amp;lt;String&amp;gt; &lt;span&gt;watch&lt;/span&gt;&lt;span&gt;(@PathVariable String id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 延迟对象设置超时时间&lt;/span&gt;&lt;br/&gt;        DeferredResult&amp;lt;String&amp;gt; deferredResult = &lt;span&gt;new&lt;/span&gt; DeferredResult&amp;lt;&amp;gt;(TIME_OUT);&lt;br/&gt;        &lt;span&gt;// 异步请求完成时移除 key，防止内存溢出&lt;/span&gt;&lt;br/&gt;        deferredResult.onCompletion(() -&amp;gt; {&lt;br/&gt;            watchRequests.remove(id, deferredResult);&lt;br/&gt;        });&lt;br/&gt;        &lt;span&gt;// 注册长轮询请求&lt;/span&gt;&lt;br/&gt;        watchRequests.put(id, deferredResult);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; deferredResult;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 公众号：程序员小富&lt;br/&gt;     * 变更数据&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(path = &lt;span&gt;&quot;publish/{id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;publish&lt;/span&gt;&lt;span&gt;(@PathVariable String id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 数据变更 取出监听ID的所有长轮询请求，并一一响应处理&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (watchRequests.containsKey(id)) {&lt;br/&gt;            Collection&amp;lt;DeferredResult&amp;lt;String&amp;gt;&amp;gt; deferredResults = watchRequests.get(id);&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (DeferredResult&amp;lt;String&amp;gt; deferredResult : deferredResults) {&lt;br/&gt;                deferredResult.setResult(&lt;span&gt;&quot;我更新了&quot;&lt;/span&gt; + &lt;span&gt;new&lt;/span&gt; Date());&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当请求超过设置的超时时间，会抛出&lt;code&gt;AsyncRequestTimeoutException&lt;/code&gt;异常，这里直接用&lt;code&gt;@ControllerAdvice&lt;/code&gt;全局捕获统一返回即可，前端获取约定好的状态码后再次发起长轮询请求，如此往复调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@ControllerAdvice&lt;br/&gt;public class AsyncRequestTimeoutHandler {&lt;br/&gt;&lt;br/&gt;    @ResponseStatus(HttpStatus.NOT_MODIFIED)&lt;br/&gt;    @ResponseBody&lt;br/&gt;    @ExceptionHandler(AsyncRequestTimeoutException.class)&lt;br/&gt;    public String asyncRequestTimeoutHandler(AsyncRequestTimeoutException e) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;异步请求超时&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;304&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来测试一下，首先页面发起长轮询请求&lt;code&gt;/polling/watch/10086&lt;/code&gt;监听消息更变，请求被挂起，不变更数据直至超时，再次发起了长轮询请求；紧接着手动变更数据&lt;code&gt;/polling/publish/10086&lt;/code&gt;，长轮询得到响应，前端处理业务逻辑完成后再次发起请求，如此循环往复。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5844255975327679&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLS37z8ib4hPjQutH4jv0hzY2VibR4YYqgjT5lJTrNmI4T3KibEiaOfBZSq2A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1297&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;长轮询相比于短轮询在性能上提升了很多，但依然会产生较多的请求，这是它的一点不完美的地方。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;iframe流&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;iframe流就是在页面中插入一个隐藏的&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;标签，通过在&lt;code&gt;src&lt;/code&gt;中请求消息数量API接口，由此在服务端和客户端之间创建一条长连接，服务端持续向&lt;code&gt;iframe&lt;/code&gt;传输数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;传输的数据通常是&lt;code&gt;HTML&lt;/code&gt;、或是内嵌的&lt;code&gt;javascript&lt;/code&gt;脚本，来达到实时更新页面的效果。&lt;/p&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.531317494600432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSNmFzSyv1LDCWaTDgTvUlsHhPEXtIMxJ1hiaaGkKBZA6R3Kje2xYo6fg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式实现简单，前端只要一个&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;标签搞定了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;iframe src=&lt;span&gt;&quot;/iframe/message&quot;&lt;/span&gt; style=&lt;span&gt;&quot;display:none&quot;&lt;/span&gt;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端直接组装html、js脚本数据向&lt;code&gt;response&lt;/code&gt;写入就行了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Controller&lt;br/&gt;@RequestMapping(&lt;span&gt;&quot;/iframe&quot;&lt;/span&gt;)&lt;br/&gt;public class IframeController {&lt;br/&gt;    @GetMapping(path = &lt;span&gt;&quot;message&quot;&lt;/span&gt;)&lt;br/&gt;    public void message(HttpServletResponse response) throws IOException, InterruptedException {&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            response.setHeader(&lt;span&gt;&quot;Pragma&quot;&lt;/span&gt;, &lt;span&gt;&quot;no-cache&quot;&lt;/span&gt;);&lt;br/&gt;            response.setDateHeader(&lt;span&gt;&quot;Expires&quot;&lt;/span&gt;, 0);&lt;br/&gt;            response.setHeader(&lt;span&gt;&quot;Cache-Control&quot;&lt;/span&gt;, &lt;span&gt;&quot;no-cache,no-store&quot;&lt;/span&gt;);&lt;br/&gt;            response.setStatus(HttpServletResponse.SC_OK);&lt;br/&gt;            response.getWriter().&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot; &amp;lt;script type=\&quot;text/javascript\&quot;&amp;gt;\n&quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;parent.document.getElementById(&#x27;clock&#x27;).innerHTML = \&quot;&quot;&lt;/span&gt; + count.get() + &lt;span&gt;&quot;\&quot;;&quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;parent.document.getElementById(&#x27;count&#x27;).innerHTML = \&quot;&quot;&lt;/span&gt; + count.get() + &lt;span&gt;&quot;\&quot;;&quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;&amp;lt;/script&amp;gt;&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我个人不推荐，因为它在浏览器上会显示请求未加载完，图标会不停旋转，简直是强迫症杀手。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6464088397790055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSbFJRZklR7icKUI8tCIodXcNBibqRy41hcia42yIwtuvCsqISxDGjh1I0Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;362&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SSE (我的方式)&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人可能不知道，服务端向客户端推送消息，其实除了可以用&lt;code&gt;WebSocket&lt;/code&gt;这种耳熟能详的机制外，还有一种服务器发送事件(&lt;code&gt;Server-sent events&lt;/code&gt;)，简称&lt;code&gt;SSE&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SSE&lt;/code&gt;它是基于&lt;code&gt;HTTP&lt;/code&gt;协议的，我们知道一般意义上的HTTP协议是无法做到服务端主动向客户端推送消息的，但SSE是个例外，它变换了一种思路。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42857142857142855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSDAUZjvsvST8wO356lbp8NiaeMhoIqvoO8e6vL4uHU4RMficwBPSn1wwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SSE在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是&lt;code&gt;text/event-stream&lt;/code&gt;类型的数据流信息，在有数据变更时从服务器流式传输到客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5182795698924731&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSHpEjFU6Qmt0LOV1SHawOc3rawPDxxZjVxNibiaUQ9fb7TTb5ZGyMXHwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1395&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SSE&lt;/code&gt;与&lt;code&gt;WebSocket&lt;/code&gt;作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;SSE 是基于HTTP协议的，它们不需要特殊的协议或服务器实现即可工作；&lt;code&gt;WebSocket&lt;/code&gt;需单独服务器来处理协议。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SSE 单向通信，只能由服务端向客户端单向通信；webSocket全双工通信，即通信的双方可以同时发送和接受信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SSE 实现简单开发成本低，无需引入其他组件；WebSocket传输数据需做二次解析，开发门槛高一些。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SSE 默认支持断线重连；WebSocket则需要自己实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket默认支持传送二进制数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SSE 与 WebSocket 该如何选择？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;技术并没有好坏之分，只有哪个更合适&lt;/p&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SSE好像一直不被大家所熟知，一部分原因是出现了WebSockets，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，&lt;code&gt;SEE&lt;/code&gt;不管是从实现的难易和成本上都更加有优势。此外，SSE 具有&lt;code&gt;WebSockets&lt;/code&gt;在设计上缺乏的多种功能，例如：&lt;code&gt;自动重新连接&lt;/code&gt;、&lt;code&gt;事件ID&lt;/code&gt;和&lt;code&gt;发送任意事件&lt;/code&gt;的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端只需进行一次HTTP请求，带上唯一ID，打开事件流，监听服务端推送的事件就可以了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; source = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; userId = &lt;span&gt;7777&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;window&lt;/span&gt;.EventSource) {&lt;br/&gt;        &lt;span&gt;// 建立连接&lt;/span&gt;&lt;br/&gt;        source = &lt;span&gt;new&lt;/span&gt; EventSource(&lt;span&gt;&#x27;http://localhost:7777/sse/sub/&#x27;&lt;/span&gt;+userId);&lt;br/&gt;        setMessageInnerHTML(&lt;span&gt;&quot;连接用户=&quot;&lt;/span&gt; + userId);&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * 连接一旦建立，就会触发open事件&lt;br/&gt;         * 另一种写法：source.onopen = function (event) {}&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        source.addEventListener(&lt;span&gt;&#x27;open&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;            setMessageInnerHTML(&lt;span&gt;&quot;建立连接。。。&quot;&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * 客户端收到服务器发来的数据&lt;br/&gt;         * 另一种写法：source.onmessage = function (event) {}&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        source.addEventListener(&lt;span&gt;&#x27;message&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;            setMessageInnerHTML(e.data);&lt;br/&gt;        });&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        setMessageInnerHTML(&lt;span&gt;&quot;你的浏览器不支持SSE&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&amp;lt;&lt;span&gt;/script&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端的实现更简单，创建一个&lt;code&gt;SseEmitter&lt;/code&gt;对象放入&lt;code&gt;sseEmitterMap&lt;/code&gt;进行管理&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, SseEmitter&amp;gt; sseEmitterMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 创建连接&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt;: 2022/7/12 14:51&lt;br/&gt; * &lt;span&gt;@auther&lt;/span&gt;: 公众号：程序员小富&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SseEmitter &lt;span&gt;connect&lt;/span&gt;&lt;span&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 设置超时时间，0表示不过期。默认30秒&lt;/span&gt;&lt;br/&gt;        SseEmitter sseEmitter = &lt;span&gt;new&lt;/span&gt; SseEmitter(&lt;span&gt;0L&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 注册回调&lt;/span&gt;&lt;br/&gt;        sseEmitter.onCompletion(completionCallBack(userId));&lt;br/&gt;        sseEmitter.onError(errorCallBack(userId));&lt;br/&gt;        sseEmitter.onTimeout(timeoutCallBack(userId));&lt;br/&gt;        sseEmitterMap.put(userId, sseEmitter);&lt;br/&gt;        count.getAndIncrement();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; sseEmitter;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        log.info(&lt;span&gt;&quot;创建新的sse连接异常，当前用户：{}&quot;&lt;/span&gt;, userId);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 给指定用户发送消息&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt;: 2022/7/12 14:51&lt;br/&gt; * &lt;span&gt;@auther&lt;/span&gt;: 公众号：程序员小富&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendMessage&lt;/span&gt;&lt;span&gt;(String userId, String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (sseEmitterMap.containsKey(userId)) {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            sseEmitterMap.get(userId).send(message);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            log.error(&lt;span&gt;&quot;用户[{}]推送异常:{}&quot;&lt;/span&gt;, userId, e.getMessage());&lt;br/&gt;            removeUser(userId);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们模拟服务端推送消息，看下客户端收到了消息，和我们预期的效果一致。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5540958268933539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSDEGw1icFuuzSmKOeaqnvntXibzrbCT0y4LJ5wantI00yRPKCZ41BI1OA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1294&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt; SSE不支持&lt;code&gt;IE&lt;/code&gt;浏览器，对其他主流浏览器兼容性做的还不错。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31432748538011696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSZpKUPKh2CqeNVaG3lD7teeibAG3dWyulZrE7TPrfo2yp9J8Yzx7zLibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MQTT&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是 MQTT协议？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MQTT&lt;/code&gt; 全称(Message Queue Telemetry Transport)：一种基于发布/订阅（&lt;code&gt;publish&lt;/code&gt;/&lt;code&gt;subscribe&lt;/code&gt;）模式的&lt;code&gt;轻量级&lt;/code&gt;通讯协议，通过订阅相应的主题来获取消息，是物联网（&lt;code&gt;Internet of Thing&lt;/code&gt;）中的一个标准传输协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该协议将消息的发布者（&lt;code&gt;publisher&lt;/code&gt;）与订阅者（&lt;code&gt;subscriber&lt;/code&gt;）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的MQ有点类似。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.52734375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSokHnrFibYro6xsia2orma1qI0nkxKTK113ACcBBwfiaGhk1PKfb8VxIPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;TCP&lt;/code&gt;协议位于传输层，&lt;code&gt;MQTT&lt;/code&gt; 协议位于应用层，&lt;code&gt;MQTT&lt;/code&gt; 协议构建于&lt;code&gt;TCP/IP&lt;/code&gt;协议上，也就是说只要支持&lt;code&gt;TCP/IP&lt;/code&gt;协议栈的地方，都可以使用&lt;code&gt;MQTT&lt;/code&gt;协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要用 MQTT协议？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MQTT&lt;/code&gt;协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的 &lt;code&gt;HTTP&lt;/code&gt;协议呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先&lt;code&gt;HTTP&lt;/code&gt;协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合&lt;code&gt;IOT&lt;/code&gt;应用程序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;HTTP&lt;/code&gt;是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通常需要将一条命令或者消息，发送到网络上的所有设备上。&lt;code&gt;HTTP&lt;/code&gt;要实现这样的功能不但很困难，而且成本极高。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的MQTT协议介绍和实践，这里我就不再赘述了，大家可以参考我之前的两篇文章，里边写的也都很详细了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MQTT协议的介绍&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNTM4NzAyNg==&amp;amp;mid=2247486353&amp;amp;idx=1&amp;amp;sn=02371acc8048cb15f29285f0505c4958&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;我也没想到 springboot + rabbitmq 做智能家居，会这么简单&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MQTT实现消息推送&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNTM4NzAyNg==&amp;amp;mid=2247487818&amp;amp;idx=1&amp;amp;sn=19393de4304e1ddd3179d0e45ec16cd7&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;未读消息（小红点），前端 与 RabbitMQ 实时消息推送实践，贼简单~&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Websocket&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;websocket&lt;/code&gt;应该是大家都比较熟悉的一种实现消息推送的方式，上边我们在讲SSE的时候也和websocket进行过比较。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebSocket是一种在&lt;code&gt;TCP&lt;/code&gt;连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7215346534653465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLS88c9RL7cWXDic6oJar1SUlG4jlHibv6q6KW9LrCJWJZJl1GchHDibFDPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;808&quot;/&gt;&lt;figcaption&gt;图片源于网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;springboot整合websocket，先引入&lt;code&gt;websocket&lt;/code&gt;相关的工具包，和SSE相比额外的开发成本。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;!-- 引入websocket --&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;spring-boot-starter-websocket&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端使用&lt;code&gt;@ServerEndpoint&lt;/code&gt;注解标注当前类为一个websocket服务器，客户端可以通过&lt;code&gt;ws://localhost:7777/webSocket/10086&lt;/code&gt;来连接到WebSocket服务器端。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@ServerEndpoint&lt;/span&gt;(&lt;span&gt;&quot;/websocket/{userId}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebSocketServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//与某个客户端的连接会话，需要通过它来给客户端发送数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Session session;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; CopyOnWriteArraySet&amp;lt;WebSocketServer&amp;gt; webSockets = &lt;span&gt;new&lt;/span&gt; CopyOnWriteArraySet&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;// 用来存在线连接数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, Session&amp;gt; sessionPool = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Session&amp;gt;();&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 公众号：程序员小富&lt;br/&gt;     * 链接成功调用的方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnOpen&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onOpen&lt;/span&gt;&lt;span&gt;(Session session, @PathParam(value = &lt;span&gt;&quot;userId&quot;&lt;/span&gt;)&lt;/span&gt; String userId) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.session = session;&lt;br/&gt;            webSockets.add(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;            sessionPool.put(userId, session);&lt;br/&gt;            log.info(&lt;span&gt;&quot;websocket消息: 有新的连接，总数为:&quot;&lt;/span&gt; + webSockets.size());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 公众号：程序员小富&lt;br/&gt;     * 收到客户端消息后调用的方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnMessage&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;websocket消息: 收到客户端消息:&quot;&lt;/span&gt; + message);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 公众号：程序员小富&lt;br/&gt;     * 此为单点消息&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendOneMessage&lt;/span&gt;&lt;span&gt;(String userId, String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Session session = sessionPool.get(userId);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (session != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; session.isOpen()) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                log.info(&lt;span&gt;&quot;websocket消: 单点消息:&quot;&lt;/span&gt; + message);&lt;br/&gt;                session.getAsyncRemote().sendText(message);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端初始化打开WebSocket连接，并监听连接状态，接收服务端数据或向服务端发送数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; ws = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;&#x27;ws://localhost:7777/webSocket/10086&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 获取连接状态&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;ws连接状态：&#x27;&lt;/span&gt; + ws.readyState);&lt;br/&gt;    &lt;span&gt;//监听是否连接成功&lt;/span&gt;&lt;br/&gt;    ws.onopen = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;ws连接状态：&#x27;&lt;/span&gt; + ws.readyState);&lt;br/&gt;        &lt;span&gt;//连接成功则发送一个数据&lt;/span&gt;&lt;br/&gt;        ws.send(&lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 接听服务器发回的信息并处理展示&lt;/span&gt;&lt;br/&gt;    ws.onmessage = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;接收到来自服务器的消息：&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(data);&lt;br/&gt;        &lt;span&gt;//完成通信后关闭WebSocket连接&lt;/span&gt;&lt;br/&gt;        ws.close();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 监听连接关闭事件&lt;/span&gt;&lt;br/&gt;    ws.onclose = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 监听整个过程中websocket的状态&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;ws连接状态：&#x27;&lt;/span&gt; + ws.readyState);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 监听并处理error事件&lt;/span&gt;&lt;br/&gt;    ws.onerror = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;error&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(error);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;sendMessage&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; content = $(&lt;span&gt;&quot;#message&quot;&lt;/span&gt;).val();&lt;br/&gt;        $.ajax({&lt;br/&gt;            &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;/socket/publish?userId=10086&amp;amp;message=&#x27;&lt;/span&gt; + content,&lt;br/&gt;            &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;GET&#x27;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;data&lt;/span&gt;: { &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;&quot;7777&quot;&lt;/span&gt;, &lt;span&gt;&quot;content&quot;&lt;/span&gt;: content },&lt;br/&gt;            &lt;span&gt;success&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;console&lt;/span&gt;.log(data)&lt;br/&gt;            }&lt;br/&gt;        })&lt;br/&gt;    }&lt;br/&gt;&amp;lt;&lt;span&gt;/script&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页面初始化建立websocket连接，之后就可以进行双向通信了，效果还不错&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0943900267141585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSOuI1UOGoaNCC50kjnMjCMP39RndVOJpPfgwwibhCWms4rWHLoXLDlxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1123&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47417840375586856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSxJTIOhIibCdQpreJ7OdEBdIBcWkPnqt376OBeyMKWZmSU7qoaqun3MA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1278&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自定义推送&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边我们给我出了6种方案的原理和代码实现，但在实际业务开发过程中，不能盲目的直接拿过来用，还是要结合自身系统业务的特点和实际场景来选择合适的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推送最直接的方式就是使用第三推送平台，毕竟&lt;strong&gt;钱能解决的需求都不是问题&lt;/strong&gt;，无需复杂的开发运维，直接可以使用，省时、省力、省心，像goEasy、极光推送都是很不错的三方服务商。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般大型公司都有自研的消息推送平台，像我们本次实现的web站内信只是平台上的一个触点而已，短信、邮件、微信公众号、小程序凡是可以触达到用户的渠道都可以接入进来。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35212298682284043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSM5ib73GpHXYicr6xfVIG729eDJWH5TI1EtA89n1iavCVImqs3DjicOGHRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1366&quot;/&gt;&lt;figcaption&gt;图片来源于网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息推送系统内部是相当复杂的，诸如消息内容的维护审核、圈定推送人群、触达过滤拦截（推送的规则频次、时段、数量、黑白名单、关键词等等）、推送失败补偿非常多的模块，技术上涉及到大数据量、高并发的场景也很多。所以我们今天的实现方式在这个庞大的系统面前只是小打小闹。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Github地址&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中所提到的案例我都一一的做了实现，整理放在了&lt;code&gt;Github&lt;/code&gt;上，觉得有用就 &lt;strong&gt;Star&lt;/strong&gt; 一下吧！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;传送门：https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-realtime-data&lt;/p&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0e89018b092e8344c4b7d4d126f2eb3b</guid>
<title>你也能成为“黑客”高手——趣谈 Linux Shell 编程语言</title>
<link>https://toutiao.io/k/yjp4mey</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：京东零售 杜兴文&lt;/p&gt;

&lt;p&gt;我们看过很多在电脑命令行敲一些命令并给观众展示很高科技的画面感的电影，比如《盗梦空间》《操作系统革命》《代码》等等，&lt;/p&gt;

&lt;p&gt;再想想电影黑客帝国中的画面，估计会令很多人都叹为观止，其实挺简单的，只要会使用Linux操作系统就可以很简单地实现电脑屏幕的字符串雨了！是不是很高大上呢！&lt;/p&gt;

&lt;p&gt;同时Linux系统的其他几个操作指令，都有十分酷炫的效果，绝对令人叹为观止，废话不多说，直接进入主题！&lt;/p&gt;

&lt;p&gt;下面不妨逐一介绍这10个Linux比较有趣的命令。&lt;/p&gt;

&lt;p&gt;1、1.cmatrix命令&lt;/p&gt;

&lt;p&gt;接下来就是见证奇迹的时刻：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/3bbc9e4b70794f62a00aad14be75aae6%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=g9cBycw3Iy3KgoMcx3TU%2BKEeEwk%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、htop命令&lt;/p&gt;

&lt;p&gt;htop是Linux操作系统的图形化性能检测工具，如果类比的话相当于windows操作系统的任务管理器&lt;/p&gt;

&lt;p&gt;运行出来的结果是绿色的界面，同时动态的检测显示，下面看看是不是很酷的样子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/d690b0dff9ff4c40ad8ce637e069d1aa%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=Rv2Mude7iZnCQPilTkKon7ePOR0%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、hollywood命令&lt;/p&gt;

&lt;p&gt;说实话这个命令可能就是抖音里很火的那个，你眼中的程序猿VS现实中的程序猿：&lt;/p&gt;

&lt;p&gt;执行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/852424cdd9d14ea6a255bb38832ed811%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=3UevhN2WcXHUHCkka4zxyTMpH6I%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、aafire&lt;/p&gt;

&lt;p&gt;aafire终端命令可以将字符串像火焰一样的燃烧的输出&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/1b07c0f5c8844723a9e7aad1caeb9b7d%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=EnJfAV0UT4Lp%2FWIx9JwhQ9x%2BioA%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5、bastet命令&lt;/p&gt;

&lt;p&gt;使用bastet命令可以在Linux系统下玩俄罗斯方块：&lt;/p&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/fa733c6213f449fc990de6605a6b8a1b%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=vjmjvCtGw76f%2By32yFKP4ndamP8%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;6、sl&lt;/p&gt;

&lt;p&gt;运行结果是一辆呼啸而过的火车：&lt;/p&gt;

&lt;p&gt;运性结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/e2082d14501b4c8094b01bc027f51e5b%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=Un53D1yPbWiBFdnAGcqmP%2Fkx3mY%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;7、cowsay命令可以打印出来一头牛，并且可以指定让这头牛说任意的话语，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/34938f49dff841e2afdd8caac1756299%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=fMBzgdoe8RMv%2FjK4kJyPD98cVcU%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;8、fortune&lt;/p&gt;

&lt;p&gt;这是一个比较有趣的功能&lt;/p&gt;

&lt;p&gt;在输入fortune之后，Terminal会输出一句名言，诗句，或一些有趣的话：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/73078f6096e2435bbd73b289d841bc6a%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=5u8i1OypKvmMqkR2hWNOBX9CkPA%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;9、echo “&quot; | boxes -d dog&lt;/p&gt;

&lt;p&gt;输出一条小狗&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/7b8862af87c045e8bfb1f0a100dcc278%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=OOvBBihuONg3Jo0FlFQJD2ylklw%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看到以上使用简单的命令输出可爱的图案，是不是觉得Linux命令功能既强大又好玩！&lt;/p&gt;

&lt;p&gt;另外，我们使用Linux系统基本操作命令来管理操作系统文件、配置环境，排查问题等等也是看着非常高大上的！&lt;/p&gt;

&lt;p&gt;下面是一些基本的操作命令，用熟了操作起来也是很酷的啊！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/56becf7b49d140da9b5ff0d23346a821%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=ndtUAw7euPUY4u7FGwwfFlQm19s%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>81ba89abf2e4a35418c6b8a12e4cfba7</guid>
<title>携程一面：什么是双亲委派模型？</title>
<link>https://toutiao.io/k/3mwl8tg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;ER15uXTl&quot;&gt;这是携程一面的一个 JVM 面试真题。参加过校招面试的同学，应该对这个问题不陌生。一般提问 JVM 知识点的时候，就会顺带问你双亲委派模型（别扭的翻译。。。）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-45413c6cbe867bc06787902091ba787b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1110&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-45413c6cbe867bc06787902091ba787b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1110&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-45413c6cbe867bc06787902091ba787b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-45413c6cbe867bc06787902091ba787b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;84Pw_WsH&quot;&gt;就算是不准备面试，学习双亲委派模型对于我们也非常有帮助。我们比较熟悉的 Tomcat 服务器为了实现 Web 应用的隔离，就自定义了类加载并打破了双亲委派模型。&lt;/p&gt;&lt;p data-pid=&quot;UXAn0hid&quot;&gt;这篇文章我会先介绍类加载器，再介绍双亲委派模型，这样有助于我们更好地理解。&lt;/p&gt;&lt;p data-pid=&quot;sM7MDxri&quot;&gt;目录概览：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5166b465ebcd6663f97b36d88f4372ba_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;734&quot; data-rawheight=&quot;836&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-5166b465ebcd6663f97b36d88f4372ba_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;734&quot; data-rawheight=&quot;836&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-5166b465ebcd6663f97b36d88f4372ba_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-5166b465ebcd6663f97b36d88f4372ba_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;回顾一下类加载过程&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;pduCa6kV&quot;&gt;开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;IhU7vQE2&quot;&gt;类加载过程：&lt;b&gt;加载-&amp;gt;连接-&amp;gt;初始化&lt;/b&gt;。&lt;/li&gt;&lt;li data-pid=&quot;l-hA88N3&quot;&gt;连接过程又可分为三步：&lt;b&gt;验证-&amp;gt;准备-&amp;gt;解析&lt;/b&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11c3d6f2183018eea985257ebd5115f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;692&quot; data-rawheight=&quot;478&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-11c3d6f2183018eea985257ebd5115f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;692&quot; data-rawheight=&quot;478&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-11c3d6f2183018eea985257ebd5115f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-11c3d6f2183018eea985257ebd5115f4_b.jpg&quot;/&gt;&lt;figcaption&gt;类加载过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;EdqEvZu_&quot;&gt;加载是类加载过程的第一步，主要完成下面 3 件事情：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;xPfV-WxL&quot;&gt;通过全类名获取定义此类的二进制字节流&lt;/li&gt;&lt;li data-pid=&quot;57YwjdoX&quot;&gt;将字节流所代表的静态存储结构转换为方法区的运行时数据结构&lt;/li&gt;&lt;li data-pid=&quot;Ro02g788&quot;&gt;在内存中生成一个代表该类的 &lt;code&gt;Class&lt;/code&gt; 对象，作为方法区这些数据的访问入口&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;类加载器&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;类加载器介绍&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;nR9JW3WI&quot;&gt;类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java Applet（已经被淘汰） 的需要。后来，慢慢成为 Java 程序中的一个重要组成部分，赋予了 Java 类可以被动态加载到 JVM 中并执行的能力。&lt;/p&gt;&lt;p data-pid=&quot;jeFOJdMz&quot;&gt;根据官方 API 文档的介绍：&lt;/p&gt;&lt;blockquote data-pid=&quot;QYUI7Qvz&quot;&gt; A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a &quot;class file&quot; of that name from a file system.&lt;br/&gt; Every Class object contains a reference to the ClassLoader that defined it.&lt;br/&gt; Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;nBKoIASj&quot;&gt;翻译过来大概的意思是：&lt;/p&gt;&lt;blockquote data-pid=&quot;gNNF-KQO&quot;&gt; 类加载器是一个负责加载类的对象。&lt;code&gt;ClassLoader&lt;/code&gt; 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。&lt;br/&gt; 每个 Java 类都有一个引用指向加载它的 &lt;code&gt;ClassLoader&lt;/code&gt;。不过，数组类不是通过 &lt;code&gt;ClassLoader&lt;/code&gt; 创建的，而是 JVM 在需要的时候自动创建的，数组类通过&lt;code&gt;getClassLoader()&lt;/code&gt;方法获取 &lt;code&gt;ClassLoader&lt;/code&gt; 的时候和该数组的元素类型的 &lt;code&gt;ClassLoader&lt;/code&gt; 是一致的。&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;WirC1FB7&quot;&gt;从上面的介绍可以看出:&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;zG7oIeMq&quot;&gt;类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。&lt;/li&gt;&lt;li data-pid=&quot;eHGx5_2a&quot;&gt;每个 Java 类都有一个引用指向加载它的 &lt;code&gt;ClassLoader&lt;/code&gt;。&lt;/li&gt;&lt;li data-pid=&quot;NDpl82wv&quot;&gt;数组类不是通过 &lt;code&gt;ClassLoader&lt;/code&gt; 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@CallerSensitive&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;3o_cALDx&quot;&gt;简单来说，&lt;b&gt;类加载器的主要作用就是加载 Java 类的字节码（ &lt;code&gt;.class&lt;/code&gt; 文件）到 JVM 中（在内存中生成一个代表该类的 &lt;code&gt;Class&lt;/code&gt; 对象）。&lt;/b&gt; 字节码可以是 Java 源程序（&lt;code&gt;.java&lt;/code&gt;文件）经过 &lt;code&gt;javac&lt;/code&gt; 编译得来，也可以是通过工具动态生成或者通过网络下载得来。&lt;/p&gt;&lt;p data-pid=&quot;A1aBH73s&quot;&gt;其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。本文只讨论其核心功能：加载类。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;类加载器加载规则&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;V1qahZQH&quot;&gt;JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。&lt;/p&gt;&lt;p data-pid=&quot;iPNYdx5g&quot;&gt;对于已经加载的类会被放在 &lt;code&gt;ClassLoader&lt;/code&gt; 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 由这个类加载器加载的类。
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 由VM调用，用此类加载器记录每个已加载类。
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;classes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;类加载器总结&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;cY2gy7yi&quot;&gt;JVM 中内置了三个重要的 &lt;code&gt;ClassLoader&lt;/code&gt;：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;CbW_wt9p&quot;&gt;&lt;b&gt;&lt;code&gt;BootstrapClassLoader&lt;/code&gt;(启动类加载器)&lt;/b&gt; ：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ &lt;code&gt;%JAVA_HOME%/lib&lt;/code&gt;目录下的 &lt;code&gt;rt.jar&lt;/code&gt; 、&lt;code&gt;resources.jar&lt;/code&gt; 、&lt;code&gt;charsets.jar&lt;/code&gt;等 jar 包和类）以及被 &lt;code&gt;-Xbootclasspath&lt;/code&gt;参数指定的路径下的所有类。&lt;/li&gt;&lt;li data-pid=&quot;DJ7MC_04&quot;&gt;&lt;b&gt;&lt;code&gt;ExtensionClassLoader&lt;/code&gt;(扩展类加载器)&lt;/b&gt; ：主要负责加载 &lt;code&gt;%JRE_HOME%/lib/ext&lt;/code&gt; 目录下的 jar 包和类以及被 &lt;code&gt;java.ext.dirs&lt;/code&gt; 系统变量所指定的路径下的所有类。&lt;/li&gt;&lt;li data-pid=&quot;rDMDXAHv&quot;&gt;&lt;b&gt;&lt;code&gt;AppClassLoader&lt;/code&gt;(应用程序类加载器)&lt;/b&gt; ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-pid=&quot;zzvDSTGv&quot;&gt;   拓展一下：&lt;br/&gt; &lt;/blockquote&gt;&lt;ul&gt;&lt;li data-pid=&quot;_buJ5mJl&quot;&gt;&lt;b&gt;&lt;code&gt;rt.jar&lt;/code&gt;&lt;/b&gt; ： rt 代表“RunTime”，&lt;code&gt;rt.jar&lt;/code&gt;是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 &lt;code&gt;java.xxx.*&lt;/code&gt;都在里面，比如&lt;code&gt;java.util.*&lt;/code&gt;、&lt;code&gt;java.io.*&lt;/code&gt;、&lt;code&gt;java.nio.*&lt;/code&gt;、&lt;code&gt;java.lang.*&lt;/code&gt;、&lt;code&gt;java.sql.*&lt;/code&gt;、&lt;code&gt;java.math.*&lt;/code&gt;。&lt;/li&gt;&lt;li data-pid=&quot;KfOmQ4Qu&quot;&gt;Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 &lt;code&gt;java.base&lt;/code&gt; 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;x3jmiQTr&quot;&gt;除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ &lt;code&gt;.class&lt;/code&gt; 文件）进行加密，加载时再利用自定义的类加载器对其解密。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;771&quot; data-rawheight=&quot;761&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;771&quot; data-rawheight=&quot;761&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_b.jpg&quot;/&gt;&lt;figcaption&gt;类加载器层次关系图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;WPoIpJbY&quot;&gt;除了 &lt;code&gt;BootstrapClassLoader&lt;/code&gt; 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 &lt;code&gt;ClassLoader&lt;/code&gt;抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。&lt;/p&gt;&lt;p data-pid=&quot;wTwnY9Bi&quot;&gt;每个 &lt;code&gt;ClassLoader&lt;/code&gt; 可以通过&lt;code&gt;getParent()&lt;/code&gt;获取其父 &lt;code&gt;ClassLoader&lt;/code&gt;，如果获取到 &lt;code&gt;ClassLoader&lt;/code&gt; 为&lt;code&gt;null&lt;/code&gt;的话，那么该类是通过 &lt;code&gt;BootstrapClassLoader&lt;/code&gt; 加载的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 父加载器
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@CallerSensitive&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;vXoNzzAq&quot;&gt;&lt;b&gt;为什么 获取到 &lt;code&gt;ClassLoader&lt;/code&gt; 为&lt;code&gt;null&lt;/code&gt;就是 &lt;code&gt;BootstrapClassLoader&lt;/code&gt; 加载的呢？&lt;/b&gt; 这是因为&lt;code&gt;BootstrapClassLoader&lt;/code&gt; 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。&lt;/p&gt;&lt;p data-pid=&quot;8Ilf_5_U&quot;&gt;下面我们来看一个获取 &lt;code&gt;ClassLoader&lt;/code&gt; 的小案例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PrintClassLoaderTree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintClassLoaderTree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;|--&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;needContinue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;needContinue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;needContinue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;classLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;\t&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;G1KG-MMn&quot;&gt;输出结果(JDK 8 )：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;|--sun.misc.Launcher$AppClassLoader@18b4aac2
    |--sun.misc.Launcher$ExtClassLoader@53bd815b
        |--null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;8iwMG9MO&quot;&gt;从输出结果可以看出：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;zVMDgdYU&quot;&gt;我们编写的 Java 类 &lt;code&gt;PrintClassLoaderTree&lt;/code&gt; 的 &lt;code&gt;ClassLoader&lt;/code&gt; 是&lt;code&gt;AppClassLoader&lt;/code&gt;；&lt;/li&gt;&lt;li data-pid=&quot;tB1UiCaW&quot;&gt;&lt;code&gt;AppClassLoader&lt;/code&gt;的父 &lt;code&gt;ClassLoader&lt;/code&gt; 是&lt;code&gt;ExtClassLoader&lt;/code&gt;；&lt;/li&gt;&lt;li data-pid=&quot;uu1Lg2-X&quot;&gt;&lt;code&gt;ExtClassLoader&lt;/code&gt;的父&lt;code&gt;ClassLoader&lt;/code&gt;是&lt;code&gt;Bootstrap ClassLoader&lt;/code&gt;，因此输出结果为 null。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;自定义类加载器&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;JuOHQLyY&quot;&gt;我们前面也说说了，除了 &lt;code&gt;BootstrapClassLoader&lt;/code&gt; 其他类加载器均由 Java 实现且全部继承自&lt;code&gt;java.lang.ClassLoader&lt;/code&gt;。如果我们要自定义自己的类加载器，很明显需要继承 &lt;code&gt;ClassLoader&lt;/code&gt;抽象类。&lt;/p&gt;&lt;p data-pid=&quot;FQXWsr8W&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt; 类有两个关键的方法：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;DBrsfRNp&quot;&gt;&lt;code&gt;protected Class loadClass(String name, boolean resolve)&lt;/code&gt;：加载指定二进制名称的类，实现了双亲委派机制 。&lt;code&gt;name&lt;/code&gt; 为类的二进制名称，&lt;code&gt;resove&lt;/code&gt; 如果为 true，在加载时调用 &lt;code&gt;resolveClass(Class&amp;lt;?&amp;gt; c)&lt;/code&gt; 方法解析该类。&lt;/li&gt;&lt;li data-pid=&quot;JPPipHLG&quot;&gt;&lt;code&gt;protected Class findClass(String name)&lt;/code&gt;：根据类的二进制名称来查找类，默认实现是空方法。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;ruM3QNoV&quot;&gt;官方 API 文档中写到：&lt;/p&gt;&lt;blockquote data-pid=&quot;Rbvb-2nM&quot;&gt; Subclasses of &lt;code&gt;ClassLoader&lt;/code&gt; are encouraged to override &lt;code&gt;findClass(String name)&lt;/code&gt;, rather than this method.&lt;br/&gt; 建议 &lt;code&gt;ClassLoader&lt;/code&gt;的子类重写 &lt;code&gt;findClass(String name)&lt;/code&gt;方法而不是&lt;code&gt;loadClass(String name, boolean resolve)&lt;/code&gt; 方法。&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;ktWytO3o&quot;&gt;如果我们不想打破双亲委派模型，就重写 &lt;code&gt;ClassLoader&lt;/code&gt; 类中的 &lt;code&gt;findClass()&lt;/code&gt; 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 &lt;code&gt;loadClass()&lt;/code&gt; 方法。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;双亲委派模型&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;双亲委派模型介绍&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;wdjBSwzs&quot;&gt;类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。&lt;/p&gt;&lt;p data-pid=&quot;mzzJ7Kja&quot;&gt;根据官网介绍：&lt;/p&gt;&lt;blockquote data-pid=&quot;iko4JBVD&quot;&gt; The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine&#x27;s built-in class loader, called the &quot;bootstrap class loader&quot;, does not itself have a parent but may serve as the parent of a ClassLoader instance.&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;y5A-pVvY&quot;&gt;翻译过来大概的意思是：&lt;/p&gt;&lt;blockquote data-pid=&quot;t0BAtGK8&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt; 类使用委托模型来搜索类和资源。每个 &lt;code&gt;ClassLoader&lt;/code&gt; 实例都有一个相关的父类加载器。需要查找类或资源时，&lt;code&gt;ClassLoader&lt;/code&gt; 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。 虚拟机中被称为 &quot;bootstrap class loader&quot;的内置类加载器本身没有父类加载器，但是可以作为 &lt;code&gt;ClassLoader&lt;/code&gt; 实例的父类加载器。&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;Q9SyrJN3&quot;&gt;从上面的介绍可以看出：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;NbqWSVqc&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt; 类使用委托模型来搜索类和资源。&lt;/li&gt;&lt;li data-pid=&quot;1E6oIVo8&quot;&gt;双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。&lt;/li&gt;&lt;li data-pid=&quot;wD3mKZk7&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt; 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;9HFhpeE0&quot;&gt;下图展示的各种类加载器之间的层次关系被称为类加载器的“**双亲委派模型(Parents Delegation Model)**”。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;771&quot; data-rawheight=&quot;761&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;771&quot; data-rawheight=&quot;761&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_b.jpg&quot;/&gt;&lt;figcaption&gt;类加载器层次关系图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;gwgFQefY&quot;&gt;注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。&lt;/p&gt;&lt;p data-pid=&quot;-qhIRfkf&quot;&gt;其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 &lt;code&gt;MotherClassLoader&lt;/code&gt; 和一个&lt;code&gt;FatherClassLoader&lt;/code&gt; 。个人觉得翻译成单亲委派模型更好一些，不过，国内既然翻译成了双亲委派模型并流传了，按照这个来也没问题，不要被误解了就好。&lt;/p&gt;&lt;p data-pid=&quot;ZqdedT9x&quot;&gt;另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 组合
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checkCreateClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;eC9LUZ4d&quot;&gt;在面向对象编程中，有一条非常经典的设计原则： &lt;b&gt;组合优于继承，多用组合少用继承。&lt;/b&gt;&lt;/p&gt;&lt;h3&gt;&lt;b&gt;双亲委派模型的执行流程&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;HNs7UyF-&quot;&gt;双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 &lt;code&gt;java.lang.ClassLoader&lt;/code&gt; 的 &lt;code&gt;loadClass()&lt;/code&gt; 中，相关代码如下所示。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loadClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassNotFoundException&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getClassLoadingLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//首先，检查该类是否已经加载过
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findLoadedClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//如果 c 为 null，则说明该类没有被加载过
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;            &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;//当父类的加载器不为空，则通过父类的loadClass来加载该类
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;                    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loadClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;//当父类的加载器为空，则调用启动类加载器来加载该类
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;                    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findBootstrapClassOrNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//非空父类的类加载器无法找到相应的类，则抛出异常
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//当父类加载器无法加载时，则调用findClass方法来加载该类
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;                &lt;span class=&quot;c1&quot;&gt;//用户可通过覆写该方法，来自定义类加载器
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;                &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

                &lt;span class=&quot;c1&quot;&gt;//用于统计类加载器相关的信息
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;                &lt;span class=&quot;n&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;misc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PerfCounter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParentDelegationTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;misc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PerfCounter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFindClassTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addElapsedTimeFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;misc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PerfCounter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFindClasses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;increment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//对类进行link操作
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;            &lt;span class=&quot;n&quot;&gt;resolveClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;SsNAhnNi&quot;&gt;每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。&lt;/p&gt;&lt;p data-pid=&quot;ydNYR2Di&quot;&gt;结合上面的源码，简单总结一下双亲委派模型的执行流程：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;DpOkRwS_&quot;&gt;在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。&lt;/li&gt;&lt;li data-pid=&quot;jPg7PnrC&quot;&gt;类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 &lt;code&gt;loadClass()&lt;/code&gt;方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 &lt;code&gt;BootstrapClassLoader&lt;/code&gt; 中。&lt;/li&gt;&lt;li data-pid=&quot;xG48Mxz0&quot;&gt;只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 &lt;code&gt;findClass()&lt;/code&gt; 方法来加载类）。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;z-z7OZFW&quot;&gt;  拓展一下：&lt;/p&gt;&lt;p data-pid=&quot;GvUW37fF&quot;&gt;&lt;b&gt;JVM 判定两个 Java 类是否相同的具体规则&lt;/b&gt; ：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 &lt;code&gt;Class&lt;/code&gt; 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;双亲委派模型的好处&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;ecw0to9n&quot;&gt;双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。&lt;/p&gt;&lt;p data-pid=&quot;M_3qcGWE&quot;&gt;如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 &lt;code&gt;java.lang.Object&lt;/code&gt; 类的话，那么程序运行的时候，系统就会出现两个不同的 &lt;code&gt;Object&lt;/code&gt; 类。双亲委派模型可以保证加载的是 JRE 里的那个 &lt;code&gt;Object&lt;/code&gt; 类，而不是你写的 &lt;code&gt;Object&lt;/code&gt; 类。这是因为 &lt;code&gt;AppClassLoader&lt;/code&gt; 在加载你的 &lt;code&gt;Object&lt;/code&gt; 类时，会委托给 &lt;code&gt;ExtClassLoader&lt;/code&gt; 去加载，而 &lt;code&gt;ExtClassLoader&lt;/code&gt; 又会委托给 &lt;code&gt;BootstrapClassLoader&lt;/code&gt;，&lt;code&gt;BootstrapClassLoader&lt;/code&gt; 发现自己已经加载过了 &lt;code&gt;Object&lt;/code&gt; 类，会直接返回，不会去加载你写的 &lt;code&gt;Object&lt;/code&gt; 类。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;打破双亲委派模型方法&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;UynNrRDZ&quot;&gt;为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 &lt;code&gt;loadClass()&lt;/code&gt; 即可。&lt;/p&gt;&lt;p data-pid=&quot;_Rale3jS&quot;&gt;&lt;b&gt;  修正（参见：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Snailclimb/JavaGuide/issues/871&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;issue871&lt;/a&gt; ）&lt;/b&gt; ：自定义加载器的话，需要继承 &lt;code&gt;ClassLoader&lt;/code&gt; 。如果我们不想打破双亲委派模型，就重写 &lt;code&gt;ClassLoader&lt;/code&gt; 类中的 &lt;code&gt;findClass()&lt;/code&gt; 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 &lt;code&gt;loadClass()&lt;/code&gt; 方法。&lt;/p&gt;&lt;p data-pid=&quot;SmNCVxDK&quot;&gt;为什么是重写 &lt;code&gt;loadClass()&lt;/code&gt; 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：&lt;/p&gt;&lt;blockquote data-pid=&quot;EH1TVBsv&quot;&gt; 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 &lt;code&gt;loadClass()&lt;/code&gt;方法来加载类）。&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;IVBr8j7H&quot;&gt;我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 &lt;code&gt;WebAppClassLoader&lt;/code&gt; 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。&lt;/p&gt;&lt;p data-pid=&quot;Y5fbhbQY&quot;&gt;Tomcat 的类加载器的层次结构如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-153968e5cf17c27b8787a2d211466f12_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;471&quot; data-rawheight=&quot;901&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-153968e5cf17c27b8787a2d211466f12_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;471&quot; data-rawheight=&quot;901&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-153968e5cf17c27b8787a2d211466f12_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-153968e5cf17c27b8787a2d211466f12_b.jpg&quot;/&gt;&lt;figcaption&gt;Tomcat 的类加载器的层次结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;xnpEk7f4&quot;&gt;感兴趣的小伙伴可以自行研究一下 Tomcat 类加载器的层次结构，这有助于我们搞懂 Tomcat 隔离 Web 应用的原理，推荐资料是&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//gk.link/a/10Egr&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入拆解 Tomcat &amp;amp; Jetty》&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;推荐阅读&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;更多面试题总结&lt;/h2&gt;&lt;p data-pid=&quot;zXLahUBD&quot;&gt;&lt;b&gt;Java&lt;/b&gt; ：&lt;/p&gt;&lt;p data-pid=&quot;z0ueBacI&quot;&gt;&lt;b&gt;计算机基础&lt;/b&gt; ：&lt;/p&gt;&lt;p data-pid=&quot;OMt3t-Gz&quot;&gt;&lt;b&gt;数据库&lt;/b&gt; ：&lt;/p&gt;&lt;p data-pid=&quot;anSVZTGT&quot;&gt;&lt;b&gt;常用框架&lt;/b&gt; ：&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9d8cf7021bbec91de63cb8463eda3696</guid>
<title>Docker 使用过程中的一些技巧（2）</title>
<link>https://toutiao.io/k/q10wbcr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mp-common-profile&quot; data-from=&quot;0&quot; data-id=&quot;MzAwOTU4NzM5Ng==&quot; data-alias=&quot;yudadanwx&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/5Wib5Wh04ugwID68icb2oFcuc8rPmySWAHaWnQsQD8ax6PxocJ6nruWaMfxoarXh1eicga9ENlQrUPFTh8LFeEX7w/0?wx_fmt=png&quot; data-nickname=&quot;虞大胆的叽叽喳喳&quot; data-signature=&quot;《深入浅出HTTPS：从原理到实战》作者。&quot; data-weuitheme=&quot;light&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;p&gt;继续上文说一些docker使用心得&lt;/p&gt;&lt;p&gt;1：—no-cache&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwOTU4NzM5Ng==&amp;amp;mid=2455772382&amp;amp;idx=1&amp;amp;sn=89ab8742164f5b20e5f185234d96b090&amp;amp;chksm=8cc9e375bbbe6a6379e0d2dd2d1bbff29618e5a052760c6b925fcc1dbed524c64f1277fcd41e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《docker使用过程中的一些技巧（1）》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《docker使用过程中的一些技巧（1）》&lt;/a&gt;中提到构建缓存的问题，docker-compose使用CACHEBUST指令解决，而docker构建可以使用—no-cache参数解决缓存问题。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;rebuild the image from the base image without using cached layers by using the —no-cache option&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;基于Dockerfile构建的时候，由于要经常调试，如果缓存错误结果则会很难排查，所以强烈建议使用该参数，且每次每次使用新的中间容器（后面会提到）。&lt;/p&gt;&lt;p&gt;2：Dangling 镜像&lt;/p&gt;&lt;p&gt;docker images（注意不是docker images -a）经常发现有些镜像标识为 none，这些就是Dangling镜像：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Those old image are the ones that are untagged and displays “none” on its name when you run docker images.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;什么情况下会产生Dangling 镜像呢？最直接的原因是构建相同tag镜像的时候，前一个镜像的tag会被改成None。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;a dangling image just means that you’ve created the new build of the image, but it wasn’t given a new name. So the old images you have becomes the “dangling image”. Those old image are the ones that are untagged and displays “none” on its name when you run docker images.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;还有其他的一些原因，比如：&lt;/p&gt;&lt;p&gt;（1）在构建镜像过程中出现了错误，这个镜像可能会标记为none。&lt;/p&gt;&lt;p&gt;（2）删除了一个镜像，但它依赖的镜像还存在，这个依赖的镜像可能会标记为none。&lt;/p&gt;&lt;p&gt;这两种情况自己没有实际遇到过，也不能完全叫做Dangling镜像，因为这种镜像仍然是有用的，尤其上述（2）的情况。&lt;/p&gt;&lt;p&gt;Dangling镜像的坏处就是占用磁盘空间，因为这些镜像是unused或referenced by any images，基于此应该定期清理它&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ docker rmi $(docker images -f &quot;dangling=true&quot; -q)&lt;br/&gt;&lt;br/&gt;$ docker images -f &quot;dangling=true&quot; -q | xargs docker rmi&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3：intermediate 镜像&lt;/p&gt;&lt;p&gt;如果输入docker images -a，还会发现标记为none的镜像，但这些镜像是“好的”。&lt;/p&gt;&lt;p&gt;它们不占用磁盘空间，且各个中间层之间是互相依赖的，所以删除的时候会提示 Error response from daemon: conflict: unable to delete cccf1fb3f503 (cannot be forced) - image has dependent child images。&lt;/p&gt;&lt;p&gt;一般情况下在Dockerfile中安装一些包（比如Add）的时候会遇到，最终镜像生成后，中间镜像会删除（&lt;strong&gt;但自己遇到的情况中间镜像太多了，不知道怎么产生的&lt;/strong&gt;）。&lt;/p&gt;&lt;p&gt;可以通过docker inspect观察这些intermediate镜像的关联情况。&lt;/p&gt;&lt;p&gt;4：intermediate 容器&lt;/p&gt;&lt;p&gt;有的时候删除感觉没有用的镜像，却提示有容器在引用它，感觉特别奇怪，通过docker ps -a发现很多STATUS列显示Exited，这是什么情况？&lt;/p&gt;&lt;p&gt;在基于Dockerfile构建镜像的时候，实际上会创建中间容器，用于运行Dockerfile中的指令（比如Add），如果创建失败，这个中间容器就会处于Exited。&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>59cb30f0391c069981a7c9c660f45152</guid>
<title>31 岁程序员，8 年 5 跳，年薪 4 万变 92 万，现在环沪上海各一套房</title>
<link>https://toutiao.io/k/j1hhvk8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-v-b51c2330=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;p data-track=&quot;1&quot;&gt;&lt;span&gt;很多时候，虽然跳槽可能带来降薪的结果，但依然有很多人认为跳槽可以涨薪。近日，看到一则帖子，发帖的楼主表示，自己8年5跳，年薪4万到92万，现在环沪上海各一套房，再干5年码农，就可以自由创业了。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;1&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t09VbpQYMct3ScDiaicRzibnkW51OEJuqLiarmyyBgwdKf7GNt0bqKic9GiaZGXjM3XQqMcAA2Domj65bv6djTEbVqfw/640?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;616.6089965397924&quot; data-ratio=&quot;0.5703703703703704&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uVtw9FmykSiaKj5aZJaRJTkm5fD8fBhuBg1ibjuYVh9IoTCcicCxnswzkxnKjP389L4RpknYibjo1ibUsiatRBlvjX0g/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;3&quot;&gt;&lt;span&gt;原贴如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;3&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9944444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/t09VbpQYMct3ScDiaicRzibnkW51OEJuqLia6ara4lsCibPZplTXxNHree3Qibz7U9mD5hTZlDNYyskvQLUZH4yvvkMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;6&quot;&gt;&lt;span&gt;但很明显，有不少网友对于靠着频繁跳槽还能实现薪资的高涨表示质疑：这一看就是吹牛逼的，我老大去哪网的总监都没这么牛逼；连续4次一年一跳，你搁着当雇佣兵呢。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;6&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9944444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/t09VbpQYMct3ScDiaicRzibnkW51OEJuqLia1Aiabict09pPiatQpsugKeFayic3mptgZhIs3OSwGCTd3ucMPajazJuGuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;9&quot;&gt;&lt;span&gt;@北京思福迪信息技术有限公司员工：牛二放牛 牛儿不吃草 ，牛二吹笛 牛儿天上飞&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;9&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;11&quot;&gt;&lt;span&gt;@设计狮.甄士隐：我没本，总包300我骄傲了吗&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;11&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;13&quot;&gt;&lt;span&gt;@中兴通讯股份有限公司员工：宝贝，吹牛要注意技巧。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;13&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;15&quot;&gt;&lt;span&gt;@阿里巴巴集团员工：我2030年毕业 也就5000多万年薪吧&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;15&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;17&quot;&gt;&lt;span&gt;@程序员：在座的各位，我说楼主是真·跳跳虎，大家不介意吧&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;17&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;19&quot;&gt;&lt;span&gt;不少网友表示太频繁跳槽根本没人要：假的，连续4年，一年一跳，你在牛逼也没人要；这样跳槽的一般不收。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;19&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8916666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/t09VbpQYMct3ScDiaicRzibnkW51OEJuqLia9AEgK50qTCPGiaW3t3n2psN49S8920ZJGf7co9l08QLwS8JdApHbdBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;22&quot;&gt;&lt;span&gt;@项目管理.昆仑弟子：换我是面试官，从18年开始我就不会要你了～&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;22&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;24&quot;&gt;&lt;span&gt;@宋清：请问你每年跳槽，每年工作都不到一年，年终考评居然还能拿满勤奖金，太假了吧&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;24&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;26&quot;&gt;&lt;span&gt;@京东员工：乘数都是虚的，这跳槽频率真不一定能拿到年终奖&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;26&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;28&quot;&gt;&lt;span&gt;不过，随后楼主在评论区很真诚的回复：以上经历薪资绝对真实，现在互联网跳槽频繁的人多了去了，开水团 拼夕夕都待过。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;28&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;30&quot;&gt;&lt;span&gt;此外，楼主还表示：这只是就职公司的收入，前几年没有投资意识，这两年开始做实业投资和金融投资，预计今年投资收入与打工收入持平。个人能力还行，不靠学历。不然跳槽这么频繁早就失业了&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;30&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;32&quot;&gt;&lt;span&gt;有些网友也是相信楼主就是靠着实力跳槽和涨薪：不奇怪，一年四跳的我也都见过；也是凭奋斗来的，没什么好吹不吹。互联网行业只要人牛逼了，到处挖你，投去羡慕的眼光&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;32&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.038888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/t09VbpQYMct3ScDiaicRzibnkW51OEJuqLia43RDibzAWxCbyAWuyzpMwhiaJ67dib6QnnjH9bA75HianMKUzVLXjia0hMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;35&quot;&gt;&lt;span&gt;@腾讯员工：17年硕，工资在你2017年-2018年中间，加油&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;35&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;37&quot;&gt;&lt;span&gt;@无崖子：果然互联网涨薪靠跳槽&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;37&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;39&quot;&gt;&lt;span&gt;@北京捷科智诚员工：夸张可能稍微有点夸张，但是靠跳槽涨薪的确实比比皆是，现在这个行业市场就是这样，靠在一个公司涨薪，是不可能的&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;39&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;41&quot;&gt;&lt;span&gt;@北京捷科智诚员工：看到有人在这酸了，说公司一看跳槽这么频繁就不要，你们能说出来这样的话，证明你们还是太天真！你们都不知道简历可以造假嘛？只要资历够了，技术没啥问题，人家招聘的管你跳几次槽干嘛，人家招聘的也需要业绩支撑，有人愿意跳，他们就敢要&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;41&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;43&quot;&gt;&lt;span&gt;@程序员：我一朋友跟你经历有些相似，不过只换过两家公司，第一家是从普通不知名公司跳到企鹅，今年从企鹅跳到华为，刚毕业进普通公司一个月三千多，到今年进华为不到6年时间，目前年薪90多万&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;43&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;45&quot;&gt;&lt;span&gt;对于大部分人来说，跳槽是为了“赚更多的钱”，但跳槽也是一门技术活，正如上文中提到的楼主，看似频繁跳槽，但确实离“财务自由”更近一步了。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;45&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;47&quot;&gt;&lt;span&gt;其实，对于薪资较低的求职者来说，一般薪资涨幅大概在20%~30%左右，当然特殊情况除外，而对于薪资较高的，跳槽的价位可以是前任工作薪资标准上浮30%~50%左右，也可以是行业地区薪酬标准的60—75分位，当然前提是应聘者的各方面条件都符合招聘方的要求。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;47&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;49&quot;&gt;&lt;span&gt;不过，跳槽加薪有风险，应该谨慎对待，毕竟大部分的跳槽的确可以得到一定的涨薪，但也会出现不涨，甚至是降薪的风险。如果不具备跳槽的能力，跳槽有可能变成失业。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;49&quot;&gt;&lt;/p&gt;&lt;p data-track=&quot;51&quot;&gt;&lt;span&gt;你们觉得呢？&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>