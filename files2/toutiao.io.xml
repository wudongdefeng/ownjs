<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>49be25ef84d2847b3d0dbd879cde8356</guid>
<title>「架构选型」5 种 API 网关技术选型</title>
<link>https://toutiao.io/k/a4v7vsf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0020833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnB7yDOibJthhMLT2TDl6l3fQ5x5NFSsopjjice9AiclReM40XASZ2HuLePg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/figure&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU3NzU5NTg5Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/GfOyjHGwCoN5Ky9IZgsdyZgM3lbEC5Ixe3ZgxBu5MdzvjWFyC7uqrsffcyhtrD8r8t0qicxbGmNxKYr4l4mANKQ/0?wx_fmt=png&quot; data-nickname=&quot;面试突击&quot; data-alias=&quot;PassJava1&quot; data-signature=&quot;大厂面试突击，专注分享面试题，如计算机基础、计算机网络、Java后端、前端Vue。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于什么是网关，以及为什么需要网关，可以看上一篇：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451964154&amp;amp;idx=1&amp;amp;sn=202154c1206936d8eaa72e617a2ef6ad&amp;amp;chksm=8d1ff965ba6870732290b202e2f97c85f9c8c6f84f8d33e57dca63085f5eefc9aba05e0ef523&amp;amp;token=30209230&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;几种常见网关的对比&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来个几款 API 网关的对比，让大家有个整体的印象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5724867724867725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnBvFt32r61nyEweKrCMKqhazibx3vibQS1gO52OoqEfBmJ9zPCmJnSz1Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1890&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设计网关，需要考虑哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果让你设计一个 API 网关，你会考虑哪些方面？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;路由转发&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求先到达 API 网关，然后经过断言，匹配到路由后，由路由将请求转发给真正的业务服务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;注册发现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各个服务实例需要将自己的服务名、IP 地址和 port 注册到注册中心，然后注册中心会存放一份注册表，Gateway 可以从注册中心获取到注册表，然后转发请求时只需要转发到对应的服务名即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;负载均衡&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个服务可以由多个服务实例组成服务集群，而 Gateway 配置的通常是一个服务名，如 passjava-member 服务，所以需要具备负载均衡功能，将请求分发到不同的服务实例上。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;弹力设计&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关还可以把弹力设计中的那些异步、重试、幂等、流控、熔断、监视等都可以实现进去。这样，同样可以像 Service Mesh 那样，让应用服务只关心自己的业务逻辑（或是说数据面上的事）而不是控制逻辑（控制面）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安全方面&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SSL 加密及证书管理、Session 验证、授权、数据校验，以及对请求源进行恶意攻击的防范。错误处理越靠前的位置就是越好，所以，网关可以做到一个全站的接入组件来对后端的服务进行保护。当然，网关还可以做更多更有趣的事情，比如：灰度发布、API聚合、API编排。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;灰度发布&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关完全可以做到对相同服务不同版本的实例进行导流，还可以收集相关的数据。这样对于软件质量的提升，甚至产品试错都有非常积极的意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API 聚合&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用网关可以将多个单独请求聚合成一个请求。在微服务体系的架构中，因为服务变小了，所以一个明显的问题是，客户端可能需要多次请求才能得到所有的数据。这样一来，客户端与后端之间的频繁通信会对应用程序的性能和规模产生非常不利的影响。于是，我们可以让网关来帮客户端请求多个后端的服务（有些场景下完全可以并发请求），然后把后端服务的响应结果拼装起来，回传给客户端（当然，这个过程也可以做成异步的，但这需要客户端的配合）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API 编排&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样在微服务的架构下，要走完一个完整的业务流程，我们需要调用一系列 API，就像一种工作流一样，这个事完全可以通过网页来编排这个业务流程。我们可能通过一个 DSL 来定义和编排不同的 API，也可以通过像 AWS Lambda 服务那样的方式来串联不同的 API。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关设计重点&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关设计重点主要是三个, 高性能、高可用、高扩展:&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高性能&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在技术设计上，网关不应该也不能成为性能的瓶颈。对于高性能，最好使用高性能的编程语言来实现，如 C、C++、Go 和 Java。网关对后端的请求，以及对前端的请求的服务一定要使用异步非阻塞的 I/O 来确保后端延迟不会导致应用程序中出现性能问题。C 和 C++ 可以参看 Linux 下的 epoll 和 Windows 的 I/O Completion Port 的异步 IO 模型，Java 下如 Netty、Spring Reactor 的 NIO 框架。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高可用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为所有的流量或调用经过网关，所以网关必须成为一个高可用的技术组件，它的稳定直接关系到了所有服务的稳定。网关如果没有设计，就会成变一个单点故障。因此，一个好的网关至少要做到以下几点。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;集群化&lt;/strong&gt;。网关要成为一个集群，其最好可以自己组成一个集群，并可以自己同步集群数据，而不需要依赖于一个第三方系统来同步数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;服务化&lt;/strong&gt;。网关还需要做到在不间断的情况下修改配置，一种是像 Nginx reload 配置那样，可以做到不停服务，另一种是最好做到服务化。也就是说，得要有自己的 Admin API 来在运行时修改自己的配置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;持续化&lt;/strong&gt;。比如重启，就是像 Nginx 那样优雅地重启。有一个主管请求分发的主进程。当我们需要重启时，新的请求被分配到新的进程中，而老的进程处理完正在处理的请求后就退出。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高可用性涵盖了内部和外部的各种不确定因素，这里讲一下网关系统在高可用性方面做的努力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6378802747791953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnBmicq9YItGNicjRIljyy8IyGAeGvt7Ak5gHLJs8QAlibKpic83YT9vhWibNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1019&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高扩展&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为网关需要承接所有的业务流量和请求，所以一定会有或多或少的业务逻辑。而我们都知道，业务逻辑是多变和不确定的。比如，需要在网关上加入一些和业务相关的东西。因此，一个好的 Gateway 还需要是可以扩展的，并能进行二次开发的。当然，像 Nginx 那样通过 Module 进行二次开发的固然可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，在&lt;strong&gt;运维方面&lt;/strong&gt;，网关应该有以下几个设计原则。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;业务松耦合，协议紧耦合&lt;/strong&gt;。在业务设计上，网关不应与后面的服务之间形成服务耦合，也不应该有业务逻辑。网关应该是在网络应用层上的组件，不应该处理通讯协议体，只应该解析和处理通讯协议头。另外，除了服务发现外，网关不应该有第三方服务的依赖。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;应用监视，提供分析数据&lt;/strong&gt;。网关上需要考虑应用性能的监控，除了有相应后端服务的高可用的统计之外，还需要使用 Tracing ID 实施分布式链路跟踪，并统计好一定时间内每个 API 的吞吐量、响应时间和返回码，以便启动弹力设计中的相应策略。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;用弹力设计保护后端服务&lt;/strong&gt;。网关上一定要实现熔断、限流、重试和超时等弹力设计。如果一个或多个服务调用花费的时间过长，那么可接受超时并返回一部分数据，或是返回一个网关里的缓存的上一次成功请求的数据。你可以考虑一下这样的设计。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;DevOps&lt;/strong&gt;。因为网关这个组件太关键了，所以需要 DevOps 这样的东西，将其发生故障的概率降到最低。这个软件需要经过精良的测试，包括功能和性能的测试，还有浸泡测试。还需要有一系列自动化运维的管控工具。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关设计注意事项&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不要在网关中的代码里内置聚合后端服务的功能，而应考虑将聚合服务放在网关核心代码之外。可以使用 Plugin 的方式，也可以放在网关后面形成一个 Serverless 服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关应该靠近后端服务，并和后端服务使用同一个内网，这样可以保证网关和后端服务调用的低延迟，并可以减少很多网络上的问题。这里多说一句，网关处理的静态内容应该靠近用户（应该放到 CDN 上），而网关和此时的动态服务应该靠近后端服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关也需要做容量扩展，所以需要成为一个集群来分担前端带来的流量。这一点，要么通过 DNS 轮询的方式实现，要么通过 CDN 来做流量调度，或者通过更为底层的性能更高的负载均衡设备。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于服务发现，可以做一个时间不长的缓存，这样不需要每次请求都去查一下相关的服务所在的地方。当然，如果你的系统不复杂，可以考虑把服务发现的功能直接集成进网关中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为网关考虑 bulkhead 设计方式。用不同的网关服务不同的后端服务，或是用不同的网关服务前端不同的客户。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，因为网关是为用户请求和后端服务的桥接装置，所以需要考虑一些安全方面的事宜。具体如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;加密数据&lt;/strong&gt;。可以把 SSL 相关的证书放到网关上，由网关做统一的 SSL 传输管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;校验用户的请求&lt;/strong&gt;。一些基本的用户验证可以放在网关上来做，比如用户是否已登录，用户请求中的 token 是否合法等。但是，我们需要权衡一下，网关是否需要校验用户的输入。因为这样一来，网关就需要从只关心协议头，到需要关心协议体。而协议体中的东西一方面不像协议头是标准的，另一方面解析协议体还要耗费大量的运行时间，从而降低网关的性能。对此，我想说的是，看具体需求，一方面如果协议体是标准的，那么可以干；另一方面，对于解析协议所带来的性能问题，需要做相应的隔离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;检测异常访问&lt;/strong&gt;。网关需要检测一些异常访问，比如，在一段比较短的时间内请求次数超过一定数值；还比如，同一客户端的 4xx 请求出错率太高……对于这样的一些请求访问，网关一方面要把这样的请求屏蔽掉，另一方面需要发出警告，有可能会是一些比较重大的安全问题，如被黑客攻击。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关应用&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;流量网关&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流量网关,顾名思义就是控制流量进入集群的网关,有很多工作需要在这一步做,对于一个服务集群,势必有很多非法的请求或者无效的请求,这时候要将请求拒之门外,降低集群的流量压力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7756410256410257&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnB9xadHmDaE1z2dTOa1S1iaRh3DRwkzP1nMiaVetJgy4aLkDXjprIaPWjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义全局性的、跟具体的后端业务应用和服务完全无关的策略网关就是上图所示的架构模型——流量网关。流量网关通常只专注于全局的Api管理策略，比如全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等，有点类似防火墙。&lt;strong&gt;Kong 就是典型的流量网关。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是kong的架构图,来自官网:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8866171003717472&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnBxSDedrSFINCyChedV95ALl1YC4EwH00VOSRZEibYhTXOblDTyp3Jia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;538&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要补充一点的是，业务网关一般部署在流量网关之后、业务系统之前，比流量网关更靠近业务系统。通常API网指的是业务网关。有时候我们也会模糊流量网关和业务网关，让一个网关承担所有的工作,所以这两者之间并没有严格的界线。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;业务网关&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个单体应用被拆分成许许多多的微服务应用后，也带来了一些问题。一些与业务非强相关的功能，比如权限控制、日志输出、数据加密、熔断限流等，每个微服务应用都需要，因此存在着大量重复的代码实现。而且由于系统的迭代、人员的更替，各个微服务中这些功能的实现细节出现了较大的差异，导致维护成本变高。另一方面，原先单体应用下非常容易做的接口管理，在服务拆分后没有了一个集中管理的地方，无法统计已存在哪些接口、接口定义是什么、运行状态如何。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关就是为了解决上述问题。作为微服务体系中的核心基础设施，一般需要具备接口管理、协议适配、熔断限流、安全防护等功能，各种开源的网关产品（比如 zuul）都提供了优秀高可扩展性的架构、可以很方便的实现我们需要的一些功能、比如鉴权、日志监控、熔断限流等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与流量网关相对应的就是业务网关,业务网关更靠近我们的业务,也就是与服务器应用层打交道,那么有很多应用层需要考虑的事情就可以依托业务网关,例如在线程模型、协议适配、熔断限流，服务编排等。下面看看业务网关体系结构:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5388888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnBchicz2dcApZAialCEdiabVswe0mZpLHgjlk7bqg3AU0qGtf5icc32LD0rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个图中可以看出业务网关主要职责以及所做的事情, 目前业务网关比较成熟的 API 网关框架产品有三个 分别是:Zuul1、Zuul2 和 SpringCloud Gateway, 后面再进行对比。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关与服务器集群&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到我们服务器上,下面图介绍了网关(Gateway)作用,可知 Gateway 方式下的架构，可以细到为每一个服务的实例配置一个自己的 Gateway，也可以粗到为一组服务配置一个，甚至可以粗到为整个架构配置一个接入的 Gateway。于是，整个系统架构的复杂度就会变得简单可控起来。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5196759259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnBY7Z9lzTQcCcj2spkrwLzwb1ibeN1HNxy70FT4EK1ybkDCvFQuKypsKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这张图展示了一个多层 Gateway 架构，其中有一个总的 Gateway 接入所有的流量(&lt;strong&gt;流量网关&lt;/strong&gt;)，并分发给不同的子系统，还有第二级 Gateway 用于做各个子系统的接入 Gateway(&lt;strong&gt;业务网关&lt;/strong&gt;)。可以看到，网关所管理的服务粒度可粗可细。通过网关，我们可以把分布式架构组织成一个星型架构，由网络对服务的请求进行路由和分发。下面来聊聊好的网关应该具备哪些功能,也就是网关设计模式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常见网关对比&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然对比,就先宏观上对各种网关有一个了解,后面再挑一些常用的或者说应用广泛的详细了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前常见的开源网关大致上按照语言分类有如下几类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Nginx+lua：OpenResty、Kong、Orange、Abtesting gateway 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java：Zuul/Zuul2、Spring Cloud Gateway、Kaazing KWG、gravitee、Dromara soul 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go：Janus、fagongzi、Grpc-gateway&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Dotnet：Ocelot&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NodeJS：Express Gateway、Micro Gateway&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照使用数量、成熟度等来划分，主流的有 4 个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;OpenResty&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kong&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Zuul/Zuul2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Cloud Gateway&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;OpenResty&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty是一个流量网关,根据前面对流量网关的介绍就可以知道流量网关的指责。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过揉和众多设计良好的 Nginx 模块，OpenResty 有效地把 Nginx 服务器转变为一个强大的 Web 应用服务器，基于它开发人员可以使用 Lua 编程语言对 Nginx 核心以及现有的各种 Nginx C 模块进行脚本编程，构建出可以处理一万以上并发请求的极端高性能的 Web 应用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty 最早是顺应 OpenAPI 的潮流做的，所以 Open 取自“开放”之意，而Resty便是 REST 风格的意思。虽然后来也可以基于 ngx_openresty 实现任何形式的 web service 或者传统的 web 应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说 Nginx 不再是一个简单的静态网页服务器，也不再是一个简单的反向代理了。第二代的 openresty 致力于通过一系列 nginx 模块，把nginx扩展为全功能的 web 应用服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ngx_openresty 是用户驱动的项目，后来也有不少国内用户的参与，从 openresty.org 的点击量分布上看，国内和国外的点击量基本持平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ngx_openresty 目前有两大应用目标：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通用目的的 web 应用服务器。在这个目标下，现有的 web 应用技术都可以算是和 OpenResty 或多或少有些类似，比如 Nodejs, PHP 等等。ngx_openresty 的性能（包括内存使用和 CPU 效率）算是最大的卖点之一。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Nginx 的脚本扩展编程，用于构建灵活的 Web 应用网关和 Web 应用防火墙。有些类似的是 NetScaler。其优势在于 Lua 编程带来的巨大灵活性。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Kong&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关连接: 官网、Github&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong基于OpenResty开发，也是流量层网关, 是一个云原生、快速、可扩展、分布式的Api 网关。继承了OpenResty的高性能、易扩展性等特点。Kong通过简单的增加机器节点，可以很容易的水平扩展。同时功能插件化，可通过插件来扩展其能力。而且在任何基础架构上都可以运行。具有以下特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;提供了多样化的认证层来保护Api。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可对出入流量进行管制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供了可视化的流量检查、监视分析Api。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够及时的转换请求和相应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供log解决方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可通过api调用Serverless 函数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kong解决了什么问题&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们决定对应用进行微服务改造时，应用客户端如何与微服务交互的问题也随之而来，毕竟服务数量的增加会直接导致部署授权、负载均衡、通信管理、分析和改变的难度增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面对以上问题，API GATEWAY是一个不错的解决方案，其所提供的访问限制、安全、流量控制、分析监控、日志、请求转发、合成和协议转换功能，可以解放开发者去把精力集中在具体逻辑的代码，而不是把时间花费在考虑如何解决应用和其他微服务链接的问题上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图片来自Kong官网:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.661&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnBzQVSlZeWwEgv5K7POpDziaocfTdKr2Y17PbBnvVVsflPZZYzabHbNVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到Kong解决的问题。专注于全局的Api管理策略，全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kong的优点以及性能&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在众多 API GATEWAY 框架中，Mashape 开源的高性能高可用API网关和API服务管理层——KONG（基于 NGINX+Lua）特点尤为突出，它可以通过插件扩展已有功能，这些插件（使用 lua 编写）在API请求响应循环的生命周期中被执行。于此同时，KONG本身提供包括 HTTP 基本认证、密钥认证、CORS、TCP、UDP、文件日志、API请求限流、请求转发及 NGINX 监控等基本功能。目前，Kong 在 Mashape 管理了超过 15,000 个 API，为 200,000 开发者提供了每月数十亿的请求支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kong架构&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong提供一些列的服务,这就不得不谈谈内部的架构:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.237691001697793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnBcGRL65GCzH2ngZNm2vTsA1eXRy4HTRRTA8ORg9KIabqO0Dhypob79Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;589&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先最底层是基于Nginx, Nginx是高性能的基础层, 一个良好的负载均衡、反向代理器,然后在此基础上增加Lua脚本库,形成了OpenResty,拦截请求, 响应生命周期,可以通过Lua编写脚本,所以插件比较丰富。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Zuul1.0&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul是所有从设备和web站点到Netflix流媒体应用程序后端请求的前门。作为一个边缘服务应用程序，Zuul被构建来支持动态路由、监视、弹性和安全性。它还可以根据需要将请求路由到多个Amazon自动伸缩组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul使用了一系列不同类型的过滤器，使我们能够快速灵活地将功能应用到服务中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;过滤器&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过滤器是Zuul的核心功能。它们负责应用程序的业务逻辑，可以执行各种任务。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Type&lt;/strong&gt; ：通常定义过滤器应用在哪个阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Async&lt;/strong&gt; ：定义过滤器是同步还是异步&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Execution Order&lt;/strong&gt; ：执行顺序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Criteria&lt;/strong&gt; ：过滤器执行的条件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Action&lt;/strong&gt; ：如果条件满足，过滤器执行的动作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul提供了一个动态读取、编译和运行这些过滤器的框架。过滤器之间不直接通信，而是通过每个请求特有的RequestContext共享状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是Zuul的一些过滤器:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Incoming&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Incoming过滤器在请求被代理到Origin之前执行。这通常是执行大部分业务逻辑的地方。例如:认证、动态路由、速率限制、DDoS保护、指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Endpoint&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Endpoint过滤器负责基于incoming过滤器的执行来处理请求。Zuul有一个内置的过滤器（ProxyEndpoint），用于将请求代理到后端服务器，因此这些过滤器的典型用途是用于静态端点。例如:健康检查响应，静态错误响应，404响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Outgoing&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Outgoing过滤器在从后端接收到响应以后执行处理操作。通常情况下，它们更多地用于形成响应和添加指标，而不是用于任何繁重的工作。例如:存储统计信息、添加/剥离标准标题、向实时流发送事件、gziping响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;过滤器类型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是与一个请求典型的生命周期对应的标准的过滤器类型：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;PRE&lt;/strong&gt; ：路由到Origin之前执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ROUTING&lt;/strong&gt; ：路由到Origin期间执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;POST&lt;/strong&gt; ：请求被路由到Origin之后执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ERROR&lt;/strong&gt; ：发生错误的时候执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些过滤器帮助我们执行以下功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;身份验证和安全性&lt;/strong&gt; ：识别每个资源的身份验证需求，并拒绝不满足它们的请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;监控&lt;/strong&gt; ：在边缘跟踪有意义的数据和统计数据，以便给我们一个准确的生产视图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;动态路由&lt;/strong&gt; ：动态路由请求到不同的后端集群&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;压力测试&lt;/strong&gt; ：逐渐增加集群的流量，以评估性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;限流&lt;/strong&gt; ：为每种请求类型分配容量，并丢弃超过限制的请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;静态响应处理&lt;/strong&gt; ：直接在边缘构建一些响应，而不是将它们转发到内部集群&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Zuul 1.0 请求生命周期&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnBSw5gZiaIQQDgW7F3cVibmlhXHI2daCAx2c2wkmj2VIicAqAQsYORLoibJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netflix宣布了通用API网关Zuul的架构转型。Zuul原本采用同步阻塞架构，转型后叫作Zuul2，采用异步非阻塞架构。Zuul2和Zuul1在架构方面的主要区别在于，Zuul2运行在异步非阻塞的框架上，比如Netty。Zuul1依赖多线程来支持吞吐量的增长，而Zuul 2使用的Netty框架依赖事件循环和回调函数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Zuul2.0&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul 2.0 架构图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8268348623853211&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnBCTMWGONEcnhBdXTjLC4WOXEibia5u6rnQKJhP4ZMmlicGpaZ52Rk7LjJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是Zuul2的架构，和Zuul1没有本质区别，两点变化：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;前端用Netty Server代替Servlet，目的是支持前端异步。后端用Netty Client代替Http Client，目的是支持后端异步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;过滤器换了一下名字，用Inbound Filters代替Pre-routing Filters，用Endpoint Filter代替Routing Filter，用Outbound Filters代替Post-routing Filters。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Inbound Filters&lt;/strong&gt; ：路由到 Origin 之前执行，可以用于身份验证、路由和装饰请求&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Endpoint Filters&lt;/strong&gt; ：可用于返回静态响应，否则内置的ProxyEndpoint过滤器将请求路由到Origin&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Outbound Filters&lt;/strong&gt; ：从Origin那里获取响应后执行，可以用于度量、装饰用户的响应或添加自定义header&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种类型的过滤器：sync 和 async。因为Zuul是运行在一个事件循环之上的，因此从来不要在过滤中阻塞。如果你非要阻塞，可以在一个异步过滤器中这样做，并且在一个单独的线程池上运行，否则可以使用同步过滤器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提到过&lt;strong&gt;Zuul2开始采用了异步模型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优势&lt;/strong&gt;是异步非阻塞模式启动的线程很少，基本上一个CPU core上只需启一个事件环处理线程，它使用的线程资源就很少，上下文切换(Context Switch)开销也少。非阻塞模式可以接受的连接数大大增加，可以简单理解为请求来了只需要进队列，这个队列的容量可以设得很大，只要不超时，队列中的请求都会被依次处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不足之处：&lt;/strong&gt;异步模式让编程模型变得复杂。一方面Zuul2本身的代码要比Zuul1复杂很多，Zuul1的代码比较容易看懂，Zuul2的代码看起来就比较费劲。另一方面异步模型没有一个明确清晰的请求-&amp;gt;处理-&amp;gt;响应执行流程(call flow)，它的流程是通过事件触发的，请求处理的流程随时可能被切换断开，内部实现要通过一些关联id机制才能把整个执行流再串联起来，这就给开发调试运维引入了很多复杂性，比如你在IDE里头调试异步请求流就非常困难。另外ThreadLocal机制在这种异步模式下就不能简单工作，因为只有一个事件环线程，不是每个请求一个线程，也就没有线程局部的概念，所以对于CAT这种依赖于ThreadLocal才能工作的监控工具，调用链埋点就不好搞(实际可以工作但需要进行特殊处理)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体上，异步非阻塞模式比较适用于IO密集型(IO bound)场景，这种场景下系统大部分时间在处理IO，CPU计算比较轻，少量事件环线程就能处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Zuul 与 Zuul 2 性能对比&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图片来源:Zuul&#x27;s Journey to Non-Blocking&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5626959247648903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnBLtC2GGLiaB6hZtBhfjjb2ELWuISyD2ib8qgqCvAoDfnic6ZaQqibHJNMDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;638&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netflix给出了一个比较模糊的数据，&lt;strong&gt;大致Zuul2的性能比Zuul1好20%左右&lt;/strong&gt;，这里的性能主要指每节点每秒处理的请求数。为什么说模糊呢？因为这个数据受实际测试环境，流量场景模式等众多因素影响，你很难复现这个测试数据。即便这个20%的性能提升是确实的，其实这个性能提升也并不大，和异步引入的复杂性相比，这20%的提升是否值得是个问题。Netflix本身在其博文22和ppt11中也是有点含糊其词，甚至自身都有一些疑问的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Cloud Gateway&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理详见这篇：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451964154&amp;amp;idx=1&amp;amp;sn=202154c1206936d8eaa72e617a2ef6ad&amp;amp;chksm=8d1ff965ba6870732290b202e2f97c85f9c8c6f84f8d33e57dca63085f5eefc9aba05e0ef523&amp;amp;token=30209230&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringCloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 2.0之前的非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spring Cloud Gateway 底层使用了高性能的通信框架Netty&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SpringCloud Gateway 特征&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringCloud官方，对SpringCloud Gateway 特征介绍如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）集成 Hystrix 断路器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）集成 Spring Cloud DiscoveryClient&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）Predicates 和 Filters 作用于特定路由，易于编写的 Predicates 和 Filters&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）具备一些网关的高级功能：动态路由、限流、路径重写&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从以上的特征来说，和Zuul的特征差别不大。SpringCloud Gateway和Zuul主要的区别，还是在底层的通信框架上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说明一下上文中的三个术语：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Filter&lt;/strong&gt;（过滤器）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和Zuul的过滤器在概念上类似，可以使用它拦截和修改请求，并且对上游的响应，进行二次处理。过滤器为org.springframework.cloud.gateway.filter.GatewayFilter类的实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Route&lt;/strong&gt;（路由）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关配置的基本组成模块，和Zuul的路由配置模块类似。一个&lt;strong&gt;Route模块&lt;/strong&gt;由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Predicate&lt;/strong&gt;（断言）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个 Java 8 的 Predicate，可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。&lt;strong&gt;断言的&lt;/strong&gt;输入类型是一个 ServerWebExchange。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关对比总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5724867724867725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3mbH9eBHcHpZkIFjHDMJnBvFt32r61nyEweKrCMKqhazibx3vibQS1gO52OoqEfBmJ9zPCmJnSz1Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1890&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>957ca44f3c225ef39fdbafc47eb69464</guid>
<title>微服务接口设计原则</title>
<link>https://toutiao.io/k/4hjv10p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文结合自身后台开发经验，从高可用、高性能、易维护和低风险（安全）角度出发，尝试总结业界常见微服务接口设计原则，帮助大家设计出优秀的微服务。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.前言&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务是一种系统架构风格，是 SOA（面向服务架构）的一种实践。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个大型复杂的软件应用，都可以拆分成多个微服务。各个微服务可被独立部署，各个微服务之间是松耦合的。现如今后台服务大部分以微服务的形式存在，每个微服务负责实现应用的一个功能模块。而微服务由一个个接口组成，每个接口实现某个功能模块下的子功能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6090909090909091&quot; data-type=&quot;jpeg&quot; data-w=&quot;440&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSwdqbUbs63K9BXCcOxdcViaRI0p4BwY9z6iaqguSmDq6icvlQa1vLvD5BA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以一个 IM 应用为例，它的功能架构可能是下面这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46440677966101696&quot; data-type=&quot;jpeg&quot; data-w=&quot;590&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSVnZFJG5dLez7sSNvwiaicYow51eDtluI5LaImrbcatibwGSbjcO0LoibyA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果是后台开发的同学，经常需要实现一个后台微服务来提供相应的能力，完成业务功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务以接口形式提供服务。在实现服务时，我们要将一个大的功能拆分成一个个独立的子功能来实现，每一个子功能就是我们要在服务中实现的一个接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时一个服务会有很多接口，每个接口所要实现的功能可能会有关联，那么这就非常考验设计服务接口的功底，让服务变得简单可靠。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界已经有很多比较成熟的实践原则，可以帮助我们设计实现出一个可靠易维护的服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务设计原则并没有严格的规范，下面结合业界成熟的方法和个人多年后台开发经验，介绍&lt;strong&gt;高可用，高性能，易维护，低风险&lt;/strong&gt;服务常用的设计原则。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.高可用&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 降级兜底&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分服务是如下的结构，既要给使用方使用，又依赖于他人提供的第三方服务，中间又穿插了各种业务逻辑，这里每一块都可能是故障的来源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1514476614699332&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrS6dRnQIKW4Micrwe30ypJE28koxym1YCtcAWmNibJ432qJ7xQicZUXKrFw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果第三方服务挂掉怎么办？我们业务也跟着挂掉？显然这不是我们希望看到的结果，如果能制定好降级兜底的方案，那将大大提高服务的可靠性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们做个性化推荐服务时，需要从用户中心获取用户的个性化数据，以便代入到模型里进行打分排序，但如果用户中心服务挂掉，我们获取不到数据了，那么就不推荐了？显然不行，我们可以在本地 cache 里放置一份热门商品以便兜底。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又比如做一个数据同步的服务，这个服务需要从第三方获取最新的数据并更新到 MySQL 中，恰好第三方提供了两种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一种是消息通知服务，只发送变更后的数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一种是 HTTP 服务，需要我们自己主动调用获取数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一开始选择消息同步的方式，因为实时性更高，但是之后就遭遇到消息迟迟发送不过来的问题，而且也没什么异常，等我们发现一天时间已过去，问题已然升级为故障。合理的方式应该两个同步方案都使用，消息方式用于实时更新，HTTP 主动同步方式定时触发（比如 1 小时）用于兜底，即使消息出了问题，通过主动同步也能保证一小时一更新。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 过载保护（保护自己）&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是高并发场景使用的接口，那么需要做过载保护，防止服务过载引发雪崩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信很多做过高并发服务的同学都碰到类似事件：某天 A 君突然发现自己的接口请求量突然涨到之前的 10 倍，没多久该接口几乎不可使用，并引发连锁反应导致整个系统崩溃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何应对这种情况？生活给了我们答案：比如老式电闸都安装了保险丝，一旦有人使用超大功率的设备，保险丝就会烧断以保护各个电器不被强电流给烧坏。同理我们的接口也需要安装上“保险丝”，以防止非预期的请求对系统压力过大而引起的系统瘫痪，当流量过大时，可以采取拒绝或者引流等机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过载保护的做法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如把接收到的请求放在指定的队列中排队处理，如果请求等待时间超时了（假设是 100ms），这个时候直接拒绝超时请求；再比如队列满了之后，就清除队列中一定数量的排队请求，保护服务不过载，保障服务高可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据服务当前指标（如 CPU、内存使用率、平均耗时等）判断服务是否处于过载，过载则及早拒绝请求并带上特殊错误码，告知上游下游已经过载，应做限流处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3 流量控制（保护下游）&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流量控制，或者叫限流，一般用户保护下游不被大流量压垮。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的场景有：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）下游有严格的请求限制；比如银行转账接口，微信支付接口等都有严格的接口限频；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）调用的下游不是为高并发场景设计；比如提供异步计算结果拉取的服务，并不需要考虑各种复杂的高并发业务场景，提供高并发流量场景的支持。每个业务场景应该在拉取数据时缓存下来，而不是每次业务请求都过来拉取，将业务流量压垮下游。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）失败重试。调用下游失败了，一定要重试吗？如果不管三七二十一直接重试，这样是不对的，比如有些业务返回的异常表示业务逻辑出错，那么你怎么重试结果都是异常；又如有些异常是接口处理超时异常，这个时候就需要结合业务来判断了，有些时候重试往往会给后方服务造成更大压力，造成雪上加霜的效果。所有失败重试要有收敛策略，必要时才重试，做好限流处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;控制流量，常用的限流算法有漏桶算法和令牌桶算法。必要的情况下，需要实现分布式限流。&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.4 快速失败&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遵循快速失败原则，一定要设置超时时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某服务调用的一个第三方接口正常响应时间是 50ms，某天该第三方接口出现问题，大约有 15%的请求响应时间超过 2s，没过多久服务 load 飙高到 10 倍以上，响应时间也非常缓慢，即第三方服务将我们服务拖垮了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会被拖垮？没设置超时！我们采用的是同步调用方式，使用了一个线程池，该线程池里最大线程数设置了 50，如果所有线程都在忙，多余的请求就放置在队列里中。如果第三方接口响应时间都是 50ms 左右，那么线程都能很快处理完自己手中的活，并接着处理下一个请求，但是不幸的是如果有一定比例的第三方接口响应时间为 2s，那么最后这 50 个线程都将被拖住，队列将会堆积大量的请求，从而导致整体服务能力极大下降。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确的做法是和第三方商量确定个较短的超时时间比如 200ms，这样即使他们服务出现问题也不会对我们服务产生很大影响。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.5 无状态服务&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽可能地使微服务无状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无状态服务，可以横向扩展，从而不会成为性能瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;状态即数据。如果某一调用方的请求一定要落到某一后台节点，使用服务在本地缓存的数据（状态），那么这个服务就是有状态的服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以前在本地内存中建立的数据缓存、Session 缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.6 最少依赖&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能不依赖的，尽可能不依赖，越少越好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;减少依赖，便可以减少故障发生的可能性，提高服务可靠性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何依赖都有可能发生故障，即使其如何保证，我们在设计上应尽可能地减少对第三方的依赖。如果无法避免，则需要对第三方依赖在发生故障时做好相应处理，避免因第三方依赖的抖动或不可用导致我们自身服务不可用，比如降级兜底。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.7 简单可靠&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可靠性只有靠不断追求最大程度的简化而得到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乏味是一种美德。与生活中的其他东西不同，对于软件而言，“乏味”实际上是非常正面的态度。我们不想要自发性的和有趣的程序；我们希望这些程序按设计执行，可以预见性地完成目标。与侦探小说不同，缺少刺激、悬念和困惑是源代码的理想特征。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为工程师也是人，他们经常对于自己编写的代码形成一种情感依附，这些冲突在大规模清理源代码的时候并不少见。一些人可能会提出抗议，“如果我们以后需要这个代码怎么办？”，“我们为什么不只是把这些代码注释掉，这样稍后再使用它的时候会更容易。”，“为什么不增加一个功能开关？”，这些都是糟糕的建议。源代码控制系统中的更改反转很容易，数百行的注释代码则会造成干扰和混乱；那些由于功能开关没有启用而没有被执行的代码，就像一个定时炸弹等待爆炸。极端地说，当你指望一个 Web 服务 7*24 可以用时，某种程度上，每一行新代码都是负担。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;法国诗人 Antoine de Saint-Exupéry 曾写道：“不是在不能添加更多的时候，而是没有什么可以去掉的时候，才能达到完美”。这个原则同样适用于软件设计。API 设计是这个规则应该被遵循的一个清晰的例子。书写一个明确的、简单的 API 是接口可靠的保证。我们向 API 消费者提供的方法和参数越少，这些 API 就越容易理解。在软件工程上，少就是多！一个很小的，很简单的 API 通常也是一个对问题深刻理解的标志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件的简单性是可靠性的前提条件。当我们考虑如何简化一个给定的任务的每一步时，我们并不是在偷懒。相反，我们是在明确实际上要完成的任务是什么，以及如何容易地做到。我们对新功能说“不”的时候，不是在限制创新，而是在保持环境整洁，以免分心。这样我们可以持续关注创新，并且可以进行真正的工程工作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.8 分散原则&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鸡蛋不要放一个篮子，分散风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如一个模块的所有接口不应该放到同一个服务中，如果服务不可用，那么该模块的所有接口都不可用了。我们可以基于主次进行服务拆分，将重要接口放到一个服务中，次要接口放到另外一个服务中，避免相互影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再如所有交易数据都放在同一个库同一张表里面，万一这个库挂了，此时影响所有交易。我们可以对数据库水平切分，分库分表。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.9 隔离原则&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制风险不扩散，不放大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同模块之间要相互隔离，避免单个模块有问题影响其他模块，传播扩散了影响范围。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如部署隔离：每个模块的服务部署在不同物理机上；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再如 DB 隔离：每个模块单独使用自身的存储实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;古代赤壁之战就是一个典型的反面例子，铁锁连船导致隔离性被破坏，一把大火烧了 80W 大军。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;隔离是有级别的，隔离级别越高，风险传播扩散的难度就越大，容灾能力越强。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：一个应用集群由 N 台服务器组成，部署在同一台物理机上，或同一个机房的不同物理机上，或同一个城市的不同机房里，或不同城市里，不同的部署代表不同的容灾能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：人类由无数人组成，生活在同一个地球的不同洲上，这意味着人类不具备星球级别的隔离能力，当地球出现毁灭性影响时，人类是不具备容灾的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.10 幂等设计（可重入）&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓幂等，简单地说，就是对接口的多次调用所产生的结果和调用一次是一致的。数据发生改变才需要做幂等，有些接口是天然保证幂等性的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如查询接口，有些对数据的修改是一个常量，并且无其他记录和操作，那也可以说是具有幂等性的。其他情况下，所有涉及对数据的修改、状态的变更就都有必要防止重复性操作的发生。实现接口的幂等性可防止重复操作所带来的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重复请求很容易发生，比如用户误触，超时重试等。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果时网络异常（超时成功），此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条，就没有保证接口的幂等性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.11 故障自愈&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有 100% 可靠的系统，故障不可避免，但要有自愈能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人体拥有强大的自愈能力，比如手指划破流血，会自动止血，结痂，再到皮肤再生。微服务应该像人体一样，当面对非毁灭性伤害（故障）时，在不借助外力的情况下，自行修复故障。比如消息处理或异步逻辑等非关键操作失败引发的数据不一致，需要有最终一致的修复操作，如兜底的定时任务，失败重试队列，或由用户在下次请求时触发修复逻辑。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.12 CAP 定理&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2000 年，加州大学伯克利分校的计算机科学家 &lt;a href=&quot;https://en.wikipedia.org/wiki/Eric_Brewer_(scientist)&quot; data-linktype=&quot;2&quot;&gt;Eric Brewer&lt;/a&gt; 在分布式计算原理研讨会（PODC）上提出了一个猜想，分布式系统有三个指标：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;一致性（Consistency）&lt;br/&gt;可用性（Availability）&lt;br/&gt;分区容错性（Partition tolerance）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们的第一个字母分别是 C、A、P。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9184952978056427&quot; data-type=&quot;jpeg&quot; data-w=&quot;638&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSveEQJv1icT2yPw9FWXnp75u672GsdjYeicFbZvibVic04OulZ9sv2tkSZg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Eric Brewer 说，这三个指标最多只能同时实现两点，不可能三者兼顾，这便是著名的布鲁尔猜想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在随后的 2002 年，麻省理工学院（MIT）的 Seth Gilbert 和 Nancy Lynch 发表了布鲁尔猜想的证明，使之成为一个定理，即 CAP 定理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAP 定理告诉我们，如果服务是分布式服务，那么不同节点间通信必然存在失败可能性，即我们必须接受分区容错性（P），那么我们必须在一致性（C）和可用性（A）之间做出取舍，即要么 CP，要么 AP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的服务偏业务逻辑，对接用户，那么可用性显得更加重要，应该选择 AP，遵守 &lt;a href=&quot;https://en.wikipedia.org/wiki/Eventual_consistency&quot; data-linktype=&quot;2&quot;&gt;BASE 理论&lt;/a&gt;，这是大部分业务服务的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的服务偏系统控制，对接服务，那么一致性显得更加重要，应该选择 CP，遵守 &lt;a href=&quot;https://en.wikipedia.org/wiki/ACID&quot; data-linktype=&quot;2&quot;&gt;ACID 理论&lt;/a&gt;，经典的比如 Zookeeper。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来说 BASE 理论面向的是大型高可用、可扩展的分布式系统。与传统 ACID 特性相反，不同于 ACID 的强一致性模型，BASE 提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样，因此在设计中，ACID 和 BASE 应做好权衡和选择。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.13 BASE 理论&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 CAP 定理的背景下，大部分分布式系统都偏向业务逻辑，面向用户，那么可用性相对一致性显得更加重要。如何构建一个高可用的分布式系统，BASE 理论给出了答案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2008 年，eBay 公司选则把资料库事务的 ACID 原则放宽，于&lt;a href=&quot;https://www.acm.org/&quot; data-linktype=&quot;2&quot;&gt;计算机协会&lt;/a&gt;（Association for Computing Machinery，ACM）上发表了一篇文章&lt;a href=&quot;https://queue.acm.org/detail.cfm?id=1394128&quot; data-linktype=&quot;2&quot;&gt;Base: An Acid Alternative&lt;/a&gt;，正式提出了一套 BASE 原则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BASE 基于 CAP 定理逐步演化而来，其来源于对大型分布式系统实践的总结，是对 CAP 中一致性和可用性权衡的结果，&lt;strong&gt;其核心思想是即使无法做到强一致性，但每个业务根据自身的特点，采用适当的方式来使系统达到最终一致性&lt;/strong&gt;。BASE 可以看作是 CAP 定理的延伸。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BASE 理论指：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Basically Available（基本可用）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本可用就是假设系统出现故障，要保证系统基本可用，而不是完全不能使用。比如采用降级兜底的策略，假设我们在做个性化推荐服务时，需要从用户中心获取用户的个性化数据，以便代入到模型里进行打分排序。但如果用户中心服务挂掉，我们获取不到数据了，那么就不推荐了？显然不行，我们可以在本地 cache 里放置一份热门商品以便兜底。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软状态指的是允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Eventual consistency（最终一致性）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面讲到的软状态不可能一直是软状态，必须有时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性，因此所有客户端对系统的数据访问最终都能够获取到最新的值，而这个时间期限取决于网络延时，系统负载，数据复制方案等因素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.高性能&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 无锁&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.1 锁的问题&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高性能系统中使用锁，往往带来的坏处要大于好处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发编程中，锁带解决了安全问题，同时也带来了性能问题，因为锁让并发处理变成了串行操作，所以如无必要，尽量不要显式使用锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁和并发，貌似有一种相克相生的关系。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.638&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSsVSyOh2MLUQ6ucIJDibibN6lTdRiaHgrOPu6Hj7Bs0uBCiapw3qd3iaib2zA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免严重的锁竞争导致性能的下降，有些场景采用了无锁化设计，特别是在底层框架上。无锁化主要有两种实现，无锁队列和无锁数据结构。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.2 串行无锁&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;串行无锁最简单的实现方式可能就是单线程模型了，如 Redis/Nginx 都采用了这种方式。在网络编程模型中，常规的方式是主线程负责处理 I/O 事件，并将读到的数据压入队列，工作线程则从队列中取出数据进行处理，这种单 Reactor 多线程模型需要对队列进行加锁，这种模型叫单 Reactor 多线程模型。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5383022774327122&quot; data-type=&quot;jpeg&quot; data-w=&quot;966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSl4XR6e3X3M0mrvWdDGeoIFmR7peevarUL9GRuD17D1L7kga7jOgmdw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图的模式可以改成串行无锁的形式，当 MainReactor accept 一个新连接之后从众多的 SubReactor 选取一个进行注册，通过创建一个 Queue 与 I/O 线程进行绑定，此后该连接的读写都在同一个队列和线程中执行，无需进行队列的加锁。这种模型叫主从 Reactor 多线程模型。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4211409395973154&quot; data-type=&quot;jpeg&quot; data-w=&quot;1192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSzY0D9Bfzib2YvgTYFI2dckE0nBQRkVbbXBs5b0gHnRJwtsIaAbGXrFg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.3 无锁数据结构&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用硬件支持的原子操作可以实现无锁的数据结构，很多语言都提供 CAS 原子操作（如 Go 中的 atomic 包和 C++11 中的 atomic 库），可以用于实现无锁数据结构，如无锁链表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以一个简单的线程安全单链表的插入操作来看下无锁编程和普通加锁的区别。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    Node(&lt;span&gt;const&lt;/span&gt; T &amp;amp;value) : data(value) {}&lt;br/&gt;    T data;&lt;br/&gt;    Node *next = &lt;span&gt;nullptr&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有锁链表 WithLockList：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WithLockList&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    mutex mtx;&lt;br/&gt;    Node&amp;lt;T&amp;gt; *head;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;pushFront&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; T &amp;amp;value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;auto&lt;/span&gt; *node = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;T&amp;gt;(value);&lt;br/&gt;        &lt;span&gt;lock_guard&amp;lt;mutex&amp;gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(mtx)&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// (1)&lt;/span&gt;&lt;br/&gt;        node-&amp;gt;next = head;&lt;br/&gt;        head = node;&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无锁链表 LockFreeList：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockFreeList&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    atomic&amp;lt;Node&amp;lt;T&amp;gt; *&amp;gt; head;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;pushFront&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; T &amp;amp;value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;auto&lt;/span&gt; *node = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;T&amp;gt;(value);&lt;br/&gt;        node-&amp;gt;next = head.load();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(!head.compare_exchange_weak(node-&amp;gt;next, node)); &lt;span&gt;// (2)&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从代码可以看出，在有锁版本中 (1) 进行了加锁。在无锁版本中，(2) 使用了原子 CAS 操作 compare_exchange_weak，该函数如果存储成功则返回 true，同时为了防止伪失败（即原始值等于期望值时也不一定存储成功，主要发生在缺少单条比较交换指令的硬件机器上），通常将 CAS 放在循环中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面对有锁和无锁版本进行简单的性能比较，分别执行 1000,000 次 push 操作。测试代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SIZE = &lt;span&gt;1000000&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//有锁测试&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; start = chrono::steady_clock::now();&lt;br/&gt;    WithLockList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; wlList;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; SIZE; ++i)&lt;br/&gt;    {&lt;br/&gt;        wlList.pushFront(i);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; end = chrono::steady_clock::now();&lt;br/&gt;    chrono::duration&amp;lt;&lt;span&gt;double&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::micro&amp;gt; micro = end - start;&lt;br/&gt;    &lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;with lock list costs micro:&quot;&lt;/span&gt; &amp;lt;&amp;lt; micro.count() &amp;lt;&amp;lt; &lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//无锁测试&lt;/span&gt;&lt;br/&gt;    start = chrono::steady_clock::now();&lt;br/&gt;    LockFreeList&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; lfList;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; SIZE; ++i)&lt;br/&gt;    {&lt;br/&gt;        lfList.pushFront(i);&lt;br/&gt;    }&lt;br/&gt;    end = chrono::steady_clock::now();&lt;br/&gt;    micro = end - start;&lt;br/&gt;    &lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;free lock list costs micro:&quot;&lt;/span&gt; &amp;lt;&amp;lt; micro.count() &amp;lt;&amp;lt; &lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三次输出如下，可以看出无锁版本有锁版本性能高一些。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;with lock list costs micro:548118&lt;br/&gt;free lock list costs micro:491570&lt;br/&gt;with lock list costs micro:556037&lt;br/&gt;free lock list costs micro:476045&lt;br/&gt;with lock list costs micro:557451&lt;br/&gt;free lock list costs micro:481470&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.4 减少锁竞争&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果加锁无法避免，则可以采用分片的形式，减少对资源加锁的次数，这样也可以提高整体的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 Golang 优秀的本地缓存组件 &lt;a href=&quot;https://github.com/allegro/bigcache&quot; data-linktype=&quot;2&quot;&gt;bigcache&lt;/a&gt; 、&lt;a href=&quot;https://github.com/patrickmn/go-cache&quot; data-linktype=&quot;2&quot;&gt;go-cache&lt;/a&gt;、&lt;a href=&quot;https://github.com/coocood/freecache&quot; data-linktype=&quot;2&quot;&gt;freecache&lt;/a&gt; 都实现了分片功能，每个分片一把锁，采用分片存储的方式减少加锁的次数从而提高整体性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以一个简单的示例，通过对&lt;code&gt;map[uint64]struct{}&lt;/code&gt;分片前后并发写入的对比，来看下减少锁竞争带来的性能提升。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt; num = &lt;span&gt;1000000&lt;/span&gt;&lt;br/&gt; m0  = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}, num)&lt;br/&gt; mu0 = sync.RWMutex{}&lt;br/&gt; m1  = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}, num)&lt;br/&gt; mu1 = sync.RWMutex{}&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConWriteMapNoShard 不分片写入一个 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConWriteMapNoShard&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; g := errgroup.Group{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++ {&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   mu0.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu0.Unlock()&lt;br/&gt;   m0[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConWriteMapTwoShard 分片写入两个 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConWriteMapTwoShard&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; g := errgroup.Group{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++ {&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; i&amp;amp;&lt;span&gt;1&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    mu0.Lock()&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; mu0.Unlock()&lt;br/&gt;    m0[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   mu1.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu1.Unlock()&lt;br/&gt;   m1[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下二者的性能差异：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConWriteMapNoShard&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  ConWriteMapNoShard()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConWriteMapNoShard&lt;span&gt;-12&lt;/span&gt;                 &lt;span&gt;3&lt;/span&gt;         &lt;span&gt;472063245&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConWriteMapTwoShard&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  ConWriteMapTwoShard()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConWriteMapTwoShard&lt;span&gt;-12&lt;/span&gt;                &lt;span&gt;4&lt;/span&gt;         &lt;span&gt;310588155&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，通过对分共享资源的分片处理，减少了锁竞争，能明显地提高程序的并发性能。可以预见的是，随着分片粒度地变小，性能差距会越来越大。当然，分片粒度不是越小越好。因为每一个分片都要配一把锁，那么会带来很多额外的不必要的开销。可以选择一个不太大的值，在性能和花销上寻找一个平衡。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 缓存&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.1 为什么要有缓存？&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据的访问具有局部性，符合二八定律：80% 的数据访问是集中在 20% 的数据上，这部分数据也被称作热点数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同层级的存储访问速率不同，内存读写速度快于磁盘，磁盘快于远端存储。基于内存的存储系统（如 Redis）高于基于磁盘的存储系统（如 MySQL）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为存在热点数据和存储访问速率的不同，我们可以考虑采用缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存缓存一般使用内存作为本地缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;必要情况下，可以考虑多级缓存，如一级缓存采用本地缓存，二级缓存采用基于内存的存储系统（如 Redis、Memcache 等）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存是原始数据的一个复制集，其本质就是空间换时间，主要是为了解决高并发读。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.2 缓存的使用场景&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存是空间换时间的艺术，使用缓存能提高系统的性能。“劲酒虽好，可不要贪杯”，使用缓存的目的是为了提高性价比，而不是一上来就为了所谓的提高性能不计成本的使用缓存，而是要看场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适合使用缓存的场景，以之前参与过的项目企鹅电竞为例：（1）一旦生成后基本不会变化的数据：如企鹅电竞的游戏列表，在后台创建一个游戏之后基本很少变化，可直接缓存整个游戏列表；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）读密集型或存在热点的数据：典型的就是各种 App 的首页，如企鹅电竞首页直播列表；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）计算代价大的数据：如企鹅电竞的 Top 热榜视频，如 7 天榜在每天凌晨根据各种指标计算好之后缓存排序列表；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）千人一面的数据：同样是企鹅电竞的 Top 热榜视频，除了缓存的整个排序列表，同时直接在进程内按页缓存了前 N 页数据组装后的最终回包结果；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不适合使用缓存的场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）写多读少，更新频繁；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）对数据一致性要求严格。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.3 缓存的分类？&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）进程级缓存&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存的数据直接在进程地址空间内，这可能是访问速度最快使用最简单的缓存方式了。主要缺点是受制于进程空间大小，能缓存的数据量有限，进程重启缓存数据会丢失。一般通常用于缓存数据量不大的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）集中式缓存&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存的数据集中在一台机器上，如共享内存。这类缓存容量主要受制于机器内存大小，而且进程重启后数据不丢失。常用的集中式缓存中间件有单机版 redis、memcache 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）分布式缓存&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存的数据分布在多台机器上，通常需要采用特定算法（如 Hash）进行数据分片，将海量的缓存数据均匀的分布在每个机器节点上。常用的组件有：Memcache（客户端分片）、Codis（代理分片）、Redis Cluster（集群分片）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）多级缓存&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指在系统中的不同层级进行数据缓存，以提高访问效率和减少对后端存储系统的冲击。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.4 缓存的使用模式&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于缓存的使用，已经有人总结出了一些模式，主要分为 Cache-Aside 和 Cache-As-SoR 两类。其中 SoR（System-of-Record）表示记录系统，即数据源，而 Cache 正是 SoR 的拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这应该是最常见的缓存模式了。对于读，首先从缓存读取数据，如果没有命中则回源 SoR 读取并更新缓存。对于写操作，先写 SoR，再写缓存。这种模式架构图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6946902654867256&quot; data-type=&quot;jpeg&quot; data-w=&quot;452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSkXzAy81jWficwHv6sIMR7c3WQQEosgWUlUVdwdSObyXm5f1aQ8loDDw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式用起来简单，但对应用层不透明，需要业务代码完成读写逻辑。同时对于写来说，写数据源和写缓存不是一个原子操作，可能出现以下情况导致两者数据不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）在并发写时，可能出现数据不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，user1 和 user2 几乎同时进行读写。在 t1 时刻 user1 写 db，t2 时刻 user2 写 db，紧接着在 t3 时刻 user2 写缓存，t4 时刻 user1 写缓存。这种情况导致 db 是 user2 的数据，缓存是 user1 的数据，两者不一致。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.454054054054054&quot; data-type=&quot;jpeg&quot; data-w=&quot;370&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSIRIjUnXTYImZaKT2WwK0WcwQBQPlEVWk71OIFpjnuNA2xbRVBQicsyg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）先写数据源成功，但是接着写缓存失败，两者数据不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这两种情况如果业务不能忍受，可简单的通过先 delete 缓存然后再写 db 解决，其代价就是下一次读请求的 cache miss。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该模式把 Cache 当作 SoR，所以读写操作都是针对 Cache，然后 Cache 再将读写操作委托给 SoR，即 Cache 是一个代理。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1883656509695291&quot; data-type=&quot;jpeg&quot; data-w=&quot;722&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSAwxVYCwThsQKKqmKLPLweJ1viayibzT9Vd4TIN5EricOzBiaFX4cWZ2zBg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有三种实现方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）Read-Through：称为穿透读模式，首先查询 Cache，如果不命中则再由 Cache 回源到 SoR 即存储端实现 Cache-Aside 而不是业务）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Write-Through：称为穿透写模式，由业务先调用写操作，然后由 Cache 负责写缓存和 SoR。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）Write-Behind：称为回写模式，发生写操作时业务只更新缓存并立即返回，然后异步写 SoR，这样可以利用合并写/批量写提高性能。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.5 缓存淘汰策略&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在空间有限、低频热点访问或者无主动更新通知的情况下，需要对缓存数据进行回收，常用的回收策略有以下几种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）基于时间：基于时间的策略主要可以分两种。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;TTL（Time To Live）：即存活期，从缓存数据创建开始到指定的过期时间段，不管有没有访问缓存都会过期。如 Redis 的 EXPIRE。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TTI（Time To Idle）：即空闲期，缓存在指定的时间没有被访问将会被回收。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）基于空间：缓存设置了存储空间上限，当达到上限时按照一定的策略移除数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）基于容量：缓存设置了存储条目上限，当达到上限时按照一定的策略移除数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）基于引用：基于引用计数或者强弱引用的一些策略进行回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存常见淘汰算法如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;FIFO（First In First Out）：先进选出原则，先进入缓存的数据先被移除。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LRU（Least Recently Used）：最基于局部性原理，即如果数据最近被使用，那么它在未来也极有可能被使用，反之，如果数据很久未使用，那么未来被使用的概率也较。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LFU：（Least Frequently Used）：最近最少被使用的数据最先被淘汰，即统计每个对象的使用次数，当需要淘汰时，选择被使用次数最少的淘汰。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.6 缓存的崩溃与修复&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于在设计不足、请求攻击（并不一定是恶意攻击）等会造成一些缓存问题，下面列出了常见的缓存问题和解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大量使用不存在的 Key 进行查询时，缓存没有命中，这些请求都穿透到后端的存储，最终导致后端存储压力过大甚至被压垮。这种情况原因一般是存储中数据不存在，主要有三个解决办法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）设置空置或默认值：如果存储中没有数据，则设置一个空置或者默认值缓存起来，这样下次请求时就不会穿透到后端存储。但这种情况如果遇到恶意攻击，不断的伪造不同的 Key 来查询时并不能很好的应对，这时候需要引入一些安全策略对请求进行过滤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）布隆过滤器：采用布隆过滤器将，将所有可能存在的数据哈希到一个足够大的 Bitmap 中，一个一定不存在的数据会被这个 Bitmap 拦截掉，从而避免了对底层数据库的查询压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）singleflight
多个并发请求对一个失效的 Key 进行源数据获取时，只让其中一个得到执行，其余阻塞等待到执行的那个请求完成后，将结果传递给阻塞的其他请求达到防止击穿的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指大量的缓存在某一段时间内集体失效，导致后端存储负载瞬间升高甚至被压垮。通常是以下原因造成：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）缓存失效时间集中在某段时间，对于这种情况可以采取对不同的 Key 使用不同的过期时间，在原来基础失效时间的基础上再加上不同的随机时间；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）采用取模机制的某缓存实例宕机，这种情况移除故障实例后会导致大量的缓存不命中。有两种解决方案：（a）采取主从备份，主节点故障时直接将从实例替换主；（b）使用一致性哈希替代取模，这样即使有实例崩溃也只是少部分缓存不命中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然缓存系统本身性能很高，但也架不住某些热点数据的高并发访问从而造成缓存服务本身过载。假设一下微博以用户 ID 作为哈希 Key，突然有一天亦菲姐姐宣布婚了，如果她的微博内容按照用户 ID 缓存在某个节点上，当她的万千粉丝查看她的微博时必然会压垮这个缓存节点，因为这个 Key 太热了。这种情况可以通过生成多份缓存到不同节点上，每份缓存的内容一样，减轻单个节点访问的压力。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.6 缓存的一些好实践&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个缓存对象，可能分为很多种属性，这些属性中有的是静态的，有的是动态的。在缓存的时候最好采用动静分离的方式。以免因经常变动的数据发生更新而要把经常不变的数据也更新至缓存，成本很高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果缓存对象过大，每次读写开销非常大并且可能会卡住其他请求，特别是在 redis 这种单线程的架构中。典型的情况是将一堆列表挂在某个 value 的字段上或者存储一个没有边界的列表，这种情况下需要重新设计数据结构或者分割 value 再由客户端聚合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽量设置过期时间减少脏数据和存储占用，但要注意过期时间不能集中在某个时间段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存作为加速数据访问的手段，通常需要设置超时时间而且超时时间不能过长（如 100ms 左右），否则会导致整个请求超时连回源访问的机会都没有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，不同的业务使用不同的 Key，防止出现冲突或者互相覆盖。其次，核心和非核心业务进行通过不同的缓存实例进行物理上的隔离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用缓存需要有一定的降级预案，缓存通常不是关键逻辑，特别是对于核心服务，如果缓存部分失效或者失败，应该继续回源处理，不应该直接中断返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用缓存要进行容量控制，特别是本地缓存，缓存数量太多内存紧张时会频繁的 swap 存储空间或 GC 操作，从而降低响应速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以业务为导向，不要为了缓存而缓存。对性能要求不高或请求量不大，分布式缓存甚至数据库都足以应对时，就不需要增加本地缓存，否则可能因为引入数据节点复制和幂等处理逻辑反而得不偿失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对大对象、慢查询、内存占用等进行监控，做到缓存可观测，用得放心。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 异步&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.1 调用异步&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用异步发生在使用异步编程模型来提高代码效率的时候，实现方式主要有：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步回调通过注册一个回调函数，然后发起异步任务，当任务执行完毕时会回调用户注册的回调函数，从而减少调用端等待时间。这种方式会造成代码分散难以维护，定位问题也相对困难；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户提交一个任务时会立刻先返回一个 Future，然后任务异步执行，后续可以通过 Future 获取执行结果；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以对多个异步编程进行编排，组成更复杂的异步处理，并以同步的代码调用形式实现异步效果。CPS 将后续的处理逻辑当作参数传递给 Then 并可以最终捕获异常，解决了异步回调代码散乱和异常跟踪难的问题。Java 中的 CompletableFuture 和 C++ PPL 基本支持这一特性。典型的调用形式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;handleRequest&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Request &amp;amp;req)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; req.Read().Then([](Buffer &amp;amp;inbuf){&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; handleData(inbuf);&lt;br/&gt;  }).Then([](Buffer &amp;amp;outbuf){&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; handleWrite(outbuf);&lt;br/&gt;  }).Finally(){&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; cleanUp();&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 CPS 更多信息推荐阅读：2018 中国 C++ 大会的&lt;a href=&quot;http://km.oa.com/group/492/attachments/attachment_view/186319&quot; data-linktype=&quot;2&quot;&gt;吴锐_C++服务器开发实践部分&lt;/a&gt;。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.2 流程异步&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步改异步，可以降低主链路的处理耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，比如我们去 KFC 点餐，遇到排队的人很多，当点完餐后，大多情况下我们会隔几分钟就去问好了没，反复去问了好几次才拿到，在这期间我们也没法干活了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个就叫同步轮训，这样效率显然太低了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务员被问烦了，就在点完餐后给我们一个号码牌，每次准备好了就会在服务台叫号，这样我们就可以在被叫到的时候再去取餐，中途可以继续干自己的事。这就叫异步。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 池化&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.1 为什么要池化&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;池化的目的是完成资源复用，避免资源重复创建、删除来提高性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的池子有内存池、连接池、线程池、对象池...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存、连接、线程、对象等都是资源，创建和销毁这些资源都有一个特征， 那就是会涉及到很多系统调用或者网络 IO。每次都在请求中去创建这些资源，会增加处理耗时，但是如果我们用一个 容器（池） 把它们保存起来，下次需要的时候，直接拿出来使用，避免重复创建和销毁浪费的时间。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.1 内存池&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，在 C/C++ 中分别使用 malloc/free 和 new/delete 进行内存的分配，其底层调用系统调用 sbrk/brk。频繁的调用系统调用分配释放内存不但影响性能还容易造成内存碎片，内存池技术旨在解决这些问题。正是这些原因，C/C++ 中的内存操作并不是直接调用系统调用，而是已经实现了自己的一套内存管理，malloc 的实现主要有三大实现。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ptmalloc：glibc 的实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tcmalloc：Google 的实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jemalloc：Facebook 的实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然标准库的实现在操作系统内存管理的基础上再加了一层内存管理，但应用程序通常也会实现自己特定的内存池，如为了引用计数或者专门用于小对象分配。所以看起来内存管理一般分为三个层次。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.6407766990291262&quot; data-type=&quot;jpeg&quot; data-w=&quot;206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSOV2wJbfowH8U9ljntU1ib8jLa849jibaDP2t7WDUhFFmXTWKD60cGF0w/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.2 线程池&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程创建是需要分配资源的，这存在一定的开销，如果我们一个任务就创建一个线程去处理，这必然会影响系统的性能。线程池的可以限制线程的创建数量并重复使用，从而提高系统的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池可以分类或者分组，不同的任务可以使用不同的线程组，可以进行隔离以免互相影响。对于分类，可以分为核心和非核心，核心线程池一直存在不会被回收，非核心可能对空闲一段时间后的线程进行回收，从而节省系统资源，等到需要时在按需创建放入池子中。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.3 连接池&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的连接池有数据库连接池、redis 连接池、TCP 连接池等等，其主要目的是通过复用来减少创建和释放连接的开销。连接池实现通常需要考虑以下几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;初始化：启动即初始化和惰性初始化。启动初始化可以减少一些加锁操作和需要时可直接使用，缺点是可能造成服务启动缓慢或者启动后没有任务处理，造成资源浪费。惰性初始化是真正有需要的时候再去创建，这种方式可能有助于减少资源占用，但是如果面对突发的任务请求，然后瞬间去创建一堆连接，可能会造成系统响应慢或者响应失败，通常我们会采用启动即初始化的方式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;连接数目：权衡所需的连接数，连接数太少则可能造成任务处理缓慢，太多不但使任务处理慢还会过度消耗系统资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;连接取出：当连接池已经无可用连接时，是一直等待直到有可用连接还是分配一个新的临时连接。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;连接放入：当连接使用完毕且连接池未满时，将连接放入连接池（包括连接池已经无可用连接时创建的临时连接），否则关闭。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;连接检测：长时间空闲连接和失效连接需要关闭并从连接池移除。常用的检测方法有：使用时检测和定期检测。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.4 对象池&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;严格来说，各种池都是对象池的的具体应用，包括前面介绍的三种池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象池跟各种池一样，也是缓存一些对象从而避免大量创建同一个类型的对象，同时限制了实例的个数。如 Redis 中 0-9999 整数对象就通过对象池进行共享。在游戏开发中对象池经常使用，如进入地图时怪物和 NPC 的出现并不是每次都是重新创建，而是从对象池中取出。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.5 批量&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能批量就不要并发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果调用方需要调用我们接口多次才能进行一个完整的操作，那么这个接口设计就可能有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如获取数据的接口，如果仅仅提供&lt;code&gt;getData(int id)&lt;/code&gt;接口，那么使用方如果要一次性获取 20 个数据，它就需要循环遍历调用我们接口 20 次，不仅使用方性能很差，也无端增加了我们服务的压力，这时提供一个批量拉取的接口&lt;code&gt;getDataBatch(List&amp;lt;Integer&amp;gt; idList)&lt;/code&gt;显然是必要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于批量接口，我们也要注意接口的吞吐能力，避免长时间执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是以获取数据的接口为例：&lt;code&gt;getDataList(List&amp;lt;Integer&amp;gt; idList)&lt;/code&gt;，假设一个用户一次传 1w 个 id 进来，那么接口可能需要很长的时间才能处理完，这往往会导致超时，用户怎么调用结果都是超时异常，那怎么办？限制长度，比如限制长度为 100，即每次最多只能传 100 个 id，这样就能避免长时间执行，如果用户传的 id 列表长度超过 100 就报异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加了这样限制后，必须要让使用方清晰地知道这个方法有此限制，尽可能地避免用户误用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有三种方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;改变方法名，比如&lt;code&gt;getDataListWithLimitLength(List&amp;lt;Integer&amp;gt; idList)&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在接口说明文档中增加必要的注释说明；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接口明确抛出超长异常，直白告知主调。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.6 并发&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.6.1 请求并发&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个任务需要处理多个子任务，可以将没有依赖关系的子任务并发化，这种场景在后台开发很常见。如一个请求需要查询 3 个数据，分别耗时 T1、T2、T3，如果串行调用总耗时 T=T1+T2+T3。对三个任务执行并发，总耗时 T=max(T1,T 2,T3)。同理，写操作也如此。对于同种请求，还可以同时进行批量合并，减少 RPC 调用次数。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.6.2 冗余请求&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;冗余请求指的是同时向后端服务发送多个同样的请求，谁响应快就是使用谁，其他的则丢弃。这种策略缩短了主调方的等待时间，但也使整个系统调用量猛增，一般适用于初始化或者请求少的场景。比如腾讯公司 WNS 的跑马模块其实就是这种机制，跑马模块为了快速建立长连接同时向后台多个 IP/Port 发起请求，谁快就用谁，这在弱网的移动设备上特别有用，如果使用等待超时再重试的机制，无疑将大大增加用户的等待时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式较少使用，知道即可。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.7 存储设计&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何一个系统，从单机到分布式，从前端到后台，功能和逻辑各不相同，但干的只有两件事：读和写。而每个系统的业务特性可能都不一样，有的侧重读、有的侧重写，有的两者兼备，本节主要探讨在不同业务场景下存储读写的一些方法论。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.7.1 读写分离&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数业务都是读多写少，为了提高系统处理能力，可以采用读写分离的方式将主节点用于写，从节点用于读，如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.297752808988764&quot; data-type=&quot;jpeg&quot; data-w=&quot;356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSkNnNQ6np2kOuej9BAasEDOia7UibRicjickcFIP2bZeQYEfeZUY3FKTCBQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写分离架构有以下几个特点：（1）数据库服务为主从架构；（2）主节点负责写操作，从节点负责读操作；（3）主节点将数据复制到从节点；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于读写分离思想，可以设计出多种主从架构，如主-主-从、主-从-从等。主从节点也可以是不同的存储，如 MySQL+Redis。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写分离的主从架构一般采用异步复制，会存在数据复制延迟的问题，适用于对数据一致性要求不高的业务。可采用以下几个方式尽量避免复制滞后带来的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即读自己的写，适用于用户写操作后要求实时看到更新。典型的场景是，用户注册账号或者修改账户密码后，紧接着登录，此时如果读请求发送到从节点，由于数据可能还没同步完成，用户登录失败，这是不可接受的。针对这种情况，可以将自己的读请求发送到主节点上，查看其他用户信息的请求依然发送到从节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先读取从节点，如果读取失败或者跟踪的更新时间小于某个阀值，则再从主节点读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键业务读写主节点，非关键业务读写分离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保证用户的读请求都发到同一个从节点，避免出现回滚的现象。如用户在 M 主节点更新信息后，数据很快同步到了从节点 S1，用户查询时请求发往 S1，看到了更新的信息。接着用户再一次查询，此时请求发到数据同步没有完成的从节点 S2，用户看到的现象是刚才的更新的信息又消失了，即以为数据回滚了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.7.2 分库分表&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写分离虽然可以明显的提示查询的效率，但是无法解决更高的并发写入请求的场景，这时候就需要进行分库分表，提高并发写入的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，在以下情况下需要进行分库分表：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）单表的数据量达到了一定的量级（如 mysql 一般为千万级），读写的性能会下降。这时索引也会很大，性能不佳，需要分解单表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）数据库吞吐量达到瓶颈，需要增加更多数据库实例来分担数据读写压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表按照特定的条件将数据分散到多个数据库和表中，分为垂直切分和水平切分两种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照一定规则，如业务或模块类型，将一个数据库中的多个表分布到不同的数据库上。以电商平台为例，将商品数据、订单数据、用户数据分别存储在不同的数据库上，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6217105263157895&quot; data-type=&quot;jpeg&quot; data-w=&quot;608&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSArx6FEnV2TzzTOc60icdo7a5fC2icfw8avubvvuyYZjxFp7uI9YBqGUQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：（1）切分规则清晰，业务划分明确；（2）可以按照业务的类型、重要程度进行成本管理，扩展也方便；（3）数据维护简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：（1）不同表分到了不同的库中，无法使用表连接 Join。不过在实际的业务设计中，也基本不会用到 Join 操作，一般都会建立映射表通过两次查询或者写时构造好数据存到性能更高的存储系统中。（2）事务处理复杂，原本在事务中操作同一个库的不同表不再支持。这时可以采用柔性事务或者其他分布式事物方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照一定规则，如哈希或取模，将同一个表中的数据拆分到多个数据库上。可以简单理解为按行拆分，拆分后的表结构是一样的。如用户信息记录，日积月累，表会越来越大，可以按照用户 ID 或者用户注册日期进行水平切分，存储到不同的数据库实例中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：（1）切分后表结构一样，业务代码不需要改动；（2）能控制单表数据量，有利于性能提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：（1）Join、count、记录合并、排序、分页等问题需要跨节点处理；（2）相对复杂，需要实现路由策略；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上所述，垂直切分和水平切分各有优缺点，通常情况下这两种模式会一起使用。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.7.3 动静分离&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动静分离将经常更新的数据和更新频率低的数据进行分离。最常见于 CDN，一个网页通常分为静态资源（图片/JS/CSS 等）和动态资源（JSP、PHP 等），采取动静分离的方式将静态资源缓存在 CDN 边缘节点上，只需请求动态资源即可，减少网络传输和服务负载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据库和 KV 存储上也可以采取动态分离的方式。动静分离更像是一种垂直切分，将动态和静态的字段分别存储在不同的库表中，减小数据库锁的粒度，同时可以分配不同的数据库资源来合理提升利用率。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.7.4 冷热分离&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;冷热分离可以说是每个存储产品和海量业务的必备功能，MySQL、ElasticSearch 等都直接或间接支持冷热分离。将热数据放到性能更好的存储设备上，冷数据下沉到廉价的磁盘，从而节约成本。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.7.5 重写轻读&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本思路就是写入数据时多写点（冗余写），降低读的压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;社交平台中用户可以互相关注，查看关注用户的最新消息，形成 Feed 流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户查看 Feed 流时，系统需要查出此用户关注了哪些用户，再查询这些用户所发的消息，按时间排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了满足高并发的查询请求，可以采用重写轻读，提前为每个用户准备一个收件箱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个用户都有一个收件箱和一个发件箱。比如一个用户有 1000 个粉丝，他发布一条消息时，写入自己的发件箱即可，后台异步的把这条消息放到那 1000 个粉丝的收件箱中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，用户读取 Feed 流时就不需要实时查询聚合了，直接读自己的收件箱就行了。把计算逻辑从”读”移到了”写”一端，因为读的压力要远远大于写的压力，所以可以让”写”帮忙干点活儿，提升整体效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图展示了一个重写轻度的一个例子，在实际应用中可能会遇到一些问题。如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）写扩散：这是个写扩散的行为，如果一个大 V 的粉丝很多，这写扩散的代价也是很大的，而且可能有些人万年不看朋友圈甚至屏蔽了朋友。需要采取一些其他的策略，如粉丝数在某个范围内是才采取这种方式，数量太多采取推拉结合和分析一些活跃指标等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）信箱容量：一般来说查看 Feed 流（如微信朋友圈）不会不断的往下翻页查看，这时候应该限制信箱存储条目数，超出的条目从其他存储查询。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.7.6 数据异构&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据异构顾名思义就是存储不同结构的数据，有很多种含义：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据的存储格式不同，可以是关系型（如 MySQL、SQL Server、DB2 等），也可以是 KV 格式（如 Redis、Memcache 等），还可以是文件行二维数据（如 txt、CSV、XLS 等）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据存储在分散的物理位置上，此类情况大多出现在大型机构中，如销售数据分别存储在北京、上海、日本、韩国等多个分支机构的本地销售系统中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相同的数据按照不同的逻辑来存储，比如按照不同索引维度来存储同一份数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要说的是按照不同的维度建立索引关系以加速查询。如京东、天猫等网上商城，一般按照订单号进行了分库分表。由于订单号不在同一个表中，要查询一个买家或者商家的订单列表，就需要查询所有分库然后进行数据聚合。可以采取构建异构索引，在生成订单的时同时创建买家和商家到订单的索引表，这个表可以按照用户 ID 进行分库分表。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.8 零拷贝&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.8.1 为什么要实现零拷贝？&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的拷贝指的是数据在内核缓冲区和应用程序缓冲区直接的传输，并非指进程空间中的内存拷贝（当然这方面也可以实现零拷贝，如传引用和 C++ 中 move 操作）。现在假设我们有个服务，提供用户下载某个文件，当请求到来时，我们把服务器磁盘上的数据发送到网络中，这个流程伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;filefd = open(...); &lt;span&gt;//打开文件&lt;/span&gt;&lt;br/&gt;sockfd = socket(...); &lt;span&gt;//打开socket&lt;/span&gt;&lt;br/&gt;buffer = &lt;span&gt;new&lt;/span&gt; buffer(...); &lt;span&gt;//创建buffer&lt;/span&gt;&lt;br/&gt;read(filefd, buffer); &lt;span&gt;//从文件内容读到buffer中&lt;/span&gt;&lt;br/&gt;write(sockfd, buffer); &lt;span&gt;//将buffer中的内容发送到网络&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据拷贝流程如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6652360515021459&quot; data-type=&quot;jpeg&quot; data-w=&quot;932&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSYl0VPpaY13ZIV2icicuHWKWyk4icEDFRoSpc9qPic1icCSjkdjBIQQSMNHg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图中绿色箭头表示 DMA copy，DMA（Direct Memory Access）即直接存储器存取，是一种快速传送数据的机制，指外部设备不通过 CPU 而直接与系统内存交换数据的接口技术。红色箭头表示 CPU copy。即使在有 DMA 技术的情况下还是存在 4 次拷贝，DMA copy 和 CPU copy 各 2 次。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.8.2 内存映射&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存映射将用户空间的一段内存区域映射到内核空间，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间，简单来说就是用户空间共享这个内核缓冲区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用内存映射来改写后的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;filefd = open(...); &lt;span&gt;//打开文件&lt;/span&gt;&lt;br/&gt;sockfd = socket(...); &lt;span&gt;//打开socket&lt;/span&gt;&lt;br/&gt;buffer = mmap(filefd); &lt;span&gt;//将文件映射到进程空间&lt;/span&gt;&lt;br/&gt;write(sockfd, buffer); &lt;span&gt;//将buffer中的内容发送到网络&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用内存映射后数据拷贝流如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6766595289079229&quot; data-type=&quot;jpeg&quot; data-w=&quot;934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrS7CsxOicGLgibRDj2JbzlqQQBiaVPT0TN5DmdiaW4HJ1Mp1LpatELfhdjQQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看出，采用内存映射后数据拷贝减少为 3 次，不再经过应用程序直接将内核缓冲区中的数据拷贝到 Socket 缓冲区中。RocketMQ 为了消息存储高性能，就使用了内存映射机制，将存储文件分割成多个大小固定的文件，基于内存映射执行顺序写。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.8.3 零拷贝&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储，从而有效地提高数据传输效率的技术。Linux 内核 2.4 以后，支持带有 DMA 收集拷贝功能的传输，将内核页缓存中的数据直接打包发到网络上，伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;filefd = open(...); &lt;span&gt;//打开文件&lt;/span&gt;&lt;br/&gt;sockfd = socket(...); &lt;span&gt;//打开socket&lt;/span&gt;&lt;br/&gt;sendfile(sockfd, filefd); &lt;span&gt;//将文件内容发送到网络&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用零拷贝后流程如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5879828326180258&quot; data-type=&quot;jpeg&quot; data-w=&quot;932&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSaN32xIgFDCITVxoFuibQVtrmjyxVhT5DjFGJKaYtI7mDFiaR33MUK7oA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;零拷贝的步骤为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）DMA 将数据拷贝到 DMA 引擎的内核缓冲区中。（2）将数据的位置和长度的信息的描述符加到套接字缓冲区。（3）DMA 引擎直接将数据从内核缓冲区传递到协议引擎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，零拷贝并非真正的没有拷贝，还是有 2 次内核缓冲区的 DMA 拷贝，只是消除了内核缓冲区和用户缓冲区之间的 CPU 拷贝。Linux 中主要的零拷贝系统函数有 sendfile、splice、tee 等。零拷贝比普通传输会快很多，如 Kafka 也使用零拷贝技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图是来住 IBM 官网上普通传输和零拷贝传输的性能对比，可以看出零拷贝比普通传输快了 3 倍左右。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36835443037974686&quot; data-type=&quot;jpeg&quot; data-w=&quot;790&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSbeNSoyia0W0dH2s4OUBRDAssDvrIwricZsKGIKUpTGKMsZ2A568qF2tg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.易维护&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 充分必要&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不是随便一个功能就要有个接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然一个接口应该只专注一件事，但并不是每一个功能都要新建一个接口。要有充分的理由和考虑，即这个接口的存在是十分有意义和价值的。无意义的接口不仅浪费开发人力，更增加了服务的维护难度，服务将会十分臃肿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关功能我们应该考虑合为一个接口来实现。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 单一职责&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 API 应该只专注做一件事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像我们开发人员一样，要么从事后台开发，要么从事前端开发，要么从事服务器运维开发。公司一般不会让一个人包揽所有的开发工作，因为这让员工的职责不够单一，不利于员工在专业领域的深耕，很容易成为万金油。对公司的影响是因员工对专业知识掌握的不够深，导致开发出的软件质量得不到保证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让接口的功能保持单一，实现起来不仅简单，维护起来也会容易很多，不会因为大而全的冗杂功能导致接口经常出错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如读写分离和动静分离的做法都是单一职责原则的具体体现。如果一个接口干了两件事情，就应该把它分开，因为修改一个功能可能会影响到另一个功能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3 内聚解耦&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个接口要包含完整的业务功能，而不同接口之间的关联要尽可能的小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样便降低了对其他接口的依赖程度，如此其他接口的变动对当前接口的影响也会降低。一般都是通过消息中间件 MQ 来完成接口之间的耦合。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.4 开闭原则&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对扩展开放，对修改关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这句话怎么理解呢，也就是说，我们在设计一个接口的时候，应当使这个接口可以在不被修改的前提下被扩展其功能。换句话说，应当可以在不修改源代码的情况下改变接口的行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 IM 应用中，当用户输入简介时有个长度限制，我们不应该将长度限制写死在代码，可以通过配置文件的方式来动态扩展，这就做到了对扩展开放（用户简介长度可以变更），对修改关闭（不需要修改代码）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，在设计模式中模板方法模式和观察者模式都是开闭原则的极好体现。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.5 统一原则&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口要具备统一的命名规范、统一的出入参风格、统一的异常处理流程、统一的错误码定义、统一的版本规范等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;统一规范的接口有很多优点，自解释、易学习，难误用，易维护等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.6 用户重试&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口失败时，应该尽可能地由用户重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;失败不可避免，因为接口无法保证 100%成功。一个简单可靠的异常处理策略便是由用户重试，而不是由后台服务进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是 IM 应用为例，有这样的需求场景。群管理员需要拉黑用户，被拉黑的用户要先剔出群，且后续不允许加入群。那么拉黑由一个独立的接口来完成，需要两个操作。一是将用户剔出群，二是将用户写入群的黑名单存储。此时两个操作无法做到事务，也就是我们无法保证两个操作要么同时成功，要么同时失败。这种情况下我们该怎么做，既让接口实现起来简单，要能满足需求呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们如果将用户剔出群放到第一步，那么可能会存在踢出群成功，但是写入群的黑名单存储失败，这种情况下提示用户拉黑失败，但却把用户给踢出了群，对用户来说，体验上是个功能 bug。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;秉着用户尽可能地由用户重试的原则，我们应该将写入群的黑名单存储放到第一步，踢出群放到第二步。并且踢出群作为非关键逻辑，允许失败，因为者可以让用户手动将该用户踢出群，这就给了用户重试的机会，并且我们的接口在实现上也变得简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要引入消息队列存储踢出群的失败日志，让后由后台服务消费重试来保证一定成功，那么实现上将变得复杂且难以维护。不是非常重要的操作，一定不要这么做。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.7 最小惊讶&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码应该尽可能避免让读者蒙圈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需根据需求来设计实现即可，切勿刻意去设计一个复杂无用、华而不实的 API，以免弄巧成拙。一个通俗易懂易维护的 API 比一个炫技复杂难理解的 API 更容易让人接受。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.8 避免无效请求&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要传递无效请求至下游。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无效请求下游应及早检测发现并拒绝，可能会引发相关入参无效的告警，混淆视听且骚扰。我们应避免传递无效请求至下游，避免浪费带宽和计算资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换位思考，谁都不想浪费力气做无用功。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.9 入参校验&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自己收到的请求要做好入参校验，及早发现无效请求并拒绝，然后告警。发现垃圾请求后推动上游不要传递无效请求至下游。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，我们是上游的下游，做好入参校验，避免做无用功。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.10 设计模式&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适当的使用设计模式，让我们的代码更加简洁、易读、可扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计模式（Design Pattern）是一套被反复使用、多人知晓、分类编目、代码设计经验的总结。使用设计模式可以带来如下益处。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;简洁。比如单例模式，减少多实例创建维护的成本，获取实例只需要一个 Get 函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;易读。业界经验，多人知晓。如果告知他人自己使用了相应的设计模式实现某个功能，那么他人便大概知晓了你的实现细节，更加容易读懂你的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可扩展。设计模式不仅能简洁我们的代码，还可以增加代码的可扩展性。比如 Go 推崇的 Option 模式，既避免了书写不同参数版本的函数，又达到了无限扩增函数参数的效果，增加了函数扩展性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.11 禁用 flag 标识&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么接口不要使用 flag 标识，因为这会使接口变得臃肿，违背单一职责，最终难以维护。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里说下，我们为什么会使用 flag 标识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时，我们需要提供一个读接口供上游调用查询相关信息。如主调 A 需要信息 a，主调 B 需要信息 b，主调 C 需要信息 c，主调 D 需要信息 a 和 b。如果为每个主调获取信息都提供单独的接口，那么接口会变得很多。为了减少接口的数量，我们很容易想到给接口增加多个 flag 参数，每个主调在调用接口时携带不同的 flag，表明需要获取哪些信息，然后接口根据入参 flag 获取对应的信息。比如主调 A 调用时将 flag_a 置为 true，主调 B 将 flag_b 置为 true，主调 C 将 flag_c 置为 true，主调 D 将 flag_a 和 flag_c 置为 true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目前期或者 flag 数量较少的情况下，接口功能不是很多时，一般不会暴露出问题。一但开了这个口子，随着需要不同信息主调的增多，接口会不停的增加 flag，最终导致接口变得庞大臃肿，不仅难以阅读维护，还会使接口性能低下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以，我们应该禁用 flag 标识，尽可能地保证接口功能单一。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到上面提到的场景，不适用 flag 标识，我们改如何是好呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们应该坚持单一职责的原则，将信息进行原子分割，每个原子信息作为一个独立的接口对外提供服务&lt;/strong&gt;。如果需要多个原子信息，我们可以增加一个 proxy 层，以独立接口将需要的相关原子信息汇聚组合。这么做你可能会问，接口变多了，会导致服务难以维护。不用担心，如果服务接口数量过多，我们应该对服务进行拆分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是以上面提及的例子为例，接口禁用 flag 前后组织形式对比如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.455&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaug2GXTwQ0b7BdSzyKMqBrSnpsVUILtXPpmgLrC3pNJVOW4ktY4yxsXmCNW8dZw4APNIrCnz0v1zg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.12 页宜小不宜大&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于设计和实现 API 来说，当结果集包含成千上万条记录时，返回一个查询的所有结果可能是一个挑战，它给服务器、客户端和网络带来了不必要的压力，于是就有了分页的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常我们通过一个 offset 偏移量或者页码来进行分页，然后通过 API 一页一页的查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么页大小设为多少合适呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的页大小有 50，100，200 和 500。如何选择页大小，我们应该在满足特定业务场景需求下，宜少不宜多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;太大的页，主要有以下几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;影响用户体验。页太大，加载会比较慢，用户等待时间会比较长；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;影响接口性能。页太大，会增加数据的拉取编解码耗时，降低接口性能；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浪费带宽。很多场景下，用户在浏览的过程中，不会看完一页中的所有数据，返回太大的页是一种浪费；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩展性差。随着业务的发展，接口在页大小不变的情况下，返回的页数据可能会越来越大，导致接口性能越来越差，最终拖垮接口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页大小多少合适，没有标准答案，需要根据具体的业务场景来定。但是要坚持一点，页宜小不宜大。如果接口的页大小，能用 50 便可满足业务需求，就不要用 100 和 200，更不要用 500。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.低风险&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;道路千万条，安全第一条。虽然很多时候感觉网络攻击和安全事故离我们很远，但一旦发生，后面不堪设想，所以服务接口的安全问题是设计实现过程中不得不考虑的一环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面将列举常见的服务接口面临的安全问题与应对策略，来加固我们的服务，降低安全风险。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1 防 XSS&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1.1 简介&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XSS（Cross Site Scripting）名为跨站脚本攻击，因其缩写会与层叠样式表（Cascading Style Sheets，CSS）混淆，故将其缩写为 XSS。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XSS 漏洞是 Web 安全中最为常见的漏洞，通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页中，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是 JavaScript，但实际上也可以包括 Java、 VBScript、ActiveX、 Flash，甚至是普通的 HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和 Cookie 等各种内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XSS 本质是 HTML 注入。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1.2 分类&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XSS 攻击通常可以分为 3 类：存储型（持久型）、反射型（非持久型）、DOM 型。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储型 XSS
危害直接。跨站代码存储在服务器，如在个人信息或发表文章的地方加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;反射型 XSS
最为普遍。反射型跨站脚本漏洞，需要欺骗用户去点击链接才能触发 XSS 代码，一般容易出现在搜索页面。用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反射型和存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;基于 DOM 的 XSS
通过修改原始的客户端代码，受害者浏览器的 DOM 环境改变，导致恶意脚本的执行。也就是说，页面本身并没有变化，但由于 DOM 环境被恶意修改，有客户端代码被包含进了页面，并且意外执行。DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1.3 防御措施&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面的介绍可以得知，XSS 攻击有两大要素：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XSS 攻击主要是由程序漏洞造成的，要完全防止 XSS 安全漏洞主要依靠程序员较高的编程能力和安全意识，当然安全的软件开发流程及其他一些编程安全原则也可以大大减少 XSS 安全漏洞的发生。这些防范 XSS 漏洞原则包括：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;预防存储型和反射型 XSS 攻击&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预防这两种漏洞，常见做法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不信任 UGC（用户提交的任何内容），对所有用户提交内容进行验证，包括对 URL、查询关键字、HTTP 头、REFER、POST 数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;纯前端渲染的过程：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）然后浏览器执行 HTML 中的 JavaScript。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把&lt;code&gt;&amp;amp; &amp;lt; &amp;gt; &quot; &#x27; /&lt;/code&gt;这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;XSS 安全漏洞&lt;/th&gt;&lt;th&gt;简单转义是否有防护作用&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;HTML 标签文字内容&lt;/td&gt;&lt;td&gt;有&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;HTML 属性值&lt;/td&gt;&lt;td&gt;有&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CSS 内联样式&lt;/td&gt;&lt;td&gt;无&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内联 JavaScript&lt;/td&gt;&lt;td&gt;无&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内联 JSON&lt;/td&gt;&lt;td&gt;无&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;跳转链接&lt;/td&gt;&lt;td&gt;无&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;预防 DOM 型 XSS 攻击&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- 内联事件监听器中包含恶意代码 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;img&lt;/span&gt; &lt;span&gt;onclick&lt;/span&gt;=&lt;span&gt;&quot;UNTRUSTED&quot;&lt;/span&gt; &lt;span&gt;onerror&lt;/span&gt;=&lt;span&gt;&quot;UNTRUSTED&quot;&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;data:image/png,&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!-- 链接内包含恶意代码 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;a&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;UNTRUSTED&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;span&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;// setTimeout()/setInterval() 中调用恶意代码&lt;/span&gt;&lt;br/&gt;setTimeout(&lt;span&gt;&quot;UNTRUSTED&quot;&lt;/span&gt;)&lt;br/&gt;setInterval(&lt;span&gt;&quot;UNTRUSTED&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// location 调用恶意代码&lt;/span&gt;&lt;br/&gt;location.href = &lt;span&gt;&#x27;UNTRUSTED&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// eval() 中调用恶意代码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;eval&lt;/span&gt;(&lt;span&gt;&quot;UNTRUSTED&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果项目中有用到这些的话，一定要避免在字符串中拼接不可信数据。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其他手段&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;严格的 CSP 在 XSS 的防范中可以起到以下的作用：（1）禁止加载外域代码，防止复杂的攻击逻辑。（2）禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。（3）禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。（4）禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。（5）合理使用上报可以及时发现 XSS，利于尽快修复问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;防止脚本冒充用户提交危险操作&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）使用通用 XSS 攻击字符串手动检测 XSS 漏洞。（2）使用扫描工具自动检测 XSS 漏洞。例如 &lt;a href=&quot;https://github.com/Arachni/arachni&quot; data-linktype=&quot;2&quot;&gt;Arachni&lt;/a&gt;、&lt;a href=&quot;https://github.com/mozilla/http-observatory/&quot; data-linktype=&quot;2&quot;&gt;Mozilla HTTP Observatory&lt;/a&gt;、&lt;a href=&quot;https://github.com/andresriancho/w3af&quot; data-linktype=&quot;2&quot;&gt;w3af&lt;/a&gt; 等。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1.4 小结&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;防范 XSS 是不只是服务端的任务，需要后端和前端共同参与的系统工程。虽然很难通过技术手段完全避免 XSS，但通过上面的做法可以有效减少漏洞的产生和 XSS 攻击带来的影响。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2 防 CSRF&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2.1 简介&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CSRF（Cross Site Request Forgery）名为跨站请求伪造，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个典型的 CSRF 攻击有着如下的流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;受害者登录 a.com，并保留了登录凭证（Cookie）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;攻击者引诱受害者访问了 b.com。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;b.com 向 a.com 发送了一个请求：a.com/act。浏览器会默认携带 a.com 的 Cookie。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;a.com 以受害者的名义执行了 act。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2.2 示例&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如一家银行用以运行转账操作的 URL 地址如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;https://www.examplebank.com/withdraw?account=AccoutName&amp;amp;amount=1000&amp;amp;&lt;span&gt;for&lt;/span&gt;=PayeeName&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，一个恶意攻击者可以在另一个网站上放置如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;img src=&lt;span&gt;&quot;https://www.examplebank.com/withdraw?account=Alice&amp;amp;amount=1000&amp;amp;for=Badman&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有账户名为 Alice 的用户访问了恶意站点，当图片被加载时，图片链接将被触发，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 资金。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;透过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义运行操作。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2.3 防御措施&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文中讲了 CSRF 的两个特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CSRF（通常）发生在第三方域名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CSRF 攻击者不能获取到 Cookie 等信息，只是使用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这两点，我们可以专门制定防护策略，如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;阻止不明外域的访问
（1）同源检测
（2）Samesite Cookie&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提交时要求附加本域才能获取的信息
（1）CSRF Token
（2）双重 Cookie 验证&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下我们对各种防护方法做详细说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）同源检测：验证 HTTP Referer 字段。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上文银行操作为例，Referer 字段地址通常应该是转账按钮所在的网页地址，应该也位于 www.examplebank.com 之下。而如果是 CSRF 攻击传来的请求，Referer 字段会包含恶意网址的地址，不会位于 www.examplebank.com 之下，这时候服务器就能识别出恶意的访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）Samesite Cookie。&lt;/strong&gt;为了从源头上解决这个问题，Google 起草了一份草案来改进 HTTP 协议，那就是为 Set-Cookie 响应头新增 Samesite 属性，它用来标明这个 Cookie 是个“同站 Cookie”，同站 Cookie 只能作为第一方 Cookie，不能作为第三方 Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Samesite=Strict&lt;/strong&gt; 这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie。比如说 a.com 设置了如下 Cookie：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Set-Cookie: foo=1; Samesite=Strict&lt;br/&gt;Set-Cookie: bar=2; Samesite=Lax&lt;br/&gt;Set-Cookie: baz=3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在 b.com 下发起对 a.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Samesite=Lax&lt;/strong&gt; 这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求，则这个 Cookie 可以作为第三方 Cookie。比如说 a.com 设置了如下 Cookie：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Set-Cookie: foo=1; Samesite=Strict&lt;br/&gt;Set-Cookie: bar=2; Samesite=Lax&lt;br/&gt;Set-Cookie: baz=3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户从 b.com 点击链接进入 a.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 b.com 发起的对 a.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则 bar 也不会发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）CSRF Token。&lt;/strong&gt;CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 Token，并在服务器端建立一个拦截器来验证这个 Token，如果请求中没有 Token 或者 Token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Token 一般由服务端生成（也可以由前端生成）。一般 Token 由随机字符串和时间戳组合后通过哈希运算获得，用户首次加载页面时由服务端返回给前端。显然在提交时 Token 不能再放在 Cookie 中了，否则又会被攻击者冒用。因此，为了安全起见 ，前端在访问后台接口时，可以把 Token 放到如下三个地方：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（4）双重 Cookie 验证。&lt;/strong&gt;在会话中存储 CSRF Token 比较繁琐，而且不能在通用的拦截上统一处理所有的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么另一种防御措施是使用双重提交 Cookie。利用 CSRF 攻击不能获取到用户 Cookie 的特点，我们可以要求 Ajax 和表单请求携带一个 Cookie 中的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双重 Cookie 采用以下流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串（例如 csrfcookie=v8g9e4ksfhw）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在前端向后端发起请求时，取出 Cookie，并添加到 URL 的参数中（接上例 POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后端接口验证 Cookie 中的字段与 URL 参数中的字段是否一致，不一致则拒绝。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方法相对于 CSRF Token 就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储 Token。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2.4 小结&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CSRF 和 XSS 完全是两种不同的 Web 攻击手段，所以有着不同的应对方法。二者的主要区别有：（1）XSS 本质是 HTML 注入，和 SQL 注入差不多，而 CSRF 则是冒充用户发起非法请求；（2）CSRF 需要用户登录后完成攻击，XSS 不需要。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.3 防 SQL 注入&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是 SQL 注入？&lt;/strong&gt;SQL 注入攻击是通过将恶意的 SQL 语句插入到应用的输入参数中，再在后台 SQL 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么要防 SQL 注入？&lt;/strong&gt;如果用户输入的数据被构造成恶意 SQL 代码，程序又未对动态构造的 SQL 语句使用的参数进行审查，则会带来意想不到的危险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何防 SQL 注入？&lt;/strong&gt;这是开发人员应该思考的问题，作为测试人员，了解如何预防 SQL 注入，可以在发现注入攻击 Bug 时，对 Bug 产生原因进行定位。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;严格检查输入变量的类型和格式。对于整数参数，加判断条件：不能为空、参数类型必须为数字。对于字符串参数，可以使用正则表达式进行过滤：如 [0-9a-zA-Z] 范围内的字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;过滤和转义特殊字符。对用户输入的 SQL 参数进行转义，如&lt;code&gt;&#x27; &quot; / * #&lt;/code&gt;等特殊字符。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用参数化查询（Parameterized Query）而非手动拼接 SQL。不仅可以防止 SQL 注入，还可以避免重复编译 SQL 带来性能提升。具体是怎样防止 SQL 注入的呢？实际上当将绑定的参数传到 MySQL 服务器，MySQL 服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.4 防刷&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么要防刷?&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后台服务接口都应该有一个合理的请求速度，尤其对于来自真人请求的接口，如果单个用户短时间内对某个接口的请求量很大，很有可能接口被恶意强刷或客户端请求逻辑有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 IM 应用中的加好友请求，正常用户请求频次不会超过 1/s。如果每秒钟有 10+ 次加好友的请求，那么说明接口很有可能被刷了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口被刷，不管是读还是写接口，都会对后台服务造成巨大压力，严重的可能会导致服务不可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们应该对接口做适当的限频，提早拒绝非法请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何防刷?&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过接口限频来应对被刷。接口请求频次的统计一般有如下维度：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个接口应该有不同的合理阈值，这个需要结合具体的业务场景来定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个功能为服务接口的公共功能，建议做在网关层或单独的安全层。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.5 防篡改&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是篡改?&lt;/strong&gt;在一次客户端与服务端的请求过程中，从请求方到接收方中间要经过很多路由器和交换机，黑客可以在中途截获请求的数据，篡改请求内容后再发往服务端，比如中间人攻击。假设在一个网上存款系统中，一条消息表示用户的一笔转账，攻击者完全可以多次将收款账号改为自己的账号后再将请求发到服务端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么要防篡改?&lt;/strong&gt;假如客户端与服务端采用的是 HTTPS 协议，虽然 HTTPS 协议可以将传输的明文进行加密，但是黑客仍然可以截获传输的数据包，进一步伪造请求进行重放攻击。如果黑客使用特殊手段让请求方设备使用了伪造的证书进行通信，那么 HTTPS 加密的内容也会被解密。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 API 接口中我们除了使用 HTTPS 协议进行通信外，还需要有自己的一套加解密机制，对请求的参数进行保护，防止被篡改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何防篡改?&lt;/strong&gt;对请求包进行签名可以有效的防篡改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体过程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端使用约定好的秘钥对传输的参数进行加密，得到签名值 signature1，一般使用 &lt;a href=&quot;https://baike.baidu.com/item/hmac/7307543&quot; data-linktype=&quot;2&quot;&gt;HMAC&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端将签名值也放入请求的参数中，发送请求给服务端。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端接收到客户端的请求，然后使用约定好的秘钥对请求的参数再次进行签名，得到签名值 signature2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端比对 signature1 和 signature2 的值，如果对比一致，认定为合法请求。如果对比不一致，说明参数被篡改，为非法请求。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为黑客不知道签名的密钥，所以即使截取到请求数据，对请求参数进行篡改，但是却无法对参数进行签名，无法得到修改后参数的签名值 signature。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.6 防重放&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是重放?&lt;/strong&gt;如果恶意用户抓取真实的接口请求包，不停地发起重复请求，这就是对接口的重放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么要重放?&lt;/strong&gt;接口重放一般是针对写接口的恶意请求，读接口不会有什么影响。比如发帖，发消息这种写接口，如果不防重放，会出现很多垃圾内容和骚扰消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何防重放?&lt;/strong&gt;防重放的目的是不允许让相同内容的请求重复发起。对于一个具体的请求，我们可以限制某个请求的生命周期，如果超过其生命周期，认定为非法请求，这样便起到了防重放的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体做法是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端基于&quot;请求内容+时间戳+密钥&quot;计算一个签名 signature1，一般使用 &lt;a href=&quot;https://baike.baidu.com/item/hmac/7307543&quot; data-linktype=&quot;2&quot;&gt;HMAC&lt;/a&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端请求后台接口时带上签名 signature1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后台拿到签名后，会使用相同的算法计算出一个签名与前端带来的签名做比较，如果不一致，说明请求非法，直接拒绝。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为黑客不知道签名秘钥，没有办法生成新的签名。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上做法需要注意几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;签名计算使用的算法可能会被坏人破解。因为对于 APP 或桌面应用，坏人可以反汇编获取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;签名计算时使用密钥需要保存在客户端本地，可能会有泄露的风险。因为对于 APP 或桌面应用，坏人可以反汇编获取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;终端使用的时间戳是由后台返回的，这样防止前后端的本地时间不一致导致生成的签名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不适用于 Web 应用，坏人是可以直接查看网页源码获取签名计算使用的算法和密钥。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要严格做到一段时间内某个请求只能被请求一次，需要对请求进行次数的统计，会用到后台存储，实现起来会复杂一点。不过一般不需要这么做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个功能为服务接口的公共功能，建议做在网关层或单独的安全层。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.7 防 DDoS&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是 DDoS 攻击？&lt;/strong&gt;DDoS（Distributed Denial of Service）是分布式拒绝服务攻击，攻击者利用分散在各地的设备发出海量实际上并不需要的互联网流量，耗尽目标的资源，造成正常流量无法到达其预定目的地或目标服务被压垮无法提供正常服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能我举个例子会更加形象点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我开了一家有五十个座位的重庆火锅店，由于用料上等，童叟无欺。平时门庭若市，生意特别红火，而对面二狗家的火锅店却无人问津。二狗为了对付我，想了一个办法，叫了五十个人来我的火锅店坐着却不点菜，让别的客人无法吃饭。上面这个例子讲的就是典型的 DDoS 攻击。一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。因为“肉鸡”分散在各地，有分布式的特性，所以叫分布式拒绝服务攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在线游戏、互联网金融等领域是 DDoS 攻击的高发行业。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么要防 DDoS？&lt;/strong&gt;DDoS 攻击带来的危害轻微的会降低目标服务的质量，增加响应延迟，严重的直接导致目标服务崩溃，无法提供服务。所以必须要防 DDoS 攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;常见的 DDoS 攻击有哪些？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）ICMP Flood 攻击。ICMP Flood 攻击属于流量型的攻击方式，是利用大的流量给服务器带来较大的负载，影响服务器的正常服务。由于目前很多防火墙直接过滤 ICMP 报文。因此 ICMP Flood 出现的频度较低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）UDP 反射攻击
DNS 反射攻击是一种常见的攻击媒介，网络犯罪分子通过伪装其目标的 IP 地址，向开放的 DNS 服务器发送大量请求。作为回应，这些 DNS 服务器通过伪造的 IP 地址响应恶意请求，大量的 DNS 答复形成洪流，从而构成预定目标的攻击。很快，通过 DNS 答复产生的大量流量就会造成受害企业的服务不堪重负、无法使用，并造成合法流量无法到达其预定目的地。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如 NTP Flood 攻击，这类攻击主要利用大流量拥塞被攻击者的网络带宽，导致被攻击者的业务无法正常响应客户访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）SYN Flood 攻击。SYN Flood 攻击是当前网络上最为常见的 DDoS 攻击，它利用了 TCP 协议实现上的一个缺陷。通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半连接队列被占满，从而阻止其他合法用户进行访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Connection Flood 攻击。Connection Flood 是典型的利用小流量冲击大带宽网络服务的攻击方式，这种攻击的原理是利用真实的 IP 地址向服务器发起大量的连接。并且建立连接之后很长时间不释放，占用服务器的资源，造成服务器上残余连接（WAIT 状态）过多，效率降低，甚至资源耗尽，无法响应其他客户所发起的链接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）UDP Flood 攻击。UDP Flood 是日渐猖厥的流量型 DDoS 攻击，原理也很简单。常见的情况是利用大量 UDP 小包冲击 DNS 服务器或 Radius 认证服务器、流媒体视频服务器。由于 UDP 协议是一种无连接的服务，在 UDP Flood 攻击中，攻击者可发送大量伪造源 IP 地址的小 UDP 包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）SSL 连接攻击。比较典型的攻击类型是 SSL 连接攻击，这类攻击占用服务器的 SSL 会话资源从而达到拒绝服务的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）HTTP Get 攻击。和服务器建立正常的 TCP 连接之后，不断地向后端服务接口发起 Get 请求，压垮后台服务。这种攻击的特点是可以绕过普通的防火墙防护，可通过 Proxy 代理实施攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）UDP DNS Query Flood 攻击
UDP DNS Query Flood 攻击采用的方法是向被攻击的服务器发送大量的域名解析请求，通常请求解析的域名是随机生成或者是网络世界上根本不存在的域名。域名解析的过程给服务器带来了很大的负载，每秒钟域名解析请求超过一定的数量就会造成 DNS 服务器解析域名超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何防 DDoS？&lt;/strong&gt;DDoS 防御是保障系统安全运行的必要举措，虽然不属于服务接口层面需要考虑的事情，但是知道相关的防御措施还是很有必要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;防御 DDoS 攻击的策略方法，包括但不限于：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）定期检查服务器漏洞。定期检查服务器软件安全漏洞，是确保服务器安全的最基本措施。无论是操作系统（Windows 或 linux），还是网站常用应用软件（mysql、Apache、nginx、FTP 等），服务器运维人员要特别关注这些软件的最新漏洞动态，出现高危漏洞要及时打补丁修补。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）隐藏服务器真实 IP。通过 CDN 节点中转加速服务，可以有效的隐藏网站服务器的真实 IP 地址。CDN 服务根据网站具体情况进行选择，对于普通的中小企业站点或个人站点可以先使用免费的 CDN 服务，比如百度云加速、七牛 CDN 等，待网站流量提升了，需求高了之后，再考虑付费的 CDN 服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，防止服务器对外传送信息泄漏 IP 地址，最常见的情况是，服务器不要使用发送邮件功能，因为邮件头会泄漏服务器的 IP 地址。如果非要发送邮件，可以通过第三方代理（例如 sendcloud）发送，这样对外显示的 IP 是代理的 IP 地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）关闭不必要的服务或端口。这也是服务器运维人员最常用的做法。在服务器防火墙中，只开启使用的端口，比如网站 Web 服务的 80 端口、数据库的 3306 端口、SSH 服务的 22 端口等。关闭不必要的服务或端口，在路由器上过滤假 IP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）购买高防服务器提高承受能力。该措施是通过购买高防的盾机，提高服务器的带宽等资源，来提升自身的承受攻击能力。一些知名 IDC 服务商都有相应的服务提供，比如阿里云、腾讯云等。但该方案成本预算较高，对于普通中小企业甚至个人站长并不合适，且不被攻击时造成服务器资源闲置，所以这里不过多阐述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）限制 SYN/ICMP 流量。用户应在路由器上配置 SYN/ICMP 的最大流量来限制 SYN/ICMP 封包所能占有的最高频宽。这样，当出现大量的超过所限定的 SYN/ICMP 流量时，说明不是正常的网络访问，而是有黑客入侵。早期通过限制 SYN/ICMP 流量是最好的防范 DOS 的方法，虽然目前该方法对于 DDoS 效果不太明显了，不过仍然能够起到一定的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）黑名单。对于恶意流量，将 IP 或 IP 段拉黑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（7）DDoS 清洗。DDoS 清洗会对用户请求数据进行实时监控，及时发现 DOS 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（8）CDN 加速。CDN 指的是网站的静态内容分发到多个服务器，用户就近访问，提高速度。因此，CDN 也是带宽扩容的一种方法，可以用来防御 DDoS 攻击。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.8 小结&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;道高一尺，魔高一丈，没有绝对的安全，我们能做的就是尽可能地提高坏人作恶的门槛，让我们的系统变得更加安全可靠。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.小结&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的服务是设计出来的，而不是维护出来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优秀的设计原则告诉我们如何写出好的服务来应对千变万化的业务场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有事物都不是 100% 可靠的，服务亦是如此，但遵守优秀的设计原则让我们的服务距离 100% 可靠更近一步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://cloud.google.com/apis/design&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Google Cloud API Desgin Guide&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.zhihu.com/question/412384617&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;知乎.怎么理解软件设计中的开闭原则？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5MDEzMzg5Nw==&amp;amp;mid=2660395901&amp;amp;idx=1&amp;amp;sn=3a2bdcd8a4034c1cbc6d320a8bac773e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;微服务的 4 个设计原则和 19 个解决方案&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/LBSer/p/4753112.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;博客园.如何健壮你的后端服务？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1692367278967046308&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;高可用的本质&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/imxiaobei/p/13619630.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;一文搞懂后台高性能服务器设计的常见套路, BAT 高频面试系列&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/hemin1003/article/details/84526242&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【架构】高可用高并发系统设计原则&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/07/cap.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;CAP 定理的含义 - 阮一峰的网络日志&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/338835258&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;CAP 理论该怎么理解？为什么是三选二？为什么是 CP 或者 AP？面试题有哪些？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://nieyong.github.io/wiki_cpu/mmap%E8%AF%A6%E8%A7%A3.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;mmap 详解&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://queue.acm.org/detail.cfm?id=1394128&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Base: An Acid Alternative&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.ehcache.org/documentation/3.3/caching-patterns.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Cache Usage Patterns - Ehcache&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.f5.com/labs/articles/education/securing-apis--10-best-practices-for-keeping-your-data-and-infra&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Securing APIs: 10 Ways to Keep Your Data and Infrastructure Safe&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016551188&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;前端安全系列（一）：如何防止 XSS 攻击？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://tech.meituan.com/2018/10/11/fe-security-csrf.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;前端安全系列（二）：如何防止 CSRF 攻击？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/github_36032947/article/details/78442189&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;SQL 注入攻击常见方式及测试方法 | CSDN 博客&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1175758&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;API 接口设计：防参数篡改+防二次请求 | 腾讯云&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.zhihu.com/question/22259175/answer/386244476&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;什么是 DDoS 攻击？| 知乎&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000023238265&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;DDoS 攻击是什么? 如何防止 DDos 攻击？| SegmentFault&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card wxw_wechannel_card_horizontal&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAASq0YgLDeYwAAAAstQy6ubaLX4KHWvLEZgBPE0KJ4OxAQBvyCzNPgMIs4UP_WvRrNg5tdEY9lQ778&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzLqhyKA03Vl1MAocId9PdpnwoIYTQusVCncn35P2jX0Hibud2Yx7v1JmmTnV0EDQea2JjX3Cr4cqp3T6tP47jS3w&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdWLfTGgqyzibuibCQlhBPWibef9dvoP3qJKoZFhC2AKIKdyoen8zSWV5B2E0HtjW2QNjQ&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;程序员的生活也可以很浪漫，祝大家七夕快乐！#七夕&quot; data-nonceid=&quot;11030318403157504517&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>525b6b4a77ca6f546114a1a395dcc5ef</guid>
<title>秒杀系统的艺术</title>
<link>https://toutiao.io/k/m8ga13m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;极限并发带来的思考&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然现在大多数情况下都能订到票，但是放票瞬间即无票的场景，相信大家都深有体会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其是春节期间，大家不仅使用 12306，还会考虑“智行”和其他的抢票软件，全国上下几亿人在这段时间都在抢票。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“12306 服务”承受着这个世界上任何秒杀系统都无法超越的 QPS，上百万的并发再正常不过了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者专门研究了一下“12306”的服务端架构，学习到了其系统设计上很多亮点，在这里和大家分享一下并模拟一个例子：如何在 100 万人同时抢 1 万张火车票时，系统提供正常、稳定的服务。github代码地址&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大型高并发系统架构&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高并发的系统架构都会采用分布式集群部署，服务上层有着层层负载均衡，并提供各种容灾手段（双火机房、节点容错、服务器灾备等）保证系统的高可用，流量也会根据不同的负载能力和配置策略均衡到不同的服务器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下边是一个简单的示意图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6205733558178752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ELQw2WCMgt3ZRqPicqe9ML4tPtwXiabgb6UKiaOoeP4gL9dxxWZqgk8EAr93YvYibwzEQQV5EicoGVzBmWwIMsAr6XQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;593&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;负载均衡简介&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图中描述了用户请求到服务器经历了三层的负载均衡，下边分别简单介绍一下这三种负载均衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;① OSPF（开放式最短链路优先）是一个内部网关协议（Interior Gateway Protocol，简称 IGP）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OSPF 通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，OSPF 会自动计算路由接口上的 Cost 值，但也可以通过手工指定该接口的 Cost 值，手工指定的优先于自动计算的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OSPF 计算的 Cost，同样是和接口带宽成反比，带宽越高，Cost 值越小。到达目标相同 Cost 值的路径，可以执行负载均衡，最多 6 条链路同时执行负载均衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;②LVS （Linux Virtual Server）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是一种集群（Cluster）技术，采用 IP 负载均衡技术和基于内容请求分发技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;③Nginx&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想必大家都很熟悉了，是一款非常高性能的 HTTP 代理/反向代理服务器，服务开发中也经常使用它来做负载均衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 实现负载均衡的方式主要有三种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就针对 Nginx 的加权轮询做专门的配置和测试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 加权轮询的演示&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 实现负载均衡通过 Upstream 模块实现，其中加权轮询的配置是可以给相关的服务加上一个权重值，配置的时候可能根据服务器的性能、负载能力设置相应的负载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一个加权轮询负载的配置，我将在本地的监听 3001-3004 端口，分别配置 1，2，3，4 的权重：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#配置负载均衡&lt;/span&gt;&lt;br/&gt;    upstream load_rule {&lt;br/&gt;       server 127.0.0.1:3001 weight=1;&lt;br/&gt;       server 127.0.0.1:3002 weight=2;&lt;br/&gt;       server 127.0.0.1:3003 weight=3;&lt;br/&gt;       server 127.0.0.1:3004 weight=4;&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;    server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name  load_balance.com www.load_balance.com;&lt;br/&gt;    location / {&lt;br/&gt;       proxy_pass http://load_rule;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在本地 /etc/hosts 目录下配置了 www.load_balance.com 的虚拟域名地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来使用 Go 语言开启四个 HTTP 端口监听服务，下面是监听在 3001 端口的 Go 程序，其他几个只需要修改端口即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;strings&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    http.HandleFunc(&lt;span&gt;&quot;/buy/ticket&quot;&lt;/span&gt;, handleReq)&lt;br/&gt;    http.ListenAndServe(&lt;span&gt;&quot;:3001&quot;&lt;/span&gt;, nil)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//处理请求函数,根据请求将响应结果信息写入日志&lt;br/&gt;func handleReq(w http.ResponseWriter, r *http.Request) {&lt;br/&gt;    failedMsg :=  &lt;span&gt;&quot;handle in port:&quot;&lt;/span&gt;&lt;br/&gt;    writeLog(failedMsg, &lt;span&gt;&quot;./stat.log&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//写入日志&lt;br/&gt;func writeLog(msg string, logPath string) {&lt;br/&gt;    fd, _ := os.OpenFile(logPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)&lt;br/&gt;    defer fd.Close()&lt;br/&gt;    content := strings.Join([]string{msg, &lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;}, &lt;span&gt;&quot;3001&quot;&lt;/span&gt;)&lt;br/&gt;    buf := []byte(content)&lt;br/&gt;    fd.Write(buf)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我将请求的端口日志信息写到了 ./stat.log 文件当中，然后使用 AB 压测工具做压测：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;ab -n 1000 -c 100 http://www.load_balance.com/buy/ticket&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;统计日志中的结果，3001-3004 端口分别得到了 100、200、300、400 的请求量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这和我在 Nginx 中配置的权重占比很好的吻合在了一起，并且负载后的流量非常的均匀、随机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的实现大家可以参考 Nginx 的 Upsteam 模块实现源码：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://www.kancloud.cn/digest/understandingnginx/202607&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;秒杀抢购系统选型&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到我们最初提到的问题中来：火车票秒杀系统如何在高并发情况下提供正常、稳定的服务呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的介绍我们知道用户秒杀流量通过层层的负载均衡，均匀到了不同的服务器上，即使如此，集群中的单机所承受的 QPS 也是非常高的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何将单机性能优化到极致呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要解决这个问题，我们就要想明白一件事：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;通常订票系统要处理生成订单、减扣库存、用户支付这三个基本的阶段。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们系统要做的事情是要保证火车票订单不超卖、不少卖，每张售卖的车票都必须支付才有效，还要保证系统承受极高的并发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三个阶段的先后顺序该怎么分配才更加合理呢？我们来分析一下：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;下单减库存&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1436077057793345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ELQw2WCMgt3ZRqPicqe9ML4tPtwXiabgb6AxGktrv4ncwyZN7lLeZVETQzjsqx2eibkibM3aoVIm6r66s49WQQt54g/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;571&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户并发请求到达服务端时，首先创建订单，然后扣除库存，等待用户支付。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种顺序是我们一般人首先会想到的解决方案，这种情况下也能保证订单不会超卖，因为创建订单之后就会减库存，这是一个原子操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这样也会产生一些问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在极限并发情况下，任何一个内存操作的细节都至关影响性能，尤其像创建订单这种逻辑，一般都需要存储到磁盘数据库的，对数据库的压力是可想而知的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果用户存在恶意下单的情况，只下单不支付这样库存就会变少，会少卖很多订单，虽然服务端可以限制 IP 和用户的购买订单数量，这也不算是一个好方法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;支付减库存&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1436077057793345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ELQw2WCMgt3ZRqPicqe9ML4tPtwXiabgb6AI9dxibwgszSvjjcTdLXdLy5mYs40Kp0bTSkuqNfTBthv9JkPVviaX4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;571&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果等待用户支付了订单在减库存，第一感觉就是不会少卖。但是这是并发架构的大忌，因为在极限并发情况下，用户可能会创建很多订单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当库存减为零的时候很多用户发现抢到的订单支付不了了，这也就是所谓的“超卖”。也不能避免并发操作数据库磁盘 IO。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;预扣库存&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6830985915492958&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ELQw2WCMgt3ZRqPicqe9ML4tPtwXiabgb6eDNIwJfF3hUxbx2RaXCHIRMAjIy0EIBKUJ4OHqLrZwCPWARY3P96ibQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;426&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上边两种方案的考虑，我们可以得出结论：只要创建订单，就要频繁操作数据库 IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么有没有一种不需要直接操作数据库 IO 的方案呢，这就是预扣库存。先扣除了库存，保证不超卖，然后异步生成用户订单，这样响应给用户的速度就会快很多；那么怎么保证不少卖呢？用户拿到了订单，不支付怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道现在订单都有有效期，比如说用户五分钟内不支付，订单就失效了，订单一旦失效，就会加入新的库存，这也是现在很多网上零售企业保证商品不少卖采用的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订单的生成是异步的，一般都会放到 MQ、Kafka 这样的即时消费队列中处理，订单量比较少的情况下，生成订单非常快，用户几乎不用排队。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;扣库存的艺术&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的分析可知，显然预扣库存的方案最合理。我们进一步分析扣库存的细节，这里还有很大的优化空间，库存存在哪里？怎样保证高并发下，正确的扣库存，还能快速的响应用户请求？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单机低并发情况下，我们实现扣库存通常是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4076086956521739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ELQw2WCMgt3ZRqPicqe9ML4tPtwXiabgb6OchOz0gFkHSlqqGwuXAZEJdVwxr3Dahtpd1COPbMv8k2RpfY5iaewAA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;368&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证扣库存和生成订单的原子性，需要采用事务处理，然后取库存判断、减库存，最后提交事务，整个流程有很多 IO，对数据库的操作又是阻塞的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式根本不适合高并发的秒杀系统。接下来我们对单机扣库存的方案做优化：本地扣库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把一定的库存量分配到本地机器，直接在内存中减库存，然后按照之前的逻辑异步创建订单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改进过之后的单机系统是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3268101761252446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ELQw2WCMgt3ZRqPicqe9ML4tPtwXiabgb64cUjXicoqIBMveF6h26TDTvuGZYibHQrxzP1kOiauiclRiadcWVXFZkialEg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;511&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就避免了对数据库频繁的 IO 操作，只在内存中做运算，极大的提高了单机抗并发的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是百万的用户请求量单机是无论如何也抗不住的，虽然 Nginx 处理网络请求使用 Epoll 模型，c10k 的问题在业界早已得到了解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 Linux 系统下，一切资源皆文件，网络请求也是这样，大量的文件描述符会使操作系统瞬间失去响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们提到了 Nginx 的加权均衡策略，我们不妨假设将 100W 的用户请求量平均均衡到 100 台服务器上，这样单机所承受的并发量就小了很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们每台机器本地库存 100 张火车票，100 台服务器上的总库存还是 1 万，这样保证了库存订单不超卖，下面是我们描述的集群架构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46747352496217853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ELQw2WCMgt3ZRqPicqe9ML4tPtwXiabgb6CZlkQRxNh2Aw1a8A9ic3mMDErII14JMp8qvMvF1E5R4OicALjHBFiawxg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;661&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题接踵而至，在高并发情况下，现在我们还无法保证系统的高可用，假如这 100 台服务器上有两三台机器因为扛不住并发的流量或者其他的原因宕机了。那么这些服务器上的订单就卖不出去了，这就造成了订单的少卖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要解决这个问题，我们需要对总订单量做统一的管理，这就是接下来的容错方案。服务器不仅要在本地减库存，另外要远程统一减库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了远程统一减库存的操作，我们就可以根据机器负载情况，为每台机器分配一些多余的“Buffer 库存”用来防止机器中有机器宕机的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们结合下面架构图具体分析一下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.518361581920904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ELQw2WCMgt3ZRqPicqe9ML4tPtwXiabgb6UgvfMZle3VbfyD90OKicAWkweYO71asvqNmEthvg9zPG44HrLvdMxTw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;708&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们采用 Redis 存储统一库存，因为 Redis 的性能非常高，号称单机 QPS 能抗 10W 的并发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本地减库存以后，如果本地有订单，我们再去请求 Redis 远程减库存，本地减库存和远程减库存都成功了，才返回给用户抢票成功的提示，这样也能有效的保证订单不会超卖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当机器中有机器宕机时，因为每个机器上有预留的 Buffer 余票，所以宕机机器上的余票依然能够在其他机器上得到弥补，保证了不少卖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Buffer 余票设置多少合适呢，理论上 Buffer 设置的越多，系统容忍宕机的机器数量就越多，但是 Buffer 设置的太大也会对 Redis 造成一定的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Redis 内存数据库抗并发能力非常高，请求依然会走一次网络 IO，其实抢票过程中对 Redis 的请求次数是本地库存和 Buffer 库存的总量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为当本地库存不足时，系统直接返回用户“已售罄”的信息提示，就不会再走统一扣库存的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这在一定程度上也避免了巨大的网络请求量把 Redis 压跨，所以 Buffer 值设置多少，需要架构师对系统的负载能力做认真的考量。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码演示&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言原生为并发设计，我采用 Go 语言给大家演示一下单机抢票的具体流程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;初始化工作&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 包中的 Init 函数先于 Main 函数执行，在这个阶段主要做一些准备性工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们系统需要做的准备工作有：初始化本地库存、初始化远程 Redis 存储统一库存的 Hash 键值、初始化 Redis 连接池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还需要初始化一个大小为 1 的 Int 类型 Chan，目的是实现分布式锁的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以直接使用读写锁或者使用 Redis 等其他的方式避免资源竞争，但使用 Channel 更加高效，这就是 Go 语言的哲学：不要通过共享内存来通信，而要通过通信来共享内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 库使用的是 Redigo，下面是代码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;//localSpike包结构体定义&lt;br/&gt;package localSpike&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; LocalSpike struct {&lt;br/&gt;    LocalInStock     int64&lt;br/&gt;    LocalSalesVolume int64&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;//remoteSpike对&lt;span&gt;hash&lt;/span&gt;结构的定义和redis连接池&lt;br/&gt;package remoteSpike&lt;br/&gt;//远程订单存储健值&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; RemoteSpikeKeys struct {&lt;br/&gt;    SpikeOrderHashKey string    //redis中秒杀订单&lt;span&gt;hash&lt;/span&gt;结构key&lt;br/&gt;    TotalInventoryKey string    //&lt;span&gt;hash&lt;/span&gt;结构中总订单库存key&lt;br/&gt;    QuantityOfOrderKey string   //&lt;span&gt;hash&lt;/span&gt;结构中已有订单数量key&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//初始化redis连接池&lt;br/&gt;func NewPool() *redis.Pool {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;redis.Pool{&lt;br/&gt;        MaxIdle:   10000,&lt;br/&gt;        MaxActive: 12000, // max number of connections&lt;br/&gt;        Dial: func() (redis.Conn, error) {&lt;br/&gt;            c, err := redis.Dial(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;:6379&quot;&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                panic(err.Error())&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; c, err&lt;br/&gt;        },&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;func &lt;span&gt;&lt;span&gt;init&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    localSpike = localSpike2.LocalSpike{&lt;br/&gt;        LocalInStock:     150,&lt;br/&gt;        LocalSalesVolume: 0,&lt;br/&gt;    }&lt;br/&gt;    remoteSpike = remoteSpike2.RemoteSpikeKeys{&lt;br/&gt;        SpikeOrderHashKey:  &lt;span&gt;&quot;ticket_hash_key&quot;&lt;/span&gt;,&lt;br/&gt;        TotalInventoryKey:  &lt;span&gt;&quot;ticket_total_nums&quot;&lt;/span&gt;,&lt;br/&gt;        QuantityOfOrderKey: &lt;span&gt;&quot;ticket_sold_nums&quot;&lt;/span&gt;,&lt;br/&gt;    }&lt;br/&gt;    redisPool = remoteSpike2.NewPool()&lt;br/&gt;    &lt;span&gt;done&lt;/span&gt; = make(chan int, 1)&lt;br/&gt;    &lt;span&gt;done&lt;/span&gt; &amp;lt;- 1&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;本地扣库存和统一扣库存&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地扣库存逻辑非常简单，用户请求过来，添加销量，然后对比销量是否大于本地库存，返回 Bool 值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package localSpike&lt;br/&gt;//本地扣库存,返回bool值&lt;br/&gt;func (spike *LocalSpike) LocalDeductionStock() bool{&lt;br/&gt;    spike.LocalSalesVolume = spike.LocalSalesVolume + 1&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; spike.LocalSalesVolume &amp;lt; spike.LocalInStock&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意这里对共享数据 LocalSalesVolume 的操作是要使用锁来实现的，但是因为本地扣库存和统一扣库存是一个原子性操作，所以在最上层使用 Channel 来实现，这块后边会讲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;统一扣库存操作 Redis，因为 Redis 是单线程的，而我们要实现从中取数据，写数据并计算一些列步骤，我们要配合 Lua 脚本打包命令，保证操作的原子性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package remoteSpike&lt;br/&gt;......&lt;br/&gt;const LuaScript = `&lt;br/&gt;        &lt;span&gt;local&lt;/span&gt; ticket_key = KEYS[1]&lt;br/&gt;        &lt;span&gt;local&lt;/span&gt; ticket_total_key = ARGV[1]&lt;br/&gt;        &lt;span&gt;local&lt;/span&gt; ticket_sold_key = ARGV[2]&lt;br/&gt;        &lt;span&gt;local&lt;/span&gt; ticket_total_nums = tonumber(redis.call(&lt;span&gt;&#x27;HGET&#x27;&lt;/span&gt;, ticket_key, ticket_total_key))&lt;br/&gt;        &lt;span&gt;local&lt;/span&gt; ticket_sold_nums = tonumber(redis.call(&lt;span&gt;&#x27;HGET&#x27;&lt;/span&gt;, ticket_key, ticket_sold_key))&lt;br/&gt;        -- 查看是否还有余票,增加订单数量,返回结果值&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt;(ticket_total_nums &amp;gt;= ticket_sold_nums) &lt;span&gt;then&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&#x27;HINCRBY&#x27;&lt;/span&gt;, ticket_key, ticket_sold_key, 1)&lt;br/&gt;        end&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; 0&lt;br/&gt;`&lt;br/&gt;//远端统一扣库存&lt;br/&gt;func (RemoteSpikeKeys *RemoteSpikeKeys) RemoteDeductionStock(conn redis.Conn) bool {&lt;br/&gt;    lua := redis.NewScript(1, LuaScript)&lt;br/&gt;    result, err := redis.Int(lua.Do(conn, RemoteSpikeKeys.SpikeOrderHashKey, RemoteSpikeKeys.TotalInventoryKey, RemoteSpikeKeys.QuantityOfOrderKey))&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result != 0&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用 Hash 结构存储总库存和总销量的信息，用户请求过来时，判断总销量是否大于库存，然后返回相关的 Bool 值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在启动服务之前，我们需要初始化 Redis 的初始库存信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hmset ticket_hash_key &lt;span&gt;&quot;ticket_total_nums&quot;&lt;/span&gt; 10000 &lt;span&gt;&quot;ticket_sold_nums&quot;&lt;/span&gt; 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;响应用户信息&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们开启一个 HTTP 服务，监听在一个端口上：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;...&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    http.HandleFunc(&lt;span&gt;&quot;/buy/ticket&quot;&lt;/span&gt;, handleReq)&lt;br/&gt;    http.ListenAndServe(&lt;span&gt;&quot;:3005&quot;&lt;/span&gt;, nil)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们做完了所有的初始化工作，接下来 handleReq 的逻辑非常清晰，判断是否抢票成功，返回给用户信息就可以了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;//处理请求函数,根据请求将响应结果信息写入日志&lt;br/&gt;func handleReq(w http.ResponseWriter, r *http.Request) {&lt;br/&gt;    redisConn := redisPool.Get()&lt;br/&gt;    LogMsg := &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;    &amp;lt;-&lt;span&gt;done&lt;/span&gt;&lt;br/&gt;    //全局读写锁&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; localSpike.LocalDeductionStock() &amp;amp;&amp;amp; remoteSpike.RemoteDeductionStock(redisConn) {&lt;br/&gt;        util.RespJson(w, 1,  &lt;span&gt;&quot;抢票成功&quot;&lt;/span&gt;, nil)&lt;br/&gt;        LogMsg = LogMsg + &lt;span&gt;&quot;result:1,localSales:&quot;&lt;/span&gt; + strconv.FormatInt(localSpike.LocalSalesVolume, 10)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        util.RespJson(w, -1, &lt;span&gt;&quot;已售罄&quot;&lt;/span&gt;, nil)&lt;br/&gt;        LogMsg = LogMsg + &lt;span&gt;&quot;result:0,localSales:&quot;&lt;/span&gt; + strconv.FormatInt(localSpike.LocalSalesVolume, 10)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;done&lt;/span&gt; &amp;lt;- 1&lt;br/&gt;&lt;br/&gt;    //将抢票状态写入到&lt;span&gt;log&lt;/span&gt;中&lt;br/&gt;    writeLog(LogMsg, &lt;span&gt;&quot;./stat.log&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func writeLog(msg string, logPath string) {&lt;br/&gt;    fd, _ := os.OpenFile(logPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)&lt;br/&gt;    defer fd.Close()&lt;br/&gt;    content := strings.Join([]string{msg, &lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;}, &lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt;    buf := []byte(content)&lt;br/&gt;    fd.Write(buf)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边提到我们扣库存时要考虑竞态条件，我们这里是使用 Channel 避免并发的读写，保证了请求的高效顺序执行。我们将接口的返回信息写入到了 ./stat.log 文件方便做压测统计。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;单机服务压测&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启服务，我们使用 AB 压测工具进行测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ab -n 10000 -c 100 http://127.0.0.1:3005/buy/ticket&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是我本地低配 Mac 的压测信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;This is ApacheBench, Version 2.3 &amp;lt;&lt;span&gt;$revision&lt;/span&gt;: 1826891=&lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/&lt;br/&gt;Licensed to The Apache Software Foundation, http://www.apache.org/&lt;br/&gt;&lt;br/&gt;Benchmarking 127.0.0.1 (be patient)&lt;br/&gt;Completed 1000 requests&lt;br/&gt;Completed 2000 requests&lt;br/&gt;Completed 3000 requests&lt;br/&gt;Completed 4000 requests&lt;br/&gt;Completed 5000 requests&lt;br/&gt;Completed 6000 requests&lt;br/&gt;Completed 7000 requests&lt;br/&gt;Completed 8000 requests&lt;br/&gt;Completed 9000 requests&lt;br/&gt;Completed 10000 requests&lt;br/&gt;Finished 10000 requests&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;Server Software:&lt;br/&gt;Server Hostname:        127.0.0.1&lt;br/&gt;Server Port:            3005&lt;br/&gt;&lt;br/&gt;Document Path:          /buy/ticket&lt;br/&gt;Document Length:        29 bytes&lt;br/&gt;&lt;br/&gt;Concurrency Level:      100&lt;br/&gt;Time taken &lt;span&gt;for&lt;/span&gt; tests:   2.339 seconds&lt;br/&gt;Complete requests:      10000&lt;br/&gt;Failed requests:        0&lt;br/&gt;Total transferred:      1370000 bytes&lt;br/&gt;HTML transferred:       290000 bytes&lt;br/&gt;Requests per second:    4275.96 [&lt;span&gt;#/sec] (mean)&lt;/span&gt;&lt;br/&gt;Time per request:       23.387 [ms] (mean)&lt;br/&gt;Time per request:       0.234 [ms] (mean, across all concurrent requests)&lt;br/&gt;Transfer rate:          572.08 [Kbytes/sec] received&lt;br/&gt;&lt;br/&gt;Connection Times (ms)&lt;br/&gt;              min  mean[+/-sd] median   max&lt;br/&gt;Connect:        0    8  14.7      6     223&lt;br/&gt;Processing:     2   15  17.6     11     232&lt;br/&gt;Waiting:        1   11  13.5      8     225&lt;br/&gt;Total:          7   23  22.8     18     239&lt;br/&gt;&lt;br/&gt;Percentage of the requests served within a certain time (ms)&lt;br/&gt;  50%     18&lt;br/&gt;  66%     24&lt;br/&gt;  75%     26&lt;br/&gt;  80%     28&lt;br/&gt;  90%     33&lt;br/&gt;  95%     39&lt;br/&gt;  98%     45&lt;br/&gt;  99%     54&lt;br/&gt; 100%    239 (longest request)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据指标显示，我单机每秒就能处理 4000+ 的请求，正常服务器都是多核配置，处理 1W+ 的请求根本没有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且查看日志发现整个服务过程中，请求都很正常，流量均匀，Redis 也很正常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//stat.log&lt;br/&gt;...&lt;br/&gt;result:1,localSales:145&lt;br/&gt;result:1,localSales:146&lt;br/&gt;result:1,localSales:147&lt;br/&gt;result:1,localSales:148&lt;br/&gt;result:1,localSales:149&lt;br/&gt;result:1,localSales:150&lt;br/&gt;result:0,localSales:151&lt;br/&gt;result:0,localSales:152&lt;br/&gt;result:0,localSales:153&lt;br/&gt;result:0,localSales:154&lt;br/&gt;result:0,localSales:156&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结回顾&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来说，秒杀系统是非常复杂的。我们这里只是简单介绍模拟了一下单机如何优化到高性能，集群如何避免单点故障，保证订单不超卖、不少卖的一些策略&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整的订单系统还有订单进度的查看，每台服务器上都有一个任务，定时的从总库存同步余票和库存信息展示给用户，还有用户在订单有效期内不支付，释放订单，补充到库存等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们实现了高并发抢票的核心逻辑，可以说系统设计的非常的巧妙，巧妙的避开了对 DB 数据库 IO 的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 Redis 网络 IO 的高并发请求，几乎所有的计算都是在内存中完成的，而且有效的保证了不超卖、不少卖，还能够容忍部分机器的宕机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得其中有两点特别值得学习总结：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;①负载均衡，分而治之&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过负载均衡，将不同的流量划分到不同的机器上，每台机器处理好自己的请求，将自己的性能发挥到极致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样系统的整体也就能承受极高的并发了，就像工作的一个团队，每个人都将自己的价值发挥到了极致，团队成长自然是很大的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;②合理的使用并发和异步&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自 Epoll 网络架构模型解决了 c10k 问题以来，异步越来越被服务端开发人员所接受，能够用异步来做的工作，就用异步来做，在功能拆解上能达到意想不到的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这点在 Nginx、Node.JS、Redis 上都能体现，他们处理网络请求使用的 Epoll 模型，用实践告诉了我们单线程依然可以发挥强大的威力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器已经进入了多核时代，Go 语言这种天生为并发而生的语言，完美的发挥了服务器多核优势，很多可以并发处理的任务都可以使用并发来解决，比如 Go 处理 HTTP 请求时每个请求都会在一个 Goroutine 中执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，怎样合理的压榨 CPU，让其发挥出应有的价值，是我们一直需要探索学习的方向。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;转自：绘你一世倾城&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接&lt;span&gt;：https://juejin.cn/post/6844903949632274445&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651498366&amp;amp;idx=1&amp;amp;sn=8d2da4f9e728b09664e0a9417247a0e7&amp;amp;chksm=bd25cb018a524217aa7b2d29d539b68e8fef3a08e133c137c7fc09e51faf3893de256092eb46&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;高并发下秒杀商品，你必须知道的 9 个细节&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;高并发下秒杀商品，你必须知道的 9 个细节&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651490994&amp;amp;idx=1&amp;amp;sn=5330a66e59885ec5dfc2919d53a0af1a&amp;amp;chksm=bd25e6cd8a526fdb1e952d6ec3a35fd089bea014005b050004e15c7cb58b78ca48f95b9c8ff3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;高频面试题：秒杀场景设计&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;高频面试题：秒杀场景设计&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>af533cbc7d3c8f877aaef15b079187f2</guid>
<title>教你如何定位不合理的SQL？并优化之</title>
<link>https://toutiao.io/k/huxhsnt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                        &lt;h1&gt;如何定位不合理的SQL&lt;/h1&gt; 
&lt;pre&gt;&lt;code&gt;引言
在应用的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多SQL语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的SQL语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在MySQL中优化SQL语句的方法。

当面对一个有SQL性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题SQL并尽快解决问题。
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;4.1 如何查看SQL执行频率&lt;/h2&gt; 
&lt;p&gt;MySQL 客户端连接成功后，通过&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- 服务器状态信息
show [session|global] status;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。&lt;/p&gt; 
&lt;p&gt;如果不写，默认使用参数是“session”。&lt;/p&gt; 
&lt;p&gt;下面的命令显示了当前 session 中所有统计参数的值：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;show status like &#x27;Com_______&#x27;;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-0f0fa8a261cb7f03d783322855bdbc51768.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;show status like &#x27;Innodb_rows_%&#x27;;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-301c38317ed76b33255ba5291abce037e73.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th align=&quot;left&quot;&gt;参数&lt;/th&gt; 
   &lt;th&gt;含义&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;Com_select&lt;/td&gt; 
   &lt;td&gt;执行 select 操作的次数，一次查询只累加 1。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;Com_insert&lt;/td&gt; 
   &lt;td&gt;执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;Com_update&lt;/td&gt; 
   &lt;td&gt;执行 UPDATE 操作的次数。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;Com_delete&lt;/td&gt; 
   &lt;td&gt;执行 DELETE 操作的次数。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;Innodb_rows_read&lt;/td&gt; 
   &lt;td&gt;select 查询返回的行数。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;Innodb_rows_inserted&lt;/td&gt; 
   &lt;td&gt;执行 INSERT 操作插入的行数。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;Innodb_rows_updated&lt;/td&gt; 
   &lt;td&gt;执行 UPDATE 操作更新的行数。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;Innodb_rows_deleted&lt;/td&gt; 
   &lt;td&gt;执行 DELETE 操作删除的行数。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;Connections&lt;/td&gt; 
   &lt;td&gt;试图连接 MySQL 服务器的次数。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;Uptime&lt;/td&gt; 
   &lt;td&gt;服务器工作时间。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;Slow_queries&lt;/td&gt; 
   &lt;td&gt;慢查询的次数。&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;Com_*** : 这些参数对于所有存储引擎的表操作都会进行累计。&lt;/p&gt; 
&lt;p&gt;Innodb_*** : 这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。&lt;/p&gt; 
&lt;h2&gt;4.2 如何定位低效率SQL&lt;/h2&gt; 
&lt;p&gt;以下两种方式：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;慢查询日志（重要） :&lt;/strong&gt; 通过慢查询日志定位那些执行效率较低的 SQL 语句，用--log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;tips：&lt;/p&gt; 
   &lt;p&gt;关于慢查询SQL如何获取&lt;/p&gt; 
   &lt;p&gt;参看上个章节&lt;/p&gt; 
  &lt;/blockquote&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;show processlist （重要） :&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;慢查询日志在查询结束以后才记录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题。&lt;/p&gt; &lt;p&gt;可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-7d647c94783723830a00a013f6fca57a910.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;属性字段解释
1） id列，用户登录mysql时，系统分配的&quot;connection_id&quot;，可以使用函数connection_id()查看
2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句
3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户
4） db列，显示这个进程目前连接的是哪个数据库
5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等
6） time列，显示这个状态持续的时间，单位是秒
7） state列，显示使用当前连接的sql语句的状态，很重要的列。
state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成
8） info列，显示这个sql语句，是判断问题语句的一个重要依据
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;4.3 使用explain分析执行计划&lt;/h2&gt; 
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;-- explain 分析执行计划
explain SELECT * FROM product_list WHERE store_name = &#x27;联想北达兴科专卖店&#x27;;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-d62fbe64fb0e918b4c2b16e4a8c6731d8f7.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;字段&lt;/th&gt; 
   &lt;th&gt;含义&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;id&lt;/td&gt; 
   &lt;td&gt;select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;select_type&lt;/td&gt; 
   &lt;td&gt;表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;table&lt;/td&gt; 
   &lt;td&gt;输出结果集的表&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;partitions&lt;/td&gt; 
   &lt;td&gt;匹配的分区&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;type&lt;/td&gt; 
   &lt;td&gt;表示表的连接类型，性能由好到差的连接类型为( system ---&amp;gt; const -----&amp;gt; eq_ref ------&amp;gt; ref -------&amp;gt; ref_or_null----&amp;gt; index_merge ---&amp;gt; index_subquery -----&amp;gt; range -----&amp;gt; index ------&amp;gt; all )&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;possible_keys&lt;/td&gt; 
   &lt;td&gt;表示查询时，可能使用的索引&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;key&lt;/td&gt; 
   &lt;td&gt;表示实际使用的索引&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;key_len&lt;/td&gt; 
   &lt;td&gt;索引字段的长度&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;rows&lt;/td&gt; 
   &lt;td&gt;扫描行的数量&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;filtered&lt;/td&gt; 
   &lt;td&gt;按表条件过滤的行百分比&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;extra&lt;/td&gt; 
   &lt;td&gt;执行情况的说明和描述&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h3&gt;4.3.1 环境准备&lt;/h3&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-505e9df7e57b438be9ecc9d75d5d0068e05.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `t_role` (
  `id` varchar(32) NOT NULL,
  `role_name` varchar(255) DEFAULT NULL,
  `role_code` varchar(255) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_role_name` (`role_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `t_user` (
  `id` varchar(32) NOT NULL,
  `username` varchar(45) NOT NULL,
  `password` varchar(96) NOT NULL,
  `name` varchar(45) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `user_role` (
  `id` int(11) NOT NULL auto_increment ,
  `user_id` varchar(32) DEFAULT NULL,
  `role_id` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_role_user` (`role_id`,`user_id`),
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert into `t_user` (`id`, `username`, `password`, `name`) values(&#x27;1&#x27;,&#x27;super&#x27;,&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;,&#x27;超级管理员&#x27;);
insert into `t_user` (`id`, `username`, `password`, `name`) values(&#x27;2&#x27;,&#x27;admin&#x27;,&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;,&#x27;系统管理员&#x27;);
insert into `t_user` (`id`, `username`, `password`, `name`) values(&#x27;3&#x27;,&#x27;itcast&#x27;,&#x27;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#x27;,&#x27;test02&#x27;);
insert into `t_user` (`id`, `username`, `password`, `name`) values(&#x27;4&#x27;,&#x27;stu1&#x27;,&#x27;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa&#x27;,&#x27;学生1&#x27;);
insert into `t_user` (`id`, `username`, `password`, `name`) values(&#x27;5&#x27;,&#x27;stu2&#x27;,&#x27;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm&#x27;,&#x27;学生2&#x27;);
insert into `t_user` (`id`, `username`, `password`, `name`) values(&#x27;6&#x27;,&#x27;t1&#x27;,&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;,&#x27;老师1&#x27;);

INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(&#x27;5&#x27;,&#x27;学生&#x27;,&#x27;student&#x27;,&#x27;学生&#x27;);
INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(&#x27;7&#x27;,&#x27;老师&#x27;,&#x27;teacher&#x27;,&#x27;老师&#x27;);
INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(&#x27;8&#x27;,&#x27;教学管理员&#x27;,&#x27;teachmanager&#x27;,&#x27;教学管理员&#x27;);
INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(&#x27;9&#x27;,&#x27;管理员&#x27;,&#x27;admin&#x27;,&#x27;管理员&#x27;);
INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(&#x27;10&#x27;,&#x27;超级管理员&#x27;,&#x27;super&#x27;,&#x27;超级管理员&#x27;);

INSERT INTO user_role(id,user_id,role_id) VALUES(NULL, &#x27;1&#x27;, &#x27;5&#x27;),(NULL, &#x27;1&#x27;, &#x27;7&#x27;),(NULL, &#x27;2&#x27;, &#x27;8&#x27;),(NULL, &#x27;3&#x27;, &#x27;9&#x27;),(NULL, &#x27;4&#x27;, &#x27;8&#x27;),(NULL, &#x27;5&#x27;, &#x27;10&#x27;) ;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;4.3.2 explain 之 id&lt;/h3&gt; 
&lt;p&gt;id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。&lt;/p&gt; 
&lt;p&gt;id 情况有三种 ：&lt;/p&gt; 
&lt;p&gt;1） id 相同表示加载表的顺序是从上到下。&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;explain select * from t_role r, t_user u, user_role ur where r.id = ur.role_id and u.id = ur.user_id ;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-7782ec2772709c02183bb7e0da6ccd3d45d.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;2） id 不同id值越大，优先级越高，越先被执行。&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;EXPLAIN SELECT * FROM t_role WHERE id = (SELECT role_id FROM user_role WHERE user_id = (SELECT id FROM t_user WHERE username = &#x27;stu1&#x27;))
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-24a3673f1e09de7c598d95effd280dfa10c.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;3） id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;EXPLAIN SELECT * FROM t_role r , (SELECT * FROM user_role ur WHERE ur.`user_id` = &#x27;2&#x27;) a WHERE r.id = (select role.id from t_user, user_role role where role.id = 10) ;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-3788c00e9e00f1da9973d5955d54a92c4ec.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;4.3.3 explain 之 select_type&lt;/h3&gt; 
&lt;p&gt;表示 SELECT 的类型，常见的取值，如下表所示：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;EXPLAIN SELECT * FROM t_role WHERE id = (SELECT role_id FROM user_role WHERE user_id = (SELECT id FROM t_user WHERE username = &#x27;stu1&#x27;));
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-a97f4bfb7bc1718e40fd1b25ced4e429b2c.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;select_type&lt;/th&gt; 
   &lt;th&gt;含义&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;SIMPLE&lt;/td&gt; 
   &lt;td&gt;简单的select查询，查询中不包含子查询或者UNION&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;PRIMARY&lt;/td&gt; 
   &lt;td&gt;查询中若包含任何复杂的子查询，最外层查询标记为该标识&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;SUBQUERY&lt;/td&gt; 
   &lt;td&gt;在SELECT 或 WHERE 列表中包含了子查询&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;DERIVED&lt;/td&gt; 
   &lt;td&gt;在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;UNION&lt;/td&gt; 
   &lt;td&gt;若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;UNION RESULT&lt;/td&gt; 
   &lt;td&gt;从UNION表获取结果的SELECT&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h3&gt;4.3.4 explain 之 table&lt;/h3&gt; 
&lt;p&gt;展示这一行的数据是关于哪一张表的&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;EXPLAIN SELECT * FROM t_role WHERE id = (SELECT role_id FROM user_role WHERE user_id = (SELECT id FROM t_user WHERE username = &#x27;stu1&#x27;));
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-520269c821a8f1451dca7dc0119c1a9768e.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;4.3.5 explain 之 type&lt;/h3&gt; 
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;EXPLAIN SELECT * FROM t_role WHERE id = (SELECT role_id FROM user_role WHERE user_id = (SELECT id FROM t_user WHERE username = &#x27;stu1&#x27;));
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-621b0da6e4b3e294f75043e1ff95687b3d1.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;type 显示的是访问类型，是较为重要的一个指标，可取值为：&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;type&lt;/th&gt; 
   &lt;th&gt;含义&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;NULL&lt;/td&gt; 
   &lt;td&gt;MySQL不访问任何表，索引，直接返回结果&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;system&lt;/td&gt; 
   &lt;td&gt;表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;const&lt;/td&gt; 
   &lt;td&gt;表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常量。const会将 &quot;主键&quot; 或 &quot;唯一&quot; 索引的所有部分与常量值进行比较&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;eq_ref&lt;/td&gt; 
   &lt;td&gt;类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;ref&lt;/td&gt; 
   &lt;td&gt;非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;range&lt;/td&gt; 
   &lt;td&gt;只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &amp;lt; , &amp;gt; , in 等操作。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;index&lt;/td&gt; 
   &lt;td&gt;index 与 ALL的区别为 index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;all&lt;/td&gt; 
   &lt;td&gt;将遍历全表以找到匹配的行&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;结果值从最好到最坏依次是：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;NULL &amp;gt; system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; fulltext &amp;gt; ref_or_null &amp;gt; index_merge &amp;gt; unique_subquery &amp;gt; index_subquery &amp;gt; range &amp;gt; index &amp;gt; ALL


system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; ALL
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。&lt;/p&gt; 
&lt;h3&gt;4.3.6 explain 之 key&lt;/h3&gt; 
&lt;pre&gt;&lt;code&gt;possible_keys : 显示可能应用在这张表的索引， 一个或多个。 
key ： 实际使用的索引， 如果为NULL， 则没有使用索引。
key_len : 表示索引中使用的字节数。len=3*n+2（n为索引字段的长度）

EXPLAIN select * from t_role where role_name = &#x27;超级管理员&#x27;; 
select 255 * 3 + 2; -- role_name VARCHAR(255)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-0ee7692406926ac2292816f03a5caa9aa97.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;4.3.7 explain 之 rows&lt;/h3&gt; 
&lt;p&gt;扫描行的数量。&lt;/p&gt; 
&lt;h3&gt;4.3.8 explain 之 extra&lt;/h3&gt; 
&lt;p&gt;其他的额外的执行计划信息，在该列展示 。&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;EXPLAIN select u.username from t_user u order by u.username desc;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-cc4c0f9a01a38bfc940a60d64c477d12a13.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;extra&lt;/th&gt; 
   &lt;th&gt;含义&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;using filesort&lt;/td&gt; 
   &lt;td&gt;说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;using temporary&lt;/td&gt; 
   &lt;td&gt;使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;using index&lt;/td&gt; 
   &lt;td&gt;表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;本文由育博学谷狂野架构师发布 如果本文对您有帮助，欢迎关注和点赞；如果您有任何建议也可留言评论或私信，您的支持是我坚持创作的动力 转载请注明出处！&lt;/p&gt; 
&lt;/blockquote&gt;
                                        &lt;/div&gt;
                                    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e598d7888ed4db763ba34c16d843aa05</guid>
<title>太强了！Python 开发桌面小工具，让代码替我们干重复的工作！</title>
<link>https://toutiao.io/k/6ygdu6f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2NjY5NzI0NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/gY6csrBUrKh3h4SdEvm82PSOkKwZhDXibthiaS1pzjoJ7n2EvZg8lic2QqKXhDcicrl6KVnD4wibKgx9DUkBfS2PA7w/0?wx_fmt=png&quot; data-nickname=&quot;Python数据之道&quot; data-alias=&quot;PyDataLab&quot; data-signature=&quot;点击领取《Python知识手册》高清电子版，回复数字 “600” 获取。「Python数据之道」秉承“让数据更有价值”的理念，聚焦于 Python 数据分析、数据可视化、AI、机器学习、深度学习等领域。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span msthash=&quot;837629&quot; msttexthash=&quot;11849097&quot; mstvisible=&quot;9&quot;/&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;24&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span msthash=&quot;837629&quot; msttexthash=&quot;11849097&quot; mstvisible=&quot;9&quot;&gt;作者 | Cherish&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span msthash=&quot;837630&quot; msttexthash=&quot;50709126&quot; mstvisible=&quot;9&quot;&gt;来源 | 杰哥的IT之旅&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span msthash=&quot;837630&quot; msttexthash=&quot;50709126&quot; mstvisible=&quot;9&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span msthash=&quot;837630&quot; msttexthash=&quot;50709126&quot; mstvisible=&quot;9&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;决定写这篇文章的初衷是来源于一位小伙伴的问题，关于&quot;如何根据数据源用 Python 自动生成透视表&quot;，这个问题背后有个非常好的解决思路，让代码替我们做重复的工作，从而减轻工作量，减少出错。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Python 开发的小工具实际上是将 Python 程序打包成 exe，分享即可用，即便电脑没有安装 Python 环境，也可以使用，用代码提高工作效率，尽量少加班。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpQSxkP86X0WRl0fqNMbaGmfugCUZlSFegRv3QRUqeGyibURn0WdVysSQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;内容大纲&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;明确需求：自动生成透视表【这部分可以换成你的重复性工作】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;安装三方依赖库：tkinter 和 pyinstaller&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码实现：包括两部分 Python 生成透视表和桌面 GUI 联动设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;打包 Python 程序 生成 exe 可执行文件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决 exe 文件可能过大问题：安装虚拟环境&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VeJKXItpwPWf7XS3tqT5j3m4RicVvkJia4KmRKa57BIIr7XAJCfTuGCQc83zviaBP0D9fSpeQyWLGiaCicYnkm2WpTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1125&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;需求背景&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;将工作中重复性的操作，利用供应商名称，月份，入库金额三个字段来生成想要的透视表格式。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38166666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpYPicUVZJYEgiaZIND3MVHklZ6DgTHepUnBbk28GBS0KuTOZzQF9lBsIQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VeJKXItpwPWf7XS3tqT5j3m4RicVvkJia4wIV1EdGtAngSs2lGEDj9K0Bzl65dkVbBichNGPxc5r8HmsgJBbtD8zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1125&quot;/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;安装三方依赖库&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;创建桌面窗口，这里使用 tkinter，它是 Python 自带的 GUI 库，安装后即可使用。&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;pip&lt;/span&gt; install tkinter&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;使用 pyinsatller 将程序打包成 exe，好处是不需要将代码部署到服务器，直接将打包好的 exe 发给对方，就能直接使用，对于这种小而轻的功能非常友好。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;pip&lt;/span&gt; install pyinstaller&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VeJKXItpwPWf7XS3tqT5j3m4RicVvkJia4wQ2vZgibWoq4ibczickNm1Yl4kkrSMRAscsfyzYOxSOMB0HYdTSmE9hlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1125&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;代码实现&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Excel 文件生成透视表和筛选数据，文件名：excel_to_pivot.py&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; pandas &lt;span&gt;as&lt;/span&gt; pd&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; numpy &lt;span&gt;as&lt;/span&gt; np&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExcelToPivot&lt;/span&gt;&lt;span&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, filename, file_path)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        self.file_name = filename&lt;br/&gt;        self.file_path = file_path&lt;br/&gt;    &lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;        excel自动转透视表功能&lt;br/&gt;        返回透视结果&lt;br/&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;excel_Pivot&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        print(self.file_path)&lt;br/&gt;        data = pd.read_excel(self.file_path)&lt;br/&gt;        data_pivot_table = pd.pivot_table(data, index=[&lt;span&gt;&#x27;供应商名称&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;月份&#x27;&lt;/span&gt;], values=[&lt;span&gt;&quot;入库金额&quot;&lt;/span&gt;], aggfunc=np.sum)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; data_pivot_table&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;        按条件筛选，并保存&lt;br/&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;select_data&lt;/span&gt;&lt;span&gt;(self, name, month)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        data_pivot_table = self.excel_Pivot()&lt;br/&gt;        data_new = data_pivot_table.query(&lt;span&gt;&#x27;供应商名称 == [&quot;{}&quot;] &amp;amp; 月份 == {}&#x27;&lt;/span&gt;.format(name, month))&lt;br/&gt;        data_new.to_excel(&lt;span&gt;&#x27;{}.xlsx&#x27;&lt;/span&gt;.format(str(self.file_name).split(&lt;span&gt;&#x27;.&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;]))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;筛选完成！&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;    filename = input(&lt;span&gt;&quot;请输入文件名字：&quot;&lt;/span&gt;)&lt;br/&gt;    path = &lt;span&gt;&#x27;C:/Users/cherich/Desktop/&#x27;&lt;/span&gt; + filename&lt;br/&gt;    pross = ExcelToPivot(filename, path)&lt;br/&gt;    print(pross.select_data(&lt;span&gt;&quot;C&quot;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;))&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2934156378600823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vprwU3xpTs9QOMuAUZNxMLFarTpJ7sqDbiaJ1rvgUOewpTkWOhX9kPsibA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2430&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;设计桌面窗口功能，文件名：opration.py&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt; tkinter &lt;span&gt;import&lt;/span&gt; Tk, Entry, Button, mainloop&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; tkinter.filedialog&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; excel_to_pivot&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; tkinter &lt;span&gt;import&lt;/span&gt; messagebox&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; tkinter &lt;span&gt;import&lt;/span&gt; ttk&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;Upload&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;global&lt;/span&gt; filename, data_pivot_table&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt;:&lt;br/&gt;        filename = tkinter.filedialog.askopenfilename(title=&lt;span&gt;&#x27;选择文件&#x27;&lt;/span&gt;)&lt;br/&gt;        pross = excel_to_pivot.ExcelToPivot(str(filename).split(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;)[&lt;span&gt;-1&lt;/span&gt;], filename)&lt;br/&gt;        data_pivot_table = pross.excel_Pivot()&lt;br/&gt;        messagebox.showinfo(&lt;span&gt;&#x27;Info&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;转换成功！&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;except&lt;/span&gt; Exception &lt;span&gt;as&lt;/span&gt; e:&lt;br/&gt;        print(e)&lt;br/&gt;        messagebox.showinfo(&lt;span&gt;&#x27;Info&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;转换失败！&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;(name, month)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt;:&lt;br/&gt;        print(&lt;span&gt;&#x27;供应商名称 == [&quot;{}&quot;] &amp;amp; 月份 == {}&#x27;&lt;/span&gt;.format(name, month))&lt;br/&gt;        data_new = data_pivot_table.query(&lt;span&gt;&#x27;供应商名称 == [&quot;{}&quot;] &amp;amp; 月份 == {}&#x27;&lt;/span&gt;.format(name, month))&lt;br/&gt;        data_new.to_excel(&lt;span&gt;&#x27;{}.xlsx&#x27;&lt;/span&gt;.format(str(filename).split(&lt;span&gt;&#x27;.&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;]))&lt;br/&gt;        messagebox.showinfo(&lt;span&gt;&#x27;Info&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;筛选完成并生成文件！&#x27;&lt;/span&gt;)&lt;br/&gt;        root.destroy()&lt;br/&gt;    &lt;span&gt;except&lt;/span&gt; Exception &lt;span&gt;as&lt;/span&gt; e:&lt;br/&gt;        print(e)&lt;br/&gt;        messagebox.showinfo(&lt;span&gt;&#x27;Info&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;筛选失败！&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;root = Tk()&lt;br/&gt;root.config(background=&lt;span&gt;&quot;#6fb765&quot;&lt;/span&gt;)&lt;br/&gt;root.title(&lt;span&gt;&#x27;自动转透视表小工具&#x27;&lt;/span&gt;)&lt;br/&gt;root.geometry(&lt;span&gt;&#x27;500x250&#x27;&lt;/span&gt;)&lt;br/&gt;e1 = Entry(root, width=&lt;span&gt;30&lt;/span&gt;)&lt;br/&gt;e1.grid(row=&lt;span&gt;2&lt;/span&gt;, column=&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;btn1 = Button(root, text=&lt;span&gt;&#x27; 上传文件 &#x27;&lt;/span&gt;, command=Upload).grid(row=&lt;span&gt;2&lt;/span&gt;, column=&lt;span&gt;10&lt;/span&gt;, pady=&lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;box1 = ttk.Combobox(root)&lt;br/&gt;&lt;span&gt;# 使用 grid() 来控制控件的位置&lt;/span&gt;&lt;br/&gt;box1.grid(row=&lt;span&gt;5&lt;/span&gt;, sticky=&lt;span&gt;&quot;NW&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;# 设置下拉菜单中的值&lt;/span&gt;&lt;br/&gt;box1[&lt;span&gt;&#x27;value&#x27;&lt;/span&gt;] = (&lt;span&gt;&#x27;A&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;B&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;C&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;D&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;供应商&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;# 通过 current() 设置下拉菜单选项的默认值&lt;/span&gt;&lt;br/&gt;box1.current(&lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;box2 = ttk.Combobox(root)&lt;br/&gt;box2.grid(row=&lt;span&gt;5&lt;/span&gt;, column=&lt;span&gt;1&lt;/span&gt;, sticky=&lt;span&gt;&quot;NW&quot;&lt;/span&gt;)&lt;br/&gt;box2[&lt;span&gt;&#x27;value&#x27;&lt;/span&gt;] = (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;&#x27;月份&#x27;&lt;/span&gt;)&lt;br/&gt;box2.current(&lt;span&gt;12&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 编写回调函数，绑定执行事件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(event)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;global&lt;/span&gt; b1, b2&lt;br/&gt;    b1 = box1.get()&lt;br/&gt;    b2 = box2.get()&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 绑定下拉菜单事件&lt;/span&gt;&lt;br/&gt;box1.bind(&lt;span&gt;&quot;&amp;lt;&amp;lt;ComboboxSelected&amp;gt;&amp;gt;&quot;&lt;/span&gt;, func)&lt;br/&gt;box2.bind(&lt;span&gt;&quot;&amp;lt;&amp;lt;ComboboxSelected&amp;gt;&amp;gt;&quot;&lt;/span&gt;, func)&lt;br/&gt;btn2 = Button(root, text=&lt;span&gt;&#x27; 筛选数据 &#x27;&lt;/span&gt;, command=&lt;span&gt;lambda&lt;/span&gt;: select(b1, b2)).grid(row=&lt;span&gt;30&lt;/span&gt;, column=&lt;span&gt;10&lt;/span&gt;, pady=&lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;mainloop()&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42049025769956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpcViaGwXxEFz6DSdOZPVa1pXUTezbFfPqJud5p7cB4CB3XDdAn6DIrWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3182&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;如果运行结果如上，说明代码没有问题了，可以进行下一步。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VeJKXItpwPWf7XS3tqT5j3m4RicVvkJia4JxlFASkab3MUTtghhicJhaHhcJor04HtIFOZBVPvucx14Q4FaU24VTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1125&quot;/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;打包 Python 程序生成 exe&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;打开 DOS 窗口并切换到 两个 py 文件所在的目录，注意路径中不要有中文。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;pyinsatller&lt;/span&gt; &lt;span&gt;-F&lt;/span&gt; &lt;span&gt;-w&lt;/span&gt; &lt;span&gt;opration&lt;/span&gt;&lt;span&gt;.py&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5180217937971501&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpbvyjkzwzSRUI405ap7jQ4xzP4Rht7oDq3UPaoAibZmJT1icunnjVVMHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2386&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;pyinstaller 指令的常见可选参数：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-i 给应用程序添加图标&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-F 指定打包后只生成一个exe格式的文件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-D –onedir 创建一个目录，包含exe文件，但会依赖很多文件（默认选项）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-c –console, –nowindowed 使用控制台，无界面(默认)&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-w –windowed, –noconsole 使用窗口，无控制台&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;-p 添加搜索路径&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37416666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpo9eJpfZYpdUFxNJbuYKOvxefqBXq1tXb0J1dxeXRsfgVnicB75BicoHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21416666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpdblicdor7bW4YcK2Wdlezlar4VRsREDol54l6icBfFGW6PdicZ3Ih7bpQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;在当前的目录下，将会生成两个文件夹：build 和 dist。dist 里面就是所有可执行 exe 文件，发送快捷方式到桌面，点击 opration.exe 就能运行了，可以发它的快捷方式发送到桌面，双击就可以。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VeJKXItpwPWf7XS3tqT5j3m4RicVvkJia49OwAgFgic4BrtAgvibArIZwSlM6qsTFhyrHxUO9YXvLiaicV860eXL12ew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1125&quot;/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解决 exe 文件可能过大问题&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;有的伙伴 Python 环境刚安装没多久，可能不存在这个文件过大的问题。像我的电脑里安装了 Python 很多的依赖包和 anaconda 等等，打包出来的文件居然 660M，打包时间长，执行时还卡，后来经过整改缩小到 31M，打包快，秒级执行。解决方案是在 Windows 系统下安装一个 Python 的虚拟环境，前提是已经在电脑上安装过 Python 才可以进行如下操作。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5316666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpgDSILx3K2iciaGRgicJFXKoarbAuVFoYfUjx9qYb7UzRdTm61YJIB8qIg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;找到 Python 所在路径，如果忘记了，可以在电脑左下角搜索【编辑系统环境变量】——【用户变量】——【PATH】中找到&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49166666666666664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpFopsBUIkALV9RCoznT5kibSlkwJrwFwiccbiaBHuLWfPyxUHhaeDFvYxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.73&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpicmcicQsRbC03N7RKpdIQwkE0MHxRD3gHwmvvQSO8m4JnpZ2YazE3t0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;h4&gt;&lt;span&gt;配置虚拟环境&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;虚拟环境可以理解为是 Python 解释器的一个副本，在这个环境你可以安装私有包，而且不会影响系统中安装的全局 Python 解释器。虚拟环境非常有用，可以在系统的 Python 解释器中避免包的混乱和版本的冲突。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重要是不同虚拟环境可以搭建不同的 Python 版本，创建时候选择，我们这里需要一个相对 &quot;干净&quot; 的 Python 环境，没有安装过多依赖包，避免 exe 打包文件过大，所以用到虚拟环境。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;安装虚拟环境依赖包&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;pip &lt;span&gt;install&lt;/span&gt; virtualenv&lt;br/&gt;pip &lt;span&gt;install&lt;/span&gt; virtualenvwrapper-win&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;创建虚拟环境命令&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;mkvirtualenv&lt;/span&gt; -p=&lt;span&gt;&quot;C:\Users\cherich\AppData\Local\Programs\Python\Python38\python.exe&quot;&lt;/span&gt; py38&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;进入虚拟环境，可以看到只有几个默认的 Python 库&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3518930957683742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vp6S2FuzHm8kU0XVg8HG6ZH6XX0fGibLeyJzzP5Zbibh7l9H7steJU4J2g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;这时可以测试一下代码，是否缺少相关依赖，比如我这个缺少 Pandas，openpyxl，依次按照 pip install 包名安装即可，非常重要的点：pyinstaller 必须重新安装，文件才会缩小。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpTThanZS2ZVNJPgLUG1oltWRjGTibs35g2dibOh00pbJ8eZ28klUyetuw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;上述操作完成后，打包就可以了，最后退出虚拟环境即可。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48583333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vp8ZDzf1JRq58iaCxsBt8IFbtU0wNkQbqXeX7iasL6AZgdfnIEnz17HD7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;退出虚拟环境&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;deactivate&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7233333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpo3NeURdBfLPFw4g8WPlnfkRLnZV516Rl1XVwtjkkaSdicsQiaaFhAxxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28372497824194953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpoI18FiaULEU2WA3H61AwWXRDr3CG6dI83FPCG7TEu3oZ5QlSKoIgFmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1149&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/nDMNE6lrvW4ILYMXKHic1wXxoJPz770vpNNm0XXiaF7v2grV3SibiaxT2ywMX9pxGVxzZibM1d3iaUwo4gdNAWrTzrjw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;整个自动化思路的实现就完成了，大家可以将整个流程套用到你现有的重复性工作中，在过程中有两个需要注意的点，如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽量不要用中文路径，要不会报些莫名其妙的错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导包是尽量避免使用 import * 导入不必要的包，节省打包和执行时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;让代码自动工作，省下来的时间，摸摸鱼，打打小游戏不好么~&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAZFUtS7ul9AAAAAstQy6ubaLX4KHWvLEZgBPEjoNIKQkcKL38zNPgMItZNPKHlAubkV7-S0UYRtwS&quot; data-url=&quot;https://findermp.video.qq.com/251/20350/stodownload?encfilekey=oibeqyX228riaCwo9STVsGLIBn9G5YG8Zn8TJDBKGnk134ADuIUzUGC5QYcNozJjyjpGXyiazvT8S0a5iczZ1Dffs8hrxBicXywUNWcvfliaxBHgpm1j4FViaR0Isy2KjUgIafUWxZoTHicl4B4&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=c11bbc13366dcfe9937a57d4b72811f1&amp;amp;token=x5Y29zUxcibCuT2yrrv6t29xRRmECZHsfjxpsgP89FCricksxKmWTQXic03s9plv7DPEQRfxl8vwJg&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/HhRfwkaJkMsy46GzicObuerV8fkhWrq1jNpRtXMDYS9xctKCYmx8RxQ/0&quot; data-username=&quot;v2_060000231003b20faec8c4ea8c1cc7d5cf03ec31b077f7655f41829a9665070aa58701f44b1f@finder&quot; data-nickname=&quot;Python数据之道&quot; data-desc=&quot;#图解Pandas，更多精彩内容戳👇 👇 👇 &quot; data-nonceid=&quot;676043902968276342&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;-------- End --------&lt;/strong&gt;&lt;/p&gt;&lt;/center&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10185185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gY6csrBUrKjcsCsjlCNM8uNZ460gDrRoibBj3ah24eibQzGQUTKaJicqquSuvpHyFNFebgx3ND5XicM7h2Xf1fcK1Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;精选内容&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI2NjY5NzI0NA==&amp;amp;action=getalbum&amp;amp;album_id=2293754972943122444#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gY6csrBUrKjcsCsjlCNM8uNZ460gDrRo0EccQCo33xXJXibQ8s6rTVq9oqCwZCg6gUAwtBLDMy3UlEkP4OWfiavQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI2NjY5NzI0NA==&amp;amp;action=getalbum&amp;amp;album_id=1370549534602133504&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gY6csrBUrKjcsCsjlCNM8uNZ460gDrRozgBJXwh7UfL4WvqfVXRic5yufab33ibgvmqbORkWvib1sxlib87zicNxnDA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section mstvisible=&quot;7&quot;&gt;&lt;section hm_fix=&quot;256:729&quot; mstvisible=&quot;8&quot;&gt;&lt;section mstvisible=&quot;9&quot;&gt;&lt;section mstvisible=&quot;10&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mstvisible=&quot;11&quot;&gt;&lt;p mstvisible=&quot;12&quot;&gt;&lt;span mstvisible=&quot;17&quot;&gt;&lt;strong msthash=&quot;3106773&quot; msttexthash=&quot;8512010&quot; mstvisible=&quot;13&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>