<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>86306c82390aba79cbb99783d7b166b8</guid>
<title>一文搞懂 Redis 架构演化之路</title>
<link>https://toutiao.io/k/cwwpjem</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：ryetan，腾讯 CSIG 后台开发工程师&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现如今 Redis 变得越来越流行，几乎在很多项目中都要被用到，不知道你在使用 Redis 时，有没有思考过，Redis 到底是如何稳定、高性能地提供服务的？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;我使用 Redis 的场景很简单，只使用单机版 Redis 会有什么问题吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我的 Redis 故障宕机了，数据丢失了怎么办？如何能保证我的业务应用不受影响？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么需要主从集群？它有什么优势？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是分片集群？我真的需要分片集群吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对 Redis 已经有些了解，肯定也听说过「&lt;strong&gt;数据持久化、主从复制、哨兵、分片集群&lt;/strong&gt;」这些概念，它们之间又有什么区别和联系呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你存在这样的疑惑，这篇文章，我会从 0 到 1，再从 1 到 N，带你一步步构建出一个稳定、高性能的 Redis 集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个过程中，你可以了解到 Redis 为了做到稳定、高性能，都采取了哪些优化方案，以及为什么要这么做？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;掌握了这些原理，这样平时你在使用 Redis 时，就能够做到「游刃有余」。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;从最简单的开始：单机版 Redis&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们从最简单的场景开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在你有一个业务应用，需要引入 Redis 来提高应用的性能，此时你可以选择部署一个单机版的 Redis 来使用，就像这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48787061994609165&quot; data-type=&quot;jpeg&quot; data-w=&quot;742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGf2bIHoQJwa2USVqbIB1ZoS2mgRicTh54IS5An8meQgYMzAW0b5Bu1EVA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个架构非常简单，你的业务应用可以把 Redis 当做缓存来使用，从 MySQL 中查询数据，然后写入到 Redis 中，之后业务应用再从 Redis 中读取这些数据，由于 Redis 的数据都存储在内存中，所以这个速度飞快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务体量并不大，那这样的架构模型基本可以满足你的需求。是不是很简单？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着时间的推移，你的业务体量逐渐发展起来了，Redis 中存储的数据也越来越多，此时你的业务应用对 Redis 的依赖也越来越重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;突然有一天，你的 Redis 因为某些原因宕机了，这时你的所有业务流量，都会打到后端 MySQL 上，MySQL 压力剧增，严重的话甚至会压垮 MySQL。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41043083900226757&quot; data-type=&quot;jpeg&quot; data-w=&quot;882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfMybvXyF0bGLb507IhrN4G0u9Hs1w6ib81vgK8qfoyhaDP9LOTArDtVw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时你应该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我猜你的方案肯定是，赶紧重启 Redis，让它可以继续提供服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，因为之前 Redis 中的数据都在内存中，尽管你现在把 Redis 重启了，之前的数据也都丢失了（假设没开持久化）。重启后的 Redis 虽然可以正常工作，但是由于 Redis 中没有任何数据，业务流量还是都会打到后端 MySQL 上，MySQL 的压力还是很大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有什么好的办法解决这个问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然 Redis 只把数据存储在内存中，那是否可以把这些数据也写一份到磁盘上呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果采用这种方式，当 Redis 重启时，我们把磁盘中的数据快速「&lt;strong&gt;恢复&lt;/strong&gt;」到内存中，这样它就可以继续正常提供服务了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，这是一个很好的解决方案，这个把内存数据写到磁盘上的过程，就是「数据持久化」。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据持久化：有备无患&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，你设想的 Redis 数据持久化是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1800356506238859&quot; data-type=&quot;jpeg&quot; data-w=&quot;1122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfexIvwLQlxD2tSdU3BI3jRrc7avCevVlEYCqqMp1CO1D84lO44eI1Wg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，数据持久化具体应该怎么做呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我猜你最容易想到的一个方案是，Redis 每一次执行写操作，除了写内存之外，同时也写一份到磁盘上，就像这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.170182841068917&quot; data-type=&quot;jpeg&quot; data-w=&quot;1422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfZL7Nh0uqeMzh53VicsZYW3mDaJicFNEiaqmqJzB4LHRASUUPpjGXFOic4g/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，这是最简单直接的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但仔细想一下，这个方案有个问题：&lt;strong&gt;客户端的每次写操作，既需要写内存，又需要写磁盘，而写磁盘的耗时相比于写内存来说，肯定要慢很多！这势必会影响到 Redis 的性能。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何规避这个问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我们需要分析写磁盘的细节问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，要把内存数据写到磁盘，其实是分 2 步的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;程序写文件的 PageCache（write）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把 PageCache 刷到磁盘（fsync）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体就是下图这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1483050847457627&quot; data-type=&quot;jpeg&quot; data-w=&quot;944&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfic7qyq7YDeMXBmXnLhK2rXupgia7TwxwMlP0gxYJicgIvYk4icrmVDmEUg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据持久化最粗暴的思路就是上面提到的那样，写完 Redis 内存后，同步写 PageCache + fsync 磁盘，当然，这样肯定因为磁盘拖慢整个写入速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何优化？也很简单，我们可以这样做：&lt;strong&gt;Redis 写内存由主线程来做，写内存完成后就给客户端返回结果，然后 Redis 用「另一个线程」去写磁盘，这样就可以避免主线程写磁盘对性能的影响。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1347708894878705&quot; data-type=&quot;jpeg&quot; data-w=&quot;742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGf6TmbZQRCTuicWF93t0093Cibml73rBawgiaicYeDQoDIQPwwficib4ibHRQfA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种持久化方案，其实就是我们经常听到的 Redis AOF（Append Only File）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis AOF 持久化提供了 3 种刷盘机制：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;appendfsync always：主线程同步 fsync&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;appendfsync no：由 OS fsync&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;appendfsync everysec：后台线程每间隔1秒 fsync&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决了数据实时持久化，我们还会面临另一个问题，数据实时写入 AOF，随着时间的推移，AOF 文件会越来越大，那使用 AOF 恢复时变得非常慢，这该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 很贴心地提供了 AOF rewrite 方案，俗称 AOF 「瘦身」，顾名思义，就是压缩 AOF 的体积。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 AOF 里记录的都是每一次写命令，例如执行 set k1 v1，set k1 v2，其实我们只关心数据的最终版本 v2 就可以了。AOF rewrite 正是利用了这个特点，在 AOF 体积越来越大时（超过设定阈值），Redis 就会定期重写一份新的 AOF，这个新的 AOF 只记录数据的最终版本就可以了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3887468030690537&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfcnpl8k9GzeEq8aiaEic2E7Tj8XJaVj7DDb1rhfia8oDs467F555d151vg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可以压缩 AOF 体积。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，我们可以换个角度，思考一下还有什么方式可以持久化数据？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时你就要结合 Redis 的使用场景来考虑了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回忆一下，我们在使用 Redis 时，通常把它用作什么场景？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把 Redis 当做缓存来用，意味着尽管 Redis 中没有保存全量数据，对于不在缓存中的数据，我们的业务应用依旧可以通过查询后端数据库得到结果，只不过查询后端数据的速度会慢一点而已，但对业务结果其实是没有影响的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这个特点，我们的 Redis 数据持久化还可以用「&lt;strong&gt;数据快照&lt;/strong&gt;」的方式来做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那什么是数据快照呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲，你可以这么理解：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;你把 Redis 想象成一个水杯，向 Redis 写入数据，就相当于往这个杯子里倒水&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此时你拿一个相机给这个水杯拍一张照片，拍照的这一瞬间，照片中记录到这个水杯中水的容量，就是水杯的数据快照&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3374045801526718&quot; data-type=&quot;jpeg&quot; data-w=&quot;1310&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGficdjvjbIRwgoGEpV8icq5llc2psJbPrIZNuM5S1OvMicxTwMDqnVmpdwg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，Redis 的数据快照，是记录某一时刻下 Redis 中的数据，然后只需要把这个数据快照写到磁盘上就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的优势在于，只在需要持久化时，把数据「&lt;strong&gt;一次性&lt;/strong&gt;」写入磁盘，其它时间都不需要操作磁盘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这个方案，我们可以「&lt;strong&gt;定时&lt;/strong&gt;」给 Redis 做数据快照，把数据持久化到磁盘上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3835021707670043&quot; data-type=&quot;jpeg&quot; data-w=&quot;1382&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfVx38iaH8TDibhg6PzExe9BDjac0wHUicjmFQvDVnUIc0NEYZxMXl6tfvg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案就是我们经常听到的 Redis RDB，RDB 采用「&lt;strong&gt;定时快照&lt;/strong&gt;」的方式进行数据持久化，它的优点是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;持久化文件体积小（二进制 + 压缩）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写盘频率低（定时写入）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点也很明显，因为是定时持久化，数据肯定没有 AOF 实时持久化完整，如果你的 Redis 只当做缓存，对于丢失数据不敏感（可从后端的数据库查询），那这种持久化方式是非常合适的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果让你来选择持久化方案，你可以这样选择：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;业务对于数据丢失不敏感，选 RDB&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务对数据完整性要求比较高，选 AOF&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了 RDB 和 AOF，我们再进一步思考一下，有没有什么办法，&lt;strong&gt;既可以保证数据完整性，还能让持久化文件体积更小，恢复更快呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾一下我们前面讲到的，RDB 和 AOF 各自的特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RDB 以二进制 + 数据压缩方式存储，文件体积小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AOF 记录每一次写命令，数据最全&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可否利用它们各自的优势呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然可以，这就是 Redis 的「&lt;strong&gt;混合持久化&lt;/strong&gt;」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想数据完整性更高，肯定就不能只用 RDB 了，重点还是要放在 AOF 优化上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体来说，当 AOF 在做 rewrite 时，&lt;strong&gt;Redis 先以 RDB 格式在 AOF 文件中写入一个数据快照，再把在这期间产生的每一个写命令，追加到 AOF 文件中。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 RDB 是二进制压缩写入的，这样 AOF 文件体积就变得更小了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43115124153498874&quot; data-type=&quot;jpeg&quot; data-w=&quot;886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfyN2Is1qxibpyLdQ3JXZ7YuO6BsJCMxA0bibiagaw8OiaeTA2MLlStMahJQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 AOF 体积进一步压缩，你在使用 AOF 恢复数据时，这个恢复时间就会更短了！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Redis 4.0 以上版本才支持混合持久化。&lt;/p&gt;&lt;p&gt;注意：混合持久化是对 AOF rewrite 的优化，这意味着使用它必须基于 AOF + AOF rewrite。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么一番优化，你的 Redis 再也不用担心实例宕机了，当发生宕机时，你就可以用持久化文件快速恢复 Redis 中的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这样就没问题了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细想一下，虽然我们已经把持久化的文件优化到最小了，但在&lt;strong&gt;恢复数据时依旧是需要时间&lt;/strong&gt;的，在这期间你的业务应用无法提供服务，这怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个实例宕机，只能用恢复数据来解决，那我们是否可以部署多个 Redis 实例，然后让这些实例数据保持实时同步，这样当一个实例宕机时，我们在剩下的实例中选择一个继续提供服务就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，这个方案就是接下来要讲的「主从复制：多副本」。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;主从复制：多副本&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以部署多个 Redis 实例，架构模型就变成了这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6226415094339622&quot; data-type=&quot;jpeg&quot; data-w=&quot;742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfUDNJcmlHSicKIwGwuCG27c6BNn1VlTVgvYGDicibR3xnvvKCWMcPC7FcA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这里把实时读写的节点叫做 master，另一个实时同步数据的节点叫做 slave。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用多副本的方案，它的优势是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缩短不可用时间&lt;/strong&gt;：master 发生宕机，我们可以手动把 slave 提升为 master 继续提供服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;提升读性能&lt;/strong&gt;：让 slave 分担一部分读请求，提升应用的整体性能&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5956873315363881&quot; data-type=&quot;jpeg&quot; data-w=&quot;742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfOAib2MyPFqGDS1CkLKmJX37auXusx90bgDZpHqQTgibAiccCKK2KYTibHQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案不错，不仅节省了数据恢复的时间，还能提升性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但它的问题在于：&lt;strong&gt;当 master 宕机时，我们需要「手动」把 slave 提升为 master，这个过程也是需要花费时间的。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然比恢复数据要快得多，但还是需要人工介入处理。一旦需要人工介入，就必须要算上人的反应时间、操作时间，所以，在这期间你的业务应用依旧会受到影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们是否可以把这个切换的过程，变成自动化？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;哨兵：故障自动切换&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想自动切换，肯定不能依赖人了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我们可以引入一个「观察者」，让这个观察者去实时监测 master 的健康状态，这个观察者就是「哨兵」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体如何做？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;哨兵每间隔一段时间，询问 master 是否正常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;master 正常回复，表示状态正常，回复超时表示异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哨兵发现异常，发起主从切换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3939393939393939&quot; data-type=&quot;jpeg&quot; data-w=&quot;1122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGf5dM6wPrTM99Sxc89AAnv7EP8Xt3ZicO5AUSqV9TYy0a3EoH0m01lL1g/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个方案，就不需要人去介入处理了，一切就变得自动化了，是不是很爽？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这里还有一个问题，如果 master 状态正常，但这个哨兵在询问 master 时，它们之间的网络发生了问题，那这个哨兵可能会「&lt;strong&gt;误判&lt;/strong&gt;」。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3939393939393939&quot; data-type=&quot;jpeg&quot; data-w=&quot;1122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfOncDy2S8VWedzP3UiaK1vyBKHJ8CE9LCd419xiaicqsbepib2RJBShXqtQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题怎么解决？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然一个哨兵会误判，那我们可以部署多个哨兵，让它们分布在不同的机器上，让它们一起监测 master 的状态，流程就变成了这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4533762057877814&quot; data-type=&quot;jpeg&quot; data-w=&quot;1244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfclksWF0yEYsguAc1UPbDt6s92dUsZ9s5hrTpqKocq2LIS4FLs4s0hw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;多个哨兵每间隔一段时间，询问 master 是否正常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;master 正常回复，表示状态正常，回复超时表示异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一旦有一个哨兵判定 master 异常（不管是否是网络问题），就询问其它哨兵，如果多个哨兵（设置一个阈值）都认为 master 异常了，这才判定 master 确实发生了故障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多个哨兵经过协商后，判定 master 故障，则发起主从切换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们用多个哨兵互相协商来判定 master 的状态，这样，就可以大大降低误判的概率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哨兵协商判定 master 异常后，这里还有一个问题：&lt;strong&gt;由哪个哨兵来发起主从切换呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是，选出一个哨兵「领导者」，由这个领导者进行主从切换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题又来了，这个领导者怎么选？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想象一下，在现实生活中，选举是怎么做的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，投票。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在选举哨兵领导者时，我们可以制定这样一个选举规则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每个哨兵都询问其它哨兵，请求对方为自己投票&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个哨兵只投票给第一个请求投票的哨兵，且只能投票一次&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;首先拿到超过半数投票的哨兵，当选为领导者，发起主从切换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个选举的过程就是我们经常听到的：分布式系统领域中的「&lt;strong&gt;共识算法&lt;/strong&gt;」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是共识算法？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在多个机器部署哨兵，它们需要共同协作完成一项任务，所以它们就组成了一个「分布式系统」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统领域，多个节点如何就一个问题达成共识的算法，就叫共识算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个场景下，多个哨兵共同协商，选举出一个都认可的领导者，就是使用共识算法完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个算法还规定节点的数量必须是奇数个，这样可以保证系统中即使有节点发生了故障，剩余超过「半数」的节点状态正常，依旧可以提供正确的结果，也就是说，这个算法还兼容了存在故障节点的情况。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;共识算法在分布式系统领域有很多，例如 Paxos、Raft，哨兵选举领导者这个场景，使用的是 Raft 共识算法，因为它足够简单，且易于实现。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，到这里我们先小结一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的 Redis 从最简单的单机版，经过数据持久化、主从多副本、哨兵集群，这一路优化下来，你的 Redis 不管是性能还是稳定性，都越来越高，就算节点发生故障，也不用担心了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 以这样的架构模式部署，基本上就可以稳定运行很长时间了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着时间的发展，你的业务体量开始迎来了爆炸性增长，此时你的架构模型，还能够承担这么大的流量吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一起来分析一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据怕丢失&lt;/strong&gt;：持久化（RDB/AOF）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;恢复时间久&lt;/strong&gt;：主从副本（副本随时可切）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;手动切换时间长&lt;/strong&gt;：哨兵集群（自动切换）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;读存在压力&lt;/strong&gt;：扩容副本（读写分离）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;写存在压力&lt;/strong&gt;：&lt;strong&gt;一个 mater 扛不住怎么办？&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见，现在剩下的问题是，当写请求量越来越大时，一个 master 实例可能就无法承担这么大的写流量了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想完美解决这个问题，此时你就需要考虑使用「分片集群」了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分片集群：横向扩展&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是「分片集群」？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲，一个实例扛不住写压力，那我们是否可以部署多个实例，然后把这些实例按照一定规则组织起来，把它们当成一个整体，对外提供服务，这样不就可以解决集中写一个实例的瓶颈问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，现在的架构模型就变成了这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.819935691318328&quot; data-type=&quot;jpeg&quot; data-w=&quot;1244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfW8c2ia3Ig1KKEITsZjsM6MU6IGmKltNARp3wuVNqUhrI7KLAl70vwLg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在问题又来了，这么多实例如何组织呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们制定规则如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每个节点各自存储一部分数据，所有节点数据之和才是全量数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;制定一个路由规则，对于不同的 key，把它路由到固定一个实例上进行读写&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据分多个实例存储，那寻找 key 的路由规则需要放在客户端来做，具体就是下面这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.819935691318328&quot; data-type=&quot;jpeg&quot; data-w=&quot;1244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfhxfsHhicH5VBkA3SLgTP8m1ibApEG1CNALcezbYEX5wQdcJEcQdTyCFw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案也叫做「客户端分片」，这个方案的缺点是，&lt;strong&gt;客户端需要维护这个路由规则，也就是说，你需要把路由规则写到你的业务代码中。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何做到不把路由规则耦合在客户端业务代码中呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续优化，我们可以在客户端和服务端之间增加一个「中间代理层」，这个代理就是我们经常听到的 Proxy，路由转发规则，放在这个 Proxy 层来维护。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，客户端就无需关心服务端有多少个 Redis 节点了，只需要和这个 Proxy 交互即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Proxy 会把你的请求根据路由规则，转发到对应的 Redis 节点上，而且，当集群实例不足以支撑更大的流量请求时，还可以横向扩容，添加新的 Redis 实例提升性能，这一切对于你的客户端来说，都是透明无感知的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界开源的 Redis 分片集群方案，例如 Twemproxy、Codis 就是采用的这种方案。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6995412844036697&quot; data-type=&quot;jpeg&quot; data-w=&quot;872&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGf9JC3WG8MDkqr02L875Tq8rTSnPo5GXtjlmrV8wrERTyElPUUwoRxDg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案的优点在于，客户端无需关心数据转发规则，只需要和 Proxy 打交道，客户端像操作单机 Redis 那样去操作后面的集群，简单易用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构演进到目前为止，路由规则无论是客户端来做，还是 Proxy 来做，都是「社区」演进出来的分片解决方案，它们的特点是集群中的 Redis 节点，都不知道对方的存在，只有客户端或 Proxy 才会统筹数据写到哪里，从哪里读取，而且它们都依赖哨兵集群负责故障自动切换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说我们其实就是把多个孤立的 Redis 节点，自己组合起来使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 在 3.0 其实就推出了「官方」的 Redis Cluster 分片方案，但由于推出初期不稳定，所以用的人很少，也因此业界涌现出了各种开源方案，上面讲到的 Twemproxy、Codis 分片方案就是在这种背景下诞生的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但随着 Redis Cluster 方案的逐渐成熟，业界越来越多的公司开始采用官方方案（毕竟官方保证持续维护，Twemproxy、Codis 目前都逐渐放弃维护了），Redis Cluster 方案比上面讲到的分片方案更简单，它的架构如下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.509493670886076&quot; data-type=&quot;jpeg&quot; data-w=&quot;1264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGfSUPuD1vn3Mvczd0dYBh6iaMYXzeQZ9zefgMzSOVutia2Vhib86qRAF3bw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redis Cluster 无需部署哨兵集群，集群内 Redis 节点通过 Gossip 协议互相探测健康状态，在故障时可发起自动切换。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，关于路由转发规则，也不需要客户端自己编写了，Redis Cluster 提供了「配套」的 SDK，只要客户端升级 SDK，就可以和 Redis Cluster 集成，SDK 会帮你找到 key 对应的 Redis 节点进行读写，还能自动适配 Redis 节点的增加和删除，业务侧无感知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然省去了哨兵集群的部署，维护成本降低了不少，但对于客户端升级 SDK，对于新业务应用来说，可能成本不高，但对于老业务来讲，「升级成本」还是比较高的，这对于切换官方 Redis Cluster 方案有不少阻力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，各个公司有开始自研针对 Redis Cluster 的 Proxy，降低客户端的升级成本，架构就变成了这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34328358208955223&quot; data-type=&quot;jpeg&quot; data-w=&quot;1206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvav4rRaCTiaalHHTHiaLsUuaGftQcic0A6x7lmhMdBroiba4X25Eicia83r1gdEDia4Qw3JILopUibM1kvtdAA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，客户端无需做任何变更，只需把连接地址切到 Proxy 上即可，由 Proxy 负责转发数据，以及应对后面集群增删节点带来的路由变更。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，业界主流的 Redis 分片架构已经成型，当你使用分片集群后，对于未来更大的流量压力，也都可以从容面对了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下，我们是如何从 0 到 1，再从 1 到 N 构建一个稳定、高性能的 Redis 集群的，从这之中你可以清晰地看到 Redis 架构演进的整个过程。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据怕丢失&lt;/strong&gt; -&amp;gt; 持久化（RDB/AOF）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;恢复时间久&lt;/strong&gt; -&amp;gt; 主从副本（副本随时可切）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;故障手动切换慢&lt;/strong&gt; -&amp;gt; 哨兵集群（自动切换）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;读存在压力&lt;/strong&gt; -&amp;gt; 扩容副本（读写分离）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;写存在压力/容量瓶颈&lt;/strong&gt; -&amp;gt; 分片集群&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;分片集群社区方案&lt;/strong&gt; -&amp;gt;  Twemproxy、Codis（Redis 节点之间无通信，需要部署哨兵，可横向扩容）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;分片集群官方方案&lt;/strong&gt; -&amp;gt;  Redis Cluster （Redis 节点之间 Gossip 协议，无需部署哨兵，可横向扩容）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;业务侧升级困难&lt;/strong&gt; -&amp;gt; Proxy + Redis Cluster（不侵入业务侧）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们的 Redis 集群才得以长期稳定、高性能的为我们的业务提供服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望这篇文章可以帮你更好的理解 Redis 架构的演进之路。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者介绍：&lt;/p&gt;&lt;p&gt;ryetan（谭帅），CSIG 专有云平台研发团队，负责 TCS/TCE 容器化 Redis 研发工作，对 Redis 架构有过深入理解。&lt;/p&gt;&lt;p&gt;如有任何 Redis 问题，欢迎与我交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d792738a386f693036a31cacc35d4891</guid>
<title>坐拥最大的高速缓存，Facebook 如何保证缓存一致性？</title>
<link>https://toutiao.io/k/93fubbq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwOTIxNDQ3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YRIaicYx5pzj5Cxwick8DamnOgbTJu96QTibKyHEDZt1815yOV1r27oZ6HgoYTEYWYLRz4jIV4iasHgg/0?wx_fmt=png&quot; data-nickname=&quot;dbaplus社群&quot; data-alias=&quot;dbaplus&quot; data-signature=&quot;围绕Database、BigData、AIOps的企业级专业社群。资深大咖、技术干货，每天精品原创文章推送，每周线上技术分享，每月线下技术沙龙，每季度Gdevops&amp;amp;DAMS行业大会.&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;缓存有助于减少延迟，提高重读工作负载的可扩展性，并且节省成本。实际上缓存是无处不在的，它也在你的手机和你的浏览器中运行。例如，CDN和DNS本质上是地理复制的缓存。正是由于许多缓存在幕后工作，你现在才能阅读这篇文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Phil Karlton有句名言：“计算机科学中只有两个难题：缓存失效和命名。”如果你曾经处理过的无效缓存，那么你很有可能遇到过缓存不一致这个恼人的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Meta，我们运营着世界上最大的高速缓存，包括TAO和Memcache。多年来，我们将TAO的缓存一致性提高了一个档次，从99.9999%（六个九）提高到99.99999999%（十个九）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当涉及到缓存无效时，我们相信我们现在有一个有效的解决方案来弥补理论和实践之间的差距。这篇博文中的原则和方法广泛适用于大多数（如果不是所有）的缓存服务。无论你是在Redis中缓存Postgres数据，还是将分散数据具象化，都是如此。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们希望能帮助减少工程师必须处理的缓存失效问题，并帮助增强缓存的一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、定义缓存失效和缓存一致性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据定义，缓存并不是你数据的真实来源（例如数据库）。缓存失效描述的是当真实源中的数据发生变化时，主动将陈旧的缓存条目失效的过程。如果缓存失效处理不当，就会在缓存中无限期地保留一个不一致的值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存失效涉及到一个必须由缓存自身以外的程序来执行的动作。一些程序（例如，客户端或公共/子系统）需要告诉缓存其中数据发生了变化。仅仅依靠TTL来保持有效性的缓存，不在本文讨论范围之内。在这篇文章的其余部分，我们将假设存在缓存失效操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么这个看似简单的过程在计算机科学中被认为是个困难的问题？下面是个简单的例子，说明如何引入缓存不一致的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;180&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31203703703703706&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YBR28Kp4hTJmt9yLmmXEDHw7ZzK587bNOJoWBMia2NIt2ScCeHGAWxfsvm0XnKc6aW3sR5CZ5WY3A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存首先尝试从数据库中填充x。但是在 &quot;x=42 &quot;到达缓存主机之前，有人将x设置为43。缓存失效事件 &quot;x=43 &quot;首先到达缓存主机，将x设置为43。&quot;x=42 &quot;到达了缓存，将x设置为42。现在数据库中&quot;x=43 &quot;，而缓存中 &quot;x=42 &quot;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有很多方法来解决这个问题，其中之一就是维护版本字段。这样我们就可解决冲突，因为旧的数据不应该覆盖新的数据。但是，如果缓存条目 &quot;x=43 @version=2 &quot;在 &quot;x=42 &quot;到达之前就失效了呢？在这种情况下，缓存数据依然是错误的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存失效的挑战不仅来自于失效协议的复杂性，还来自于监控缓存一致性和如何确定缓存不一致的原因。设计一个一致的缓存与操作一个一致的缓存有很大不同，就像设计Paxos协议与构建在生产中实际运行的Paxos一样，都有很大区别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、我们为什么要关心缓存的一致性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们必须解决复杂的缓存失效问题吗？在某些情况下，缓存的不一致性几乎和数据库数据丢失一样严重。从用户的角度来看，它甚至和数据丢失没有区别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;让我们来看看另一个关于缓存不一致如何导致脑裂的例子。Meta公司使用消息将其从用户在主存储数据的映射到TAO中。它经常进行移动，以保证用户可以就近访问。每次你向某人发送消息时，系统都会查询TAO，以找到消息的存储位置。许多年前，当TAO的一致性较差时，一些TAO副本在重新移动后会出现不一致的数据，如下例所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想象一下，在将Alice的主消息存储从区域2切换到区域1后，Bob和Mary，都向Alice发送了消息。当Bob向Alice发送消息时，系统查询了靠近Bob居住地的区域的TAO副本，并将消息发送到区域1。当Mary向Alice发送消息时，系统查询了靠近Mary居住地的地区的TAO副本，命中了不一致的TAO副本，并将消息发送到了地区2。Bob和Mary将他们的消息发送到不同的区域，而两个区域都没有爱丽丝消息的完整副本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;286&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49537037037037035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YBR28Kp4hTJmt9yLmmXEDHMlib481xuHicGLRMV8GchcJ70RJXD9SDm2Rqic6A8ib6kdCRoAnvX10OicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、缓存失效模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;241&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41759259259259257&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YBR28Kp4hTJmt9yLmmXEDHAl4ktpUJOSv3z8OHJpH5WWPrlVAql4BQE9KkyGnXN3HFbicpIuUvNMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;了解缓存失效的困难之处尤其具有挑战性。让我们从一个简单的模型开始。缓存的核心是一个有状态的服务，它将数据存储在一个可寻址的存储介质中。分布式系统本质上是一种状态机。如果每个状态转换都能正确执行，我们就会有一个按预期工作的分布式系统。否则，系统就会问题。所以，关键的问题是：对于有状态的服务，什么在改数据？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;284&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49074074074074076&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YBR28Kp4hTJmt9yLmmXEDHf5CjMtxhXicicZlFt8yYpFnIYJG4oBT7MI3IOTacoWTP38QGQ8qaGZicw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;静态缓存有一个非常简单的缓存模型（例如，简化的CDN接近这个模型）。数据是不可改变的。没有缓存主动失效。对于数据库来说，数据只有在写入（或复制）时才会发生变化。我们通常对数据库的每一个状态变化都有日志。每当发生异常时，日志可以帮助我们了解发生了什么，缩小问题的范围，并找出问题所在。构建容错的分布式数据库（这已经很困难了），有其独特的挑战。这些只是简化的模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;334&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5777777777777777&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YBR28Kp4hTJmt9yLmmXEDH92COg15ickr8fnRL2yY1EgRXLFolt6f9RaGVibmDaCfUyjfAxAV5iaSYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于像TAO和Memcache这样的动态缓存，数据在读取（缓存填充）和写入（缓存失效）的路径上都会发生变化。这种组合使得多竞态条件成为可能，而缓存失效则是一个困难的问题。缓存中的数据是不持久的，这意味着有时候对解决冲突很重要的版本信息会被清除出去。结合所有这些特点，动态缓存产生的竞态条件超出了我们的想象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而且，记录和跟踪每一个缓存状态的变化几乎是不现实的。缓存经常被引入来扩展重读的工作负载。这意味着大部分的缓存状态变化都来自缓存填充路径。以TAO为例。它每天提供超过四亿次的查询。即使缓存命中率达到99%，我们每天也要进行超过10万亿次的缓存填充。记录和追踪所有的缓存状态变化会使一个重读的缓存工作负载变成一个极重写的日志系统工作负载。调试一个分布式系统已经带来了巨大的挑战。调试一个没有缓存状态变化的日志或追踪的分布式系统，基本是不可能的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽管有这些挑战，我们还是提高了TAO的缓存一致性，这些年来从99.9999%提高到99.99999999%。在文章的其余部分，我们将解释我们是如何做到的，并强调一些未来的工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、针对一致性的可观察性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决缓存失效和缓存一致性问题，第一步涉及测量。我们要测量高速缓存的一致性，并在高速缓存中出现不一致的条目时发出警报。测量不能包含任何假阳性。人类的大脑可以很容易地调出噪音。如果存在任何误报，人们很快就会学会忽略它，而这个测量也变得毫无用处。我们还需要测量是精确的，因为我们谈论的是测量超过10个九的一致性。如果一个修正已经落地，我们要保证我们可以定量地测量它带来的改进。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;319&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5518518518518518&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YBR28Kp4hTJmt9yLmmXEDHqy0SGWhKft6qhLvnpRFZjCdzPNPHIWUwOgrY3xHkUhePicsFyZRib2aw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决测量问题，我们建立了一个名为Polaris的服务。对于一个有状态的服务中的任何异常，只有当客户能够以这种或那种方式观察到它，它才是一个异常。否则，它就根本不重要。基于这一原则，Polaris 专注于测量违反客户可观察不变量的情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在高层次上，Polaris作为客户端与有状态的服务进行交互，并且不假设了解服务内部。这使得它是通用的。Meta有几十个服务使用Polaris。&quot;缓存最终应该与数据库一致 &quot;是Polaris监控的一个典型的客户端可观察到的不变因素，特别是在异步缓存失效的情况下。在这种情况下，Polaris假装是一个缓存服务器并接收缓存失效事件。例如，如果Polaris收到一个无效事件，说 &quot;x=4 @version 4&quot;，它就会作为客户查询所有的缓存副本，以验证是否有任何违反该不变性的情况发生。如果一个缓存副本返回 &quot;x=3 @version 3&quot;，Polaris将其标记为不一致，并重新等待样本，以便以后针对同一目标缓存主机进行检查。Polaris在某些时间尺度上报告不一致，例如一分钟、五分钟或十分钟。如果这个样本在一分钟后仍然显示为不一致，Polaris就将其报告为相应时间尺度的不一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种多时间尺度的设计不仅允许Polaris在内部存在多个队列，以有效地实现回退和重试，而且对于防止产生误报也是至关重要的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来看看一个更有趣的例子。假设Polaris收到一个 &quot;x=4 @version 4 &quot;的无效信息。但是当它查询一个缓存副本时，得到的答复是x不存在。目前还不清楚Polaris是否应该将此作为一个不一致的标记。有可能x在版本3的时候是不存在的，版本4的写入是对key的最新写入，而这种情况确实是缓存不一致。也有可能是第5个版本的操作删除了x，也许Polaris只是看到了失效事件中的数据更新的视图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了区分这两种情况，我们需要绕过缓存，检查数据库中的内容。绕过缓存的查询是非常密集的运算。它们也会使数据库面临风险，因为保护数据库和扩展重读工作负载是缓存最常见的用例之一。因此，我们不能绕过缓存发送太多的查询。Polaris通过延迟执行计算密集型操作来解决这个问题，直到不一致的样本跨越报告时间尺度（如一分钟或五分钟）。真正的缓存不一致和对同一key的竞争写操作是很少的。因此，在它跨越下一个时间尺度边界之前才进行一致性检查有助于消除执行大部分数据库查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们还在Polaris发给缓存服务器的查询中加入了一个特殊的标志。因此，Polaris会知道目标缓存服务器是否已经看到并处理了缓存失效事件。这一点信息使Polaris能够区分瞬时的缓存不一致（通常由复制/验证滞后引起）和 &quot;永久 &quot;的缓存不一致(旧版本还无限期地存在于缓存中)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Polaris也提供观测指标，如“N个9的缓存写入在M分钟内是一致的”。在文章的开头，我们提到，通过一项改进，我们将TAO的缓存一致性从99.9999%提高到99.99999999%。Polaris提供了5分钟时间尺度的指标。换句话说，99.99999999%的缓存写入在5分钟内是一致的。在TAO中5分钟内，100亿次缓存写入中不到1次会出现不一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们将Polaris部署为一个单独的服务，这样它就可以独立于生产服务及其工作负载进行扩展。如果我们想测量到更多的数据，我们可以只增加Polaris的吞吐量或在更长的时间窗口上执行聚合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、一致性追踪&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在大多数图中，我们用一个简单的盒子来表示缓存。在现实中，省略了许多依赖关系和数据流之后，看起来可能像这样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;314&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5425925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YBR28Kp4hTJmt9yLmmXEDHGpqSafPNNjCq7qI8SChRibcwWRiclfnl4icDhSHZibeaxCOrC7TPVuBEFg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存可以在不同的时间点从不同的上游填充，这些上游可以是在同一region内或跨region。升级、分片移动、故障恢复、网络分区和硬件故障都有可能触发导致缓存不一致的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而，正如前面提到的，记录和追踪每一个缓存数据的变化是不切实际的。但是，如果我们只在缓存不一致的地方和时候（或者缓存失效可能被错误地处理）记录和跟踪缓存的突变，会怎么样呢？在这个庞大而复杂的分布式系统中，任何组件的缺陷都可能导致缓存不一致，是否有可能找到一个引入大部分（如果不是全部）缓存不一致的地方？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的任务变成了寻找一个简单的解决方案来帮助我们管理这种复杂性。我们想从单个缓存服务器的角度来评估整个缓存一致性问题。最后，不一致的问题必须在一个缓存服务器上出现。从它的角度来看，它只关心几个方面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;它是否收到了失效信息？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;它是否正确地处理了这个失效信息？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;之后缓存是否变得不一致了？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;284&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49074074074074076&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YBR28Kp4hTJmt9yLmmXEDHiapMpWNiadhNvyueL5lGBHknnGGibiajJzKg4x8zKIIicyGibAY5b0bBEetA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是我们在文章开头解释的那个例子，现在用一个时空图来说明。如果我们把注意力集中在底部的缓存时间轴上，我们可以看到在客户端写完之后，有一个窗口，在这个窗口中，失效和缓存填充都在竞争更新缓存。一段时间后，缓存将处于静止状态。在这种状态下，缓存的填充仍然会大量发生，但从一致性的角度来看，由于没有写入，它已经沦为一个静态的缓存，所以它的意义不大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们建立了一个有状态的库，记录和跟踪这个小的紫色窗口中的缓存突变，在这个窗口中，所有相关的复杂交互都会引发导致缓存不一致的问题。它涵盖了缓存的过期，甚至没有日志也能告诉我们是否无效事件从未到达。它被嵌入到几个主要的缓存服务中，并贯穿于整个失效管道。它缓冲了最近修改的数据索引，用于确定后续的缓存状态变化是否应该被记录下来。它还支持代码追踪，所以我们会知道每个被追踪查询的确切代码路径。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种方法帮助我们发现并修复了许多缺陷。它为诊断缓存的不一致提供了一个系统性的、更可扩展的方法。事实证明，它非常有效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、我们今年发现并修复的一个线上错误&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;215&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37222222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YBR28Kp4hTJmt9yLmmXEDHoRBfT6YU2mVeWb6Pwic9GejIWpZD0cJAibwvTXgeKF8dViau7hl5reyrQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在一个系统中，我们对每条数据进行了版本排序和冲突解决。在这种情况下，我们在缓存中观察到 &quot;metadata=0 @version4&quot;，而数据库中包含 &quot;metadata=1 @version4&quot;。缓存无限期地保持不一致。这种状态应该是不可能的。你会如何处理这个问题？如果我们能得到导致最终不一致状态的每一个步骤的完整时间线，那该有多好？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一致性追踪正好提供了我们需要的时间线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;218&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37777777777777777&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YBR28Kp4hTJmt9yLmmXEDH7q7ibzmdDnj0BYeqMnu64s8ScZYJEXZbWQU0zcbmRTKkicc72XKF2PAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在系统中，一个非常罕见的操作以事务方式更新了底层数据库的两个表—元数据表和版本表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据一致性追踪，我们知道发生了以下情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）缓存试图添加版本数据和元数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）在第一轮中，缓存首先填充了旧的元数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）接下来，一个写事务以原子方式更新了元数据表和版本表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）在第二轮中，缓存写入了新的版本数据。这里，缓存填充操作与数据库事务交错进行。因为竞态窗口很小，所以这种情况很少发生。你可能会想，“这就是bug”。但是实际上到目前为止，一切都按预期进行，因为缓存失效应该可以把缓存恢复一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5）稍后，在尝试将缓存项更新为新元数据和新版本时，出现了缓存无效。这几乎总是有效的，但这次没有。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6）缓存失效在缓存主机上遇到了一个罕见的瞬时错误，这触发了错误处理代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7）错误处理程序将该条目删除。伪代码看起来是这样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;drop_cache(key, version);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果条目的版本低于指定的版本，则将其放入缓存。但是，不一致的缓存项包含最新版本。所以这段代码什么也没做，将过时的元数据无限期地留在缓存中。这就是bug。我们在这里把这个例子简化了很多。实际的bug甚至更加复杂，涉及到数据库复制和跨区域通信。只有当以上所有的步骤都发生，并且以这个顺序具体发生时，这个bug才会被触发。不一致的情况很少出现。该错误隐藏在交互操作和瞬时错误背后的错误处理代码中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;许多年前，如果有人对代码和服务了如指掌并且他们足够幸运的话，要花几周时间才能找到这种错误的根本原因。在这种情况下，Polaris发现了异常情况，并立即发出警报。通过一致性追踪的信息，值班工程师花了不到30分钟就可以找到这个错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;七、未来的缓存一致性工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们已经分享了我们如何用一种通用的、系统的、可扩展的方法来增强我们的缓存一致性。展望未来，我们想让我们所有缓存的一致性在物理上尽可能地接近100%。分散的二级指数的一致性带来了一个有趣的挑战。我们也在测量并有目的地改善读取时的缓存一致性。最后，我们正在为分布式系统建立高水平的一致性API，想想针对分布式系统的C++的std::memory_order。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85988&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;原文链接&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;Cache made consistent: Meta’s cache invalidation solution&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;https://engineering.fb.com/2022/06/08/core-data/cache-invalidation/?continueFlag=5d7598b8068e4850d16d3bc686805488&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作者丨Lu Pan&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源丨公众号：高可用架构（ID：ArchNotes）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dbaplus社群欢迎广大技术人员投稿，投稿邮箱：editor@dbaplus.cn&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c25ed38036b35642c0c89c3e16a25bc3</guid>
<title>Redis 内存优化神技，小内存保存大数据</title>
<link>https://toutiao.io/k/u7j6uun</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;这次跟大家分享一些优化神技，当你面试或者工作中你遇到如下问题，那就使出今天学到的绝招，一招定乾坤！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何用更少的内存保存更多的数据？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们应该从 Redis 是如何保存数据的原理展开，分析键值对的存储结构和原理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从而继续延展出每种数据类型底层的数据结构，针对不同场景使用更恰当的数据结构和编码实现更少的内存占用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了保存数据， Redis 需要先申请内存，数据过期或者内存淘汰需要回收内存，从而拓展出内存碎片优化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，说下 key、value 使用规范和技巧、 Bitmap 等高阶数据类型，运用这些技巧巧妙解决有限内存去存储更多数据难题……&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这一套组合拳下来直接封神。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主要优化神技如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;键值对优化；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;小数据集合的编码优化；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用对象共享池；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用 Bit 比特位或 byte 级别操作&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用 hash 类型优化；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;内存碎片优化；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用 32 位的 Redis。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在优化之前，我们先掌握 Redis 是如何存储数据的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Redis 如何存储键值对&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 以 redisDb 为中心存储，Redis 7.0 源码&lt;/span&gt;&lt;span&gt;在 https://github.com/redis/redis/blob/7.0/src/server.h：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38470873786407767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtfNp8LYGJVwpAauU9m9PfbkG3zG6p75jvvT2Op9D74RUGnV9wgko6nbzErCmATI6FAyL9453tSCmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1648&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;redisDb&lt;/span&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;dict&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：最重要的属性之一，就是靠这个定义了保存了对象数据键值对，dcit 的底层结构是一个哈希表；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;expires&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：保存着所有 key 的过期信息；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;blocking_keys&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 和 &lt;strong&gt;ready_keys&lt;/strong&gt; 主要为了实现 BLPOP 等阻塞命令；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;watched_keys &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;用于实现 watch 命令，记录正在被 watch 的一些 key，与事务相关；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;id&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 为当前数据库的 id。&lt;/span&gt;&lt;span&gt;Redis 支持单个服务多数据库，默认有1 6 个；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;clusterSlotToKeyMapping&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Cluster 模式下，存储 key 与哈希槽映射关系的数组。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 使用「dict」结构来保存所有的键值对（key-value）数据，这是一个全局哈希表，所以对 key 的查询能以 O(1) 时间得到。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所谓哈希表，我们可以类比 Java 中的 HashMap，其实就是一个数组，数组的每个元素叫做哈希桶。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;dict 结构如下，源码在 https://github.com/redis/redis/blob/7.0/src/dict.h：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;struct dict {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 特定类型的处理函数&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    dictType *type;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  // 两个全局哈希表指针数组，与渐进式 rehash 有关&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    dictEntry **ht_table[2];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 记录 dict 中现有的数据个数。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    unsigned long ht_used[2];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   // 记录渐进式 rehash 进度的标志， -1 表示当前没有执行 rehash &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    long rehashidx;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   // 小于 0 表示 rehash 暂停&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    int16_t pauserehash;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    signed char ht_size_exp[2];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;dictType&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：存储了 hash 函数，key 和 value 的复制等函数；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;ht_table&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：长度为 2 的 数组，正常情况使用 ht_table[0] 存储数据，当执行 rehash 的时候，使用 ht_table[1]  配合完成 。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;key 的哈希值最终会映射到 ht_table  的一个位置，如果发生哈希冲突，则拉出一个哈希链表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家重点关注 dictEntry 类型的 ht_table，ht_table 数组每个位置我们也叫做&lt;strong&gt;哈希桶&lt;/strong&gt;，就是这玩意保存了所有键值对。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis 支持那么多的数据类型，哈希桶咋保存？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哈希桶的每个元素的结构由 dictEntry 定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;typedef struct dictEntry {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   // 指向 key 的指针&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void *key;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    union {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 指向实际 value 的指针&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        void *val;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        uint64_t u64;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        int64_t s64;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        double d;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } v;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 哈希冲突拉出的链表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    struct dictEntry *next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} dictEntry;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;key&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 指向键值对的键的指针，key 都是 string 类型；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;value&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 是个 union（联合体）当它的值是 uint64_t、int64_t 或 double 类型时，就不再需要额外的存储，这有利于减少内存碎片。（为了节省内存操碎了心）当然，val 也可以是 void 指针，指向值的指针，以便能存储任何类型的数据；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;next&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  指向另一个 dictEntry 结构， 多个 dictEntry 可以通过 next 指针串连成链表， 从这里可以看出， ht_table 使用链地址法来处理键碰撞：当多个不同的键拥有相同的哈希值时，哈希表用一个链表将这些键连接起来。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哈希桶并没有保存值本身，而是指向具体值的指针，从而实现了哈希桶能存不同数据类型的需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而哈希桶中，键值对的值都是由一个叫做 redisObject 的对象定义，源码地址：&lt;/span&gt;&lt;span&gt;https://github.com/redis/redis/blob/7.0/src/server.h。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;typedef struct redisObject {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    unsigned type:4;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    unsigned encoding:4;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    unsigned lru:LRU_BITS;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    int refcount;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void *ptr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} robj;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;type&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：记录了对象的类型，string、set、hash 、Lis、Sorted Set 等，根据该类型才可以确定是哪种数据类型，使用什么样的 API 操作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;encoding&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：编码方式，表示 ptr 指向的数据类型具体数据结构，即这个对象使用了什么数据结构作为底层实现保存数据。同一个对象使用不同编码实现内存占用存在明显差异，内部编码对内存优化非常重要；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;lru:LRU_BITS：LRU&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 策略下对象最后一次被访问的时间，如果是 LFU 策略，那么低 8 位表示访问频率，高 16 位表示访问时间；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;refcount&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：表示引用计数，由于 C 语言并不具备内存回收功能，所以 Redis 在自己的对象系统中添加了这个属性，当一个对象的引用计数为 0 时，则表示该对象已经不被任何对象引用，则可以进行垃圾回收了；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;ptr 指针&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：指向对象的底层实现数据结构，指向值的指针。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如下图是由 redisDb、dict、dictEntry、redisObejct 关系图：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5667144906743186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtfNp8LYGJVwpAauU9m9PfbkCcGibDsDZtib5Bv3qicyZQSGjriar8Fj6Gbx7Lic5UM6JHD5pUcvEgEJAuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1394&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;redis存储结构&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里再唠叨几句，void *key  和 void *value 指针指向的是 &lt;strong&gt;redisObject&lt;/strong&gt;，Redis 中每个对象都是用 redisObject 表示。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;知道了 Redis 存储原理以及不同数据类型的存储数据结构后，我们继续看如何做性能优化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1. 键值对优化&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当我们执行 set key value 的命令，*key指针指向 SDS 字符串保存 key，而 value 的值保存在 *ptr 指针指向的数据结构，消耗的内存：key + value。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;第一个优化神技：降低 Redis 内存使用的最粗暴的方式就是缩减键（key）与值（value）的长度。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 key 的命名使用「业务模块名:表名:数据唯一id」这样的方式方便定位问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如：users:firends:996 表示用户系统中，id = 996 的朋友信息。我们可以简写为：u:fs:996&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 key 的优化：使用单词简写方式优化内存占用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 value 的优化那就更多了：&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;过滤不必要的数据&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：不要大而全的一股脑将所有信息保存，想办法去掉一些不必要的属性，比如缓存登录用户的信息，通常只需要存储昵称、性别、账号等；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;精简数据&lt;/strong&gt;：比如用户的会员类型：0 表示「屌丝」、1 表示 「VIP」、2表示「VVIP」。而不是存储 VIP 这个字符串；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据压缩&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：对数据的内容进行压缩，比如使用 GZIP、Snappy；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用性能好，内存占用小的序列化方式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。比如 Java 内置的序列化不管是速度还是压缩比都不行，我们可以选择 protostuff，kryo等方式。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图 Java 常见的序列化工具空间压缩比：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.503125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtfNp8LYGJVwpAauU9m9Pfbkx1KXcWEDVnciaHsbRU5ticdJiaoHRTJDHZibViaMvKicus5ZXOUr930Mcw1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;span&gt;序列化工具压缩比&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;p&gt;&lt;span&gt;我们通常使用 JSON 作为字符串存储在 Redis，用 &lt;span&gt;JSON&lt;/span&gt; 存储与二进制数据存储有什么优缺点呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JSON 格式的优点：方便调试和跨语言；缺点是：同样的数据相比字节数组占用的空间更大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一定要 JSON 格式的话，那就先通过压缩算法压缩 JSON，再把压缩后的数据存入 Redis。比如 GZIP 压缩后的 JSON 可降低约 60% 的空间。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2. 小数据集合编码优化&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;key 对象都是 String 类型，value 对象主要有五种基本数据类型：String、List、Set、Zset、Hash。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据类型与底层数据结构的关系如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2815198618307426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtfNp8LYGJVwpAauU9m9PfbkykbX07D4tk4XMO6I4ibv1YldMyHnbJBVrSwKwNoVdh71EicibECYCSB5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;579&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;编码与数据结构&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;特别说明下在最新版（非稳定版本，时间 2022-7-3），ziplist 压缩列表由 quicklist 代替（3.2 版本引入），而双向链表由 listpack 代替。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另外，同一数据类型会根据键的数量和值的大小也有不同的底层编码类型实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Redis 2.2 版本之后，存储集合数据（Hash、List、Set、SortedSet）在满足某些情况下，会采用内存压缩技术来实现使用更少的内存存储更多的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当这些集合中的数据元素数量小于某个值且元素的值占用的字节大小小于某个值的时候，存储的数据会用非常节省内存的方式进行编码，理论上至少节省 10 倍以上内存（平均节省 5 倍以上）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如 Hash 类型里面的数据不是很多，虽然哈希表的时间复杂度是 O(1)，ziplist 的时间复杂度是 O(n)，但是使用 ziplist 保存数据的话会节省了内存，并且在少量数据情况下效率并不会降低很多。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，我们需要尽可能地控制集合元素数量和每个元素的内存大小，这样能充分利用紧凑型编码减少内存占用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并且，这些编码对用户和 API 是无感知的，当集合数据超过配置文件的配置的最大值， Redis 会自动转成正常编码。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据类型对应的编码规则如下所示&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;String 字符串&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;int&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：整数且数字长度小于 20，直接保存在 *ptr 中；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;embstr&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：开辟一块连续分配的内存（字符串长度小于等于 44 字节）；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;raw&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：动态字符串（大于 44 字节的字符串，同时字符串小于 512 MB）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;List 列表&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ziplist&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：元素个数小于 hash-max-ziplist-entries 配置，同时所有的元素的值大小都小于 hash-max-ziplist-value 配置；&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15080527086383602&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtfNp8LYGJVwpAauU9m9Pfbk3TTSG3xosf2vuMH5EzoH67RS3ZICpjvoOl8BvYicTn2EYVNaVziawFYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;683&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;ziplist&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;linkedlist&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.0 版本之前当列表类型无法满足 ziplist 的条件时，Redis会使用 linkedlist 作为列表的内部实现；&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;quicklist&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Redis  3.2 引入，并作为 List 数据类型的底层实现，不再使用双端链表 linkedlist 和 ziplist 实现。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Set 集合&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;intset 整数集合&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：元素都是整数，且元素个数小于 set-max-intset-entries配置；&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;hashtable 哈希表&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：集合类型无法满足intset的条件时就会使用hashtable 编码。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Hash 哈希表&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ziplist&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：元素个数小于 hash-max-ziplist-entries 配置，同时任意一个 value 的占用字节大小都小于 hash-max-ziplist-value ；&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;hashtable&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：hash 类型无法满足 intset 的条件时就会使用 hashtable。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Sorted Set 有序集合&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;ziplist&lt;/strong&gt;：元素个数小于 zset-max-ziplist-entries 同时每个元素的 value 小于 zset-max-ziplist-value 配置；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;skiplist&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：当ziplist条件不满足时，有序集合会使用skiplist作为内部实现。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以下是 Redis redis.conf  配置文件默认编码阈值配置：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;hash-max-ziplist-entries 512&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;hash-max-ziplist-value 64&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;zset-max-ziplist-entries 128&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;zset-max-ziplist-value 64&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;set-max-intset-entries 512&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;下图是 reidsObject 对象的 type 和 encoding 对应关系图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.191969887076537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtfNp8LYGJVwpAauU9m9Pfbklquibsea2hn6eJ5kfkE7GNJibR03ydHtt5bpDGRGjyYUvw36G8Bsotjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;797&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;type 与编码&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么对一种数据类型实现多种不同编码方式？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;主要原因是想通过不同编码实现效率和空间的平衡。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如当我们的存储只有100个元素的列表，当使用双向链表数据结构时，需要维护大量的内部字段。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如每个元素需要：前置指针、后置指针、数据指针等，造成空间浪费。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果采用连续内存结构的压缩列表(ziplist)，将会节省大量内存，而由于数据长度较小，存取操作时间复杂度即使为O(n) 性能也相差不大，因为 n 值小 与 O(1) 并明显差别。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;数据编码优化技巧&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ziplist 存储 list 时每个元素会作为一个 entry，存储 hash 时 key 和 value 会作为相邻的两个 entry。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;存储 zset 时 member 和 score 会作为相邻的两个entry，当不满足上述条件时，ziplist 会升级为 linkedlist, hashtable 或 skiplist 编码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于目前大部分Redis运行的版本都是在3.2以上，所以 List 类型的编码都是quicklist。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;quicklist 是 ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;考虑了综合平衡空间碎片和读写性能两个维度所以使用了新编码 quicklist。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30603448275862066&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtfNp8LYGJVwpAauU9m9Pfbkic1FeNwfTQ5mA2WqicAMtT9h17f3VV4SZYcH4BhY4n1UHiaF4WU7qZRmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ziplist 的不足&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每次修改都可能触发 realloc 和 memcopy，可能导致连锁更新（数据可能需要挪动）。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此修改操作的效率较低，在 ziplist 的元素很多时这个问题更加突出。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化手段：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;key 尽量控制在 44 字节以内，走 embstr 编码；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;集合类型的 value 对象的元素个数不要太多太大，充分利用 ziplist 编码实现内存压缩。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3. 对象共享池&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;整数我们经常在工作中使用，Redis 在启动的时候默认生成一个 0 ~9999 的整数对象共享池用于对象复用，减少内存占用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如执行：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; set 码哥 18; set 吴彦祖 18;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;key 等于 「码哥」 和「吴彦祖」的 value 都指向同一个对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果 value 可以使用整数表示的话尽可能使用整数，这样即使大量键值对的 value 大量保存了 0~9999 范围内的整数，在实例中，其实只有一份数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里有两个大坑需要注意，它会导致对象共享池失效。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redis 中设置了 maxmemory 限制最大内存占用大小且启用了 LRU 策略（allkeys-lru 或 volatile-lru 策略）。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为 LRU 需要记录每个键值对的访问时间，都共享一个整数 对象，LRU 策略就无法进行统计了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;集合类型的编码采用 ziplist 编码，并且集合内容是整数，也不能共享一个整数对象。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里由于使用了 ziplist 紧凑型内存结构存储数据，判断整数对象是否共享的效率很低。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4.使用 Bit 比特位或 byte 级别操作&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如在一些「二值状态统计」的场景下使用 Bitmap 实现，对于网页 UV 使用 HyperLogLog 来实现，大大减少内存占用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么是二值状态统计？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也就是集合中的元素的值只有 0 和 1 两种。在签到打卡和用户是否登陆的场景中，只需记录签到 (1) 或 未签到( 0)，已登录 (1) 或未登陆 (0)。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假如我们在判断用户是否登陆的场景中使用 Redis 的 String 类型实现（key -&amp;gt; userId，value -&amp;gt; 0 表示下线，1 - 登陆），假如存储 100 万个用户的登陆状态，如果以字符串的形式存储，就需要存储 100 万个字符串，内存开销太大。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;String 类型除了记录实际数据以外，还需要额外的内存记录数据长度、空间使用等信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Bitmap 的底层数据结构用的是 String 类型的 SDS 数据结构来保存位数组，Redis 把每个字节数组的 8 个 bit 位利用起来，每个 bit 位 表示一个元素的二值状态（不是 0 就是 1）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以将 Bitmap 看成是一个 bit 为单位的数组，数组的每个单元只能存储 0 或者 1，数组的下标在 Bitmap 中叫做 offset 偏移量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了直观展示，我们可以理解成 buf 数组的每个字节用一行表示，每一行有 8 个 bit 位，8 个格子分别表示这个字节中的 8 个 bit 位，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4583333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtfNp8LYGJVwpAauU9m9PfbkretOo3b61TiaXRxBwHrH3fPZaugicib7jxxSjAP1icOsnA41ib5S3NPM2xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8 个 bit 组成一个 Byte，所以 Bitmap 会极大地节省存储空间。 这就是 Bitmap 的优势。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 妙用 Hash 类型优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽可能把数据抽象到一个哈希表里。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如说系统中有一个用户对象，我们不需要为一个用户的昵称、姓名、邮箱、地址等单独设置一个 key，而是将这个信息存放在一个哈希表里。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;hset users:深圳:999 姓名 码哥&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;hset users:深圳:999 年龄 18&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;hset users:深圳:999 爱好 女&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;为什么使用 String 类型，为每个属性设置一个 key 会占用大量内存呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为 Redis 的数据类型有很多，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，用 *prt 指针指向实际数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当我们为每个属性都创建 key，就会创建大量的 redisObejct 对象占用内存。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如下所示  redisObject 内存占用：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7096774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtfNp8LYGJVwpAauU9m9Pfbkhn0bPkd0VkOosjzGMZWrk3aQp7DGRHad8vCjg1ic0EFoZlTIF3eJauQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;403&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;redisObejct&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用 Hash 类型的话，每个用户只需要设置一个 key。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6. 内存碎片优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Redis 释放的内存空间可能并不是连续的，这些不连续的内存空间很有可能处于一种闲置的状态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然有空闲空间，Redis 却无法用来保存数据，不仅会减少 Redis 能够实际保存的数据量，还会降低 Redis 运行机器的成本回报率。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如， Redis 存储一个整形数字集合需要一块占用 32 字节的连续内存空间，当前虽然有 64 字节的空闲，但是他们都是不连续的，导致无法保存。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;内存碎片是如何形成呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;两个层面原因导致：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;操作系统内存分配机制：内存分配策略决定了无法做到按需分配。因为分配器是按照固定大小来分配内存；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;键值对被修改和删除，从而导致内存空间的扩容和释放。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;碎片优化可以降低内存使用率，提高访问效率，在 4.0 以下版本，我们只能使用重启恢复：重启加载 RDB 或者通过高可用主从切换实现数据的重新加载减少碎片。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 4.0 以上版本，Redis 提供了自动和手动的碎片整理功能，原理大致是把数据拷贝到新的内存空间，然后把老的空间释放掉，这个是有一定的性能损耗的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为 Redis 是单线程，在数据拷贝时，Redis 只能等着。这就导致 Redis 无法处理请求，性能就会降低。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;手动整理碎片&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;执行 memory purge 命令即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;自动整理内存碎片&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用 config set activedefrag yes 指令或者在 redis.conf 配置 activedefrag yes 将 activedefrag 配置成 yes 表示启动自动清理功能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个配置还不够，至于啥时候清理还需要看下面的两个配置：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;active-defrag-ignore-bytes 200mb&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：内存碎片的大小达到 200MB，开始清理；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;active-defrag-threshold-lower 6&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：表示内存碎片空间占操作系统分配给 Redis 的总空间比例达到 6% 时，开始清理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只有满足这两个条件， Redis 才会执行内存碎片自动清理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此之外，Redis 为了防止清理碎片对 Redis 正常处理指令造成影响，有两个参数用于控制清理操作占用 CPU 的时间比例上下限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7. 使用 32 位的 Redis&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用 32 位的 Redis，对于每一个 key 将使用更少的内存。因为 32 位程序，指针占用的字节数更少。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，32 位 Redis 整个实例使用的内存将被限制在 4G 以下。我们可以通过 cluster 模式将多个小内存节点构成一个集群，从而保存更多的数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外小内存的节点 fork 生成 rdb 的速度也更快。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RDB 和 AOF 文件是不区分 32 位和 64 位的（包括字节顺序），所以你可以使用 64 位的 Redis 恢复 32 位的 RDB 备份文件，相反亦然。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[1]https://redis.io/docs/reference/optimization/memory-optimization/&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2]《Redis 核心技术与实战》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[3] https://segmentfault.com/a/1190000041771534&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651496409&amp;amp;idx=2&amp;amp;sn=e9a46baeb2adae0c3a5474555605adb0&amp;amp;chksm=bd25f3a68a527ab0efc241b2b07aa5694885a36f1e555aa74bac195129bccbd3245c14c1a430&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Redis 性能问题分析&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Redis 性能问题分析&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651516037&amp;amp;idx=1&amp;amp;sn=66194dfc1b5365b9451f515fba3a69fb&amp;amp;chksm=bd2580fa8a5209ec8080de7bc599688b19a18aeb70492a3ba673f409de8a94047e694e9cae81&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;掘地三尺搞定 Redis 与 MySQL 数据一致性问题&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;掘地三尺搞定 Redis 与 MySQL 数据一致性问题&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651515566&amp;amp;idx=1&amp;amp;sn=89609233ab6414dfa46e7d599220e554&amp;amp;chksm=bd2586d18a520fc760fff157a065bdbdd287bcf1002118a7eb54c6b68f9374555cb7f4d9e881&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;解决了 Redis 大 key 问题，同事们都夸他牛皮&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;解决了 Redis 大 key 问题，同事们都夸他牛皮&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a869bd5b0134821549e3c5610c47b1a1</guid>
<title>原来低代码平台可以这样设计！</title>
<link>https://toutiao.io/k/d4dofn0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxNzk1MjQ0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YBFV3Da0Nwvv72YkFO0qPibDKicOCsfltiaE9070DOu4iahXnicYwRIHcxe9VBicAy45MkPqy8nZzLTVibugOtV0ORFcg/0?wx_fmt=png&quot; data-nickname=&quot;程序员成长指北&quot; data-alias=&quot;coder_growth&quot; data-signature=&quot;专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;大厂技术&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;高级前端&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;Node进阶&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;程序员成长指北&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，加入高级Node交流群&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文会主要分享自己对低代码平台的理解，从多个角度和问题去看低代码平台的设计。我觉得&lt;strong&gt;「低代码平台的核心在于模型设计，包括控件模型、组件模型、画布模型等等」&lt;/strong&gt;。希望看完本文，你能知道：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;低代码平台核心的底层逻辑是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为何常见低代码平台都包含“控件区”、“布局区”和“属性编辑区”？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;低代码平台的控件、组件、画布的本质是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何让低代码平台支持跨平台？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何让低代码平台支持自定义数据源？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下主要从低代码平台设计器方向去分析介绍。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、你所看见过的低代码平台&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近几年国内纷纷出现各种低代码产品，在&lt;strong&gt;「降本增效提质」&lt;/strong&gt;方面发挥重要作用。低代码平台的业务场景涉及越来越广泛：自定义表单、页面制作、活动详情页、工作流场景、数据报表、大屏数据报表、数据表格、白板笔记等等。对应成熟的低代码产品也非常多：&lt;span&gt;阿里宜搭&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;、&lt;span&gt;腾讯云搭&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;、&lt;span&gt;百度爱速搭&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;、&lt;span&gt;轻流&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;、&lt;span&gt;Jeecg Boot&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;、&lt;span&gt;码良&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图腾讯开源的 &lt;span&gt;tmagic&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt; 平台，是我们最常见的低代码平台布局方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4932150313152401&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZicvKG5VHUtVbp03E7vHN781lZ00pVw5QLicwBQjibMFicQBibMlh95icYFnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1916&quot;/&gt;（本图来自：&lt;span&gt;tmagic&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt; ）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中包括三个核心模块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「控件区」&lt;/strong&gt;：展示平台内支持的控件，用户通过拖拽控件到布局区，即可展示控件对应的 UI 组件样式；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「布局区」&lt;/strong&gt;：用来承载控件对应的 UI 组件，用户可以对每个 UI 组件进行布局，并且直观查看页面效果；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「属性编辑区」&lt;/strong&gt;：用来展示该控件支持的配置内容，可以更加灵活的对每个控件对应的 UI 组件进行自定义设置。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，&lt;strong&gt;「为何各个产品纷纷采用这类布局？」&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、换个角度思考低代码平台设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在解决问题时，经常会使用两种方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「自顶向下法」&lt;/strong&gt;：从目标出发，拆解和细化问题，找到解决方法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「自底向上法」&lt;/strong&gt;：汇总各种零散信息，得到正确方法和结论。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们试着用&lt;strong&gt;「自顶向下法」&lt;/strong&gt;思考一下低代码平台的设计：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常在团队确定是否需要开发低代码平台前，都会通过头脑风暴、灵感讨论、业务需要情况分析，然后确定开发低代码平台的原始需求。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5102564102564102&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZxNz7WFlsaORxJaicR6JD3pAXYo6xy8gl9zBetQ47TeicPrIbmQED1QKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设这么一个场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;掘金社区的主页布局比较单一，当需要增加或调整部分模块时，需要改动项目代码、打包、提测、发布，这时候如果能有一个主页设计平台，让运营人员自由调整页面布局，还可以针对不同节日、活动调整出不同主页布局。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6418636995827538&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZziaKzcfwPRAbiaCtsk9DibvtD1RXS3rSsiaBsGwKG3WyicAgcMahCU6slhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1438&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这样的场景，我们使用&lt;strong&gt;「自顶向下法」&lt;/strong&gt;，从目标出发，拆解和细化问题，找出解决方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 确定目标&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的目标需求是能够灵活的布局社区主页：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4598290598290598&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZhePKgFlUVaRYBWDlWqkzVF7g71rwYrYAajemjTEiaoKicBCZ7kl0oaYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 拆解和细化问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要实现灵活布局的掘金主页，就需要将主页中的模块抽成每个独立控件：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37139107611548555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZY0O7LPiasNCGWb5KKhKdbbqmEKzVGgaBkTnRKu0sAh5P4iarPYeZpXkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1524&quot;/&gt;如果每个控件需要能够灵活配置，我们还需要能够配置控件的任意部分：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45065963060686015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZBrkibeRSGm6xSTCbQyjiacD1tzs0NHiaOw2oLzldRnw9cpFV7AOmQGrow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1895&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 找到解决方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照前两个步骤的分析，我们可以确定大致解决方法：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;需要实现一个支持自由拖拽布局的设计平台；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该平台支持拖拽不同控件到页面中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个控件支持不同的自定义配置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计器支持导出页面结构，渲染器支持渲染页面内容。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是我们就有了下面的方案：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.559445178335535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZ2WHX4LEcVmp2CyMQ34oCicUvAZSkOEOVs9VFWRVv4SbmxQBzicSTRIKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1514&quot;/&gt;这样是为什么常见低代码平台都会有“控件区”、“布局区”和“属性编辑区”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常交互逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从「控件区」拖拽一个控件进入「布局区」，将控件渲染成对应组件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选中组件，在「属性配置区」显示该组件所有支持配置的属性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改「属性配置区」的属性，更新「布局区」中该组件的样式。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5528401585204755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZ81zV2TH30OrIWIiaeW4GD6rYw7Zq0sH0icX9hAH86UJQuUWYveIpuNYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1514&quot;/&gt;这是最简单的一个流程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、思考更加通用的低代码模型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;低代码平台创建的页面，本质上不一定是单个页面，也可以是由多个页面组成的一个 Web 应用，因此，我们可以把上面示例，抽象成更加通用的低代码平台模型：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4485294117647059&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZllich2fibQsGMOCX63ltEQ1icfDRPld1sGibg0iaopfz87NzXXWZWuzEFGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1904&quot;/&gt;该模型定义了低代码平台创建的页面结构，最终的渲染是由对应渲染器渲染页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就有点 VNode 树的味道啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38184663536776214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZPvPJ2ic9icfKT09mlBFDZHsFdJnC0gPZXzW90COYVpbvEfXw2mvUkdwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;639&quot;/&gt;（图片来源：&lt;span&gt;https://v3.cn.vuejs.org/&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Vue 而言，&lt;strong&gt;「核心要解决的就是“如何创建 VNode”和“如何渲染 VNode”。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们通过 TypeScript 接口形式定义下面的结构：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7557823129251701&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZLmZElQWmbgQNZheWdMVbo6icGHa6smdwoKya8LWp4wibFdBNlU0jPJHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1470&quot;/&gt;可以发现，单页应用和多页应用的关系在于，通过为单页应用增加 &lt;code&gt;path&lt;/code&gt;配置，将多个单页应用组合成多页应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我们就有一个更加通用的低代码模型，并且使用 TypeScript 接口定义了每一层的结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出：&lt;strong&gt;「低代码平台的核心在于模型设计，定义每个部分的模型。」&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、控件区的控件没这么简单&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 控件是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控件本质是一个&lt;strong&gt;「标准的 JSONSchema 对象，用来描述最终渲染出来的组件」&lt;/strong&gt;。在低代码平台中，将控件拖拽到布局区才会显示对应的组件样式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以「用户信息控件」为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; UserInfo = {&lt;br/&gt;    name: &lt;span&gt;&#x27;用户信息控件&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;UserInfoComponent&#x27;&lt;/span&gt;, &lt;span&gt;// 指定渲染的组件名称&lt;/span&gt;&lt;br/&gt;    config: [&lt;br/&gt;        {&lt;br/&gt;            label: &lt;span&gt;&#x27;头像&#x27;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;input&#x27;&lt;/span&gt;,&lt;br/&gt;            value: &lt;span&gt;&#x27;https://a.com&#x27;&lt;/span&gt;,&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;            label: &lt;span&gt;&#x27;昵称&#x27;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;input&#x27;&lt;/span&gt;,&lt;br/&gt;            value: &lt;span&gt;&#x27;pingan8787&#x27;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常我们会在控件对象中定义一个 type（也可能是其他名称），用来&lt;strong&gt;「指定控件所渲染的组件名称」&lt;/strong&gt;。比如 Vue 中，就可以通过该 type 值，使用动态组件 &lt;code&gt;&amp;lt;component :is={type} /&amp;gt;&lt;/code&gt;形式动态渲染组件。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.556870479947403&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZ5FsPUibjUSADGudQQZFUOnY0kcbriahyHGIBDLhUtauNcj56oLmwzreg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1521&quot;/&gt;控件就好比是组件的说明书，只是对组件进行描述，描述了它是什么样子，有哪些行为、配置等信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 控件还有什么优点？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控件定义成&lt;strong&gt;「标准的 JSON 对象」&lt;/strong&gt;，还有其他优点。比如：&lt;strong&gt;「可以实现控件跨平台适配，在不同平台/组件库渲染不同的组件」&lt;/strong&gt;。目标平台只需按照模型渲染不同组件即可。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4891518737672584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZKZLoNMLmcWyABRLjZj0fU56fQVGVgrQuxCcQiakJkq9UmY7JEAIMxdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1521&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 控件如何实现动态加载远程组件？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的方案是为每个控件指定远程组件的地址（如设置 &lt;code&gt;path&lt;/code&gt; 属性），当控件开始被拖拽时，发送请求获取远程组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; UserInfo = {&lt;br/&gt;    name: &lt;span&gt;&#x27;用户信息控件&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;UserInfoComponent&#x27;&lt;/span&gt;, &lt;span&gt;// 指定渲染的组件名称&lt;/span&gt;&lt;br/&gt;    path: &lt;span&gt;&#x27;https://a.com/UserInfoComponent.js&#x27;&lt;/span&gt;, &lt;span&gt;// 远程组件的地址&lt;/span&gt;&lt;br/&gt;    config: [&lt;br/&gt;        {&lt;br/&gt;            label: &lt;span&gt;&#x27;头像&#x27;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;input&#x27;&lt;/span&gt;,&lt;br/&gt;            value: &lt;span&gt;&#x27;https://a.com&#x27;&lt;/span&gt;,&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;            label: &lt;span&gt;&#x27;昵称&#x27;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;input&#x27;&lt;/span&gt;,&lt;br/&gt;            value: &lt;span&gt;&#x27;pingan8787&#x27;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 Vue 为例，当获取到远程 Vue 组件后，可以通过 Vue 提供的动态组件进行注册和使用。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5636838667537557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZ9B0oX5py9Sc4UxjriaiaUzrVshJYIRiczmmEXmM7W6vn6qiam6gDHBCBJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1531&quot;/&gt;完整过程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;开始拖拽「控件区」控件，并发起请求，从服务端获取远程组件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当获取到远程组件后，注册到项目中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;松开控件，渲染组件内容到「画布区」。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，考虑到编辑器的性能优化，避免每次拖拽都发送请求获取组件文件，我们可以这样优化：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用请求缓存，如果是重复请求，则从缓存读取上次请求结果；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对常用基础组件预先发送请求并保存本地；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地缓存已请求的组件，下次请求相同组件，则读取缓存结果；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、画布区的画布也没这么简单&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 画布是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画布的本质也是一个&lt;strong&gt;「标准 JSON 对象，」&lt;/strong&gt;它是我们最终要渲染页面所用的数据源，通常包含整个页面的结构和配置信息。当拖拽控件进入画布和更新组件配置时，会更新画布。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们根据掘金主页，简单构造一个模型（不考虑多页面情况）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; Juejin = {&lt;br/&gt;    title: &lt;span&gt;&#x27;掘金主页&#x27;&lt;/span&gt;,&lt;br/&gt;    favicon: &lt;span&gt;&#x27;./favicon.icon&#x27;&lt;/span&gt;,&lt;br/&gt;    components: [&lt;br/&gt;        {&lt;br/&gt;            name: &lt;span&gt;&#x27;用户信息控件&#x27;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;UserInfoComponent&#x27;&lt;/span&gt;,&lt;br/&gt;            config: [&lt;br/&gt;                {&lt;br/&gt;                    label: &lt;span&gt;&#x27;头像&#x27;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;input&#x27;&lt;/span&gt;,&lt;br/&gt;                    value: &lt;span&gt;&#x27;https://a.com&#x27;&lt;/span&gt;,&lt;br/&gt;                },&lt;br/&gt;                {&lt;br/&gt;                    label: &lt;span&gt;&#x27;昵称&#x27;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;input&#x27;&lt;/span&gt;,&lt;br/&gt;                    value: &lt;span&gt;&#x27;pingan8787&#x27;&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            ]&lt;br/&gt;        }&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面模型中，定义了画布中的每个组件，存放在 &lt;code&gt;components&lt;/code&gt;数组下，每个组件都包含各自的 &lt;code&gt;name&lt;/code&gt;、&lt;code&gt;type&lt;/code&gt;、&lt;code&gt;config&lt;/code&gt;等信息，在渲染器渲染时，就可以：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;根据 &lt;code&gt;type&lt;/code&gt;渲染配置区的组件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据 &lt;code&gt;label&lt;/code&gt; 渲染配置区表单的 label 文本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据 &lt;code&gt;value&lt;/code&gt;渲染配置区表单的值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 画布还有丰富的配置&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于画布模型，最重要的应该是组件列表，即前面的 &lt;code&gt;components&lt;/code&gt;数组，对于每一个组件，最主要的信息包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;事件模型信息：包含该组件绑定的一些事件（如事件名称等）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;动画模型信息：包含该组件绑定的一些动画效果（如旋转、放大等）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UI 样式模型信息：包含该组件绑定的一些 UI 样式（如背景色、字号等）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据/数据源模型信息：包含该组件绑定的一些数据源相关的配置（如数据源接口地址等）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以「&lt;strong&gt;「事件模型信息」&lt;/strong&gt;」为例，当页面中配置了一个按钮，这个按钮往往可以做如下事情：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;打开链接；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打开弹框；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打开 APP；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;刷新页面；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，该按钮可触发的行为非常多，如果把每个事件处理逻辑都写在组件中，会使得组件臃肿无比，且耦合在组件中，可维护性差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了降低组件和事件处理逻辑之间的耦合度，我们可以在组件和事件处理逻辑中间增加一层，即事件总线：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4637454355764215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZib5AGOiaXxdAroibVY7DrPicBLpriaf0FZpaQLlXIZ1J4iciaR4N2yEvWrUug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1917&quot;/&gt;实现通用组件派发事件到事件总线，不同的业务场景监听事件，执行具体的事件处理逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过事件总线，将派发事件和监听事件的双方互相解耦，完成解耦后，还能够实现&lt;strong&gt;「跨平台」&lt;/strong&gt;的功能，&lt;strong&gt;「对于派发相同的事件，只需要在不同平台监听该事件，实现不同的处理逻辑即可」&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、数据源设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓「数据源」即低代码平台中数据来源，通常按照业务需求可以将数据源分为两类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「静态数据源」&lt;/strong&gt;：数据绑定在页面配置中，在最终效果页时，直接使用页面配置中的数据，无需通过接口获取数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「动态数据源」&lt;/strong&gt;：一般是保存数据源的接口在配置中，不绑定数据，在最终效果页时，客户端需要再发送请求获取数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 静态数据源的过程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在低代码设计平台中，平台先请求数据，用户选择其中指定数据，保存在页面配置中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，当我们已有 banner 列表接口，需要选择其中一张，添加到布局区中：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28566710700132103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZRmsJ15PX6Jj8ONzwfvQnADoYq09ENibrTOsk42iciaEHrsZib5Y7nNePaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3028&quot;/&gt;步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户在「控件区」选择「轮播控件」，拖入「布局区」；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;点击「布局区」中「轮播控件」的组件，打开「属性配置区」；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择「属性配置区」中「选择 banner」，平台发送请求，从服务端获取 banner 列表；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打开「选择 banner 弹框」，展示 banner 列表，用户选择所需 banner 图片；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;点击「确定」，关闭「选择 banner 」弹框，并在「布局区」的「轮播控件」组件插入该笔数据，完成选择。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户在「选择 banner」弹框中，选中指定的数据，保存到页面配置中，当访问最终生成效果页，会直接显示出已选择的 banner 图片。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 动态数据源的过程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态数据源相比静态数据源，会更加灵活，用户指定数据源接口后，当接口数据变化，最终效果页可以动态改变展示的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如当我们已有 banner 列表接口，可以在管理后台添加不同的 banner，最终效果页能够展示新的 banner，而用户只需在设计时，指定 banner 列表接口即可：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28566710700132103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZeIVV7AxUUJoibMVIlVAYVAmkSCOklo6F4FlI7wu67s58RrSr5a8mouw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3028&quot;/&gt;步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户在「控件区」选择「轮播控件」，拖入「布局区」；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;点击「布局区」中「轮播控件」的组件，打开「属性配置区」；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择「属性配置区」中「配置 banner」，配置“接口地址”和“转换规则”；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择完成，点击「确定」，关闭「选择 banner 」弹框，将配置的“接口地址”和“转换规则”数据保存在「布局区」页面配置中，配置完成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当用户访问最终效果页时，页面会先调用配置的“接口地址”获取远程的 banner 列表；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将接口返回的数据通过“转换规则”，将接口返回的数据转换成组件所有的数据格式。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就实现了最终效果页能够每次都展示最新的数据，实现完全动态。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 增加数据源适配器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当需要对两个耦合度较高的逻辑进行解耦，可以通过增加适配器方法进行解耦，因此在数据源这边也可以增加适配器对「UI 组件」和「接口数据」进行解耦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想状态应该是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;UI 组件只对外暴露组件支持的配置和方法，而无需关注是什么业务使用该组件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接口数据也无需关注数据被什么组件使用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，我们分别为「静态数据源」和「动态数据源」增加了数据适配器，流程如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2981181908220535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZWEt5HFDrXZLr7vE5zacn0t3zoFibocWMSibbyzeoibdZYP7kz2rJIvcKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3029&quot;/&gt;在第 4 步时，接口返回的数据会经过「数据适配器 1」，将接口数据转换为「选择 banner」弹框组件统一的参数。同理，第 6 步将弹框组件返回的数据结构，通过「数据适配器 2」转换为「banner 组件」所需参数的数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28722350610762626&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dy9CXeZLlCVIvge4zo6YPNtA4IJqnUrZGoHSkjchnpADNof2VGv2EWibxp8icJ5LuneiabwqRHnE2ABN1qibAib8TqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3029&quot;/&gt;在第 6 步时，接口返回的数据会经过「数据适配器 」，将接口数据转换为「banner 组件」统一的参数数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实总结一下，就是通过各种数据适配器，将各种来源的数据结构转换为组件的参数模型即可。好处也很明显：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;更换数据源时，只需要按照组件参数模型对接接口，实现各种数据适配器，无需改动原有逻辑；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更换 UI 组件库时，也只需要按照组件参数模型对接 UI 组件，实现各种数据适配器，无需改动原有逻辑。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 总结数据源设计&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照前面的方案，我们对数据源就有了主要方向，其主要的核心在于：通过定义组件接口模型和适配器模型，我们可以很容易的开发任意组件和适配器，按照定义的模型，其他开发者也能很方便的开发。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;七、总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「低代码平台作用在于降本增效提质，核心在于模型设计，降低各个功能点的耦合度，让平台支持跨平台」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文通过&lt;strong&gt;「自顶向下法」&lt;/strong&gt;，介绍低代码平台的设计思路，&lt;strong&gt;「从目标出发，拆解和细化问题，找到解决方法」&lt;/strong&gt;。后面针对低代码平台的几个核心模块逐一分析自己的理解，着重介绍了核心模块的模型设计和配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文是自己经过几个低代码平台实战后的理解和总结，希望对各位有所帮助，低代码平台的未来无限可能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我第一次写低代码相关的文章，如有错误，欢迎指正~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxNzk1MjQ0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YBFV3Da0Nwvv72YkFO0qPibDKicOCsfltiaE9070DOu4iahXnicYwRIHcxe9VBicAy45MkPqy8nZzLTVibugOtV0ORFcg/0?wx_fmt=png&quot; data-nickname=&quot;程序员成长指北&quot; data-alias=&quot;coder_growth&quot; data-signature=&quot;专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section label=&quot;Copyright © 2016 playhudong All Rights Reserved.&quot; donone=&quot;shifuMouseDownPayStyle(&#x27;shifu_t_042&#x27;)&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;Node 社群&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89226&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我组建了一个氛围特别好的 Node.js 社群，里面有很多 Node.js小伙伴，如果你对Node.js学习感兴趣的话（后续有计划也可以），我们可以一起进行Node.js相关的交流、学习、共建。下方加 考拉 好友回复「Node」即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YBFV3Da0NwsF7OKB4iaaXAzQPbNstk2LybA0Zz5I1hiaiazE9W7WH2Ojt2dibDODWMVUmHqgfXCefVwt7z5ibNMWLvg/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;578.2649006622516&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;700.2119205298013&quot; data-fileid=&quot;100016913&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2093425605536332&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YBFV3Da0NwvFQgO67XibvUG5S2UMXwCghOuJvE8BFRzUXnCAfWXkU1qHld6Ly9xiarib3siaWicJWJ0U3lI8kSgD38w/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; color: rgb(89, 89, 89); line-height: 26px;&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;&lt;span&gt;如果你觉得这篇内容对你有帮助，我想请你帮我2个小忙：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;1. 点个&lt;/span&gt;&lt;span&gt;「在看」&lt;/span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;，让更多人也能看到这篇文章&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;2. 订阅官方博客 &lt;/span&gt;&lt;span&gt;www.inode.club &lt;/span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;让我们一起成长&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3913677&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;阿里宜搭: &lt;em&gt;https://yida.alibaba-inc.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;腾讯云搭: &lt;em&gt;https://cloud.tencent.com/product/weda?ivk_sa=1024320u&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;百度爱速搭: &lt;em&gt;https://aisuda.baidu.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;轻流: &lt;em&gt;https://qingflow.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Jeecg Boot: &lt;em&gt;http://boot.jeecg.com&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;码良: &lt;em&gt;https://godspen.ymm56.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;tmagic: &lt;em&gt;https://tencent.github.io/tmagic-editor/playground/index.html#/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;tmagic: &lt;em&gt;https://tencent.github.io/tmagic-editor/playground/index.html#/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;https://v3.cn.vuejs.org/: &lt;em&gt;https://v3.cn.vuejs.org/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aa266344e94823c35ccf80793babd710</guid>
<title>MQTT over QUIC：物联网消息传输还有更多可能</title>
<link>https://toutiao.io/k/9tw1pqf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;引言：首个将 QUIC 引入 MQTT 的开创性产品&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在最新发布的 &lt;a href=&quot;https://www.emqx.com/zh/blog/emqx-v-5-0-released&quot;&gt;5.0 版本&lt;/a&gt;中，EMQX 开创性地引入了 QUIC 支持。&lt;/p&gt;
&lt;p&gt;QUIC 是下一代互联网协议 HTTP/3 的底层传输协议，与 TCP/TLS 协议相比，它&lt;strong&gt;在减少连接开销与消息延迟的同时，为现代移动互联网提供了有效灵活的传输层。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于 QUIC 这些极适用于物联网消息传输场景的优势，EMQX 5.0 引入 QUIC 支持（MQTT over QUIC）并设计了独特的消息传输机制和管理方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文将通过对 MQTT over QUIC 的详细解析，为大家展现这一领先技术实现对于物联网场景的优势与价值，帮助大家更有效地借助 EMQX 5.0 对 QUIC 的支持能力，在各类 MQTT 应用场景中进行更加高效、低成本的物联网数据传输。&lt;/p&gt;
&lt;h2 id=&quot;什么是-quic&quot;&gt;什么是 QUIC&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc9000&quot;&gt;QUIC&lt;/a&gt; 是一种建立在 UDP 之上通用的传输层网络协议，最初由 Google 提出，作为 TCP+TLS 的替代方案，旨在改善用户体验。&lt;/p&gt;
&lt;p&gt;与现有的 TLS over TCP 方案相比，QUIC 有很多优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速建立低延迟连接（1 RTT 或者 0 RTT）&lt;/li&gt;
&lt;li&gt;端到端加密，握手通过 TLS 1.3 进行身份验证&lt;/li&gt;
&lt;li&gt;避免队头阻塞的多路复用&lt;/li&gt;
&lt;li&gt;改进的拥塞控制，可插拔的拥塞控制策略&lt;/li&gt;
&lt;li&gt;多路径支持，连接平滑迁移&lt;/li&gt;
&lt;li&gt;无状态负载均衡&lt;/li&gt;
&lt;li&gt;现有网络无需改造升级即可支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因其高效的传输效率和多路并发的能力，QUIC 已经成为下一代互联网协议 HTTP/3 的底层传输协议。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;HTTP/3 协议介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2018 年 10 月，IETF 的 HTTP 和 QUIC 工作组联合决定将 QUIC 上的 HTTP 映射称为 &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP/3&quot;&gt;HTTP/3&lt;/a&gt;，以提前使其成为全球标准。2022 年 6 月 6 日，IETF 将 HTTP/3 标准化为&lt;a href=&quot;https://en.wikipedia.org/wiki/RFC_(identifier&quot;&gt;RFC &lt;/a&gt;)&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc9114&quot;&gt;9114&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;HTTP/3 的目标是通过解决 HTTP/2 的传输相关问题，在所有形式的设备上提供快速、可靠和安全的 Web 连接。HTTP/3 使用与 HTTP/2 版本类似的语义，包括相同的请求方法、状态代码和消息字段，两者根本区别在于，HTTP/2 底层使用的是 TCP/TLS 协议，而 HTTP/3 使用的是 QUIC 协议。&lt;/p&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://w3techs.com/technologies/details/ce-http3&quot;&gt;W3Techs 统计&lt;/a&gt;，互联网至少 40% 的流量是基于 QUIC 的，前 1000 万个网站中的 25% 已经支持 HTTP/3 协议，包括 Google，Youtube，Facebook 等顶流站点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;quic-在-mqtt-通信场景中的应用前景&quot;&gt;QUIC 在 MQTT 通信场景中的应用前景&lt;/h2&gt;
&lt;p&gt;MQTT 是基于 TCP 的物联网通信协议，紧凑的报文结构能够在严重受限的硬件设备和低带宽、高延迟的网络上实现稳定传输；心跳机制、遗嘱消息、QoS 质量等级等诸多特性能够应对各种物联网场景。&lt;/p&gt;
&lt;p&gt;尽管如此，由于底层 TCP 传输协议限制，某些复杂网络环境下 MQTT 协议存在固有的弊端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络切换导致经常性连接中断&lt;/li&gt;
&lt;li&gt;断网后重新建立连接困难：断网后操作系统释放资源较慢，且应用层无法及时感知断开状态，重连时 Server/Client 开销较大&lt;/li&gt;
&lt;li&gt;弱网环境下数据传输受限于拥塞、丢包侦测和重传机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如车联网用户通常会面对类似的问题：车辆可能会运行在山区、矿场、隧道等地方，当进入到信号死角或被动切换基站时会导致连接中断，频繁连接中断与较慢的连接恢复速度会导致用户体验变差。在一些对数据传输实时性和稳定性要求较高的业务，如 L4 级别的无人驾驶中，客户需要花费大量的成本来缓解这一问题。&lt;/p&gt;
&lt;p&gt;在上述这类场景中，QUIC 低连接开销和多路径支持的特性就显示出了其优势。经过更深入的探索，我们认为 MQTT Over QUIC 可以非常好地解决这一困境 —— 基于 QUIC 0 RTT/1 RTT 重连/新建能力，能够在弱网与不固定的网络通路中有效提升用户体验。&lt;/p&gt;
&lt;h2 id=&quot;emqx-5-0-的-mqtt-over-quic-实现&quot;&gt;EMQX 5.0 的 MQTT over QUIC 实现&lt;/h2&gt;
&lt;p&gt;EMQX 目前的实现将传输层换成 QUIC Stream，由客户端发起连接和创建 Stream，EMQX 和客户端在一个双向 Stream 上实现交互。&lt;/p&gt;
&lt;p&gt;考虑到复杂的网络环境，如果客户端因某种原因未能通过 QUIC 握手，建议客户端自动退回到传统 TCP 上，避免系统无法建立跟服务器的通信。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/b93cb1ce646e93b7ce24440b1936ba06.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;MQTT over QUIC&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/b93cb1ce646e93b7ce24440b1936ba06.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/b93cb1ce646e93b7ce24440b1936ba06.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/b93cb1ce646e93b7ce24440b1936ba06.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前 EMQX 5.0 中已经实现了以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;更高级的拥塞控制：&lt;/strong&gt;有效降低数据丢包率，在测试中在网络波动的情况下仍能持续稳定传输数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运维友好：&lt;/strong&gt;减少大规模重连导致的开销（时间开销、客户端/服务器性能开销），减少不必要的应用层状态迁移而引发的系统过载（0 RTT）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更灵活的架构创新：&lt;/strong&gt;比如 Direct server return (DSR，服务器直接返回模式)，只有入口/请求流量经过 LB，出口和响应流量绕过 LB 直接回到客户端，减少 LB 的瓶颈&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减少握手延迟 （1 RTT）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多路径支持，连接平滑迁移：&lt;/strong&gt;从 4G 切换到 WIFI, 或者因为 NAT Rebinding 导致五元组发生变化，QUIC 依然可以在新的五元组上继续进行连接状态，尤其适用于网络经常性变化的移动设备&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更敏捷的开发部署：&lt;/strong&gt;协议栈的实现在 userspace，能够开发快速迭代&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;端到端加密：&lt;/strong&gt;未加密的包头带有极少信息， 减少传输路径中中间节点的影响，带来更好的安全性和更可控的用户体验&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时还有以下更多能力有待进一步探索：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不同主题的流：&lt;/strong&gt;对于独立主题，每个主题可以有独立的 Streams 以消除其他主题长阻塞带来的影响，比如接收端长阻塞或流量控制，亦可以实现优先级主题功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不同 QoS 的流：&lt;/strong&gt;比如在「流量控制」中，QoS 0 传输应该让位给高 QoS 传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将控制消息分成不同的流：&lt;/strong&gt;MQTT 控制消息可以单向或双向发送。如客⼾端可以通过「控制流」异步发送 UNSUBSCRIBE 请求，以要求服务器端停⽌发送不再感兴趣的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更细粒度的收发端协同流量控制：&lt;/strong&gt;面对每一个流进行流控且对整个连接进行流控，实现更细粒度的流量控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;quic-vs-tcp-tls-测试对比&quot;&gt;QUIC vs TCP/TLS 测试对比&lt;/h2&gt;
&lt;p&gt;我们在实验室环境下，基于 EMQX 5.0 版本对不同的场景下 QUIC 与 TCP/TLS 的性能表现进行了模拟测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试环境&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试平台：EMQX 5.0 单节点&lt;/li&gt;
&lt;li&gt;服务器规格：AWS EC2 M4.2xlarge (8 核 32GB)&lt;/li&gt;
&lt;li&gt;操作系统：Ubuntu 20.04&lt;/li&gt;
&lt;li&gt;客户端数：5000&lt;/li&gt;
&lt;li&gt;loadgen 并行数：8&lt;/li&gt;
&lt;li&gt;latency 取值：P95&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;客户端连接时延&quot;&gt;客户端连接时延&lt;/h3&gt;
&lt;p&gt;测试在不同网络时延下握手、建立连接、完成订阅的时延。相较于 TLS，在网络时延较高时 QUIC 有一定的优势。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/587cb62a55c1c8e964772047697c1ee2.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;1ms 延迟&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/587cb62a55c1c8e964772047697c1ee2.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/587cb62a55c1c8e964772047697c1ee2.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/587cb62a55c1c8e964772047697c1ee2.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;1ms 延迟&lt;/center&gt;&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/0c715dad8849602f7a60a5aaeb073ac0.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;10ms 延迟&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/0c715dad8849602f7a60a5aaeb073ac0.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/0c715dad8849602f7a60a5aaeb073ac0.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/0c715dad8849602f7a60a5aaeb073ac0.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;10ms 延迟&lt;/center&gt;&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/40507a3f7e0f35b50a5817a4b27eb875.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;30ms 延迟&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/40507a3f7e0f35b50a5817a4b27eb875.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/40507a3f7e0f35b50a5817a4b27eb875.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/40507a3f7e0f35b50a5817a4b27eb875.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;30ms 延迟&lt;/center&gt;&lt;h3 id=&quot;0-rtt-重连时延&quot;&gt;0 RTT 重连时延&lt;/h3&gt;
&lt;p&gt;测试断开连接后，重新发起连接并恢复重连所需的时延。&lt;/p&gt;
&lt;p&gt;由于 QUIC 在 0 RTT 场景下可以在第一个包上带上应用层的数据包， 应用层相较于 TCP 一个来回握手响应更快。&lt;/p&gt;
&lt;p&gt;QUIC 协议支持 0 RTT 握手，当客户端和服务端完成&lt;strong&gt;初次&lt;/strong&gt;握手后，服务端可向客户端发送 NST 包。 客户端在连接断开后可用 NST 跳过 1 RTT 中的很多步骤快速重建连接。&lt;/p&gt;
&lt;p&gt;0 RTT 的好处是可有效降低客户端和服务端握手开销和提高性能（握手延迟），EMQX 默认给客户端发送 NST 包， 有效时性为 2 小时。&lt;/p&gt;
&lt;p&gt;0 RTT 也支持 early data，相比于 1 RTT 需要握手完成后才可进行应用层传输，0 RTT 的 early data 可以在第一个包上带上应用层数据，用于快速恢复或重启应用层业务。但由于 0 RTT 的 early data 不能防范重放攻击， 因此 QUIC 建议不要在 0 RTT 上携带会改变应用状态的数据。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;EMQX 默认不支持 early data，此测试只用于对比验证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试结果表明如果 MQTT 层协议设计得当，在完成首次握手后，QUIC 表现优于纯 TCP。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/ee6b0475d2fff3f9902fef578cc76c56.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;MQTT over QUIC&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/ee6b0475d2fff3f9902fef578cc76c56.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/ee6b0475d2fff3f9902fef578cc76c56.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/ee6b0475d2fff3f9902fef578cc76c56.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/263e2bfe8e8ba9133e756365365c9c91.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;MQTT over QUIC&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/263e2bfe8e8ba9133e756365365c9c91.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/263e2bfe8e8ba9133e756365365c9c91.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/263e2bfe8e8ba9133e756365365c9c91.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;连接-重连时服务器资源使用&quot;&gt;连接/重连时服务器资源使用&lt;/h3&gt;
&lt;p&gt;测试新连接与断线重新连接不同过程中服务器 CPU 和内存的占用情况，以对比 TLS，QUIC 1 RTT 和 0 RTT 握手时资源开销。测试结果表明 QUIC 的 CPU 和内存使用均优于 TLS，但是重建连接耗费带宽比 TLS 多。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;测试项目&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;QUIC&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;TLS&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CPU (首次连接)&lt;/td&gt;
&lt;td&gt;~60%&lt;/td&gt;
&lt;td&gt;~80%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU(重连)&lt;/td&gt;
&lt;td&gt;~65% ¹&lt;/td&gt;
&lt;td&gt;~75%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内存最高使用&lt;/td&gt;
&lt;td&gt;9 GB&lt;/td&gt;
&lt;td&gt;12 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络带宽使用(Trans+Recv)&lt;/td&gt;
&lt;td&gt;峰值 100Mb ²&lt;/td&gt;
&lt;td&gt;峰值 30Mb&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;&lt;p&gt;注 1：主要为 MQTT 清除会话，踢开旧连接的额外开销&lt;/p&gt;
&lt;p&gt;注 2:：主要为传输路径 MTU 验证导致的大量 QUIC 初始化握手数据包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/eb0beee6063dbde95320368c193d946b.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;MQTT over QUIC 测试&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/eb0beee6063dbde95320368c193d946b.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/eb0beee6063dbde95320368c193d946b.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/eb0beee6063dbde95320368c193d946b.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;客户端地址迁移&quot;&gt;客户端地址迁移&lt;/h3&gt;
&lt;p&gt;此测试模拟大规模客户端地址迁移时业务层消息传输的变化。&lt;/p&gt;
&lt;p&gt;传统 TCP/TLS 客户端必须在应用层感知到断线才进行重连，此过程响应非常慢并伴有许多不必要的重传。 QUIC 的处理更加平顺，在传输层做到了保持连接不要求重连且让应用层无感（如果有需要应用层也可以订阅地址的变化）。&lt;/p&gt;
&lt;p&gt;QUIC 在客户端源 IP 地址/端口变化情况下，消息发送无任何影响。而 TLS 连接在变化后出现消息发送中断现象，即使客户端可以通过重连机制重新连接到 EMQX 上，但中间时间窗口将无法进行任何操作。&lt;/p&gt;
&lt;p&gt;这一结果表明 QUIC 非常适合用在网络经常需要切换的环境。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/26bca0a052ea8717e9d8f5343b80acd9.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;MQTT over QUIC 测试&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/26bca0a052ea8717e9d8f5343b80acd9.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/26bca0a052ea8717e9d8f5343b80acd9.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/26bca0a052ea8717e9d8f5343b80acd9.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;网络丢包测试&quot;&gt;网络丢包测试&lt;/h3&gt;
&lt;p&gt;测试在弱网条件下数据传输情况。我们分别做了 3 次测试：EMQX terminated TCP/TLS，QUIC 以及 nginx terminated TCP/TLS。&lt;/p&gt;
&lt;p&gt;测试场景：EMQX 以 20K/s 的速率发布 QoS 1 消息，在此过程中注入网络错误：20% 乱序（发送端与接受端包的顺序不一致），10% 丢包，QUIC 测试中还额外增加每 30 秒一次的网络切换干扰。&lt;/p&gt;
&lt;p&gt;在此情况下 QUIC 服务端接收的数据稍微有所抖动，但不丢失消息；而 TLS 出现因网络环境差而导致的拥塞、丢包。此项结果表明 QUIC 在弱网环境下可以提供可靠的传输。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/dae1f833b20fc71eeccc05dedcb9d5ae.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;MQTT over QUIC 测试&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/dae1f833b20fc71eeccc05dedcb9d5ae.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/dae1f833b20fc71eeccc05dedcb9d5ae.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/dae1f833b20fc71eeccc05dedcb9d5ae.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/6181a275b718164c16fc961da2488e0a.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;MQTT over QUIC 测试&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/6181a275b718164c16fc961da2488e0a.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/6181a275b718164c16fc961da2488e0a.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/6181a275b718164c16fc961da2488e0a.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;黄圈标记中我们去除了网络错误，可以看到 TLS 的收发恢复正常收发，包数量一致没有堆积，而 QUIC 只是从轻微抖动变得更平滑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;更便捷的使用-mqtt-over-quic-sdk&quot;&gt;更便捷的使用：MQTT over QUIC SDK&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nanomq/NanoSDK/&quot;&gt;NanoSDK&lt;/a&gt; 0.6.0 基于 MsQuic 项目率先实现了第一个 C 语言的 MQTT over QUIC SDK。&lt;/p&gt;
&lt;p&gt;NanoSDK 通过为 NNG 的传输层增加 QUIC 支持，使 MQTT、nanomsg 等协议能够从 TCP 转为 UDP，从而提供更好的物联网连接体验。其内部将 QUIC Stream 和 MQTT 连接映射绑定，并内置实现了 0 RTT 快速握手重连功能。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;消息示例代码请参考 &lt;a href=&quot;https://github.com/nanomq/NanoSDK/blob/main/demo/quic/client.c&quot;&gt;NanoSDK QUIC Demo&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们近期也将基于 NanoSDK 进行封装并陆续推出 Python、Go 等语言的 SDK，方便更多用户尽快体验到 MQTT over QUIC 的优势能力。&lt;/p&gt;
&lt;p&gt;同时，相关的 SDK 将支持 QUIC fallback，当 QUIC 不可用时，连接层将自动切换为 TCP/TLS 1.2，确保各类网络环境下业务都能正常运行。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/113ee2b80e15463b1d45ba952c5f3e83.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;NanoSDK 与 EMQX 之间通过 QUIC 进行消息收发&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/113ee2b80e15463b1d45ba952c5f3e83.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/113ee2b80e15463b1d45ba952c5f3e83.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/113ee2b80e15463b1d45ba952c5f3e83.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;NanoSDK 与 EMQX 之间通过 QUIC 进行消息收发&lt;/center&gt;&lt;h2 id=&quot;未来的-emqx-quic&quot;&gt;未来的 EMQX QUIC&lt;/h2&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/f01ff156928f2969f197ae0a19f3e93a.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;未来的 EMQX QUIC&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/f01ff156928f2969f197ae0a19f3e93a.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/f01ff156928f2969f197ae0a19f3e93a.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/f01ff156928f2969f197ae0a19f3e93a.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结合 QUIC 特性和物联网场景，我们为 MQTT over QUIC 规划了诸多特性，如通过区分控制通道实现主题优先级设置，实现非可靠实时流传输以应对高频数据传输场景，以及灵活的主题和数据通道（Stream）映射以降低主题之间的干扰。未来的版本中将陆续呈现。&lt;/p&gt;
&lt;p&gt;EMQ 也正在积极推进 MQTT over QUIC 的标准化落地。继 2018 年成为 OASIS MQTT 技术委员会中目前为止唯一拥有投票权的中国公司并参与 5.0 协议标准制定后，EMQ 目前也已提交了 MQTT over QUIC 的相关草案。相信在不久的将来，MQTT 的底层协议将同时支持 TCP 与 QUIC，使整个物联网行业从中获益。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;可以看到，QUIC 非常适用于传统 TCP/IP 网络 UDP MTU 大小能够保证的弱网环境或者网络经常切换的环境。对于设备时刻处在移动中的物联网场景（如车联网、移动采集等），或是需要频繁断连不适合做长连接的场景（如设备需要定期休眠）来说，QUIC 都拥有巨大的潜力，是更为适合的底层协议选择，这也是 EMQX 5.0 引入 QUIC 支持的原因。&lt;/p&gt;
&lt;p&gt;MQTT over QUIC 在 EMQX 5.0 中的率先实现，让 EMQ 再次走在全球物联网消息服务器领域的前沿。EMQ 将始终坚持以不断的技术革新驱动产品持续的迭代升级，期待通过领先的产品为物联网领域带来基础设施保障和业务创新动力。&lt;/p&gt;
&lt;section class=&quot;promotion&quot;&gt;
    &lt;p&gt;
        现在试用 EMQX 5.0
    &lt;/p&gt;
    &lt;a href=&quot;https://www.emqx.com/zh/try?product=broker&quot; class=&quot;button is-gradient px-5&quot;&gt;立即下载 →&lt;/a&gt;
&lt;/section&gt;&lt;h2 id=&quot;本系列中的其它文章&quot;&gt;本系列中的其它文章&lt;/h2&gt;

&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>