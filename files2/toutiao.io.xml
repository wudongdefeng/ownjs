<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f542bf12d98f3896ef1d82a2ed6025b9</guid>
<title>面向对象分析与设计的底层逻辑</title>
<link>https://toutiao.io/k/5x9px3n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;82&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.14106583072100312&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/qdzZBE73hWvNG9VjIS9sOow1MoYQgibicAhyLCiagyqhMVMBR5LiaLDIwVjiayNbjG4682icRrJOrll5bkJu9kebAQHA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;面向对象是符合人认识事物的基本方法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;人是怎么认识事物的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在面向对象出现之前，已有面向过程的分析方法，为什么面向对象被提出了呢？究其本质原因，人们发现面向过程并不是按照人正常认识事物的方式去分析软件，那么人究竟是怎么认识事物的呢，Yourdon 在《面向对象的分析》一书中提到，人类认识事物是遵循分类学的原理，分类学主要包含三点：&lt;strong&gt;区分对象及其属性；区分整体对象及其组成部分；不同对象类的形成及区分。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们现在可以回想下我们认识事物的过程，是不是和分类学所提到的 3 个要点很相似，看到一个事物，大概会感知到它的组成结构是怎样的，形状是怎样的，属于什么分类。所以，人认识事物是以对象的视角切入的，然后赋于对象具体的概念，比如苹果、梨子、汽车等等概念名称。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;348&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6028225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWib691diaoVDCHG2xSZvT0gOTW1GpVJ2NN9hFbGVchdLxPiblk7U4D4icJTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;021&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;分类与分层的两种思维&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们面对的现实世界是非常复杂的，应对复杂事物的有一个重要的方法即是抽象，抽象在实际应用过程中，又体现在两种方法上：&lt;strong&gt;分层和分类&lt;/strong&gt;。分类即是将有差异的事物归类到不同的分组中，正如我们常听到的&quot;物以类聚、人以群分&quot;的道理一样，产生分类的原因有两点：一点是事物间的关联紧密程度，不需要将所有的事物都耦合在一起；另一点是人掌握事物是有局限的，只能掌握少量的要点，比如 5~7 个要点，超过了容易忘记。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;224&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.38705738705738707&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibdsFLxsxFqXX2X86vbo4c5vNTkNah6yq6zvd60mn9eHNCGNz5SDw9rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分层是通过不同的视角看事物，每一层的关注点是不一样的，这种关注点不同是由自己的视角造成的，比如我们理解计算机，并不需要深入到二进制电信号去理解计算机。层次特性在软件设计中我们经常遇到，比如计算机体系结构、TCP 七层协议等，层次特性有一个特点：越往上越具体、越往下越抽象，越往上的内容越不稳定，也即是容易变化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;229&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3954802259887006&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibCpvHaQf9I1DzuNqSxvGaiav2VCohm3VJODfia0ibfkBNs4jBWuUhMQwRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1416&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;问题域到解空间的映射&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们把需要解决的问题称之为问题域，或者问题空间，把解决方案称之为解空间。正向上一小节中提到的事物有层次特性，不同的人理解的事物是站在各自理解的视角，这样大家的理解、沟通并不一致的。如果我们看到的问题空间是表层的，那么基于浅层次理解设计出来的方案就会不稳定，可能下次有一个小变化导致方案需要重新设计。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;324&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5606435643564357&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWib9PpnBl5FqImxPb7dZjLzYHtJvMQjiaBkINNrXHEsNULfRstyKnkwZxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以把一个软件划分成三层：场景、功能和实体，场景层是经常会变的，比如发放优惠券场景就非常多，比如有天降红包领取优惠、分享有礼领取优惠券、新人注册领取优惠券等，这种场景的更迭随着业务的调整变化得非常快，因此场景层是不稳定的。功能支撑某一些的场景集合，对比场景，功能相对而言稳定些，就像前面提到的发放优惠券场景，本质就是给用户发放优惠券，只需要提供发放优惠券的功能即可，至于哪些场景来调用它并不关注，但功能还是基于场景的集合抽象出来的，如果场景场景类型变化了，功能也就随之变化，比如担保交易和预售交易就不一样。实体是稳定的，以担保交易和预售交易为例，它的订单模型大致是一样的，只是新增加了一些信息而已。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;253&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.43782837127845886&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibvbOVCTxVq5rsdfjfva9zBzxrq7l8U4ZQCchPluC5r4Pslu4LAV5XDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，我们希望从问题空间到解空间，大家看到的、理解的是一致的，而且看到的是问题的本质而非表象，往往场景、功能是不稳定的，而面向过程又是以功能驱动的，所以在易变化的场景下，它面临的问题就比较多。比较稳定的是问题空间中的实体对象，所以面向对象分析是现实的需要。面向过程和面向对象是两个不同的视角的分析方法：&lt;strong&gt;面向过程是一种归纳的分析方法，由外到内的过程；面向对象是一种演绎的分析方法，由内到外的过程。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;三个一致性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;软件开发会经历需要分析、概要设计、详细设计、编码、测试、上线主要阶段，我们不希望每块是割裂的，比如分析做完之后，做设计阶段又要重新去做分析的工作，那么这里面就涉及到一致性的问题，&lt;strong&gt;即需求到分析的一致性、分析到设计的一致性、设计到编码的一致性。&lt;/strong&gt;这样做的好处可以保证无信息失真，因此我们急需求一种分析设计方法能做到这一点，面向对象分析与设计就能做到，因此全流程是以对象作为分析与设计的目标，在最终编码中也都是对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;177&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3062438057482656&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibcWr3I3axuBlwPEAO516cT9IJPTZ2MJoXKdOe3L196Ha60ThL7P6c3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2018&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;05&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;面向对象的底层逻辑&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;提到面向对象，有部分人会提到封装、继承、多态等特性，然后这些并不是面向对象的本质特性，比如封装，面向过程中也有封装，多态面向过程也有体现，这些特性算不上面向对象特有的特性。&lt;strong&gt;面向对象的底层逻辑是基于现实事物做的抽象映射&lt;/strong&gt;：现实事物对应软件中的对象，我们讨论解空间能对应到问题空间中的对象，两者是一一直接映射的，其它的分析方法是问题空间到解空间的间接映射。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;203&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.35038084874863984&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibd1CSDaziazA4ic62xf4XtRicLRcZtv65kWxxn6ibTJk0mRVcqhVjCKpQOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1838&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;面向对象分析与设计的全景图&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;我们面临的问题是什么&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;从顶层看，我们要完成需求到编码的工作，然而从需求到编码又会经过多个阶段，如需求分析、方案设计等，从大的层面讲，我们主要遇到三个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;做什么的问题&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看似这是一个简单的问题，但在复杂的业务场景下，对做什么的理解太重要了，因为不同的人对需求的理解是不同的，比如最近做了一个项目，有一个业务判断规则是只针对跨境订单计税，最开始开发同学的理解是判断卖家类型是否是跨境卖家，然而到了测试阶段，发现大家对这个业务规则判断理解是不一致的，跨境订单跟卖家类型是没有关系的，真正的跨境订单计税场景是 shipTo（收货地址）和 shipFrom（发货地址）国家地址是不一样的。在大项项目中，涉及到多个团队之间的协同，这样的问题异常突出。而且从业务诉求到产品需求，再到技术方案，这其中是经过了 2 次变换，每次变换是不同的角色在里面，大家的认识也会不一样。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2. 怎么做的问题&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;落实到事情具体要怎么做时，往往大家并不会出大的问题，怎么做偏具体执行阶段，程序员往往在逻辑严密性上没多大的问题，往往出问题是在第一个问题上，相当于方向弄错了，所做的工作也是无用的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3. 方法指导的问题&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们往往希望不劳而获得到一种万能的方法，能够应对所有的问题，同时又看不起低级的方法，比如大部分人对用例分析方法嗤之以鼻，想要能体现技术水平高大上的方法。其实自上世纪 70、80 年代，软件的分析设计方法并没有太大的变化，而且在我们大学期间都学过，只是大家并不认为它是一种高大上的方法而已。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5625730994152047&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibUKvwSGaZgoibsl20Xnyq8Q164w54LT7TfUMbA7wdezwdWia8anxtTShA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;分析到设计的过程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在本节中，我们推导软件分析到设计的过程，由粗到细，最终落实到我们接触到的 UML 知识上。从需求提出到编码实现，这中间有两个关键问题：一是界定目标，即是定义清楚要做什么的问题，相当于是我们做事的方向、目标；二是具体如何做的问题，即通过怎样具体的方案支撑需求目标实现。因此，我们需要一种方法能够帮助我们界定目标和表示具体方案，而且是大家互认的一种通用的方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;59&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.10219675262655205&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibYkh2aOG7HGSgyEBLu0zszDj1bTwpMyuGq8TNNrbVGXg3AULW8ycfbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2094&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过用例图可以帮我们界定目标，用例中有三个关键要素：用户、场景和目标。比如交易下单是一个用例，它的用户是买家，场景包含下单成功和下单失败两个场景，用例的目标是买家可以购买心仪的商品。当用例目标确定了，相当于界定了目标，知道需求要做什么，这个过程要反复和业务方确认好，至到最终大家对目标的理解是一致的，方向对了，具体怎么做就好办了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体怎么做用时序图表示，画时序图需要注意的一点是顶层的对象层次要一致，不能有的对象表示具体的实体对象，有的表示系统对象，即对象的层级是一致的，要么大家都是系统，比如导购系统调用交易系统，交易系统调用支付系统，要么大家都是对象，比如商品、订单等。通过时序图可以看到一个完整功能的执行步骤，它就包含具体执行的细节，如正常流程、异常流程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;138&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2387774594078319&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibN5hG0kJIRiaZOxxJvd2952ajsnia5RllarTtQVjiaAbe75XU8VKEOFdUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2094&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实在上面有一个问题，在画时序图时要确定好对象，那么这个对象是怎么来的呢？它是由健壮性图分析出来的，它里面有三个关键的对象：一个是边界对象，这个比较好理解，比如UI界面就是边界对象；另一个是控制对象，即是控制业务流程的对象，如下单服务就可以看作是控制对象；实体对象即是问题空间中的业务对象，比如订单。画健壮性图是有规则的，一般是边界对象调用控制对象，控制对象产生实体对象，比如用户下单界面是边界对象，下单服务是控制对象，订单就是实体对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;120&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2079866888519135&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWib80NzXibsLiaibKgw0qTH5DXr0icsoh1hPNUj6ecE2u2XBcb7ZxvW8T4x3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2404&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong&gt;寻找对象之路&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;对象从哪里来&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在本文第一部分第三小节中已经提到，问题空间到解空间是一一映射，我们讨论解空间中的对象时，其实它映射到问题空间中的对象，而问题空间中的对象主要来源于业务概念、业务规则、关键事件。大部分的对象是显现的，我们通过理解业务能发现，有的对象是隐性的，需要我们持续对业务有更深的理解才能发掘出来。好的对象模型是需要经过多次迭代打磨出来的，并非一次就能设计得十全十美。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;发现对象的方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;在本文第二部分第二小&lt;/span&gt;节中已经提到寻找对象的方法，不过那还只是关键显现的对象，在本节中主要讲述完整对象发现的方法，主要方法分成四个步骤：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 通过健壮性图找到关键的实体对象；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 通过结构分析方法找出更多的实体对象；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 将对象组成有机的对象模型；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 最后通过用例走查对象模型是否完备。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;243&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.42065009560229444&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibaR9uLK0QUL36eN1k8CyxeJLEkoZnbzIG0hRDc2Wfeia5KKnosK7rSRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2092&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里以一个案例来说明发现对象的过程，案例是用户在下单时，在订单上展示税的金额。首先画出健壮性图，这里的边界对象是下单界面，控制对象有两个，一个是下单服务，另一个是计税服务，实体对象也有两个，一个是计税单，一个是订单。有了计税单和订单这两个实体对象后，接下来通过结构分析方法，分析出更多的对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;190&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3286573146292585&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibibShQhw4sU6PIzXvdqWh1TibE7XG6jI5go9yBV04M5ibz0iaX6rtiacVjRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1996&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对象都是有结构的，只要我们掌握了对象的结构，基本上就能掌握对象的概貌，因此我们从对象的结构入手，去分析对象内部的结构、对象关联的结构，实质上是从两个维度出发：一是从自身的角度出发，看自己内部还包含了哪些对象，如主订单包含了子订单；另一个是从外部的角度出发，看自己还与哪些对象相关联，如计税单与订单是有关联的。这种找对象的方法我称之为结构分析方法，因为本身结构又是事物本质的一种表达方式，比如化学分子结构决定化学现象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了更好地表达出对象的结构，我的一个经验是给对象下好定义，下定义可以从不同的维度，比如功能性维度、价值性维度、目的性维度、结构性维度等，这里可以从结构性的维度去给对象下定义。以计税单为例，可以给它下一个定义：计税单是将订单金额信息转成若干个标的物计税的单据模型，从这个定义中，我们可以看到计税单是与订单有关联关系的，另一个是计税单是包含了若干个标的物，我们可以画出计税单的对象模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;212&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.36681222707423583&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibhk6qdEIYsFMUhwkyUb6u7hFS4GOiapLTOnhOPqIPibla8x6gvKtiaUJ9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2290&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当对象模型画出来后，后续我们讨论业务基本上围绕这个对象模型去讨论业务问题的，比如商品标的物哪些金额要参与计税、计税金额的计算口径是怎样的，到这里，大家再体会下&quot;问题空间到解空间一一直接映射&quot;这句话，业务上的诉求也无非是哪些订单费用项要计税，计税的逻辑是怎样的，有可能在这个场景下要扣减金本位优惠，在另外一种场景下金本位优惠不需要扣减，基于对象模型与产品、测试同学讨论问题，大家都是处于同一个维度的视角看问题，沟通理解成本会少很多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对象模型是一种可视化的表达，我们大部分的沟通问题是缺乏显性表达造成的，这句话可以这样理解，也可以那样理解，导致大家理解有偏差，现在用模型的形式沟通问题，很多偏差、歧义就消除了。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;组织对象结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们分析出一堆的对象后，还需要经过一定的组织，正如前面提到，人对事物理解是有局限的，不能一下子接受太多的事物，因此可以将它们分成一个个小的域，比如商品域、订单域、税务域等，这样当聚集一个问题时，可以只看某个子域里的对象模型即可。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;274&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.47396386822529224&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibkiam3PrD8X2h9DMicWydluj3zA7fjrkFmE9icUUTTibhX0olo9YeYjvoEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1882&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;04&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;如何分配职责&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;职责是怎么来的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;面向对象最难的点有两个：一个是找出对象；另一个是分配职责。UML 把职责定义为&quot;类元的契约或义务&quot;，因此职责的划分从本质来讲还是类元本身决定的，比如订单，它要提供订单渲染、订单创建、订单修改、订单查询的义务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;职责分为两类：一类是认知职责；另一类是行为职责。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对私有数据封装的认知。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对相关对象的认知。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对其能够导出或计算的事物的认识。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt; &lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;自己执行的行为，包括创建对象或计算。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;初始化其它对象的动作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;控制或协调其它对象的活动。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;分配职责的逻辑&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;上一小节中提到的职责有两类，认知职责是对象自身的认知范围，即它只能基于自身属性完成相应的职责，举一个例子，假如一主多子的订单，要计算总的订单金额，怎么分配职责呢？首先商品只能查到自身价格的信息，它的认识是基于商品 price 属性，一个子订单可以有多个商品，那么它也只能计算出子订单的金额信息，它的认知是基于 item 和 quantity两个属性，主订单包含所有子订单的信息，那么就可以计算出总的订单金额。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;414&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7155756207674944&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibGp8crv1FlwgEFjIvqhw7l3RrFPGg8f2qRLn8tesy68x2W1JlmqCoQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;886&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从上面的例子中我们可以看出，认知职责是基于对象属性的，正所谓&quot;不在其位、不谋其政&quot;，认知职责一定不会超过它的认识范围的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;行为职责是偏领域服务的，有的时候一个职责不属于某一个对象，比如转账，就是一个行为，让其它的职责承担并不合适，这类行为职责往往是一个显著的业务活动，比如订单渲染、订单创建就是行为职责而非认知职责。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分配职责一定要遵循&quot;信息专家&quot;模式，它的含义是将职责分配给具有完成该职责所需要信息的那个类，也即上面提到的认识产生职责。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;验证职责分配的合理性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们期望分配的职责满足&quot;高内聚、低耦合&quot;，怎么检验呢？我们再回过头来思考职责的定义：类元的契约或义务，换句话讲，职责是满足其它对象来调用的，这个就与我们画时序图的目的是一致的，每次发生一次调用，即意味着其它的对象要提供一个职责出来，因此我们可以在时序图中看对象间的调用频次，如果一个对象被调用得非常频繁，有可能这个对象承担了太多的职责，是不是可以对其拆分，把职责分配一部分出去。因此，对象职责分配并不是一蹴而就的，需要不断审视、检验。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分配职责是要遵循一定的原则，如创建者模式、信息专家模式、纯虚构模式等，这些原则会在下一篇中单独去讲。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;05&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong&gt;案例&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;案例背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这里举一个例子，说明面向过程和面向对象在分析、编写代码的差异性，计税需要判断是否满足计税规则，比如虚拟商品不计税（手机充值之类）、有些免税地址不计税、小 B 买家也不计税等，因此需要提供一个计税过滤判断逻辑。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;常规面向过程实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;面向过程的思路很简单，提供一个过滤方法依次处理下面逻辑：过滤虚拟商品计税请求、过滤免税地址计税请求、过滤小 B 买家计税请求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;62&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.10727969348659004&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibZ0fjQUlPay3vGF1xGCd1ko8deibiae6O9FxWrpDMqKibmN2VCLxQljtOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2088&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;filter&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;List&amp;lt;TaxCalculateRequest&amp;gt; request&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     filterVirtualItem(request);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     filterOuterIsland(request);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     filterPurchaseType(reqeust);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;面向对象实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;面向过程是从过程视角或者是功能视角分析问题，而面向对象是从对象的视角分析问题，过滤计税请求是计税过滤器判断计税请求是否满足计税规则，这里就包含了两个对象：计税过滤器和计税规则，判断是否满足计税要求这个职责应该是在具体的计税规则处理器中，比如是否是小 B 买家等，因此我们可以画出对象模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;406&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7027491408934707&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibdicia8Yicxp31E1thP5dqw7f1592CWPlxCULaaDjt5vibD5iaqUpLOG0upA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1164&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关键代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AbstractRuleHandler&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;handler&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;TaxCalculateRequest request&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AbstractRuleHandler&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TaxCaluclateFilter.register(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;06&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在文章中提到，面向对象的底层逻辑是基于现实事物做的抽象映射，重要的不是要面向对象具体技术的使用上，而是分析问题的思维上，这是最难的，它最大的好处是问题空间到解空间是一一直接映射的，请注意是一一直接映射，它意味着我们在讨论方案的时候，完全可以映射到问题空间，如果是间接映射，也就意味着设计的方案后面会面临重新设计的可能性，因为它是基于场景或功能做出的归纳设计，而且是表层的设计。真正掌握了面向对象分析和设计的方法，也体会到其中的益处，对理解业务、方案设计、编码开发都有好处。&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;

          

          



                    
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2ce69140adaa47c26eef2a758a4dfb7f</guid>
<title>Binlog 的三个业务应用场景</title>
<link>https://toutiao.io/k/wzfse2x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;点击上方&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&amp;amp;mid=2247487217&amp;amp;idx=1&amp;amp;sn=a6428305479760448199d89eecc343f3&amp;amp;chksm=fcaed4edcbd95dfb9e00745d2a46601f62d22063ee1927f00d0b9968f1580a2f8af6d4fbcc30&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;匠心零度&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;匠心零度&lt;/span&gt;&lt;/a&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，选择“&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&amp;amp;mid=2247494117&amp;amp;idx=1&amp;amp;sn=318b3aa32d9346c6bd770f1f878c1e67&amp;amp;chksm=fcad33f9cbdabaef591910f357a32137e4ea1525b80cd482c0cf2bf64b5ab368388b52779c7e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;设为星标&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;设为星标&lt;/span&gt;&lt;/a&gt;&lt;span&gt;”&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;做积极的人，而不是积极废人&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;574&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;336&quot; data-ratio=&quot;0.667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1QxwhpDy7ia01DUzEDwHib7nmlsj2eMxSz4lSyYt7unicX7ichfVJztgeXjV4nvzBia4qYsYBZyU7Lhiaib3J1vqvNLqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot; title=&quot;&quot;/&gt;&lt;span&gt;来源 | www.cnblogs.com/kingszelda/p/8362612.html&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;binlog是mysql的一种二进制日志文件，用来记录数据的变化。mysql使用binlog进行主从复制，如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1QxwhpDy7ia16ZA0zg2MgrlZCw3sI4pjzbiccD37SdzoIgYX5l5V67N9nuruZA9B0Gm1qQJFolhl7EXH8EPuhaew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.41955445544554454&quot; data-w=&quot;808&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端向master的mysql sever写入数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当数据发生变化时，master将变更的数据记录写入到二进制文件中，即binlog。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;slave订阅了master的binlog，所以会通过一个I/O THREAD与master的DUMP THREAD进行通信，同步binlog&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;I/O THREAD读取到binlog后会吸入到relay log中，准备重放。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;slave会通过SQL THREAD读取relay log，重放数据的改动并执行相应的改动。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有几点需要注意：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主从复制不是强一致性，只能保证最终一致&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;master配合binlog复制会影响性能，所以尽量不要在master上挂太多的slave，如果对时间要求不高，可以在slave上挂slave&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍了mysql中应用binlog的场景，而我们的业务可以伪装成master的slave节点，感知数据的变化，这就给了我们很多的业务运用空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经常有这样一个场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原来业务是一个很单一的系统，所以表也在一起。随着业务的发展，系统开始拆分，总有一些表是各个业务都关注的表，但是对相关的字段的运用场景不同，所以这样一份元数据怎样更好的为各个系统服务就成了问题。当然，多写或者读写分离可以从物理节点上减少对数据服务器的压力，但是对业务并没有做到足够的支持，因为这些表都是一样的。因此我们可以通过binlog进行数据异构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1QxwhpDy7ia16ZA0zg2MgrlZCw3sI4pjzehqHYrnId5njaicQdHHv8RsnqOGm6p4QITr0rpLkRDJZkia1d464reibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6071829405162739&quot; data-w=&quot;891&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，订单系统生成订单后，通过binlog可以解析生成用户维度的订单信息供用户中心查询、商户维度订单表供运营管理，以及搜索系统的搜索数据，提供全文搜索功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，我们就通过原始的订单数据异构到三个系统中，提供了丰富的数据访问功能。不仅从节点上降低了数据服务器的压力，数据表现形式也更贴近自己的服务，减少不必要的字段冗余。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于高并发的系统，数据库往往是系统性能的瓶颈，毕竟IO响应速度是远远小于电子的运算速度的。因此，很多查询类服务都会在CPU与数据库之间加上一层缓存。即现从缓存获取，命中后直接返回，否则从DB中获取并存入缓存后返回。而如果原始数据变化了但缓存尚未超时，则缓存中的数据就是过时的数据了。当数据有变更的时候主动修改缓存数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1QxwhpDy7ia16ZA0zg2MgrlZCw3sI4pjzRnIQ0V9Ow2fHRR1bUcRYXYxQ5y0EJCB5EpAUL11S4bn0dpKvQh3x6g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.822992700729927&quot; data-w=&quot;548&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端更改了数据之后，中间件系统通过binlog获得数据变更，并同步到缓存中。这样就保证了缓存中数据有效性，减少了对数据库的调用，从而提高整体性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有这样一个场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多系统依赖同一块重要数据，当这些数据发生变化的时候，需要调用其他相关系统的通知接口同步数据变化，或者mq消息告知变化并等待其主动同步。这两种情况都对原始系统造成了侵入，原始系统改一块数据，并不想做这么多其他的事情。所以这时候可以通过binlog进行任务分发。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1QxwhpDy7ia16ZA0zg2MgrlZCw3sI4pjzTzgichdicwuSCyXR1q2cicQ6p0ib2ic3wzO87aNTs39NCvPEsL8eIn9qaNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6877697841726619&quot; data-w=&quot;695&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当原始业务系统修改数据后，不需要进行其他的业务关联。由调度系统读取binlog进行相应的任务分发、消息发送以及同步其他业务状态。这样可以将其他业务与原始业务系统解耦，并从数据的角度将所有管理功能放在了同一个调度系统中，责任清晰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;binlog是mysql提供的数据同步机制，很好的解决了主从分离、读写库分离等业务。而我们可以构建一个中间件系统，“伪造”成master的一个slave。当读取了binlog中的数据变化后，根据相应的业务场景做各种业务处理。而目前我接触到的最常见的就是第一个场景——数据异构，可以异构到其他表中，也可以异构到其他数据引擎中，比如Elastic Search。&lt;/p&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template-id=&quot;1480331&quot; data-mpa-category=&quot;收藏&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89715&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template-id=&quot;1252&quot; data-mpa-category=&quot;divider&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89428&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;END&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;如果读完觉得有收获的话，欢迎点【好看】，关注【匠心零度】，查阅更多精彩历史！！！&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2NjIzNDk5NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/1QxwhpDy7ia24jYyJAhtYn1117uszVQ1vsZLWka7iaESAkCwzu7M3qseH4dtN0jWic5uR9jTBvyDy9vozfgmwFYFg/0?wx_fmt=png&quot; data-nickname=&quot;匠心零度&quot; data-alias=&quot;jiangxinlingdu&quot; data-signature=&quot;以匠心，铸非凡!看零度如何一步一步实践过来，java技术干货及实践（重点分享JVM、并发、全链路调优）及一些感悟，内容多为原创，欢迎关注！&quot; data-from=&quot;1&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;让我“&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;好看&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;” &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/kw2nrMk65scprt048NlNbq4wEMicKRhkt63RdNGIiaNLqIzDKYz5hXvVsfibs6WsaoNr1P5PhD0sBHwujeQDMaZeg/640?wx_fmt=gif&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          

          



                    
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>139157adc14cd71a22edfcd1c3da1127</guid>
<title>大厂基本功 | MySQL 三大日志 ( binlog、redo log 和 undo log ) 的作用？</title>
<link>https://toutiao.io/k/o1494l7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;日志 主要包括&lt;/span&gt;&lt;span&gt;错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 &lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（归档日志）和事务日志 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（重做日志）和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;undo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（回滚日志）。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8913043478260869&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcicgpjaDEJiaMWSNNydat2Qb9ldZFiaHjW2G3ert2lEh25W9t7auRNuPQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;今天就来聊聊 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（重做日志）、&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（归档日志）、两阶段提交、&lt;/span&gt;&lt;code&gt;&lt;span&gt;undo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; （回滚日志）。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（重做日志）是&lt;/span&gt;&lt;code&gt;&lt;span&gt;InnoDB&lt;/span&gt;&lt;/code&gt;&lt;span&gt;存储引擎独有的，它让&lt;/span&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;拥有了崩溃恢复能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如 &lt;/span&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 实例挂了或宕机了，重启时，&lt;/span&gt;&lt;code&gt;&lt;span&gt;InnoDB&lt;/span&gt;&lt;/code&gt;&lt;span&gt;存储引擎会使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;恢复数据，保证数据的持久性与完整性。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4753593429158111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcciaRLsYIPgR0Em5iapjSQNicuMTS2UOSCAcGXyW0icsNSLica5c0icPWfJCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Buffer Pool&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后续的查询都是先从 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Buffer Pool&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中找，没有命中再去硬盘加载，减少硬盘 &lt;/span&gt;&lt;code&gt;&lt;span&gt;IO&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 开销，提升性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更新表数据的时候，也是如此，发现 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Buffer Pool&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 里存在要更新的数据，就直接在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Buffer Pool&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 里更新。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）里，接着刷盘到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件里。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5937172774869109&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHc5qxmP5ZyBbsKdRvOPjIyzdjcoqrNO6o1U14S3dZaXo1TZEj9p4qGSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;955&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;刷盘时机&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;InnoDB&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 存储引擎为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的刷盘策略提供了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;innodb_flush_log_at_trx_commit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数，它支持三种策略：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt; ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;1&lt;/strong&gt; ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;2&lt;/strong&gt; ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;innodb_flush_log_at_trx_commit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数默认为 1 ，也就是说当事务提交时会调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;fsync&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对 redo log 进行刷盘&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另外，&lt;/span&gt;&lt;code&gt;&lt;span&gt;InnoDB&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 存储引擎有一个后台线程，每隔&lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 秒，就会把 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中的内容写到文件系统缓存（&lt;/span&gt;&lt;code&gt;&lt;span&gt;page cache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;），然后调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;fsync&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 刷盘。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6292798110979929&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHc9t4adibM6KgLBrsibSswO0dMMiazbtHVoYB6VIlPIPj8QaysNnKKpsRrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;847&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也就是说，一个没有提交事务的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记录，也可能会刷盘。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;为什么呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为在事务执行过程 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记录是会写入&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，这些 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记录会被后台线程刷盘。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6055276381909548&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcicJTSTGGmpXoc4Au31aWJjudjCuiaCibSNzpyyyaY0evYR6B9z5o73YFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1194&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;除了后台线程每秒&lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;次的轮询操作，还有一种情况，当 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 占用的空间即将达到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;innodb_log_buffer_size&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 一半的时候，后台线程会主动刷盘。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面是不同刷盘策略的流程图。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;innodb_flush_log_at_trx_commit=0&lt;/span&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.653693407466243&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcZwWRyXpcicEEC28iaRMIdSR83AWkEO7lLo4ibB6gPSu8dQTDc6sAzI09g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1259&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为&lt;/span&gt;&lt;code&gt;&lt;span&gt;0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;时，如果&lt;/span&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;挂了或宕机可能会有&lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;秒数据的丢失。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;innodb_flush_log_at_trx_commit=1&lt;/span&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6559934318555009&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcHjUwkH7zST27ictFgcbAdmVWLicbPqia4FW9c61gLRRvBqEN4ICbibYjCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为&lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;时， 只要事务提交成功，&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;记录就一定在硬盘里，不会有任何数据丢失。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果事务执行期间&lt;/span&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;innodb_flush_log_at_trx_commit=2&lt;/span&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6130030959752322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcIesibvlicUzCtQIdTFcqdPFQiaH17XK5RpQJYDTL89Ts59xBAV5B6gByg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1292&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为&lt;/span&gt;&lt;code&gt;&lt;span&gt;2&lt;/span&gt;&lt;/code&gt;&lt;span&gt;时， 只要事务提交成功，&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中的内容只写入文件系统缓存（&lt;/span&gt;&lt;code&gt;&lt;span&gt;page cache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果仅仅只是&lt;/span&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;挂了不会有任何数据丢失，但是宕机可能会有&lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;秒数据的丢失。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日志文件组&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;硬盘上存储的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 日志文件不只一个，而是以一个&lt;strong&gt;日志文件组&lt;/strong&gt;的形式出现的，每个的&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo&lt;/span&gt;&lt;/code&gt;&lt;span&gt;日志文件大小都是一样的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如可以配置为一组&lt;/span&gt;&lt;code&gt;&lt;span&gt;4&lt;/span&gt;&lt;/code&gt;&lt;span&gt;个文件，每个文件的大小是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;1GB&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，整个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 日志文件组可以记录&lt;/span&gt;&lt;code&gt;&lt;span&gt;4G&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的内容。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9528023598820059&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcbts57G4JKe4ZVlxybic2QImaFqE92nhORrEnLzGQVyRwmBWuNWU1BVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;678&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在个&lt;strong&gt;日志文件组&lt;/strong&gt;中还有两个重要的属性，分别是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;write pos、checkpoint&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;write pos&lt;/strong&gt; 是当前记录的位置，一边写一边后移&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;checkpoint&lt;/strong&gt; 是当前要擦除的位置，也是往后推移&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每次刷盘 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记录到&lt;strong&gt;日志文件组&lt;/strong&gt;中，&lt;/span&gt;&lt;code&gt;&lt;span&gt;write pos&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 位置就会后移更新。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每次 &lt;/span&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 加载&lt;strong&gt;日志文件组&lt;/strong&gt;恢复数据时，会清空加载过的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记录，并把 &lt;/span&gt;&lt;code&gt;&lt;span&gt;checkpoint&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 后移更新。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;write pos&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;checkpoint&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 之间的还空着的部分可以用来写入新的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记录。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.437956204379562&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcMDy2iasjLM7wicxPGfx1M46VaWV0SwzmFSmaNUOrRZOGxGfC2ibuectzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;411&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 &lt;/span&gt;&lt;code&gt;&lt;span&gt;write pos&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 追上 &lt;/span&gt;&lt;code&gt;&lt;span&gt;checkpoint&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，表示&lt;strong&gt;日志文件组&lt;/strong&gt;满了，这时候不能再写入新的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记录，&lt;/span&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 得停下来，清空一些记录，把 &lt;/span&gt;&lt;code&gt;&lt;span&gt;checkpoint&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 推进一下。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8085106382978723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHc7d5egiamxBYQnhY714oG7T19MjDe0j77r1Xh15NFEF9IDssDobJbCYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;611&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redo log 小结&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相信大家都知道 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的作用和它的刷盘时机、存储形式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我们来思考一个问题：&lt;strong&gt;只要每次把修改后的数据页直接刷盘不就好了，还有 &lt;/strong&gt;&lt;strong&gt;&lt;code&gt;redo log&lt;/code&gt; 什么事？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它们不都是刷盘么？差别在哪里？&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt; Byte = &lt;span&gt;8&lt;/span&gt;bit&lt;br/&gt;&lt;span&gt;1&lt;/span&gt; KB = &lt;span&gt;1024&lt;/span&gt; Byte&lt;br/&gt;&lt;span&gt;1&lt;/span&gt; MB = &lt;span&gt;1024&lt;/span&gt; KB&lt;br/&gt;&lt;span&gt;1&lt;/span&gt; GB = &lt;span&gt;1024&lt;/span&gt; MB&lt;br/&gt;&lt;span&gt;1&lt;/span&gt; TB = &lt;span&gt;1024&lt;/span&gt; GB&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际上，数据页大小是&lt;/span&gt;&lt;code&gt;&lt;span&gt;16KB&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，刷盘比较耗时，可能就修改了数据页里的几 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Byte&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 数据，有必要把完整的数据页刷盘吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果是写 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，一行记录可能就占几十 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Byte&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，只包含表空间号、数据页号、磁盘文件偏移
量、更新值，再加上是顺序写，所以刷盘速度很快。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;其实内存的数据页在一定时机也会刷盘，我们把这称为页合并，讲 &lt;code&gt;Buffer Pool&lt;/code&gt;的时候会对这块细说&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;InnoDB&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 存储引擎。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而 &lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于&lt;/span&gt;&lt;code&gt;&lt;span&gt;MySQL Server&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 层。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不管用什么存储引擎，只要发生了表数据更新，都会产生 &lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 日志。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那 &lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 到底是用来干嘛的？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以说&lt;/span&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;数据库的&lt;strong&gt;数据备份、主备、主主、主从&lt;/strong&gt;都离不开&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，需要依靠&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;来同步数据，保证数据一致性。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45348837209302323&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcRuKRfgcDc7SPib24fgadppaDfs8ulYgicU4ACQKXRNkKesiciabeea0NzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1204&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;会记录所有涉及更新数据的逻辑操作，并且是顺序写。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;记录格式&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 日志有三种格式，可以通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog_format&lt;/span&gt;&lt;/code&gt;&lt;span&gt;参数指定。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;指定&lt;/span&gt;&lt;code&gt;&lt;span&gt;statement&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，记录的内容是&lt;/span&gt;&lt;code&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;语句原文，比如执行一条&lt;/span&gt;&lt;code&gt;&lt;span&gt;update T set update_time=now() where id=1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，记录的内容如下。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5159235668789809&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcqicSleQmTibTzOnYUPxkgTGIiaT49pOa04KktPRT0qxr5ia2sUrLdOHe3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;471&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同步数据时，会执行记录的&lt;/span&gt;&lt;code&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;语句，但是有个问题，&lt;/span&gt;&lt;code&gt;&lt;span&gt;update_time=now()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这里会获取当前系统时间，直接执行会导致与原库的数据不一致。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决这种问题，我们需要指定为&lt;/span&gt;&lt;code&gt;&lt;span&gt;row&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，记录的内容不再是简单的&lt;/span&gt;&lt;code&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;语句了，还包含操作的具体数据，记录内容如下。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34772182254196643&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcBia7VgFLmBl8ZHSU5Oy5G0NpcmibgbTatsCkicEZia3nRXX9jYzUK5vRLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;834&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;row&lt;/span&gt;&lt;/code&gt;&lt;span&gt;格式记录的内容看不到详细信息，要通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;mysqlbinlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;工具解析出来。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;update_time=now()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;变成了具体的时间&lt;/span&gt;&lt;code&gt;&lt;span&gt;update_time=1627112756247&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（&lt;strong&gt;假设这张表只有 3 个字段&lt;/strong&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样就能保证同步数据的一致性，通常情况下都是指定为&lt;/span&gt;&lt;code&gt;&lt;span&gt;row&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，这样可以为数据库的恢复与同步带来更好的可靠性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗&lt;/span&gt;&lt;code&gt;&lt;span&gt;IO&lt;/span&gt;&lt;/code&gt;&lt;span&gt;资源，影响执行速度。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以就有了一种折中的方案，指定为&lt;/span&gt;&lt;code&gt;&lt;span&gt;mixed&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，记录的内容是前两者的混合。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;会判断这条&lt;/span&gt;&lt;code&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;语句是否可能引起数据不一致，如果是，就用&lt;/span&gt;&lt;code&gt;&lt;span&gt;row&lt;/span&gt;&lt;/code&gt;&lt;span&gt;格式，否则就用&lt;/span&gt;&lt;code&gt;&lt;span&gt;statement&lt;/span&gt;&lt;/code&gt;&lt;span&gt;格式。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;写入机制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的写入时机也非常简单，事务执行过程中，先把日志写到&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog cache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，事务提交的时候，再把&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog cache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;写到&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;文件中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为一个事务的&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog cache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们可以通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog_cache_size&lt;/span&gt;&lt;/code&gt;&lt;span&gt;参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（&lt;/span&gt;&lt;code&gt;&lt;span&gt;Swap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;日志刷盘流程如下&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7071865443425076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHccTEu9aCYdbJvDia7GlAicluNticLicVCCDOVZs9094fWLXG7wkrhdibibFxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1308&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;上图的 fsync，才是将数据持久化到磁盘的操作&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;write&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;fsync&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的时机，可以由参数&lt;/span&gt;&lt;code&gt;&lt;span&gt;sync_binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;控制，默认是&lt;/span&gt;&lt;code&gt;&lt;span&gt;0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为&lt;/span&gt;&lt;code&gt;&lt;span&gt;0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的时候，表示每次提交事务都只&lt;/span&gt;&lt;code&gt;&lt;span&gt;write&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，由系统自行判断什么时候执行&lt;/span&gt;&lt;code&gt;&lt;span&gt;fsync&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7901716068642746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcxxU8AkNq4Kk5kibfppEaoxAaubbAXnlX9UX47oIp8kYpNABgqyV8gKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1282&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽然性能得到提升，但是机器宕机，&lt;/span&gt;&lt;code&gt;&lt;span&gt;page cache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;里面的 binglog 会丢失。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了安全起见，可以设置为&lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，表示每次提交事务都会执行&lt;/span&gt;&lt;code&gt;&lt;span&gt;fsync&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，就如同&lt;strong&gt;binlog 日志刷盘流程&lt;/strong&gt;一样。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后还有一种折中方式，可以设置为&lt;/span&gt;&lt;code&gt;&lt;span&gt;N(N&amp;gt;1)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，表示每次提交事务都&lt;/span&gt;&lt;code&gt;&lt;span&gt;write&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，但累积&lt;/span&gt;&lt;code&gt;&lt;span&gt;N&lt;/span&gt;&lt;/code&gt;&lt;span&gt;个事务后才&lt;/span&gt;&lt;code&gt;&lt;span&gt;fsync&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.776661514683153&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHca6Dt8rQs8icxLQDRr08dicLZvK9gGTpOPQqPYZPBoBnuzQ73gCgBg0ZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1294&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在出现&lt;/span&gt;&lt;code&gt;&lt;span&gt;IO&lt;/span&gt;&lt;/code&gt;&lt;span&gt;瓶颈的场景里，将&lt;/span&gt;&lt;code&gt;&lt;span&gt;sync_binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;设置成一个比较大的值，可以提升性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同样的，如果机器宕机，会丢失最近&lt;/span&gt;&lt;code&gt;&lt;span&gt;N&lt;/span&gt;&lt;/code&gt;&lt;span&gt;个事务的&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;日志。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;两阶段提交&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（重做日志）让&lt;/span&gt;&lt;code&gt;&lt;span&gt;InnoDB&lt;/span&gt;&lt;/code&gt;&lt;span&gt;存储引擎拥有了崩溃恢复能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（归档日志）保证了&lt;/span&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;集群架构的数据一致性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽然它们都属于持久化的保证，但是则重点不同。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在执行更新语句过程，会记录&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;与&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;两块日志，以基本的事务为单位，&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;在事务执行过程中可以不断写入，而&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;只有在提交事务时才写入，所以&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;与&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的写入时机不一样。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1669266770670828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcJLrJHAMsYdk8Kg2Y8icPZUXfkY6nal9K1WrE7qUrnLhdsp0VdBILTHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;回到正题，&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;与&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;两份日志之间的逻辑不一致，会出现什么问题？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们以&lt;/span&gt;&lt;code&gt;&lt;span&gt;update&lt;/span&gt;&lt;/code&gt;&lt;span&gt;语句为例，假设&lt;/span&gt;&lt;code&gt;&lt;span&gt;id=2&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的记录，字段&lt;/span&gt;&lt;code&gt;&lt;span&gt;c&lt;/span&gt;&lt;/code&gt;&lt;span&gt;值是&lt;/span&gt;&lt;code&gt;&lt;span&gt;0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，把字段&lt;/span&gt;&lt;code&gt;&lt;span&gt;c&lt;/span&gt;&lt;/code&gt;&lt;span&gt;值更新成&lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;语句为&lt;/span&gt;&lt;code&gt;&lt;span&gt;update T set c=1 where id=2&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设执行过程中写完&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;日志后，&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;日志写期间发生了异常，会出现什么情况呢？&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2394957983193278&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcYv9jnf9kz8WsdlKa6nUfNtjDiadibu7ClqmAb8ZEjHcCoOyyibf3HLyhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;没写完就异常，这时候&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;里面没有对应的修改记录。因此，之后用&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;日志恢复数据时，就会少这一次更新，恢复出来的这一行&lt;/span&gt;&lt;code&gt;&lt;span&gt;c&lt;/span&gt;&lt;/code&gt;&lt;span&gt;值是&lt;/span&gt;&lt;code&gt;&lt;span&gt;0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而原库因为&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;日志恢复，这一行&lt;/span&gt;&lt;code&gt;&lt;span&gt;c&lt;/span&gt;&lt;/code&gt;&lt;span&gt;值是&lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，最终数据不一致。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9079685746352413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcc5iczPKwF2FZwhV82y0dCJHbnA3unTOckh0S4wO21TiaYicicxNqvUicCTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;891&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决两份日志之间的逻辑一致问题，&lt;/span&gt;&lt;code&gt;&lt;span&gt;InnoDB&lt;/span&gt;&lt;/code&gt;&lt;span&gt;存储引擎使用&lt;strong&gt;两阶段提交&lt;/strong&gt;方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原理很简单，将&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的写入拆成了两个步骤&lt;/span&gt;&lt;code&gt;&lt;span&gt;prepare&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;commit&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，这就是&lt;strong&gt;两阶段提交&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9059929494712103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcqj9de9ibFuhbJuQhXLucOE8s9t880FpVhPtuSWTnSe0Aiad4aGByNZZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;851&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用&lt;strong&gt;两阶段提交&lt;/strong&gt;后，写入&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;时发生异常也不会有影响，因为&lt;/span&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;根据&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;日志恢复数据时，发现&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;还处于&lt;/span&gt;&lt;code&gt;&lt;span&gt;prepare&lt;/span&gt;&lt;/code&gt;&lt;span&gt;阶段，并且没有对应&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;日志，就会回滚该事务。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4604715672676838&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcWJT4YKdh9Rm5ibbGPd68iaTiaKs3Ktic408MHYQwDVnSsr8r7p3Dbib9tuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1442&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再看一个场景，&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;设置&lt;/span&gt;&lt;code&gt;&lt;span&gt;commit&lt;/span&gt;&lt;/code&gt;&lt;span&gt;阶段发生异常，那会不会回滚事务呢？&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.463859649122807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txrfh3m3uwZPfsiciaprZNIHcXyf4sFaEyMC4ib7GfS0FK4FRicPyCGOJVQwVyulHtxU73Ckxz6tRs97w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1425&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并不会回滚事务，它会执行上图框住的逻辑，虽然&lt;/span&gt;&lt;code&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是处于&lt;/span&gt;&lt;code&gt;&lt;span&gt;prepare&lt;/span&gt;&lt;/code&gt;&lt;span&gt;阶段，但是能通过事务&lt;/span&gt;&lt;code&gt;&lt;span&gt;id&lt;/span&gt;&lt;/code&gt;&lt;span&gt;找到对应的&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;日志，所以&lt;/span&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;认为是完整的，就会提交事务恢复数据。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;undo log&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据库事务四大特性中有一个是&lt;strong&gt; 原子性&lt;/strong&gt; ，具体来说就是 &lt;strong&gt;原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行&lt;strong&gt;回滚&lt;/strong&gt;，在 MySQL 中，恢复机制是通过 &lt;strong&gt;回滚日志（undo log）&lt;/strong&gt; 实现的，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果执行过程中遇到异常的话，我们直接利用 &lt;strong&gt;回滚日志&lt;/strong&gt; 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另外，&lt;/span&gt;&lt;code&gt;&lt;span&gt;MVCC&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的实现依赖于：&lt;strong&gt;隐藏字段、Read View、undo log&lt;/strong&gt;。在内部实现中，&lt;/span&gt;&lt;code&gt;&lt;span&gt;InnoDB&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 通过数据行的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;DB_TRX_ID&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Read View&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来判断数据的可见性，如不可见，则通过数据行的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;DB_ROLL_PTR&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 找到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;undo log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中的历史版本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Read View&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 之前已经提交的修改和该事务本身做的修改。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MySQL InnoDB 引擎使用 &lt;strong&gt;redo log(重做日志)&lt;/strong&gt; 保证事务的&lt;strong&gt;持久性&lt;/strong&gt;，使用 &lt;strong&gt;undo log(回滚日志)&lt;/strong&gt; 来保证事务的&lt;strong&gt;原子性&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;数据库的&lt;strong&gt;数据备份、主备、主主、主从&lt;/strong&gt;都离不开&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，需要依靠&lt;/span&gt;&lt;code&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;/code&gt;&lt;span&gt;来同步数据，保证数据一致性。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;作者：&lt;/span&gt;&lt;span&gt;佳幂小煜&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/qq_38482920/article/details/120727649&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjMxMTA5Mw==&amp;amp;mid=2651350048&amp;amp;idx=1&amp;amp;sn=8213f12052f855974af77b083321c98e&amp;amp;chksm=80f399fab78410ec952a9451b99fc0d90f799b091685b6aab15d97af28880b5e165705fb6637&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MySQL + JSON = 王炸！！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;MySQL + JSON = 王炸！！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjMxMTA5Mw==&amp;amp;mid=2651350122&amp;amp;idx=1&amp;amp;sn=e55075fd5f94cd106d5f20b8c47bfdad&amp;amp;chksm=80f399b0b78410a676739e98bb3e991d7e7adc3295769cf9ce8191fcf2b27e5d26b942d9735b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Mysql 数据库查询好慢，除了索引，还能因为什么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Mysql 数据库查询好慢，除了索引，还能因为什么？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjMxMTA5Mw==&amp;amp;mid=2651349772&amp;amp;idx=1&amp;amp;sn=bd5085774e26b448a4f1323a828e9efe&amp;amp;chksm=80f39ed6b78417c0c8dde54d65042e0e5071133ce11901ab47dd505963bfe70e4e12e446a1ee&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;mysql 主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;mysql 主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;↓推荐关注↓&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzA5ODM5MDU3MA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/DmibiaFiaAI4B3yECIF3LxR8ZMPVxnto79bB8LrraNT18VPT5aCHSDFGiczOnt4CYCQlBCWg5ykox33kcLydFc4jhA/0?wx_fmt=png&quot; data-nickname=&quot;数据分析与开发&quot; data-alias=&quot;DBDevs&quot; data-signature=&quot;「数据分析与开发」分享数据分析与开发相关技术文章、教程、工具&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;「数据分析与开发」分享数据分析、数据库开发相关技术文章、教程、工具&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ba2757bc20e6ffdbe471b0eeddf930ff</guid>
<title>Redis 定长队列的探索和实践</title>
<link>https://toutiao.io/k/eink2lm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;vivo 互联网服务器团队 - Wang Zhi&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、业务背景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;从技术的角度来说，技术方案的选型都是受限于实际的业务场景，都以解决实际业务场景为目标。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在我们的实际业务场景中，需要以游戏的维度收集和上报行为数据，考虑数据的量级，执行尽最大努力交付且允许数据的部分丢弃。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据上报支持游戏的维度的批量上报，支持同一款游戏128个行为进行批量上报。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据上报需要时效控制，上报的数据必须是上报时刻的前3分钟的数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;整体数据的业务形态如下图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41171875&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUaD2YKl7wc4HIwibibTLGq4LicnJ2AF11jNJ1AGTU8sIibJYibxqNyVnHt8ww/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、技术选型&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;从业务的角度来说包含数据的收集和数据的上报，我们把数据的收集比作生产者，数据的上报比作消费者，是一个典型的生产消费模型。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;生产消费模型在JVM进程内部通过队列+锁或者无锁的Disruptor来实现，在跨进程场景下通过MQ（RocketMQ/kafka）进行处理解耦。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是细化到具体业务场景来看，消息的消费有诸多限制，包括：&lt;strong&gt;游戏维度的批量行为上报，行为上报的时效限制，细化到各个技术方案选型进行对比。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;方案一&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;使用RocketMQ 或者Kafaka等消息队列来存储上报的消息，但是消费侧需要考虑在业务进程中按照游戏维度进行聚合，其中技术细节涉及按照游戏维度进行拆分，在满足消息时效性和批量性的前提下触发上报。在这种方案下消息中间件扮演的角色本质上消息的中转站，&lt;strong&gt;没有解决任何业务场景中提及的游戏维度拆分、批量性和时效性。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方案二&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;在方案一的基础上，寻求一种技术方案来解决游戏维度的&lt;strong&gt;消息分组、批量消费 、时效性&lt;/strong&gt;。通过Redis的list结构来实现队列（进一步要求实现定长队列）来解决游戏维度的消息分组；通过Redis的list支持的Lrange来实现批量消费；通过业务侧的多线程来解决时效问题，针对高频的游戏使用单独的线程池进行处理，上述两个手段能够保证消费速度大于生产速度。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方案对比&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对比两种方案后决定使用Redis的实现了一个伪消息中间件：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;通过List对象实现定长队列来保存游戏维度的行为消息（以游戏作为key的List对象来保存用户行为）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过List来保存所有的存在行为数据的游戏列表；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过Set来进行去重判断来保证2中的List对象的唯一性。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;整体的技术方案如下图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7583826429980276&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUa9HpN09L4gpjF3GS6vzN6stn7UED7qf3GJdODkZiaHomneqYO6h3sBmw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;生产过程&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;步骤一：&lt;/strong&gt;游戏维度的某行为数据PUSH到游戏维度的队列当中。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;步骤二：&lt;/strong&gt;判断游戏是否在游戏的集合Set中，如果在就直接返回，如果不在进行步骤三。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;步骤三：&lt;/strong&gt;往游戏列表中PUSH游戏。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;消费过程&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;步骤一：&lt;/strong&gt;从游戏对象的列表中循环取出一款游戏。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;步骤二：&lt;/strong&gt;通过步骤一获取的游戏对象去该游戏对象的行为数据队列中批量获取数据处理。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、技术原理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在Redis的支持命令中，在List和Set的基础命令，结合Lua脚本来实现整个技术方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;消息数据层面，通过单独的List循环维护待消费的游戏维度的数据，每个游戏维度使用定长的List来保存消息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;消息生产过程中，通过结合List的llen+lpop+rpush来实现游戏维度的定长队列，保证队列的长度可控。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;消息消费过程中，通过结合List的lrange+ltrim来实现游戏维度的消息的批量消费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在整个执行的复杂度层面，需要保证时间复杂度在0(N)常量维度，保证时间可控。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 Lua 脚本&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;EVAL script numkeys key [key ...] arg [arg ...]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：取决于脚本本身的执行的时间复杂度。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; eval &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; key1 key2 first second&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;key1&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;key2&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;first&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;second&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Redis uses the same Lua interpreter to run all the commands.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Also Redis guarantees that a script &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; executed &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; an atomic way:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;no other script &lt;span class=&quot;code-snippet__keyword&quot;&gt;or&lt;/span&gt; Redis command will be executed &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; a script &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; being executed.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;This semantic &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; similar to the one of MULTI / EXEC.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;From the point of view of all the other clients the effects of a script are either still &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; visible &lt;span class=&quot;code-snippet__keyword&quot;&gt;or&lt;/span&gt; already completed.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;Redis采用相同的Lua解释器去运行所有命令，我们可以保证，脚本的执行是原子性的。作用就类似于加了MULTI/EXEC。&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Lua 脚本内多个命令以原子性的方式执行，保证了命令执行的线程安全。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Lua 脚本结合List命令实现定长队列，实现批量消费。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Lua 脚本仅支持单个key的操作，不支持多key的操作。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 List 对象&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LLEN key&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    计算&lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;的长度&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LPOP key [count]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    从&lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;的左侧移除元素&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(N)，N为移除元素的个数。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;RPUSH key element [element ...]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    从&lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;的右侧保存元素&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(N)，N为保存元素的个数。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LRANGE key &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(S+N)， S为偏移量&lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt;， N为指定区间内元素的数量。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    下标(&lt;span class=&quot;code-snippet__keyword&quot;&gt;index&lt;/span&gt;)参数 &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt; 和 &lt;span class=&quot;code-snippet__keyword&quot;&gt;stop&lt;/span&gt; 都以 &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; 为底，也就是说，以 &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; 表示列表的第一个元素，以 &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; 表示列表的第二个元素，以此类推。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    你也可以使用负数下标，以 &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt; 表示列表的最后一个元素， &lt;span class=&quot;code-snippet__number&quot;&gt;-2&lt;/span&gt; 表示列表的倒数第二个元素，以此类推。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;LTRIM&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;stop&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(N) &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; N &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; the &lt;span class=&quot;code-snippet__built_in&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;of&lt;/span&gt; elements &lt;span class=&quot;code-snippet__keyword&quot;&gt;to&lt;/span&gt; be removed &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; the operation.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    修剪(&lt;span class=&quot;code-snippet__keyword&quot;&gt;trim&lt;/span&gt;)一个已存在的 &lt;span class=&quot;code-snippet__keyword&quot;&gt;list&lt;/span&gt;，这样 &lt;span class=&quot;code-snippet__keyword&quot;&gt;list&lt;/span&gt; 就会只包含指定范围的指定元素。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3 Set 对象&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SADD key member [member ...]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    往&lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt;集合添加数据。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SISMEMBER &lt;span class=&quot;code-snippet__keyword&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;member&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    判断&lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt;集合是否存在元素。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、技术应用&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 生产消息&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;定义LUA脚本   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CACHE_NPPA_EVENT_LUA =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local retVal = 0 &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local key = KEYS[1] &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local num = tonumber(ARGV[1]) &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local val = ARGV[2] &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local expire = tonumber(ARGV[3]) &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;if (redis.call(&#x27;llen&#x27;, key) &amp;lt; num) then redis.call(&#x27;rpush&#x27;, key, val) &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;else redis.call(&#x27;lpop&#x27;, key) redis.call(&#x27;rpush&#x27;, key, val) retVal = 1 end &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;redis.call(&#x27;expire&#x27;, key, expire) return retVal&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;执行LUA脚本&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; data = &lt;span class=&quot;code-snippet__built_in&quot;&gt;JSON&lt;/span&gt;.toJSONString(nppaBehavior);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Long retVal = (Long)jedisClusterTemplate.eval(CACHE_NPPA_EVENT_LUA, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, NPPA_PREFIX + nppaBehavior.getGamePackage(), &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.valueOf(MAX_GAME_EVENT_PER_GAME), data, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.valueOf(NPPA_TTL_MINUTE * &lt;span class=&quot;code-snippet__number&quot;&gt;60&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;执行效果&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    实现固长队列的数据存储并设置过期时间&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35471204188481675&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUaEayVwcVUa0recLRu58SMWzyOTticewXXtPTIdKyBLic4L5Jia1ISUVfSQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 消费消息&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;定义LUA脚本&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    QUERY_NPPA_EVENT_LUA =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local data = {} &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local key = KEYS[1] &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local num = tonumber(ARGV[1]) &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;data = redis.call(&#x27;lrange&#x27;, key, 0, num) redis.call(&#x27;ltrim&#x27;, key, num+1, -1) return data&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;执行LUA脚本&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Integer batchSize = NppaConfigUtils.getInteger(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;nppa.report.batch.size&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; result = jedisClusterTemplate.eval(QUERY_NPPA_EVENT_LUA, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,NPPA_PREFIX + gamePackage, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.valueOf(batchSize));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;执行效果&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    取固定数量的对象，然后保留队列的剩余的消息对象。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过整合lrange+ltrim两个命令实现消息的批量消费。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过lua脚本保证上述命令的原子性执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11583924349881797&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUaIbOiaExz4e7EUPIVyOt2I4MTpiavKu1apJmxGAXhTzpvd46e9ZPw9Wbg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.3 注意事项&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Redis集群模式下，执行Lua脚本建议传单key，多key会报重定向错误。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在不同的Redis版本下，Lua脚本针对null的返回值处理不同，参考官方文档。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;消费者的消费过程中通过循环遍历游戏列表，然后根据游戏去获取对应的消息对象，但是不同的游戏对应的热度不同，所以在消费端我们通过配置的方式为热门游戏单独开启消费线程进行消费，相当于针对不同游戏配置不同优先级的消费者。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、线上效果&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3953125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUaibA2WaicSNf0GL5MMhA1ibmiaKpPVKic98PCObaYJIX90RWzKxA3KhgLLMQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3984375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUa6oqicBibiathXXHahbzbxApWSWrMicTPt0HzVIW5SRLD5DXzRfSaBynpOg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3984375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUamiaygbcaBh8df25OoibR3tj0csMickRCLd3F6Rvia02wZ5kBDcqn0gLYKQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;六、适用场景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;在描述完方案的原理和实现细节之后，进一步对适用的业务场景进行下总结。整体方案是基于redis的基本数据结构构建一个伪消息队列，用以解决&lt;strong&gt;消息的单个生产批量消费&lt;/strong&gt;的场景，通过多key形式实现消息队列的多Topic模式，重要的是能够借助于redis的原生能力在O(N)的时间复杂度完成批量消费。另外该方案也可以降级作为实现先进先出定长的日志队列。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;七、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;本文主要探索在特定业务场景下通过Redis的原生命令实现类MQ的功能，创新式的通过Lua脚本组合Redis的List的基础命令，实现了消息的分组，消息的定长队列，消息的批量消费功能；整体解决方案在线上环境落地并平稳运行，为特定场景提供了一种通用的解决方案。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;—— 活动推荐——&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6133333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOPR8SfKS29VgT4rFCBPxYhL4ytjzxic6xGWdMwuUlfsJkicjfA4TufP9wjM1MHf31Vu5iaB4TuIOTCfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;本文由高可用架构转载。技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMDU1MTE1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONl06YmHad4csRU93kcbJ76JIWzEAmOSVooibFHHkzfWzzkc7dpU4H06Wp9F6Z687vIghdawxvl47A/0?wx_fmt=png&quot; data-nickname=&quot;高可用架构&quot; data-alias=&quot;ArchNotes&quot; data-signature=&quot;高可用架构公众号。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;       &lt;/section&gt;&lt;/div&gt;

          

          



                    
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>58c4b89d9321dcd011300cdf3347bff5</guid>
<title>记一次 ClickHouse 性能测试</title>
<link>https://toutiao.io/k/2pzdh5q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工作场景中，我们会采集工厂设备数据用于智能控制，数据的存储用了 InfluxDB，随着数据规模越来越大，InfluxDB 的性能越来越差，故考虑引入 ClickHouse 分担 InfluxDB 大数据分析的压力，再加上我们业务上也用到了 MySQL ，所以本文就来对比下 MySQL、InfluxDB、ClickHouse 在千万数据量下的写入耗时、聚合查询耗时、磁盘占用等各方面性能指标。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结论先行&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终的结论是，直接使用 ClickHouse 官网提供的 6600w 数据集来做对比测试，在 MySQL、InfluxDB、ClickHouse 同样分配 4c16g 资源的情况下，ClickHouse 无论是导入速度、磁盘占用、查询性能都完全碾压 MySQL 和 InfluxDB，具体对比指标如以下表格：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;MySQL&lt;/th&gt;&lt;th&gt;InfluxDB&lt;/th&gt;&lt;th&gt;ClickHouse&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;导入耗时&lt;/td&gt;&lt;td&gt;大概耗时70分钟&lt;/td&gt;&lt;td&gt;大概耗时35分钟&lt;/td&gt;&lt;td&gt;75秒&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;磁盘空间&lt;/td&gt;&lt;td&gt;12.35 G&lt;/td&gt;&lt;td&gt;5.9 G&lt;/td&gt;&lt;td&gt;2.66 G&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全表count&lt;/td&gt;&lt;td&gt;24366 ms&lt;/td&gt;&lt;td&gt;11674 ms&lt;/td&gt;&lt;td&gt;100 ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全表max/min&lt;/td&gt;&lt;td&gt;27023 ms&lt;/td&gt;&lt;td&gt;26829 ms&lt;/td&gt;&lt;td&gt;186 ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全表平均值&lt;/td&gt;&lt;td&gt;24841 ms&lt;/td&gt;&lt;td&gt;12043 ms&lt;/td&gt;&lt;td&gt;123 ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全表方差&lt;/td&gt;&lt;td&gt;24600 ms&lt;/td&gt;&lt;td&gt;OOM&lt;/td&gt;&lt;td&gt;113 ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;复杂查询1&lt;/td&gt;&lt;td&gt;30260 ms&lt;/td&gt;&lt;td&gt;OOM&lt;/td&gt;&lt;td&gt;385 ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;复杂查询2&lt;/td&gt;&lt;td&gt;470 ms&lt;/td&gt;&lt;td&gt;200 ms&lt;/td&gt;&lt;td&gt;8 ms&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了确保测试结果相对准确，以上每条sql起码执行5次，然后取中间值。其中 InfluxDB 表现比想象中的要差，甚至还不如 MySQL，可能是数据样本和测试用例不太适合 InfluxDB 场景导致的，如果大家对测试结果有疑问，可以 &lt;code&gt;git clone [https://github.com/stone0090/clickhouse-test.git](https://github.com/stone0090/clickhouse-test.git)&lt;/code&gt;项目，完整验证以上对比全过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据库简介&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MySQL&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，属于 Oracle 旗下产品，是最流行的关系型数据库管理系统之一。它所使用的 SQL 语言是用于访问数据库的最常用标准化语言。它采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型和大型网站的开发都选择 MySQL 作为网站数据库。《高性能MySQL》一书中开篇明义讲到的最核心的一句话是“MySQL并不完美，但是却足够灵活”，它是架构中的万金油，庞杂非单一的项目中总会有它的用武之地。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InfluxDB&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InfluxDB 是一个由 InfluxData 公司开发的开源时序型数据库，专注于海量时序数据的高性能读、高性能写、高效存储与实时分析，在 DB-Engines Ranking 时序型数据库排行榜上位列榜首，广泛应用于DevOps监控、IoT监控、实时分析等场景。传统数据库通常记录数据的当前值，时序型数据库则记录所有的历史数据，在处理当前时序数据时又要不断接收新的时序数据，同时时序数据的查询也总是以时间为基础查询条件，并专注于解决以下海量数据场景的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;时序数据的写入：如何支持千万级/秒数据的写入；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时序数据的读取：如何支持千万级/秒数据的聚合和查询；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;成本敏感：海量数据存储带来的是成本问题，如何更低成本地存储这些数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ClickHouse&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ClickHouse 是 Yandex（俄罗斯最大的搜索引擎）开源的一个用于实时数据分析的基于列存储的数据库，其处理数据的速度比传统方法快 100-1000 倍。ClickHouse 的性能超过了目前市场上可比的面向列的 DBMS，每秒钟每台服务器每秒处理数亿至十亿多行和数十千兆字节的数据。它是一个用于联机分析（OLAP）的列式数据库管理系统（DBMS），简单介绍一下 OLTP 和 OLAP。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;OLTP：是传统的关系型数据库，主要操作增删改查，强调事务一致性，比如银行系统、电商系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OLAP：是仓库型数据库，主要是读取数据，做复杂数据分析，侧重技术决策支持，提供直观简单的结果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那 ClickHouse OLAP 适用场景有：1）读多于写；2）大宽表，读大量行但是少量列，结果集较小；3）数据批量写入，且数据不更新或少更新；4）无需事务，数据一致性要求低；5）灵活多变，不适合预先建模。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;环境准备&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在阿里云买一台 16c64g 的服务器，操作系统 centos 7.8，使用 sealos 一键安装 k8s，使用 helm 一键安装 mysql（5.7）、influxdb（1.8）、clickhouse（22.3） ，每个应用各分配 4c16g 的资源。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 下载 sealos&lt;/span&gt;&lt;br/&gt;$ wget https://github.com/labring/sealos/releases/download/v4.0.0/sealos_4.0.0_linux_amd64.tar.gz \&lt;br/&gt;&amp;amp;&amp;amp; tar zxvf sealos_4.0.0_linux_amd64.tar.gz sealos &amp;amp;&amp;amp; chmod +x sealos &amp;amp;&amp;amp; mv sealos /usr/bin&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 初始化一个单节点 Kubernetes&lt;/span&gt;&lt;br/&gt;$ sealos run labring/kubernetes:v1.24.0 labring/calico:v3.22.1 --masters [xxx.xxx.xxx.xxx] -p [your-ecs-password]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 去掉 master 的污点，允许安装应用到 master 和 control-plane&lt;/span&gt;&lt;br/&gt;$ kubectl taint nodes --all node-role.kubernetes.io/master-&lt;br/&gt;$ kubectl taint nodes --all node-role.kubernetes.io/control-plane-&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 获取 mysql、influxdb、clickhouse 一键安装 Helm-Charts&lt;/span&gt;&lt;br/&gt;$ wget https://github.com/stone0090/clickhouse-test/archive/refs/tags/v1.0.0.tar.gz&lt;br/&gt;$ tar -zxvf v1.0.0.tar.gz&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 安装 Kubernetes 包管理工具 Helm，以及 mysql、influxdb、clickhouse 3大数据库&lt;/span&gt;&lt;br/&gt;$ sealos run labring/helm:v3.8.2&lt;br/&gt;$ helm install mysql clickhouse-test-1.0.0/helm-charts/mysql/&lt;br/&gt;$ helm install influxdb clickhouse-test-1.0.0/helm-charts/influxdb/&lt;br/&gt;$ helm install clickhouse clickhouse-test-1.0.0/helm-charts/clickhouse/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据导入&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接使用 ClickHouse 官方提供的测试数据 https://clickhouse.com/docs/zh/getting-started/example-datasets/opensky，此数据集中的数据是从完整的 OpenSky 数据集中派生和清理而来的，以说明 COVID-19 新冠肺炎大流行期间空中交通的发展情况。它涵盖了自2019年1月1日以来该网络超过2500名成员看到的所有航班，总数据量有6600w。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 在服务器 /home/flightlist 目录执行以下命令，该目录会被挂载到 mysql-pod、influxdb-pod、clickhouse-pod 内&lt;/span&gt;&lt;br/&gt;$ wget -O- https://zenodo.org/record/5092942 | grep -oP &lt;span&gt;&#x27;https://zenodo.org/record/5092942/files/flightlist_\d+_\d+\.csv\.gz&#x27;&lt;/span&gt; | xargs wget&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 批量解压 flightlist.gz 数据&lt;/span&gt;&lt;br/&gt;$ &lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; flightlist_*.csv.gz; &lt;span&gt;do&lt;/span&gt; gzip -d &lt;span&gt;&quot;&lt;span&gt;$file&lt;/span&gt;&quot;&lt;/span&gt;; &lt;span&gt;done&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 将 csv 处理成 influxdb 导入所需的 txt 格式（此过程大概耗时1小时）&lt;/span&gt;&lt;br/&gt;$ python clickhouse-test-1.0.0/influxdb_csv2txt.py&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MySQL&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 进入 mysql pod&lt;/span&gt;&lt;br/&gt;$ kubectl &lt;span&gt;exec&lt;/span&gt; -it [influxdb-podname] -- bash&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 连上 mysql 建库、建表&lt;/span&gt;&lt;br/&gt;$ mysql -uroot -p123456&lt;br/&gt;$ use &lt;span&gt;test&lt;/span&gt;;&lt;br/&gt;$ CREATE TABLE `opensky` (`callsign` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`number` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`icao24` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`registration` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`typecode` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`origin` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`destination` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`firstseen` datetime DEFAULT NULL,`lastseen` datetime DEFAULT NULL,`day` datetime DEFAULT NULL,`latitude_1` double DEFAULT NULL,`longitude_1` double DEFAULT NULL,`altitude_1` double DEFAULT NULL,`latitude_2` double DEFAULT NULL,`longitude_2` double DEFAULT NULL,`altitude_2` double DEFAULT NULL,KEY `idx_callsign` (`callsign`),KEY `idx_origin` (`origin`),KEY `idx_destination` (`destination`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 导入数据（大概耗时70分钟）&lt;/span&gt;&lt;br/&gt;$ load data &lt;span&gt;local&lt;/span&gt; infile &lt;span&gt;&#x27;flightlist_20190101_20190131.csv&#x27;&lt;/span&gt; into table opensky character &lt;span&gt;set&lt;/span&gt; utf8mb4 fields terminated by &lt;span&gt;&#x27;,&#x27;&lt;/span&gt; lines terminated by &lt;span&gt;&#x27;\n&#x27;&lt;/span&gt; ignore 1 lines;&lt;br/&gt;&lt;span&gt;# 省略其他29条导入命令：load data local infile &#x27;flightlist_*_*.csv&#x27; into table opensky character set utf8mb4 fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27; ignore 1 lines;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 检查数据是否导入成功&lt;/span&gt;&lt;br/&gt;$ select count(*) from test.opensky;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InfluxDB&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 进入 influxdb pod&lt;/span&gt;&lt;br/&gt;$ kubectl &lt;span&gt;exec&lt;/span&gt; -it [influxdb-podname] -- bash&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 导入数据（大概耗时30分钟）&lt;/span&gt;&lt;br/&gt;$ influx -username &lt;span&gt;&#x27;admin&#x27;&lt;/span&gt; -password &lt;span&gt;&#x27;admin123456&#x27;&lt;/span&gt; -import -path=/tmp/flightlist/flightlist_20190101_20190131.txt -precision=ns;&lt;br/&gt;&lt;span&gt;# 省略其他29条导入命令：influx -username &#x27;admin&#x27; -password &#x27;admin123456&#x27; -import -path=/tmp/flightlist/flightlist_*_*.txt -precision=ns;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 检查数据是否导入成功&lt;/span&gt;&lt;br/&gt;$ influx -username &lt;span&gt;&#x27;admin&#x27;&lt;/span&gt; -password &lt;span&gt;&#x27;admin123456&#x27;&lt;/span&gt;&lt;br/&gt;$ select count(latitude_1) from test.autogen.opensky;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ClickHouse&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 进入 clickhouse pod&lt;/span&gt;&lt;br/&gt;$ kubectl &lt;span&gt;exec&lt;/span&gt; -it [clickhouse-podname] -- bash&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 连上 clickhouse 建库、建表&lt;/span&gt;&lt;br/&gt;$ clickhouse-client&lt;br/&gt;$ create database &lt;span&gt;test&lt;/span&gt;;&lt;br/&gt;$ use &lt;span&gt;test&lt;/span&gt;;&lt;br/&gt;$ CREATE TABLE opensky(callsign String,number String,icao24 String,registration String,typecode String,origin String,destination String,firstseen DateTime,lastseen DateTime,day DateTime,latitude_1 Float64,longitude_1 Float64,altitude_1 Float64,latitude_2 Float64,longitude_2 Float64,altitude_2 Float64) ENGINE = MergeTree ORDER BY (origin, destination, callsign);&lt;br/&gt;$ &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 导入数据（大概耗时75秒）&lt;/span&gt;&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; /tmp/flightlist&lt;br/&gt;$ &lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; flightlist_*.csv; &lt;span&gt;do&lt;/span&gt; cat &lt;span&gt;&quot;&lt;span&gt;$file&lt;/span&gt;&quot;&lt;/span&gt; | clickhouse-client --date_time_input_format best_effort --query &lt;span&gt;&quot;INSERT INTO test.opensky FORMAT CSVWithNames&quot;&lt;/span&gt;; &lt;span&gt;done&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 检查数据是否导入成功&lt;/span&gt;&lt;br/&gt;$ clickhouse-client&lt;br/&gt;$ SELECT count() FROM test.opensky;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;测试场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MySQL&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ mysql -uroot -p123456&lt;br/&gt;$ use test;&lt;br/&gt;-- 开启性能分析&lt;br/&gt;set profiling = 1;&lt;br/&gt;-- 查询磁盘空间&lt;br/&gt;select table_rows as `总行数`, (data_length + index_length)/1024/1024/1024 as `磁盘占用(G)` from information_schema.`TABLES` where table_name = &#x27;opensky&#x27;;&lt;br/&gt;-- 全表count&lt;br/&gt;select count(latitude_1) from opensky;&lt;br/&gt;-- 全表max/min&lt;br/&gt;select max(longitude_1),min(altitude_1) from opensky;&lt;br/&gt;-- 全表平均值&lt;br/&gt;select avg(latitude_2) from opensky;&lt;br/&gt;-- 全表方差&lt;br/&gt;select var_pop(longitude_2) from opensky;&lt;br/&gt;-- 复杂查询1：全表多个字段聚合查询&lt;br/&gt;select count(latitude_1),max(longitude_1),min(altitude_1),avg(latitude_2) from opensky;&lt;br/&gt;-- 复杂查询2：从莫斯科三个主要机场起飞的航班数量&lt;br/&gt;SELECT origin, count(1) AS c FROM opensky WHERE origin IN (&#x27;UUEE&#x27;, &#x27;UUDD&#x27;, &#x27;UUWW&#x27;) GROUP BY origin;&lt;br/&gt;-- 输出分析结果&lt;br/&gt;show profiles;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InfluxDB&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ influx -username &#x27;admin&#x27; -password &#x27;admin123456&#x27;&lt;br/&gt;$ use test;&lt;br/&gt;-- 耗时统计，queryReqDurationNs 是累计查询时间，2次任务的时间相减就是耗时&lt;br/&gt;select queryReq,queryReqDurationNs/1000/1000,queryRespBytes from _internal.&quot;monitor&quot;.httpd order by time desc limit 10;&lt;br/&gt;-- 查询磁盘空间&lt;br/&gt;select sum(diskBytes) / 1024 / 1024 /1024 from _internal.&quot;monitor&quot;.&quot;shard&quot; where time &amp;gt; now() - 10s group by &quot;database&quot;;&lt;br/&gt;-- 全表count&lt;br/&gt;select count(latitude_1) from opensky;&lt;br/&gt;-- 全表max/min&lt;br/&gt;select max(longitude_1),min(altitude_1) from opensky;&lt;br/&gt;-- 全表平均值&lt;br/&gt;select mean(latitude_2) from opensky;&lt;br/&gt;-- 全表方差&lt;br/&gt;select stddev(longitude_2) from opensky;&lt;br/&gt;-- 复杂查询1：全表多个字段聚合查询&lt;br/&gt;select count(latitude_1),max(longitude_1),min(altitude_1),mean(latitude_2) from opensky;&lt;br/&gt;-- 复杂查询2：从莫斯科三个主要机场起飞的航班数量&lt;br/&gt;SELECT count(latitude_1) AS c FROM opensky WHERE origin =~/^UUEE|UUDD|UUWW$/ GROUP BY origin;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ClickHouse&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ clickhouse-client&lt;br/&gt;$ use test;&lt;br/&gt;-- 耗时统计&lt;br/&gt;select event_time_microseconds,query_duration_ms,read_rows,result_rows,memory_usage,query from system.query_log where query like &#x27;%opensky%&#x27; and query_duration_ms &amp;lt;&amp;gt; 0 and query not like &#x27;%event_time_microseconds%&#x27; order by event_time_microseconds desc limit 5;&lt;br/&gt;-- 查询磁盘空间&lt;br/&gt;SELECT formatReadableSize(total_bytes) FROM system.tables WHERE name = &#x27;opensky&#x27;;&lt;br/&gt;-- 全表count&lt;br/&gt;select count(latitude_1) from opensky;&lt;br/&gt;-- 全表max/min&lt;br/&gt;select max(longitude_1),min(altitude_1) from opensky;&lt;br/&gt;-- 全表平均值&lt;br/&gt;select avg(latitude_2) from opensky;&lt;br/&gt;-- 全表方差&lt;br/&gt;select var_pop(longitude_2) from opensky;&lt;br/&gt;-- 复杂查询1：全表多个字段聚合查询&lt;br/&gt;select count(latitude_1),max(longitude_1),min(altitude_1),avg(latitude_2) from opensky;&lt;br/&gt;-- 复杂查询2：从莫斯科三个主要机场起飞的航班数量&lt;br/&gt;SELECT origin, count() AS c FROM opensky WHERE origin IN (&#x27;UUEE&#x27;, &#x27;UUDD&#x27;, &#x27;UUWW&#x27;) GROUP BY origin;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ClickHouse 为什么快&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、列式存储&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据是按列存储，数据即是索引；查询只访问涉及的列，降低系统I/O；每一列都由一个线程来处理，高效利用CPU资源；还为向量化执行做好了铺垫。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、数据压缩&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据压缩的本质是按照一定的步长对数据进行匹配扫描，当发现重复数据的时候就进行编码转换。因为是列式存储，所以数据特征很相似，所以数据中的重复项多，则压缩率越高，则数据体量越小，则磁盘I/O压力越小，则网络中传输越快。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、向量化执行引擎&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIMD（Single Instruction Multiple Data）即单条指令操作多条数据，它是通过数据并行以提高性能的一种方式，可以简单理解为在寄存器层面对程序中的数据做并行处理，Clickhouse 在能够提升计算效率的地方大量使用了 SIMD，通过使用 SIMD，基本上能带来几倍的性能提升。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4、多线程和分布式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式领域存在一条定律，计算移动比数据移动更加划算，这也是其核心所在，将数据的计算直接发放到数据所在的服务器，多机并行处理，再把最终的结果汇集在一起；另外 ClickHouse 也通过线程级别并行的方式为效率进一步提速，极致去利用服务器的资源。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5、多样的表引擎&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MergeTree 存储结构对写入的数据做排序然后进行有序存储，有序存储主要有两大优势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;列存文件在按块做压缩时，排序键中的列值是连续或者重复的，使得列存块的数据可以获得极致的压缩比；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储有序本身可以加速查询的索引结构，根据排序键中列的等值条件或者 rang 条件，我们可以快速找到目标所在的近似位置区间，并且这种索引结构是不会产生额外的存储开销。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MergeTree 是 ClickHouse 表引擎中最核心的引擎，其他引擎均以 MergeTree 引擎为基础，并在数据合并过程中实现了不同的特性，从而构成了 MergeTree 表引擎家族。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ClickHouse 的优缺点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：极致的查询分析性能，较低的存储成本，高吞吐的数据写入，多样化的表引擎，完备的 DBMS 功能；&lt;br/&gt;缺点：不支持事务，不支持真正的删除/更新，分布式能力较弱；不支持高并发，官方建议 QPS 为100；非标准的 SQL，join 的实现比较特殊，且性能不好；频繁小批量数据操作会影响查询性能；&lt;br/&gt;目前还没有一个 OLAP 引擎能够满足各种场景的需求，其本质原因是，没有一个系统能同时在查询效率、时效性、可维护性三个方面做到完美，只能说 ClickHouse 是为了极致查询性能做了一些取舍。&lt;br/&gt;ClickHouse 优缺点都很明显，是否采用还是要取决于和实际业务场景的契合度，适合自己的架构才是最好架构。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考引用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;识堂 | 笔记分享讨论社区，让知识说话&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InfluxDB优化配置项_sqtce的技术博客_51CTO博客&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;influxDB系列（二）--查看数据库的大小 - 立志做一个好的程序员 - 博客园&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Clickhouse技术分享_大数据_scalad_InfoQ写作社区&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>