<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>af7778062c07d071b10cb4bb566deca3</guid>
<title>Ghost 解决 jsdelivr 资源加载慢的问题</title>
<link>https://toutiao.io/k/x82yflm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;toc-content post tag-ghost-tag tag-network no-image&quot;&gt;
      &lt;h2 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;用了很久的自建 Ghost 博客系统不知道从哪个版本开始，页面加载速度忽然变慢了很多。看了下加载的资源，发现多了很多走 jsdelivr cdn 的资源，加载速度竟然长达半分钟。。。&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2023/01/image-10.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;本来选择自建博客系统的重要目的之一就是为了页面加载速度可控，尽量避免加载不可靠、容易被墙的第三方资源。结果没想到 Ghost 官方又在核心模块里引用了第三方的 CDN。&lt;/p&gt;&lt;p&gt;不过还好 Ghost 项目本身的配置化做的还是不错的，大年初六上班摸个鱼的时间解决了一下。&lt;/p&gt;&lt;h2 id=&quot;%E8%A7%A3%E5%86%B3&quot;&gt;解决&lt;/h2&gt;&lt;p&gt;仔细看了下，新加入的走 CDN 的资源主要是 会员系统（portal）+评论系统（comments）+页面搜索 （sodo-search），因此在某次支持这些系统的更新前都是没问题的。不过考虑到目前的主题已经集成了这些系统，所以这些功能也不能禁用掉。&lt;/p&gt;&lt;p&gt;参考 &lt;a href=&quot;https://forum.ghost.org/t/is-it-possible-to-disable-jsdelivr-cdn/31761&quot;&gt;Ghost Forum&lt;/a&gt; 的这篇讨论，可以通过在 config.[env].json 中修改配置，将 url 等替换成 self-hosted 的版本。不过这里的讨论中提到的配置来源并不清晰，在源码中搜索了一番发现了端倪（这里的 /var/lib/ghost 目录是我这 docker 里的 ghost 安装目录）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@1f7b379a87f4:/var/lib/ghost/current# grep -r &#x27;cdn.jsdelivr.net/ghost&#x27; *
core/shared/config/defaults.json:        &quot;url&quot;: &quot;https://cdn.jsdelivr.net/ghost/portal@~{version}/umd/portal.min.js&quot;,
core/shared/config/defaults.json:        &quot;url&quot;: &quot;https://cdn.jsdelivr.net/ghost/sodo-search@~{version}/umd/sodo-search.min.js&quot;,
core/shared/config/defaults.json:        &quot;styles&quot;: &quot;https://cdn.jsdelivr.net/ghost/sodo-search@~{version}/umd/main.css&quot;,
core/shared/config/defaults.json:        &quot;url&quot;: &quot;https://cdn.jsdelivr.net/ghost/comments-ui@~{version}/umd/comments-ui.min.js&quot;,
core/shared/config/defaults.json:        &quot;styles&quot;: &quot;https://cdn.jsdelivr.net/ghost/comments-ui@~{version}/umd/main.css&quot;,&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可见这些配置都来源于 &lt;code&gt;core/shared/config/defaults.json&lt;/code&gt; 这个文件，涉及到 CDN 的相关配置如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{

    ...

    &quot;portal&quot;: {
        &quot;url&quot;: &quot;https://cdn.jsdelivr.net/ghost/portal@~{version}/umd/portal.min.js&quot;,
        &quot;version&quot;: &quot;2.23&quot;
    },
    &quot;sodoSearch&quot;: {
        &quot;url&quot;: &quot;https://cdn.jsdelivr.net/ghost/sodo-search@~{version}/umd/sodo-search.min.js&quot;,
        &quot;styles&quot;: &quot;https://cdn.jsdelivr.net/ghost/sodo-search@~{version}/umd/main.css&quot;,
        &quot;version&quot;: &quot;1.1&quot;
    },
    &quot;comments&quot;: {
        &quot;url&quot;: &quot;https://cdn.jsdelivr.net/ghost/comments-ui@~{version}/umd/comments-ui.min.js&quot;,
        &quot;styles&quot;: &quot;https://cdn.jsdelivr.net/ghost/comments-ui@~{version}/umd/main.css&quot;,
        &quot;version&quot;: &quot;0.12&quot;
    },
    
    ...

 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了自托管这些文件，我们首先将这些文件下载到静态文件夹下，然后在想办法将 config.[env].json 配置好即可。&lt;/p&gt;&lt;p&gt;不过问题来了，静态文件夹有哪些？如果想当然的放在 &lt;code&gt;/var/lib/ghost/content/public&lt;/code&gt; 下，肯定是要吃瘪的。正解应该是要看下 &lt;code&gt;/var/lib/ghost/current/core/frontend/web/site.js&lt;/code&gt; 这里启动 express 的地方：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;module.exports = function setupSiteApp(routerConfig) {
    debug(&#x27;Site setup start&#x27;, routerConfig);

    const siteApp = express(&#x27;site&#x27;);

    //...
    
    // Serve sitemap.xsl file
    siteApp.use(mw.servePublicFile(&#x27;static&#x27;, &#x27;sitemap.xsl&#x27;, &#x27;text/xsl&#x27;, config.get(&#x27;caching:sitemapXSL:maxAge&#x27;)));

    // Serve stylesheets for default templates
    siteApp.use(mw.servePublicFile(&#x27;static&#x27;, &#x27;public/ghost.css&#x27;, &#x27;text/css&#x27;, config.get(&#x27;caching:publicAssets:maxAge&#x27;)));
    siteApp.use(mw.servePublicFile(&#x27;static&#x27;, &#x27;public/ghost.min.css&#x27;, &#x27;text/css&#x27;, config.get(&#x27;caching:publicAssets:maxAge&#x27;)));

    // Card assets
    siteApp.use(mw.servePublicFile(&#x27;built&#x27;, &#x27;public/cards.min.css&#x27;, &#x27;text/css&#x27;, config.get(&#x27;caching:publicAssets:maxAge&#x27;)));
    siteApp.use(mw.servePublicFile(&#x27;built&#x27;, &#x27;public/cards.min.js&#x27;, &#x27;application/javascript&#x27;, config.get(&#x27;caching:publicAssets:maxAge&#x27;)));

    // Comment counts
    siteApp.use(mw.servePublicFile(&#x27;built&#x27;, &#x27;public/comment-counts.min.js&#x27;, &#x27;application/javascript&#x27;, config.get(&#x27;caching:publicAssets:maxAge&#x27;)));

    // Member attribution
    siteApp.use(mw.servePublicFile(&#x27;built&#x27;, &#x27;public/member-attribution.min.js&#x27;, &#x27;application/javascript&#x27;, config.get(&#x27;caching:publicAssets:maxAge&#x27;)));

    // Serve site images using the storage adapter
    siteApp.use(STATIC_IMAGE_URL_PREFIX, mw.handleImageSizes, storage.getStorage(&#x27;images&#x27;).serve());
    // Serve site media using the storage adapter
    siteApp.use(STATIC_MEDIA_URL_PREFIX, storage.getStorage(&#x27;media&#x27;).serve());
    // Serve site files using the storage adapter
    siteApp.use(STATIC_FILES_URL_PREFIX, storage.getStorage(&#x27;files&#x27;).serve());
    
    //...
};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然，这里 public 文件夹下的文件都是单独配置绑定的，不是整个文件夹的绑定。额外添加文件的话是不会映射到外部路径上的。这样一来，我们只能绑定在 images , media , files 这些路径下。再 check 下这些具体的变量，就会得知这些路径映射到的外部路径：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@1f7b379a87f4:/var/lib/ghost/current# grep -r &#x27;STATIC_.*_URL_PREFIX&#x27; *
...
node_modules/@tryghost/constants/index.js:    STATIC_IMAGES_URL_PREFIX: &#x27;content/images&#x27;,
node_modules/@tryghost/constants/index.js:    STATIC_MEDIA_URL_PREFIX: &#x27;content/media&#x27;,
node_modules/@tryghost/constants/index.js:    STATIC_FILES_URL_PREFIX: &#x27;content/files&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我这里就选择放在  files 文件夹下，这里新建一个 self-host 文件夹：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@1f7b379a87f4:/var/lib/ghost/content/files/self-host# ls
comments-ui-0.12.css  comments-ui-0.12.min.js  portal-2.23.min.js  sodo-search-1.1.css  sodo-search-1.1.min.js&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于我是通过 docker-compose 部署，相比于修改 config 文件，直接通过环境变量配置更为方便，变量名跟 config 中的 json 格式一一对应，这里不得不夸奖下 Ghost 的配置自动映射做的挺方便：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;version: &quot;3.8&quot;
services:
  ghost:
  image: ghost:5.27
  container_name: &quot;ghost&quot;
  environment:
    ...
    portal__url: /content/files/self-host/portal-2.23.min.js
    sodoSearch__url: /content/files/self-host/sodo-search-1.1.min.js
    sodoSearch__styles: /content/files/self-host/sodo-search-1.1.css
    comments__url: /content/files/self-host/comments-ui-0.12.min.js
    comments__styles: /content/files/self-host/comments-ui-0.12.css
  ...&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;%E6%95%88%E6%9E%9C&quot;&gt;效果&lt;/h2&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2023/01/image-11.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首次加载速度直接从 30s 优化到了 300ms ，优化效果十分感人。。。&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fbefb364ecd0de9b1b3f1d321622be61</guid>
<title>杭州程序员从互联网跳央企，晒一天工作和收入，网友：待一年就废</title>
<link>https://toutiao.io/k/19z441x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-v-b51c2330=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;p&gt;&lt;span&gt;说到互联网，有些人兴奋有些人恐惧，这几年相信不少人都听说过，很多互联网行业的人都挣到了人生第1桶金，可是现在不少的互联网行业人纷纷都跳槽，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就比如接下一位男子，从互联网跳槽到了央企，而他分享的央企一天工作日常，更是让网友吐槽，到底怎么回事？请往下看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/t09VbpQYMctTibloAelvU8lRL9NCdadjKd9ibb2W4K5WXEYvomEU28iaUKgP49UP9MIC03ib7IzIxwR9Mr9OPoyDUg/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;471.69550173010384&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;369.8269896193772&quot; data-ratio=&quot;0.7855626326963907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jNmCBexQlC4ibIB7ggCKac5x5icDhx510T0DOqdibBBgWkI6DkLSkvf47rE6icqctMibalNJmtaPyvpOiadiapxgoAR1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;471&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原来是一位程序员，分享了自己从互联网跳槽到央企之后的工作流程，男子说自己是211本科外硕士，有3年工作经验，而从这个表格可以看出了，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他9:15到公司露面，就直接去公司食堂吃早餐，然后9:30~11:00一个半小时查看公司邮件，和处理各种邮件，而11:00~11:30划水刷手机，11:30就开始吃午餐，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而且是六菜一汤加甜品，而下午就更轻松，先做上级汇报的PPT，和技术演讲稿，然后就去公司食堂买杯咖啡，再去开会一小时，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后5:00~5:30就是到了吃晚餐的时候，还可以顺便看一下漂亮妹子就下班，下班之后顺便用手机邮件给外包公司发一封感谢信，而主要内容就是感谢他们996让项目能顺利上线，以后会有更多的项目跟他们合作，今晚还要继续奋斗加油！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/t09VbpQYMctTibloAelvU8lRL9NCdadjKT7e7je5fmOsm8uJuurQZtbIWdlHNCovy1LCic05dP45vwpGaolRwibKg/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;355&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;404&quot; data-ratio=&quot;1.1380281690140845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jNmCBexQlC4ibIB7ggCKac5x5icDhx510Thy00uic5OW76240Tc6VBHserxg0lzXonHrVmBia1Efv4CvQiad1A8EDgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;355&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相信这样的工作，不管换谁也非常羡慕，不仅吃的好，而且还待遇非常不错，最主要不用加班，5:30就可以下班了，工作可以说非常轻松，怪不得网友会吐槽说待个一年差不多就废了，不过在央企确实很稳定，不像在互联网公司少不了加班，而且工作还不能稳定，这是互联网不能比的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/t09VbpQYMctTibloAelvU8lRL9NCdadjK3UBlUdH5zf4z9ujwqiaFWZNEXjXI4f1YjKYfRZ53FbnE8JveSxxL5kg/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;525&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;391&quot; data-ratio=&quot;0.7428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jNmCBexQlC4ibIB7ggCKac5x5icDhx510TD8UtexypoXajcC0rMPNeS3IfA0jibux8EVabvGsta9xIOuq2Ud67AWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;525&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对此网友纷纷说出了自己的看法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有网友说：国企都这样呀，我也一样。所谓的废掉是神马……我没事儿就在办公室写代码看书，自我学习的那种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后没事看看股票、楼市。看看理财产品。所谓的废掉，根本不存在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/t09VbpQYMctTibloAelvU8lRL9NCdadjKbgVClH7UribnT7b1VvSg6MQCvmMnMtsqfWqXz9qsiaYPhtsvrYbI98Dw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;456&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;333&quot; data-ratio=&quot;0.7302631578947368&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jNmCBexQlC4ibIB7ggCKac5x5icDhx510TMR2pPZL71WBRictGBicjfZSkibwOqKholNhIGUMkhykp4K0MFGToRSZbw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;456&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也有网友说：食物链越靠上，越负有责任。如果仅仅满足于吃几餐好吃的饭，刷手机，看漂亮妹子，说几句浮夸的大话，这个境界真的太低了。你记住一点：国企领导都不是瞎子，他们肩负的社会责任需要有人分担。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有网友说不错，我之前在某大型国企呆了一年，一年本非技术35w现在为了成长平薪去了互联网公司发现一样闲，怀疑很多人说的加班都是骗人的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，我们再看一个从央企离职当程序员的真实故事，希望对大家有启发：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020年3月，我离开了工作两年多的大型央企单位，转行去了IT公司当程序员，目前在新单位工作已三个月。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本硕非985/211，2016年秋招时签了前东家，作为国内该行业的龙头企业，产业好、国家政策又支持，所以当初对他的期望很高。单位在沿海城市，父母也想让我出去看看，见见世面，自己也考虑该公司平台大、起点高，后期发展也会好些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公司属于制造业，为了能多挣钱，签工作的时候选择的岗位是技术支持，需要国内到处出差，出差补助加工资，每个月到手还可以。不过出差地点不固定，可能在这个城市一两年左右，那个城市一两年。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当初签的时候因为家附近城市有办事点，所以想着以后能申请在家附近上班。那会打听到在家附近城市上班可能调动比较困难，但我还是选择自己骗自己。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2017年毕业后进入公司，公司对于新员工的培养与关照很到位，相关福利与制度也很完善，感觉一切都很新鲜，入职培训比较密集且对业务的掌握要求比较高，由于上学期间接触该行业较少，培训期间对理论的掌握比较困难，压力也挺大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2017年12月，培训结束后新员工前往全国各地的项目点工作，我去的北京，刚去租着最廉价的房子，恰巧赶上大兴着火，相关政策说是要把底层人员赶出北京，清理危险房源，房子租金涨价、房源不好找，经过几次搬家后慢慢稳定下来了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当时新产品刚上线，工作强度很大，每天平均工作至少十五、六个小时。那年冬天，雪很大，而下雪天气对产品的性能危害很大，故障频发，同事们也都是硬着头皮干。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2018年春天，因为其他地方的项目慢慢展开了，我被派往长沙工作。如果说之前的工作是熟悉工作性质，接下来的工作是正儿八经的干活。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为是新项目、新团队，很多设计人员对产品也不是很清楚，只能靠我们现场的人慢慢摸索，平时既要室外作业，还要应对大量文件报告，任何一个环节出错，可能会遭到客户的投诉或者公司的考核，每天高强度工作12个小时，连续工作了小半年才修了一次假。这段时期对工作流程有了大体的认识，但技能水平提升很少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2018年9月，因为广州开展新项目，我离开了那个团队。在广州又是全新的客户、全新的团队。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广州领导的管理比长沙领导的管理相对宽松，自己也有时间研究技术、提升业务能力与技能水平，真正以自己的思路去做一些工作，所以在此期间自己的技术、信心都提升了不少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从开始工作就对工作内容与性质不是特别感兴趣，日常需要应付大量报表，室外作业，工作地点不固定，同时还偶尔需要上夜班，每次上完夜班都极度不舒服，有时感觉快要猝死。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在广州的时候技术遇到瓶颈，提不起兴趣再进一步提升了。工作地点不固定，没有归属感，隔段时间非常焦虑、抑郁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2019年12月份左右，在极度抑郁的情况下，跟领导申请前往家附近城市工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到离家近的城市后，心情好了很多，但工作性质依然不满意，刚回来时计划要调我去另一个岗位，因为其他原因没去成。后面每天的工作跟广州一样，只是由于不熟悉新项目，提不起兴趣学习，每天的成就感不高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2019年最后几天，有IT公司联系我，新公司在业内的知名度很高，但与自己工作两年多做的项目不相关，研究生学的知识也忘的差不多了，所以就以试试的态度去了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面试的时候面试官问了我好多专业知识，基本一个都没答出来，只能说个基本印象，后面简单的聊了一下我离职的原因与以前的工作情况，我没报希望，结果回来的时候在地铁上收到了offer，待遇跟我现在工作差不多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;离职的选择很纠结，毕竟我现在的工作除了工作地点不固定，其他都还能接受，而IT公司是私企，可能存在35岁辞退情况。在网上查该公司，负面信息很多，但是托朋友打听，反映还好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终想着马上30岁的人了，趁房、车、媳妇都没有，压力不大，折腾一次，干自己想干的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020年2月，给领导打电话申请离职，领导跟同事很惊讶，当天晚上不断劝我，而我心意已决坚持要走。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020年3月，回公司总部所在城市自我隔离，隔离结束后前往公司开始办理离职。由于疫情期间上班人员不全，离职流程审查签字人员较多，所以办理比较慢，但是整体过程同事、领导还是相对照顾。2020年3月底办理完成，结束了我毕业后的第一份工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前跟新单位处于熟悉期。当下唯一的目标就是好好工作，深耕一个行业。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>febb4944956a7278c27840ebc17ec182</guid>
<title>gRPC 初体验</title>
<link>https://toutiao.io/k/3yau4u1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;strong&gt;&lt;span&gt;一、简单介绍RPC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;RPC（Remote Procedure Call）&lt;/span&gt;&lt;span&gt;远程过程调用&lt;/span&gt;&lt;span&gt;，它允许在一台服务器程序中调用另一台服务器上的子程序。RPC采用了&lt;/span&gt;&lt;span&gt;代理模式&lt;/span&gt;&lt;span&gt;从而屏蔽了网络之间的调用细节，使得调用远程函数就像调用本地程序一样简单。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RPC它包含了&lt;/span&gt;&lt;span&gt;接口规范&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;传输协议&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;数据序列化反序列化&lt;/span&gt;&lt;span&gt;规范。它可以基于HTTP或TCP协议之上来构建RPC协议，其各自都有优缺点。Google选择将GRPC定义在HTTP/2通信协议之上。GRPC的优势由HTTP/2和Protobuf继承而来。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Dubbo 国内最早的RPC框架、偏向服务治理、阿里巴巴开源支持java语言&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Motan 微博内部使用的RPC框架、2016年开源仅支持java语言&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Tars 腾讯内部使用的RPC框架、2017年开源仅支持C++语言&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Spring Cloud 国外Pivotal公司于2014年开源、仅支持java语言&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;span&gt; Google于2015年开源的跨语言RPC框架、支持多种语言&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Thrift Apache开源项目之一（原Facebook）、支持多种语言&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、什么是gRPC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gRPC 是由Google开发的一个高性能、开源、跨语言使用的RPC框架。主要基于&lt;/span&gt;&lt;span&gt;HTTP/2&lt;/span&gt;&lt;span&gt;通信协议标准设计，基于&lt;/span&gt;&lt;span&gt;Protobuf&lt;/span&gt;&lt;span&gt;（Protocol Buffers ）序列化协议开发，采用&lt;/span&gt;&lt;span&gt;IDL文件定义&lt;/span&gt;&lt;span&gt;服务而设计，同时支持大多数主流的编程语言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IDL接口描述语言&lt;/span&gt;&lt;span&gt;(Internal Define Language) 使用的是protobuf，通过proto3工具生成指定语言的数据结构、服务端接口以及客户端接口的存根(Stub)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Protobuf 作为轻量级的结构化数据存储格式，可以用于结构化、数据序列化、即时通讯、数据存储等领域。它是与语言无关、平台无关、可扩展的序列化结构数据格式，其功能类似于json、xml。但是Protobuf 比它们更小、更快、更简单，所以Protobuf 更适合RPC作为数据交换格式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Protobuf的核心内容&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;定义接口：接口路径和参数，以service标识&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;定义消息：消息的结构体，以message标识&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;通过Protobuf提供的机制，服务端与服务端之间只需要关注接口方法名（service）和参数（message）即可通信，而不需关注繁琐的链路协议和字段解析，极大降低了服务端的设计开发成本。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;通信协议&lt;/span&gt;&lt;span&gt;使用的是HTTP/2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，其特点如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;HTTP/2采用的是&lt;/span&gt;&lt;span&gt;二进制&lt;/span&gt;&lt;span&gt;格式的&lt;/span&gt;&lt;span&gt;传输协议&lt;/span&gt;&lt;span&gt;，而不是HTTP/1.x的文本格式，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持多路&lt;/span&gt;&lt;span&gt;复用&lt;/span&gt;&lt;span&gt;，即通过一个连接发送多个并发的请求。而HTTP/1.x虽然可以通过pipeline实现并发请求，但是多个请求之间的响应仍会被阻塞。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持&lt;/span&gt;&lt;span&gt;服务端推送&lt;/span&gt;&lt;span&gt;，即客户端发送一个请求，服务器可以对客户端发送多个响应。而不像HTTP/1.x只能通过客户端发起请求，服务端才响应。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持&lt;/span&gt;&lt;span&gt;头部压缩&lt;/span&gt;&lt;span&gt;，HTTP/2对传输的消息头进行了压缩传输，节省了头部在网络传输过程所占用的网络流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;gRPC基于HTTP/2对流传输提供了如下几种支持，在后面的案例也是基于这几种流式体验的。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Unary RP，一元RPC&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Server-side streaming RPC，服务端流式RPC&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Client-side streaming RPC，客户端流式RPC&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Bidirectional streaming RP，双向流式RPC&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;gRPC的调用模型：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;275&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWX77NKmYzyXRM94NQ4r9f5LQuOC8tTj0NMbrgvlXFF1YO0DXDBRbZlBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大致介绍一下流转的流程：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;客户端（gRPC Stub）调用 A 方法，发起 RPC 调用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对请求信息使用 Protobuf 进行对象序列化压缩（IDL）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务端（gRPC Server）接收到请求后，解码请求体，进行业务逻辑处理并返回&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对响应结果使用 Protobuf 进行对象序列化压缩（IDL）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;客户端接受到服务端响应，解码请求体。回调被调用的 A 方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、准备Protobuf环境&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）安装Protobuf的编译器protoc&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;brew search protobuf&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;brew install protobuf&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;protoc --versio&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;467&quot; data-backw=&quot;561&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8315617334423548&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWXRRtgaBxL8pVSVuRL3DbGQP2AkkaK4lUl0NxWKbrLlSboRd46LZEj4g/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1223&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2) 安装go语言的protobuf插件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：从google.golang.org官网下载 网上很多资源是旧版本的地址github上，目前已经被google收录管辖。其生成的.proto文件也跟之前的不同，甚至会报错。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;go&lt;/span&gt; install google.golang.org/grpc/cmd/protoc-gen-&lt;span&gt;go&lt;/span&gt;-grpc@v1&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;go&lt;/span&gt; install google.golang.org/protobuf/cmd/protoc-gen-&lt;span&gt;go&lt;/span&gt;@v1&lt;span&gt;.28&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;297&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5132575757575758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWXBrA3IFN5MiaVG8uC8Wpr5zBiaJ0MarPZVozbBYQuALAFK5mP7dWggtqQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;插件的安装路径在go/bin目录下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;311&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5383177570093458&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWX5t6MucN9jib86byt6hgvwRuibpF6s5MMJicJ5PreDiaYOYJeXDPWIAGSkQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1070&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）修改环境变量使得全局可用&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;vi .zshrc&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;export GO_PATH=~/&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;export PATH=$PATH:/$GO_PATH/bin&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;source ~/.zshrc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;四、gRPC初体验&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1）创建一个项目目录，其结构如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;314&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5428082191780822&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWX3thCkW3Cn7kianS8AZaQ5Nr0ic7QLfWBOjCDTmfqkspibzy60LnEXfNWQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）在protolist.proto文件中定义gRPC服务、方法请求、响应类型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先指定proto的版本，默认是proto2版本，我们需要手动指定版本为proto3类型（可以了解一下proto2 和 proto3的区别）且需要写在第一行。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;syntax = &lt;span&gt;&quot;proto3&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;然后指定生成的go文件在哪个目录中，已经包的命名空间是什么，使用分号分割。（.）表示当前目录，其包名为（proto）可随意取，&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;option go_package = &lt;span&gt;&quot;.;proto&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面也说过Protobuf的核心内容有两个：&lt;/span&gt;&lt;span&gt;service 和 message&lt;/span&gt;&lt;span&gt;，即&lt;/span&gt;&lt;span&gt;定义服务接口和消息&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定义服务和服务的方法&lt;/span&gt;&lt;span&gt;，gRPC支持四种服务：一元RPC、服务端流式RPC、客户端流式RPC、双向流式RPC。那就先体验双向流式PRC吧。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;service Greeter {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;//双向流式RPC&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    rpc SayRoute(stream HelloRequest) returns (stream HelloReply) {}&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面的代码定义了一个名字为Greeter的服务，里面包含了一个双向流式的RPC方法。其意味着，双方可以使用读写流发送一系列消息。注意，这两个流独立运行，在客户端和服务端可以按照任意的顺序读取和写入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定义消息类型&lt;/span&gt;&lt;span&gt;，请求的消息类型以及请求响应的消息类型&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;message HelloRequest {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;string&lt;/span&gt; name = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;}&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;message HelloReply {&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;    &lt;span&gt;string&lt;/span&gt; message = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这段代码看着就很眼熟呀，有点像结构体。不过人家叫消息体，消息体内的类型支持多种，这里就不列举了，可以自行查阅。其中 name=1 也不是为了赋值，它表示此变量在消息体内的位置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后在当前目录下执行如下命令：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;protoc --go_out=. --go_opt=paths=source_relative --&lt;span&gt;go&lt;/span&gt;-grpc_out=. --&lt;span&gt;go&lt;/span&gt;-grpc_opt=paths=source_relative .&lt;span&gt;/*.proto&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;此时，会在当前目录下生成以下go文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;431&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7452229299363057&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWXxfxJrUn3OQdn4AFbIvtyqy2A3vxeTmvpxshpzAYD4ZoYxI0s3llofA/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;protolist.pb.go&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;protolist_grpc.pb.go&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;p&gt;&lt;/p&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3）服务端实现，注册服务&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在server目录下的server.go文件中注册一个结构体为GreeterServers的服务。并监听一个端口号，在服务端运行着&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    server := grpc.NewServer()&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    proto.RegisterGreeterServer(server, &amp;amp;GreeterServers{})&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;    lis, _ := net.Listen(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;:8090&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;    server.Serve(lis)&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在protolist_grpc.pb.go文件中有一个GreeterServer的接口，里面包含了两个方法，我们在server.go文件中就需要按照协议接口来实现所有的方法。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;// GreeterServer is the server API for Greeter service.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;// All implementations must embed UnimplementedGreeterServer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;// for forward compatibility&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;type&lt;/span&gt; GreeterServer &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;    SayRoute(Greeter_SayRouteServer) error&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;    mustEmbedUnimplementedGreeterServer()&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在server.go中声明一个GreeterServers结构体中里面继承了一个结构体。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;type&lt;/span&gt; GreeterServers &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    proto.UnimplementedGreeterServer&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这里直接继承proto（proto就是生成的grpc.pb.go文件的引用）下面的结构体即可，mustEmbedUnimplementedGreeterServer这个方法在协议中已经被这个UnimplementedGreeterServer结构体实现了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面实现SayRoute方法&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *GreeterServers)&lt;/span&gt; &lt;span&gt;SayRoute&lt;/span&gt;&lt;span&gt;(stream proto.Greeter_SayRouteServer)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;        _ = stream.Send(&amp;amp;proto.HelloReply{Message: &lt;span&gt;&quot;ha ha ha ha&quot;&lt;/span&gt;})&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;        resp, err := stream.Recv()&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; err == io.EOF {&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;        log.Printf(&lt;span&gt;&quot;resp:%v&quot;&lt;/span&gt;, resp)&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其中Send和Recv都是&lt;/span&gt;&lt;span&gt;Greeter_SayRouteServer接口中的方法，用于发送消息和接收消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时运行go run server.go 文件，然后TCP端口号为8090服务跑起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）客户端实现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端连接上服务端的端口:8090，然后调用服务端的SayRoute()方法，在通过Send()方法发送消息，使用Recv()方法接收消息。整个流程就像调用本地方法一样。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    conn, _ := grpc.Dial(&lt;span&gt;&quot;:8090&quot;&lt;/span&gt;, grpc.WithInsecure())&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;defer&lt;/span&gt; conn.Close()&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;    client := proto.NewGreeterClient(conn)&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;    _ = SayRoute(client, &amp;amp;proto.HelloRequest{Name: &lt;span&gt;&quot;cici&quot;&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SayRoute&lt;/span&gt;&lt;span&gt;(client proto.GreeterClient, r *proto.HelloRequest)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    stream, _ := client.SayRoute(context.Background())&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; &lt;span&gt;6&lt;/span&gt;; n++ {&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;        _ = stream.Send(r)&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        resp, err := stream.Recv()&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; err == io.EOF {&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;            &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;        log.Printf(&lt;span&gt;&quot;resp err: %v&quot;&lt;/span&gt;, resp)&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;    _ = stream.CloseSend()&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下面运行一下，如下是输出内容：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;148&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25688073394495414&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWX5EJTJ0ya9r99AZMzbAnl2lfdV7oEssEK6mKlGdAicu5qRucyqKgugjQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1308&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;145&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25158227848101267&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWXoDzW3wWp1EQNCeBnP9q3icR0Dx2IIKAGDEb4mLicwniaOrJaAvjGIXhQA/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1264&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，双向流式RPC就是指两端可以同时使用读写流发送消息。这两个流可以独立运行，可以根据业务需求完善流中消息的交互顺序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结这次gRPC案例初体验，我们简单的了解到什么是RPC以及gRPC的设计理念，什么是Protobuf以及它的核心内容是什么。最后实践了&lt;span&gt;双向流的简单demo。线下在学习的过程中对安装Protobuf插件的确走了一点弯路，好在最后走出来了。&lt;/span&gt;然后呢~特别感谢《&lt;span&gt;Go语言编程之旅&lt;/span&gt;》的作者让我这个小🐟儿有幸在gRPC的世界里稍微扑腾了一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、参考来源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;《Go语言编程之旅》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://blog.csdn.net/weixin_42905141/article/details/125272803&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://developers.google.com/protocol-buffers/docs/reference/go-generated?hl=zh-cn&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://blog.csdn.net/i_19970916/article/details/125733894&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;578&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z33JZWhn1uNE2jbQicbpwrWbzt4yCuXsolw0UEM7wZRXB1Rl8vvAJzbNsaQc7llGM2RQmT0TEJD94GARMRFUQvQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;157&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.271585557299843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z33JZWhn1uOnC8YBW9UGogSXeaGKoIibSDV6rg2FnuL671lPX6ibOEBOcNuvPqxyhqxlWicyf8dcraK579G8FWzrg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ab4658c033d1ce0081581c4ef66a4ab</guid>
<title>12款开源的低代码开发平台，建议收藏</title>
<link>https://toutiao.io/k/ulwrd25</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7e00041d12ecb7227d7427f1e0789b4d</guid>
<title>设计模式：委派模式——从SLF4J说起</title>
<link>https://toutiao.io/k/6v3ph80</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;作者：vivo 互联网服务器团队- Xiong yangxin&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;将某个通用解决方案包装成成熟的工具包，是每一个技术建设工作者必须思考且必须解决的问题。本文从业内流行的既有工具包入手，解析实现思路，沉淀一般方法。为技术建设的初学者提供一些实践思路的参考。尤其是文中提倡的“去中心化”的协作模式，和“关键链路+开发接口”的开发模式，具有一定的实际落地意义。当然本文在行文中，不可避免存在一定主观偏见性，读者可酌情阅读。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、前言&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;熟悉JAVA服务器开发的同学应该都使用过日志模块，并且大概率使用过&quot;log4j-over-slf4j&quot;和“slf4j-log4j”这两个包。那么这两个包的区别是什么？为什么会互相引用包含呢？这篇文章会解释下这几个概念的区别。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先说一下&lt;strong&gt;SLF4J&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、从SLF4J开始&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;SLF4J&lt;/strong&gt;全称&quot;Simple Logging Facade for Java (SLF4J) &quot;, 它诞生之初的目的，是为了针对不同的log解决方案，提供一套统一的接口适配标准，从而让业务代码无须关心使用到的第三方模块都使用了哪些log方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举个例子， Apache Dubbo和RabbitMQ使用到的日志模块便不相同。从某种意义上而言，SLF4J只是一个facade,类似于当年的ODBC(针对不同的数据库厂商而制定的统一接口标准， 下文会涉及到)。而这个facade对应的包名，是 “slf4j-api-xxx.xxx.xxx.jar”。所以，&lt;strong&gt;当你应用了&quot;slf4j-api-xxx.jar&quot;的包时，其实只是引入了一个日志接口标准，而并没有引入日志具体实现&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.1、业内实现&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;SLF4J标准在应用层的核心类，就是两个: org.slf4j.Logger 和 org.slf4j.LoggerFactory。其中，自版本1.6.0后，如果并没有具体的实现，slf4j-api会默认提供一个啥也不干的Logger实现(org.slf4j.helpers.NOPLogger)。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在当前(本稿件于2022-03-01拟制)的市面上，既有的实现SLF4J的方案有以下几种：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42276422764227645&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GpmhdsA6Px0Y1yiayw4URVNV9NqKdB13Ja83sQ5dV1ticBYbia6F3gibKeA6GLaa1cJ9wxHfMROfl2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;615&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;整体层次如下图：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GpmhdsA6Px0Y1yiayw4URVpkE3QgB72gXicujh3saZm4ZfvnsoDKXjJZaib36q8bkzbduGQ0oYZHMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;综上而言：&lt;strong&gt;以SLF4J-开头的jar包，一般指的是采用某种第三方框架实现的slf4j解决方案。&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.2 工作机制&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;那么整个SLF4J的工作机制是如何运作的呢，换句话说，系统是如何知道应该使用哪个实现方案的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于那种不需要适配器的原生实现方式，直接引入对应的包即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于那种需要适配器的委托式实现方式，则需要通过另外的一个渠道来告知SLF4J应该使用哪个实现类: SPI机制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举个例子，我们看一下slf4j-log4j的包结构：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6453089244851259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4GpmhdsA6Px0Y1yiayw4URVpmqkJicMzjJicfTj1u8UrV1pd9KqjicBOziaibr4ZcGBPI80HOHYCKAU1Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;437&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;我们先看pom文件，就包含两个依赖：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;slf4j-api&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;log4j&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;log4j&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;slf4j-log4j同时引入了slf4j-api和log4j。那么slf4j-log4j本身的作用不言而喻：使用LOG4J的功能，实现SLF4J的接口标准。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;整体的接口/类关系路径如下图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.665625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GpmhdsA6Px0Y1yiayw4URVzZJOuyI8ZFnlkm4fsPspjIGiaTXYib8JP85F6m6owNYQkwlaFrwvtZUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;但是这仍然没有解决本章节开始提出的问题（程序怎么知道应该用哪个Logger）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以从源码入手：(slf4j/slf4j-log4j12 at master · qos-ch/slf4j · GitHub)，我们看到了以下关键的文件：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.1497584541062802&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4GpmhdsA6Px0Y1yiayw4URV2xBl2KUMEicIwbVPJvtmT7aoHdQ3oViaicd9vkSm6E5r2SdS97KyT7n1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1242&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;也就是说：slf4j-log4j使用了java的SPI机制告知JVM在运行时调用具体哪一个实现类。由于SPI机制暂不属于本文章讨论范围，读者可以去官网获取信息。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;读者可以去GitHub - qos-ch/slf4j: Simple Logging Facade for Java看其他的实现方式的适配器是如何工作的。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;那么本章开始的问题答案便是：&lt;/p&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;SLF4J制定一套日志打印流程，然后把核心类抽象出接口给外部去实现；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;适配器使用第三方日志组件实现了这些核心类接口，并采用SPI机制，让JAVA运行时意识到核心接口的具体实现类。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;而上述两点，构成了本文接下来要讲述的知识点：委派模式。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、委派模式&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;从上文中，我们从&lt;span&gt;SLF4J&lt;/span&gt;的案例，引出了&quot;委派模式&quot;这个概念，下面我们就重点讨论委派模式(delegation)。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;接下来我们按照认知流程，依次从三个问题，解释委派模式：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;然后会在下一章，用业内的典型案例，分析委派模式的使用情况。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.1 为什么采用委派模式？&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们回到SLF4J。为什么它会用委派模式呢？因为日志打印功能存在各种不同的实现方式。对于应用开发者而言，最好需要一个标准的打印流程，其他第三方组件可以在某些地方有些不同，但是核心流程是最好不要变。对于标准制定者 而言，他无法控制每一个第三方组件的所有细节，所以只能暴露出有限的自定制能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而我们放大到软件领域，或者在互联网开发领域，不同的开发者的协作模式，主要靠jar包应用：第三方开发一个工具包，放在中心仓库中(maven, gradle)， 使用者从其他信息渠道(csdn, stackoverflow等等)根据问题定位到这个jar包，然后在代码工程中引用。理论上，如果这个第三方jar包很稳定(例如c3p0)，那么该jar包的维护者就很少甚至几乎不会和使用者建立联系。如果某些中间件开发者觉得不满足自己公司/部门的需求，会根据该jar包再做一次自定义封装。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;纵观上述整个过程，不难发现两点：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;工具包开发者和使用者没有建立稳定的协同渠道&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;工具包开发者对自己成品的发展掌控很薄弱&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么如果有人想要建立一套标准呢？比如log标准，比如数据库连接标准，那么只能有几个大公司联盟，或者著名的开发团队联盟，制定一个标准，并实现其中核心链路部分。至于为什么不实现全部链路，原因也很简单：软件领域的协同本身就是弱中心化的 ，否则你不带别人玩，别人也不会采用你的标准(参考当年IBM推广的COBOL)。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;综上而言：委派模式是基于当前软件领域的协作特性，采取的较好的软件结构模式。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.540625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GpmhdsA6Px0Y1yiayw4URVGqgMjBGEcIXNEd2zcewjnGwxjuutfFHEhYqsAia9pFZ1Gg8kq7hwqgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;所以啥时候采用委派模式呢？&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;存在设定某个标准并由中心化团队负责的必要&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用者有强烈的需求自定制某些局部实现&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;这里就举一个硬件领域的反例：快充标准。在2018年甚至更早，消费者就需要一个快充的功能。但是快充需要定制很多硬件才能实现，所以此时就具备了条件一，但是当时并没有任何一个团队或者公司能够掌控安卓手机硬件整个生态，无法共同推出一个中心化团队去负责，从而导致各个手机厂商的快充功能百花齐放：A公司的快充线，无法给B公司的手机快充。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.2 什么是委派模式？&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于上述的讨论，委派模式的核心构成就显而易见了：&lt;strong&gt;核心链路， 开放接口。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;核心链路指的是：&lt;strong&gt;为了达到某个目的，特定的一组构件，按照特定的顺序，特定的协同标准，共同执行计算的逻辑。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;开放接口指的是：&lt;strong&gt;给定特定的输入和输出，将实现细节交给外部的功能接口。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;举个比较现实的例子：传统汽车。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;几乎每一辆传统汽车，都按照三大件进行集成和协作：发动机，变速器，底盘。发动机做功， 通过变速器将动力传输给底盘(这么说并不标准，甚至在汽车工业的工人眼中，这种描述几乎是谬论，但是大致是这样)。也基于此，发动机的接口， 变速箱的接口，底盘的接口都已经固定，剩下的就各个厂商去实现了：三菱的发动机， 日产的发动机，爱信的变速箱，采埃孚的变速箱，伦福德的底盘，天合的底盘等等。甚至连轮胎的接口都制定好了：大陆的轮胎，普利司通的轮胎，固特异的轮胎。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不同的汽车厂商，选择不同公司的组件，集成出某个汽车型号。当然也有公司自己去实现某个标准：比如大众自己生产EA888发动机，PSA自己生产并调教的底盘并引以为傲。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果大家觉得不够熟悉，那么可以举一个tomcat的例子。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;经历过00年代的软件开发者，应该知道当时开发一个web应用是多么的困难：如何监听socket, 如何编码解码，如何处理并发，如何管理进程等等。但是有一点是共通的：每一个Web开发者都想要一个框架去管理整个http服务的协议层和内核层。于是出现了JBoss, WebSphere, Tomcat（笑到了最后）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这些产品，都是指定了核心的链路：监听socket → 读数据包→ 封装成http报文 → 派发给处理池子 → 处理池的线程调用处理逻辑去处理 → 编码返回的报文 → 编组成tcp包 → 调用内核函数→ 发出数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于这个核心链路，制定标准：业务处理逻辑的输入是什么，输出是什么，如何让web框架识别到业务处理模块。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Tomcat的方案就是web.xml。开发者只要遵从web.xml标准去实现servlet即可。也就是说，在整个http服务器链路中，Tomcat将特定的几个流程处理构件(listener, filter, interceptor, servlet)委派给了业务开发者去实现。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.3 如何使用委派模式&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;在使用委派模式之前，先根据上文的模式匹配条件进行自我判断：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;存在设定某个标准并由中心化团队负责的必要&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用者有强烈的需求自定制某些局部实现&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果并不符合条件一，那么就不需要考虑使用委派模式；如果符合条件一但是不符合条件二，那就先预留好接口，采用依赖注入的方式，自己开发接口实现类并注入到主流程中。这个做法在很多的第三方依赖包中能够看到，比如spring的BeanFactory， BeanAware等等，还有各个公司开发SSO时预留的一些hook和filter等等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在确定使用委派模式后，第一件事就是“确定核心链路”，这一步最难，因为往往使用者都有某种期望，但是让他们具体描述出来，却又经常不够精准，甚至有时候后主次颠倒。笔者的建议是：直接让他们说出原始的需求/痛点，然后自己尝试给出方案，再对比他们的方案，进行沟通，并逐渐将两个方案统一。统一的过程也就是不断试探和确定的过程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5398406374501992&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GpmhdsA6Px0Y1yiayw4URVQM4OnLHJxgqHbWbQMaL2p8gViccQ1xIx3cNG0BONSgkiaazD4rFWMSFQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;502&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上述的过程是笔者自己的经验，仅当借鉴。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在确定核心流程后，再将流程中的一些需要自定制的功能抽象成接口暴露出去。接口的定义中，尽量减少对整个流程中其他类的调用依赖。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以整体的流程分为三步：&lt;strong&gt;确认使用该模式；提取核心流程；抽象开放接口。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至于是采用SPI机制还是像TOMCAT一样使用XML配置识别，需要看具体情况，在此不做涉及。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、 业内案例&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;4.1 JDBC&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;JDBC的诞生很大程度上是借鉴了ODBC的思想，为JAVA设计了专用的数据库连接规范JDBC(JAVA Database Connectivity)。JDBC期望的目标是让Java开发人员在编写数据库应用程序时，可以有统一的接口，无须依赖特定数据库API，达到“ 一次开发，适用所有数据库”。虽然实际开发中，经常会因为使用了数据库特定的语法、数据类型或函数等而无法达到目标，但JDBC的标准还是大大简化了开发工作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;整体而言，JDBC的接入结构大致如下图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7097944377267231&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GpmhdsA6Px0Y1yiayw4URVApcPKKeqwugkWNViayI4riaL0BvUfIKOsghfCmwtnHibcXqTAEEqYw5RQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;827&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;但是实际上，在JDBC诞生之初，市面上并未有很多的厂家响应SUN公司(那时候SUN还并未被ORACLE收购)， 于是SUN公司就使用了本文介绍的桥接模式，如下图：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.378125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GpmhdsA6Px0Y1yiayw4URVLPd4HYCzIzib0HNvNZdaHJcibZ9oCqfLMtrF5GK8x8qdkjAYHE9nKLQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;也是说，形式上，出现了初步委派的结构形式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下文会只针对单次委托的JDBC层级做分析。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;按照上文所言，每一个委派结构，必然存在两个要素：核心路径和开放接口。我们从这两个维度开始分析JDBC。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;JDBC的核心路径分为六步， 包含委托机制需要的两步(引入包，声明委托承接人)，总共八步，如下：&lt;/p&gt;&lt;/section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot; powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;引入JDBC实现包&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;注册JDBC Driver&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;和数据库建立连接&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;发起transaction（必要的话），创建statement&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;执行statement并读取返回，塞入ResultSet&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;处理ResultSet&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关闭ResultSet， 关闭Statement&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关闭Connection&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;纵观整个过程，核心的参与者为：Driver, Connection, Statement, ResultSet。transaction实际上是基于Connection的三个方法(setAutoCommit, commit, rollback)包装而成的会话层，理论上不属于标准层。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以mysql-connector-java为例，具体实现JDBC接口的情况如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36553945249597425&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GpmhdsA6Px0Y1yiayw4URV3wIXCDuvHcD2QnY8Wr5JspjjZBibfq1o5XgEpoGzLFO85jhicLAicqGHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;621&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过Java自带的overriding机制，只要使用com.mysql.jdbc.Driver，那么其他组件的实现类便直接被应用实现。具体细节不做讨论。那么mysql-connector-java是如何告知JVM应该使用com.mysql.jdbc.Driver呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;两种模式&lt;/p&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;明文模式&lt;/strong&gt;——在业务代码中明文使用Class.forName(&quot;com.mysql.jdbc.Driver&quot;)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;SPA机制&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;其实上述的两种方法，核心就是初始化com.mysql.jdbc.Driver，执行以下类初始化逻辑。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DriverManager.registerDriver(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Driver());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (SQLException var1) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Can&#x27;t register driver!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;也就是说，JDBC通过DriveManager维护委托承接者的信息。&lt;strong&gt;读者如果有兴趣查看DriverManager的源码，会发现JDBC的另一种实现类发现方式。&lt;/strong&gt;不过考虑行文长度，笔者在此不表。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;4.2 Apach Dubbo&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;Dubbo的核心路径大致如下(不考虑服务管理那一套)：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;consumer调用 → &lt;em&gt;参数序列化 &lt;/em&gt;→ &lt;em&gt;网络请&lt;/em&gt;&lt;em&gt;求&lt;/em&gt; → &lt;span&gt;接收请求 → 参数反序列化&lt;/span&gt; → provider计算并返回 → &lt;span&gt;结果序列化 → 网络返回&lt;/span&gt; → &lt;em&gt;consumer方接收&lt;/em&gt; → &lt;em&gt;结果反序列化&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（斜体代表consumer方的dubbo职责，下划线代表provider方的dubbo职责）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Dubbo的可定制接口有很多，整体大量采用了“类SPI”机制，为整个RPC流程的很多环节，提供了自定制的注入机制。相较于传统的Java SPI, Dubbo SPI在封装性和实现类发现性上做了很多的扩展和自定制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Dubbo SPI整体实现机制及工作机制不在本文范围，但为了行文方便，在此做一些必要说明。整体的Dubbo SPI机制可以分为三部分：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section/&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们以Dubbo-Auth&lt;/p&gt;&lt;p&gt;(dubbo/dubbo-plugin/dubbo-auth at 3.0 · apache/dubbo · GitHub)为例，从核心路径和开放接口两个维度进行分析。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Dubbo-Auth的实现逻辑，是基于Dubbo-filter的原理，也就是说：Dubbo-Auth本身就是Dubbo整体流程中的某一个环节的委派实现方。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Dubbo-Auth的核心入口(也就是核心路径的起始点)， 是ProviderAuthFilter，&lt;/p&gt;&lt;p&gt;是org.apache.dubbo.auth.filter的具体实现， 也就是说：&lt;/p&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;org.apache.dubbo.auth.filter是dubbo核心链路中对外暴露的一个开发接口(类定义上标注了@SPI)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ProviderAuthFilter是实现了dubbo核心链路中对外暴露的开发接口Filter(ProviderAuthFilter实现类定义上标注了@Activate)。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ProviderAuthFilter的核心路径比较简单：获取Authenticator对象，使用Authenticator对象进行auth验证。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;具体代码如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Activate&lt;/span&gt;(group = CommonConstants.PROVIDER, order = -&lt;span class=&quot;code-snippet__number&quot;&gt;10000&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ProviderAuthFilter&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Filter&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Result &lt;span class=&quot;code-snippet__title&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Invoker&amp;lt;?&amp;gt; invoker, Invocation invocation)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; RpcException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        URL url = invoker.getUrl();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; shouldAuth = url.getParameter(Constants.SERVICE_AUTH, &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (shouldAuth) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Authenticator authenticator = ExtensionLoader.getExtensionLoader(Authenticator.class)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    .getExtension(url.getParameter(Constants.AUTHENTICATOR, Constants.DEFAULT_AUTHENTICATOR));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                authenticator.authenticate(invocation, url);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; AsyncRpcResult.newDefaultAsyncResult(e, invocation);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; invoker.invoke(invocation);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;注意，上文代码中&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;url.getParameter(Constants.AUTHENTICATOR, Constants.DEFAULT_AUTHENTICATOR)&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;是dubbo spi 的Adaptive机制中的选择条件，读者可以深究，本文在此略过。&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于核心路径包含了Authenticator ，那么Authenticator 自然就很可能是对外暴露的开发接口了。也就是说，Authenticator 的声明类中，必然是注解了@SPI。&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@SPI&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;accessKey&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Authenticator&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; url&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sign&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Invocation invocation, URL url)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * verify the signature of the request is valid or not&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; invocation&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; url&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@throws&lt;/span&gt; RpcAuthenticationException when failed to authenticate current invocation&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;authenticate&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Invocation invocation, URL url)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; RpcAuthenticationException&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;上述代码证明了笔者的猜想。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;在Dubbo-Auth中，提供了一个默认的Authenticator ：AccessKeyAuthenticator。在这个实现类中，核心路径被再次具体化：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;获取accessKeyPai；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用accessKeyPair, 计算签名；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对比请求中的签名和计算的签名是否相同。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;在此核心路径中，由于引入了accessKeyPair概念，于是就引出一个环节：如何获取accessKeyPair, 针对此， dubbo-auth又定义了一个开放接口：AccessKeyStorage。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@SPI&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AccessKeyStorage&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * get AccessKeyPair of this request&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; url&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; invocation&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;AccessKeyPair &lt;span class=&quot;code-snippet__title&quot;&gt;getAccessKey&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(URL url, Invocation invocation)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;4.3 LOG4J&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最后一个案例，我们又回到了日志组件，而之所以介绍LOG4J, 是由于它使用了非常规的“反向委派”机制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;LOG4J借鉴了SLF4J的思想(或者LOG4J在前？SLF4J借鉴的LOG4J ?), 也采用了 接口标准+ 适配器+第三方方案的思路来实现委派。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5706806282722514&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GpmhdsA6Px0Y1yiayw4URV75DE0vNWpZboVpFS2pnmdRSkXQPgiaztSvrTIB78rEbn7Io45OQTp0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;191&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;那么显然，这里就有个问题：SLF4J确认了自己的核心路径，然后暴露出待实现接口，SLF4J-LOG4J在尝试实现SLF4J的待实现接口时，又使用了委托机制，把相关的路径细节外包了出去，从而形成了一个环。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1700554528650646&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GpmhdsA6Px0Y1yiayw4URVV0FRaxCseFPAicvCSWw4mf27sqdqhJKBxcotuttKhYAbu9CDtbGicT5A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;541&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;所以说，如果我同时引入了&quot;log4j-over-slf4j&quot;和&quot;slf4j-log4j&quot;，会造成stackoverflow。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个问题非常典型， google一下就可能看到很多的案例，比如Analysis of stack overflow exception of log4j-over-slf4j and slf4j-log4j12 coexistence - actorsfit等等， 官方也给出了警告（SLF4J Error Codes）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于此文的关注点在委派模式，所以关于此问题并不详细讨论。而此案例的重点，是说明了一件事：&lt;strong&gt;委派模式的缺点，就是对于开放接口的实现逻辑不可控。&lt;/strong&gt;如果第三方实现存在重大机制性隐患，会导致整体核心流程出现问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;综上所述， &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;委派模式的&lt;strong&gt;使用场景&lt;/strong&gt;是：&lt;/p&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;存在设定某个标准并由中心化团队负责的必要；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用者有强烈的需求自定制某些局部实现。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;委派模式的&lt;strong&gt;核心点&lt;/strong&gt;：&lt;strong&gt; 核心路径， 开放接口&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;委派模式的&lt;strong&gt;隐藏机制&lt;/strong&gt;：&lt;strong&gt;实现方式的注册/发现&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;SLF4J Manual&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Using log4j2 with slf4j: java.lang.StackOverflowError - Stack Overflow&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Creating Extensible Applications (The Java™ Tutorials &amp;gt; The Extension Mechanism &amp;gt; Creating and Using Extensions) (oracle.com)&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;slf4j/slf4j-log4j12 at master · qos-ch/slf4j · GitHub&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Delegation pattern - Wikipedia&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;What is a JDBC driver? - IBM Documentation&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Lesson: JDBC Basics (The Java™ Tutorials &amp;gt; JDBC Database Access) (oracle.com)&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GitHub - apache/dubbo: Apache Dubbo is a high-performance, java based, open source RPC framework.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:134.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>