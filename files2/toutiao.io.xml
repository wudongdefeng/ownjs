<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>de2b355106be82700422038f873927de</guid>
<title>测试角色在项目各阶段的项目管理 tips</title>
<link>https://toutiao.io/k/w4i9u34</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h4&gt;作者：京东物流 宋雪薇&lt;/h4&gt;

&lt;h4&gt;1 前言&lt;/h4&gt;

&lt;p&gt;项目管理是一个繁杂的过程，每个阶段需要涉及到不同人员、资源的协调配合。每个角色都有自己的定位和任务，为了紧密配合项目经理或无分配项目经理运行项目的场景下确保项目成员共同达成项目目标，不同的角色掌握相应的项目管理意识就尤为重要。&lt;/p&gt;

&lt;p&gt;那么，测试角色作为项目交付的质量把控者，具备相应的项目管理意识在项目的高质量、高效率交付目标上有着重要作用，如前置识别质量风险、进度风险等。本文旨在梳理、谈论测试角色在项目各阶段如何评估测试范围及风险、前置暴露问题以及推进测试进度等项目管理事项，高效协作及交付测试角色产物，最终与项目各方共同推进达到高质量、高效率交付的目标。&lt;/p&gt;

&lt;h3&gt;2 现状及思考&lt;/h3&gt;

&lt;p&gt;在现有敏捷迭代快速交付模式下，针对某一需求/项目会拆分至各个团队，各个团队节奏及交付目标不完全一致，且无项目经理角色跟踪推进的情况下，存在后置与协作团队沟通确认事项，如：未拉齐依赖方排期、前期未识别出改动系统、需求/设计变更未及时同步相关方、无设计方案沟通导致提测内容不满足提测标准，等均可影响交付节奏。那么作为测试角色的我们可以做哪些事情？&lt;/p&gt;

&lt;p&gt;核心主旨：高效沟通协作，提前思考后续阶段较容易影响进度、质量问题及风险点，暴露问题，前置沟通、评估及推进相关事宜；避免问题后置暴露在测试阶段；下一章节就让我们来详谈各个阶段测试角色可提前关注事项，与各方高效协作共同推进解决的相关tips。&lt;/p&gt;

&lt;h3&gt;3 详谈测试介入各阶段的项目管理tips&lt;/h3&gt;

&lt;h4&gt;3.1 需求评审阶段&lt;/h4&gt;

&lt;p&gt;软件测试的第一步就是需求评审，只有对软件需求做了准确、完整的评审后，才能对接下来各种测试工作的开展做好基础，如需求评审理解偏差，后期很多测试任务都将会受到影响。&lt;/p&gt;

&lt;p&gt;需求评审完成需了解哪些信息：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 优先级——识别项目/需求重点程度，优先级，以及期望上线时间情况（定位后续跟进力度）&lt;/li&gt;
&lt;li&gt; 需求背景——该需求基于什么业务背景改造（便于需求理解不偏差及后续测试阶段重点关注的核心目标）&lt;/li&gt;
&lt;li&gt; 改动范围——评审改动范围基于现有系统是否有冲突、是否明确合理，是否影响其他系统，也可关注下体验问题（避免后续开发测试阶段流程不通返工）&lt;/li&gt;
&lt;li&gt; 识别改动/交互系统——明确该需求是否涉及其他系统改动，识别改动系统/是否需配合联调系统（识别改动系统前置协调拉齐相关系统周期，避免后续阶段临时协调资源情况）&lt;/li&gt;
&lt;li&gt; 测试节点——软件需要进行哪些方面的测试，如功能测试、联调测试、回归测试、性能测试、稳定性测试、兼容性测试、安全测试等&lt;/li&gt;
&lt;li&gt; 测试环境——明确交互系统是否支持测试环境联调（可前置协调/前置确定联调方案，避免后置沟通确定环境占用测试周期）&lt;/li&gt;
&lt;li&gt; 测试数据——根据改动范围思考测试数据来源，识别是否可内部闭环造数，是否可使用测试小工具&lt;/li&gt;
&lt;li&gt; 测试方式——可前置思考使用功能测试、自动化测试&lt;/li&gt;
&lt;li&gt; 测试人员——识别测试干系人、明确主测试方（如重点项目/需求需要主测试情况）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;3.2 设计评审阶段&lt;/h4&gt;

&lt;p&gt;设计评审为评价设计满足质量要求的能力，识别问题及提出解决办法。设计过程中越早增加质量保证活动对最终设计效果的影响就越明显。目前较大项目/逻辑较复杂需求/研发优化，均需研发输出设计评审文档并邀请测试参与涉及评审。&lt;/p&gt;

&lt;p&gt;设计评审时需要check的内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 设计思路满足需求——结合需求背景及内容优先关注设计思路是否与需求评审阶段理解的有偏差&lt;/li&gt;
&lt;li&gt; 设计内容是否存在遗漏——评估是否存在遗漏功能&lt;/li&gt;
&lt;li&gt; 关注实现方式——实时、异步等处理方式对后续测试排期、方式及测试难度有参考价值&lt;/li&gt;
&lt;li&gt; 评估改动设计影响——基于原有系统改动除本次需求修改内容是否影响原有功能，是需明确影响范围，研发侧输出影响范围&lt;/li&gt;
&lt;li&gt; 明确阶段范围——根据需求是否存在拆解阶段交付，是需明确各阶段交付内容&lt;/li&gt;
&lt;li&gt; 交互方/依赖方实现方式——关注交互方/依赖方实现方式&lt;/li&gt;
&lt;li&gt; UAT/灰度/上线方案——根据上线特性，前置沟通UAT/灰度/上线方案&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;3.3 排期阶段&lt;/h4&gt;

&lt;p&gt;排期阶段是项目管理中重要的一环，时常在此阶段会暴露一些风险，排期容易出现两个问题，一是排期不合理，二是后续不能按照排期稳步推进，好的排期就要尽量避免这两个问题，那么测试阶段合理的排期就需尽可能多的参考该节点及之前节点项目各方提供的有效信息，全局评估、拆分任务交付，最终提供较合理排期。&lt;/p&gt;

&lt;p&gt;输出测试排期需要考虑的维度：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 参考项目重点程度、优先级——是否优先级与已排期需求冲突，需参考优先级调整资源及排期&lt;/li&gt;
&lt;li&gt; 结合需求、设计参考及核对研发工时及排期、阶段交付内容——研发提供拆解后的任务排期是否合理（前置功能是否提前交付，依赖的任务是否有序等），测试依据研发排期时间提供可并行/串行等较合理的测试排期&lt;/li&gt;
&lt;li&gt; 关注研发是否有联调排期——需保障提测质量，时间紧任务重情况下是否压缩研发联调排期，可能影响提测质量及测试交付时间&lt;/li&gt;
&lt;li&gt; 测试联调排期——测试输出联调周期需拉齐对接系统排期（可协同产品沟通拉齐），避免临时协调联调时间导致延期&lt;/li&gt;
&lt;li&gt; APP排期——需确认实现方式为：原生/flutter&lt;/li&gt;
&lt;li&gt; 明确方案是否存在变更——可再次明确需求/设计方案是否存在变更未同步情况&lt;/li&gt;
&lt;li&gt; 明确主测试方——如涉及多方系统，排期阶段可明确主产品、主研发、主测试方&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;3.4 测试用例编写、评审阶段&lt;/h4&gt;

&lt;p&gt;测试用例的编写必须依据需求文档，结合设计方案，确认所有以疑问点，覆盖所有功能需求点，跟进需求情况输出冒烟测试用例、功能测试用例、联调测试用例，思考业务实操场景，模拟用户场景串联流程保障测试内容的高覆盖。并在用例评审节点邀请产研参与评审，有序进行用例评审，确认疑问共同完善测试点并会后输出评审会议纪要。&lt;/p&gt;

&lt;p&gt;测试用例编写、评审阶段需要注意的事项：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 确认需求文档版本及标准——明确最新PRD版本（存在产研线下沟通后未同步测试情况，尽量避免），如有原型需明确原型及PRD内容描述不一致情况下如何开展测试工作&lt;/li&gt;
&lt;li&gt; 思考细节逻辑合理性及歧义描述——思考细节逻辑描述是否合理，PRD描述存在歧义点需标注明确&lt;/li&gt;
&lt;li&gt; 包含充分的异常测试用例——丰富异常用例，避免异常情况下功能异常&lt;/li&gt;
&lt;li&gt; 识别用户体验问题——提示信息是否明确、页面功能是否易用&lt;/li&gt;
&lt;li&gt; 业务范围和系统设计维度补全用例——跟进需求及设计细化测试维度丰富测试用例&lt;/li&gt;
&lt;li&gt; 测试数据、账号、配置等——识别测试数据、账号及配置是否需协同方配合，是否可使用工具等提升效率，如需全流程连通在该阶段记录&lt;/li&gt;
&lt;li&gt; 测试用例评审——与产研侧确认测试范围、沟通疑问，评审用例设计的清晰度与合理性，优先级排定是否合理，是否覆盖了需求上所有测试点，用例是否具有很好的可执行性，用例的冗余处理机制，是否设计了充足的异常测试用例，是否从用户的角度出发来设计用户使用场景和使用流程的测试用例，是否简洁、复用性强。&lt;/li&gt;
&lt;li&gt; 联调用例评审——输出交互场景与交互方评审，如为主测试，评审前串联整个项目/需求的流程场景用例，组织评审、明确测试数据、账号、配置等信息&lt;/li&gt;
&lt;li&gt; 用例评审会议纪要——记录待确认点及已确认点&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;3.5 编码阶段&lt;/h4&gt;

&lt;p&gt;编码阶段作为研发角色活动，通过编码过程来实现产品需求，此阶段的异常等需相关方知悉；&lt;/p&gt;

&lt;p&gt;研发阶段需同步的信息：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 需求/方案变更——是否存在需求/方案变更，是否及时同步至产品、测试侧&lt;/li&gt;
&lt;li&gt; 是否有提测延期风险——存在延期风险会压缩后续测试周期，需前置识别并抛出&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;3.6 代码评审阶段&lt;/h4&gt;

&lt;p&gt;代码评审是研发全流程的工程实践之一，通过代码评审可以更好的保障产品质量和代码质量；可根据改动大小与研发侧沟通进行线上/线下等评审方式参与。&lt;/p&gt;

&lt;p&gt;代码评审阶段需检验的标准：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 慢sql、空指针等——可有意识评审慢sql、空指针等问题&lt;/li&gt;
&lt;li&gt; 业务逻辑——测试人员需关注是否有明显的逻辑错误，改动是否遵循业务逻辑&lt;/li&gt;
&lt;li&gt; 补全回归用例——跟进改动范围可识别需改动影响原有功能部分，特别注意需确保主流程是否影响，补充回归用例&lt;/li&gt;
&lt;li&gt; 文档——提供新接口/修改接口是否有相应的接口文档更新维护&lt;/li&gt;
&lt;li&gt; 需求冲突识别——关注改动范围，识别其他需求是否也存在改动该段代码问题，避免需求冲突&lt;/li&gt;
&lt;li&gt; 提高个人代码评审能力——学习研发针对代码评审的意见/建议以及好的代码实现逻辑，便于问题更早的发现（以及代码编写规范、可读性、可维护性等）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;3.7 冒烟测试阶段&lt;/h4&gt;

&lt;p&gt;冒烟测试是指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性，尽早发现较阻塞进度问题，提前识别。&lt;/p&gt;

&lt;p&gt;冒烟测试阶段重点关注的维度：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 基本功能验证——优先验证基本功能是否可用，便于后续逻辑等较复杂功能开展&lt;/li&gt;
&lt;li&gt; 主流程验证——优先识别主流程问题，避免流程阻塞，阻碍测试进度，提前暴露流程问题及风险（方式依据项目/需求情况有效采取手工/自动化方式进行）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;3.8 功能测试阶段（内部测试阶段）&lt;/h4&gt;

&lt;p&gt;功能测试阶段开始了大规模的测试工作，在此期间仔细详尽的测试，&lt;/p&gt;

&lt;p&gt;功能测试阶段核心把控的思想：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 明确变更同步——针对测试阶段任何变更需同步至相关方，避免一方不知情&lt;/li&gt;
&lt;li&gt; 识别需求冲突——共同测试需求，测试分支、需求相互影响&lt;/li&gt;
&lt;li&gt; 测试数据高效使用——分析测试数据是否可验证多用例，高效使用测试数据验证尽可能多用例提升效率&lt;/li&gt;
&lt;li&gt; 测试问题务必抛出——测试阶段发现的问题即使较小也需要抛出来提供给相关确认方确认，如无需更改则记录相关结论&lt;/li&gt;
&lt;li&gt; 探索性测试——探索性测试，可在测试阶段发现前期未识别到的影响功能等&lt;/li&gt;
&lt;li&gt; 测试进度报告、风险抛出——针对时间较长/较大需求、项目发送测试进度报告，暴露风险（识别是否有影响进度、质量等风险问题，抛出问题，记录待确认问题及已沟通确认问题&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;3.9 联调测试阶段（包含研发联调、测试联调）&lt;/h4&gt;

&lt;p&gt;联调测试为了保障该需求/项目的所有改动场景下发的数据在全链路系统下正常流转闭环，覆盖用户真实实操场景来确保项目/需求的交付质量。&lt;/p&gt;

&lt;p&gt;联调测试阶段注重：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 研发联调环节——再次核对涉及系统交互需求/项目，研发联调工作是否覆盖主流程测试点&lt;/li&gt;
&lt;li&gt; 联调场景验证——与全链路系统进行联调测试验证，覆盖用户真实实操场景&lt;/li&gt;
&lt;li&gt; 补全联调场景——在联调阶段，可能存在场景覆盖不全情况，可有选择性了解上下游系统逻辑，可覆盖补全联调场景，且针对接口及消息尽量全的确保数据传输场景&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.10 稳定性测试（适用于APP）&lt;/p&gt;

&lt;p&gt;为保障APP端用户体验，APP稳定性测试不可或缺，上线前针对上线版本进行稳定性测试已加入到APP测试流程中，日常针对APP稳定性随机测试也持续监控。&lt;/p&gt;

&lt;p&gt;稳定性测试需监控：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 崩溃率——监控阿凡达平台统计，分析APP线上崩溃原因，丰富稳定性测试脚本&lt;/li&gt;
&lt;li&gt; CPU实时监控——记录稳定性测试期间对应版本的CPU占用数据，平均值、最大值&lt;/li&gt;
&lt;li&gt; 内存实时监控——记录稳定性测试期间对应版本内存占用数据，平均值、最大值&lt;/li&gt;
&lt;li&gt; 网络实时监控——记录稳定性测试期间对应版本流量占用数据，平均值、最大值&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;3.11 UAT阶段&lt;/h4&gt;

&lt;p&gt;UAT阶段主要为业务验收阶段，用户角色验收产研测交付内容，为确保UAT顺利进行，较大项目/需求测试人员有针对性进行主流程拉通测试可提前发现配置、环境因素所产生的问题，此环节可加快UAT进度确保项目更高效交付（该阶段可根据项目诉求调整）。&lt;/p&gt;

&lt;p&gt;UAT阶段应保障：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 拉通主流程——根据项目/需求大小确定是否需拉通UAT，避免UAT因配置/环境等原因产生流程阻塞&lt;/li&gt;
&lt;li&gt; 跟进/复盘UAT问题——针对较大项目/需求跟进及复盘UAT中产生的问题，规避重复问题产生事项&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;3.12 上线前master回归测试阶段&lt;/h4&gt;

&lt;p&gt;上线前master回归未确保长时间需求不上线分支及版本冲突等因素，上线当前进行master回归操作可有效确保发布内容运行稳定，保障质量。&lt;/p&gt;

&lt;p&gt;master回归阶段需check：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; master回归测试——回归上线功能主流程以及原有流程主流程，规避测试分支与上线分支代码冲突等问题&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;4 暴露风险最终与协作方共同确定运作策略&lt;/h3&gt;

&lt;p&gt;在项目各环节已前置思考可能带来的风险，提前规避、提前暴露，但并不能完全保障，那么在暴露风险后，可参考风险程度分析与分类定位，与项目各方高效协作，共同商榷解除风险的可行性方案以及后续运行策略。&lt;/p&gt;

&lt;h4&gt;4.1 风险程度分析&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;  极小：没有危害或微小危害 20%&lt;/li&gt;
&lt;li&gt;  轻度：轻度危害 40%&lt;/li&gt;
&lt;li&gt;  中度：中等 60%&lt;/li&gt;
&lt;li&gt;  重度：较大危害 80%&lt;/li&gt;
&lt;li&gt;  极大：重度危害 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;4.2 风险识别分类/分解结构&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;  技术类：明确是否为需求/技术层面引起的风险&lt;/li&gt;
&lt;li&gt;  组织类：明确是否为项目依赖关系、资源等原因引起的风险&lt;/li&gt;
&lt;li&gt;  外部：明确外部影响具体原因&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;4.3 与协作方共同商榷风险推进方案&lt;/h4&gt;

&lt;p&gt;测试人员可根据测试角度定位风险优先级，优先解决风险程度较高问题，且优先级较高风险需同步至上级知悉，必要时可采取升级等方式处理；&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 如为技术类风险——与项目经理、产品、研发共同评估技术层面解除方案；&lt;/li&gt;
&lt;li&gt; 如为组织类风险——与项目经理、产品、研发共同协同调整计划/申请资源等方式处理；&lt;/li&gt;
&lt;li&gt; 如为外部风险——测试人员需提供具体问题，协同项目经理、产品沟通具体原因，采取相对应的应对措施；&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;4.4 举例说明&lt;/h4&gt;

&lt;p&gt;4.4.1 举例一&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;背景：&lt;/strong&gt;管理工作台项目（优先级top1，交付时间紧，开发工作量大）&lt;br/&gt;
&lt;strong&gt;产生问题：&lt;/strong&gt;因测试周期时间紧，为避免延期提测，测试在研发阶段明确提测时间时，发现提测存在延期风险&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;依据风险程度，可内部解除的快速推进落地，需耗时较长/协调资源等需及时反馈至上级沟通，确保风险尽快解除落地。&lt;/p&gt;

&lt;h3&gt;5 总结&lt;/h3&gt;

&lt;p&gt;前置评估、高效协作&lt;/p&gt;

&lt;p&gt;保障在前置阶段通过测试经验总结提前思考后续阶段会带来的影响，包含但不仅限于：信息不同步、影响范围不明确、依赖关系不清晰等，前置有意识的识别较容易影响进度、质量问题及风险点，并暴露问题，继而与相关协作方高效协作、评估及推进风险点解除，避免问题后置暴露在测试阶段甚至交付上线阶段。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a2cda73aebba27deb6edabcfb2650751</guid>
<title>Vue3 响应式 API 之 ref 和 reactive</title>
<link>https://toutiao.io/k/6roiua9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们知道 ref 函数和 reactive 函数用于实现数据的响应性。但是开发中如何选择使用 ref 和 reactive 呢？下面我们就详细说说 ref 和 reactive 的区别。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回顾&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Vue3 版本之前，响应数据在 data 函数中定义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;  &amp;lt;h1&amp;gt;{{ title }}&amp;lt;/h1&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;  &lt;span&gt;export&lt;/span&gt; default {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;data&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;        title: &lt;span&gt;&quot;Hello, Vue!&quot;&lt;/span&gt;&lt;br/&gt;      };&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue2 会遍历 data 中的所有属性，使用 Object.defineProperty 把每个 property 全部转为 getter/setter，getter 用来收集依赖，setter 用来执行 notify，发布更新事件。Vue2 对每个属性创建一个 Dep 对象，作为订阅发布模式的中间机构来收集依赖。Vue 追踪这些依赖，在其被访问和修改时通知变更。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Vue3&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue3 中引入了 ref，reactive 来创建响应式数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;  &amp;lt;h1&amp;gt;{{ title }}&amp;lt;/h1&amp;gt;&lt;br/&gt;  &amp;lt;h2&amp;gt;{{ data.author }}&amp;lt;/h2&amp;gt;&lt;br/&gt;  &amp;lt;button @click=&lt;span&gt;&quot;&quot;&lt;/span&gt;changeTitle&amp;gt;修改title&amp;lt;/button&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;  import { ref, reactive, toRefs } from &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;export&lt;/span&gt; default {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;setup&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      const title = ref(&lt;span&gt;&quot;Hello, Vue 3!&quot;&lt;/span&gt;);&lt;br/&gt;      // 修改&lt;br/&gt;      &lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;changeTitle&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        title.value == &lt;span&gt;&quot;Hello, Vue3!&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      const data = reactive({&lt;br/&gt;        author: &lt;span&gt;&quot;青年码农&quot;&lt;/span&gt;,&lt;br/&gt;        age: &lt;span&gt;&quot;18&quot;&lt;/span&gt;&lt;br/&gt;      });&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; { title, data, changeTitle };&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的代码我们大概可以看出区别。ref 的作用就是将一个原始数据类型转换成一个响应式数据，原始数据类型共有 7 个，分别是：String、Number、BigInt、Boolean、Symbol、Undefined、Null。但是有个奇淫技巧，那就是 ref 也可以是对象。后面我们再说。reactive 的作用就是将一个对象转换成一个响应式对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ref&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;ref 的作用就是将一个原始数据类型转换成一个带有响应式特性的数据类型。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const title = ref(&lt;span&gt;&quot;Hello, Vue 3!&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ref 接收参数并将其包裹在一个带有 value 属性的对象中返回，然后可以使用该属性访问或更改响应式变量的值，比如上面的代码我们使用 count.value 去修改值，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;title.value = &lt;span&gt;&quot;Hello, Vue3!&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到了 ref 也是可以接受对象类型&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const data = ref({&lt;br/&gt;    author: &lt;span&gt;&quot;青年码农&quot;&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;&quot;18&quot;&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种也是可以的，赋值的时候就会有点别扭了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;data.value.author = &lt;span&gt;&quot;nmgwap&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ref 响应式原理是依赖于 Object.defineProperty()，因此如果是对象，还是建议用 reactive。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;216&quot; data-backw=&quot;416&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5192307692307693&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ldv96ZtlFHSQHJYRvOmWuNibo0t4l5ibEmzOPFQX0mSEtEmnJiay6Ziawgib9H0IlXic1olb7Jj9ATWXGEDzJM1wL8EA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;416&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;reactive&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;reactive 返回对象的响应式副本, 它将解包所有深层的 refs，同时维持 ref 的响应性。一般我们用来实现对象或者数组的响应性。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const data = reactive({&lt;br/&gt;    author: &lt;span&gt;&quot;青年码农&quot;&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;&quot;18&quot;&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改和普通对象没区别，视图会实时更新&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;data.author = &lt;span&gt;&quot;nmgwap&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ref 是针对原始数据类型 和 reactive 是用于对象 这两个 API 都是为了给 JavaScript 普通的数据类型赋予响应式特性(reactivity)。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0fdabc8847e9d270e39c795260790b4b</guid>
<title>软件架构的 10 个质量属性</title>
<link>https://toutiao.io/k/skttt3x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;一般地，对于软件系统的需求而言，分为两类：功能性需求和非功能性需求。软件系统的架构设计既要满足软件的功能性需求，还要满足软件的非功能性需求。特别地， 系统架构对软件非功能性需求的支撑成为架构的质量属性。本文描述了软件的10个质量属性， 但不意味着每个质量属性都会在架构设计中呈现，可以挑选对产品最重要的质量属性，然后进行实现。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/DE2dk1GjczpDZ6wiaMMpWGTAX34mZxoLUUpBxZyvX6jNTASgdMDg1begHfUklVia7pQoZKyzjRlHibj2rKUA9pJ1g/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;h2&gt;1 可伸缩性&lt;/h2&gt;&lt;p&gt;随着用户或请求数量的增加，系统运行和操作的能力也随之增加。在云平台上，可伸缩性可以通过机器的水平或垂直缩放或者简单地附加 AutoScalingGroup 来实现。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;流量模式:&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;了解系统的交通模式。尽可能多地产生机器是不划算的，即使它的利用率不高。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;自动缩放&lt;/strong&gt;: 能够迅速产生一些机器，以处理流量的爆发，当&lt;span&gt;需求&lt;/span&gt;&lt;span&gt;正在减少时，&lt;/span&gt;优雅地收缩。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;延迟&lt;/strong&gt;: 能够尽快为请求提供服务。这还包括优化算法和在用户位置附近复制系统，以减少请求的往返。&lt;/p&gt;&lt;h2&gt;2 可用性&lt;/h2&gt;&lt;p&gt;它以正常运行时间的百分比来衡量，并定义了系统正常运行和正常工作的时间比例。可用性受到系统错误、基础设施问题、恶意攻击和系统负载的影响。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;部署标记&lt;/strong&gt;: 部署应用程序组件的多个独立副本，包括数据存储区&lt;/p&gt;&lt;p&gt;&lt;strong&gt;区域部署&lt;/strong&gt;: 将后端服务部署到一组地理节点中，每个节点都可以服务任何区域中的任何客户端请求。&lt;/p&gt;&lt;h2&gt;3 可扩展性&lt;/h2&gt;&lt;p&gt;可扩展性度量扩展了系统的能力和实现扩展所需的工作。扩展可以通过添加新功能或修改现有功能来实现，该原则规定在不损害当前系统功能的情况下进行增强。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;模块化/可重用性&lt;/strong&gt;: 可重用性和可扩展性使得技术可以以更少的开发和维护时间转移到另一个项目，同时增强了可靠性和一致性。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可插拔性&lt;/strong&gt;: 能够轻松地插入其他组件，比如微内核架构。&lt;/p&gt;&lt;h2&gt;4 一致性&lt;/h2&gt;&lt;p&gt;一致性保证每个读操作返回最近的写操作。这意味着在执行每个操作之后，所有节点的数据都是一致的，因此，，无论它们连接到哪个节点，所有客户端都可以同时看到相同的数据。一致性提高了数据的新鲜程度。&lt;/p&gt;&lt;h2&gt;5 弹性&lt;/h2&gt;&lt;p&gt;系统可以从容地处理意外故障和恶意故障并进行恢复，检测故障并快速有效地恢复对于保持弹性是必要的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可恢复性&lt;/strong&gt;: 准备的过程和功能能够在发生意外更改后将服务返回到初始运行状态。意外的更改包括应用程序的软删除或硬删除或错误配置。灾难恢复包括了旨在防止或尽量减少灾难性事件造成的数据丢失和业务中断的最佳实践，涵盖了从设备故障和局部停电到网络攻击、民事紧急情况、犯罪或军事攻击以及自然灾害。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;设计模式:&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;隔离: 将应用程序的元素隔离到池中，以便在一个池失败时，其他元素继续运行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;断路器: 当连接到远程服务或资源时，处理可能需要花费不同时间来修复的故障。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;选举: 通过选举一个实例作为负责管理其他实例的领导者，协调分布式应用程序中协作任务实例集合执行的操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/DE2dk1GjczpDZ6wiaMMpWGTAX34mZxoLUxUs3NTh0bGhqqLKy3s4u40HmBtrAibXTL8rXqyaKGGVPcmJUDh9yreg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;h2&gt;6 易用性&lt;/h2&gt;&lt;p&gt;可用性可以描述为一个系统的能力，为其用户提供一个条件，以执行任务的安全有效，同时拥有良好的用户体验。它是指特定的消费者能够使用软件在量化的环境中以有效、高效和满意的方式实现量化目标的程度。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;易访问性&lt;/strong&gt;: 让具有最广泛特征和功能的人可以使用该软件。这包括失聪、失明、色盲等用户。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;易学性&lt;/strong&gt;: 用户学习如何使用软件有多容易？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;API 契约&lt;/strong&gt;: 对于内部团队，理解 API 契约有助于轻松接入任何系统。&lt;/p&gt;&lt;h2&gt;7 可观测性&lt;/h2&gt;&lt;p&gt;可观测性是收集关于程序执行、模块内部状态及组件间通信的数据的能力。为了提高可观测性，可以使用各种测试跟踪技术和工具。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;日志记录&lt;/strong&gt;: 在每个请求中生成不同类型的日志: 事件日志、事务日志、消息日志和服务器日志。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;警报和监控&lt;/strong&gt;: 准备监控仪表板，创建 SLI (服务水平指示器)并设置关键警报。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;L1/L2/L3&lt;/strong&gt;: 为 L1/L2设置随叫随到的支持流程。L1支持包括与客户交互，L2支持 L1路由到它们的工单，并帮助进行故障排除。L3是支持的最后一环，通常包括一个解决技术问题的开发团队。&lt;/p&gt;&lt;h2&gt;8 安全性&lt;/h2&gt;&lt;p&gt;软件保护信息和数据，使人或其他产品或系统有相应的数据访问类型和授权水平。这一系列特征包括机密性(数据只能被授权访问) ，完整性(软件防止未经授权访问或修改软件或信息) ，不可否认性(能否证明已经发生的行为或事件) ，问责性(能否追踪用户的行为)和真实性(验证用户的身份)。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可审核性&lt;/strong&gt;: 审核并跟踪系统活动，以便在发生安全性缺陷时，可以确定缺陷的机制和程度。远程存储审计跟踪(可以防止入侵者掩盖其踪迹。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;合法性&lt;/strong&gt;:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;身份验证&lt;/strong&gt;: 确保用户身份的安全性要求。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;授权&lt;/strong&gt;: 确保用户只能访问应用程序中的某些功能(通过用例、子系统、网页、业务规则、字段级别等)。&lt;/p&gt;&lt;h2&gt;9 持久性&lt;/h2&gt;&lt;p&gt;持久性是软件可服务性的解决能力，能够较长时间地满足用户的需求。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;复制&lt;/strong&gt;: 涉及共享信息，以确保冗余资源之间的一致性，从而提高可靠性、容错性或可访问性。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;容错性&lt;/strong&gt;: 容错性是一种特性，它使系统能够在某些组件出现一个或多个故障时继续正常运行。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可归档性&lt;/strong&gt;: 数据是否需要在一段时间后归档或删除？(例如，客户数据将在三个月后被删除，或被标记为过时，并存档在备用数据库中，以便将来访问。)&lt;/p&gt;&lt;h2&gt;10 敏捷性&lt;/h2&gt;&lt;p&gt;敏捷已经成为当今描述当代软件方法的流行语，相关的敏捷团队可能是一个能够适应变化的团队。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可维护性&lt;/strong&gt;: 应用更改和增强系统有多容易？表示开发人员可以修改软件以改进、纠正或使其适应环境和需求变化的有效性和效率程度。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可部署性&lt;/strong&gt;: 在提交部署之后到代码投入生产的时间。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可安装性&lt;/strong&gt;: 易于在所有必要的平台上安装系统。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可升级性&lt;/strong&gt;: 在服务器和客户端上从此应用程序/解决方案的以前版本轻松/快速升级到较新版本的能力。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可移植性&lt;/strong&gt;: 系统是否需要在多个平台上运行？(例如，前端是否需要针对 Oracle 和 SAP 运行？）&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可配置性&lt;/strong&gt;: 最终用户可以轻松地更改软件配置的各个方面(通过可用的接口)。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;兼容性&lt;/strong&gt;: 产品、系统或组件在共享相同的硬件或软件环境时，与其他产品、设计或成员交换信息并执行所需功能的程度。&lt;/p&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;了解了软件架构中的10个质量属性，我们可能需要考虑哪一个质量属性更是适合自己的产品或项目。那么，如何在项目中继续采用这些特性呢？&lt;/p&gt;&lt;p&gt;一旦了解了功能性需求，尝试找出系统中可能给这些功能增加障碍的瓶颈。如何找到瓶颈呢？可以试着回答几个这样的问题:&lt;/p&gt;&lt;p&gt;更多的思考，更多的工具，更多的设计原则， 可以参考《持续架构实践》一书。&lt;/p&gt;&lt;p&gt;下面是上周直播的有关本书的2个视频。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAfv42ZO6iAQAAAAstQy6ubaLX4KHWvLEZgBPE-YE8NmdIbsWAzNPgMIs3HO26zGxwzO9VLFaBjTSY&quot; data-url=&quot;https://findermp.video.qq.com/251/20350/stodownload?encfilekey=oibeqyX228riaCwo9STVsGLPj9UYCicgttvAUahr7lYVVMlzsuO5dHWDkEJTn74VdmNsDcmsBibh1WZhtjPLhulfrqSPGNcpYuS2vqwzOSty5eNQW68picSFXL44OuVbhcgWxp1ElLdKjm7Q&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=0462003883f0732ae5e9dc8223634e4e&amp;amp;token=AxricY7RBHdVdBSIpFYLpcpohn0sfiaqXMBecTo0iaG6KsyeU5icakySibaNxJRojEzheNxnsq7hdKL4&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/OM4v0FU2h0udMmuITa6G7VpS0IYFFs8Cb9iaPvSyicd0vnAGZq3cmWAg/0&quot; data-username=&quot;v2_060000231003b20faec8c4e28d11c2d0cd0cea30b0775e99a4475039b31ce2f9b0ac47457b13@finder&quot; data-nickname=&quot;右军&quot; data-desc=&quot;&quot; data-nonceid=&quot;8417252746245173060&quot; data-type=&quot;video&quot; data-authiconurl=&quot;&quot; data-width=&quot;640&quot; data-height=&quot;360&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAA84wVibqNwQAAAAstQy6ubaLX4KHWvLEZgBPEhoFgSldEbsWAzNPgMIvwgdtpQXNhurol1ysWvDJx&quot; data-url=&quot;https://findermp.video.qq.com/251/20350/stodownload?encfilekey=oibeqyX228riaCwo9STVsGLPj9UYCicgttvh4UIyNGkTBFTicEo6J0BKblekEB2yN28cSicJXebVXKvQlTShROnUNibqQibWQZ8gQwIn21SsMr12ZknPwm89NtDhPfmebmaAuEdVI6XLnCPHuA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=87cd69a348c3d61a6bfd5b7c1a8d02c4&amp;amp;token=x5Y29zUxcibC682x1fZ313K2EDricxt5fUGyicicdJKqRJA6ibPNx1IrT94s8A0V9tMqfibRpGm4KcnsE&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/OM4v0FU2h0udMmuITa6G7VpS0IYFFs8Cb9iaPvSyicd0vnAGZq3cmWAg/0&quot; data-username=&quot;v2_060000231003b20faec8c4e28d11c2d0cd0cea30b0775e99a4475039b31ce2f9b0ac47457b13@finder&quot; data-nickname=&quot;右军&quot; data-desc=&quot;软件架构#复用&quot; data-nonceid=&quot;7622792106747632853&quot; data-type=&quot;video&quot; data-authiconurl=&quot;&quot; data-width=&quot;640&quot; data-height=&quot;360&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.3140096618357489&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWF6LS3wytYTKKRk3ibPibr1Bob1nzOBfv0aQK09valJ2DQoKfCichOxAhvAuUPNOAcYl7jyVtjRQs7SA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;往期推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p draggable=&quot;true&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;技术琐话 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以分布式设计、架构、体系思想为基础，兼论研发相关的点点滴滴，不限于代码、质量体系和研发管理。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable js_wx_tap_highlight&quot; data-id=&quot;MzIxMzEzMjM5NQ==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/nhlGsolibOWF3auwD2unWLZHOt6TeCJ1iboL4Po7ickwKsibk7WgicbkOxG7wibMw8ZsSMQtDpR9D3OsF2RKibxKN00Xg/0?wx_fmt=png&quot; data-nickname=&quot;技术琐话&quot; data-alias=&quot;TheoryPractice&quot; data-signature=&quot;最干货的分布式技术公众号，范围包括大数据/运维/Java/人工智能，兼及研发管理。本号专家阵容：蚂蚁金服右军、NETSTARS CTO陈斌、江苏百瑞赢CTO李伟山、某互联网公司技术总监老G先生、前蚂蚁金服高级技术专家张翔等。&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot; has-insert-preloading=&quot;1&quot; data-index=&quot;0&quot; data-origin_num=&quot;307&quot; data-isban=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>05fa9a1c42d8ff9488a02f3d25b73fe3</guid>
<title>面试官：一千万的数据，你是怎么查询的？</title>
<link>https://toutiao.io/k/pl76dj8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是田哥&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在给大家做模拟面试和简历优化，其中发现很多人一看到&lt;strong&gt;什么千万级数据&lt;/strong&gt;之类的面试题就会腿软。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许有些人没遇过上千万数据量的表，也不清楚查询上千万数据量的时候会发生什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天就来带大家实操一下，这次是基于&lt;strong&gt;MySQL 5.7.26&lt;/strong&gt;做测试&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;准备数据&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有一千万的数据怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有数据自己不会造吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;造数据难吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码创建一千万？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那是不可能的，太慢了，可能真的要跑一天。可以采用数据库脚本执行速度快很多。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建表&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt;  (&lt;br/&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT,&lt;br/&gt;  &lt;span&gt;`user_id`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`ip`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`op_data`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`attr1`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`attr2`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`attr3`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`attr4`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`attr5`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`attr6`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`attr7`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`attr8`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`attr9`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`attr10`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`attr11`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`attr12`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_general_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  PRIMARY &lt;span&gt;KEY&lt;/span&gt; (&lt;span&gt;`id`&lt;/span&gt;) &lt;span&gt;USING&lt;/span&gt; BTREE&lt;br/&gt;) &lt;span&gt;ENGINE&lt;/span&gt; = &lt;span&gt;InnoDB&lt;/span&gt; AUTO_INCREMENT = &lt;span&gt;1&lt;/span&gt; &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; = utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; = utf8mb4_general_ci ROW_FORMAT = Dynamic;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建数据脚本&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用批量插入，效率会快很多，而且每1000条数就commit，数据量太大，也会导致批量插入效率慢&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;DELIMITER ;;&lt;br/&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;PROCEDURE&lt;/span&gt; batch_insert_log()&lt;br/&gt;&lt;span&gt;BEGIN&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;DECLARE&lt;/span&gt; i &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;DECLARE&lt;/span&gt; userId &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;10000000&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;set&lt;/span&gt; @execSql = &lt;span&gt;&#x27;INSERT INTO `test`.`user_operation_log`(`user_id`, `ip`, `op_data`, `attr1`, `attr2`, `attr3`, `attr4`, `attr5`, `attr6`, `attr7`, `attr8`, `attr9`, `attr10`, `attr11`, `attr12`) VALUES&#x27;&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;set&lt;/span&gt; @execData = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;  WHILE i&amp;lt;=10000000 &lt;span&gt;DO&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;set&lt;/span&gt; @&lt;span&gt;attr&lt;/span&gt; = &lt;span&gt;&quot;&#x27;测试很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的属性&#x27;&quot;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;set&lt;/span&gt; @execData = &lt;span&gt;concat&lt;/span&gt;(@execData, &lt;span&gt;&quot;(&quot;&lt;/span&gt;, userId + i, &lt;span&gt;&quot;, &#x27;10.0.69.175&#x27;, &#x27;用户登录操作&#x27;&quot;&lt;/span&gt;, &lt;span&gt;&quot;,&quot;&lt;/span&gt;, @&lt;span&gt;attr&lt;/span&gt;, &lt;span&gt;&quot;,&quot;&lt;/span&gt;, @&lt;span&gt;attr&lt;/span&gt;, &lt;span&gt;&quot;,&quot;&lt;/span&gt;, @&lt;span&gt;attr&lt;/span&gt;, &lt;span&gt;&quot;,&quot;&lt;/span&gt;, @&lt;span&gt;attr&lt;/span&gt;, &lt;span&gt;&quot;,&quot;&lt;/span&gt;, @&lt;span&gt;attr&lt;/span&gt;, &lt;span&gt;&quot;,&quot;&lt;/span&gt;, @&lt;span&gt;attr&lt;/span&gt;, &lt;span&gt;&quot;,&quot;&lt;/span&gt;, @&lt;span&gt;attr&lt;/span&gt;, &lt;span&gt;&quot;,&quot;&lt;/span&gt;, @&lt;span&gt;attr&lt;/span&gt;, &lt;span&gt;&quot;,&quot;&lt;/span&gt;, @&lt;span&gt;attr&lt;/span&gt;, &lt;span&gt;&quot;,&quot;&lt;/span&gt;, @&lt;span&gt;attr&lt;/span&gt;, &lt;span&gt;&quot;,&quot;&lt;/span&gt;, @&lt;span&gt;attr&lt;/span&gt;, &lt;span&gt;&quot;,&quot;&lt;/span&gt;, @&lt;span&gt;attr&lt;/span&gt;, &lt;span&gt;&quot;)&quot;&lt;/span&gt;);&lt;br/&gt;  if i % 1000 = 0&lt;br/&gt;  then&lt;br/&gt;     &lt;span&gt;set&lt;/span&gt; @stmtSql = &lt;span&gt;concat&lt;/span&gt;(@execSql, @execData,&lt;span&gt;&quot;;&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;prepare&lt;/span&gt; stmt &lt;span&gt;from&lt;/span&gt; @stmtSql;&lt;br/&gt;    &lt;span&gt;execute&lt;/span&gt; stmt;&lt;br/&gt;    &lt;span&gt;DEALLOCATE&lt;/span&gt; &lt;span&gt;prepare&lt;/span&gt; stmt;&lt;br/&gt;    &lt;span&gt;commit&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt; @execData = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;   else&lt;br/&gt;     &lt;span&gt;set&lt;/span&gt; @execData = &lt;span&gt;concat&lt;/span&gt;(@execData, &lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;br/&gt;   &lt;span&gt;end&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;SET&lt;/span&gt; i=i+&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;END&lt;/span&gt; &lt;span&gt;WHILE&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;END&lt;/span&gt;;;&lt;br/&gt;DELIMITER ;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开始测试&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;哥的电脑配置比较低：win10 标压渣渣i5 读写约500MB的SSD&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于配置低，本次测试只准备了3148000条数据，占用了磁盘5G(还没建索引的情况下)，跑了38min，电脑配置好的同学，可以插入多点数据测试&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SELECT count(1) FROM `user_operation_log`&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果：3148000&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三次查询时间分别为：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;普通分页查询&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 支持 LIMIT 语句来选取指定的条数数据， Oracle 可以使用 ROWNUM 来选取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL分页查询语法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; [&lt;span&gt;offset&lt;/span&gt;,] &lt;span&gt;rows&lt;/span&gt; | &lt;span&gt;rows&lt;/span&gt; &lt;span&gt;OFFSET&lt;/span&gt; &lt;span&gt;offset&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一个参数指定第一个返回记录行的偏移量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个参数指定返回记录行的最大数目&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们开始测试查询结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询3次时间分别为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样看起来速度还行，不过是本地数据库，速度自然快点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换个角度来测试&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;相同偏移量，不同数据量&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;100000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;1000000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询时间如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数量&lt;/th&gt;&lt;th&gt;第一次&lt;/th&gt;&lt;th&gt;第二次&lt;/th&gt;&lt;th&gt;第三次&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10条&lt;/td&gt;&lt;td&gt;53ms&lt;/td&gt;&lt;td&gt;52ms&lt;/td&gt;&lt;td&gt;47ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;100条&lt;/td&gt;&lt;td&gt;50ms&lt;/td&gt;&lt;td&gt;60ms&lt;/td&gt;&lt;td&gt;55ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1000条&lt;/td&gt;&lt;td&gt;61ms&lt;/td&gt;&lt;td&gt;74ms&lt;/td&gt;&lt;td&gt;60ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;10000条&lt;/td&gt;&lt;td&gt;164ms&lt;/td&gt;&lt;td&gt;180ms&lt;/td&gt;&lt;td&gt;217ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;100000条&lt;/td&gt;&lt;td&gt;1609ms&lt;/td&gt;&lt;td&gt;1741ms&lt;/td&gt;&lt;td&gt;1764ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1000000条&lt;/td&gt;&lt;td&gt;16219ms&lt;/td&gt;&lt;td&gt;16889ms&lt;/td&gt;&lt;td&gt;17081ms&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面结果可以得出结束：&lt;strong&gt;数据量越大，花费时间越长&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;相同数据量，不同偏移量&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;100000&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;偏移量&lt;/th&gt;&lt;th&gt;第一次&lt;/th&gt;&lt;th&gt;第二次&lt;/th&gt;&lt;th&gt;第三次&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;100&lt;/td&gt;&lt;td&gt;36ms&lt;/td&gt;&lt;td&gt;40ms&lt;/td&gt;&lt;td&gt;36ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1000&lt;/td&gt;&lt;td&gt;31ms&lt;/td&gt;&lt;td&gt;38ms&lt;/td&gt;&lt;td&gt;32ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;10000&lt;/td&gt;&lt;td&gt;53ms&lt;/td&gt;&lt;td&gt;48ms&lt;/td&gt;&lt;td&gt;51ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;100000&lt;/td&gt;&lt;td&gt;622ms&lt;/td&gt;&lt;td&gt;576ms&lt;/td&gt;&lt;td&gt;627ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1000000&lt;/td&gt;&lt;td&gt;4891ms&lt;/td&gt;&lt;td&gt;5076ms&lt;/td&gt;&lt;td&gt;4856ms&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面结果可以得出结束：&lt;strong&gt;偏移量越大，花费时间越长&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;, &lt;span&gt;attr&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何优化&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然我们经过上面一番的折腾，也得出了结论，针对上面两个问题：偏移大、数据量大，我们分别着手优化&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优化偏移量大问题&lt;span/&gt;&lt;/h4&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;采用子查询方式&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以先定位偏移位置的 id，然后再查询数据&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &amp;gt;= (&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询结果如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;sql&lt;/th&gt;&lt;th&gt;花费时间&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;第一条&lt;/td&gt;&lt;td&gt;4818ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第二条(无索引情况下)&lt;/td&gt;&lt;td&gt;4329ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第二条(有索引情况下)&lt;/td&gt;&lt;td&gt;199ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第三条(无索引情况下)&lt;/td&gt;&lt;td&gt;4319ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第三条(有索引情况下)&lt;/td&gt;&lt;td&gt;201ms&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面结果得出结论：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一条花费的时间最大，第三条比第一条稍微好点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子查询使用索引速度更快&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：只适用于id递增的情况&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;id非递增的情况可以使用以下写法，但这种缺点是分页查询只能放在子查询里面&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：某些 mysql 版本不支持在 in 子句中使用 limit，所以采用了多个嵌套select&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; t.id &lt;span&gt;FROM&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt; t)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;采用 id 限定方式&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方法要求更高些，id必须是连续递增，而且还得计算id的范围，然后使用 between，sql如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;between&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;1000100&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &amp;gt;= &lt;span&gt;1000000&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询结果如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果可以看出这种方式非常快&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;注意：这里的 LIMIT 是限制了条数，没有采用偏移量&lt;/em&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优化数据量大问题&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果的数据量也会直接影响速度&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1000000&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1000000&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;, user_id, ip, op_data, attr1, attr2, attr3, attr4, attr5, attr6, attr7, attr8, attr9, attr10, attr11, attr12 &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;`user_operation_log`&lt;/span&gt; &lt;span&gt;LIMIT&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1000000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询结果如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;sql&lt;/th&gt;&lt;th&gt;花费时间&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;第一条&lt;/td&gt;&lt;td&gt;15676ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第二条&lt;/td&gt;&lt;td&gt;7298ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第三条&lt;/td&gt;&lt;td&gt;15960ms&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果可以看出减少不需要的列，查询效率也可以得到明显提升&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一条和第三条查询速度差不多，这时候你肯定会吐槽，那我还写那么多字段干啥呢，直接 * 不就完事了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意本人的 MySQL 服务器和客户端是在_同一台机器_上，所以查询数据相差不多，有条件的同学可以测测客户端与MySQL分开&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SELECT * 它不香吗？&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里顺便补充一下为什么要禁止 &lt;code&gt;SELECT *&lt;/code&gt;。难道简单无脑，它不香吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要两点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用 &quot;&lt;code&gt;SELECT * &lt;/code&gt;&quot; 数据库需要解析更多的对象、字段、权限、属性等相关内容，在 SQL 语句复杂，硬解析较多的情况下，会对数据库造成沉重的负担。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增大网络开销，&lt;code&gt;*&lt;/code&gt; 有时会误带上如log、IconMD5之类的无用且大文本字段，数据传输size会几何增涨。特别是MySQL和应用程序不在同一台机器，这种开销非常明显。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，如果你也需要修改简历，需要模拟面试的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;欢迎加入我的知识星球，我给你&lt;strong&gt;免费做&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.392&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/07BicZywOVtl3Hy5Al12e1adAoYLt8qWJuDVicFwk2oVSU26gTMgCba7ibibufIxJfGFSkOwcfxtbic7mxVQDlPJV5Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>499cbfd9f378933fc14fba84132c50ea</guid>
<title>细说｜Linux Out Of Memory 机制</title>
<link>https://toutiao.io/k/jo0so3f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;有时候我们会发现系统中某个进程会突然挂掉，通过查看系统日志发现是由于 &lt;code&gt;OOM机制&lt;/code&gt; 导致进程被杀掉。&lt;/p&gt;&lt;p&gt;今天我们就来介绍一下什么是 &lt;code&gt;OOM机制&lt;/code&gt; 以及怎么防止进程因为 &lt;code&gt;OOM机制&lt;/code&gt; 而被杀掉。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;什么是OOM机制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;OOM&lt;/code&gt; 是 Out Of Memory 的缩写，中文意思是内存不足。而 &lt;code&gt;OOM机制&lt;/code&gt; 是指当系统内存不足时，系统触发的应急机制。&lt;/p&gt;&lt;p&gt;当 Linux 内核发现系统中的物理内存不足时，首先会对系统中的可回收内存进行回收，能够被回收的内存有如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;读写文件时的页缓存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为了性能而延迟释放的空闲 slab 内存页。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当系统内存不足时，内核会优先释放这些内存页。因为使用这些内存页只是为了提升系统的性能，释放这些内存页也不会影响系统的正常运行。&lt;/p&gt;&lt;p&gt;如果释放上述的内存后，还不能解决内存不足的情况，那么内核会如何处理呢？答案就是：触发 &lt;code&gt;OOM killer&lt;/code&gt; 杀掉系统中占用内存最大的进程。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.46015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J6Q0zEBJqyQ5W97PpTS2VdRHW6WlfyFDms7r6BAd3KLcVgaru3CoMzmSWC7OSdAV3D64foTe1JMWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;可以看出，OOM killer 是防止系统崩溃的最后一个手段，不到迫不得已的情况是不会触发的。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;OOM killer 实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;接下来，我们分析一下内核是如何实现 OOM killer 的。&lt;/p&gt;&lt;p&gt;由于在 Linux 系统中，进程申请的都是虚拟内存地址。所以当程序调用 &lt;code&gt;malloc()&lt;/code&gt; 申请内存时，如果虚拟内存空间足够的话，是不会触发 OOM 机制的。&lt;/p&gt;&lt;p&gt;当进程访问虚拟内存地址时，如果此虚拟内存地址还没有映射到物理内存地址的话，那么将会触发 &lt;code&gt;缺页异常&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在缺页异常处理例程中，将会申请新的物理内存页，并且将进程的虚拟内存地址映射到刚申请的物理内存。&lt;/p&gt;&lt;p&gt;如果在申请物理内存时，系统中的物理内存不足，那么内核将会回收一些能够被回收的文件页缓存。如果回收完后，物理内存还是不足的话，那么将会触发 &lt;code&gt;swapping机制&lt;/code&gt;（如果开启了的话）。&lt;/p&gt;&lt;p&gt;&lt;code&gt;swapping机制&lt;/code&gt; 会将某些进程不常用的内存页写入到交换区（硬盘分区或文件）中，然后释放掉这些内存页，从而达到缓解内存不足的情况。&lt;/p&gt;&lt;p&gt;如果通过上面的手段还不能解决内存不足的情况，那么内核将会调用 &lt;code&gt;pagefault_out_of_memory()&lt;/code&gt; 函数来杀掉系统中占用物理内存最多的进程。&lt;/p&gt;&lt;p&gt;我们来看看 &lt;code&gt;pagefault_out_of_memory()&lt;/code&gt; 函数的实现：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;pagefault_out_of_memory&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    out_of_memory(&lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出，&lt;code&gt;pagefault_out_of_memory()&lt;/code&gt; 函数最终会调用 &lt;code&gt;out_of_memory()&lt;/code&gt; 来杀死系统中占用内存最多的进程。&lt;/p&gt;&lt;p&gt;我们继续来看看 &lt;code&gt;out_of_memory()&lt;/code&gt; 函数的实现：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;out_of_memory&lt;/span&gt;&lt;span&gt;(struct zonelist *zonelist, &lt;span&gt;gfp_t&lt;/span&gt; gfp_mask, &lt;span&gt;int&lt;/span&gt; order,&lt;br/&gt;                   &lt;span&gt;nodemask_t&lt;/span&gt; *nodemask, &lt;span&gt;bool&lt;/span&gt; force_kill)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1. 从系统中选择一个最坏(占用内存最多)的进程&lt;/span&gt;&lt;br/&gt;    p = select_bad_process(&amp;amp;points, totalpages, mpol_mask, force_kill);&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 2. 如果找到最坏的进程，那么调用 oom_kill_process 函数杀掉进程&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (p != (&lt;span&gt;void&lt;/span&gt; *)&lt;span&gt;-1U&lt;/span&gt;L) {&lt;br/&gt;        oom_kill_process(p, gfp_mask, order, points, totalpages, &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;                         nodemask, &lt;span&gt;&quot;Out of memory&quot;&lt;/span&gt;);&lt;br/&gt;        killed = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;out_of_memory()&lt;/code&gt; 函数的逻辑比较简单，主要完成两个事情：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;调用 &lt;code&gt;select_bad_process()&lt;/code&gt; 函数从系统中选择一个最坏（占用物理内存最多）的进程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果找到最坏的进程，那么调用 &lt;code&gt;oom_kill_process()&lt;/code&gt; 函数将此进程杀掉。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;从上面的分析可知，找到最坏的进程是 OOM killer 最为重要的事情。&lt;/p&gt;&lt;p&gt;那么我们来看看 &lt;code&gt;select_bad_process()&lt;/code&gt; 函数是怎样选择最坏的进程的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; struct task_struct *&lt;br/&gt;&lt;span&gt;select_bad_process&lt;/span&gt;&lt;span&gt;(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *ppoints, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; totalpages,&lt;br/&gt;                   &lt;span&gt;const&lt;/span&gt; &lt;span&gt;nodemask_t&lt;/span&gt; *nodemask, &lt;span&gt;bool&lt;/span&gt; force_kill)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; *&lt;span&gt;g&lt;/span&gt;, *&lt;span&gt;p&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; *&lt;span&gt;chosen&lt;/span&gt; = &lt;span&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; chosen_points = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1. 遍历系统中所有的进程和线程&lt;/span&gt;&lt;br/&gt;    for_each_process_thread(g, p) {&lt;br/&gt;        &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; points;&lt;br/&gt;        ...&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 2. 计算进程最坏分数值, 选择分数最大的进程作为杀掉的目标进程&lt;/span&gt;&lt;br/&gt;        points = oom_badness(p, &lt;span&gt;NULL&lt;/span&gt;, nodemask, totalpages);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!points || points &amp;lt; chosen_points)&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        ...&lt;br/&gt;        chosen = p;&lt;br/&gt;        chosen_points = points;&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; chosen;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;select_bad_process()&lt;/code&gt; 函数的主要工作如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;遍历系统中所有的进程和线程，并且调用 &lt;code&gt;oom_badness()&lt;/code&gt; 函数计算进程的最坏分数值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择最坏分数值最大的进程作为被杀掉的目标进程。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以，计算进程的最坏分数值就是 OOM killer 的核心工作。我们接着来看看 &lt;code&gt;oom_badness()&lt;/code&gt; 函数是怎么计算进程的最坏分数值的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;br/&gt;&lt;span&gt;oom_badness&lt;/span&gt;&lt;span&gt;(struct task_struct *p, struct mem_cgroup *memcg,&lt;br/&gt;            &lt;span&gt;const&lt;/span&gt; &lt;span&gt;nodemask_t&lt;/span&gt; *nodemask, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; totalpages)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; points;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; adj;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1. 如果进程不能被杀掉（init进程和内核进程是不能被杀的）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (oom_unkillable_task(p, memcg, nodemask))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 2. 我们可以通过 /proc/{pid}/oom_score_adj 文件来设置进程的被杀建议值，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//    这个值越小，进程被杀的机会越低。如果设置为 -1000 时，进程将被禁止杀掉。&lt;/span&gt;&lt;br/&gt;    adj = (&lt;span&gt;long&lt;/span&gt;)p-&amp;gt;signal-&amp;gt;oom_score_adj;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (adj == OOM_SCORE_ADJ_MIN) {&lt;br/&gt;        ...&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 3. 统计进程使用的物理内存数&lt;/span&gt;&lt;br/&gt;    points = get_mm_rss(p-&amp;gt;mm)&lt;br/&gt;                + atomic_long_read(&amp;amp;p-&amp;gt;mm-&amp;gt;nr_ptes)&lt;br/&gt;                + get_mm_counter(p-&amp;gt;mm, MM_SWAPENTS);&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 4. 加上进程被杀建议值，得出最终的分数值&lt;/span&gt;&lt;br/&gt;    adj *= totalpages / &lt;span&gt;1000&lt;/span&gt;;&lt;br/&gt;    points += adj;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; points &amp;gt; &lt;span&gt;0&lt;/span&gt; ? points : &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;oom_badness()&lt;/code&gt; 函数主要按照以下步骤来计算进程的最坏分数值：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果进程不能被杀掉（init进程和内核进程是不能被杀的），那么返回分数值为 0。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以通过 &lt;code&gt;/proc/{pid}/oom_score_adj&lt;/code&gt; 文件来设置进程的 OOM 建议值（取值范围为 -1000 ~ 1000）。建议值越小，进程被杀的机会越低。如果将其设置为 -1000 时，进程将被禁止杀掉。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;统计进程使用的物理内存数，包括实际使用的物理内存、页表占用的物理内存和 swap 机制占用的物理内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后加上进程的 OOM 建议值，得出最终的分数值。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;通过 &lt;code&gt;oom_badness()&lt;/code&gt; 函数计算出进程的最坏分数值后，系统就能从中选择一个分数值最大的进程杀死，从而解决内存不足的情况。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;禁止进程被 OOM 杀掉&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;有时候，我们不希望某些进程被 OOM killer 杀掉。例如 MySQL 进程如果被 OOM killer 杀掉的话，那么可能导致数据丢失的情况。&lt;/p&gt;&lt;p&gt;那么如何防止进程被 OOM killer 杀掉呢？从上面的分析可知，在内核计算进程最坏分数值时，会加上进程的 &lt;code&gt;oom_score_adj&lt;/code&gt;（OOM建议值）值。如果将此值设置为 &lt;code&gt;-1000&lt;/code&gt; 时，那么系统将会禁止 OOM killer 杀死此进程。&lt;/p&gt;&lt;p&gt;例如使用如下命令，将会禁止杀死 PID 为 2000 的进程：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ &lt;span&gt;echo&lt;/span&gt; -1000 &amp;gt; /proc/2000/oom_score_adj&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，我们就能防止一些重要的进程被 OOM killer 杀死。&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;89429&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;end&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;一口Linux &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关注，回复【&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1024&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;】海量Linux资料赠送&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_wx_tap_highlight&quot; data-id=&quot;MzUxMjEyNDgyNw==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8535w2vKlsLPf5hwdMjpYrzuVCHx0rcQmvv8rYqTFtIyic5qErtciaibqaIOWgeKkDsOMeae4HciaUaw/0?wx_fmt=png&quot; data-nickname=&quot;一口Linux&quot; data-alias=&quot;yikoulinux&quot; data-signature=&quot;一起学习嵌入式，Linux，网络，驱动，arm知识。&quot; data-from=&quot;2&quot; data-index=&quot;0&quot; data-origin_num=&quot;238&quot; data-isban=&quot;0&quot; data-weuitheme=&quot;light&quot; data-weui-theme=&quot;light&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;精彩文章合集&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;文章推荐&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;☞&lt;/span&gt;【专辑】&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxMjEyNDgyNw==&amp;amp;action=getalbum&amp;amp;album_id=1614665559315382276#wechat_redirect&quot; textvalue=&quot;从0学ARM&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;ARM&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;☞&lt;/span&gt;【专辑】&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxMjEyNDgyNw==&amp;amp;action=getalbum&amp;amp;album_id=1629876820810465283#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;粉丝问答&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;☞&lt;/span&gt;【&lt;span&gt;专辑&lt;/span&gt;】&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxMjEyNDgyNw==&amp;amp;action=getalbum&amp;amp;album_id=1507350615537025026#wechat_redirect&quot; textvalue=&quot;linux&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;linux&lt;/span&gt;&lt;/a&gt;&lt;span&gt;入门&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;☞&lt;/span&gt;【&lt;span&gt;专辑&lt;/span&gt;】&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxMjEyNDgyNw==&amp;amp;action=getalbum&amp;amp;album_id=1598710257097179137#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;计算机网络&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;☞&lt;/span&gt;【&lt;span&gt;专辑&lt;/span&gt;】&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxMjEyNDgyNw==&amp;amp;action=getalbum&amp;amp;album_id=1502410824114569216#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;Linux驱动&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;☞&lt;/span&gt;【干货】&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMjEyNDgyNw==&amp;amp;mid=2247496985&amp;amp;idx=1&amp;amp;sn=c3d5e8406ff328be92d3ef4814108cd0&amp;amp;chksm=f96b87edce1c0efb6f60a6a0088c714087e4a908db1938c44251cdd5175462160e26d50baf24&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;嵌入式驱动工程师学习路线&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;☞&lt;/span&gt;【干货】&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMjEyNDgyNw==&amp;amp;mid=2247497822&amp;amp;idx=1&amp;amp;sn=1e2aed9294f95ae43b1ad057c2262980&amp;amp;chksm=f96b8aaace1c03bc2c9b0c3a94c023062f15e9ccdea20cd76fd38967b8f2eaad4dfd28e1ca3d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Linux嵌入式所有知识点-思维导图&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>