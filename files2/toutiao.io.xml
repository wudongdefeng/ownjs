<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f65145ee9b85a0db7d73dcd1e1ba48a5</guid>
<title>软件架构可视化及 C4 模型：架构设计不仅仅是 UML</title>
<link>https://toutiao.io/k/6fx50ha</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;软件系统架构设计的目标不在于设计本身，而在于&lt;strong&gt;架构设计意图的传达&lt;/strong&gt;。图形化有助于在团队间进行高效的信息同步，但不同的图形化方式需要&lt;strong&gt;语义一致性和效率间实现平衡&lt;/strong&gt;。C4模型通过不同的抽象层级来表达系统的静态结构，并提供了最小集的抽象建模元素，为设计人员提供了一种低认知负载、易于学习和使用的高效建模方式。&lt;/p&gt;

&lt;hr/&gt;

&lt;h1&gt;&lt;strong&gt;1 为什么要进行架构可视化？&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;软件系统架构设计的目标不在于设计本身，而在于架构设计意图的传达。如果不能清晰、一致的在干系人间进行设计意图的同步，即使再好的设计也只是空中楼阁。软件架构设计本质上也是一种抽象和建模的过程（对模型和抽象的本质参考文章《 &lt;a href=&quot;http://jagile.jd.com/shendeng/article/detail/4239?forumId=79&amp;amp;jdme_router=jdme%3A%2F%2Fweb%2F202206081297%3Furl%3Dhttps%3A%2F%2Fshendengh5.jd.com%2FarticleDetail%3Fid%3D4239&quot;&gt;领域驱动设计开篇&lt;/a&gt;  》），软件架构设计模型的表达有多种方式：图形化、语言和文字。绝大部分场景下，&lt;strong&gt;图形化在架构设计的表现力层面效果更佳&lt;/strong&gt;。因此，对于软件系统架构进行可视化表达是有价值，且是必要的。&lt;/p&gt;

&lt;p&gt;软件架构可视化的方式有多种，不同的团队有不同的实践方式，最为常见的由如下几种：&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;线框图&lt;/strong&gt;：通过线框图和连线表达架构元素及之间的关系&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;UML&lt;/strong&gt;：统一建模语言，表达系统的静态结构和动态行为&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;草图&lt;/strong&gt;：非正式的图形&lt;/p&gt;

&lt;p&gt;不同的可视化方式各有优劣，以下部分将对不同的表现形式进行说明&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;1.1 可视化方式-线框图&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;线框图是最为通用的可视化表达方式之一，架构师或设计人员大量的架构图，比如技术架构、功能架构、数据架构、逻辑架构等等都通过线框图的形式表达。该种可视化方式的优势是：&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;建模工具多样化&lt;/strong&gt;：你可以基于Viso、Drawio、PPT等任何一款支持线框图的软件进行建模工作&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;学习成本低&lt;/strong&gt;：设计人员几乎不需要进行专门的建模语言以及建模工具的学习，门槛较低&lt;/p&gt;

&lt;p&gt;但，基于线框图表达软件系统架构存在的问题也非常明显：&lt;strong&gt;语义的一致性问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你可能自己画过很多软件系统架构图，也可能参与评审过其他团队的架构图，我相信，对你而言并不是的所有的图都是“&lt;strong&gt;清晰且易于理解的&lt;/strong&gt;”。举个简单的场景，如果我们在百度搜索 “架构图” ，你可能得到以下结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-056cpO10cLGjYc79tl.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;各式各样的 “架构图”&lt;/strong&gt;：不同形状和颜色的图形元素、不同形状和颜色的连线、不同的意图。&lt;/p&gt;

&lt;p&gt;我们可以看出：&lt;strong&gt;线框图虽然简单，但其其图形化的语义一致性是大问题&lt;/strong&gt;。虽然都是通过线框表达软件系统架构，但不同的人可能使用不同的元素、不同的颜色、不同的连线和分层等等，线框自由表达的灵活性和图形化语义的一致性存在潜在冲突，最终都会阻碍架构设计意图传达。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;1.2 可视化方式-UML&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;UML是统一建模语言，相比于线框图而言，其优势是在软件建模层面&lt;strong&gt;提供了一致性的建模元语言&lt;/strong&gt;。简单来说，UML提供了大家达成一致的（UML支持扩展的场景除外）建模元素。如果团队成员比较熟悉UML，那么通过UML表达的系统架构图天然具有认知一致性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;丰富灵活的建模元语言在提升语义一致性的同时，也必然会导致复杂性的上升&lt;/strong&gt;。掌握UML具有一定的学习成本，而熟练的应用对研发人员也提出了更高的要求。基于 Simon Brown给出的数据，实际情况只有少数团队真正使用UML。不论是UML的复杂度和学习成本原因，还是敏捷化下对UML的排斥，很多团队都放弃了UML。&lt;/p&gt;

&lt;p&gt;我们不能否认UML的价值，基于统一建模语言能够更有效的进行架构设计的信息传递和沟通，也能基于UML提供的详细的模型图元素进行充分的设计表达。团队中是否要基于UML进行沟通需要权衡，虽然UML不能表达你所要传达的全部的架构信息，但其在某些维度的表达相对比较适合。&lt;/p&gt;

&lt;p&gt;• 表达流程和工作流可以采用UML活动图&lt;/p&gt;

&lt;p&gt;• 表达运行时的交互可以采用UML时序图&lt;/p&gt;

&lt;p&gt;• 表达领域模型或者设计模式可以采用UML类图&lt;/p&gt;

&lt;p&gt;• 表达状态转换可以采用UML状态机&lt;/p&gt;

&lt;p&gt;• 表达系统的部署结构可以使用UML部署图&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;1.3 可视化方式-草图&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;架构可视化另一个非常常见的方式是：&lt;strong&gt;草图&lt;/strong&gt;。草图是一种&lt;strong&gt;非正式的、易于快速沟通&lt;/strong&gt;的图形化方式。团队基于特定的场景，可以通过草图的形式进行快速的沟通，以便高效的在干系人间拉齐关键信息。&lt;/p&gt;

&lt;p&gt;但，草图的劣势与线框图一样：&lt;strong&gt;语义一致性低&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们可以在白板上 “&lt;strong&gt;随心所欲&lt;/strong&gt;” 的画各式各样的草图，草图上的元素、连线，又或者布局都可能是&lt;strong&gt;涌现式的、临时性的&lt;/strong&gt;，这些&lt;strong&gt;草图的价值在于 “会话周期内的高效沟通”&lt;/strong&gt;。如果干系人没有完全参与到草图的讨论，又或是后置查看，大概也很难精准捕获这些草图所要表达的设计意图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-17nXf17YCXOv7wS0kg.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;2 C4 模型&lt;/strong&gt;&lt;/h1&gt;

&lt;h2&gt;&lt;strong&gt;2.1 C4模型的统一抽象&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;团队需要统一语言进行高效沟通 !!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C4模型在不同的级别提供了统一的抽象以表达软件系统的静态结构&lt;/strong&gt;。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-18JZt8LYi9ONkRXa8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;软件系统&lt;/strong&gt;：最顶层的抽象，其对用户提供价值。包含待构建的系统以及外部依赖的系统&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;容器&lt;/strong&gt;：表示一个应用或者数据存储，容器需要运行以支持系统的正常运转。&lt;strong&gt;每个容器都是独立部署或运行的单元，容器间的通信一般式跨进程交互&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;组件&lt;/strong&gt;：提供一定能力封装的单元。&lt;strong&gt;在C4模型上下文中，组件不是独立部署的单元，一般情况下运行于容器之中&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;代码&lt;/strong&gt;：系统的实现细节相关&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;人&lt;/strong&gt;：系统的使用用户&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2.2 上下文图：System Context Diagram&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;我们要构建的系统不会孤立存在，都会依赖现有的IT设施。要明确我们构建的系统是什么，宏观上需要回答：&lt;strong&gt;我们的系统如何融入到现有的IT设施&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;系统上下文图正是从高层视角表述待构建系统与当前IT设施的交互及边界。通过上下文图：&lt;/p&gt;

&lt;p&gt;• 展示&lt;strong&gt;与软件系统交互的各方及相互关系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;• 展示&lt;strong&gt;软件系统与外部环境的边界&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;• 作为了解系统架构的切入点&lt;/p&gt;

&lt;p&gt;• 确保所有人都理解、认可系统的工作范围&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-19yiRWG7nNed8GiUe.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2.3 容器图：Container Diargram&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;更进一步的剖析核心系统，回答：&lt;strong&gt;系统由哪些容器组成？容器的职责是什么？以及相关的高层的技术选型是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与Docker的容器概念不同，C4模型的容器是在 “系统” 作用域之下，其表达的是组成系统的可独立可部署的物理单元。以下图为例：单个容器元素重包含了名称、职责描述、技术选型，同时，容器间的连线及标注标识了其高层的交互协议及交互形式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-19sRqfOJv7gIeEchg.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2.4 组件图：Component Diagram&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;进一步的剖析容器，回答：容器由哪些组件组成？这些组件的职责及组件间的交互形式是什么？&lt;/p&gt;

&lt;p&gt;具体到每个容器内部，通过多个组件及组件间的关系表达容器的组成。“组件” 本身是一个泛化的概念，C4模型的组件是在 “容器” 的作用域之下，其表现形式可能是独立的Jar包，或者是应用内独立的包，也可能是类级别，但逻辑上都能够表达一个组件的概念。对于组件图关键的是要表示清楚组件的实现选型、组件职责以及组件间的交互关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-22jdDUiguwySLfEou.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2.5 代码&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;代码处于C4模型的最低层，且是可选的，其关注的是实现相关。C4模型并没有对实现层面的可视化进行统一抽象，开发人员可以选择UML类图、E-R图等进行可视化。是否需要提现代码层面研发人员基于具体情况具体分析，&lt;strong&gt;一般情况下，如果系统中需要重点关注的部分可以考虑一些代码级别的图支持&lt;/strong&gt;，比如，我们非常关注系统设计的可扩展性，则关键部分可能需要一些类图表达；又或者非常关注底层数据模型，则E-R图可以纳入考虑范围。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-22P8Fj7lkKBA8AjFM.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;3 C4模型实践中的决策和问题&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;连线表达依赖关系还是数据流向 ？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;都可以，C4模型中的连线既可以表达依赖方向，也可以表达数据流向。原则上，&lt;strong&gt;设计人员需要保证其清晰且无歧义&lt;/strong&gt;。实践中一般通过合理的文字说明来明确的表达元素间的关系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jar或类库应该建模为“容器”？ “组件” ？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jar包或类库一般是链接到调用方的进程中，作为进程中的一部分存在，这种依赖一般不表示为容器，而是组件。当然，是否要将Jar，比如SDK表示为组件并体现在组件图上需要设计人员具体情况具体分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据存储系统应该建模为 “软件系统” 还是 “容器” ？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据存储系统，比如MySQL、DFS等一般是作为独立的外部存储集群存在，集群的运维可能归属于公司的运维团队。以OSS为例，但从应用角度而言，即使集群的运维不归属当前开发团队，团队也会申请租户隔离的专属空间，因此，在C4模型中这种情况应该表述为 “容器”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;消息系统应该如何建模 ？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;消息系统一般作为两个容器间的交互媒介，因此在C4模型中消息系统的建模存在两种方式：&lt;/p&gt;

&lt;p&gt;• 依赖消息系统的容器都显示与消息系统交互，明确的表达各自与消息系统的依赖关系或数据流向&lt;/p&gt;

&lt;p&gt;• 屏蔽消息系统，只提现容器间的依赖关系，并对依赖进行明确说明&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图形化的过期问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C4模型本身也是一种文档化机制，同样也存在过期问题。只不过&lt;strong&gt;C4模型通过对系统在不同的层级进行抽象，每个抽象层级的过期频率不同&lt;/strong&gt;，由上到下逐渐增大，上下文图的变化频率最小，而代码级则变化最大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么C4不涉及业务流、状态机、数据模型等建模&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C4模型仅对系统的静态结构进行建模，并不试图囊括或替代其它建模方式，C4模型并不适合所有维度的可视化表达。对于业务流可以基于BPML、UML活动图进行表达，状态机可以基于UML状态机图进行表达，而数据模型可以通过E-R图表达，不同建模语言相互补充。&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;4 系统架构设计关注不同维度&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;作为架构师或系统设计人员，在进行系统架构设计时一般会关注不同维度，一般情况下，对于业务系统建设而言，会关注以下维度。在架构设计（架构和设计）过程中，基于C4模型、UML及BPML等多种建模方式相互补充，不同表现维度下可以采用不同的建模方式&lt;/p&gt;

&lt;p&gt;• 业务流程：泳道图或UML活动图，表达核心的业务流&lt;/p&gt;

&lt;p&gt;• 业务用例、系统用例：UML用例图&lt;/p&gt;

&lt;p&gt;• 领域模型：UML类图&lt;/p&gt;

&lt;p&gt;• 系统边界：C1，系统上下文图&lt;/p&gt;

&lt;p&gt;• 高层技术选型：C2，容器图&lt;/p&gt;

&lt;p&gt;• 系统职责分配：用线框图表示功能架构&lt;/p&gt;

&lt;p&gt;• 关键部分的实现：C3，组件图&lt;/p&gt;

&lt;p&gt;• 系统关键的交互逻辑：UML时序图&lt;/p&gt;

&lt;p&gt;• 数据模型：E-R图&lt;/p&gt;

&lt;p&gt;• 关键实体的状态机：UML状态机图&lt;/p&gt;

&lt;p&gt;• 不同的高优先级架构属性的设计：比如，缓存方案、幂等性设计方案、定时任务补偿策略、降级限流策略等等，这些都与具体的需求所关注的高优先级的架构属性相关。&lt;/p&gt;

&lt;p&gt;• 部署架构：UML部署图&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;5 总结&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;软件架构设计的终极目标不在于设计本身，而在于架构设计意图的传达。图形化有助于在团队间进行高效的信息同步，但&lt;strong&gt;不同的图形化方式在语义一致性和效率间存在平衡&lt;/strong&gt;。C4模型通过不同的抽象层级来表达系统的静态结构，并提供了最小及的抽象建模元素，为设计人员提供了一种&lt;strong&gt;低认知负载、易于学习和使用&lt;/strong&gt;的高效的建模方式。在实际项目落地过程中，结合C4模型以及UML、线框图等组合方式对架构设计进行可视化表达，一定程度上能够提升团队对架构设计认知的一致性以及建模效率。&lt;/p&gt;

&lt;p&gt;作者：倪新明&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20b840c905c18cc70b9c45a2ffbcac28</guid>
<title>ThreadLocal 夺命 11 连问</title>
<link>https://toutiao.io/k/dtj3btq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前一段时间，有同事使用&lt;code&gt;ThreadLocal&lt;/code&gt;踩坑了，正好引起了我的兴趣。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以近期，我抽空把ThreadLocal的源码再研究了一下，越看越有意思，发现里面的东西还真不少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把精华浓缩了一下，汇集成了下面11个问题，看看你能顶住第几个？&lt;img data-ratio=&quot;0.8727810650887574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPwOE8aUPLISj0JWBM96Uhcfib0xSBpBPteS3icH0sPsicEoLBwoLmqc2Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1352&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 为什么要用ThreadLocal?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发编程是一项非常重要的技术，它让我们的程序变得更加高效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在并发的场景中，如果有多个线程同时修改公共变量，可能会出现线程安全问题，即该变量最终结果可能出现异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决线程安全问题，&lt;code&gt;JDK&lt;/code&gt;出现了很多技术手段，比如：使用&lt;code&gt;synchronized&lt;/code&gt;或&lt;code&gt;Lock&lt;/code&gt;，给访问公共资源的代码上锁，保证了代码的&lt;code&gt;原子性&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在高并发的场景中，如果多个线程同时竞争一把锁，这时会存在大量的锁等待，可能会浪费很多时间，让系统的响应时间一下子变慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，&lt;code&gt;JDK&lt;/code&gt;还提供了另外一种用空间换时间的新思路：&lt;code&gt;ThreadLocal&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的核心思想是：共享变量在每个&lt;code&gt;线程&lt;/code&gt;都有一个&lt;code&gt;副本&lt;/code&gt;，每个线程操作的都是自己的副本，对另外的线程没有影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        threadLocal.set(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        doSamething();&lt;br/&gt;        Integer integer = threadLocal.get();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. ThreadLocal的原理是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了搞清楚ThreadLocal的底层实现原理，我们不得不扒一下源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;的内部有一个静态的内部类叫：&lt;code&gt;ThreadLocalMap&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;     ...&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取当前线程&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;//获取当前线程的成员变量ThreadLocalMap对象&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//根据threadLocal对象从map中获取Entry对象&lt;/span&gt;&lt;br/&gt;            ThreadLocalMap.Entry e = map.getEntry(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;//获取保存的数据&lt;/span&gt;&lt;br/&gt;                T result = (T)e.value;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//初始化数据&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; setInitialValue();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; T &lt;span&gt;setInitialValue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取要初始化的数据&lt;/span&gt;&lt;br/&gt;        T value = initialValue();&lt;br/&gt;        &lt;span&gt;//获取当前线程&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;//获取当前线程的成员变量ThreadLocalMap对象&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;//如果map不为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;//将初始值设置到map中，key是this，即threadLocal对象，value是初始值&lt;/span&gt;&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;//如果map为空，则需要创建新的map对象&lt;/span&gt;&lt;br/&gt;            createMap(t, value);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(T value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取当前线程&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;//获取当前线程的成员变量ThreadLocalMap对象&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;//如果map不为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;//将值设置到map中，key是this，即threadLocal对象，value是传入的value值&lt;/span&gt;&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;//如果map为空，则需要创建新的map对象&lt;/span&gt;&lt;br/&gt;            createMap(t, value);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ...&lt;br/&gt;     }&lt;br/&gt;     ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;方法、&lt;code&gt;set&lt;/code&gt;方法和&lt;code&gt;setInitialValue&lt;/code&gt;方法，其实最终操作的都是&lt;code&gt;ThreadLocalMap&lt;/code&gt;类中的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中&lt;code&gt;ThreadLocalMap&lt;/code&gt;类的内部如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&amp;lt;&lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        Object value;&lt;br/&gt;&lt;br/&gt;        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;(k);&lt;br/&gt;            value = v;&lt;br/&gt;        }&lt;br/&gt;   }&lt;br/&gt;   ...&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; Entry[] table;&lt;br/&gt;   ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;里面包含一个静态的内部类&lt;code&gt;Entry&lt;/code&gt;，该类继承于&lt;code&gt;WeakReference&lt;/code&gt;类，说明&lt;code&gt;Entry&lt;/code&gt;是一个弱引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;内部还包含了一个&lt;code&gt;Entry&lt;/code&gt;数组，其中：&lt;code&gt;Entry&lt;/code&gt; = &lt;code&gt;ThreadLocal&lt;/code&gt; + &lt;code&gt;value&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;ThreadLocalMap&lt;/code&gt;被定义成了&lt;code&gt;Thread&lt;/code&gt;类的成员变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图从宏观上，认识一下ThreadLocal的整体结构：&lt;img data-ratio=&quot;0.6101398601398601&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPibvIt0m0xgZ5xPBg9icLaYJ2tpewlXIia04nCgAWicuVolVEdb6CJ469PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;从上图中看出，在每个&lt;code&gt;Thread&lt;/code&gt;类中，都有一个&lt;code&gt;ThreadLocalMap&lt;/code&gt;的成员变量，该变量包含了一个&lt;code&gt;Entry数组&lt;/code&gt;，该数组真正保存了ThreadLocal类set的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;是由threadLocal和value组成，其中threadLocal对象是弱引用，在&lt;code&gt;GC&lt;/code&gt;的时候，会被自动回收。而value就是ThreadLocal类set的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图总结一下引用关系：&lt;img data-ratio=&quot;0.3882646691635456&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPDV2MbZtHgetjCIm03QW2iasXjia96wr8RKictVUgIJ5y8WLWQNia09H72w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1602&quot;/&gt;上图中除了Entry的key对ThreadLocal对象是&lt;code&gt;弱引用&lt;/code&gt;，其他的引用都是&lt;code&gt;强引用&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要特别说明的是，上图中ThreadLocal对象我画到了堆上，其实在实际的业务场景中不一定在堆上。因为如果ThreadLocal被定义成了static的，ThreadLocal的对象是类共用的，可能出现在方法区。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 为什么用ThreadLocal做key？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有思考过这样一个问题：&lt;code&gt;ThreadLocalMap&lt;/code&gt;为什么要用&lt;code&gt;ThreadLocal&lt;/code&gt;做key，而不是用&lt;code&gt;Thread&lt;/code&gt;做key？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在你的应用中，一个线程中只使用了一个&lt;code&gt;ThreadLocal&lt;/code&gt;对象，那么使用&lt;code&gt;Thread&lt;/code&gt;做key也未尝不可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;}    &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但实际情况中，你的应用，一个线程中很有可能不只使用了一个ThreadLocal对象。这时使用&lt;code&gt;Thread&lt;/code&gt;做key不就出有问题？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal1 = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal2 = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal3 = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;}    &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如使用&lt;code&gt;Thread&lt;/code&gt;做key时，你的代码中定义了3个ThreadLocal对象，那么，通过Thread对象，它怎么知道要获取哪个ThreadLocal对象呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img data-ratio=&quot;0.5417298937784522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPRNiaWw5iamw6OhpvhSHTtjf8z69UhmVxTOKhAm1ykGAARfXNqjBgicEng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1318&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，不能使用&lt;code&gt;Thread&lt;/code&gt;做key，而应该改成用&lt;code&gt;ThreadLocal&lt;/code&gt;对象做key，这样才能通过具体ThreadLocal对象的&lt;code&gt;get&lt;/code&gt;方法，轻松获取到你想要的ThreadLocal对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPddzQJKggvqA7bjyPYUBbnoBMROAlJ7SxlicJTNFREJHzia6ACV1r8saQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Entry的key为什么设计成弱引用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说过，Entry的key，传入的是ThreadLocal对象，使用了&lt;code&gt;WeakReference&lt;/code&gt;对象，即被设计成了弱引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，为什么要这样设计呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如key对ThreadLocal对象的弱引用，改为强引用。&lt;img data-ratio=&quot;0.39420654911838793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPT8KKEnrticic4sSRcDpOH51tzibCiadrlKGvUxndul4zGe613FRhG6icbkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1588&quot;/&gt;我们都知道ThreadLocal变量对ThreadLocal对象是有强引用存在的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使ThreadLocal变量生命周期完了，设置成null了，但由于key对ThreadLocal还是强引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果执行该代码的&lt;code&gt;线程&lt;/code&gt;使用了&lt;code&gt;线程池&lt;/code&gt;，一直长期存在，不会被销毁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就会存在这样的&lt;code&gt;强引用链&lt;/code&gt;：Thread变量 -&amp;gt; Thread对象 -&amp;gt; ThreadLocalMap -&amp;gt; Entry -&amp;gt; key -&amp;gt; ThreadLocal对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，ThreadLocal对象和ThreadLocalMap都将不会被&lt;code&gt;GC&lt;/code&gt;回收，于是产生了&lt;code&gt;内存泄露&lt;/code&gt;问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，JDK的开发者们把Entry的key设计成了&lt;code&gt;弱引用&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;弱引用&lt;/code&gt;的对象，在GC做垃圾清理的时候，就会被自动回收了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果key是弱引用，当ThreadLocal变量指向null之后，在GC做垃圾清理的时候，key会被自动回收，其值也被设置成null。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img data-ratio=&quot;0.40960809102402024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPuibZibcVKRd0ZNPpa1U6YYSvgfYa31EILjkpyKibq3NDibtuVBv4lZbs3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;&lt;strong&gt;接下来，最关键的地方来了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于当前的ThreadLocal变量已经被指向&lt;code&gt;null&lt;/code&gt;了，但如果直接调用它的&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;方法，很显然会出现&lt;code&gt;空指针异常&lt;/code&gt;。因为它的生命已经结束了，再调用它的方法也没啥意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果系统中还定义了另外一个ThreadLocal变量b，调用了它的&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;，三个方法中的任何一个方法，都会自动触发清理机制，将key为null的value值清空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果key和value都是null，那么Entry对象会被GC回收。如果所有的Entry对象都被回收了，ThreadLocalMap也会被回收了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能最大程度的解决&lt;code&gt;内存泄露&lt;/code&gt;问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要特别注意的地方是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;key为null的条件是，ThreadLocal变量指向&lt;code&gt;null&lt;/code&gt;，并且key是弱引用。如果ThreadLocal变量没有断开对ThreadLocal的强引用，即ThreadLocal变量没有指向null，GC就贸然的把弱引用的key回收了，不就会影响正常用户的使用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果当前ThreadLocal变量指向&lt;code&gt;null&lt;/code&gt;了，并且key也为null了，但如果没有其他ThreadLocal变量触发&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;方法，也会造成内存泄露。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看看弱引用的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    WeakReference&amp;lt;Object&amp;gt; weakReference0 = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; Object());&lt;br/&gt;    System.out.println(weakReference0.get());&lt;br/&gt;    System.gc();&lt;br/&gt;    System.out.println(weakReference0.get());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.Object@&lt;span&gt;1&lt;/span&gt;ef7fe8e&lt;br/&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传入WeakReference构造方法的是直接new处理的对象，没有其他引用，在调用gc方法后，弱引用对象会被自动回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果出现下面这种情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Object object = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;    WeakReference&amp;lt;Object&amp;gt; weakReference1 = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(object);&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;    System.gc();&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.Object@&lt;span&gt;1&lt;/span&gt;ef7fe8e&lt;br/&gt;java.lang.Object@&lt;span&gt;1&lt;/span&gt;ef7fe8e&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先定义了一个强引用object对象，在WeakReference构造方法中将object对象的引用作为参数传入。这时，调用gc后，弱引用对象不会被自动回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的Entry对象中的key不就是第二种情况吗？在Entry构造方法中传入的是ThreadLocal对象的引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将object强引用设置为null：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Object object = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;    WeakReference&amp;lt;Object&amp;gt; weakReference1 = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(object);&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;    System.gc();&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;&lt;br/&gt;    object=&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    System.gc();&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.Object@&lt;span&gt;6f&lt;/span&gt;496d9f&lt;br/&gt;java.lang.Object@&lt;span&gt;6f&lt;/span&gt;496d9f&lt;br/&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二次gc之后，弱引用能够被正常回收。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由此可见，如果强引用和弱引用同时关联一个对象，那么这个对象是不会被GC回收。也就是说这种情况下Entry的key，一直都不会为null，除非强引用主动断开关联。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，你可能还会问这样一个问题：&lt;strong&gt;Entry的value为什么不设计成弱引用？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：Entry的value假如只是被Entry引用，有可能没被业务系统中的其他地方引用。如果将value改成了弱引用，被GC贸然回收了（数据突然没了），可能会导致业务系统出现异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而相比之下，Entry的key，管理的地方就非常明确了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是Entry的key被设计成弱引用，而value没被设计成弱引用的原因。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. ThreadLocal真的会导致内存泄露？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的Entry对象中的key设置成弱引用，并且使用&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;方法清理key为null的value值，就能彻底解决内存泄露问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40960809102402024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPuibZibcVKRd0ZNPpa1U6YYSvgfYa31EILjkpyKibq3NDibtuVBv4lZbs3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;假如ThreadLocalMap中存在很多key为null的Entry，但后面的程序，一直都没有调用过有效的ThreadLocal的&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，Entry的value值一直都没被清空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以会存在这样一条&lt;code&gt;强引用链&lt;/code&gt;：Thread变量 -&amp;gt; Thread对象 -&amp;gt; ThreadLocalMap -&amp;gt; Entry -&amp;gt; value -&amp;gt; Object。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其结果就是：Entry和ThreadLocalMap将会长期存在下去，会导致&lt;code&gt;内存泄露&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 如何解决内存泄露问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说过的ThreadLocal还是会导致内存泄露的问题，我们有没有解决办法呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：有办法，调用ThreadLocal对象的&lt;code&gt;remove&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不是在一开始就调用remove方法，而是在使用完ThreadLocal对象之后。列如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先创建一个CurrentUser类，其中包含了ThreadLocal的逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CurrentUser&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;UserInfo&amp;gt; THREA_LOCAL = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(UserInfo userInfo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        THREA_LOCAL.set(userInfo);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UserInfo &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.get();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.remove();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在业务代码中调用相关方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;     CurrentUser.set(userInfo);&lt;br/&gt;     ...&lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;     UserInfo userInfo = CurrentUser.get();&lt;br/&gt;     ...&lt;br/&gt;   } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;      CurrentUser.remove();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要我们特别注意的地方是：一定要在&lt;code&gt;finally&lt;/code&gt;代码块中，调用&lt;code&gt;remove&lt;/code&gt;方法清理没用的数据。如果业务代码出现异常，也能及时清理没用的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;remove&lt;/code&gt;方法中会把Entry中的key和value都设置成null，这样就能被GC及时回收，无需触发额外的清理机制，所以它能解决内存泄露问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. ThreadLocal是如何定位数据的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说过ThreadLocalMap对象底层是用Entry数组保存数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，ThreadLocal是如何定位Entry数组数据的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ThreadLocal的get、set、remove方法中都有这样一行代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过key的hashCode值，&lt;code&gt;与&lt;/code&gt;数组的长度减1。其中key就是ThreadLocal对象，&lt;code&gt;与&lt;/code&gt;数组的长度减1，相当于除以数组的长度减1，然后&lt;code&gt;取模&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一种hash算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来给大家举个例子：假设len=16，key.threadLocalHashCode=31，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是： int i = 31 &amp;amp; 15 = 15&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相当于：int i = 31 % 16 = 15&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算的结果是一样的，但是使用&lt;code&gt;与运算&lt;/code&gt;效率跟高一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么与运算效率更高？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：因为ThreadLocal的初始大小是&lt;code&gt;16&lt;/code&gt;，每次都是按&lt;code&gt;2&lt;/code&gt;倍扩容，数组的大小其实一直都是2的n次方。这种数据有个规律就是高位是0，低位都是1。在做与运算时，可以不用考虑高位，因为与运算的结果必定是0。只需考虑低位的与运算，所以效率更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用hash算法定位具体位置的话，就可能会出现&lt;code&gt;hash冲突&lt;/code&gt;的情况，即两个不同的hashCode取模后的值相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal是如何解决hash冲突的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看看&lt;code&gt;getEntry&lt;/code&gt;是怎么做的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Entry &lt;span&gt;getEntry&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//通过hash算法获取下标值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (table.length - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    Entry e = table[i];&lt;br/&gt;    &lt;span&gt;//如果下标位置上的key正好是我们所需要寻找的key&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == key)&lt;br/&gt;        &lt;span&gt;//说明找到数据了，直接返回&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; e;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//说明出现hash冲突了，继续往后找&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; getEntryAfterMiss(key, i, e);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再看看&lt;code&gt;getEntryAfterMiss&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Entry &lt;span&gt;getEntryAfterMiss&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, &lt;span&gt;int&lt;/span&gt; i, Entry e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//判断Entry对象如果不为空，则一直循环&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;        &lt;span&gt;//如果当前Entry的key正好是我们所需要寻找的key&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == key)&lt;br/&gt;            &lt;span&gt;//说明这次真的找到数据了&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; e;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;//如果key为空，则清理脏数据&lt;/span&gt;&lt;br/&gt;            expungeStaleEntry(i);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//如果还是没找到数据，则继续往后找&lt;/span&gt;&lt;br/&gt;            i = nextIndex(i, len);&lt;br/&gt;        e = tab[i];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键看看&lt;code&gt;nextIndex&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;nextIndex&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ((i + &lt;span&gt;1&lt;/span&gt; &amp;lt; len) ? i + &lt;span&gt;1&lt;/span&gt; : &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当通过hash算法计算出的下标小于数组大小，则将下标值加1。否则，即下标大于等于数组大小，下标变成0了。下标变成0之后，则循环一次，下标又变成1。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;寻找的大致过程如下图所示：&lt;img data-ratio=&quot;0.4837758112094395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPhoM9mFH5eXkorCiaiagK2mtxd4iaLxyQBRPwqBSu9t7j6WU1icbqXJwcrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;678&quot;/&gt;如果找到最后一个，还是没有找到，则再从头开始找。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4214876033057851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPxsTqeQ2lAVj4Hp8pqodHZtRenJne946HaFFY5xaDciaLibyafFyevIicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;不知道你有没有发现，它构成了一个：&lt;code&gt;环形&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal从数组中找数据的过程大致是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通过key的hashCode取余计算出一个下标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过下标，在数组中定位具体Entry，如果key正好是我们所需要的key，说明找到了，则直接返回数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果第2步没有找到我们想要的数据，则从数组的下标位置，继续往后面找。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果第3步中找key的正好是我们所需要的key，说明找到了，则直接返回数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果还是没有找到数据，再继续往后面找。如果找到最后一个位置，还是没有找到数据，则再从头，即下标为0的位置，继续从前往后找数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直到找到第一个Entry为空为止。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. ThreadLocal是如何扩容的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面得知，ThreadLocal的初始大小是&lt;code&gt;16&lt;/code&gt;。那么问题来了，ThreadLocal是如何扩容的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;set&lt;/code&gt;方法中会调用&lt;code&gt;rehash&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, Object value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Entry e = tab[i];&lt;br/&gt;         e != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;         e = tab[i = nextIndex(i, len)]) {&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == key) {&lt;br/&gt;            e.value = value;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            replaceStaleEntry(key, value, i);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    tab[i] = &lt;span&gt;new&lt;/span&gt; Entry(key, value);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; sz = ++size;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)&lt;br/&gt;        rehash();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意一下，其中有个判断条件是：sz(之前的size+1)如果大于或等于threshold的话，则调用rehash方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;threshold默认是0，在创建ThreadLocalMap时，调用它的构造方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ThreadLocalMap(ThreadLocal&amp;lt;?&amp;gt; firstKey, Object firstValue) {&lt;br/&gt;    table = &lt;span&gt;new&lt;/span&gt; Entry[INITIAL_CAPACITY];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = firstKey.threadLocalHashCode &amp;amp; (INITIAL_CAPACITY - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    table[i] = &lt;span&gt;new&lt;/span&gt; Entry(firstKey, firstValue);&lt;br/&gt;    size = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    setThreshold(INITIAL_CAPACITY);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用setThreshold方法给threshold设置一个值，而这个值INITIAL_CAPACITY是默认的大小16。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setThreshold&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    threshold = len * &lt;span&gt;2&lt;/span&gt; / &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是第一次设置的threshold = 16 * 2 / 3， 取整后的值是：10。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说当sz大于等于10时，就可以考虑扩容了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rehash代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//先尝试回收一次key为null的值，腾出一些空间&lt;/span&gt;&lt;br/&gt;    expungeStaleEntries();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (size &amp;gt;= threshold - threshold / &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;        resize();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真正扩容之前，先尝试回收一次key为null的值，腾出一些空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果回收之后的size大于等于threshold的3/4时，才需要真正的扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算公式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;16&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt; * &lt;span&gt;4&lt;/span&gt; / &lt;span&gt;3&lt;/span&gt; * &lt;span&gt;4&lt;/span&gt; - &lt;span&gt;16&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt; / &lt;span&gt;3&lt;/span&gt; * &lt;span&gt;4&lt;/span&gt; = &lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说添加数据后，新的size大于等于老size的&lt;code&gt;1/2&lt;/code&gt;时，才需要扩容。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;resize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] oldTab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; oldLen = oldTab.length;&lt;br/&gt;    &lt;span&gt;//按2倍的大小扩容&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; newLen = oldLen * &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    Entry[] newTab = &lt;span&gt;new&lt;/span&gt; Entry[newLen];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; oldLen; ++j) {&lt;br/&gt;        Entry e = oldTab[j];&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                e.value = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// Help the GC&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (newLen - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (newTab[h] != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    h = nextIndex(h, newLen);&lt;br/&gt;                newTab[h] = e;&lt;br/&gt;                count++;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    setThreshold(newLen);&lt;br/&gt;    size = count;&lt;br/&gt;    table = newTab;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;resize中每次都是按2倍的大小扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩容的过程如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9527272727272726&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgP6HufRYWSy9DqCibKtibW5pPkaVhVGibyvbt6tUssr9ZCdKAWzChxC83mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;扩容的关键步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;老size + 1 = 新size&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果新size大于等于老size的2/3时，需要考虑扩容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩容前先尝试回收一次key为null的值，腾出一些空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果回收之后发现size还是大于等于老size的1/2时，才需要真正的扩容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每次都是按2倍的大小扩容。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 父子线程如何共享数据？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍的ThreadLocal都是在&lt;code&gt;一个线程&lt;/code&gt;中保存和获取数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在实际工作中，有可能是在父子线程中共享数据的。即在父线程中往ThreadLocal设置了值，在子线程中能够获取到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;        threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;子线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;子线程获取数据：&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会发现，在这种情况下使用ThreadLocal是行不通的。main方法是在主线程中执行的，相当于父线程。在main方法中开启了另外一个线程，相当于子线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然通过ThreadLocal，无法在父子线程中共享数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;InheritableThreadLocal&lt;/code&gt;，它是JDK自带的类，继承了ThreadLocal类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改代码之后：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        InheritableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;        threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;子线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;子线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;果然，在换成InheritableThreadLocal之后，在子线程中能够正常获取父线程中设置的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在Thread类中除了成员变量threadLocals之外，还有另一个成员变量：inheritableThreadLocals。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Thread类的部分代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;ThreadLocal.ThreadLocalMap inheritableThreadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最关键的一点是，在它的&lt;code&gt;init&lt;/code&gt;方法中会将父线程中往ThreadLocal设置的值，拷贝一份到子线程中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感兴趣的小伙伴，可以找我私聊。或者看看我后面的文章，后面还会有专栏。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. 线程池中如何共享数据？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真实的业务场景中，一般很少用&lt;code&gt;单独的线程&lt;/code&gt;，绝大多数，都是用的&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，在线程池中如何共享ThreadLocal对象生成的数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为涉及到不同的线程，如果直接使用ThreadLocal，显然是不合适的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们应该使用InheritableThreadLocal，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    InheritableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;    ExecutorService executorService = Executors.newSingleThreadExecutor();&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第一次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第二次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第一次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第二次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这个例子中使用了单例线程池，固定线程数是1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次submit任务的时候，该线程池会自动创建一个线程。因为使用了InheritableThreadLocal，所以创建线程时，会调用它的init方法，将父线程中的inheritableThreadLocals数据复制到子线程中。所以我们看到，在主线程中将数据设置成6，第一次从线程池中获取了正确的数据6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，在主线程中又将数据改成7，但在第二次从线程池中获取数据却依然是6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为第二次submit任务的时候，线程池中已经有一个线程了，就直接拿过来复用，不会再重新创建线程了。所以不会再调用线程的init方法，所以第二次其实没有获取到最新的数据7，还是获取的老数据6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;，它并非JDK自带的类，而是阿里巴巴开源jar包中的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下pom文件引入该jar包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;transmittable-thread-local&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.11.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;compile&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码调整如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    TransmittableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; TransmittableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;    ExecutorService ttlExecutorService = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    ttlExecutorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第一次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;    ttlExecutorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第二次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第一次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第二次从线程池中获取数据：&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到，使用了TransmittableThreadLocal之后，第二次从线程中也能正确获取最新的数据7了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nice。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你仔细观察这个例子，你可能会发现，代码中除了使用&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;类之外，还使用了&lt;code&gt;TtlExecutors.getTtlExecutorService&lt;/code&gt;方法，去创建&lt;code&gt;ExecutorService&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是非常重要的地方，如果没有这一步，&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;在线程池中共享数据将不会起作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;code&gt;ExecutorService&lt;/code&gt;对象，底层的submit方法会&lt;code&gt;TtlRunnable&lt;/code&gt;或&lt;code&gt;TtlCallable&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以TtlRunnable类为例，它实现了&lt;code&gt;Runnable&lt;/code&gt;接口，同时还实现了它的run方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Map&amp;lt;TransmittableThreadLocal&amp;lt;?&amp;gt;, Object&amp;gt; copied = (Map)&lt;span&gt;this&lt;/span&gt;.copiedRef.get();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (copied != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (!&lt;span&gt;this&lt;/span&gt;.releaseTtlValueReferenceAfterRun || &lt;span&gt;this&lt;/span&gt;.copiedRef.compareAndSet(copied, (Object)&lt;span&gt;null&lt;/span&gt;))) {&lt;br/&gt;        Map backup = TransmittableThreadLocal.backupAndSetToCopied(copied);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.runnable.run();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            TransmittableThreadLocal.restoreBackup(backup);&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;TTL value reference is released after run!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的主要逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;把当时的ThreadLocal做个备份，然后将父类的ThreadLocal拷贝过来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行真正的run方法，可以获取到父类最新的ThreadLocal数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从备份的数据中，恢复当时的ThreadLocal数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11. ThreadLocal有哪些用途？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，一起聊聊ThreadLocal有哪些用途？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老实说，使用ThreadLocal的场景挺多的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面列举几个常见的场景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在spring事务中，保证一个线程下，一个事务的多个操作拿到的是一个Connection。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在hiberate中管理session。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在JDK8之前，为了解决SimpleDateFormat的线程安全问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取当前登录用户上下文。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;临时保存权限数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用MDC保存日志信息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等等，还有很多业务场景，这里就不一一列举了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于篇幅有限，今天的内容先分享到这里。希望你看了这篇文章，会有所收获。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来留几个问题给大家思考一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ThreadLocal变量为什么建议要定义成static的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Entry数组为什么要通过hash算法计算下标，即直线寻址法，而不直接使用下标值？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强引用和弱引用有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Entry数组大小，为什么是2的N次方？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用InheritableThreadLocal时，如果父线程中重新set值，在子线程中能够正确的获取修改后的新值吗？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;敬请期待我的下一篇文章，谢谢。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>49a8b1669d5bb6157b52003b5c75505e</guid>
<title>跟着这 12 张图，重新复习 Redis</title>
<link>https://toutiao.io/k/25u7bi6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7620370370370371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapfQQZJOKziaehj1pZzNHTicFkDKBMhTBzjZjys2GHM2nWd3LWt5SA7y0A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;八股文网站：&lt;/span&gt;&lt;span&gt;xiaolincoding.com&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小林。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网上看到一篇很不错的 Redis  文章，内容很精炼，而且图画的非常棒，所以分享给大家一起拜读拜读，主要说了「Redis 介绍、Redis 架构、Redis 持久化」这三个方面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这篇文章也不是把所有 Redis 功能都介绍了，如果你想了解更多 Redis 其他知识，可以看我之前写的这篇：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247516196&amp;amp;idx=1&amp;amp;sn=bf62f4349a10d2516b9b1e1ba9a4bde7&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3 万字 + 40 张图 | 攻破 Redis 常见面试题&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，话不多说了，发车！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3043478260869565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf4wic9AG3NR0ereDEnem0Ky2M27wYE8K45ribaxAOoAwxFykhwRYUG3ial4BR0OmXV4rjU2qDibGq48Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;736&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是 Redis？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis（REmote DIctionary Service）是一个开源的键值对数据库服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 更准确的描述是一个数据结构服务器。Redis 的这种特殊性质让它在开发人员中很受欢迎。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7074074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6tibgyywkfL76yJF7r0hLAb3GvmKFmphibicEwzASMibbsU1Fb3xZgFlDDg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis不是通过迭代或者排序方式处理数据，而是一开始就按照数据结构方式组织。早期，它的使用很像 Memcached，但随着 Redis 的改进，它在许多其他用例中变得可行，包括发布-订阅机制、流（streaming）和队列。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.326851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6ichZ8Wb4qk3ojlLu48SUicHoBA34oQDKU8IoqJBFVMLd2dUaIGuMcSOw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要来说，Redis 是一个内存数据库，用作另一个“真实”数据库（如 MySQL 或 PostgreSQL）前面的缓存，以帮助提高应用程序性能。它通过利用内存的高速访问速度，从而减轻核心应用程序数据库的负载，例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不经常更改且经常被请求的数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任务关键性较低且经常变动的数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述数据的示例可以包括会话或数据缓存以及仪表板的排行榜或汇总分析。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5518518518518518&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6HSKdEfwI0niaazf1SpMNYAA320WXEKKMokQSibicZ7jm2d3aT5gqTASSQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，对于许多用例场景，Redis 都可以提供足够的保证，可以将其用作成熟的主数据库。再加上 Redis 插件及其各种高可用性（HA）设置，Redis 作为数据库对于某些场景和工作负载变得非常有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个重要方面是 Redis 模糊了缓存和数据存储之间的界限。这里要理解的重要一点是，相比于使用 SSD 或 HDD 作为存储的传统数据库，读取和操作内存中数据的速度要快得多。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4462962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6NDX3tjrUj97ju6ouO6JmoqYt8bVxDlyIibDfBrUFXT4e0riaJMTDtRdA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最初，Redis 最常被比作 Memcached，后者当时缺乏任何非易失性持久化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是当前两个缓存之间的功能细分。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Memcached&lt;/th&gt;&lt;th&gt;Redis&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;亚毫秒延迟&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;开发者易用性&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据分区&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;支持广泛的编程语言&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;高级数据结构&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;多线程架构&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;快照&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;复制（Replication）&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;事务&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;发布/订阅&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Lua脚本&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;地理空间支持&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然现在拥有多种配置方式将数据持久化到磁盘，但当时首次引入持久化时，Redis 是使用快照方式，通过异步拷贝内存中的数据方式来做持久化。不幸的是，这种机制的缺点是可能会在快照之间丢失数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 自 2009 年成立到现在已经变的很成熟。我们将介绍它的大部分架构和拓扑，以便你可以将 Redis 添加到你的数据存储系统库中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 架构&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始讨论 Redis 内部结构之前，让我们先讨论一下各种 Redis 部署及其权衡取舍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将主要关注以下这些设置：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;单个 Redis 实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 高可用性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 哨兵&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 集群&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据你的用例和规模，决定使用哪一种设置。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单个 Redis 实例&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5581127733026467&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6FWRDgwxWLQ2WyJDOjpZ48wjXYcQyJquXgicatticY2l3GnuWg0tbe2bQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;869&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单个 Redis 实例是最直接的 Redis 部署方式。它允许用户设置和运行小型实例，从而帮助他们快速发展和加速服务。但是，这种部署并非没有缺点。例如，如果此实例失败或不可用，则所有客户端对 Redis 的调用都将失败，从而降低系统的整体性能和速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有足够的内存和服务器资源，这个实例可以很强大。主要用于缓存的场景可能会以最少的设置获得显著的性能提升。给定足够的系统资源，你可以在应用程序运行的同一机器上部署此 Redis 服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在管理系统内的数据方面，了解一些 Redis 概念是必不可少的。发送到 Redis 的命令首先在内存中处理。然后，如果在这些实例上设置了持久性，则在某个时间间隔上会有一个fork进程，来生成数据持久化 RDB（Redis 数据的非常紧凑的时间点表示）快照或 AOF（仅附加文件）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个流程可以让 Redis 拥有长期存储，支持各种复制策略，并启用更复杂的拓扑。如果 Redis 未设置为持久化数据，则在重新启动或故障转移时数据会丢失。如果在重启时启用了持久化，它会将 RDB 快照或 AOF 中的所有数据加载回内存，然后实例可以支持新的客户端请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话虽如此，让我们看看你可能会用到的更多分布式 Redis 设置。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 高可用性&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5509259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6e8nH2hqyVlFXmia4DOnKRibFwicEC6wC8bVKsfWq7nLVY759iayYjXIXMg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;864&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 的另一个流行设置是主从部署方式，从部署保持与主部署之间数据同步。当数据写入主实例时，它会将这些命令的副本发送到从部署客户端输出缓冲区，从而达到数据同步的效果。从部署可以有一个或多个实例。这些实例可以帮助扩展 Redis 的读取操作或提供故障转移，以防 main 丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在已经进入了一个分布式系统，因此需要在此拓扑中考虑许多新事物。以前简单的事情现在变得复杂了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 复制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 的每个主实例都有一个复制 ID 和一个偏移量。这两条数据对于确定副本可以继续其复制过程的时间点或确定它是否需要进行完整同步至关重要。对于主 Redis 部署上发生的每个操作，此偏移量都会增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更明确地说，当 Redis 副本实例仅落后于主实例几个偏移量时，它会从主实例接收剩余的命令，然后在其数据集上重放，直到同步完成。如果两个实例无法就复制 ID 达成一致，或者主实例不知道偏移量，则副本将请求全量同步。这时主实例会创建一个新的 RDB 快照并将其发送到副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此传输之间，主实例会缓冲快照截止和当前偏移之间的所有中间更新指令，这样在快照同步完后，再将这些指令发送到副本实例。这样完成后，复制就可以正常继续。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个实例具有相同的复制 ID 和偏移量，则它们具有完全相同的数据。现在你可能想知道为什么需要复制 ID。当 Redis 实例被提升为主实例或作为主实例从头开始重新启动时，它会被赋予一个新的复制 ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这用于推断此新提升的副本实例是从先前哪个主实例复制出来的。这允许它能够执行部分同步（与其他副本节点），因为新的主实例会记住其旧的复制 ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，两个实例（主实例和从实例）具有相同的复制 ID，但偏移量相差几百个命令，这意味着如果在实例上重放这些偏移量后面的命令，它们将具有相同的数据集。现在，如果复制 ID 完全不同，并且我们不知道新降级（或重新加入）从节点的先前复制 ID（没有共同祖先）。我们将需要执行昂贵的全量同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相反，如果我们知道以前的复制 ID，我们就可以推断如何使数据同步，因为我们能够推断出它们共享的共同祖先，并且偏移量对于部分同步再次有意义。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 哨兵&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1123809523809525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6VnBEz4GFovzpicVBF7IymGyI6hwdE8v3xvKvNbl1D2sHib18ju9f6oZQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1050&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel 是一个分布式系统。与所有分布式系统一样，Sentinel 有几个优点和缺点。Sentinel 的设计方式是，一组哨兵进程协同工作以协调状态，从而为 Redis 提供高可用性。毕竟，你不希望保护你免受故障影响的系统有自己的单点故障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel 负责一些事情。首先，它确保当前的主实例和从实例正常运行并做出响应。这是必要的，因为哨兵（与其他哨兵进程）可以在主节点和/或从节点丢失的情况下发出警报并采取行动。其次，它在服务发现中发挥作用，就像其他系统中的 Zookeeper 和 Consul 一样。所以当一个新的客户端尝试向 Redis 写东西时，Sentinel 会告诉客户端当前的主实例是什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，哨兵不断监控可用性并将该信息发送给客户端，以便他们能够在他们确实进行故障转移时对其做出反应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是它的职责：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;监控——确保主从实例按预期工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通知——通知系统管理员 Redis 实例中的事件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;故障转移管理——如果主实例不可用并且足够多的（法定数量）节点同意这是真的，Sentinel 节点可以启动故障转移。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置管理——Sentinel 节点还充当当前主 Redis 实例的发现服务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以这种方式使用 Redis Sentinel 可以进行故障检测。此检测涉及多个哨兵进程同意当前主实例不再可用。这个协议过程称为 Quorum。这可以提高鲁棒性并防止一台机器行为异常导致无法访问主 Redis 节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此设置并非没有缺点，因此我们将在使用 Redis Sentinel 时介绍一些建议和最佳实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以通过多种方式部署 Redis Sentinel。老实说，要提出任何明智的建议，我需要有关你的系统的更多背景信息。作为一般指导，我建议在每个应用程序服务器旁边运行一个哨兵节点（如果可能的话），这样你也不需要考虑哨兵节点和实际使用 Redis 的客户端之间的网络可达性差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以将 Sentinel 与 Redis 实例一起运行，甚至可以在独立节点上运行，只不过它会按照别的方式处理，从而会让事情变得更复杂。我建议至少运行三个节点，并且至少具有两个法定人数（quorum）。这是一个简单的图表，分解了集群中的服务器数量以及相关的法定人数和可容忍的可持续故障。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Number of Servers&lt;/th&gt;&lt;th&gt;Quorum&lt;/th&gt;&lt;th&gt;Number Of Tolerated Failures&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这会因系统而异，但总体思路是不变的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们花点时间思考一下这样的设置会出现什么问题。如果你运行这个系统足够长的时间，你会遇到所有这些。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果哨兵节点超出法定人数怎么办？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果网络分裂将旧的主实例置于少数群体中怎么办？这些写入会发生什么？（剧透：当系统完全恢复时它们会丢失）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果哨兵节点和客户端节点（应用程序节点）的网络拓扑错位会发生什么？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有持久性保证，特别是持久化到磁盘的操作（见下文）是异步的。还有一个麻烦的问题，当客户发现新的 primary 时，我们失去了多少写给一个不知道的 primary？Redis 建议在建立新连接时查询新的主节点。根据系统配置，这可能意味着大量数据丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你强制主实例将写入复制到至少一个副本实例，有几种方法可以减轻损失程度。请记住，所有 Redis 复制都是异步的，这是有其权衡的考虑。因此，它需要独立跟踪确认，如果至少有一个副本实例没有确认它们，主实例将停止接受写入。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 集群&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6064814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6AXgmiawOvoop0N7GLq5SEKFIdTcbIcyE68xseAFGvSm2hucK3uhLfzg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信很多人都想过当你无法将所有数据存储在一台机器上的内存中时会发生什么。目前，单个服务器中可用的最大 RAM 为 24TIB，这是目前 AWS 线上列出来的。当然，这很多，但对于某些系统来说，这还不够，即使对于缓存层也是如此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster 允许 Redis 的水平扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，让我们摆脱一些术语约束；一旦我们决定使用 Redis 集群，我们就决定将我们存储的数据分散到多台机器上，这称为分片。所以集群中的每个 Redis 实例都被认为是整个数据的一个分片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这带来了一个新的问题。如果我们向集群推送一个key，我们如何知道哪个 Redis 实例（分片）保存了该数据？有几种方法可以做到这一点，但 Redis Cluster 使用算法分片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了找到给定 key 的分片，我们对 key 进行哈希处理，并通过对总分片数量取模。然后，使用确定性哈希函数，这意味着给定的 key 将始终映射到同一个分片，我们可以推断将来读取特定 key 的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们之后想在系统中添加一个新的分片时会发生什么？这个过程称为重新分片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设键 &#x27;foo&#x27; 之前映射到分片 0， 在引入新分片后它可能会映射到分片 5。但是，如果我们需要快速扩展系统，移动数据来达到新的分片映射，这将是缓慢且不切实际的。它还对 Redis 集群的可用性产生不利影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster 为这个问题设计了一种解决方案，称为 Hashslot，所有数据都映射到它。有 16K 哈希槽。这为我们提供了一种在集群中传播数据的合理方式，当我们添加新的分片时，我们只需在系统之间移动哈希槽。通过这样做，我们只需要将 hashlot 从一个分片移动到另一个分片，并简化将新的主实例添加到集群中的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可以在没有任何停机时间和最小的性能影响的情况下实现。让我们通过一个例子来谈谈。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;M1 包含从 0 到 8191 的哈希槽。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;M2 包含从 8192 到 16383 的哈希槽。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，为了映射 “foo”，我们采用一个确定性的键（foo）散列，并通过散列槽的数量（16K）对其进行修改，从而得到 M2 的映射。现在假设我们添加了一个新实例 M3。新的映射将是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;M1 包含从 0 到 5460 的哈希槽。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;M2 包含从 5461 到 10922 的哈希槽。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;M3 包含从 10923 到 16383 的哈希槽。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在映射到 M2 的 M1 中映射哈希槽的所有键都需要移动。但是散列槽的各个键的散列不需要移动，因为它们已经被划分到散列槽中。因此，这一级别的误导（misdirection）解决了算法分片的重新分片问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Gossiping 协议&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster 使用 gossiping 来确定整个集群的健康状况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6064814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6AXgmiawOvoop0N7GLq5SEKFIdTcbIcyE68xseAFGvSm2hucK3uhLfzg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，我们有 3 个 M 个节点和 3 个 S 节点。所有这些节点不断地进行通信以了解哪些分片可用并准备好为请求提供服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果足够多的分片同意 M1 没有响应，他们可以决定将 M1 的副本 S1 提升为主节点以保持集群健康。触发此操作所需的节点数量是可配置的，并且必须正确执行此操作。如果操作不当并且在分区的两边相等时无法打破平局，则可能会导致集群被拆分。这种现象称为裂脑。作为一般规则，必须拥有奇数个主节点和两个副本，以实现最稳健的设置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 持久化模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们要使用 Redis 存储任何类型的数据同时要求安全保存，了解 Redis 是如何做到这一点很重要。在许多用例中，如果你丢失了 Redis 存储的数据，这并不是世界末日。将其用作缓存或在其支持实时分析的情况下，如果发生数据丢失，则并非世界末日。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在其他场景中，我们希望围绕数据持久性和恢复有一些保证。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2074074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6UaUtnz2cI6dZThd6Z7tmr4qBz6EZSEe8eIq1zd7DxtxibuC7wt41lPA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;无持久化&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无持久化：如果你愿意，可以完全禁用持久化。这是运行 Redis 的最快方式，并且没有持久性保证。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RDB文件&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDB（Redis 数据库）：RDB 持久化以指定的时间间隔执行数据集的时间点快照。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种机制的主要缺点是快照之间的数据会丢失。此外，这种存储机制还依赖于主进程的 fork，在更大的数据集中，这可能会导致服务请求的瞬间延迟。话虽如此，RDB 文件在内存中的加载速度要比 AOF 快得多。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AOF&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOF（Append Only File）：AOF 持久化记录服务器接收到的每个写入操作，这些操作将在服务器启动时再次被执行，重建原始数据集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种持久性的方法能够确保比 RDB 快照更持久，因为它是一个仅附加文件。随着操作的发生，我们将它们缓冲到日志中，但它们还没有被持久化。该日志与我们运行的实际命令一致，以便在需要时进行重放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，如果可能，我们使用 fsync 将其刷新到磁盘（当此运行可配置时），它将被持久化。缺点是格式不紧凑，并且比 RDB 文件使用更多的磁盘。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么不兼得？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDB + AOF：可以将 AOF 和 RDB 组合在同一个 Redis 实例中。如果你愿意的话，可以以速度换取持久化是一种折衷方法。我认为这是设置 Redis 的一种可接受的方式。在重启的情况下，请记住如果两者都启用，Redis 将使用 AOF 来重建数据，因为它是最完整的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Forking&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们了解了持久化的类型，让我们讨论一下我们如何在像 Redis 这样的单线程应用程序中实际执行它。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7481481481481481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6aah7Vj54CbruBa4mFFryHicTiaTaZjtf9atiaARIbv9zAZhibia42zsjwcw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我看来，Redis 最酷的部分是它如何利用 forking 和写时复制来高效地促进数据持久化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Forking 是操作系统通过创建自身副本来创建新进程的一种方式。这样，你将获得一个新的进程 ID 和一些其他信息和句柄，因此新 forking 的进程（子进程）可以与原始进程父进程通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在事情变得有趣了。Redis 是一个分配了大量内存的进程，那么它如何在不耗尽内存的情况下进行复制呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你 fork 一个进程时，父进程和子进程共享内存，并且在该子进程中 Redis 开始快照（Redis）进程。这是通过一种称为写时复制的内存共享技术实现的——该技术在创建分叉时传递对内存的引用。如果在子进程持久化到磁盘时没有发生任何更改，则不会进行新的分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发生更改的情况下，内核会跟踪对每个页面的引用，如果某个页面有多个更改，则将更改写入新页面。子进程完全不知道更改以及具有一致的内存快照的事情。因此，在只使用了一小部分内存的情况下，我们能够非常快速有效地获得潜在千兆字节内存的时间点快照！&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>781996f545ebe661d55f3f7948b54284</guid>
<title>如何快速打造一个高性能数据库原型</title>
<link>https://toutiao.io/k/tkvf7rp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;col-md-10 col-sm-12&quot;&gt;
            &lt;h1&gt; 如何快速打造一个高性能数据库原型&lt;/h1&gt;
            &lt;hr/&gt;
            &lt;p&gt;作者: 康凯森&lt;/p&gt;
            &lt;p&gt;日期: 2022-11-06&lt;/p&gt;
            &lt;p&gt;分类: &lt;a href=&quot;../tag/OLAP.html&quot; target=&quot;_blank&quot;&gt;OLAP&lt;/a&gt;&lt;/p&gt;
            &lt;hr/&gt;
            


&lt;h1 id=&quot;如何快速打造一个高性能数据库原型&quot;&gt;如何快速打造一个高性能数据库原型&lt;/h1&gt;
&lt;p&gt;在上篇博客 &lt;a href=&quot;https://blog.bcmeng.com/post/dpa.html&quot;&gt;Data-Parallel Actors：千行代码构建高性能 OLAP 数据库 &lt;/a&gt; 中，我提出开源数据库会越来越模块化，打造一个高性能的数据库原型会越来越简单，下图是一个利用 DPA 和 一些开源系统打造的数据库架构示意，可能只需要 1 个或者几个人月，就可以打造出这个原型，并且在 SSB，TPC-H,TPC-DS 等标准测试集上取得不错的性能。下面会对图中的一些系统进行介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/Scratch%20Performance%20Database%20With%20Open%20Source.png&quot; alt=&quot;Scratch Performance Database With Open Source&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;查询优化-apache-calcite&quot;&gt;查询优化 Apache Calcite&lt;/h2&gt;
&lt;p&gt;Apache Calcite 网上相关的资料已经很多了，这里就不过多介绍了。 Calcite 相比 StarRocks 的优化器扩展性会更好，但是性能不及 StarRocks 的优化器。&lt;/p&gt;
&lt;h3 id=&quot;架构&quot;&gt;架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/calcite%20architecture%20and%20interaction.png&quot; alt=&quot;calcite architecture and interaction&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Calcite 的核心是优化器，同时支持 RBO 和 CBO，包括 Catalog, SQL parser, SQL validator, Query Optimizer，JDBC Server 和 内置的执行器&lt;/p&gt;
&lt;h3 id=&quot;可扩展性&quot;&gt;可扩展性&lt;/h3&gt;
&lt;p&gt;Calcite 的目标是成为一个通用的查询优化器，可以被各种系统使用，所以在扩展性上做的比较好，开发者在使用 Calcite 时对以下部分都可以进行扩展：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;relational operators&lt;/li&gt;
&lt;li&gt;planner rules&lt;/li&gt;
&lt;li&gt;cost model&lt;/li&gt;
&lt;li&gt;statistics&lt;/li&gt;
&lt;li&gt;元数据：支持 行数，基数，选择度，唯一性等很多元数据都可以定义&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;built-in-sql-implementation&quot;&gt;Built-in SQL implementation&lt;/h3&gt;
&lt;p&gt;Calcite 也内置了一套 执行器，可以执行所有的算子和表达式。Calcite 会生成 java 代码，然后编译，并在 JVM 中执行。Calcite 就利用了 Janino 库来将优化后的方案编译成 JVM Bytecode 来执行，虽然性能比较低下，但是可以作为默认的保底和 fall-back 的方式。&lt;/p&gt;
&lt;h3 id=&quot;流行度&quot;&gt;流行度&lt;/h3&gt;
&lt;p&gt;Calcite 在工业界已经被大量采用，许多项目都使用 Apache Calcite 实现 SQL parsing， 查询优化，数据联邦，物化视图重写，知名的项目有 Apache Hive, Apache Drill, Apache Flink, Apache Kylin, Apache Druid, Dremio 等。&lt;/p&gt;
&lt;h2 id=&quot;查询执行-velox&quot;&gt;查询执行 Velox&lt;/h2&gt;
&lt;p&gt;Velox 是由 Mate 开源的执行引擎，目标是想打造一个统一的高性能 C++ 执行引擎，整体实现和 StarRocks 的执行引擎很类型，亮点不多。 可以参考 Velox 的论文，也可以参考之前我对 StarRocks 执行引擎的介绍：&lt;/p&gt;

&lt;p&gt;Velox 的执行引擎，和 StarRocks 主要包括下面几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type&lt;/li&gt;
&lt;li&gt;兼容 Arrow 的列式布局&lt;/li&gt;
&lt;li&gt;向量化的表达式计算&lt;/li&gt;
&lt;li&gt;标量和聚合函数&lt;/li&gt;
&lt;li&gt;向量化算子&lt;/li&gt;
&lt;li&gt;序列化&lt;/li&gt;
&lt;li&gt;资源管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;流行度&quot;&gt;流行度&lt;/h3&gt;
&lt;p&gt;Velox 开源不久，还没有完全成熟，目前主要和是 Presto 和 Spark 项目合作，一起在搞。&lt;/p&gt;
&lt;h2 id=&quot;内存存储-apache-arrow&quot;&gt;内存存储 Apache Arrow&lt;/h2&gt;
&lt;p&gt;Apache Arrow 项目的目标是成为一个跨平台，跨语言的列式内存格式和磁盘格式 （Apache Parquet），并以此基础，实现了基于内存的查询引擎，最终成为一个内存数据处理的标准。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/arrow.jpg&quot; alt=&quot;Arrow format&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是 Arrow 的列式内存布局。&lt;/p&gt;
&lt;h3 id=&quot;网络传输-apache-arrow-flight&quot;&gt;网络传输 Apache Arrow Flight&lt;/h3&gt;
&lt;p&gt;基于 grpc 和 arrow 列式格式的网络传输框架, 下面两个图是个简单示意，具体可以参考：&lt;a href=&quot;https://www.dremio.com/subsurface/an-introduction-to-apache-arrow-flight-sql/&quot;&gt;https://www.dremio.com/subsurface/an-introduction-to-apache-arrow-flight-sql/&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/apache%20arrow%20flight%201.png&quot; alt=&quot;apache arrow flight 1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/apache%20arrow%20flight%202.png&quot; alt=&quot;apache arrow flight 2&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;datafusion&quot;&gt;DataFusion&lt;/h3&gt;
&lt;p&gt;基于 apache arrow 实现的 可扩展的查询引擎，包括查询优化和查询执行框架。&lt;/p&gt;
&lt;p&gt;下图是 Arrow 和 DataFusion 逐步向 DataBase 演化的路径：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/arrow%20-%20datafusion.png&quot; alt=&quot;arrow - datafusion&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图是 DataFusion 的框架，核心是可扩展：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/16677265297142.png&quot; alt=&quot;arrow - datafusion 2&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;流行度&quot;&gt;流行度&lt;/h3&gt;
&lt;p&gt;Apache Arrow 已经被很多业界项目广泛采用，比如 Velox，Spark, StarRocks, Snowflake 等系统都使用了 Apache Arrow。&lt;/p&gt;
&lt;h2 id=&quot;分布式框架-dpa&quot;&gt;分布式框架 DPA&lt;/h2&gt;
&lt;p&gt;对分布式查询的相关功能进行了统一和抽象：数据复制，更新一致性，容错，查询负载均衡，弹性，持久化等。 可以参考之前的文章：&lt;a href=&quot;https://blog.bcmeng.com/post/dpa.html&quot;&gt;Data-Parallel Actors：千行代码构建高性能 OLAP 数据库 &lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;rocksdb&quot;&gt;RocksDB&lt;/h2&gt;
&lt;p&gt;一个基于 LSM tree 的 KV store，被大量用来打造分布式 KV 存储或者存储元数据。&lt;/p&gt;
&lt;h2 id=&quot;序列化&quot;&gt;序列化&lt;/h2&gt;
&lt;p&gt;常量有 json，Protobuf 等协议，业内已经有大量的成熟框架。&lt;/p&gt;
&lt;h2 id=&quot;打造一个成熟的数据库的难点有哪些&quot;&gt;打造一个成熟的数据库的难点有哪些&lt;/h2&gt;
&lt;p&gt;有人会问，打造一个数据库原型如此简单的话，那么数据库公司花费数十人年，数百人年，甚至数千人年都是在做什么。 下面文章我会回答这个问题，为什么打造一个成熟数据库如此困难，为什么数据库是一个如此复杂的工程。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;


            &lt;hr/&gt;
            &lt;h3&gt;欢迎来知识星球和我交流&lt;/h3&gt;
            
        &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>111a476ee0b407325f0c622d02128bb4</guid>
<title>万字详解数仓分层设计架构 ODS-DWD-DWS-ADS</title>
<link>https://toutiao.io/k/rwbg5v2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、数仓分层架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;311&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5377833753148614&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCb9Hs6mDib9feegnmRq07gEdHmEMQA1Mtzia9DbFNUbq1Jics33Xv0qEBXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据仓库标准上可以分为四层。但是注意这种划分和命名不是唯一的，一般数仓都是四层，但是不同公司可能叫法不同。但是核心的理念都是从四层数据模型而来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;338&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5849056603773585&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCbtkQjFnLOQcCvT3tCQSNtM9NICE5w5InMUxkmWicsQuRkcj0OwOjibfzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;689&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;672&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1628264208909371&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCbTpVdmsCiagVITC2ialBIeJIIvI2hTUYudyZbNicZ6G4Ztziaz0lgtnZn1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;360&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6222222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCbmjXVmIRyx3wnaJPGst4BVliar8k34ibiczr7pOk7OyIpSicpfcWIl6GYlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、贴源层（ODS, Operational Data Store）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;418&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7231543624161074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCb51EVicaDqtYWeZk5JELQQHTyp1T1uc6OpnU6kqQ9dFL45erf1OM1VEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据引入层（ODS，Operational Data Store，又称数据基础层）：将原始数据几乎无处理地存放在数据仓库系统中，结构上与源系统基本保持一致，是数据仓库的数据准备区。这一层的主要职责是将基础数据同步、存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般来说 ODS 层的数据和源系统的数据是同构的，主要目的是简化后续数据加工处理的工作。从数据粒度上来说 ODS 层的数据粒度是细的。ODS 层的表通常包括两类，一个用于存储当前需要加载的数据，一个用于存储处理完后的历史数据。历史数据一般保存 3-6 个月后需要清除，以节省空间。但不同的项目要区别对待，如果源系统的数据量不大，可以保留更长的时间，甚至全量保存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：在这层，理应不是简单的数据接入，而是要考虑一定的数据清洗，比如异常字段的处理、字段命名规范化、时间字段的统一等，一般这些很容易会被忽略，但是却至关重要。特别是后期我们做各种特征自动生成的时候，会十分有用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：有的公司ODS层不会做太多数据过滤处理,会放到DWD层来处理。&lt;/span&gt;&lt;span&gt;有的公司会在一开始时就在ODS层做数据相对精细化的过滤.这个并没有明确规定,看每个公司自己的想法和技术规范。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般企业开发时,都会对原始数据存入到ODS时,做一些最基本的处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据来源区分&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据按照时间分区存储,一般是按照天,也有公司使用年、月、日三级分区做存储的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进行最基本的数据处理,如格式错误的丢弃,关键信息丢失的过滤掉等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据实时离线&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）数据主要来源：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）数据存储策略（增量、全量）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际应用中，可以选择采用增量、全量存储或拉链存储的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了满足历史数据分析需求，您可以在ODS层表中添加时间维度作为分区字段。以天为单位的增量存储，以业务日期作为分区，每个分区存放日增量的业务数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举例如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1月1日，用户A访问了A公司电商店铺B，A公司电商日志产生一条记录t1。1月2日，用户A又访问了A公司电商店铺C，A公司电商日志产生一条记录t2。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用增量存储方式，t1将存储在1月1日这个分区中，t2将存储在1月2日这个分区中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1月1日，用户A在A公司电商网购买了B商品，交易日志将生成一条记录t1。1月2日，用户A又将B商品退货了，交易日志将更新t1记录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用增量存储方式，初始购买的t1记录将存储在1月1日这个分区中，更新后的t1将存储在1月2日这个分区中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;交易、日志等事务性较强的ODS表适合增量存储方式。这类表数据量较大，采用全量存储的方式存储成本压力大。此外，这类表的下游应用对于历史全量数据访问的需求较小（此类需求可通过数据仓库后续汇总后得到）。例如，日志类ODS表没有数据更新的业务过程，因此所有增量分区UNION在一起就是一份全量数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以天为单位的全量存储，以业务日期作为分区，每个分区存放截止到业务日期为止的全量业务数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如，1月1日，卖家A在A公司电商网发布了B、C两个商品，前端商品表将生成两条记录t1、t2。1月2日，卖家A将B商品下架了，同时又发布了商品D，前端商品表将更新记录t1，同时新生成记录t3。采用全量存储方式， 在1月1日这个分区中存储t1和t2两条记录，在1月2日这个分区中存储更新后的t1以及t2、t3记录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于小数据量的缓慢变化维度数据，例如商品类目，可直接使用全量存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拉链存储通过新增两个时间戳字段（start_dt和end_dt），将所有以天为粒度的变更数据都记录下来，通常分区字段也是这两个时间戳字段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;169&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.29172714078374457&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCbrzVCsLHvH10AiauhoFuyYAM6yrgsl7vNd6OzwAialux4MRibIU6om3JWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;689&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;概念：又称为接口层(stage)，用于存储每天的增量数据和变更数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据生成方式：直接从kafka接收源数据，需要业务表每天生成update,delete,inseret数据，只生成insert数据的业务表，数据直接入明细层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;讨论方案：只把canal日志直接入缓冲层，如果其它有拉链数据的业务，也入缓冲层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日志存储方式：使用impala外表，parquet文件格式，方便需要MR处理的数据读取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日志删除方式：长久存储，可只存储最近几天的数据。讨论方案：直接长久存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表schema：一般按天创建分区，partitioned by 一般都是按照天进行存放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;库与表命名。库名：ods,表名：初步考虑格式为ods日期业务表名,待定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;hive的外部表,对应的是业务表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;hive外部表,存放数据的文件可以不是在hive的hdfs默认的位置,并且hive对应的表删除时,相应的数据文件并不会被删除.这样对于企业开发来说,可以防止因为删除表的操作而把宝贵的数据删除掉hive的业务表,则相反.数据文件存放在hive对应的默认位置,表删除时,对应文件也会被删除掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、数仓层（DW,data warehouse）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据仓库层(DW)层：数据仓库层是我们在做数据仓库时要核心设计的一层，本层将从 ODS 层中获得的数据按照主题建立各种数据模型，每一个主题对应一个宏观的分析领域，数据仓库层排除对决策无用的数据，提供特定主题的简明视图。在DW层会保存BI系统中所有的历史数据，例如保存10年的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DW存放明细事实数据、维表数据及公共指标汇总数据。其中，明细事实数据、维表数据一般根据ODS层数据加工生成。公共指标汇总数据一般根据维表数据和明细事实数据加工生成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DW层又细分为维度层（DIM）、明细数据层（DWD）和汇总数据层（DWS），采用维度模型方法作为理论基础， 可以定义维度模型主键与事实模型中外键关系，减少数据冗余，也提高明细数据表的易用性。在汇总数据层同样可以关联复用统计粒度中的维度，采取更多的宽表化手段构建公共指标数据层，提升公共指标的复用性，减少重复加工。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维度层（DIM，Dimension）：以维度作为建模驱动，基于每个维度的业务含义，通过添加维度属性、关联维度等定义计算逻辑，完成属性定义的过程并建立一致的数据分析维表。为了避免在维度模型中冗余关联维度的属性，基于雪花模型构建维度表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;明细数据层（DWD，Data Warehouse Detail）：以业务过程作为建模驱动，基于每个具体的业务过程特点，构建最细粒度的明细事实表。可将某些重要属性字段做适当冗余，也即宽表化处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;汇总数据层（DWS，Data Warehouse Summary）：以分析的主题对象作为建模驱动，基于上层的应用和产品的指标需求，构建公共粒度的汇总指标表。以宽表化手段物理化模型，构建命名规范、口径一致的统计指标，为上层提供公共指标，建立汇总宽表、明细事实表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题域：面向业务过程，将业务活动事件进行抽象的集合，如下单、支付、退款都是业务过程。针对公共明细层（DWD）进行主题划分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据域：面向业务分析，将业务过程或者维度进行抽象的集合。针对公共汇总层（DWS） 进行数据域划分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DWD 层是以业务过程为驱动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DWS 层、DWT 层和 ADS 层都是以需求为驱动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DWD：data warehouse details 数据明细层。主要对ODS数据层做一些数据清洗和规范化的操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据清洗：去除空值、脏数据、枚举值转换，超过极限范围的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DWB：data warehouse base 数据基础层，存储的是客观数据，一般用作中间层，可以认为是大量指标的数据层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DWS：data warehouse service 数据服务层，基于DWB上的基础数据，整合汇总成分析某一个主题域的服务数据层，一般是宽表。用于提供后续的业务查询，OLAP分析，数据分发等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户行为，轻度聚合&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要对ODS/DWD层数据做一些轻度的汇总。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）公共维度层（DIM，Dimension）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DIM：这一层比较单纯，举个例子就明白，比如国家代码和国家名、地理位置、中文名、国旗图片等信息就存在DIM层中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于维度建模理念思想，建立整个企业的一致性维度。降低数据计算口径和算法不统一风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公共维度汇总层（DIM）主要由维度表（维表）构成。维度是逻辑概念，是衡量和观察业务的角度。维表是根据维度及其属性将数据平台上构建的表物理化的表，采用宽表设计的原则。因此，构建公共维度汇总层（DIM）首先需要定义维度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高基数维度数据：一般是用户资料表、商品资料表类似的资料表。数据量可能是千万级或者上亿级别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;低基数维度数据：一般是配置表，比如枚举值对应的中文含义，或者日期维表。数据量可能是个位数或者几千几万。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设计维表：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完成维度定义后，您就可以对维度进行补充，进而生成维表了。维表的设计需要注意：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;建议维表单表信息不超过1000万条。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维表与其他表进行Join时，建议您使用Map Join。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;避免过于频繁的更新维表的数据。缓慢变化维：拉链表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公共维度汇总层（DIM）维表规范&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公共维度汇总层（DIM）维表命名规范：dim_{业务板块名称/pub}_{维度定义}[_{自定义命名标签}]，所谓pub是与具体业务板块无关或各个业务板块都可公用的维度，如时间维度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如：公共区域维表dim_pub_area 商品维表dim_asale_itm&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事实表中一条记录所表达的业务细节程度被称为粒度。通常粒度可以通过两种方式来表述：一种是维度属性组合所表示的细节程度，一种是所表示的具体业务含义。通透！数据仓库领域常见建模方法及实例演示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;建模方式及原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要构建维度模型，一般采用星型模型，呈现的状态一般为星座模型（由多个事实表组合，维表是公共的，可被多个事实表共享）；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为支持数据重跑可额外增加数据业务日期字段，可按日进行分表，用增量ODS层数据和前一天DWD相关表进行merge处理？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;粒度是一行信息代表一次行为，例如一次下单。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;维度建模步骤&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;选择业务过程：在业务系统中，挑选感兴趣的业务线，比如下单业务，支付业务，退款业务，物流业务，一条业务线对应一张事实表。如果是中小公司，尽量把所有业务过程都选择。DWD如果是大公司（1000多张表），选择和需求相关的业务线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;声明粒度：数据粒度指数据仓库的数据中保存数据的细化程度或综合程度的级别。声明粒度意味着精确定义事实表中的一行数据表示什么，应该尽可能选择最小粒度，以此来应各种各样的需求。典型的粒度声明如下：订单当中的每个商品项作为下单事实表中的一行，粒度为每次。每周的订单次数作为一行，粒度为每周。每月的订单次数作为一行，粒度为每月。如果在DWD层粒度就是每周或者每月，那么后续就没有办法统计细粒度的指标了。所以建议采用最小粒度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;确定维度：维度的主要作用是描述业务是事实，主要表示的是“谁，何处，何时”等信息。确定维度的原则是：后续需求中是否要分析相关维度的指标。例如，需要统计，什么时间下的订单多，哪个地区下的订单多，哪个用户下的订单多。需要确定的维度就包括：时间维度、地区维度、用户维度。维度表：需要根据维度建模中的星型模型原则进行维度退化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;确定事实：此处的“事实”一词，指的是业务中的度量值（次数、个数、件数、金额，可以进行累加），例如订单金额、下单次数等。在DWD层，以业务过程为建模驱动，基于每个具体业务过程的特点，构建最细粒度的明细层事实表。事实表可做适当的宽表化处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：DWD层是以业务过程为驱动。DWS层、DWT层和ADS层都是以需求为驱动，和维度建模已经没有关系了。DWS和DWT都是建宽表，按照主题去建表。主题相当于观察问题的角度。对应着维度表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于主题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据仓库中的数据是面向主题组织的，主题是在较高层次上将企业信息系统中的数据进行综合、归类和分析利用的一个抽象概念，每一个主题基本对应一个宏观的分析领域。如财务分析就是一个分析领域，因此这个数据仓库应用的主题就为“财务分析”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于主题域：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题域通常是联系较为紧密的数据主题的集合。可以根据业务的关注点，将这些数据主题划分到不同的主题域(也说是对某个主题进行分析后确定的主题的边界)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于主题域的划分：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题域的确定必须由最终用户（业务）和数据仓库的设计人员共同完成的， 而在划分主题域时，大家的切入点不同可能会造成一些争论、重构等的现象，考虑的点可能会是下方的某些方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总而言之，切入的出发点逻辑不一样，就可以存在不同的划分逻辑。在建设过程中可采用迭代方式，不纠结于一次完成所有主题的抽象，可先从明确定义的主题开始，后续逐步归纳总结成自身行业的标准模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题：当事人、营销、财务、合同协议、机构、地址、渠道、 产品、&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;金融业务主题有哪些 ：可分为四个主题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）DWD（data warehouse detail）数据明细层，明细粒度事实层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;361&quot; data-backw=&quot;541&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.66728280961183&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCbgc9WmHUvHnG0qGys7LW9WZWRU29evkfrlQt4ibuIWPoMeGYkV8NESZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DWD是业务层与数据仓库的隔离层， 这一层主要解决一些数据质量问题和数据的完整度问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;明细表用于存储ODS层原始表转换过来的明细数据，DWD 层的数据应该是一致的、准确的、干净的数据，即对源系统数据ODS层数据进行清洗（去除空值，脏数据，超过极限范围的数据，行式存储改为列存储，改压缩格式）、规范化、维度退化、脱敏等操作。比如用户的资料信息来自于很多不同表，而且经常出现延迟丢数据等问题，为了方便各个使用方更好的使用数据，我们可以在这一层做一个屏蔽。这一层也包含统一的维度数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;明细粒度事实层（DWD）：以业务过程作为建模驱动，基于每个具体的业务过程特点，构建最细粒度的明细层事实表。可以结合企业的数据使用特点，将明细事实表的某些重要维度属性字段做适当冗余，即宽表化处理。明细粒度事实层的表通常也被称为逻辑事实表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负责数据的最细粒度的数据，在DWD层基础上，进行轻度汇总，结合常用维度（时间，地点，组织层级，用户，商品等）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该层一般保持和ODS层一样的数据粒度，并且提供一定的数据质量保证，在ODS的基础上对数据进行加工处理，提供更干净的数据。同时，为了提高数据明细层的易用性，该层会采用一些维度退化手法，当一个维度没有数据仓库需要的任何数据时，就可以退化维度，将维度退化至事实表中，减少事实表和维表的关联。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;订单id,这种量级很大的维度，没必要用一张维度表来进行存储，而我们一般在进行数据分析时订单id又非常重要，所以我们将订单id冗余在事实表中，这种维度就是退化维度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一层的数据一般是遵循数据库第三范式或者维度建模，其数据粒度通常和 ODS 的粒度相同。在 PDW 层会保存 BI 系统中所有的历史数据，例如保存10年的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据在装入本层前需要做以下工作：去噪、去重、提脏、业务提取、单位统一、砍字段、业务判别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;清洗的数据种类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据清洗的任务是过滤那些不符合要求的数据，将过滤的结果交给业务主管部门，确认是否过滤掉还是由业务单位修正之后再进行抽取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DWD层做了哪些事？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;①数据清洗过滤&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;去除废弃字段,去除格式错误的信息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;去除丢失了关键字段的信息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;过滤核心字段无意义的数据，比如订单表中订单id为null，支付表中支付id为空&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对手机号、身份证号等敏感数据脱敏&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;去除不含时间信息的数据(这个看公司具体业务,但一般数据中都会带上时间戳,这样方便后续处理时,进行时间维度上信息分析处理和提取)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有些公司还会在这一层将数据打平,不过这具体要看业务需求.这是因为kylin适合处理展平后数据,不适合处理嵌套的表数据信息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有些公司还会将数据session做切割,这个一般是app的日志数据,其他业务场景不一定适合.这是因为app有进入后台模式,例如用户上午打开app用了10分钟,然后app切入后台,晚上再打开,这时候session还是一个,实际上应该做切割才对.(也有公司会记录app进入后台,再度进入前台的记录,这样来做session切割)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;②数据映射,转换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将GPS经纬度转换为省市区详细地址。业界常见GPS快速查询一般将地理位置知识库使用geohash映射,然后将需要比对的GPS转换为geohash后跟知识库中geohash比对,查找出地理位置信息当然,也有公司使用open api,如高德地图,百度地图的api进行GPS和地理位置信息映射,但这个达到一定次数需要花钱,所以大家都懂的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;会将IP地址也转换为省市区详细地址。这个有很多快速查找库,不过基本原理都是二分查找,因为ip地址可以转换为长整数.典型的如ip2region库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将时间转换为年,月,日甚至周,季度维度信息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据规范化,因为大数据处理的数据可能来资源公司不同部门,不同项目,不同客户端,这时候可能相同业务数据字段,数据类型,空值等都不一样,这时候需要在DWD层做抹平.否则后续处理使用时,会造成很大的困扰&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如boolean,有使用0 1标识,也有使用true false标识的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如字符串空值,有使用&quot;&quot;,也有使用null,的,统一为null即可&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如日期格式,这种就差异性更大,需要根据实际业务数据决定,不过一般都是格式化为YYYY-MM-dd HH:mm:ss 这类标准格式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维度退化：对业务数据传过来的表进行维度退化和降维。（商品一级二级三级、省市县、年月日）订单id冗余在事实表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;清洗掉多少数据算合理：1万条数据清洗掉1条。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;合理表数：一万张表变为三千张表，三千张表变为一千张表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;明细粒度事实表设计原则：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个明细粒度事实表仅和一个维度关联。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;尽可能包含所有与业务过程相关的事实 。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;只选择与业务过程相关的事实。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分解不可加性事实为可加的组件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在选择维度和事实之前必须先声明粒度。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在同一个事实表中不能有多种不同粒度的事实。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事实的单位要保持一致。粒度&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;谨慎处理Null值。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用退化维度提高事实表的易用性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;讨论方案：数据的合成方式为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全量：每天把明细层的前天全量数据和昨天新数据合成一个新的数据表，覆盖旧表。同时使用历史镜像，按周/按月/按年存储一个历史镜像到新表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日志存储方式：直接数据使用impala外表，parquet文件格式， 建议使用内表，下面几层都是从impala生成的数据，建议都用内表+静态/动态分区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表schema：一般按天创建分区，没有时间概念的按具体业务选择分区字段。partitioned by 一般都是按照天进行存放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;库与表命名。库名：dwd,表名：初步考虑格式为dwd日期业务表名,待定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;旧数据更新方式：直接覆盖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;明细粒度事实层（DWD）规范&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;命名规范为：dwd_{业务板块/pub}_{数据域缩写}_{业务过程缩写}[_{自定义表命名标签缩写}] _{单分区增量全量标识}，pub表示数据包括多个业务板块的数据。单分区增量全量标识通常为：i表示增量，f表示全量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如：dwd_asale_trd_ordcrt_trip_di（A电商公司航旅机票订单下单事实表，日刷新增量） dwd_asale_itm_item_df（A电商商品快照事实表，日刷新全量）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本教程中，DWD层主要由三个表构成：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;交易商品信息事实表：dwd_asale_trd_itm_di。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;交易会员信息事实表：ods_asale_trd_mbr_di。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;交易订单信息事实表：dwd_asale_trd_ord_di。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;304&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5259259259259259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCbJmQJZmGatcgxWTMeJUwzcXhcUWEiaCUFNE6mM8IElNmqMZOwEvcEBXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;EXISTS&lt;/span&gt; dwd_asale_trd_itm_di&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;item_id &lt;span class=&quot;code-snippet__built_in&quot;&gt;BIGINT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品ID&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;item_title &lt;span class=&quot;code-snippet__keyword&quot;&gt;STRING&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品名称&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;item_price &lt;span class=&quot;code-snippet__keyword&quot;&gt;DOUBLE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品价格&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;item_stuff_status &lt;span class=&quot;code-snippet__built_in&quot;&gt;BIGINT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品新旧程度_0全新1闲置2二手&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;item_prov &lt;span class=&quot;code-snippet__keyword&quot;&gt;STRING&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品省份&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;item_city &lt;span class=&quot;code-snippet__keyword&quot;&gt;STRING&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品城市&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cate_id &lt;span class=&quot;code-snippet__built_in&quot;&gt;BIGINT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品类目ID&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cate_name &lt;span class=&quot;code-snippet__keyword&quot;&gt;STRING&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品类目名称&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;commodity_id &lt;span class=&quot;code-snippet__built_in&quot;&gt;BIGINT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;品类ID&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;commodity_name &lt;span class=&quot;code-snippet__keyword&quot;&gt;STRING&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;品类名称&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;buyer_id &lt;span class=&quot;code-snippet__built_in&quot;&gt;BIGINT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;买家ID&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;交易商品信息事实表&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;PARTITIONED &lt;span class=&quot;code-snippet__keyword&quot;&gt;BY&lt;/span&gt; (ds &lt;span class=&quot;code-snippet__keyword&quot;&gt;STRING&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;日期&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LIFECYCLE &lt;span class=&quot;code-snippet__number&quot;&gt;400&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;346&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5987903225806451&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCb66WcmS4cXC2RBxz1Ajnesr7jnbNEfabzlyz5iadadgJOm8TS2Ikx3AQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;992&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）DWS（ data warehouse service）数据服务层，汇总层宽表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;333&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5763993948562783&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCboySYIu1j5YBfvrlyULAiarQt8xbI0H9ZtnROr5TCuAF6OOX4oYwepcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于 DWD 明细数据层，我们会按照一些分析场景、分析实体等去组织我们的数据，组织成一些分主题的汇总数据层 DWS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;明细粒度 ==&amp;gt; 汇总粒度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DWS层（数据汇总层）宽表，面向主题的汇总，维度相对来说比较少，DWS是根据DWD层基础数据按各个维度ID进行粗粒度汇总聚合，如按交易来源，交易类型进行汇合。整合汇总成分析某一个主题域的服务数据，一般是宽表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以DWD为基础，按天进行轻度汇总。统计各个主题对象的当天行为，（例如，购买行为，统计商品复购率）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该层数据表会相对比较少，大多都是宽表(一张表会涵盖比较多的业务内容，表中的字段较多)。按照主题划分，如订单、用户等，生成字段比较多的宽表，用于提供后续的业务查询，OLAP分析，数据分发等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;融合多个中间层数据，基于主题形成事实表，比如用户事实表、渠道事实表、终端事实表、资产事实表等等，事实表一般是宽表，在本层上实现企业级数据的一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先划分业务主题，将主题划分为销售域、库存域、客户域、采购域 等，其次就是 确定每个主题域的事实表和维度表。通常根据业务需求，划分成流量、订单、用户等，生成字段比较多的宽表，用于提供后续的业务查询，OLAP分析，数据分发等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近一天某个类目（例如：厨具）商品在各省的销售总额、该类目Top10销售额商品名称、各省用户购买力分布。因此，我们可以以最终交易成功的商品、类目、买家等角度对最近一天的数据进行汇总。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如用户每个时间段在不同登录ip购买的商品数等。这里做一层轻度的汇总会让计算更加的高效，在此基础上如果计算仅7天、30天、90天的行为的话会快很多。我们希望80%的业务都能通过我们的DWS层计算，而不是ODS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DWS层做了哪些事？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;dws将dwd层的数据按主题进行汇总，按照主题放到一个表中，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如用户主题下会将用户注册信息、用户收货地址、用户的征信数据放到同一张表中，而这些在dwd层是对应多张表的,按照业务划分，如流量、订单、用户等，生成字段比较多的宽表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题建模,围绕某一个业务主题进行数据建模,将相关数据抽离提取出来.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将流量会话按照天,月进行聚合&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将每日新用户进行聚合&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将每日活跃用户进行聚合&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;维度建模,其实也差不多,不过是根据业务需要,提前将后续数据查询处理需要的维度数据抽离处理出来,方便后续查询使用.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如将运营位维度数据聚合&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将渠道拉新维度数据聚合&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;①DWS层每个主题1-3张宽表（处理100-200个指标 70%以上的需求）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体宽表名称：用户行为宽表，用户购买商品明细行为宽表，商品宽表， 物流宽表、 售后等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②哪个宽表最宽？大概有多少个字段？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最宽的是用户行为宽表。大概有60-200个字段&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③具体用户行为宽表字段名称&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;评论、打赏、收藏、关注--商品、关注--人、点赞、分享、好价爆料、文章发布、活跃、签到、补签卡、幸运屋、礼品、金币、电商点击、gmv&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;④分析过的指标&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日活、月活、周活、留存、留存率、新增（日、周、年）、转化率、流失、回流、七天内连续 3 天登录（点赞、收藏、评价、购买、加购、下单、活动）、连续 3 周（月）登录、GMV（成交金额，下单）、复购率、复购率排行、点赞、评论、收藏、领优惠价人数、使用优惠价、沉默、值不值得买、退款人数、退款率 topn 热门商品&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日活：100 万 ；月活：是日活的 2-3 倍 300 万&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总注册的用户多少？1000 万-3000 万之间&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GMV：每天 10 万订单 （50 – 100 元） 500 万-1000 万&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;100万的日活每天大概有10万人购买，平均每人消费100元，一天的GMV在1000万&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;10%-20% 100 万-200 万&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;某日常商品复购；（手纸、面膜、牙膏）10%-20%&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;电脑、显示器、手表 1%&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商品详情 =》 加购物车 =》下单 =》 支付&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5%-10% 60-70% 90%-95%&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1/2/3、周留存、月留存&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;搞活动：10-20%&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;概念：又称数据集市或宽表。按照业务划分，如流量、订单、用户等，生成字段比较多的宽表，用于提供后续的业务查询，OLAP分析，数据分发等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据生成方式：由轻度汇总层和明细层数据计算生成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日志存储方式：使用impala内表，parquet文件格式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表schema：一般按天创建分区，没有时间概念的按具体业务选择分区字段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;库与表命名。库名：dws, 表名：初步考虑格式为：dws日期业务表名,待定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;旧数据更新方式：直接覆盖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;公共汇总事实表规范&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公共汇总事实表命名规范：dws_{业务板块缩写/pub}_{数据域缩写}_{数据粒度缩写}[_{自定义表命名标签缩写}]_{统计时间周期范围缩写}。关于统计实际周期范围缩写，缺省情况下，离线计算应该包括最近一天（_1d），最近N天（_nd）和历史截至当天（_td）三个表。如果出现_nd的表字段过多需要拆分时，只允许以一个统计周期单元作为原子拆分。即一个统计周期拆分一个表，例如最近7天（_1w）拆分一个表。不允许拆分出来的一个表存储多个统计周期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于小时表（无论是天刷新还是小时刷新），都用_hh来表示。对于分钟表（无论是天刷新还是小时刷新），都用_mm来表示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举例如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;dws_asale_trd_byr_subpay_1d（买家粒度交易分阶段付款一日汇总事实表）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;dws_asale_trd_byr_subpay_td（买家粒度分阶段付款截至当日汇总表）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;dws_asale_trd_byr_cod_nd（买家粒度货到付款交易汇总事实表）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;dws_asale_itm_slr_td（卖家粒度商品截至当日存量汇总表）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;dws_asale_itm_slr_hh（卖家粒度商品小时汇总表）---维度为小时&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;dws_asale_itm_slr_mm（卖家粒度商品分钟汇总表）---维度为分钟&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;exists&lt;/span&gt; dws_sale_detail_daycount;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;external&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; dws_sale_detail_daycount(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;user_id &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;用户 id&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;user_gender &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;用户性别&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;user_age &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;用户年龄&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;user_level &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;用户等级&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;buyer_nick &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;买家昵称&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mord_prov &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;地址&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;login_count &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;当日登录次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cart_count &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;加入购物车次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;order_count &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;当日下单次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;order_amount &lt;span class=&quot;code-snippet__built_in&quot;&gt;decimal&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;16&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;当日下单金额&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;payment_count &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;当日支付次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;payment_amount &lt;span class=&quot;code-snippet__built_in&quot;&gt;decimal&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;16&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;当日支付金额&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;confirm_paid_amt_sum_1d &lt;span class=&quot;code-snippet__keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;最近一天订单已经确认收货的金额总和&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;order_detail_stats &lt;span class=&quot;code-snippet__built_in&quot;&gt;array&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt;&amp;lt;sku_id:&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;,sku_num:&lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt;,order_count:&lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt;,order_amount:&lt;span class=&quot;code-snippet__built_in&quot;&gt;decimal&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;)&amp;gt;&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;下单明细统计&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;每日购买行为&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;partitioned &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;`dt`&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;stored&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; parquet&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;location &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;/warehouse/gmall/dws/dws_sale_detail_daycount/&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tblproperties(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;parquet.compression&quot;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;lzo&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;EXISTS&lt;/span&gt; dws_asale_trd_itm_ord_1d&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;item_id &lt;span class=&quot;code-snippet__built_in&quot;&gt;BIGINT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品ID&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;item_title &lt;span class=&quot;code-snippet__keyword&quot;&gt;STRING&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品名称&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cate_id &lt;span class=&quot;code-snippet__built_in&quot;&gt;BIGINT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品类目ID&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cate_name &lt;span class=&quot;code-snippet__keyword&quot;&gt;STRING&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品类目名称&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;confirm_paid_amt_sum_1d &lt;span class=&quot;code-snippet__keyword&quot;&gt;DOUBLE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;最近一天订单已经确认收货的金额总和&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品粒度交易最近一天汇总事实表&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;PARTITIONED &lt;span class=&quot;code-snippet__keyword&quot;&gt;BY&lt;/span&gt; (ds &lt;span class=&quot;code-snippet__keyword&quot;&gt;STRING&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;分区字段YYYYMMDD&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LIFECYCLE &lt;span class=&quot;code-snippet__number&quot;&gt;36000&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;337&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5833333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCb0EGRd0G86MChObQBicyH6hvHgiaUrAHpIPAwFcKZMefeNn3ickHnGfL1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问：数据集市层是不是没地方放了，各个业务的数据集市表是应该在 dws 还是在 app?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;答：这个问题不太好回答，我感觉主要就是明确一下数据集市层是干什么的，如果你的数据集市层放的就是一些可以供业务方使用的宽表，放在 app 层就行。如果你说的数据集市层是一个比较泛一点的概念，那么其实 dws、dwd、app 这些合起来都算是数据集市的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、应用层（ADS）applicationData Service应用数据服务&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;272&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4713656387665198&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCbtJQRkBYAjxA1OGwCLyveLOdb1zyj1ibMSibcwKkop9vjiafyTEI1vq5PA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据应用层（ADS，Application Data Store）：存放数据产品个性化的统计指标数据，报表数据。主要是提供给数据产品和数据分析使用的数据，通常根据业务需求，划分成流量、订单、用户等，生成字段比较多的宽表，用于提供后续的业务查询，OLAP分析，数据分发等。从数据粒度来说，这层的数据是汇总级的数据，也包括部分明细数据。从数据的时间跨度来说，通常是DW层的一部分，主要的目的是为了满足用户分析的需求，而从分析的角度来说，用户通常只需要分析近几年的即可。从数据的广度来说，仍然覆盖了所有业务数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 DWS 之上，我们会面向应用场景去做一些更贴近应用的 APP 应用数据层，这些数据应该是高度汇总的，并且能够直接导入到我们的应用服务去使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用层(ADS)：应用层主要是各个业务方或者部门基于DWD和DWS建立的数据集市(Data Market, DM)，一般来说应用层的数据来源于DW层，而且相对于DW层，应用层只包含部门或者业务方面自己关心的明细层和汇总层的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该层主要是提供数据产品和数据分析使用的数据。一般就直接对接OLAP分析,或者业务层数据调用接口了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据应用层APP：面向业务定制的应用数据主要提供给数据铲平和数据分析使用的数据，一般会放在ES，MYSQL，Oracle，Redis等系统供线上系统使用，也可以放在Hive 或者 Druid 中供数据分析和数据挖掘使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;APP 层：为应用层，这层数据是完全为了满足具体的分析需求而构建的数据，也是星形或雪花结构的数据。如我们经常说的报表数据，或者说那种大宽表，一般就放在这里。包括前端报表、分析图表、KPI、仪表盘、OLAP、专题等分析，面向最终结果用户；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;概念：应用层是根据业务需要，由前面三层数据统计而出的结果，可以直接提供查询展现，或导入至Mysql中使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据生成方式：由明细层、轻度汇总层，数据集市层生成，一般要求数据主要来源于集市层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日志存储方式：使用impala内表，parquet文件格式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表schema：一般按天创建分区，没有时间概念的按具体业务选择分区字段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;库与表命名。库名：暂定ads，另外根据业务不同，不限定一定要一个库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;旧数据更新方式：直接覆盖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ADS 层复购率统计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;224&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38796296296296295&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCbeveo3VzvibaaABQUKcKgYFuTsoQqk2pZodLib0DNbbSpuu4fvqjskU0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;299&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5168711656441718&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCbn8yY6VjvtDSclZJWTKrfBqBib7lc6Xl1FS4TOaPhVhyiaib57AjWWefEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;652&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;107&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.18425925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCbWXpyHkjZBRPyvKNhFEYibWBLDkhVCm4KTZaJafyoibOyks3z9keMDG1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;280&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4842592592592593&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zj9HceGY7iaoWBibcF8AicZCbMWCW9oz8OX5amL8mzJqGdExOicqSn9ibMwWpyd6KMO6keWoUicRIX9CDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; app_usr_interact( user_id &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;用户id&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;nickname &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;用户昵称&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;register_date &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;注册日期&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;register_from &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;注册来源&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;remark &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;细分渠道&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;province &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;注册省份&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pl_cnt &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;评论次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ds_cnt &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;打赏次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sc_add &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;添加收藏&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sc_cancel &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;取消收藏&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;gzg_add &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;关注商品&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;gzg_cancel &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;取消关注商品&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;gzp_add &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;关注人&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;gzp_cancel &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;取消关注人&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;buzhi_cnt &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;点不值次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;zhi_cnt &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;点值次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;zan_cnt &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;点赞次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;share_cnts &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;分享次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;bl_cnt &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;爆料数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fb_cnt &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;好价发布数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;online_cnt &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;活跃次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;checkin_cnt &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;签到次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fix_checkin &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;补签次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;house_point &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;幸运屋金币抽奖次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;house_gold &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;幸运屋积分抽奖次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pack_cnt &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;礼品兑换次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;gold_add &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;获取金币&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;gold_cancel &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;支出金币&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;surplus_gold &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;剩余金币&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;电商点击次数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;gmv_amount &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;gmv&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;gmv_sales &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;订单数&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;PARTITIONED &lt;span class=&quot;code-snippet__keyword&quot;&gt;BY&lt;/span&gt;( dt &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;互动日期&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;①如何分析用户活跃？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在启动日志中统计不同设备 id 出现次数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②如何分析用户新增?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用活跃用户表 left join 用户新增表，用户新增表中 mid 为空的即为用户新增。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③如何分析用户 1 天留存？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;留存用户=前一天新增 join 今天活跃&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户留存率=留存用户/前一天新增&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;④如何分析沉默用户？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(登录时间为 7 天前,且只出现过一次)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照设备 id 对日活表分组，登录次数为 1，且是在一周前登录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;⑤如何分析本周回流用户？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本周活跃 left join 本周新增 left join 上周活跃，且本周新增 id 和上周活跃 id 都为 null。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;⑥如何分析流失用户？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(登录时间为 7 天前)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照设备 id 对日活表分组，且七天内没有登录过。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;⑦如何分析最近连续 3 周活跃用户数？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照设备 id 对周活进行分组，统计次数大于 3 次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;⑧如何分析最近七天内连续三天活跃用户数？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7 天连续收藏、点赞、购买、加购、付款、浏览、商品点击、退货&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1 个月连续 7 天&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;连续两周&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TMP：每一层的计算都会有很多临时表，专设一个DW TMP层来存储我们数据仓库的临时表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、层次调用规范&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p draggable=&quot;true&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;作者丨四月天03&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源丨网址：https://blog.csdn.net/qq_22473611/article/details/103278799&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section data-recommend-type=&quot;list-normal&quot; data-recommend-tid=&quot;2&quot; data-mpa-template=&quot;t&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501257_1&quot; data-recommend-article-time=&quot;1636251616&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/zc3KLDBfJlm8bD2WBlwbvnsktMdtfSudNaJWbHr1Iyr6HkwCxETHiaiceaWYLmq7tWmHV29U8Xv8UnoeCAOYNj9Q/0?wx_fmt=jpeg&amp;amp;amp;random=0.27521905775014543&quot; data-recommend-article-title=&quot;强势开源一款小程序！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501257&amp;amp;idx=1&amp;amp;sn=7b4e27cdb1d3146a5e7e1951b5bdc9e8&amp;amp;chksm=c1ca33f9f6bdbaefd3874fa6313e422c8fb6b2799b40d09f36620f0ceaed4fd63c820da1f3ff#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501257&amp;amp;idx=1&amp;amp;sn=7b4e27cdb1d3146a5e7e1951b5bdc9e8&amp;amp;chksm=c1ca33f9f6bdbaefd3874fa6313e422c8fb6b2799b40d09f36620f0ceaed4fd63c820da1f3ff&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;强势开源一款小程序！&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-11-07&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42592592592592593&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zc3KLDBfJlm8bD2WBlwbvnsktMdtfSudNaJWbHr1Iyr6HkwCxETHiaiceaWYLmq7tWmHV29U8Xv8UnoeCAOYNj9Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501242_1&quot; data-recommend-article-time=&quot;1634952613&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UWibGeSzVdcKHzDRdVHusb9CJicA5FdhDVPAiaicdTbibx5XoRkhKA3O7Q727cTSurBkJpciczjLrF2wkA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;强力推荐一个完善的物流（WMS）管理项目（附代码）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501242&amp;amp;idx=1&amp;amp;sn=aa2297b69874de0993f62ea404376bab&amp;amp;chksm=c1ca338af6bdba9cf3e051ff3001e1f31f9fa97350f3851c797d6486eca360df537196dbe67b#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501242&amp;amp;idx=1&amp;amp;sn=aa2297b69874de0993f62ea404376bab&amp;amp;chksm=c1ca338af6bdba9cf3e051ff3001e1f31f9fa97350f3851c797d6486eca360df537196dbe67b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;强力推荐一个完善的物流（WMS）管理项目（附代码）&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-10-23&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UWibGeSzVdcKHzDRdVHusb9CJicA5FdhDVPAiaicdTbibx5XoRkhKA3O7Q727cTSurBkJpciczjLrF2wkA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501238_1&quot; data-recommend-article-time=&quot;1634606700&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VduLA9tc9dQkaw5HWIV6pqNrOiciaE17jeIeTtoLfgLbyu67dWkRj3tjKX7AFIMrV0rKD5ic6kwicyxg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;推荐一个 Spring Boot + MyBatis + Vue 音乐网站&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501238&amp;amp;idx=1&amp;amp;sn=d7e873d752a28b582d70bc9f7a981ddb&amp;amp;chksm=c1ca3386f6bdba9031ce115e734ce04c9b6728e8e027fbcf17d8d07f1e029ea5bea04f4a6273#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501238&amp;amp;idx=1&amp;amp;sn=d7e873d752a28b582d70bc9f7a981ddb&amp;amp;chksm=c1ca3386f6bdba9031ce115e734ce04c9b6728e8e027fbcf17d8d07f1e029ea5bea04f4a6273&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;推荐一个 Spring Boot + MyBatis + Vue 音乐网站&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-10-19&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42592592592592593&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VduLA9tc9dQkaw5HWIV6pqNrOiciaE17jeIeTtoLfgLbyu67dWkRj3tjKX7AFIMrV0rKD5ic6kwicyxg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501208_1&quot; data-recommend-article-time=&quot;1632101100&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VibcP3PNgQvXGZ7UJkVeu0JZsrldvF1urHlmNwhUP89IeKHz1PfJ12es2ArTwkYibAh3Y0soOib2rjA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;分享一套家庭理财系统（附源码）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501208&amp;amp;idx=1&amp;amp;sn=44fcdfe2d7f81a26845faf33750ea9bb&amp;amp;chksm=c1ca33a8f6bdbabec8ff34719f438465adf745cbef30bfb92be53897c714d8c13bdd01989d17#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501208&amp;amp;idx=1&amp;amp;sn=44fcdfe2d7f81a26845faf33750ea9bb&amp;amp;chksm=c1ca33a8f6bdbabec8ff34719f438465adf745cbef30bfb92be53897c714d8c13bdd01989d17&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;分享一套家庭理财系统（附源码）&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-09-20&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42407407407407405&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VibcP3PNgQvXGZ7UJkVeu0JZsrldvF1urHlmNwhUP89IeKHz1PfJ12es2ArTwkYibAh3Y0soOib2rjA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501192_1&quot; data-recommend-article-time=&quot;1630718700&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UG0pYPldneUCCVsPia3Rtr9j3hlFHakhItFlOXuwLicUqQvP1PhkTM28CUU9BpRCWfWPfHYredCBiaA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;推荐一个互联网企业级别的开源支付系统&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501192&amp;amp;idx=1&amp;amp;sn=444404a565f02a8c532d291d99678a7b&amp;amp;chksm=c1ca33b8f6bdbaaeb7c65d9f6f0c399f609fb203f065b6e88a3ad5431473713dbb5ae3507b32#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501192&amp;amp;idx=1&amp;amp;sn=444404a565f02a8c532d291d99678a7b&amp;amp;chksm=c1ca33b8f6bdbaaeb7c65d9f6f0c399f609fb203f065b6e88a3ad5431473713dbb5ae3507b32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;推荐一个互联网企业级别的开源支付系统&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-09-04&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UG0pYPldneUCCVsPia3Rtr9j3hlFHakhItFlOXuwLicUqQvP1PhkTM28CUU9BpRCWfWPfHYredCBiaA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501176_1&quot; data-recommend-article-time=&quot;1629509100&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VQRwetNLhDOB2Ej0fDZK4eRXsYlRNicgmsWwmuvlhibooic3N3su1lbMQPqWD186JiaOC5yJ9iaaic8bzw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;推荐一套开源通用后台管理系统（附源码）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501176&amp;amp;idx=1&amp;amp;sn=68e3ae7a9dc33fbbd379906ddcefdf5b&amp;amp;chksm=c1ca3348f6bdba5e1774625745f5ef40081c9b8eb0189073734b6808efb872720781d25b8dc0#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501176&amp;amp;idx=1&amp;amp;sn=68e3ae7a9dc33fbbd379906ddcefdf5b&amp;amp;chksm=c1ca3348f6bdba5e1774625745f5ef40081c9b8eb0189073734b6808efb872720781d25b8dc0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;推荐一套开源通用后台管理系统（附源码）&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-08-21&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4265625&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VQRwetNLhDOB2Ej0fDZK4eRXsYlRNicgmsWwmuvlhibooic3N3su1lbMQPqWD186JiaOC5yJ9iaaic8bzw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501153_1&quot; data-recommend-article-time=&quot;1627704022&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UbyFoOMqOObokEYiahCar20LiaY8ZLGKzU7NYQQoGycgnhrmIzNJibPicGcNia3cbbXlYib6bcLJVV5aww/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;一款神仙接私活儿软件，吊到不行！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501153&amp;amp;idx=1&amp;amp;sn=bb29cffa56431b72a92709c0ae993af7&amp;amp;chksm=c1ca3351f6bdba4729c671cdcd0ee8b6af75c6ce8a7003e6c032942b849aab5bfedecd0f9d3b#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501153&amp;amp;idx=1&amp;amp;sn=bb29cffa56431b72a92709c0ae993af7&amp;amp;chksm=c1ca3351f6bdba4729c671cdcd0ee8b6af75c6ce8a7003e6c032942b849aab5bfedecd0f9d3b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;一款神仙接私活儿软件，吊到不行！&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-07-31&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4265625&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UbyFoOMqOObokEYiahCar20LiaY8ZLGKzU7NYQQoGycgnhrmIzNJibPicGcNia3cbbXlYib6bcLJVV5aww/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501139_1&quot; data-recommend-article-time=&quot;1626571500&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VGxZrbRFy96Sm9cXQzVEhiaLibUUYhYH1SJL4HUXenau3DCeq0KEOsguY4CWjaEd1BeAicJd24qFM2w/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;基于 SpringBoot 的仿豆瓣平台【源码分享】&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501139&amp;amp;idx=1&amp;amp;sn=f133e70bda8abae27459ccc4d3d6d8fd&amp;amp;chksm=c1ca3363f6bdba75b9a4145510d9b6108c56146a3146b2e2e6d660a08221618b01c815d55642#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501139&amp;amp;idx=1&amp;amp;sn=f133e70bda8abae27459ccc4d3d6d8fd&amp;amp;chksm=c1ca3363f6bdba75b9a4145510d9b6108c56146a3146b2e2e6d660a08221618b01c815d55642&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;基于 SpringBoot 的仿豆瓣平台【源码分享】&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-07-18&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42427884615384615&quot; data-type=&quot;jpeg&quot; data-w=&quot;832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VGxZrbRFy96Sm9cXQzVEhiaLibUUYhYH1SJL4HUXenau3DCeq0KEOsguY4CWjaEd1BeAicJd24qFM2w/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501105_1&quot; data-recommend-article-time=&quot;1623979500&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7Xw68Ow8vZian4lanQFAu09f4JOZlXbC85jsByb8V6StkOpibAdgPamPWoPPY3G7S3nic50QvxxuGNrg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;干掉 Wordpress！这个开源建站神器有点吊！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501105&amp;amp;idx=1&amp;amp;sn=caf01186b6d2e4a38e940ce07d822238&amp;amp;chksm=c1ca3301f6bdba17ba7127da24e28963ae40f944e587f14b57405e2a9ee9d8cdbcb835c880c8#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501105&amp;amp;idx=1&amp;amp;sn=caf01186b6d2e4a38e940ce07d822238&amp;amp;chksm=c1ca3301f6bdba17ba7127da24e28963ae40f944e587f14b57405e2a9ee9d8cdbcb835c880c8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;干掉 Wordpress！这个开源建站神器有点吊！&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-06-18&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42578125&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7Xw68Ow8vZian4lanQFAu09f4JOZlXbC85jsByb8V6StkOpibAdgPamPWoPPY3G7S3nic50QvxxuGNrg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501098_2&quot; data-recommend-article-time=&quot;1623461160&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VzIP6xibP6U8htKa7YEad1iaTE02ZbsOfvDX1D8LoTiaNsMVgdjFOdm5LahpnNXFe3ibSp8S4FJ39KkA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;从朋友那里搞了 20 个实战项目，速领！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4#rd&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;从朋友那里搞了 20 个实战项目，速领！&lt;/a&gt;&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;2021-06-12&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;200&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VzIP6xibP6U8htKa7YEad1iaTE02ZbsOfvDX1D8LoTiaNsMVgdjFOdm5LahpnNXFe3ibSp8S4FJ39KkA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4703703703703704&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Baq5lYpIw7X6YPYGQITyP8Zdk96ab7CX0Ind5E05VokoepTP9Adic0xRwiaQrAvfTeC7iafngRibhBShpVqibqNcCCA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如有收获，点个在看，诚挚感谢&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100018364&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;19&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54JM0xl7WLNGnqqwbcXQBWIOCMuOgPHRoOjMamXzrCqMS2xgOo5ibic9icPk7u3zsVgic3s1ZUYJ4xHXg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>