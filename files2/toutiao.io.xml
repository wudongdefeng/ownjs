<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>924c067248a96e16b4a192c7f7092663</guid>
<title>大厂Kafka的深度实践</title>
<link>https://toutiao.io/k/7jz8lsl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;华仔聊技术&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;gh_97b8de4b5b34&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;聊聊后端技术架构以及中间件源码&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0961e9471a5c99adbaf0aeb973e4884b</guid>
<title>HttpClient 在vivo内销浏览器的高并发实践优化</title>
<link>https://toutiao.io/k/whq0h15</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;作者：vivo 互联网服务器团队- Zhi Guangquan&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;HttpClient作为Java程序员最常用的Http工具，其对Http连接的管理能简化开发，并且提升连接重用效率；在正常情况下，HttpClient能帮助我们高效管理连接，但在一些并发高，报文体较大的情况下，如果再遇到网络波动，如何保证连接被高效利用，有哪些优化空间。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、问题现象&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;北京时间X月X日，浏览器信息流服务监控出现异常，主要表现在以下三个方面：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;从某个时间点开始，云监控显示部分Http接口的熔断器被打开，而且从明细列表可以发现问题机器：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEur15EYAlfFXS2v6ibSZBGh5ttNolxdgnVx9RvXX3y9M2UW3ibI12XKKQIA/0?wx_fmt=png&quot; data-cropx1=&quot;11.347750865051903&quot; data-cropx2=&quot;925.6522491349482&quot; data-cropy1=&quot;8.105536332179932&quot; data-cropy2=&quot;520.3754325259516&quot; data-ratio=&quot;0.5612691466083151&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6ANHib9N7picyuomWhjsuEur5AIibyxz3ELszDfH8WD2D7jiaRh8OMR4X1V0kedsKSjQw2evOZtfSbjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;2.06651376146789&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEur6s0RcbP2Bg3qbgIUHuVyCQYVOzZ6PLZhgF88phEfauktUeMxqhL5rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;436&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;2. 从PAAS平台Hystrix熔断管理界面中可以进一步确认问题机器的所有Http接口调用均出现了熔断：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;3. 日志中心有大量从Http连接池获取连接的异常：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;org.apache.http.impl.execchain.RequestAbortedException: Request aborted。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、问题定位&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;综合以上三个现象，大概可以推测出问题机器的TCP连接管理出了问题，可能是虚拟机问题，也可能是物理机问题；与运维与系统侧沟通后，发现虚拟机与物理机均无明显异常，第一时间联系运维重启了问题机器，线上问题得到解决。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.1 临时解决方案&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;几天以后，线上部分其他机器也陆续出现了上述现象，此时基本可以确认是服务本身有问题；既然问题与TCP连接相关，于是联系运维在问题机器上建立了一个作业查看TCP连接的状态分布：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;netstat&lt;/span&gt; -ant|awk &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;/^tcp/ {++S[&lt;span class=&quot;code-snippet__variable&quot;&gt;$NF&lt;/span&gt;]} END {for(a in S) print (a,S[a])}&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;结果如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5706806282722514&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurWrF38mPTicd7HZxGabxC9BwhXb9iaVhCj3kXLW4o7fHoR7SDJauWlmBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;191&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;如上图，问题机器的CLOSE_WAIT状态的连接数已经接近200左右（该服务Http连接池最大连接数设置的250），那问题直接原因基本可以确认是CLOSE_WAIT状态的连接过多导致的；本着第一时间先解决线上问题的原则，先把连接池调整到500，然后让运维重启了机器，线上问题暂时得到解决。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.2 原因分析&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;调整连接池大小只是暂时解决了线上问题，但是具体原因还不确定，按照以往经验，出现连接无法正常释放基本都是开发者使用不当，在使用完成后没有及时关闭连接；但很快这个想法就被否定了，原因显而易见：当前的服务已经在线上运行了一周左右，中间没有经历过发版，以浏览器的业务量，如果是连接使用完没有及时关。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;闭，250的连接数连一分钟都撑不到就会被打爆。那么问题就只能是一些异常场景导致的连接没有释放；于是，重点排查了下近期上线的业务接口，尤其是那种数据包体较大，响应时间较长的接口，最终把目标锁定在了某个详情页优化接口上；先查看处于CLOSE_WAIT状态的IP与端口连接对，确认对方服务器IP地址。&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat-tulnap|grep &lt;span class=&quot;code-snippet__built_in&quot;&gt;CLOSE_WAIT&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47398843930635837&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEur01UhbE9Xr6OEsLkwBcuU1VdibUj5vzibsZYM0OOl87f5kFz8fe5ib53zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;经过与合作方确认，目标IP均来自该合作方，与我们的推测是相符的。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.3 TCP抓包&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;在定位问题的同时，也让运维同事帮忙抓取了TCP的数据包，结果表明确实是客户端（浏览器服务端）没返回ACK结束握手，导致挥手失败，客户端处于了CLOSE_WAIT状态，数据包的大小也与怀疑的问题接口相符。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2254335260115607&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEur7JVPyB85KruzYNfwmjaCYttFj0NGsd2Xdux5LCTxW0D9vLrXa3tDibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;为了方便大家理解，我从网上找了一张图，大家可以作为参考：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9421965317919075&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurmN7AzjyiaUFtoE8XkxicztqTrrHHcwzNYJF6ar5QOXp34pCaIO9hP9zQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CLOSE_WAIT是一种被动关闭状态，如果是SERVER主动断开的连接，那么就会在CLIENT出现CLOSE_WAIT的状态，反之同理；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常情况下，如果客户端在一次http请求完成后没有及时关闭流（tcp中的流套接字），那么超时后服务端就会主动发送关闭连接的FIN，客户端没有主动关闭，所以就停留在了CLOSE_WAIT状态，如果是这种情况，很快连接池中的连接就会被耗尽。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以，我们今天遇到的情况（处于CLOSE_WAIT状态的连接数每天都在缓慢增长），更像是某一种异常场景导致的连接没有关闭。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.4 独立连接池&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;为了不影响其他业务场景，防止出现系统性风险，我们先把问题接口连接池进行了独立管理。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.5 深入分析&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;带着2.3的疑问我们仔细查看一下业务调用代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        httpResponse = HttpsClientUtil.getHttpClient().execute(request);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HttpEntity httpEntity = httpResponse.getEntity();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; = httpEntity.getContent();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        log.error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        IOUtils.closeQuietly(&lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        IOUtils.closeQuietly(httpResponse);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这段代码存在一个明显的问题：既关闭了数据传输流（ &lt;strong&gt;IOUtils.closeQuietly(is)&lt;/strong&gt;），也关闭了整个连接（&lt;strong&gt;IOUtils.closeQuietly(httpResponse)&lt;/strong&gt;），这样我们就没办法进行连接的复用了；但是却更让人疑惑了：既然每次都手动关闭了连接，为什么还会有大量CLOSE_WAIT状态的连接存在呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果问题不在业务调用代码上，那么只能是这个业务接口具有的某种特殊性导致了问题的发生；通过抓包分析发现该接口有一个明显特征：&lt;strong&gt;接口返回报文较大，平均在500KB左右&lt;/strong&gt;。那么问题就极有可能是报文过大导致了某种异常，造成了连接不能被复用也不能被释放。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.6 源码分析&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;开始分析之前，我们需要了解一个基础知识：&lt;strong&gt;Http的长连接和短连接&lt;/strong&gt;。所谓长连接就是建立起连接之后，可以复用连接多次进行数据传输；而短连接则是每次都需要重新建立连接再进行数据传输。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而通过对接口的抓包我们发现，响应头里有Connection:keep-live字样，那我们就可以重点从HttpClient对长连接的管理入手来进行代码分析。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.6.1 连接池初始化 &lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;初始化方法：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.34858188472095153&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurgicYc34WE717UibUPV4yVCHNAhacFg6wYTp3yYZjvqc9icoiazoK5GJMBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1093&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;进入PoolingHttpClientConnectionManager这个类，有一个重载构造方法里包含连接存活时间参数：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3196060877350045&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurC6OqfsAVkL5D9fGHo9rHWSG4BUSQrKc8xVYF3CjLyy1e9WWK5oQgvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1117&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;顺着继续向下查看：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.46895787139689576&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurm7jCw5QEbfKRbuZTJGTK5fcBiblMmoS1wpCNicj1MLgHDnMqz8DWicEyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;manager的构造方法到此结束，我们不难发现validityDeadline会被赋值给expiry变量，那我们接下来就要看下HttpClient是在哪里使用expiry这个参数的；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常情况下，实例对象被构建出来的时候会初始化一些策略参数，此时我们需要查看构建HttpClient实例的方法来寻找答案：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.11466666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurguib85JMT1FoQJrzVVEFQCzmlqUibrs0m8icCG4OwLeCWjicaXmFkMa0CA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此方法包含一系列的初始化操作，包括构建连接池，给连接池设置最大连接数，指定重用策略和长连接策略等，这里我们还注意到，HttpClient创建了一个异步线程，去监听清理空闲连接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然，前提是你打开了自动清理空闲连接的配置，默认是关闭的。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2563667232597623&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEuriaEuLwJ3Q1WibQ00m2J7AibBicMkL8rHwBmAVG6bOvtyB1YBapZWIC5GeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5612612612612613&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEure8ICZ1KxwqgdWsKlkEn3F1OS4zQOPlXQiaTAOIA2wfP1nqWQSPcXF2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1110&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;接着我们就看到了HttpClient关闭空闲连接的具体实现，里面有我们想要看到的内容：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4912485414235706&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurwuhoSNyTCggvjvw5G0CEttazzoMg2nZpqmOazn3uVBl7icuM1Jk1L3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;857&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4619750283768445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurdFeW0kXNnWScCMdb53wEMZ7Y3dprGMtb04icCeYgPWvYkJnI1soLmQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;881&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;此时，我们可以得出第一个结论：可以在初始化连接池的时候，通过实现带参的PoolingHttpClientConnectionManager构造方法，修改validityDeadline的值，从而影响HttpClient对长连接的管理策略。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.6.2 执行方法入口&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;先找到执行入口方法：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;org.apache.http.impl.execchain.MainClientExec.execute,看到了keepalive相关代码实现：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4505154639175258&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurzZJSgpM42fIsILUE61hkWpFU1Jfpplk5FkLSsib5c9R9Fic0zIp5EfFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;我们来看下默认的策略：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42618110236220474&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurYTTxCxpb6XRBvylo2UiaxFLwWqHQXtyD5RKewQDSC4XVEkgU5B6aXWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3185437997724687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurfdsPe1VoiaWTNDB6C8reVGibnz6N1DS2ojVoOjxFDsmmJV6Cfg7mbwibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;879&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;由于中间的调用逻辑比较简单，就不在这里一一把调用的链路贴出来了，这边直接给结论：HttpClient对没有指定连接有效时间的长连接，有效期设置为永久（Long.MAX_VALUE）。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;综合以上分析,我们可以得出最终结论：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HttpClient通过控制newExpiry和validityDeadline来实现对长连接的有效期的管理，而且对没有指定连接有效时间的长连接，有效期设置为永久。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至此我们可以大胆给出一个猜测：长连接的有效期是永久，而因为某种异常导致长连接没有被及时关闭，而永久存活了下来，不能被复用也不能被释放。（只是根据现象的猜测，虽然最后被证实并不完全正确，但确实提高了我们解决问题的效率）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于此，我们也可以通过改变这两个参数来实现对长连接的管理：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurL0uJGdtayaWSCLh0v04xMqK4cqXhZX4jDC8uwh6ZV2W5d7ftt8S85g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;这样简单修改上线后，处于close_wait状态的连接数没有再持续增长，这个线上问题也算是得到了彻底的解决。&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;但此时相信大家也都存在一个疑问：作为被广泛使用的开源框架，HttpClient难道对长连接的管理这么粗糙吗？一个简单的异常调用就能导致整个调度机制彻底崩溃，而且不会自行恢复；&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;于是带着疑问，再一次详细查看了HttpClient的源码。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、关于HttpClient&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.1 前言&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;开始分析之前，先简单介绍下几个核心类：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;【PoolingHttpClientConnectionManager】&lt;/strong&gt;：连接池管理器类，主要作用是管理连接和连接池，封装连接的创建、状态流转以及连接池的相关操作，是操作连接和连接池的入口方法；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;【CPool】&lt;/strong&gt;：连接池的具体实现类，连接和连接池的具体实现均在CPool以及抽象类AbstractConnPool中实现，也是分析的重点；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;【CPoolEntry】&lt;/strong&gt;：具体的连接封装类，包含连接的一些基础属性和基础操作，比如连接id，创建时间，有效期等；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;【HttpClientBuilder】&lt;/strong&gt;：HttpClient的构造器，重点关注build方法；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;【MainClientExec】&lt;/strong&gt;：客户端请求的执行类，是执行的入口，重点关注execute方法；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;【ConnectionHolder】&lt;/strong&gt;：主要封装释放连接的方法，是在PoolingHttpClientConnectionManager的基础上进行了封装。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.2 两个连接&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;最大连接数（maxTotal）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最大单路由连接数(maxPerRoute)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.3 三个超时&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;connectionRequestTimout&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;connetionTimeout&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;socketTimeout&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【connectionRequestTimout】：&lt;/strong&gt;指从连接池获取连接的超时时间；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【connetionTimeout】&lt;/strong&gt;：指客户端和服务器建立连接的超时时间，超时后会报&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ConnectionTimeOutException异常；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【socketTimeout】&lt;/strong&gt;：指客户端和服务器建立连接后，数据传输过程中数据包之间间隔的最大时间，超出后会抛出SocketTimeOutException。&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一定要注意：这里的超时不是数据传输完成，而只是接收到两个数据包的间隔时间，这也是很多线上诡异问题发生的根本原因。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.4 四个容器&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;free&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;leased&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;pending&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;available&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;【free】：&lt;/strong&gt;空闲连接的容器，连接还没有建立，理论上freeSize=maxTotal -leasedSize&lt;/p&gt;&lt;p&gt;- availableSize（其实HttpClient中并没有该容器，只是为了描述方便，特意引入的一个容器）。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;【leased】&lt;/strong&gt;：租赁连接的容器，连接创建后，会从free容器转移到leased容器；也可以直接从available容器租赁连接，租赁成功后连接被放在leased容器中，此种场景主要是连接的复用，也是连接池的一个很重要的能力。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;【pending】&lt;/strong&gt;：等待连接的容器，其实该容器只是在等待连接释放的时候用作阻塞线程，下文也不会再提到，感兴趣的可以参考具体实现代码，其与connectionRequestTimout相关。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;【available】&lt;/strong&gt;：可复用连接的容器，通常直接从leased容器转移过来，长连接的情况下完成通信后，会把连接放到available列表，一些对连接的管理和释放通常都是围绕该容器进行的。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;注：由于存在maxTotal和maxPerRoute两个连接数限制，下文在提到这四种容器时，如果没有带前缀，都代表是总连接数，如果是r.xxxx则代表是路由连接里的某个容器大小。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0042105263157894&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurC3HeZcR5MsEUpEyWsOpUSsd9D1LENvJxs6mbcC3VmoeAe879d0d2lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;475&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;maxTotal的组成&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.5 连接的产生与管理&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;循环从available容器中获取连接，如果该连接未失效（根据上文提到的expiry字段判断），则把该连接从available容器中删除，并添加到leased容器，并返回该连接；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果在第一步中没有获取到可用连接，则判断r.available + r.leased是否大于maxPerRoute，其实就是判断是否还有free连接；如果不存在，则需要把多余分配的连接释放掉（r. available + r.leased - maxPerRoute），来保证真实的连接数受maxPerRoute控制（至于为什么会出现r.leased+r.available&amp;gt;maxPerRoute的情况其实也很好理解，虽然在整个状态流转过程都加了锁，但是状态的流转并不是原子操作，存在一些异常的场景都会导致状态短时间不正确）；所以我们可以得出结论，maxPerRoute只是一个理论上的最大数值，其实真实产生的连接数在短时间内是可能大于这个值的；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在真实的连接数（r .leased+ r .available）小于maxPerRoute且maxTotal&amp;gt;leased的情况下：如果free&amp;gt;0，则重新创建一个连接；如果free=0，则把available容器里的最早创建的一个连接关闭掉，然后再重新创建一个连接；看起来有点绕，其实就是优先使用free容器里的连接，获取不到再释放available容器里的连接；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果经过上述过程仍然没有获取到可用连接，那就只能等待一个connectionRequestTimout时间，或者有其他线程的信号通知来结束整个获取连接的过程。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5846599131693198&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurcZYcQJNpQsQiaCFleT0d1ByYqpdaZDZ2060fJ7vAe98xfeXa5h2FickQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.6 连接的释放&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;如果是长连接（reusable），则把该连接从leased容器中删除，然后添加到available容器的头部，设置有效期为expiry；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果是短连接（non-reusable），则直接关闭该连接，并且从released容器中删除，此时的连接被释放，处于free容器中；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最后，唤醒“连接的产生与管理“第四部中的等待线程。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;整个过程分析完，了解了httpclient如何管理连接，再回头来看我们遇到的那个问题就比较清晰了：&lt;/p&gt;&lt;p&gt;正常情况下，虽然建立了长连接，但是我们会在finally代码块里去手动关闭，此场景其实是触发了“&lt;strong&gt;连接的释放&lt;/strong&gt;”中的步骤2，连接直接被关闭；所以正常情况下是没有问题的，长连接其实并没有发挥真正的作用；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那问题自然就只能出现在一些异常场景，导致了长连接没有被及时关闭，结合最初的分析，是服务端主动断开了连接，那大概率出现在一些超时导致连接断开的异常场景，我们再回到&lt;/p&gt;&lt;p&gt;org.apache.http.impl.execchain.MainClientExec这个类，发现这样几行代码：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.20460358056265984&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurZNq2RrNovs9aJIUMxNf36LsSBr2Yw4n0R5eibYZIjsvGZX4brliaZXMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;782&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;connHolder.releaseConnection()&lt;/strong&gt;对应“&lt;strong&gt;连接的释放&lt;/strong&gt;”中提到的步骤1，此时连接只是被放入了available容器，并且有效期是永久；&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;return new HttpResponseProxy(response, null)&lt;/strong&gt;返回的ConnectionHolder是null，结合IOUtils.closeQuietly(httpResponse)的具体实现，连接并没有及时关闭，而是永久的放在了available容器里，并且状态为CLOSE_WAIT，无法被复用；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3257261410788382&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEury97ZSUqBu8yZIdicKIA686T3XH6UT9hxMbCCP88XKMCDLEclbrYXgDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;482&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;根据 “&lt;strong&gt;连接的产生与管理&lt;/strong&gt;”的步骤3的描述，在free容器为空的时候httpclient是能够主动释放available里的连接的，即使连接永久的放在了available容器里，理论上也不会造成连接永远无法释放；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然而再结合“&lt;strong&gt;连接的产生与管理&lt;/strong&gt;”的步骤4，当free容器为空了以后，从连接池获取连接时需要等待available容器里的连接被释放掉，整个过程是单线程的，效率极低，势必会造成拥堵，最终导致大量等待获取连接超时报错，这也与我们线上看到的场景相吻合。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;连接池的主要功能有两个：连接的管理和连接的复用，在使用连接池的时候一定要注意只需关闭当前数据流，而不要每次都关闭连接，除非你的目标访问地址是完全随机的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;maxTotal和maxPerRoute的设置一定要谨慎，合理的分配参数可以做到业务隔离，但如果无法准确做出评估，可以暂时设置成一样，或者用两个独立的httpclient实例；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一定记得要设置长连接的有效期，用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PoolingHttpClientConnectionManager(60, TimeUnit.SECONDS)构造函数，尤其是调用量较大的情况，防止发生不可预知的问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以通过设置evictIdleConnections(5, TimeUnit.SECONDS)定时清理空闲连接，尤其是http接口响应时间短，并发量大的情况下，及时清理空闲连接，避免从连接池获取连接的时候发现连接过期再去关闭连接，能在一定程度上提高接口性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、写在最后&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;HttpClient作为当前使用最广泛的基于Java语言的Http调用框架，在笔者看来其存在两点明显不足：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;没有提供监控连接状态的入口，也没有提供能外部介入动态影响连接生命周期的扩展点，一旦线上出现问题可能就是致命的；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;此外，其获取连接的方式是采用同步锁的方式，在并发较高的情况下存在一定的性能瓶颈，而且其对长连接的管理方式存在问题，稍不注意就会导致建立大量异常长连接而无法及时释放，造成系统性灾难。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:154.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3330030ab6746955a35dcb9e6c37d10d</guid>
<title>从内核角度来看网络 IO 模型的演变，以及 Netty 中的 IO 线程模型</title>
<link>https://toutiao.io/k/z1sn4ob</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从今天开始我们来聊聊Netty的那些事儿，我们都知道Netty是一个高性能异步事件驱动的网络框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的设计异常优雅简洁，扩展性高，稳定性强。拥有非常详细完整的用户文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时内置了很多非常有用的模块基本上做到了开箱即用，用户只需要编写短短几行代码，就可以快速构建出一个具有&lt;code&gt;高吞吐&lt;/code&gt;，&lt;code&gt;低延时&lt;/code&gt;，&lt;code&gt;更少的资源消耗&lt;/code&gt;，&lt;code&gt;高性能（非必要的内存拷贝最小化）&lt;/code&gt;等特征的高并发网络应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们来探讨下支持Netty具有&lt;code&gt;高吞吐&lt;/code&gt;，&lt;code&gt;低延时&lt;/code&gt;特征的基石----netty的&lt;code&gt;网络IO模型&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由Netty的&lt;code&gt;网络IO模型&lt;/code&gt;开始，我们来正式揭开本系列Netty源码解析的序幕：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网络包接收流程&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8943548387096775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEAVqTQC2CLFPicUHhicvVfVnFGUOEwWI1ueTic9xAtwibD0iaGVmSMxkuJcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;网络包收发过程.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当&lt;code&gt;网络数据帧&lt;/code&gt;通过网络传输到达网卡时，网卡会将网络数据帧通过&lt;code&gt;DMA的方式&lt;/code&gt;放到&lt;code&gt;环形缓冲区RingBuffer&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;RingBuffer&lt;/code&gt;是网卡在启动的时候&lt;code&gt;分配和初始化&lt;/code&gt;的&lt;code&gt;环形缓冲队列&lt;/code&gt;。当&lt;code&gt;RingBuffer满&lt;/code&gt;的时候，新来的数据包就会被&lt;code&gt;丢弃&lt;/code&gt;。我们可以通过&lt;code&gt;ifconfig&lt;/code&gt;命令查看网卡收发数据包的情况。其中&lt;code&gt;overruns&lt;/code&gt;数据项表示当&lt;code&gt;RingBuffer满&lt;/code&gt;时，被&lt;code&gt;丢弃的数据包&lt;/code&gt;。如果发现出现丢包情况，可以通过&lt;code&gt;ethtool命令&lt;/code&gt;来增大RingBuffer长度。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当&lt;code&gt;DMA操作完成&lt;/code&gt;时，网卡会向CPU发起一个&lt;code&gt;硬中断&lt;/code&gt;，告诉&lt;code&gt;CPU&lt;/code&gt;有网络数据到达。CPU调用网卡驱动注册的&lt;code&gt;硬中断响应程序&lt;/code&gt;。网卡硬中断响应程序会为网络数据帧创建内核数据结构&lt;code&gt;sk_buffer&lt;/code&gt;，并将网络数据帧&lt;code&gt;拷贝&lt;/code&gt;到&lt;code&gt;sk_buffer&lt;/code&gt;中。然后发起&lt;code&gt;软中断请求&lt;/code&gt;，通知&lt;code&gt;内核&lt;/code&gt;有新的网络数据帧到达。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;sk_buff&lt;/code&gt;缓冲区，是一个维护网络帧结构的&lt;code&gt;双向链表&lt;/code&gt;，链表中的每一个元素都是一个&lt;code&gt;网络帧&lt;/code&gt;。虽然 TCP/IP 协议栈分了好几层，但上下不同层之间的传递，实际上只需要操作这个数据结构中的指针，而&lt;code&gt;无需进行数据复制&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内核线程&lt;code&gt;ksoftirqd&lt;/code&gt;发现有软中断请求到来，随后调用网卡驱动注册的&lt;code&gt;poll函数&lt;/code&gt;，&lt;code&gt;poll函数&lt;/code&gt;将&lt;code&gt;sk_buffer&lt;/code&gt;中的&lt;code&gt;网络数据包&lt;/code&gt;送到内核协议栈中注册的&lt;code&gt;ip_rcv函数&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;每个CPU&lt;/code&gt;会绑定&lt;code&gt;一个ksoftirqd&lt;/code&gt;内核线程&lt;code&gt;专门&lt;/code&gt;用来处理&lt;code&gt;软中断响应&lt;/code&gt;。2个 CPU 时，就会有 &lt;code&gt;ksoftirqd/0&lt;/code&gt; 和 &lt;code&gt;ksoftirqd/1&lt;/code&gt;这两个内核线程。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;这里有个事情需要注意下：&lt;/strong&gt; 网卡接收到数据后，当&lt;code&gt;DMA拷贝完成&lt;/code&gt;时，向CPU发出&lt;code&gt;硬中断&lt;/code&gt;，这时&lt;code&gt;哪个CPU&lt;/code&gt;上响应了这个&lt;code&gt;硬中断&lt;/code&gt;，那么在网卡&lt;code&gt;硬中断响应程序&lt;/code&gt;中发出的&lt;code&gt;软中断请求&lt;/code&gt;也会在&lt;code&gt;这个CPU绑定的ksoftirqd线程&lt;/code&gt;中响应。所以如果发现Linux软中断，CPU消耗都&lt;code&gt;集中在一个核上&lt;/code&gt;的话，那么就需要调整硬中断的&lt;code&gt;CPU亲和性&lt;/code&gt;，来将硬中断&lt;code&gt;打散&lt;/code&gt;到&lt;code&gt;不通的CPU核&lt;/code&gt;上去。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;ip_rcv函数&lt;/code&gt;中也就是上图中的&lt;code&gt;网络层&lt;/code&gt;，&lt;code&gt;取出&lt;/code&gt;数据包的&lt;code&gt;IP头&lt;/code&gt;，判断该数据包下一跳的走向，如果数据包是发送给本机的，则取出传输层的协议类型（&lt;code&gt;TCP&lt;/code&gt;或者&lt;code&gt;UDP&lt;/code&gt;)，并&lt;code&gt;去掉&lt;/code&gt;数据包的&lt;code&gt;IP头&lt;/code&gt;，将数据包交给上图中得&lt;code&gt;传输层&lt;/code&gt;处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;传输层的处理函数：&lt;code&gt;TCP协议&lt;/code&gt;对应内核协议栈中注册的&lt;code&gt;tcp_rcv函数&lt;/code&gt;，&lt;code&gt;UDP协议&lt;/code&gt;对应内核协议栈中注册的&lt;code&gt;udp_rcv函数&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当我们采用的是&lt;code&gt;TCP协议&lt;/code&gt;时，数据包到达传输层时，会在内核协议栈中的&lt;code&gt;tcp_rcv函数&lt;/code&gt;处理，在tcp_rcv函数中&lt;code&gt;去掉&lt;/code&gt;TCP头，根据&lt;code&gt;四元组（源IP，源端口，目的IP，目的端口）&lt;/code&gt;查找&lt;code&gt;对应的Socket&lt;/code&gt;，如果找到对应的Socket则将网络数据包中的传输数据拷贝到&lt;code&gt;Socket&lt;/code&gt;中的&lt;code&gt;接收缓冲区&lt;/code&gt;中。如果没有找到，则发送一个&lt;code&gt;目标不可达&lt;/code&gt;的&lt;code&gt;icmp&lt;/code&gt;包。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核在接收网络数据包时所做的工作我们就介绍完了，现在我们把视角放到应用层，当我们程序通过系统调用&lt;code&gt;read&lt;/code&gt;读取&lt;code&gt;Socket接收缓冲区&lt;/code&gt;中的数据时，如果接收缓冲区中&lt;code&gt;没有数据&lt;/code&gt;，那么应用程序就会在系统调用上&lt;code&gt;阻塞&lt;/code&gt;，直到Socket接收缓冲区&lt;code&gt;有数据&lt;/code&gt;，然后&lt;code&gt;CPU&lt;/code&gt;将&lt;code&gt;内核空间&lt;/code&gt;（Socket接收缓冲区）的数据&lt;code&gt;拷贝&lt;/code&gt;到&lt;code&gt;用户空间&lt;/code&gt;，最后系统调用&lt;code&gt;read返回&lt;/code&gt;，应用程序&lt;code&gt;读取&lt;/code&gt;数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;性能开销&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从内核处理网络数据包接收的整个过程来看，内核帮我们做了非常之多的工作，最终我们的应用程序才能读取到网络数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着而来的也带来了很多的性能开销，结合前面介绍的网络数据包接收过程我们来看下网络数据包接收的过程中都有哪些性能开销：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;应用程序通过&lt;code&gt;系统调用&lt;/code&gt;从&lt;code&gt;用户态&lt;/code&gt;转为&lt;code&gt;内核态&lt;/code&gt;的开销以及系统调用&lt;code&gt;返回&lt;/code&gt;时从&lt;code&gt;内核态&lt;/code&gt;转为&lt;code&gt;用户态&lt;/code&gt;的开销。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网络数据从&lt;code&gt;内核空间&lt;/code&gt;通过&lt;code&gt;CPU拷贝&lt;/code&gt;到&lt;code&gt;用户空间&lt;/code&gt;的开销。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内核线程&lt;code&gt;ksoftirqd&lt;/code&gt;响应&lt;code&gt;软中断&lt;/code&gt;的开销。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;CPU&lt;/code&gt;响应&lt;code&gt;硬中断&lt;/code&gt;的开销。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;DMA拷贝&lt;/code&gt;网络数据包到&lt;code&gt;内存&lt;/code&gt;中的开销。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网络包发送流程&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.117741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEUK82351HYuWhJCicKvej94Cico9gLw6PJFPQBzmSibCplZAJXLoTz9O7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;网络包发送过程.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当我们在应用程序中调用&lt;code&gt;send&lt;/code&gt;系统调用发送数据时，由于是系统调用所以线程会发生一次用户态到内核态的转换，在内核中首先根据&lt;code&gt;fd&lt;/code&gt;将真正的Socket找出，这个Socket对象中记录着各种协议栈的函数地址，然后构造&lt;code&gt;struct msghdr&lt;/code&gt;对象，将用户需要发送的数据全部封装在这个&lt;code&gt;struct msghdr&lt;/code&gt;结构体中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;调用内核协议栈函数&lt;code&gt;inet_sendmsg&lt;/code&gt;，发送流程进入内核协议栈处理。在进入到内核协议栈之后，内核会找到Socket上的具体协议的发送函数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如：我们使用的是&lt;code&gt;TCP协议&lt;/code&gt;，对应的&lt;code&gt;TCP协议&lt;/code&gt;发送函数是&lt;code&gt;tcp_sendmsg&lt;/code&gt;，如果是&lt;code&gt;UDP协议&lt;/code&gt;的话，对应的发送函数为&lt;code&gt;udp_sendmsg&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;TCP协议&lt;/code&gt;的发送函数&lt;code&gt;tcp_sendmsg&lt;/code&gt;中，创建内核数据结构&lt;code&gt;sk_buffer&lt;/code&gt;,将&lt;code&gt;struct msghdr&lt;/code&gt;结构体中的发送数据&lt;code&gt;拷贝&lt;/code&gt;到&lt;code&gt;sk_buffer&lt;/code&gt;中。调用&lt;code&gt;tcp_write_queue_tail&lt;/code&gt;函数获取&lt;code&gt;Socket&lt;/code&gt;发送队列中的队尾元素，将新创建的&lt;code&gt;sk_buffer&lt;/code&gt;添加到&lt;code&gt;Socket&lt;/code&gt;发送队列的尾部。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;的发送队列是由&lt;code&gt;sk_buffer&lt;/code&gt;组成的一个&lt;code&gt;双向链表&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;发送流程走到这里，用户要发送的数据总算是从&lt;code&gt;用户空间&lt;/code&gt;拷贝到了&lt;code&gt;内核&lt;/code&gt;中，这时虽然发送数据已经&lt;code&gt;拷贝&lt;/code&gt;到了内核&lt;code&gt;Socket&lt;/code&gt;中的&lt;code&gt;发送队列&lt;/code&gt;中，但并不代表内核会开始发送，因为&lt;code&gt;TCP协议&lt;/code&gt;的&lt;code&gt;流量控制&lt;/code&gt;和&lt;code&gt;拥塞控制&lt;/code&gt;，用户要发送的数据包&lt;code&gt;并不一定&lt;/code&gt;会立马被发送出去，需要符合&lt;code&gt;TCP协议&lt;/code&gt;的发送条件。如果&lt;code&gt;没有达到发送条件&lt;/code&gt;，那么本次&lt;code&gt;send&lt;/code&gt;系统调用就会直接返回。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果符合发送条件，则开始调用&lt;code&gt;tcp_write_xmit&lt;/code&gt;内核函数。在这个函数中，会循环获取&lt;code&gt;Socket&lt;/code&gt;发送队列中待发送的&lt;code&gt;sk_buffer&lt;/code&gt;，然后进行&lt;code&gt;拥塞控制&lt;/code&gt;以及&lt;code&gt;滑动窗口的管理&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将从&lt;code&gt;Socket&lt;/code&gt;发送队列中获取到的&lt;code&gt;sk_buffer&lt;/code&gt;重新&lt;code&gt;拷贝一份&lt;/code&gt;，设置&lt;code&gt;sk_buffer副本&lt;/code&gt;中的&lt;code&gt;TCP HEADER&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;sk_buffer&lt;/code&gt; 内部其实包含了网络协议中所有的 &lt;code&gt;header&lt;/code&gt;。在设置 &lt;code&gt;TCP HEADER&lt;/code&gt;的时候，只是把指针指向 &lt;code&gt;sk_buffer&lt;/code&gt;的合适位置。后面再设置 &lt;code&gt;IP HEADER&lt;/code&gt;的时候，在把指针移动一下就行，避免频繁的内存申请和拷贝，效率很高。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4112903225806452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEpYMIdLl6Jch1BmZ4hwRpDHIXJIhmKibfPeEib9Y8SDx2YzXibkVWkic3Yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;sk_buffer.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么不直接使用&lt;code&gt;Socket&lt;/code&gt;发送队列中的&lt;code&gt;sk_buffer&lt;/code&gt;而是需要拷贝一份呢？&lt;/strong&gt;因为&lt;code&gt;TCP协议&lt;/code&gt;是支持&lt;code&gt;丢包重传&lt;/code&gt;的，在没有收到对端的&lt;code&gt;ACK&lt;/code&gt;之前，这个&lt;code&gt;sk_buffer&lt;/code&gt;是不能删除的。内核每次调用网卡发送数据的时候，实际上传递的是&lt;code&gt;sk_buffer&lt;/code&gt;的&lt;code&gt;拷贝副本&lt;/code&gt;，当网卡把数据发送出去后，&lt;code&gt;sk_buffer&lt;/code&gt;拷贝副本会被释放。当收到对端的&lt;code&gt;ACK&lt;/code&gt;之后，&lt;code&gt;Socket&lt;/code&gt;发送队列中的&lt;code&gt;sk_buffer&lt;/code&gt;才会被真正删除。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当设置完&lt;code&gt;TCP头&lt;/code&gt;后，内核协议栈&lt;code&gt;传输层&lt;/code&gt;的事情就做完了，下面通过调用&lt;code&gt;ip_queue_xmit&lt;/code&gt;内核函数，正式来到内核协议栈&lt;code&gt;网络层&lt;/code&gt;的处理。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;通过&lt;code&gt;route&lt;/code&gt;命令可以查看本机路由配置。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;如果你使用 &lt;code&gt;iptables&lt;/code&gt;配置了一些规则，那么这里将检测&lt;code&gt;是否命中&lt;/code&gt;规则。如果你设置了非常&lt;code&gt;复杂的 netfilter 规则&lt;/code&gt;，在这个函数里将会导致你的线程 &lt;code&gt;CPU 开销&lt;/code&gt;会&lt;code&gt;极大增加&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将&lt;code&gt;sk_buffer&lt;/code&gt;中的指针移动到&lt;code&gt;IP头&lt;/code&gt;位置上，设置&lt;code&gt;IP头&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行&lt;code&gt;netfilters&lt;/code&gt;过滤。过滤通过之后，如果数据大于 &lt;code&gt;MTU&lt;/code&gt;的话，则执行分片。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;检查&lt;code&gt;Socket&lt;/code&gt;中是否有缓存路由表，如果没有的话，则查找路由项，并缓存到&lt;code&gt;Socket&lt;/code&gt;中。接着在把路由表设置到&lt;code&gt;sk_buffer&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核协议栈&lt;code&gt;网络层&lt;/code&gt;的事情处理完后，现在发送流程进入了到了&lt;code&gt;邻居子系统&lt;/code&gt;，&lt;code&gt;邻居子系统&lt;/code&gt;位于内核协议栈中的&lt;code&gt;网络层&lt;/code&gt;和&lt;code&gt;网络接口层&lt;/code&gt;之间，用于发送&lt;code&gt;ARP请求&lt;/code&gt;获取&lt;code&gt;MAC地址&lt;/code&gt;，然后将&lt;code&gt;sk_buffer&lt;/code&gt;中的指针移动到&lt;code&gt;MAC头&lt;/code&gt;位置，填充&lt;code&gt;MAC头&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;经过&lt;code&gt;邻居子系统&lt;/code&gt;的处理，现在&lt;code&gt;sk_buffer&lt;/code&gt;中已经封装了一个完整的&lt;code&gt;数据帧&lt;/code&gt;，随后内核将&lt;code&gt;sk_buffer&lt;/code&gt;交给&lt;code&gt;网络设备子系统&lt;/code&gt;进行处理。&lt;code&gt;网络设备子系统&lt;/code&gt;主要做以下几项事情：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;选择发送队列（&lt;code&gt;RingBuffer&lt;/code&gt;）。因为网卡拥有多个发送队列，所以在发送前需要选择一个发送队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将&lt;code&gt;sk_buffer&lt;/code&gt;添加到发送队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环从发送队列（&lt;code&gt;RingBuffer&lt;/code&gt;）中取出&lt;code&gt;sk_buffer&lt;/code&gt;，调用内核函数&lt;code&gt;sch_direct_xmit&lt;/code&gt;发送数据，其中会调用&lt;code&gt;网卡驱动程序&lt;/code&gt;来发送数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;以上过程全部是用户线程的内核态在执行，占用的CPU时间是系统态时间(&lt;code&gt;sy&lt;/code&gt;)，当分配给用户线程的&lt;code&gt;CPU quota&lt;/code&gt;用完的时候，会触发&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;类型的软中断，内核线程&lt;code&gt;ksoftirqd&lt;/code&gt;会响应这个软中断，并执行&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;类型的软中断注册的回调函数&lt;code&gt;net_tx_action&lt;/code&gt;，在回调函数中会执行到驱动程序函数 &lt;code&gt;dev_hard_start_xmit&lt;/code&gt;来发送数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意：当触发&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;软中断来发送数据时，后边消耗的 CPU 就都显示在 &lt;code&gt;si&lt;/code&gt;这里了，不会消耗用户进程的系统态时间（&lt;code&gt;sy&lt;/code&gt;）了。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从这里可以看到网络包的发送过程和接受过程是不同的，在介绍网络包的接受过程时，我们提到是通过触发&lt;code&gt;NET_RX_SOFTIRQ&lt;/code&gt;类型的软中断在内核线程&lt;code&gt;ksoftirqd&lt;/code&gt;中执行&lt;code&gt;内核网络协议栈&lt;/code&gt;接受数据。而在网络数据包的发送过程中是&lt;code&gt;用户线程的内核态&lt;/code&gt;在执行&lt;code&gt;内核网络协议栈&lt;/code&gt;，只有当线程的&lt;code&gt;CPU quota&lt;/code&gt;用尽时，才触发&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;软中断来发送数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在整个网络包的发送和接受过程中，&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;类型的软中断只会在发送网络包时并且当用户线程的&lt;code&gt;CPU quota&lt;/code&gt;用尽时，才会触发。剩下的接受过程中触发的软中断类型以及发送完数据触发的软中断类型均为&lt;code&gt;NET_RX_SOFTIRQ&lt;/code&gt;。所以这就是你在服务器上查看 &lt;code&gt;/proc/softirqs&lt;/code&gt;，一般 &lt;code&gt;NET_RX&lt;/code&gt;都要比 &lt;code&gt;NET_TX&lt;/code&gt;大很多的的原因。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;现在发送流程终于到了网卡真实发送数据的阶段，前边我们讲到无论是用户线程的内核态还是触发&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;类型的软中断在发送数据的时候最终会调用到网卡的驱动程序函数&lt;code&gt;dev_hard_start_xmit&lt;/code&gt;来发送数据。在网卡驱动程序函数&lt;code&gt;dev_hard_start_xmit&lt;/code&gt;中会将&lt;code&gt;sk_buffer&lt;/code&gt;映射到网卡可访问的&lt;code&gt;内存 DMA 区域&lt;/code&gt;，最终网卡驱动程序通过&lt;code&gt;DMA&lt;/code&gt;的方式将&lt;code&gt;数据帧&lt;/code&gt;通过物理网卡发送出去。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当数据发送完毕后，还有最后一项重要的工作，就是清理工作。数据发送完毕后，网卡设备会向&lt;code&gt;CPU&lt;/code&gt;发送一个硬中断，&lt;code&gt;CPU&lt;/code&gt;调用网卡驱动程序注册的&lt;code&gt;硬中断响应程序&lt;/code&gt;，在硬中断响应中触发&lt;code&gt;NET_RX_SOFTIRQ&lt;/code&gt;类型的软中断，在软中断的回调函数&lt;code&gt;igb_poll&lt;/code&gt;中清理释放 &lt;code&gt;sk_buffer&lt;/code&gt;，清理&lt;code&gt;网卡&lt;/code&gt;发送队列（&lt;code&gt;RingBuffer&lt;/code&gt;），解除 DMA 映射。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;无论&lt;code&gt;硬中断&lt;/code&gt;是因为&lt;code&gt;有数据要接收&lt;/code&gt;，还是说&lt;code&gt;发送完成通知&lt;/code&gt;，从硬中断触发的软中断都是 &lt;code&gt;NET_RX_SOFTIRQ&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里释放清理的只是&lt;code&gt;sk_buffer&lt;/code&gt;的副本，真正的&lt;code&gt;sk_buffer&lt;/code&gt;现在还是存放在&lt;code&gt;Socket&lt;/code&gt;的发送队列中。前面在&lt;code&gt;传输层&lt;/code&gt;处理的时候我们提到过，因为传输层需要&lt;code&gt;保证可靠性&lt;/code&gt;，所以 &lt;code&gt;sk_buffer&lt;/code&gt;其实还没有删除。它得等收到对方的 ACK 之后才会真正删除。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;性能开销&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们提到了在网络包接收过程中涉及到的性能开销，现在介绍完了网络包的发送过程，我们来看下在数据包发送过程中的性能开销：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;和接收数据一样，应用程序在调用&lt;code&gt;系统调用send&lt;/code&gt;的时候会从&lt;code&gt;用户态&lt;/code&gt;转为&lt;code&gt;内核态&lt;/code&gt;以及发送完数据后，&lt;code&gt;系统调用&lt;/code&gt;返回时从&lt;code&gt;内核态&lt;/code&gt;转为&lt;code&gt;用户态&lt;/code&gt;的开销。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户线程内核态&lt;code&gt;CPU quota&lt;/code&gt;用尽时触发&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;类型软中断，内核响应软中断的开销。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;网卡发送完数据，向&lt;code&gt;CPU&lt;/code&gt;发送硬中断，&lt;code&gt;CPU&lt;/code&gt;响应硬中断的开销。以及在硬中断中发送&lt;code&gt;NET_RX_SOFTIRQ&lt;/code&gt;软中断执行具体的内存清理动作。内核响应软中断的开销。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内存拷贝的开销。我们来回顾下在数据包发送的过程中都发生了哪些内存拷贝：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在内核协议栈的传输层中，&lt;code&gt;TCP协议&lt;/code&gt;对应的发送函数&lt;code&gt;tcp_sendmsg&lt;/code&gt;会申请&lt;code&gt;sk_buffer&lt;/code&gt;，将用户要发送的数据&lt;code&gt;拷贝&lt;/code&gt;到&lt;code&gt;sk_buffer&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在发送流程从传输层到网络层的时候，会&lt;code&gt;拷贝&lt;/code&gt;一个&lt;code&gt;sk_buffer副本&lt;/code&gt;出来，将这个&lt;code&gt;sk_buffer副本&lt;/code&gt;向下传递。原始&lt;code&gt;sk_buffer&lt;/code&gt;保留在&lt;code&gt;Socket&lt;/code&gt;发送队列中，等待网络对端&lt;code&gt;ACK&lt;/code&gt;，对端&lt;code&gt;ACK&lt;/code&gt;后删除&lt;code&gt;Socket&lt;/code&gt;发送队列中的&lt;code&gt;sk_buffer&lt;/code&gt;。对端没有发送&lt;code&gt;ACK&lt;/code&gt;，则重新从&lt;code&gt;Socket&lt;/code&gt;发送队列中发送，实现&lt;code&gt;TCP协议&lt;/code&gt;的可靠传输。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在网络层，如果发现要发送的数据大于&lt;code&gt;MTU&lt;/code&gt;，则会进行分片操作，申请额外的&lt;code&gt;sk_buffer&lt;/code&gt;，并将原来的sk_buffer&lt;code&gt;拷贝&lt;/code&gt;到多个小的sk_buffer中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;再谈(阻塞，非阻塞)与(同步，异步)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们聊完网络数据的接收和发送过程后，我们来谈下IO中特别容易混淆的概念：&lt;code&gt;阻塞与同步&lt;/code&gt;，&lt;code&gt;非阻塞与异步&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上各种博文还有各种书籍中有大量的关于这两个概念的解释，但是笔者觉得还是不够形象化，只是对概念的生硬解释，如果硬套概念的话，其实感觉&lt;code&gt;阻塞与同步&lt;/code&gt;，&lt;code&gt;非阻塞与异步&lt;/code&gt;还是没啥区别，时间长了，还是比较模糊容易混淆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以笔者在这里尝试换一种更加形象化，更加容易理解记忆的方式来清晰地解释下什么是&lt;code&gt;阻塞与非阻塞&lt;/code&gt;，什么是&lt;code&gt;同步与异步&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过前边对网络数据包接收流程的介绍，在这里我们可以将整个流程总结为两个阶段：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7629032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEgwcdMwZya6aIFeslTuyUGGUtLgBnkQhrP9GhxRPMxNvG3TmKxFG5bQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;数据接收阶段.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;数据准备阶段：&lt;/strong&gt; 在这个阶段，网络数据包到达网卡，通过&lt;code&gt;DMA&lt;/code&gt;的方式将数据包拷贝到内存中，然后经过硬中断，软中断，接着通过内核线程&lt;code&gt;ksoftirqd&lt;/code&gt;经过内核协议栈的处理，最终将数据发送到&lt;code&gt;内核Socket&lt;/code&gt;的接收缓冲区中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;数据拷贝阶段：&lt;/strong&gt; 当数据到达&lt;code&gt;内核Socket&lt;/code&gt;的接收缓冲区中时，此时数据存在于&lt;code&gt;内核空间&lt;/code&gt;中，需要将数据&lt;code&gt;拷贝&lt;/code&gt;到&lt;code&gt;用户空间&lt;/code&gt;中，才能够被应用程序读取。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;阻塞与非阻塞&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阻塞与非阻塞的区别主要发生在第一阶段：&lt;code&gt;数据准备阶段&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当应用程序发起&lt;code&gt;系统调用read&lt;/code&gt;时，线程从用户态转为内核态，读取内核&lt;code&gt;Socket&lt;/code&gt;的接收缓冲区中的网络数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;阻塞&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这时内核&lt;code&gt;Socket&lt;/code&gt;的接收缓冲区没有数据，那么线程就会一直&lt;code&gt;等待&lt;/code&gt;，直到&lt;code&gt;Socket&lt;/code&gt;接收缓冲区有数据为止。随后将数据从内核空间拷贝到用户空间，&lt;code&gt;系统调用read&lt;/code&gt;返回。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6959677419354838&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcE59KUqV0jGMaO1RzueavdIWFn5lpNicVTss7vF5OvdChgR3zjtbGcgzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;阻塞IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看出：&lt;strong&gt;阻塞&lt;/strong&gt;的特点是在第一阶段和第二阶段&lt;code&gt;都会等待&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非阻塞&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;阻塞&lt;/code&gt;和&lt;code&gt;非阻塞&lt;/code&gt;主要的区分是在第一阶段：&lt;code&gt;数据准备阶段&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在第一阶段，当&lt;code&gt;Socket&lt;/code&gt;的接收缓冲区中没有数据的时候，&lt;code&gt;阻塞模式下&lt;/code&gt;应用线程会一直等待。&lt;code&gt;非阻塞模式下&lt;/code&gt;应用线程不会等待，&lt;code&gt;系统调用&lt;/code&gt;直接返回错误标志&lt;code&gt;EWOULDBLOCK&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当&lt;code&gt;Socket&lt;/code&gt;的接收缓冲区中有数据的时候，&lt;code&gt;阻塞&lt;/code&gt;和&lt;code&gt;非阻塞&lt;/code&gt;的表现是一样的，都会进入第二阶段&lt;code&gt;等待&lt;/code&gt;数据从&lt;code&gt;内核空间&lt;/code&gt;拷贝到&lt;code&gt;用户空间&lt;/code&gt;，然后&lt;code&gt;系统调用返回&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7483870967741936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcERxuxKJvM0hOVl9fGVF4uP3b5iasjyBg7AQPjwbc9O3w5MjtiaRYM9URQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;非阻塞IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图中，我们可以看出：&lt;strong&gt;非阻塞&lt;/strong&gt;的特点是第一阶段&lt;code&gt;不会等待&lt;/code&gt;，但是在第二阶段还是会&lt;code&gt;等待&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;同步与异步&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;同步&lt;/code&gt;与&lt;code&gt;异步&lt;/code&gt;主要的区别发生在第二阶段：&lt;code&gt;数据拷贝阶段&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们提到在&lt;code&gt;数据拷贝阶段&lt;/code&gt;主要是将数据从&lt;code&gt;内核空间&lt;/code&gt;拷贝到&lt;code&gt;用户空间&lt;/code&gt;。然后应用程序才可以读取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当内核&lt;code&gt;Socket&lt;/code&gt;的接收缓冲区有数据到达时，进入第二阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;同步&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;同步模式&lt;/code&gt;在数据准备好后，是由&lt;code&gt;用户线程&lt;/code&gt;的&lt;code&gt;内核态&lt;/code&gt;来执行&lt;code&gt;第二阶段&lt;/code&gt;。所以应用程序会在第二阶段发生&lt;code&gt;阻塞&lt;/code&gt;，直到数据从&lt;code&gt;内核空间&lt;/code&gt;拷贝到&lt;code&gt;用户空间&lt;/code&gt;，系统调用才会返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux下的 &lt;code&gt;epoll&lt;/code&gt;和Mac 下的 &lt;code&gt;kqueue&lt;/code&gt;都属于&lt;code&gt;同步 IO&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7532258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEjEQDIAtT2cuNI4aaW1NtREspTEhdh4opJ4bqvamfRm0PAVMC8TjKuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;同步IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;异步&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;异步模式&lt;/code&gt;下是由&lt;code&gt;内核&lt;/code&gt;来执行第二阶段的数据拷贝操作，当&lt;code&gt;内核&lt;/code&gt;执行完第二阶段，会通知用户线程IO操作已经完成，并将数据回调给用户线程。所以在&lt;code&gt;异步模式&lt;/code&gt;下 &lt;code&gt;数据准备阶段&lt;/code&gt;和&lt;code&gt;数据拷贝阶段&lt;/code&gt;均是由&lt;code&gt;内核&lt;/code&gt;来完成，不会对应用程序造成任何阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上特征，我们可以看到&lt;code&gt;异步模式&lt;/code&gt;需要内核的支持，比较依赖操作系统底层的支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在目前流行的操作系统中，只有Windows 中的 &lt;code&gt;IOCP&lt;/code&gt;才真正属于异步 IO，实现的也非常成熟。但Windows很少用来作为服务器使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而常用来作为服务器使用的Linux，&lt;code&gt;异步IO机制&lt;/code&gt;实现的不够成熟，与NIO相比性能提升的也不够明显。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但Linux kernel 在5.1版本由Facebook的大神Jens Axboe引入了新的异步IO库&lt;code&gt;io_uring&lt;/code&gt; 改善了原来Linux native AIO的一些性能问题。性能相比&lt;code&gt;Epoll&lt;/code&gt;以及之前原生的&lt;code&gt;AIO&lt;/code&gt;提高了不少，值得关注。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7532258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEgH4TCcSV12UCRFeMUEunGcgFdUG9nZLq2AQ9QjnuQpzpJuKHMTus8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;异步IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IO模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进行网络IO操作时，用什么样的IO模型来读写数据将在很大程度上决定了网络框架的IO性能。所以IO模型的选择是构建一个高性能网络框架的基础。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在《UNIX 网络编程》一书中介绍了五种IO模型：&lt;code&gt;阻塞IO&lt;/code&gt;,&lt;code&gt;非阻塞IO&lt;/code&gt;,&lt;code&gt;IO多路复用&lt;/code&gt;,&lt;code&gt;信号驱动IO&lt;/code&gt;,&lt;code&gt;异步IO&lt;/code&gt;，每一种IO模型的出现都是对前一种的升级优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就来分别介绍下这五种IO模型各自都解决了什么问题，适用于哪些场景，各自的优缺点是什么？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;阻塞IO（BIO）&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6959677419354838&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcE59KUqV0jGMaO1RzueavdIWFn5lpNicVTss7vF5OvdChgR3zjtbGcgzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;阻塞IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过前一小节对&lt;code&gt;阻塞&lt;/code&gt;这个概念的介绍，相信大家可以很容易理解&lt;code&gt;阻塞IO&lt;/code&gt;的概念和过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然这小节我们谈的是&lt;code&gt;IO&lt;/code&gt;，那么下边我们来看下在&lt;code&gt;阻塞IO&lt;/code&gt;模型下，网络数据的读写过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;阻塞读&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户线程发起&lt;code&gt;read&lt;/code&gt;系统调用，用户线程从用户态切换到内核态，在内核中去查看&lt;code&gt;Socket&lt;/code&gt;接收缓冲区是否有数据到来。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;接收缓冲区中&lt;code&gt;有数据&lt;/code&gt;，则用户线程在内核态将内核空间中的数据拷贝到用户空间，系统IO调用返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;接收缓冲区中&lt;code&gt;无数据&lt;/code&gt;，则用户线程让出CPU，进入&lt;code&gt;阻塞状态&lt;/code&gt;。当数据到达&lt;code&gt;Socket&lt;/code&gt;接收缓冲区后，内核唤醒&lt;code&gt;阻塞状态&lt;/code&gt;中的用户线程进入&lt;code&gt;就绪状态&lt;/code&gt;，随后经过CPU的调度获取到&lt;code&gt;CPU quota&lt;/code&gt;进入&lt;code&gt;运行状态&lt;/code&gt;，将内核空间的数据拷贝到用户空间，随后系统调用返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;阻塞写&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户线程发起&lt;code&gt;send&lt;/code&gt;系统调用时，用户线程从用户态切换到内核态，将发送数据从用户空间拷贝到内核空间中的&lt;code&gt;Socket&lt;/code&gt;发送缓冲区中。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当&lt;code&gt;Socket&lt;/code&gt;发送缓冲区能够容纳下发送数据时，用户线程会将全部的发送数据写入&lt;code&gt;Socket&lt;/code&gt;缓冲区，然后执行在《网络包发送流程》这小节介绍的后续流程，然后返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当&lt;code&gt;Socket&lt;/code&gt;发送缓冲区空间不够，无法容纳下全部发送数据时，用户线程让出CPU,进入&lt;code&gt;阻塞状态&lt;/code&gt;，直到&lt;code&gt;Socket&lt;/code&gt;发送缓冲区能够容纳下全部发送数据时，内核唤醒用户线程，执行后续发送流程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;阻塞IO&lt;/code&gt;模型下的写操作做事风格比较硬刚，非得要把全部的发送数据写入发送缓冲区才肯善罢甘休。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;阻塞IO模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5524193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcE15CGWNAUIdAvTbLVsusiaasD4rxcL0k8FShwAj1DguCc5cF8dPzfexA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;阻塞IO模型.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;阻塞IO&lt;/code&gt;的读写特点，所以导致在&lt;code&gt;阻塞IO&lt;/code&gt;模型下，每个请求都需要被一个独立的线程处理。一个线程在同一时刻只能与一个连接绑定。来一个请求，服务端就需要创建一个线程用来处理请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端请求的并发量突然增大时，服务端在一瞬间就会创建出大量的线程，而创建线程是需要系统资源开销的，这样一来就会一瞬间占用大量的系统资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果客户端创建好连接后，但是一直不发数据，通常大部分情况下，网络连接也&lt;code&gt;并不&lt;/code&gt;总是有数据可读，那么在空闲的这段时间内，服务端线程就会一直处于&lt;code&gt;阻塞状态&lt;/code&gt;，无法干其他的事情。CPU也&lt;code&gt;无法得到充分的发挥&lt;/code&gt;，同时还会&lt;code&gt;导致大量线程切换的开销&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;适用场景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上&lt;code&gt;阻塞IO模型&lt;/code&gt;的特点，该模型只适用于&lt;code&gt;连接数少&lt;/code&gt;，&lt;code&gt;并发度低&lt;/code&gt;的业务场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如公司内部的一些管理系统，通常请求数在100个左右，使用&lt;code&gt;阻塞IO模型&lt;/code&gt;还是非常适合的。而且性能还不输NIO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该模型在C10K之前，是普遍被采用的一种IO模型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;非阻塞IO（NIO）&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;阻塞IO模型&lt;/code&gt;最大的问题就是一个线程只能处理一个连接，如果这个连接上没有数据的话，那么这个线程就只能阻塞在系统IO调用上，不能干其他的事情。这对系统资源来说，是一种极大的浪费。同时大量的线程上下文切换，也是一个巨大的系统开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以为了解决这个问题，&lt;strong&gt;我们就需要用尽可能少的线程去处理更多的连接。&lt;/strong&gt;，&lt;code&gt;网络IO模型的演变&lt;/code&gt;也是根据这个需求来一步一步演进的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这个需求，第一种解决方案&lt;code&gt;非阻塞IO&lt;/code&gt;就出现了。我们在上一小节中介绍了&lt;code&gt;非阻塞&lt;/code&gt;的概念，现在我们来看下网络读写操作在&lt;code&gt;非阻塞IO&lt;/code&gt;下的特点：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7483870967741936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcERxuxKJvM0hOVl9fGVF4uP3b5iasjyBg7AQPjwbc9O3w5MjtiaRYM9URQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;非阻塞IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非阻塞读&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户线程发起非阻塞&lt;code&gt;read&lt;/code&gt;系统调用时，用户线程从&lt;code&gt;用户态&lt;/code&gt;转为&lt;code&gt;内核态&lt;/code&gt;，在内核中去查看&lt;code&gt;Socket&lt;/code&gt;接收缓冲区是否有数据到来。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;接收缓冲区中&lt;code&gt;无数据&lt;/code&gt;，系统调用立马返回，并带有一个 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; 或 &lt;code&gt;EAGAIN&lt;/code&gt;错误，这个阶段用户线程&lt;code&gt;不会阻塞&lt;/code&gt;，也&lt;code&gt;不会让出CPU&lt;/code&gt;，而是会继续&lt;code&gt;轮训&lt;/code&gt;直到&lt;code&gt;Socket&lt;/code&gt;接收缓冲区中有数据为止。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;接收缓冲区中&lt;code&gt;有数据&lt;/code&gt;，用户线程在&lt;code&gt;内核态&lt;/code&gt;会将&lt;code&gt;内核空间&lt;/code&gt;中的数据拷贝到&lt;code&gt;用户空间&lt;/code&gt;，&lt;strong&gt;注意&lt;/strong&gt;这个数据拷贝阶段，应用程序是&lt;code&gt;阻塞的&lt;/code&gt;，当数据拷贝完成，系统调用返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非阻塞写&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们在介绍&lt;code&gt;阻塞写&lt;/code&gt;的时候提到&lt;code&gt;阻塞写&lt;/code&gt;的风格特别的硬朗，头比较铁非要把全部发送数据一次性都写到&lt;code&gt;Socket&lt;/code&gt;的发送缓冲区中才返回，如果发送缓冲区中没有足够的空间容纳，那么就一直阻塞死等，特别的刚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比较而言&lt;code&gt;非阻塞写&lt;/code&gt;的特点就比较佛系，当发送缓冲区中没有足够的空间容纳全部发送数据时，&lt;code&gt;非阻塞写&lt;/code&gt;的特点是&lt;code&gt;能写多少写多少&lt;/code&gt;，写不下了，就立即返回。并将写入到发送缓冲区的字节数返回给应用程序，方便用户线程不断的&lt;code&gt;轮训&lt;/code&gt;尝试将&lt;code&gt;剩下的数据&lt;/code&gt;写入发送缓冲区中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;非阻塞IO模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37338709677419357&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEZHypSu2HK3FeqU10jRnAwDEkrVZA7kbl0MWpPonZrdOWfXzcngzlvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;非阻塞IO模型.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上&lt;code&gt;非阻塞IO&lt;/code&gt;的特点，我们就不必像&lt;code&gt;阻塞IO&lt;/code&gt;那样为每个请求分配一个线程去处理连接上的读写了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以利用&lt;strong&gt;一个线程或者很少的线程&lt;/strong&gt;，去&lt;code&gt;不断地轮询&lt;/code&gt;每个&lt;code&gt;Socket&lt;/code&gt;的接收缓冲区是否有数据到达，如果没有数据，&lt;code&gt;不必阻塞&lt;/code&gt;线程，而是接着去&lt;code&gt;轮询&lt;/code&gt;下一个&lt;code&gt;Socket&lt;/code&gt;接收缓冲区，直到轮询到数据后，处理连接上的读写，或者交给业务线程池去处理，轮询线程则&lt;code&gt;继续轮询&lt;/code&gt;其他的&lt;code&gt;Socket&lt;/code&gt;接收缓冲区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一个&lt;code&gt;非阻塞IO模型&lt;/code&gt;就实现了我们在本小节开始提出的需求：&lt;strong&gt;我们需要用尽可能少的线程去处理更多的连接&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;适用场景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然&lt;code&gt;非阻塞IO模型&lt;/code&gt;与&lt;code&gt;阻塞IO模型&lt;/code&gt;相比，减少了很大一部分的资源消耗和系统开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是它仍然有很大的性能问题，因为在&lt;code&gt;非阻塞IO模型&lt;/code&gt;下，需要用户线程去&lt;code&gt;不断地&lt;/code&gt;发起&lt;code&gt;系统调用&lt;/code&gt;去轮训&lt;code&gt;Socket&lt;/code&gt;接收缓冲区，这就需要用户线程不断地从&lt;code&gt;用户态&lt;/code&gt;切换到&lt;code&gt;内核态&lt;/code&gt;，&lt;code&gt;内核态&lt;/code&gt;切换到&lt;code&gt;用户态&lt;/code&gt;。随着并发量的增大，这个上下文切换的开销也是巨大的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以单纯的&lt;code&gt;非阻塞IO&lt;/code&gt;模型还是无法适用于高并发的场景。只能适用于&lt;code&gt;C10K&lt;/code&gt;以下的场景。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IO多路复用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;非阻塞IO&lt;/code&gt;这一小节的开头，我们提到&lt;code&gt;网络IO模型&lt;/code&gt;的演变都是围绕着---&lt;strong&gt;如何用尽可能少的线程去处理更多的连接&lt;/strong&gt;这个核心需求开始展开的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节我们来谈谈&lt;code&gt;IO多路复用模型&lt;/code&gt;，那么什么是&lt;code&gt;多路&lt;/code&gt;？，什么又是&lt;code&gt;复用&lt;/code&gt;呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以这个核心需求来对这两个概念展开阐述：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;多路&lt;/strong&gt;：我们的核心需求是要用尽可能少的线程来处理尽可能多的连接，这里的&lt;code&gt;多路&lt;/code&gt;指的就是我们需要处理的众多连接。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;复用&lt;/strong&gt;：核心需求要求我们使用&lt;code&gt;尽可能少的线程&lt;/code&gt;，&lt;code&gt;尽可能少的系统开销&lt;/code&gt;去处理&lt;code&gt;尽可能多&lt;/code&gt;的连接（&lt;code&gt;多路&lt;/code&gt;），那么这里的&lt;code&gt;复用&lt;/code&gt;指的就是用&lt;code&gt;有限的资源&lt;/code&gt;，比如用一个线程或者固定数量的线程去处理众多连接上的读写事件。换句话说，在&lt;code&gt;阻塞IO模型&lt;/code&gt;中一个连接就需要分配一个独立的线程去专门处理这个连接上的读写，到了&lt;code&gt;IO多路复用模型&lt;/code&gt;中，多个连接可以&lt;code&gt;复用&lt;/code&gt;这一个独立的线程去处理这多个连接上的读写。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，&lt;code&gt;IO多路复用模型&lt;/code&gt;的概念解释清楚了，那么&lt;strong&gt;问题的关键&lt;/strong&gt;是我们如何去实现这个&lt;code&gt;复用&lt;/code&gt;，也就是如何让一个独立的线程去处理众多连接上的读写事件呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题其实在&lt;code&gt;非阻塞IO模型&lt;/code&gt;中已经给出了它的答案，在&lt;code&gt;非阻塞IO模型&lt;/code&gt;中，利用&lt;code&gt;非阻塞&lt;/code&gt;的系统IO调用去不断的轮询众多连接的&lt;code&gt;Socket&lt;/code&gt;接收缓冲区看是否有数据到来，如果有则处理，如果没有则继续轮询下一个&lt;code&gt;Socket&lt;/code&gt;。这样就达到了用一个线程去处理众多连接上的读写事件了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但是&lt;/strong&gt;&lt;code&gt;非阻塞IO模型&lt;/code&gt;最大的问题就是需要不断的发起&lt;code&gt;系统调用&lt;/code&gt;去轮询各个&lt;code&gt;Socket&lt;/code&gt;中的接收缓冲区是否有数据到来，&lt;code&gt;频繁&lt;/code&gt;的&lt;code&gt;系统调用&lt;/code&gt;随之带来了大量的上下文切换开销。随着并发量的提升，这样也会导致非常严重的性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么如何避免频繁的系统调用同时又可以实现我们的核心需求呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就需要操作系统的内核来支持这样的操作，我们可以把频繁的轮询操作交给操作系统内核来替我们完成，这样就避免了在&lt;code&gt;用户空间&lt;/code&gt;频繁的去使用系统调用来轮询所带来的性能开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如我们所想，操作系统内核也确实为我们提供了这样的功能实现，下面我们来一起看下操作系统对&lt;code&gt;IO多路复用模型&lt;/code&gt;的实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select&lt;/code&gt;是操作系统内核提供给我们使用的一个&lt;code&gt;系统调用&lt;/code&gt;，它解决了在&lt;code&gt;非阻塞IO模型&lt;/code&gt;中需要不断的发起&lt;code&gt;系统IO调用&lt;/code&gt;去轮询&lt;code&gt;各个连接上的Socket&lt;/code&gt;接收缓冲区所带来的&lt;code&gt;用户空间&lt;/code&gt;与&lt;code&gt;内核空间&lt;/code&gt;不断切换的&lt;code&gt;系统开销&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select&lt;/code&gt;系统调用将&lt;code&gt;轮询&lt;/code&gt;的操作交给了&lt;code&gt;内核&lt;/code&gt;来帮助我们完成，从而避免了在&lt;code&gt;用户空间&lt;/code&gt;不断的发起轮询所带来的的系统性能开销。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEjOYnCMt84RfZyS5JVtLyrr115wOiauU5b21IvrIsHx4ndVDryGSlfMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;select.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先用户线程在发起&lt;code&gt;select&lt;/code&gt;系统调用的时候会&lt;code&gt;阻塞&lt;/code&gt;在&lt;code&gt;select&lt;/code&gt;系统调用上。此时，用户线程从&lt;code&gt;用户态&lt;/code&gt;切换到了&lt;code&gt;内核态&lt;/code&gt;完成了一次&lt;code&gt;上下文切换&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户线程将需要监听的&lt;code&gt;Socket&lt;/code&gt;对应的文件描述符&lt;code&gt;fd&lt;/code&gt;数组通过&lt;code&gt;select&lt;/code&gt;系统调用传递给内核。此时，用户线程将&lt;code&gt;用户空间&lt;/code&gt;中的文件描述符&lt;code&gt;fd&lt;/code&gt;数组&lt;code&gt;拷贝&lt;/code&gt;到&lt;code&gt;内核空间&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;strong&gt;文件描述符数组&lt;/strong&gt;其实是一个&lt;code&gt;BitMap&lt;/code&gt;，&lt;code&gt;BitMap&lt;/code&gt;下标为&lt;code&gt;文件描述符fd&lt;/code&gt;，下标对应的值为：&lt;code&gt;1&lt;/code&gt;表示该&lt;code&gt;fd&lt;/code&gt;上有读写事件，&lt;code&gt;0&lt;/code&gt;表示该&lt;code&gt;fd&lt;/code&gt;上没有读写事件。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2709677419354839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcED7ATGgNE7Ou6uf2ef80pvzAfiaFI9EakX3FDd1icRiaiaMk5on3c0CrWdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;fd数组BitMap.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文件描述符fd&lt;/strong&gt;其实就是一个&lt;code&gt;整数值&lt;/code&gt;，在Linux中一切皆文件，&lt;code&gt;Socket&lt;/code&gt;也是一个文件。描述进程所有信息的数据结构&lt;code&gt;task_struct&lt;/code&gt;中有一个属性&lt;code&gt;struct files_struct *files&lt;/code&gt;，它最终指向了一个数组，数组里存放了进程打开的所有文件列表，文件信息封装在&lt;code&gt;struct file&lt;/code&gt;结构体中，这个数组存放的类型就是&lt;code&gt;struct file&lt;/code&gt;结构体，&lt;code&gt;数组的下标&lt;/code&gt;则是我们常说的文件描述符&lt;code&gt;fd&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当用户线程调用完&lt;code&gt;select&lt;/code&gt;后开始进入&lt;code&gt;阻塞状态&lt;/code&gt;，&lt;code&gt;内核&lt;/code&gt;开始轮询遍历&lt;code&gt;fd&lt;/code&gt;数组，查看&lt;code&gt;fd&lt;/code&gt;对应的&lt;code&gt;Socket&lt;/code&gt;接收缓冲区中是否有数据到来。如果有数据到来，则将&lt;code&gt;fd&lt;/code&gt;对应&lt;code&gt;BitMap&lt;/code&gt;的值设置为&lt;code&gt;1&lt;/code&gt;。如果没有数据到来，则保持值为&lt;code&gt;0&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;这里内核会修改原始的&lt;code&gt;fd&lt;/code&gt;数组！！&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核遍历一遍&lt;code&gt;fd&lt;/code&gt;数组后，如果发现有些&lt;code&gt;fd&lt;/code&gt;上有IO数据到来，则将修改后的&lt;code&gt;fd&lt;/code&gt;数组返回给用户线程。此时，会将&lt;code&gt;fd&lt;/code&gt;数组从&lt;code&gt;内核空间&lt;/code&gt;拷贝到&lt;code&gt;用户空间&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当内核将修改后的&lt;code&gt;fd&lt;/code&gt;数组返回给用户线程后，用户线程解除&lt;code&gt;阻塞&lt;/code&gt;，由用户线程开始遍历&lt;code&gt;fd&lt;/code&gt;数组然后找出&lt;code&gt;fd&lt;/code&gt;数组中值为&lt;code&gt;1&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;文件描述符。最后对这些&lt;code&gt;Socket&lt;/code&gt;发起系统调用读取数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;select&lt;/code&gt;不会告诉用户线程具体哪些&lt;code&gt;fd&lt;/code&gt;上有IO数据到来，只是在&lt;code&gt;IO活跃&lt;/code&gt;的&lt;code&gt;fd&lt;/code&gt;上打上标记，将打好标记的完整&lt;code&gt;fd&lt;/code&gt;数组返回给用户线程，所以用户线程还需要遍历&lt;code&gt;fd&lt;/code&gt;数组找出具体哪些&lt;code&gt;fd&lt;/code&gt;上有&lt;code&gt;IO数据&lt;/code&gt;到来。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于内核在遍历的过程中已经修改了&lt;code&gt;fd&lt;/code&gt;数组，所以在用户线程遍历完&lt;code&gt;fd&lt;/code&gt;数组后获取到&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;后，就需要&lt;code&gt;重置&lt;/code&gt;fd数组，并重新调用&lt;code&gt;select&lt;/code&gt;传入重置后的&lt;code&gt;fd&lt;/code&gt;数组，让内核发起新的一轮遍历轮询。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;API介绍&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们熟悉了&lt;code&gt;select&lt;/code&gt;的原理后，就很容易理解内核给我们提供的&lt;code&gt;select API&lt;/code&gt;了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,&lt;span&gt;const&lt;/span&gt; struct timeval *timeout)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从&lt;code&gt;select API&lt;/code&gt;中我们可以看到，&lt;code&gt;select&lt;/code&gt;系统调用是在规定的&lt;code&gt;超时时间内&lt;/code&gt;，监听（&lt;code&gt;轮询&lt;/code&gt;）用户感兴趣的文件描述符集合上的&lt;code&gt;可读&lt;/code&gt;,&lt;code&gt;可写&lt;/code&gt;,&lt;code&gt;异常&lt;/code&gt;三类事件。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;maxfdp1 ：&lt;/code&gt; select传递给内核监听的文件描述符集合中数值最大的文件描述符&lt;code&gt;+1&lt;/code&gt;，目的是用于限定内核遍历范围。比如：&lt;code&gt;select&lt;/code&gt;监听的文件描述符集合为&lt;code&gt;{0,1,2,3,4}&lt;/code&gt;，那么&lt;code&gt;maxfdp1&lt;/code&gt;的值为&lt;code&gt;5&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;fd_set *readset：&lt;/code&gt; 对&lt;code&gt;可读事件&lt;/code&gt;感兴趣的文件描述符集合。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;fd_set *writeset：&lt;/code&gt; 对&lt;code&gt;可写事件&lt;/code&gt;感兴趣的文件描述符集合。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;fd_set *exceptset：&lt;/code&gt;对&lt;code&gt;异常事件&lt;/code&gt;感兴趣的文件描述符集合。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里的&lt;code&gt;fd_set&lt;/code&gt;就是我们前边提到的&lt;code&gt;文件描述符数组&lt;/code&gt;，是一个&lt;code&gt;BitMap&lt;/code&gt;结构。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;const struct timeval *timeout：&lt;/code&gt;select系统调用超时时间，在这段时间内，内核如果没有发现有&lt;code&gt;IO就绪&lt;/code&gt;的文件描述符，就直接返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上小节提到，在&lt;code&gt;内核&lt;/code&gt;遍历完&lt;code&gt;fd&lt;/code&gt;数组后，发现有&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;fd&lt;/code&gt;，则会将该&lt;code&gt;fd&lt;/code&gt;对应的&lt;code&gt;BitMap&lt;/code&gt;中的值设置为&lt;code&gt;1&lt;/code&gt;，并将修改后的&lt;code&gt;fd&lt;/code&gt;数组，返回给用户线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用户线程中需要重新遍历&lt;code&gt;fd&lt;/code&gt;数组，找出&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;fd&lt;/code&gt;出来，然后发起真正的读写调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面介绍下在用户线程中重新遍历&lt;code&gt;fd&lt;/code&gt;数组的过程中，我们需要用到的&lt;code&gt;API&lt;/code&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;void FD_ZERO(fd_set *fdset)：&lt;/code&gt;清空指定的文件描述符集合，即让&lt;code&gt;fd_set&lt;/code&gt;中不在包含任何文件描述符。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;void FD_SET(int fd, fd_set *fdset)：&lt;/code&gt;将一个给定的文件描述符加入集合之中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每次调用&lt;code&gt;select&lt;/code&gt;之前都要通过&lt;code&gt;FD_ZERO&lt;/code&gt;和&lt;code&gt;FD_SET&lt;/code&gt;重新设置文件描述符，因为文件描述符集合会在&lt;code&gt;内核&lt;/code&gt;中&lt;code&gt;被修改&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;int FD_ISSET(int fd, fd_set *fdset)：&lt;/code&gt;检查集合中指定的文件描述符是否可以读写。用户线程&lt;code&gt;遍历&lt;/code&gt;文件描述符集合,调用该方法检查相应的文件描述符是否&lt;code&gt;IO就绪&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;void FD_CLR(int fd, fd_set *fdset)：&lt;/code&gt;将一个给定的文件描述符从集合中删除&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;性能开销&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然&lt;code&gt;select&lt;/code&gt;解决了&lt;code&gt;非阻塞IO模型&lt;/code&gt;中频繁发起&lt;code&gt;系统调用&lt;/code&gt;的问题，但是在整个&lt;code&gt;select&lt;/code&gt;工作过程中，我们还是看出了&lt;code&gt;select&lt;/code&gt;有些不足的地方。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在发起&lt;code&gt;select&lt;/code&gt;系统调用以及返回时，用户线程各发生了一次&lt;code&gt;用户态&lt;/code&gt;到&lt;code&gt;内核态&lt;/code&gt;以及&lt;code&gt;内核态&lt;/code&gt;到&lt;code&gt;用户态&lt;/code&gt;的上下文切换开销。&lt;strong&gt;发生2次上下文&lt;code&gt;切换&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在发起&lt;code&gt;select&lt;/code&gt;系统调用以及返回时，用户线程在&lt;code&gt;内核态&lt;/code&gt;需要将&lt;code&gt;文件描述符集合&lt;/code&gt;从用户空间&lt;code&gt;拷贝&lt;/code&gt;到内核空间。以及在内核修改完&lt;code&gt;文件描述符集合&lt;/code&gt;后，又要将它从内核空间&lt;code&gt;拷贝&lt;/code&gt;到用户空间。&lt;strong&gt;发生2次文件描述符集合的&lt;code&gt;拷贝&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;虽然由原来在&lt;code&gt;用户空间&lt;/code&gt;发起轮询&lt;code&gt;优化成了&lt;/code&gt;在&lt;code&gt;内核空间&lt;/code&gt;发起轮询但&lt;code&gt;select&lt;/code&gt;不会告诉用户线程到底是哪些&lt;code&gt;Socket&lt;/code&gt;上发生了&lt;code&gt;IO就绪&lt;/code&gt;事件，只是对&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;作了标记，用户线程依然要&lt;code&gt;遍历&lt;/code&gt;文件描述符集合去查找具体&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;。时间复杂度依然为&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大部分情况下，网络连接并不总是活跃的，如果&lt;code&gt;select&lt;/code&gt;监听了大量的客户端连接，只有少数的连接活跃，然而使用轮询的这种方式会随着连接数的增大，效率会越来越低。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;内核&lt;/code&gt;会对原始的&lt;code&gt;文件描述符集合&lt;/code&gt;进行修改。导致每次在用户空间重新发起&lt;code&gt;select&lt;/code&gt;调用时，都需要对&lt;code&gt;文件描述符集合&lt;/code&gt;进行&lt;code&gt;重置&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;BitMap&lt;/code&gt;结构的文件描述符集合，长度为固定的&lt;code&gt;1024&lt;/code&gt;,所以只能监听&lt;code&gt;0~1023&lt;/code&gt;的文件描述符。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;select&lt;/code&gt;系统调用 不是线程安全的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上&lt;code&gt;select&lt;/code&gt;的不足所产生的&lt;code&gt;性能开销&lt;/code&gt;都会随着并发量的增大而&lt;code&gt;线性增长&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显&lt;code&gt;select&lt;/code&gt;也不能解决&lt;code&gt;C10K&lt;/code&gt;问题，只适用于&lt;code&gt;1000&lt;/code&gt;个左右的并发连接场景。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;poll&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;poll&lt;/code&gt;相当于是改进版的&lt;code&gt;select&lt;/code&gt;，但是工作原理基本和&lt;code&gt;select&lt;/code&gt;没有本质的区别。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;poll&lt;/span&gt;&lt;span&gt;(struct pollfd *fds, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nfds, &lt;span&gt;int&lt;/span&gt; timeout)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;struct pollfd {&lt;br/&gt;    int   fd;         /* 文件描述符 */&lt;br/&gt;    short events;     /* 需要监听的事件 */&lt;br/&gt;    short revents;    /* 实际发生的事件 由内核修改设置 */&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select&lt;/code&gt;中使用的文件描述符集合是采用的固定长度为1024的&lt;code&gt;BitMap&lt;/code&gt;结构的&lt;code&gt;fd_set&lt;/code&gt;，而&lt;code&gt;poll&lt;/code&gt;换成了一个&lt;code&gt;pollfd&lt;/code&gt;结构没有固定长度的数组，这样就没有了最大描述符数量的限制（当然还会受到系统文件描述符限制）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;poll&lt;/code&gt;只是改进了&lt;code&gt;select&lt;/code&gt;只能监听&lt;code&gt;1024&lt;/code&gt;个文件描述符的数量限制，但是并没有在性能方面做出改进。和&lt;code&gt;select&lt;/code&gt;上本质并没有多大差别。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;同样需要在&lt;code&gt;内核空间&lt;/code&gt;和&lt;code&gt;用户空间&lt;/code&gt;中对文件描述符集合进行&lt;code&gt;轮询&lt;/code&gt;，查找出&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;的时间复杂度依然为&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;同样需要将&lt;code&gt;包含大量文件描述符的集合&lt;/code&gt;整体在&lt;code&gt;用户空间&lt;/code&gt;和&lt;code&gt;内核空间&lt;/code&gt;之间&lt;code&gt;来回复制&lt;/code&gt;，&lt;strong&gt;无论这些文件描述符是否就绪&lt;/strong&gt;。他们的开销都会随着文件描述符数量的增加而线性增大。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;select，poll&lt;/code&gt;在每次新增，删除需要监听的socket时，都需要将整个新的&lt;code&gt;socket&lt;/code&gt;集合全量传至&lt;code&gt;内核&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;poll&lt;/code&gt;同样不适用高并发的场景。依然无法解决&lt;code&gt;C10K&lt;/code&gt;问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;epoll&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上边对&lt;code&gt;select,poll&lt;/code&gt;核心原理的介绍，我们看到&lt;code&gt;select,poll&lt;/code&gt;的性能瓶颈主要体现在下面三个地方：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;因为内核不会保存我们要监听的&lt;code&gt;socket&lt;/code&gt;集合，所以在每次调用&lt;code&gt;select,poll&lt;/code&gt;的时候都需要传入，传出全量的&lt;code&gt;socket&lt;/code&gt;文件描述符集合。这导致了大量的文件描述符在&lt;code&gt;用户空间&lt;/code&gt;和&lt;code&gt;内核空间&lt;/code&gt;频繁的来回复制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于内核不会通知具体&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;socket&lt;/code&gt;，只是在这些&lt;code&gt;IO就绪&lt;/code&gt;的socket上打好标记，所以当&lt;code&gt;select&lt;/code&gt;系统调用返回时，在&lt;code&gt;用户空间&lt;/code&gt;还是需要&lt;code&gt;完整遍历&lt;/code&gt;一遍&lt;code&gt;socket&lt;/code&gt;文件描述符集合来获取具体&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;socket&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在&lt;code&gt;内核空间&lt;/code&gt;中也是通过遍历的方式来得到&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;socket&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下&lt;code&gt;epoll&lt;/code&gt;是如何解决这些问题的。在介绍&lt;code&gt;epoll&lt;/code&gt;的核心原理之前，我们需要介绍下理解&lt;code&gt;epoll&lt;/code&gt;工作过程所需要的一些核心基础知识。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Socket的创建&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端线程调用&lt;code&gt;accept&lt;/code&gt;系统调用后开始&lt;code&gt;阻塞&lt;/code&gt;，当有客户端连接上来并完成&lt;code&gt;TCP三次握手&lt;/code&gt;后，&lt;code&gt;内核&lt;/code&gt;会创建一个对应的&lt;code&gt;Socket&lt;/code&gt;作为服务端与客户端通信的&lt;code&gt;内核&lt;/code&gt;接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Linux内核的角度看来，一切皆是文件，&lt;code&gt;Socket&lt;/code&gt;也不例外，当内核创建出&lt;code&gt;Socket&lt;/code&gt;之后，会将这个&lt;code&gt;Socket&lt;/code&gt;放到当前进程所打开的文件列表中管理起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下进程管理这些打开的文件列表相关的内核数据结构是什么样的？在了解完这些数据结构后，我们会更加清晰的理解&lt;code&gt;Socket&lt;/code&gt;在内核中所发挥的作用。并且对后面我们理解&lt;code&gt;epoll&lt;/code&gt;的创建过程有很大的帮助。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;进程中管理文件列表结构&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48629032258064514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEDCWo05bLDqtgBwGwAPGHKNGsXCEk7O6LB3ksNKFiaU4qgPouZwQDrFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;进程中管理文件列表结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct tast_struct&lt;/code&gt;是内核中用来表示进程的一个数据结构，它包含了进程的所有信息。本小节我们只列出和文件管理相关的属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中进程内打开的所有文件是通过一个数组&lt;code&gt;fd_array&lt;/code&gt;来进行组织管理，数组的下标即为我们常提到的&lt;code&gt;文件描述符&lt;/code&gt;，数组中存放的是对应的文件数据结构&lt;code&gt;struct file&lt;/code&gt;。每打开一个文件，内核都会创建一个&lt;code&gt;struct file&lt;/code&gt;与之对应，并在&lt;code&gt;fd_array&lt;/code&gt;中找到一个空闲位置分配给它，数组中对应的下标，就是我们在&lt;code&gt;用户空间&lt;/code&gt;用到的&lt;code&gt;文件描述符&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对于任何一个进程，默认情况下，文件描述符 &lt;code&gt;0&lt;/code&gt;表示 &lt;code&gt;stdin 标准输入&lt;/code&gt;，文件描述符 &lt;code&gt;1&lt;/code&gt;表示&lt;code&gt;stdout 标准输出&lt;/code&gt;，文件描述符&lt;code&gt;2&lt;/code&gt;表示&lt;code&gt;stderr 标准错误输出&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程中打开的文件列表&lt;code&gt;fd_array&lt;/code&gt;定义在内核数据结构&lt;code&gt;struct files_struct&lt;/code&gt;中，在&lt;code&gt;struct fdtable&lt;/code&gt;结构中有一个指针&lt;code&gt;struct fd **fd&lt;/code&gt;指向&lt;code&gt;fd_array&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;由于本小节讨论的是内核网络系统部分的数据结构&lt;/strong&gt;，所以这里拿&lt;code&gt;Socket&lt;/code&gt;文件类型来举例说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于封装文件元信息的内核数据结构&lt;code&gt;struct file&lt;/code&gt;中的&lt;code&gt;private_data&lt;/code&gt;指针指向具体的&lt;code&gt;Socket&lt;/code&gt;结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct file&lt;/code&gt;中的&lt;code&gt;file_operations&lt;/code&gt;属性定义了文件的操作函数，不同的文件类型，对应的&lt;code&gt;file_operations&lt;/code&gt;是不同的，针对&lt;code&gt;Socket&lt;/code&gt;文件类型，这里的&lt;code&gt;file_operations&lt;/code&gt;指向&lt;code&gt;socket_file_ops&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们在&lt;code&gt;用户空间&lt;/code&gt;对&lt;code&gt;Socket&lt;/code&gt;发起的读写等系统调用，进入内核首先会调用的是&lt;code&gt;Socket&lt;/code&gt;对应的&lt;code&gt;struct file&lt;/code&gt;中指向的&lt;code&gt;socket_file_ops&lt;/code&gt;。&lt;strong&gt;比如&lt;/strong&gt;：对&lt;code&gt;Socket&lt;/code&gt;发起&lt;code&gt;write&lt;/code&gt;写操作，在内核中首先被调用的就是&lt;code&gt;socket_file_ops&lt;/code&gt;中定义的&lt;code&gt;sock_write_iter&lt;/code&gt;。&lt;code&gt;Socket&lt;/code&gt;发起&lt;code&gt;read&lt;/code&gt;读操作内核中对应的则是&lt;code&gt;sock_read_iter&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file_operations&lt;/span&gt; &lt;span&gt;socket_file_ops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;  .owner =  THIS_MODULE,&lt;br/&gt;  .llseek =  no_llseek,&lt;br/&gt;  .read_iter =  sock_read_iter,&lt;br/&gt;  .write_iter =  sock_write_iter,&lt;br/&gt;  .poll =    sock_poll,&lt;br/&gt;  .unlocked_ioctl = sock_ioctl,&lt;br/&gt;  .mmap =    sock_mmap,&lt;br/&gt;  .release =  sock_close,&lt;br/&gt;  .fasync =  sock_fasync,&lt;br/&gt;  .sendpage =  sock_sendpage,&lt;br/&gt;  .splice_write = generic_splice_sendpage,&lt;br/&gt;  .splice_read =  sock_splice_read,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Socket内核结构&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6056451612903225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEV2mJ5ffNML0pVxP679iapicwtrNvRLjAuPJ9EOS0J2VFDtuMicX3Lw3cQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Socket内核结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们进行网络程序的编写时会首先创建一个&lt;code&gt;Socket&lt;/code&gt;，然后基于这个&lt;code&gt;Socket&lt;/code&gt;进行&lt;code&gt;bind&lt;/code&gt;，&lt;code&gt;listen&lt;/code&gt;，我们先将这个&lt;code&gt;Socket&lt;/code&gt;称作为&lt;code&gt;监听Socket&lt;/code&gt;。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当我们调用&lt;code&gt;accept&lt;/code&gt;后，内核会基于&lt;code&gt;监听Socket&lt;/code&gt;创建出来一个新的&lt;code&gt;Socket&lt;/code&gt;专门用于与客户端之间的网络通信。并将&lt;code&gt;监听Socket&lt;/code&gt;中的&lt;code&gt;Socket操作函数集合&lt;/code&gt;（&lt;code&gt;inet_stream_ops&lt;/code&gt;）&lt;code&gt;ops&lt;/code&gt;赋值到新的&lt;code&gt;Socket&lt;/code&gt;的&lt;code&gt;ops&lt;/code&gt;属性中。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;proto_ops&lt;/span&gt; &lt;span&gt;inet_stream_ops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;  .bind = inet_bind,&lt;br/&gt;  .connect = inet_stream_connect,&lt;br/&gt;  .accept = inet_accept,&lt;br/&gt;  .poll = tcp_poll,&lt;br/&gt;  .listen = inet_listen,&lt;br/&gt;  .sendmsg = inet_sendmsg,&lt;br/&gt;  .recvmsg = inet_recvmsg,&lt;br/&gt;  ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里需要注意的是，&lt;code&gt;监听的 socket&lt;/code&gt;和真正用来网络通信的 &lt;code&gt;Socket&lt;/code&gt;，是两个 Socket，一个叫作&lt;code&gt;监听 Socket&lt;/code&gt;，一个叫作&lt;code&gt;已连接的Socket&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;接着内核会为&lt;code&gt;已连接的Socket&lt;/code&gt;创建&lt;code&gt;struct file&lt;/code&gt;并初始化，并把Socket文件操作函数集合（&lt;code&gt;socket_file_ops&lt;/code&gt;）赋值给&lt;code&gt;struct file&lt;/code&gt;中的&lt;code&gt;f_ops&lt;/code&gt;指针。然后将&lt;code&gt;struct socket&lt;/code&gt;中的&lt;code&gt;file&lt;/code&gt;指针指向这个新分配申请的&lt;code&gt;struct file&lt;/code&gt;结构体。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;内核会维护两个队列：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个是已经完成&lt;code&gt;TCP三次握手&lt;/code&gt;，连接状态处于&lt;code&gt;established&lt;/code&gt;的连接队列。内核中为&lt;code&gt;icsk_accept_queue&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个是还没有完成&lt;code&gt;TCP三次握手&lt;/code&gt;，连接状态处于&lt;code&gt;syn_rcvd&lt;/code&gt;的半连接队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;然后调用&lt;code&gt;socket-&amp;gt;ops-&amp;gt;accept&lt;/code&gt;，从&lt;code&gt;Socket内核结构图&lt;/code&gt;中我们可以看到其实调用的是&lt;code&gt;inet_accept&lt;/code&gt;，该函数会在&lt;code&gt;icsk_accept_queue&lt;/code&gt;中查找是否有已经建立好的连接，如果有的话，直接从&lt;code&gt;icsk_accept_queue&lt;/code&gt;中获取已经创建好的&lt;code&gt;struct sock&lt;/code&gt;。并将这个&lt;code&gt;struct sock&lt;/code&gt;对象赋值给&lt;code&gt;struct socket&lt;/code&gt;中的&lt;code&gt;sock&lt;/code&gt;指针。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct sock&lt;/code&gt;在&lt;code&gt;struct socket&lt;/code&gt;中是一个非常核心的内核对象，正是在这里定义了我们在介绍&lt;code&gt;网络包的接收发送流程&lt;/code&gt;中提到的&lt;code&gt;接收队列&lt;/code&gt;，&lt;code&gt;发送队列&lt;/code&gt;，&lt;code&gt;等待队列&lt;/code&gt;，&lt;code&gt;数据就绪回调函数指针&lt;/code&gt;，&lt;code&gt;内核协议栈操作函数集合&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据创建&lt;code&gt;Socket&lt;/code&gt;时发起的系统调用&lt;code&gt;sock_create&lt;/code&gt;中的&lt;code&gt;protocol&lt;/code&gt;参数(对于&lt;code&gt;TCP协议&lt;/code&gt;这里的参数值为&lt;code&gt;SOCK_STREAM&lt;/code&gt;)查找到对于 tcp 定义的操作方法实现集合 &lt;code&gt;inet_stream_ops&lt;/code&gt; 和&lt;code&gt;tcp_prot&lt;/code&gt;。并把它们分别设置到&lt;code&gt;socket-&amp;gt;ops&lt;/code&gt;和&lt;code&gt;sock-&amp;gt;sk_prot&lt;/code&gt;上。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里可以回看下本小节开头的《Socket内核结构图》捋一下他们之间的关系。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;socket&lt;/code&gt;相关的操作接口定义在&lt;code&gt;inet_stream_ops&lt;/code&gt;函数集合中，负责对上给用户提供接口。而&lt;code&gt;socket&lt;/code&gt;与内核协议栈之间的操作接口定义在&lt;code&gt;struct sock&lt;/code&gt;中的&lt;code&gt;sk_prot&lt;/code&gt;指针上，这里指向&lt;code&gt;tcp_prot&lt;/code&gt;协议操作函数集合。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;proto&lt;/span&gt; &lt;span&gt;tcp_prot&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;  .name      = &lt;span&gt;&quot;TCP&quot;&lt;/span&gt;,&lt;br/&gt;  .owner      = THIS_MODULE,&lt;br/&gt;  .close      = tcp_close,&lt;br/&gt;  .connect    = tcp_v4_connect,&lt;br/&gt;  .disconnect    = tcp_disconnect,&lt;br/&gt;  .accept      = inet_csk_accept,&lt;br/&gt;  .keepalive    = tcp_set_keepalive,&lt;br/&gt;  .recvmsg    = tcp_recvmsg,&lt;br/&gt;  .sendmsg    = tcp_sendmsg,&lt;br/&gt;  .backlog_rcv    = tcp_v4_do_rcv,&lt;br/&gt;   ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;之前提到的对&lt;code&gt;Socket&lt;/code&gt;发起的系统IO调用，在内核中首先会调用&lt;code&gt;Socket&lt;/code&gt;的文件结构&lt;code&gt;struct file&lt;/code&gt;中的&lt;code&gt;file_operations&lt;/code&gt;文件操作集合，然后调用&lt;code&gt;struct socket&lt;/code&gt;中的&lt;code&gt;ops&lt;/code&gt;指向的&lt;code&gt;inet_stream_ops&lt;/code&gt;socket操作函数，最终调用到&lt;code&gt;struct sock&lt;/code&gt;中&lt;code&gt;sk_prot&lt;/code&gt;指针指向的&lt;code&gt;tcp_prot&lt;/code&gt;内核协议栈操作函数接口集合。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5620967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEulX0vLf43hBicEqX8FejWO7Z5ru4ZyWKVmQ5gRSoLruicozQOwotH6fQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;系统IO调用结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将&lt;code&gt;struct sock&lt;/code&gt; 对象中的&lt;code&gt;sk_data_ready&lt;/code&gt; 函数指针设置为 &lt;code&gt;sock_def_readable&lt;/code&gt;，在&lt;code&gt;Socket&lt;/code&gt;数据就绪的时候内核会回调该函数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;struct sock&lt;/code&gt;中的&lt;code&gt;等待队列&lt;/code&gt;中存放的是系统IO调用发生阻塞的&lt;code&gt;进程fd&lt;/code&gt;，以及相应的&lt;code&gt;回调函数&lt;/code&gt;。&lt;strong&gt;记住这个地方，后边介绍epoll的时候我们还会提到！&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当&lt;code&gt;struct file&lt;/code&gt;，&lt;code&gt;struct socket&lt;/code&gt;，&lt;code&gt;struct sock&lt;/code&gt;这些核心的内核对象创建好之后，最后就是把&lt;code&gt;socket&lt;/code&gt;对象对应的&lt;code&gt;struct file&lt;/code&gt;放到进程打开的文件列表&lt;code&gt;fd_array&lt;/code&gt;中。随后系统调用&lt;code&gt;accept&lt;/code&gt;返回&lt;code&gt;socket&lt;/code&gt;的文件描述符&lt;code&gt;fd&lt;/code&gt;给用户程序。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;阻塞IO中用户进程阻塞以及唤醒原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边小节我们介绍&lt;code&gt;阻塞IO&lt;/code&gt;的时候提到，当用户进程发起系统IO调用时，这里我们拿&lt;code&gt;read&lt;/code&gt;举例，用户进程会在&lt;code&gt;内核态&lt;/code&gt;查看对应&lt;code&gt;Socket&lt;/code&gt;接收缓冲区是否有数据到来。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Socket&lt;/code&gt;接收缓冲区有数据，则拷贝数据到&lt;code&gt;用户空间&lt;/code&gt;，系统调用返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Socket&lt;/code&gt;接收缓冲区没有数据，则用户进程让出&lt;code&gt;CPU&lt;/code&gt;进入&lt;code&gt;阻塞状态&lt;/code&gt;，当数据到达接收缓冲区时，用户进程会被唤醒，从&lt;code&gt;阻塞状态&lt;/code&gt;进入&lt;code&gt;就绪状态&lt;/code&gt;，等待CPU调度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节我们就来看下用户进程是如何&lt;code&gt;阻塞&lt;/code&gt;在&lt;code&gt;Socket&lt;/code&gt;上，又是如何在&lt;code&gt;Socket&lt;/code&gt;上被唤醒的。&lt;strong&gt;理解这个过程很重要，对我们理解epoll的事件通知过程很有帮助&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先我们在用户进程中对&lt;code&gt;Socket&lt;/code&gt;进行&lt;code&gt;read&lt;/code&gt;系统调用时，用户进程会从&lt;code&gt;用户态&lt;/code&gt;转为&lt;code&gt;内核态&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在进程的&lt;code&gt;struct task_struct&lt;/code&gt;结构找到&lt;code&gt;fd_array&lt;/code&gt;，并根据&lt;code&gt;Socket&lt;/code&gt;的文件描述符&lt;code&gt;fd&lt;/code&gt;找到对应的&lt;code&gt;struct file&lt;/code&gt;，调用&lt;code&gt;struct file&lt;/code&gt;中的文件操作函数结合&lt;code&gt;file_operations&lt;/code&gt;，&lt;code&gt;read&lt;/code&gt;系统调用对应的是&lt;code&gt;sock_read_iter&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;sock_read_iter&lt;/code&gt;函数中找到&lt;code&gt;struct file&lt;/code&gt;指向的&lt;code&gt;struct socket&lt;/code&gt;，并调用&lt;code&gt;socket-&amp;gt;ops-&amp;gt;recvmsg&lt;/code&gt;，这里我们知道调用的是&lt;code&gt;inet_stream_ops&lt;/code&gt;集合中定义的&lt;code&gt;inet_recvmsg&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;inet_recvmsg&lt;/code&gt;中会找到&lt;code&gt;struct sock&lt;/code&gt;，并调用&lt;code&gt;sock-&amp;gt;skprot-&amp;gt;recvmsg&lt;/code&gt;,这里调用的是&lt;code&gt;tcp_prot&lt;/code&gt;集合中定义的&lt;code&gt;tcp_recvmsg&lt;/code&gt;函数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;整个调用过程可以参考上边的《系统IO调用结构图》&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;熟悉了内核函数调用栈后，我们来看下系统IO调用在&lt;code&gt;tcp_recvmsg&lt;/code&gt;内核函数中是如何将用户进程给阻塞掉的&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6217741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEmK3jYMPOt7rib3Q5g7XFoaibh594gLT4uFERshJOcs9TGdVajaRaVYkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;系统IO调用阻塞原理.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;tcp_recvmsg&lt;/span&gt;&lt;span&gt;(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; len, &lt;span&gt;int&lt;/span&gt; nonblock, &lt;span&gt;int&lt;/span&gt; flags, &lt;span&gt;int&lt;/span&gt; *addr_len)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    .................省略非核心代码...............&lt;br/&gt;   &lt;span&gt;//访问sock对象中定义的接收队列&lt;/span&gt;&lt;br/&gt;  skb_queue_walk(&amp;amp;sk-&amp;gt;sk_receive_queue, skb) {&lt;br/&gt;&lt;br/&gt;    .................省略非核心代码...............&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//没有收到足够数据，调用sk_wait_data 阻塞当前进程&lt;/span&gt;&lt;br/&gt;  sk_wait_data(sk, &amp;amp;timeo);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sk_wait_data&lt;/span&gt;&lt;span&gt;(struct sock *sk, &lt;span&gt;long&lt;/span&gt; *timeo)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//创建struct sock中等待队列上的元素wait_queue_t&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//将进程描述符和回调函数autoremove_wake_function关联到wait_queue_t中&lt;/span&gt;&lt;br/&gt; DEFINE_WAIT(wait);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 调用 sk_sleep 获取 sock 对象下的等待队列的头指针wait_queue_head_t&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 调用prepare_to_wait将新创建的等待项wait_queue_t插入到等待队列中，并将进程状态设置为可打断 INTERRUPTIBLE&lt;/span&gt;&lt;br/&gt; prepare_to_wait(sk_sleep(sk), &amp;amp;wait, TASK_INTERRUPTIBLE);&lt;br/&gt; set_bit(SOCK_ASYNC_WAITDATA, &amp;amp;sk-&amp;gt;sk_socket-&amp;gt;flags);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 通过调用schedule_timeout让出CPU，然后进行睡眠，导致一次上下文切换&lt;/span&gt;&lt;br/&gt; rc = sk_wait_event(sk, timeo, !skb_queue_empty(&amp;amp;sk-&amp;gt;sk_receive_queue));&lt;br/&gt; ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先会在&lt;code&gt;DEFINE_WAIT&lt;/code&gt;中创建&lt;code&gt;struct sock&lt;/code&gt;中等待队列上的等待类型&lt;code&gt;wait_queue_t&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; DEFINE_WAIT_FUNC(name, function)    \&lt;br/&gt; wait_queue_t name = {      \&lt;br/&gt;  .private = current,    \&lt;br/&gt;  .func  = function,    \&lt;br/&gt;  .task_list = LIST_HEAD_INIT((name).task_list), \&lt;br/&gt; }&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等待类型&lt;code&gt;wait_queue_t&lt;/code&gt;中的&lt;code&gt;private&lt;/code&gt;用来关联&lt;code&gt;阻塞&lt;/code&gt;在当前&lt;code&gt;socket&lt;/code&gt;上的用户进程&lt;code&gt;fd&lt;/code&gt;。&lt;code&gt;func&lt;/code&gt;用来关联等待项上注册的回调函数。这里注册的是&lt;code&gt;autoremove_wake_function&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;调用&lt;code&gt;sk_sleep(sk)&lt;/code&gt;获取&lt;code&gt;struct sock&lt;/code&gt;对象中的等待队列头指针&lt;code&gt;wait_queue_head_t&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;调用&lt;code&gt;prepare_to_wait&lt;/code&gt;将新创建的等待项&lt;code&gt;wait_queue_t&lt;/code&gt;插入到等待队列中，并将进程设置为可打断 &lt;code&gt;INTERRUPTIBL&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;调用&lt;code&gt;sk_wait_event&lt;/code&gt;让出CPU，进程进入睡眠状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户进程的&lt;code&gt;阻塞过程&lt;/code&gt;我们就介绍完了，关键是要理解记住&lt;code&gt;struct sock&lt;/code&gt;中定义的等待队列上的等待类型&lt;code&gt;wait_queue_t&lt;/code&gt;的结构。后面&lt;code&gt;epoll&lt;/code&gt;的介绍中我们还会用到它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;下面我们接着介绍当数据就绪后，用户进程是如何被唤醒的&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文开始介绍《网络包接收过程》这一小节中我们提到：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当网络数据包到达网卡时，网卡通过&lt;code&gt;DMA&lt;/code&gt;的方式将数据放到&lt;code&gt;RingBuffer&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后向CPU发起硬中断，在硬中断响应程序中创建&lt;code&gt;sk_buffer&lt;/code&gt;，并将网络数据拷贝至&lt;code&gt;sk_buffer&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;随后发起软中断，内核线程&lt;code&gt;ksoftirqd&lt;/code&gt;响应软中断，调用&lt;code&gt;poll函数&lt;/code&gt;将&lt;code&gt;sk_buffer&lt;/code&gt;送往内核协议栈做层层协议处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在传输层&lt;code&gt;tcp_rcv 函数&lt;/code&gt;中，去掉TCP头，根据&lt;code&gt;四元组（源IP，源端口，目的IP，目的端口）&lt;/code&gt;查找对应的&lt;code&gt;Socket&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后将&lt;code&gt;sk_buffer&lt;/code&gt;放到&lt;code&gt;Socket&lt;/code&gt;中的接收队列里。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边这些过程是内核接收网络数据的完整过程，下边我们来看下，当数据包接收完毕后，用户进程是如何被唤醒的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5870967741935483&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcE9kTceMWn7KUGpgqK5Sq7nMgTBs4UkZwJ5Mor0WEibKZvLBxLeV0dJJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;系统IO调用唤醒原理.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当软中断将&lt;code&gt;sk_buffer&lt;/code&gt;放到&lt;code&gt;Socket&lt;/code&gt;的接收队列上时，接着就会调用&lt;code&gt;数据就绪函数回调指针sk_data_ready&lt;/code&gt;，前边我们提到，这个函数指针在初始化的时候指向了&lt;code&gt;sock_def_readable&lt;/code&gt;函数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在&lt;code&gt;sock_def_readable&lt;/code&gt;函数中会去获取&lt;code&gt;socket-&amp;gt;sock-&amp;gt;sk_wq&lt;/code&gt;等待队列。在&lt;code&gt;wake_up_common&lt;/code&gt;函数中从等待队列&lt;code&gt;sk_wq&lt;/code&gt;中找出&lt;code&gt;一个&lt;/code&gt;等待项&lt;code&gt;wait_queue_t&lt;/code&gt;，回调注册在该等待项上的&lt;code&gt;func&lt;/code&gt;回调函数（&lt;code&gt;wait_queue_t-&amp;gt;func&lt;/code&gt;）,创建等待项&lt;code&gt;wait_queue_t&lt;/code&gt;是我们提到，这里注册的回调函数是&lt;code&gt;autoremove_wake_function&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;即使是有多个进程都阻塞在同一个 socket 上，也只唤醒 1 个进程。其作用是为了避免惊群。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;autoremove_wake_function&lt;/code&gt;函数中，根据等待项&lt;code&gt;wait_queue_t&lt;/code&gt;上的&lt;code&gt;private&lt;/code&gt;关联的&lt;code&gt;阻塞进程fd&lt;/code&gt;调用&lt;code&gt;try_to_wake_up&lt;/code&gt;唤醒阻塞在该&lt;code&gt;Socket&lt;/code&gt;上的进程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;记住&lt;code&gt;wait_queue_t&lt;/code&gt;中的&lt;code&gt;func&lt;/code&gt;函数指针，在&lt;code&gt;epoll&lt;/code&gt;中这里会注册&lt;code&gt;epoll&lt;/code&gt;的回调函数。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在理解&lt;code&gt;epoll&lt;/code&gt;所需要的基础知识我们就介绍完了，唠叨了这么多，下面终于正式进入本小节的主题&lt;code&gt;epoll&lt;/code&gt;了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;epoll_create创建epoll对象&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;epoll_create&lt;/code&gt;是内核提供给我们创建&lt;code&gt;epoll&lt;/code&gt;对象的一个系统调用，当我们在用户进程中调用&lt;code&gt;epoll_create&lt;/code&gt;时，内核会为我们创建一个&lt;code&gt;struct eventpoll&lt;/code&gt;对象，并且也有相应的&lt;code&gt;struct file&lt;/code&gt;与之关联，同样需要把这个&lt;code&gt;struct eventpoll&lt;/code&gt;对象所关联的&lt;code&gt;struct file&lt;/code&gt;放入进程打开的文件列表&lt;code&gt;fd_array&lt;/code&gt;中管理。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;熟悉了&lt;code&gt;Socket&lt;/code&gt;的创建逻辑，&lt;code&gt;epoll&lt;/code&gt;的创建逻辑也就不难理解了。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;struct eventpoll&lt;/code&gt;对象关联的&lt;code&gt;struct file&lt;/code&gt;中的&lt;code&gt;file_operations 指针&lt;/code&gt;指向的是&lt;code&gt;eventpoll_fops&lt;/code&gt;操作函数集合。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file_operations&lt;/span&gt; &lt;span&gt;eventpoll_fops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;     .release = ep_eventpoll_release;&lt;br/&gt;     .poll = ep_eventpoll_poll,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6854838709677419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEibKwPYGuZaNbHCJ6jeia6TBicsgdh0cicLaIaHaGgLomLzb9h2r3Wfd3Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;eopll在进程中的整体结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eventpoll&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//等待队列，阻塞在epoll上的进程会放在这里&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;wait_queue_head_t&lt;/span&gt; wq;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//就绪队列，IO就绪的socket连接会放在这里&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;list_head&lt;/span&gt; &lt;span&gt;rdllist&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//红黑树用来管理所有监听的socket连接&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;rb_root&lt;/span&gt; &lt;span&gt;rbr&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;wait_queue_head_t wq：&lt;/code&gt;epoll中的等待队列，队列里存放的是&lt;code&gt;阻塞&lt;/code&gt;在&lt;code&gt;epoll&lt;/code&gt;上的用户进程。在&lt;code&gt;IO就绪&lt;/code&gt;的时候&lt;code&gt;epoll&lt;/code&gt;可以通过这个队列找到这些&lt;code&gt;阻塞&lt;/code&gt;的进程并唤醒它们，从而执行&lt;code&gt;IO调用&lt;/code&gt;读写&lt;code&gt;Socket&lt;/code&gt;上的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里注意与&lt;code&gt;Socket&lt;/code&gt;中的等待队列区分！！！&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;struct list_head rdllist：&lt;/code&gt;epoll中的就绪队列，队列里存放的是都是&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;，被唤醒的用户进程可以直接读取这个队列获取&lt;code&gt;IO活跃&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;。无需再次遍历整个&lt;code&gt;Socket&lt;/code&gt;集合。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里正是&lt;code&gt;epoll&lt;/code&gt;比&lt;code&gt;select ，poll&lt;/code&gt;高效之处，&lt;code&gt;select ，poll&lt;/code&gt;返回的是全部的&lt;code&gt;socket&lt;/code&gt;连接，我们需要在&lt;code&gt;用户空间&lt;/code&gt;再次遍历找出真正&lt;code&gt;IO活跃&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;连接。而&lt;code&gt;epoll&lt;/code&gt;只是返回&lt;code&gt;IO活跃&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;连接。用户进程可以直接进行IO操作。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;struct rb_root rbr :&lt;/code&gt; 由于红黑树在&lt;code&gt;查找&lt;/code&gt;，&lt;code&gt;插入&lt;/code&gt;，&lt;code&gt;删除&lt;/code&gt;等综合性能方面是最优的，所以epoll内部使用一颗红黑树来管理海量的&lt;code&gt;Socket&lt;/code&gt;连接。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;select&lt;/code&gt;用&lt;code&gt;数组&lt;/code&gt;管理连接，&lt;code&gt;poll&lt;/code&gt;用&lt;code&gt;链表&lt;/code&gt;管理连接。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;epoll_ctl向epoll对象中添加监听的Socket&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们调用&lt;code&gt;epoll_create&lt;/code&gt;在内核中创建出&lt;code&gt;epoll&lt;/code&gt;对象&lt;code&gt;struct eventpoll&lt;/code&gt;后，我们就可以利用&lt;code&gt;epoll_ctl&lt;/code&gt;向&lt;code&gt;epoll&lt;/code&gt;中添加我们需要管理的&lt;code&gt;Socket&lt;/code&gt;连接了。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先要在epoll内核中创建一个表示&lt;code&gt;Socket连接&lt;/code&gt;的数据结构&lt;code&gt;struct epitem&lt;/code&gt;，而在&lt;code&gt;epoll&lt;/code&gt;中为了综合性能的考虑，采用一颗红黑树来管理这些海量&lt;code&gt;socket连接&lt;/code&gt;。所以&lt;code&gt;struct epitem&lt;/code&gt;是一个红黑树节点。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEItBeLMXJPAJtcYN6yeNKBbIkH8pCgeic4CIpFTJqrBJ4IkAxJH6JaEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;struct epitem.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epitem&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;//指向所属epoll对象&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eventpoll&lt;/span&gt; *&lt;span&gt;ep&lt;/span&gt;;&lt;/span&gt; &lt;br/&gt;      &lt;span&gt;//注册的感兴趣的事件,也就是用户空间的epoll_event     &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epoll_event&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;;&lt;/span&gt; &lt;br/&gt;      &lt;span&gt;//指向epoll对象中的就绪队列&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;list_head&lt;/span&gt; &lt;span&gt;rdllink&lt;/span&gt;;&lt;/span&gt;  &lt;br/&gt;      &lt;span&gt;//指向epoll中对应的红黑树节点&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;rb_node&lt;/span&gt; &lt;span&gt;rbn&lt;/span&gt;;&lt;/span&gt;     &lt;br/&gt;      &lt;span&gt;//指向epitem所表示的socket-&amp;gt;file结构以及对应的fd&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epoll_filefd&lt;/span&gt; &lt;span&gt;ffd&lt;/span&gt;;&lt;/span&gt;                  &lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里重点记住&lt;code&gt;struct epitem&lt;/code&gt;结构中的&lt;code&gt;rdllink&lt;/code&gt;以及&lt;code&gt;epoll_filefd&lt;/code&gt;成员，后面我们会用到。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在内核中创建完表示&lt;code&gt;Socket连接&lt;/code&gt;的数据结构&lt;code&gt;struct epitem&lt;/code&gt;后，我们就需要在&lt;code&gt;Socket&lt;/code&gt;中的等待队列上创建等待项&lt;code&gt;wait_queue_t&lt;/code&gt;并且注册&lt;code&gt;epoll的回调函数ep_poll_callback&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;《阻塞IO中用户进程阻塞以及唤醒原理》&lt;/code&gt;小节的铺垫，我想大家已经猜到这一步的意义所在了吧！当时在等待项&lt;code&gt;wait_queue_t&lt;/code&gt;中注册的是&lt;code&gt;autoremove_wake_function&lt;/code&gt;回调函数。还记得吗？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;epoll的回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;正是&lt;code&gt;epoll&lt;/code&gt;同步IO事件通知机制的核心所在，也是区别于&lt;code&gt;select，poll&lt;/code&gt;采用内核轮询方式的根本性能差异所在。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5516129032258065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEkerTL14uiakMoYWeslKZrAXfMibzAwSt2CE6LmTbHMI6yK1oolEvCqAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;epitem创建等待项.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里又出现了一个新的数据结构&lt;code&gt;struct eppoll_entry&lt;/code&gt;，那它的作用是干什么的呢？大家可以结合上图先猜测下它的作用!&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道&lt;code&gt;socket-&amp;gt;sock-&amp;gt;sk_wq&lt;/code&gt;等待队列中的类型是&lt;code&gt;wait_queue_t&lt;/code&gt;，我们需要在&lt;code&gt;struct epitem&lt;/code&gt;所表示的&lt;code&gt;socket&lt;/code&gt;的等待队列上注册&lt;code&gt;epoll&lt;/code&gt;回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样当数据到达&lt;code&gt;socket&lt;/code&gt;中的接收队列时，内核会回调&lt;code&gt;sk_data_ready&lt;/code&gt;，在&lt;code&gt;阻塞IO中用户进程阻塞以及唤醒原理&lt;/code&gt;这一小节中，我们知道这个&lt;code&gt;sk_data_ready&lt;/code&gt;函数指针会指向&lt;code&gt;sk_def_readable&lt;/code&gt;函数，在&lt;code&gt;sk_def_readable&lt;/code&gt;中会回调注册在等待队列里的等待项&lt;code&gt;wait_queue_t -&amp;gt; func&lt;/code&gt;回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;。&lt;strong&gt;在&lt;code&gt;ep_poll_callback&lt;/code&gt;中需要找到&lt;code&gt;epitem&lt;/code&gt;&lt;/strong&gt;，将&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;epitem&lt;/code&gt;放入&lt;code&gt;epoll&lt;/code&gt;中的就绪队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;socket&lt;/code&gt;等待队列中类型是&lt;code&gt;wait_queue_t&lt;/code&gt;无法关联到&lt;code&gt;epitem&lt;/code&gt;。所以就出现了&lt;code&gt;struct eppoll_entry&lt;/code&gt;结构体，它的作用就是关联&lt;code&gt;Socket&lt;/code&gt;等待队列中的等待项&lt;code&gt;wait_queue_t&lt;/code&gt;和&lt;code&gt;epitem&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eppoll_entry&lt;/span&gt; {&lt;/span&gt; &lt;br/&gt;   &lt;span&gt;//指向关联的epitem&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epitem&lt;/span&gt; *&lt;span&gt;base&lt;/span&gt;;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 关联监听socket中等待队列中的等待项 (private = null  func = ep_poll_callback)&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;wait_queue_t&lt;/span&gt; wait;   &lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// 监听socket中等待队列头指针&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;wait_queue_head_t&lt;/span&gt; *whead; &lt;br/&gt;    .........&lt;br/&gt;  }; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在&lt;code&gt;ep_poll_callback&lt;/code&gt;回调函数中就可以根据&lt;code&gt;Socket&lt;/code&gt;等待队列中的等待项&lt;code&gt;wait&lt;/code&gt;，通过&lt;code&gt;container_of宏&lt;/code&gt;找到&lt;code&gt;eppoll_entry&lt;/code&gt;，继而找到&lt;code&gt;epitem&lt;/code&gt;了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;container_of&lt;/code&gt;在Linux内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里需要注意下这次等待项&lt;code&gt;wait_queue_t&lt;/code&gt;中的&lt;code&gt;private&lt;/code&gt;设置的是&lt;code&gt;null&lt;/code&gt;，因为这里&lt;code&gt;Socket&lt;/code&gt;是交给&lt;code&gt;epoll&lt;/code&gt;来管理的，阻塞在&lt;code&gt;Socket&lt;/code&gt;上的进程是也由&lt;code&gt;epoll&lt;/code&gt;来唤醒。在等待项&lt;code&gt;wait_queue_t&lt;/code&gt;注册的&lt;code&gt;func&lt;/code&gt;是&lt;code&gt;ep_poll_callback&lt;/code&gt;而不是&lt;code&gt;autoremove_wake_function&lt;/code&gt;，&lt;code&gt;阻塞进程&lt;/code&gt;并不需要&lt;code&gt;autoremove_wake_function&lt;/code&gt;来唤醒，所以这里设置&lt;code&gt;private&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当在&lt;code&gt;Socket&lt;/code&gt;的等待队列中创建好等待项&lt;code&gt;wait_queue_t&lt;/code&gt;并且注册了&lt;code&gt;epoll&lt;/code&gt;的回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;，然后又通过&lt;code&gt;eppoll_entry&lt;/code&gt;关联了&lt;code&gt;epitem&lt;/code&gt;后。剩下要做的就是将&lt;code&gt;epitem&lt;/code&gt;插入到&lt;code&gt;epoll&lt;/code&gt;中的红黑树&lt;code&gt;struct rb_root rbr&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里可以看到&lt;code&gt;epoll&lt;/code&gt;另一个优化的地方，&lt;code&gt;epoll&lt;/code&gt;将所有的&lt;code&gt;socket&lt;/code&gt;连接通过内核中的红黑树来集中管理。每次添加或者删除&lt;code&gt;socket连接&lt;/code&gt;都是增量添加删除，而不是像&lt;code&gt;select，poll&lt;/code&gt;那样每次调用都是全量&lt;code&gt;socket连接&lt;/code&gt;集合传入内核。避免了&lt;code&gt;频繁大量&lt;/code&gt;的&lt;code&gt;内存拷贝&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;epoll_wait同步阻塞获取IO就绪的Socket&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户程序调用&lt;code&gt;epoll_wait&lt;/code&gt;后，内核首先会查找epoll中的就绪队列&lt;code&gt;eventpoll-&amp;gt;rdllist&lt;/code&gt;是否有&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;epitem&lt;/code&gt;。&lt;code&gt;epitem&lt;/code&gt;里封装了&lt;code&gt;socket&lt;/code&gt;的信息。如果就绪队列中有就绪的&lt;code&gt;epitem&lt;/code&gt;，就将&lt;code&gt;就绪的socket&lt;/code&gt;信息封装到&lt;code&gt;epoll_event&lt;/code&gt;返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果&lt;code&gt;eventpoll-&amp;gt;rdllist&lt;/code&gt;就绪队列中没有&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;epitem&lt;/code&gt;，则会创建等待项&lt;code&gt;wait_queue_t&lt;/code&gt;，将用户进程的&lt;code&gt;fd&lt;/code&gt;关联到&lt;code&gt;wait_queue_t-&amp;gt;private&lt;/code&gt;上，并在等待项&lt;code&gt;wait_queue_t-&amp;gt;func&lt;/code&gt;上注册回调函数&lt;code&gt;default_wake_function&lt;/code&gt;。最后将等待项添加到&lt;code&gt;epoll&lt;/code&gt;中的等待队列中。用户进程让出CPU，进入&lt;code&gt;阻塞状态&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5056451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEG5wWc27ZGXv7sBleibFeuPfEuyfibG9VolWJCiaHlp0DZoYoibpwb3MgNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;epoll_wait同步获取数据.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里和&lt;code&gt;阻塞IO模型&lt;/code&gt;中的阻塞原理是一样的，只不过在&lt;code&gt;阻塞IO模型&lt;/code&gt;中注册到等待项&lt;code&gt;wait_queue_t-&amp;gt;func&lt;/code&gt;上的是&lt;code&gt;autoremove_wake_function&lt;/code&gt;，并将等待项添加到&lt;code&gt;socket&lt;/code&gt;中的等待队列中。这里注册的是&lt;code&gt;default_wake_function&lt;/code&gt;，将等待项添加到&lt;code&gt;epoll&lt;/code&gt;中的等待队列上。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4475806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEl2MECv0ibicDsbibN5ZJaql9ziaJMEFNtzEoxr5LcJuR9vaojRYZ5kyOfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;数据到来epoll_wait流程.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;前边做了那么多的知识铺垫，下面终于到了&lt;code&gt;epoll&lt;/code&gt;的整个工作流程了：&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4967741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEgGR4zpAZARg0IVDCjFjwuukcBZsicw9tmJeO2CCda9x4EwMRZibXptWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;epoll_wait处理过程.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当网络数据包在软中断中经过内核协议栈的处理到达&lt;code&gt;socket&lt;/code&gt;的接收缓冲区时，紧接着会调用socket的数据就绪回调指针&lt;code&gt;sk_data_ready&lt;/code&gt;，回调函数为&lt;code&gt;sock_def_readable&lt;/code&gt;。在&lt;code&gt;socket&lt;/code&gt;的等待队列中找出等待项，其中等待项中注册的回调函数为&lt;code&gt;ep_poll_callback&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;中，根据&lt;code&gt;struct eppoll_entry&lt;/code&gt;中的&lt;code&gt;struct wait_queue_t wait&lt;/code&gt;通过&lt;code&gt;container_of宏&lt;/code&gt;找到&lt;code&gt;eppoll_entry&lt;/code&gt;对象并通过它的&lt;code&gt;base&lt;/code&gt;指针找到封装&lt;code&gt;socket&lt;/code&gt;的数据结构&lt;code&gt;struct epitem&lt;/code&gt;，并将它加入到&lt;code&gt;epoll&lt;/code&gt;中的就绪队列&lt;code&gt;rdllist&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随后查看&lt;code&gt;epoll&lt;/code&gt;中的等待队列中是否有等待项，也就是说查看是否有进程阻塞在&lt;code&gt;epoll_wait&lt;/code&gt;上等待&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;socket&lt;/code&gt;。如果没有等待项，则软中断处理完成。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果有等待项，则回到注册在等待项中的回调函数&lt;code&gt;default_wake_function&lt;/code&gt;,在回调函数中唤醒&lt;code&gt;阻塞进程&lt;/code&gt;，并将就绪队列&lt;code&gt;rdllist&lt;/code&gt;中的&lt;code&gt;epitem&lt;/code&gt;的&lt;code&gt;IO就绪&lt;/code&gt;socket信息封装到&lt;code&gt;struct epoll_event&lt;/code&gt;中返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户进程拿到&lt;code&gt;epoll_event&lt;/code&gt;获取&lt;code&gt;IO就绪&lt;/code&gt;的socket，发起系统IO调用读取数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;再谈水平触发和边缘触发&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上有大量的关于这两种模式的讲解，大部分讲的比较模糊，感觉只是强行从概念上进行描述，看完让人难以理解。所以在这里，笔者想结合上边&lt;code&gt;epoll&lt;/code&gt;的工作过程，再次对这两种模式做下自己的解读，力求清晰的解释出这两种工作模式的异同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上边对&lt;code&gt;epoll&lt;/code&gt;工作过程的详细解读，我们知道，当我们监听的&lt;code&gt;socket&lt;/code&gt;上有数据到来时，软中断会执行&lt;code&gt;epoll&lt;/code&gt;的回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;,在回调函数中会将&lt;code&gt;epoll&lt;/code&gt;中描述&lt;code&gt;socket信息&lt;/code&gt;的数据结构&lt;code&gt;epitem&lt;/code&gt;插入到&lt;code&gt;epoll&lt;/code&gt;中的就绪队列&lt;code&gt;rdllist&lt;/code&gt;中。随后用户进程从&lt;code&gt;epoll&lt;/code&gt;的等待队列中被唤醒，&lt;code&gt;epoll_wait&lt;/code&gt;将&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;socket&lt;/code&gt;返回给用户进程，随即&lt;code&gt;epoll_wait&lt;/code&gt;会清空&lt;code&gt;rdllist&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;水平触发&lt;/strong&gt;和&lt;strong&gt;边缘触发&lt;/strong&gt;最关键的&lt;strong&gt;区别&lt;/strong&gt;就在于当&lt;code&gt;socket&lt;/code&gt;中的接收缓冲区还有数据可读时。&lt;strong&gt;&lt;code&gt;epoll_wait&lt;/code&gt;是否会清空&lt;code&gt;rdllist&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;水平触发&lt;/strong&gt;：在这种模式下，用户线程调用&lt;code&gt;epoll_wait&lt;/code&gt;获取到&lt;code&gt;IO就绪&lt;/code&gt;的socket后，对&lt;code&gt;Socket&lt;/code&gt;进行系统IO调用读取数据，假设&lt;code&gt;socket&lt;/code&gt;中的数据只读了一部分没有全部读完，这时再次调用&lt;code&gt;epoll_wait&lt;/code&gt;，&lt;code&gt;epoll_wait&lt;/code&gt;会检查这些&lt;code&gt;Socket&lt;/code&gt;中的接收缓冲区是否还有数据可读，如果还有数据可读，就将&lt;code&gt;socket&lt;/code&gt;重新放回&lt;code&gt;rdllist&lt;/code&gt;。所以当&lt;code&gt;socket&lt;/code&gt;上的IO没有被处理完时，再次调用&lt;code&gt;epoll_wait&lt;/code&gt;依然可以获得这些&lt;code&gt;socket&lt;/code&gt;，用户进程可以接着处理&lt;code&gt;socket&lt;/code&gt;上的IO事件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;边缘触发：&lt;/strong&gt; 在这种模式下，&lt;code&gt;epoll_wait&lt;/code&gt;就会直接清空&lt;code&gt;rdllist&lt;/code&gt;，不管&lt;code&gt;socket&lt;/code&gt;上是否还有数据可读。所以在边缘触发模式下，当你没有来得及处理&lt;code&gt;socket&lt;/code&gt;接收缓冲区的剩下可读数据时，再次调用&lt;code&gt;epoll_wait&lt;/code&gt;，因为这时&lt;code&gt;rdlist&lt;/code&gt;已经被清空了，&lt;code&gt;socket&lt;/code&gt;不会再次从&lt;code&gt;epoll_wait&lt;/code&gt;中返回，所以用户进程就不会再次获得这个&lt;code&gt;socket&lt;/code&gt;了，也就无法在对它进行IO处理了。&lt;strong&gt;除非，这个&lt;code&gt;socket&lt;/code&gt;上有新的IO数据到达&lt;/strong&gt;，根据&lt;code&gt;epoll&lt;/code&gt;的工作过程，该&lt;code&gt;socket&lt;/code&gt;会被再次放入&lt;code&gt;rdllist&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果你在&lt;code&gt;边缘触发模式&lt;/code&gt;下，处理了部分&lt;code&gt;socket&lt;/code&gt;上的数据，那么想要处理剩下部分的数据，就只能等到这个&lt;code&gt;socket&lt;/code&gt;上再次有网络数据到达。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Netty&lt;/code&gt;中实现的&lt;code&gt;EpollSocketChannel&lt;/code&gt;默认的就是&lt;code&gt;边缘触发&lt;/code&gt;模式。&lt;code&gt;JDK&lt;/code&gt;的&lt;code&gt;NIO&lt;/code&gt;默认是&lt;code&gt;水平触发&lt;/code&gt;模式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;epoll对select，poll的优化总结&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;epoll&lt;/code&gt;在内核中通过&lt;code&gt;红黑树&lt;/code&gt;管理海量的连接，所以在调用&lt;code&gt;epoll_wait&lt;/code&gt;获取&lt;code&gt;IO就绪&lt;/code&gt;的socket时，不需要传入监听的socket文件描述符。从而避免了海量的文件描述符集合在&lt;code&gt;用户空间&lt;/code&gt;和&lt;code&gt;内核空间&lt;/code&gt;中来回复制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;select，poll&lt;/code&gt;每次调用时都需要传递全量的文件描述符集合，导致大量频繁的拷贝操作。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;epoll&lt;/code&gt;仅会通知&lt;code&gt;IO就绪&lt;/code&gt;的socket。避免了在用户空间遍历的开销。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;select，poll&lt;/code&gt;只会在&lt;code&gt;IO就绪&lt;/code&gt;的socket上打好标记，依然是全量返回，所以在用户空间还需要用户程序在一次遍历全量集合找出具体&lt;code&gt;IO就绪&lt;/code&gt;的socket。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;epoll&lt;/code&gt;通过在&lt;code&gt;socket&lt;/code&gt;的等待队列上注册回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;通知用户程序&lt;code&gt;IO就绪&lt;/code&gt;的socket。避免了在内核中轮询的开销。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大部分情况下&lt;code&gt;socket&lt;/code&gt;上并不总是&lt;code&gt;IO活跃&lt;/code&gt;的，在面对海量连接的情况下，&lt;code&gt;select，poll&lt;/code&gt;采用内核轮询的方式获取&lt;code&gt;IO活跃&lt;/code&gt;的socket，无疑是性能低下的核心原因。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据以上&lt;code&gt;epoll&lt;/code&gt;的性能优势，它是目前为止各大主流网络框架，以及反向代理中间件使用到的网络IO模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用&lt;code&gt;epoll&lt;/code&gt;多路复用IO模型可以轻松的解决&lt;code&gt;C10K&lt;/code&gt;问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;C100k&lt;/code&gt;的解决方案也还是基于&lt;code&gt;C10K&lt;/code&gt;的方案，通过&lt;code&gt;epoll&lt;/code&gt; 配合线程池，再加上 CPU、内存和网络接口的性能和容量提升。大部分情况下，&lt;code&gt;C100K&lt;/code&gt;很自然就可以达到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;甚至&lt;code&gt;C1000K&lt;/code&gt;的解决方法，本质上还是构建在 &lt;code&gt;epoll&lt;/code&gt; 的&lt;code&gt;多路复用 I/O 模型&lt;/code&gt;上。只不过，除了 I/O 模型之外，还需要从应用程序到 Linux 内核、再到 CPU、内存和网络等各个层次的深度优化，特别是需要借助硬件，来卸载那些原来通过软件处理的大量功能（&lt;code&gt;去掉大量的中断响应开销&lt;/code&gt;，&lt;code&gt;以及内核协议栈处理的开销&lt;/code&gt;）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;信号驱动IO&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEPmrUxCAPYRsmPqyGfq7icCaV1FP8bwKOTt0icvGO12ickvLv8Y80K7R5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;figcaption&gt;信号驱动IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家对这个装备肯定不会陌生，当我们去一些美食城吃饭的时候，点完餐付了钱，老板会给我们一个信号器。然后我们带着这个信号器可以去找餐桌，或者干些其他的事情。当信号器亮了的时候，这时代表饭餐已经做好，我们可以去窗口取餐了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个典型的生活场景和我们要介绍的&lt;code&gt;信号驱动IO模型&lt;/code&gt;就很像。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;信号驱动IO模型&lt;/code&gt;下，用户进程操作通过&lt;code&gt;系统调用 sigaction 函数&lt;/code&gt;发起一个 IO 请求，在对应的&lt;code&gt;socket&lt;/code&gt;注册一个&lt;code&gt;信号回调&lt;/code&gt;，此时&lt;code&gt;不阻塞&lt;/code&gt;用户进程，进程会继续工作。当内核数据就绪时，内核就为该进程生成一个 &lt;code&gt;SIGIO 信号&lt;/code&gt;，通过信号回调通知进程进行相关 IO 操作。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里需要注意的是：&lt;code&gt;信号驱动式 IO 模型&lt;/code&gt;依然是&lt;code&gt;同步IO&lt;/code&gt;，因为它虽然可以在等待数据的时候不被阻塞，也不会频繁的轮询，但是当数据就绪，内核信号通知后，用户进程依然要自己去读取数据，在&lt;code&gt;数据拷贝阶段&lt;/code&gt;发生阻塞。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;信号驱动 IO模型 相比于前三种 IO 模型，实现了在等待数据就绪时，进程不被阻塞，主循环可以继续工作，所以&lt;code&gt;理论上&lt;/code&gt;性能更佳。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是实际上，使用&lt;code&gt;TCP协议&lt;/code&gt;通信时，&lt;code&gt;信号驱动IO模型&lt;/code&gt;几乎&lt;code&gt;不会被采用&lt;/code&gt;。原因如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;信号IO 在大量 IO 操作时可能会因为信号队列溢出导致没法通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SIGIO 信号&lt;/code&gt;是一种 Unix 信号，信号没有附加信息，如果一个信号源有多种产生信号的原因，信号接收者就无法确定究竟发生了什么。而 TCP socket 生产的信号事件有七种之多，这样应用程序收到 SIGIO，根本无从区分处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但&lt;code&gt;信号驱动IO模型&lt;/code&gt;可以用在 &lt;code&gt;UDP&lt;/code&gt;通信上，因为UDP 只有&lt;code&gt;一个数据请求事件&lt;/code&gt;，这也就意味着在正常情况下 UDP 进程只要捕获 SIGIO 信号，就调用 &lt;code&gt;read 系统调用&lt;/code&gt;读取到达的数据。如果出现异常，就返回一个异常错误。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里插句题外话，大家觉不觉得&lt;code&gt;阻塞IO模型&lt;/code&gt;在生活中的例子就像是我们在食堂排队打饭。你自己需要排队去打饭同时打饭师傅在配菜的过程中你需要等待。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.740909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEfnPgIKViaoGPghC3DGrmSn8YiaibhwQBrUiaFgticngwAwyqr6hh6exRocA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;220&quot;/&gt;&lt;figcaption&gt;阻塞IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IO多路复用模型&lt;/code&gt;就像是我们在饭店门口排队等待叫号。叫号器就好比&lt;code&gt;select,poll,epoll&lt;/code&gt;可以统一管理全部顾客的&lt;code&gt;吃饭就绪&lt;/code&gt;事件，客户好比是&lt;code&gt;socket&lt;/code&gt;连接，谁可以去吃饭了，叫号器就通知谁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6232394366197183&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEB28gaSs3gtCLlPLIlibib0kRf9XgKCEbuW8Tvx3dC20Bc8MylahYMbtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;284&quot;/&gt;&lt;figcaption&gt;IO多路复用.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;##异步IO（AIO）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上介绍的四种&lt;code&gt;IO模型&lt;/code&gt;均为&lt;code&gt;同步IO&lt;/code&gt;，它们都会阻塞在第二阶段&lt;code&gt;数据拷贝阶段&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过在前边小节《同步与异步》中的介绍，相信大家很容易就会理解&lt;code&gt;异步IO模型&lt;/code&gt;，在&lt;code&gt;异步IO模型&lt;/code&gt;下，IO操作在&lt;code&gt;数据准备阶段&lt;/code&gt;和&lt;code&gt;数据拷贝阶段&lt;/code&gt;均是由内核来完成，不会对应用程序造成任何阻塞。应用进程只需要在&lt;code&gt;指定的数组&lt;/code&gt;中引用数据即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;异步 IO&lt;/code&gt; 与&lt;code&gt;信号驱动 IO&lt;/code&gt; 的主要区别在于：&lt;code&gt;信号驱动 IO&lt;/code&gt; 由内核通知何时可以&lt;code&gt;开始一个 IO 操作&lt;/code&gt;，而&lt;code&gt;异步 IO&lt;/code&gt;由内核通知 &lt;code&gt;IO 操作何时已经完成&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个生活中的例子：&lt;code&gt;异步IO模型&lt;/code&gt;就像我们去一个高档饭店里的包间吃饭，我们只需要坐在包间里面，点完餐（&lt;code&gt;类比异步IO调用&lt;/code&gt;）之后，我们就什么也不需要管，该喝酒喝酒，该聊天聊天，饭餐做好后服务员（&lt;code&gt;类比内核&lt;/code&gt;）会自己给我们送到包间（&lt;code&gt;类比用户空间&lt;/code&gt;）来。整个过程没有任何阻塞。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEfQXKapnOwAK72jTpaKrqfUicX38A8Z5TWopFUyZC0B04NMBRMdiapAFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;figcaption&gt;异步IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;异步IO&lt;/code&gt;的系统调用需要操作系统内核来支持，目前只有&lt;code&gt;Window&lt;/code&gt;中的&lt;code&gt;IOCP&lt;/code&gt;实现了非常成熟的&lt;code&gt;异步IO机制&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;Linux&lt;/code&gt;系统对&lt;code&gt;异步IO机制&lt;/code&gt;实现的不够成熟，且与&lt;code&gt;NIO&lt;/code&gt;的性能相比提升也不明显。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;但Linux kernel 在5.1版本由Facebook的大神Jens Axboe引入了新的异步IO库&lt;code&gt;io_uring&lt;/code&gt; 改善了原来Linux native AIO的一些性能问题。性能相比&lt;code&gt;Epoll&lt;/code&gt;以及之前原生的&lt;code&gt;AIO&lt;/code&gt;提高了不少，值得关注。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再加上&lt;code&gt;信号驱动IO模型&lt;/code&gt;不适用&lt;code&gt;TCP协议&lt;/code&gt;，所以目前大部分采用的还是&lt;code&gt;IO多路复用模型&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IO线程模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边内容的介绍中，我们详述了网络数据包的接收和发送过程，并通过介绍5种&lt;code&gt;IO模型&lt;/code&gt;了解了内核是如何读取网络数据并通知给用户线程的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边的内容都是以&lt;code&gt;内核空间&lt;/code&gt;的视角来剖析网络数据的收发模型，本小节我们站在&lt;code&gt;用户空间&lt;/code&gt;的视角来看下如果对网络数据进行收发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对&lt;code&gt;内核&lt;/code&gt;来讲，&lt;code&gt;用户空间的IO线程模型&lt;/code&gt;相对就简单一些。这些&lt;code&gt;用户空间&lt;/code&gt;的&lt;code&gt;IO线程模型&lt;/code&gt;都是在讨论当多线程一起配合工作时谁负责接收连接，谁负责响应IO 读写、谁负责计算、谁负责发送和接收，仅仅是用户IO线程的不同分工模式罢了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Reactor&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Reactor&lt;/code&gt;是利用&lt;code&gt;NIO&lt;/code&gt;对&lt;code&gt;IO线程&lt;/code&gt;进行不同的分工：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用前边我们提到的&lt;code&gt;IO多路复用模型&lt;/code&gt;比如&lt;code&gt;select,poll,epoll,kqueue&lt;/code&gt;,进行IO事件的注册和监听。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将监听到&lt;code&gt;就绪的IO事件&lt;/code&gt;分发&lt;code&gt;dispatch&lt;/code&gt;到各个具体的处理&lt;code&gt;Handler&lt;/code&gt;中进行相应的&lt;code&gt;IO事件处理&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;IO多路复用技术&lt;/code&gt;就可以不断的监听&lt;code&gt;IO事件&lt;/code&gt;，不断的分发&lt;code&gt;dispatch&lt;/code&gt;，就像一个&lt;code&gt;反应堆&lt;/code&gt;一样，看起来像不断的产生&lt;code&gt;IO事件&lt;/code&gt;，因此我们称这种模式为&lt;code&gt;Reactor&lt;/code&gt;模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下&lt;code&gt;Reactor模型&lt;/code&gt;的三种分类：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;单Reactor单线程&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39520333680917624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEwlZPO0207A07smWv3l1Gq7rHOMAmRuqePPg2KdO7BPDbSQDrguxz6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;959&quot;/&gt;&lt;figcaption&gt;单Reactor单线程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Reactor模型&lt;/code&gt;是依赖&lt;code&gt;IO多路复用技术&lt;/code&gt;实现监听&lt;code&gt;IO事件&lt;/code&gt;，从而源源不断的产生&lt;code&gt;IO就绪事件&lt;/code&gt;，在Linux系统下我们使用&lt;code&gt;epoll&lt;/code&gt;来进行&lt;code&gt;IO多路复用&lt;/code&gt;，我们以Linux系统为例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;单&lt;code&gt;Reactor&lt;/code&gt;意味着只有一个&lt;code&gt;epoll&lt;/code&gt;对象，用来监听所有的事件，比如&lt;code&gt;连接事件&lt;/code&gt;，&lt;code&gt;读写事件&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;单线程&lt;/code&gt;意味着只有一个线程来执行&lt;code&gt;epoll_wait&lt;/code&gt;获取&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;，然后对这些就绪的&lt;code&gt;Socket&lt;/code&gt;执行读写，以及后边的业务处理也依然是这个线程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;单Reactor单线程&lt;/code&gt;模型就好比我们开了一个很小很小的小饭馆，作为老板的我们需要一个人干所有的事情，包括：迎接顾客（&lt;code&gt;accept事件&lt;/code&gt;），为顾客介绍菜单等待顾客点菜(&lt;code&gt;IO请求&lt;/code&gt;)，做菜（&lt;code&gt;业务处理&lt;/code&gt;），上菜（&lt;code&gt;IO响应&lt;/code&gt;），送客（&lt;code&gt;断开连接&lt;/code&gt;）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;单Reactor多线程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着客人的增多（&lt;code&gt;并发请求&lt;/code&gt;），显然饭馆里的事情只有我们一个人干（&lt;code&gt;单线程&lt;/code&gt;）肯定是忙不过来的，这时候我们就需要多招聘一些员工（&lt;code&gt;多线程&lt;/code&gt;）来帮着一起干上述的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是就有了&lt;code&gt;单Reactor多线程&lt;/code&gt;模型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7006048387096774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEo6zebSVIsdVBZIBDtOM5OEOwJxgZfMicrYkyfnz6hLIkiaK8MN4I5Kfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;992&quot;/&gt;&lt;figcaption&gt;单Reactor多线程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这种模式下，也是只有一个&lt;code&gt;epoll&lt;/code&gt;对象来监听所有的&lt;code&gt;IO事件&lt;/code&gt;，一个线程来调用&lt;code&gt;epoll_wait&lt;/code&gt;获取&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但是当&lt;code&gt;IO就绪事件&lt;/code&gt;产生时，这些&lt;code&gt;IO事件&lt;/code&gt;对应处理的业务&lt;code&gt;Handler&lt;/code&gt;，我们是通过线程池来执行。这样相比&lt;code&gt;单Reactor单线程&lt;/code&gt;模型提高了执行效率，充分发挥了多核CPU的优势。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;主从Reactor多线程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做任何事情都要区分&lt;code&gt;事情的优先级&lt;/code&gt;，我们应该&lt;code&gt;优先高效&lt;/code&gt;的去做&lt;code&gt;优先级更高&lt;/code&gt;的事情，而不是一股脑不分优先级的全部去做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们的小饭馆客人越来越多（&lt;code&gt;并发量越来越大&lt;/code&gt;），我们就需要扩大饭店的规模，在这个过程中我们发现，&lt;code&gt;迎接客人&lt;/code&gt;是饭店最重要的工作，我们要先把客人迎接进来，不能让客人一看人多就走掉，只要客人进来了，哪怕菜做的慢一点也没关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，&lt;code&gt;主从Reactor多线程&lt;/code&gt;模型就产生了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6917670682730924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEubXjFtTT6Ac0xQxicxT4jwia2OOjiafa2FhzzYh1VGelwHmj8OBdKwukg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;996&quot;/&gt;&lt;figcaption&gt;主从Reactor多线程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们由原来的&lt;code&gt;单Reactor&lt;/code&gt;变为了&lt;code&gt;多Reactor&lt;/code&gt;。&lt;code&gt;主Reactor&lt;/code&gt;用来优先&lt;code&gt;专门&lt;/code&gt;做优先级最高的事情，也就是迎接客人（&lt;code&gt;处理连接事件&lt;/code&gt;），对应的处理&lt;code&gt;Handler&lt;/code&gt;就是图中的&lt;code&gt;acceptor&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当创建好连接，建立好对应的&lt;code&gt;socket&lt;/code&gt;后，在&lt;code&gt;acceptor&lt;/code&gt;中将要监听的&lt;code&gt;read事件&lt;/code&gt;注册到&lt;code&gt;从Reactor&lt;/code&gt;中，由&lt;code&gt;从Reactor&lt;/code&gt;来监听&lt;code&gt;socket&lt;/code&gt;上的&lt;code&gt;读写&lt;/code&gt;事件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最终将读写的业务逻辑处理交给线程池处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里向&lt;code&gt;从Reactor&lt;/code&gt;注册的只是&lt;code&gt;read事件&lt;/code&gt;，并没有注册&lt;code&gt;write事件&lt;/code&gt;，因为&lt;code&gt;read事件&lt;/code&gt;是由&lt;code&gt;epoll内核&lt;/code&gt;触发的，而&lt;code&gt;write事件&lt;/code&gt;则是由用户业务线程触发的（&lt;code&gt;什么时候发送数据是由具体业务线程决定的&lt;/code&gt;），所以&lt;code&gt;write事件&lt;/code&gt;理应是由&lt;code&gt;用户业务线程&lt;/code&gt;去注册。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用户线程注册&lt;code&gt;write事件&lt;/code&gt;的时机是只有当用户发送的数据&lt;code&gt;无法一次性&lt;/code&gt;全部写入&lt;code&gt;buffer&lt;/code&gt;时，才会去注册&lt;code&gt;write事件&lt;/code&gt;，等待&lt;code&gt;buffer重新可写&lt;/code&gt;时，继续写入剩下的发送数据、如果用户线程可以一股脑的将发送数据全部写入&lt;code&gt;buffer&lt;/code&gt;，那么也就无需注册&lt;code&gt;write事件&lt;/code&gt;到&lt;code&gt;从Reactor&lt;/code&gt;中。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;主从Reactor多线程&lt;/code&gt;模型是现在大部分主流网络框架中采用的一种&lt;code&gt;IO线程模型&lt;/code&gt;。我们本系列的主题&lt;code&gt;Netty&lt;/code&gt;就是用的这种模型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Proactor&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Proactor&lt;/code&gt;是基于&lt;code&gt;AIO&lt;/code&gt;对&lt;code&gt;IO线程&lt;/code&gt;进行分工的一种模型。前边我们介绍了&lt;code&gt;异步IO模型&lt;/code&gt;，它是操作系统内核支持的一种全异步编程模型，在&lt;code&gt;数据准备阶段&lt;/code&gt;和&lt;code&gt;数据拷贝阶段&lt;/code&gt;全程无阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ProactorIO线程模型&lt;/code&gt;将&lt;code&gt;IO事件的监听&lt;/code&gt;，&lt;code&gt;IO操作的执行&lt;/code&gt;，&lt;code&gt;IO结果的dispatch&lt;/code&gt;统统交给&lt;code&gt;内核&lt;/code&gt;来做。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4403225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEGKYKib71IWfbpGh4URSHfiaPhTiaWfQVZuJzfg4PwDXm7E6iacaMUrnsVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;proactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;Proactor模型&lt;/code&gt;组件介绍：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;completion handler&lt;/code&gt; 为用户程序定义的异步IO操作回调函数，在异步IO操作完成时会被内核回调并通知IO结果。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Completion Event Queue&lt;/code&gt; 异步IO操作完成后，会产生对应的&lt;code&gt;IO完成事件&lt;/code&gt;，将&lt;code&gt;IO完成事件&lt;/code&gt;放入该队列中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Asynchronous Operation Processor&lt;/code&gt; 负责&lt;code&gt;异步IO&lt;/code&gt;的执行。执行完成后产生&lt;code&gt;IO完成事件&lt;/code&gt;放入&lt;code&gt;Completion Event Queue&lt;/code&gt; 队列中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Proactor&lt;/code&gt; 是一个事件循环派发器，负责从&lt;code&gt;Completion Event Queue&lt;/code&gt;中获取&lt;code&gt;IO完成事件&lt;/code&gt;，并回调与&lt;code&gt;IO完成事件&lt;/code&gt;关联的&lt;code&gt;completion handler&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Initiator&lt;/code&gt; 初始化异步操作（&lt;code&gt;asynchronous operation&lt;/code&gt;）并通过&lt;code&gt;Asynchronous Operation Processor&lt;/code&gt;将&lt;code&gt;completion handler&lt;/code&gt;和&lt;code&gt;proactor&lt;/code&gt;注册到内核。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;Proactor模型&lt;/code&gt;执行过程：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户线程发起&lt;code&gt;aio_read&lt;/code&gt;，并告诉&lt;code&gt;内核&lt;/code&gt;用户空间中的读缓冲区地址，以便&lt;code&gt;内核&lt;/code&gt;完成&lt;code&gt;IO操作&lt;/code&gt;将结果放入&lt;code&gt;用户空间&lt;/code&gt;的读缓冲区，用户线程直接可以读取结果（&lt;code&gt;无任何阻塞&lt;/code&gt;）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Initiator&lt;/code&gt; 初始化&lt;code&gt;aio_read&lt;/code&gt;异步读取操作（&lt;code&gt;asynchronous operation&lt;/code&gt;）,并将&lt;code&gt;completion handler&lt;/code&gt;注册到内核。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在&lt;code&gt;Proactor&lt;/code&gt;中我们关心的&lt;code&gt;IO完成事件&lt;/code&gt;：内核已经帮我们读好数据并放入我们指定的读缓冲区，用户线程可以直接读取。在&lt;code&gt;Reactor&lt;/code&gt;中我们关心的是&lt;code&gt;IO就绪事件&lt;/code&gt;：数据已经到来，但是需要用户线程自己去读取。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;此时用户线程就可以做其他事情了，无需等待IO结果。而内核与此同时开始异步执行IO操作。当&lt;code&gt;IO操作&lt;/code&gt;完成时会产生一个&lt;code&gt;completion event&lt;/code&gt;事件，将这个&lt;code&gt;IO完成事件&lt;/code&gt;放入&lt;code&gt;completion event queue&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Proactor&lt;/code&gt;从&lt;code&gt;completion event queue&lt;/code&gt;中取出&lt;code&gt;completion event&lt;/code&gt;，并回调与&lt;code&gt;IO完成事件&lt;/code&gt;关联的&lt;code&gt;completion handler&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在&lt;code&gt;completion handler&lt;/code&gt;中完成业务逻辑处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Reactor与Proactor对比&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Reactor&lt;/code&gt;是基于&lt;code&gt;NIO&lt;/code&gt;实现的一种&lt;code&gt;IO线程模型&lt;/code&gt;，&lt;code&gt;Proactor&lt;/code&gt;是基于&lt;code&gt;AIO&lt;/code&gt;实现的&lt;code&gt;IO线程模型&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Reactor&lt;/code&gt;关心的是&lt;code&gt;IO就绪事件&lt;/code&gt;，&lt;code&gt;Proactor&lt;/code&gt;关心的是&lt;code&gt;IO完成事件&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在&lt;code&gt;Proactor&lt;/code&gt;中，用户程序需要向内核传递&lt;code&gt;用户空间的读缓冲区地址&lt;/code&gt;。&lt;code&gt;Reactor&lt;/code&gt;则不需要。这也就导致了在&lt;code&gt;Proactor&lt;/code&gt;中每个并发操作都要求有独立的缓存区，在内存上有一定的开销。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Proactor&lt;/code&gt; 的实现逻辑复杂，编码成本较 &lt;code&gt;Reactor&lt;/code&gt;要高很多。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Proactor&lt;/code&gt; 在处理&lt;code&gt;高耗时 IO&lt;/code&gt;时的性能要高于 &lt;code&gt;Reactor&lt;/code&gt;，但对于&lt;code&gt;低耗时 IO&lt;/code&gt;的执行效率提升&lt;code&gt;并不明显&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Netty的IO模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们介绍完&lt;code&gt;网络数据包在内核中的收发过程&lt;/code&gt;以及五种&lt;code&gt;IO模型&lt;/code&gt;和两种&lt;code&gt;IO线程模型&lt;/code&gt;后，现在我们来看下&lt;code&gt;netty&lt;/code&gt;中的IO模型是什么样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们介绍&lt;code&gt;Reactor IO线程模型&lt;/code&gt;的时候提到有三种&lt;code&gt;Reactor模型&lt;/code&gt;：&lt;code&gt;单Reactor单线程&lt;/code&gt;，&lt;code&gt;单Reactor多线程&lt;/code&gt;，&lt;code&gt;主从Reactor多线程&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三种&lt;code&gt;Reactor模型&lt;/code&gt;在&lt;code&gt;netty&lt;/code&gt;中都是支持的，但是我们常用的是&lt;code&gt;主从Reactor多线程模型&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们之前介绍的三种&lt;code&gt;Reactor&lt;/code&gt;只是一种模型，是一种设计思想。实际上各种网络框架在实现中并不是严格按照模型来实现的，会有一些小的不同，但大体设计思想上是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下&lt;code&gt;netty&lt;/code&gt;中的&lt;code&gt;主从Reactor多线程模型&lt;/code&gt;是什么样子的？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.567741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEqBHAhkKJCkVgiaazsXibAeyzHXtCy8fB3JPwWlq0LL8kWQG6OVwFYDgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;netty中的reactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Reactor&lt;/code&gt;在&lt;code&gt;netty&lt;/code&gt;中是以&lt;code&gt;group&lt;/code&gt;的形式出现的，&lt;code&gt;netty&lt;/code&gt;中将&lt;code&gt;Reactor&lt;/code&gt;分为两组，一组是&lt;code&gt;MainReactorGroup&lt;/code&gt;也就是我们在编码中常常看到的&lt;code&gt;EventLoopGroup bossGroup&lt;/code&gt;,另一组是&lt;code&gt;SubReactorGroup&lt;/code&gt;也就是我们在编码中常常看到的&lt;code&gt;EventLoopGroup workerGroup&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;MainReactorGroup&lt;/code&gt;中通常只有一个&lt;code&gt;Reactor&lt;/code&gt;，专门负责做最重要的事情，也就是监听连接&lt;code&gt;accept&lt;/code&gt;事件。当有连接事件产生时，在对应的处理&lt;code&gt;handler acceptor&lt;/code&gt;中创建初始化相应的&lt;code&gt;NioSocketChannel&lt;/code&gt;（代表一个&lt;code&gt;Socket连接&lt;/code&gt;）。然后以&lt;code&gt;负载均衡&lt;/code&gt;的方式在&lt;code&gt;SubReactorGroup&lt;/code&gt;中选取一个&lt;code&gt;Reactor&lt;/code&gt;，注册上去，监听&lt;code&gt;Read事件&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;MainReactorGroup&lt;/code&gt;中只有一个&lt;code&gt;Reactor&lt;/code&gt;的原因是，通常我们服务端程序只会&lt;code&gt;绑定监听&lt;/code&gt;一个端口，如果要&lt;code&gt;绑定监听&lt;/code&gt;多个端口，就会配置多个&lt;code&gt;Reactor&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;SubReactorGroup&lt;/code&gt;中有多个&lt;code&gt;Reactor&lt;/code&gt;，具体&lt;code&gt;Reactor&lt;/code&gt;的个数可以由系统参数 &lt;code&gt;-D io.netty.eventLoopThreads&lt;/code&gt;指定。默认的&lt;code&gt;Reactor&lt;/code&gt;的个数为&lt;code&gt;CPU核数 * 2&lt;/code&gt;。&lt;code&gt;SubReactorGroup&lt;/code&gt;中的&lt;code&gt;Reactor&lt;/code&gt;主要负责监听&lt;code&gt;读写事件&lt;/code&gt;，每一个&lt;code&gt;Reactor&lt;/code&gt;负责监听一组&lt;code&gt;socket连接&lt;/code&gt;。将全量的连接&lt;code&gt;分摊&lt;/code&gt;在多个&lt;code&gt;Reactor&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一个&lt;code&gt;Reactor&lt;/code&gt;分配一个&lt;code&gt;IO线程&lt;/code&gt;，这个&lt;code&gt;IO线程&lt;/code&gt;负责从&lt;code&gt;Reactor&lt;/code&gt;中获取&lt;code&gt;IO就绪事件&lt;/code&gt;，执行&lt;code&gt;IO调用获取IO数据&lt;/code&gt;，执行&lt;code&gt;PipeLine&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;Socket连接&lt;/code&gt;在创建后就被&lt;code&gt;固定的分配&lt;/code&gt;给一个&lt;code&gt;Reactor&lt;/code&gt;，所以一个&lt;code&gt;Socket连接&lt;/code&gt;也只会被一个固定的&lt;code&gt;IO线程&lt;/code&gt;执行，每个&lt;code&gt;Socket连接&lt;/code&gt;分配一个独立的&lt;code&gt;PipeLine&lt;/code&gt;实例，用来编排这个&lt;code&gt;Socket连接&lt;/code&gt;上的&lt;code&gt;IO处理逻辑&lt;/code&gt;。这种&lt;code&gt;无锁串行化&lt;/code&gt;的设计的目的是为了防止多线程并发执行同一个socket连接上的&lt;code&gt;IO逻辑处理&lt;/code&gt;，防止出现&lt;code&gt;线程安全问题&lt;/code&gt;。同时使系统吞吐量达到最大化&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由于每个&lt;code&gt;Reactor&lt;/code&gt;中只有一个&lt;code&gt;IO线程&lt;/code&gt;，这个&lt;code&gt;IO线程&lt;/code&gt;既要执行&lt;code&gt;IO活跃Socket连接&lt;/code&gt;对应的&lt;code&gt;PipeLine&lt;/code&gt;中的&lt;code&gt;ChannelHandler&lt;/code&gt;，又要从&lt;code&gt;Reactor&lt;/code&gt;中获取&lt;code&gt;IO就绪事件&lt;/code&gt;，执行&lt;code&gt;IO调用&lt;/code&gt;。所以&lt;code&gt;PipeLine&lt;/code&gt;中&lt;code&gt;ChannelHandler&lt;/code&gt;中执行的逻辑不能耗时太长，尽量将耗时的业务逻辑处理放入单独的业务线程池中处理，否则会影响其他连接的&lt;code&gt;IO读写&lt;/code&gt;，从而近一步影响整个服务程序的&lt;code&gt;IO吞吐&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当&lt;code&gt;IO请求&lt;/code&gt;在业务线程中完成相应的业务逻辑处理后，在业务线程中利用持有的&lt;code&gt;ChannelHandlerContext&lt;/code&gt;引用将响应数据在&lt;code&gt;PipeLine&lt;/code&gt;中反向传播，最终写回给客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;netty&lt;/code&gt;中的&lt;code&gt;IO模型&lt;/code&gt;我们介绍完了，下面我们来简单介绍下在&lt;code&gt;netty&lt;/code&gt;中是如何支持前边提到的三种&lt;code&gt;Reactor模型&lt;/code&gt;的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;配置单Reactor单线程&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;EventLoopGroup eventGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;ServerBootstrap serverBootstrap = &lt;span&gt;new&lt;/span&gt; ServerBootstrap(); &lt;br/&gt;serverBootstrap.group(eventGroup);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;配置多Reactor线程&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;EventLoopGroup eventGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;br/&gt;ServerBootstrap serverBootstrap = &lt;span&gt;new&lt;/span&gt; ServerBootstrap(); &lt;br/&gt;serverBootstrap.group(eventGroup);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;配置主从Reactor多线程&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;EventLoopGroup bossGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(&lt;span&gt;1&lt;/span&gt;); &lt;br/&gt;EventLoopGroup workerGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;br/&gt;ServerBootstrap serverBootstrap = &lt;span&gt;new&lt;/span&gt; ServerBootstrap(); &lt;br/&gt;serverBootstrap.group(bossGroup, workerGroup);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文是一篇信息量比较大的文章，用了&lt;code&gt;25&lt;/code&gt;张图，&lt;code&gt;22336&lt;/code&gt;个字从内核如何处理网络数据包的收发过程开始展开，随后又在&lt;code&gt;内核角度&lt;/code&gt;介绍了经常容易混淆的&lt;code&gt;阻塞与非阻塞&lt;/code&gt;，&lt;code&gt;同步与异步&lt;/code&gt;的概念。以这个作为铺垫，我们通过一个&lt;code&gt;C10K&lt;/code&gt;的问题，引出了五种&lt;code&gt;IO模型&lt;/code&gt;，随后在&lt;code&gt;IO多路复用&lt;/code&gt;中以技术演进的形式介绍了&lt;code&gt;select,poll,epoll&lt;/code&gt;的原理和它们综合的对比。最后我们介绍了两种&lt;code&gt;IO线程模型&lt;/code&gt;以及&lt;code&gt;netty&lt;/code&gt;中的&lt;code&gt;Reactor模型&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感谢大家听我唠叨到这里，哈哈，现在大家可以揉揉眼，伸个懒腰，好好休息一下了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea4f4e4a06073f669cd7ee9a4e55c9e4</guid>
<title>求求你别在用SpringMVC了，太Low了！Spring又官宣了一个更牛逼的替代框架！</title>
<link>https://toutiao.io/k/5gti4d9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;spring-webflux&lt;/code&gt;是spring在5.0版本后提供的一套响应式编程风格的web开发框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个框架包含了&lt;code&gt;spring-framework&lt;/code&gt;和spring mvc，它可以运行在Netty、Undertow以及3.1版本以上的Serlvet容器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以在项目中同时使用&lt;code&gt;spring-webmvc&lt;/code&gt;和&lt;code&gt;spring-webflux&lt;/code&gt;，或者只用其中一个来开发web应用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是“响应式”&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓响应式，举个例子，当调用一个api获取数据时，无需阻塞等待数据返回，而是当有数据返回时会进行告知。可见响应式是非阻塞的，意味着调用方法后，CPU可以去做别的事情，当接收到数据响应时CPU再回来处理，这种方式提高了系统的吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而响应式编程，其实是为这种异步非阻塞的流式编程制定的一套标准。流式编程已不陌生了，Java8提供的stream api就是这种风格。这套标准包括对运行环境（JVM、JavaScript）以及网络协议相关的规范。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Spring-webflux的响应式API&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Spring-webflux&lt;/code&gt;框架是基于Reactor这个开源项目开发的。Reactor框架是跟Spring紧密配合的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它提供了两种API类型，分别是Mono和Flux；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Mono一般作用于单个对象&lt;/span&gt;&lt;br/&gt;Mono&amp;lt;Person&amp;gt; person = personDao.getPerson(personId);&lt;br/&gt;&lt;span&gt;// Flux一般作用于多个对象&lt;/span&gt;&lt;br/&gt;Flux&amp;lt;Person&amp;gt; people = personDao.listAllPeople();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管webflux框架基于Reactor，它也能与其他的响应式框架同时使用，比如RxJava。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;选择Spring-webmvc还是Spring-webflux呢&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个web框架分别代表着两种不同类型的编程流派，官方给出了一个图作为对比如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5748792270531401&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhqIINVW9vuiaQD3u3u3Vo1t9ffrbJz8mfzVF0ItW7maqibNn85abyLzoIHRPr04bRNlOCy6tbJ1Ba8g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1656&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据官方的建议有以下几点可以作为参考：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果你已经使用了&lt;/span&gt;&lt;code&gt;&lt;span&gt;Spring-webmvc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;进行开发，并且项目运行良好，就无需更改了；何况现在大多数的三方库都是阻塞的，并不能发挥出非阻塞的优势。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;webflux&lt;/span&gt;&lt;/code&gt;&lt;span&gt;提供了相当多的选择；在服务层，可以使用(Netty, Tomcat, Jetty, Undertow, 和3.1版本以上的Servlet容器)作为web服务；在应用层，可以选择用&lt;/span&gt;&lt;code&gt;&lt;span&gt;@Controller&lt;/span&gt;&lt;/code&gt;&lt;span&gt;定义还是使用函数编程定义；在编程风格上，可以选择用Reactor、RxJava或其他。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果你钟爱Java8提供的lambda表达式这种轻量级、函数式的编程风格，那么建议选择用webflux；同时对于一些轻量级应用，或者复杂度比较低的微服务，建议使用webflux以便更好的进行控制。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在微服务架构中，可以将webmvc和webflux项目混合使用。两个框架都可以使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;@Controller&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这种注解的方式，使得项目的重用更加容易。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;评估一个项目是否应该选择webflux的最简单的方式是，依据项目中是否会使用很多的阻塞API，比如JDBC或者一些阻塞式的API就不适用与webflux项目。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果一个webmvc项目中有很多的外部系统调用，可以试试响应式的&lt;/span&gt;&lt;code&gt;&lt;span&gt;WebClient&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，它能直接从&lt;/span&gt;&lt;code&gt;&lt;span&gt;Controller&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的方法中返回响应式结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;响应式编程的学习路线是比较陡峭的，所以如果你身在一个大型的团队中，要考虑投入的成本；不过可以用用&lt;/span&gt;&lt;code&gt;&lt;span&gt;WebClient&lt;/span&gt;&lt;/code&gt;&lt;span&gt;来体验下响应式编程。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Spring-webflux&lt;/code&gt;不仅可以支持在Tomcat、Jetty以及3.1版本以上的Servlet容器上，还能够运行在非Servlet的服务器之上，比如Netty、Undertow等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Springboot构建一个webflux应用，默认就是使用Netty，因为Netty本身就是非阻塞式的实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并发模型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管webmvc和webflux都支持使用注解来定义一个Controller，但是其实现方式完全不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;webmvc是一个Servlet应用，实现是阻塞式IO，其维护一个线程池来处理每一个用户请求，也就是当Servlet容器启动时，就会创建比如10个线程出来，因此系统吞吐量的瓶颈在于有限的连接数和阻塞的请求处理过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;webflux可以基于netty这样的NIO网络框架，它只需要很少的几个工作线程（Event loop worker）就能够处理并响应请求。由于无需阻塞等待方法返回，CPU资源就得到了更好的利用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;webflux并不能让程序运行地更快；而是提高了并发处理请求的能力，即提高了系统吞吐量。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;webflux代码示例&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Talk is cheap, show me the code&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面让我们来看一下webflux的示例，总的来说使用上是非常便捷的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用Springboot构建一个webflux应用非常简单，仅仅需要加入这么一个依赖&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-webflux&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先定义一个对象&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer age;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后定义“&lt;code&gt;PersonController&lt;/code&gt;”，响应式风格中不再使用&lt;code&gt;@RequestMapping&lt;/code&gt;声明地址映射了，而是通过&lt;code&gt;RouterFunctions.route().GET()&lt;/code&gt;方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonRouter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PersonHandler personHandler;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouterFunction&amp;lt;ServerResponse&amp;gt; &lt;span&gt;personRoutes&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; RouterFunctions.route()&lt;br/&gt;                .GET(&lt;span&gt;&quot;/person/{id}&quot;&lt;/span&gt;, RequestPredicates.accept(MediaType.APPLICATION_JSON), personHandler::getPerson)&lt;br/&gt;                .GET(&lt;span&gt;&quot;/person&quot;&lt;/span&gt;, RequestPredicates.accept(MediaType.APPLICATION_JSON), personHandler::listPeople)&lt;br/&gt;                .POST(&lt;span&gt;&quot;/person&quot;&lt;/span&gt;, personHandler::createPerson)&lt;br/&gt;                .build();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;PersonHandler&lt;/code&gt;中处理对应的HTTP请求，等同于MVC架构中的Service层&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PersonRepository personDao;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt; &lt;span&gt;listPeople&lt;/span&gt;&lt;span&gt;(ServerRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Flux&amp;lt;Person&amp;gt; people = personDao.listAllPeople();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ServerResponse.ok()&lt;br/&gt;                .contentType(MediaType.APPLICATION_JSON)&lt;br/&gt;                .body(people, Person&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt; &lt;span&gt;createPerson&lt;/span&gt;&lt;span&gt;(ServerRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Mono&amp;lt;Person&amp;gt; person = request.bodyToMono(Person&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ServerResponse.ok()&lt;br/&gt;                .build(personDao.savePerson(person));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt; &lt;span&gt;getPerson&lt;/span&gt;&lt;span&gt;(ServerRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; personId = Integer.parseInt(request.pathVariable(&lt;span&gt;&quot;id&quot;&lt;/span&gt;));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; personDao.getPerson(personId)&lt;br/&gt;                .flatMap(person -&amp;gt; ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).bodyValue(person))&lt;br/&gt;                .switchIfEmpty(ServerResponse.notFound().build());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过启动日志可以证实&lt;code&gt;Spring-webflux&lt;/code&gt;是默认使用Netty提供HTTP服务&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.055741360089186176&quot; data-type=&quot;png&quot; data-w=&quot;1794&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhqIINVW9vuiaQD3u3u3Vo1t9JxwrQB8YibHJkS2ZuIRmAQbEML4zUmJIuTTWKOtCAsYFMY0J7T3Xb6Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目启动之后浏览器访问&lt;code&gt;http://localhost:8080/person/1&lt;/code&gt;就能发现，你的Spring-webflux项目已经正常工作了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ac51b5e622769376249ccebaaf1c6243</guid>
<title>Python爬虫之xpath语法及案例使用</title>
<link>https://toutiao.io/k/vx7c0aa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;---- 钢铁侠的知识库 2022.08.15&lt;/p&gt;

&lt;p&gt;我们在写Python爬虫时，经常需要对网页提取信息，如果用传统正则表达去写会增加很多工作量，此时需要一种对数据解析的方法，也就是本章要介绍的Xpath表达式。&lt;/p&gt;

&lt;h2&gt;Xpath是什么&lt;/h2&gt;

&lt;p&gt;XPath，全称 &lt;strong&gt;XML Path Language&lt;/strong&gt;，即 XML 路径语言，它是一门在 XML 文档中查找信息的语言。最初是用来搜寻 XML 文档的，但同样适用于 HTML 文档的搜索。所以在做爬虫时完全可以使用 XPath 做相应的信息抽取。&lt;/p&gt;

&lt;p&gt;XPath 的选择功能十分强大，它提供了非常简洁明了的路径选择表达式。另外，它还提供超过 100 个内置函数，用于字符串、数值、时间的匹配以及节点、序列的处理等，几乎所有想要定位的节点都可以用 XPath 来选取。&lt;/p&gt;

&lt;p&gt;下面介绍实战中常用的几个知识点，详细也可以看W3C介绍：&lt;a href=&quot;https://www.w3school.com.cn/xpath/index.asp&quot;&gt;https://www.w3school.com.cn/xpath/index.asp&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Xpath语法介绍&lt;/h2&gt;

&lt;h3&gt;路径常用规则&lt;/h3&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th/&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;nodename&lt;/td&gt;
&lt;td&gt;选取此节点的所有子节点&lt;/td&gt;
&lt;td&gt;xpath(&#x27;//div&#x27;)&lt;/td&gt;
&lt;td&gt;选取了div节点的所有子节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;从根节点选取&lt;/td&gt;
&lt;td&gt;xpath(&#x27;/div&#x27;)&lt;/td&gt;
&lt;td&gt;从根节点上选取div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;//&lt;/td&gt;
&lt;td&gt;选取所有当前节点，不考虑位置&lt;/td&gt;
&lt;td&gt;xpath(&#x27;//div&#x27;)&lt;/td&gt;
&lt;td&gt;选取所有的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;选取当前节点&lt;/td&gt;
&lt;td&gt;xpath(&#x27;./div&#x27;)&lt;/td&gt;
&lt;td&gt;选取当前节点下的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;..&lt;/td&gt;
&lt;td&gt;选取当前节点的父节点&lt;/td&gt;
&lt;td&gt;xpath(&#x27;..&#x27;)&lt;/td&gt;
&lt;td&gt;回到上一个节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;选取属性&lt;/td&gt;
&lt;td&gt;xpath（&#x27;//@calss&#x27;）&lt;/td&gt;
&lt;td&gt;选取所有的class属性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;谓语规则&lt;/h3&gt;

&lt;p&gt;谓语被嵌在方括号内，用来查找某个特定的节点或包含某个制定的值的节点&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[1]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下的第一个div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[last()]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下最后一个div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[last()-1]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下倒数第二个div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[positon()&amp;lt;3]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下前两个div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[@class]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下带有class属性的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[@class=&quot;main&quot;]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下class属性为main的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[price&amp;gt;35.00]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下price元素值大于35的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;通配符&lt;/h3&gt;

&lt;p&gt;通配符来选取未知的XML元素&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;xpath（&#x27;/div/*&#x27;）&lt;/td&gt;
&lt;td&gt;选取div下的所有子节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/div[@*]&#x27;)&lt;/td&gt;
&lt;td&gt;选取所有带属性的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;取多个路径&lt;/h3&gt;

&lt;p&gt;使用“|”运算符可以选取多个路径 &lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;//div|//table&#x27;)&lt;/td&gt;
&lt;td&gt;选取所有的div和table节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;功能函数&lt;/h3&gt;

&lt;p&gt;使用功能函数能够更好的进行模糊搜索&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;用法&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;starts-with&lt;/td&gt;
&lt;td&gt;xpath(&#x27;//div[starts-with(@id,&quot;ma&quot;)]&#x27;)&lt;/td&gt;
&lt;td&gt;选取id值以ma开头的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;contains&lt;/td&gt;
&lt;td&gt;xpath(&#x27;//div[contains(@id,&quot;ma&quot;)]&#x27;)&lt;/td&gt;
&lt;td&gt;选取id值包含ma的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;xpath(&#x27;//div[contains(@id,&quot;ma&quot;) and contains(@id,&quot;in&quot;)]&#x27;)&lt;/td&gt;
&lt;td&gt;选取id值包含ma和in的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text()&lt;/td&gt;
&lt;td&gt;xpath(&#x27;//div[contains(text(),&quot;ma&quot;)]&#x27;)&lt;/td&gt;
&lt;td&gt;选取节点文本包含ma的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;语法熟悉&lt;/h3&gt;

&lt;p&gt;下面举一段HTML文本进行语法热身，代码如下&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
# time: 2022/8/8 0:05
# author: gangtie
# email: 648403020@qq.com
from lxml import etree

text = &#x27;&#x27;&#x27;
&amp;lt;div&amp;gt;
            &amp;lt;ul id=&#x27;ultest&#x27;&amp;gt;
                 &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                 &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                 &amp;lt;li class=&quot;item-inactive&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;third item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                 &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;&amp;lt;span&amp;gt;fourth item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                 &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt;
             &amp;lt;/ul&amp;gt;
         &amp;lt;/div&amp;gt;
&#x27;&#x27;&#x27;
# 调用HTML类进行初始化，这样就成功构造了一个XPath解析对象。
# 利用etree.HTML解析字符串
page = etree.HTML(text)   
print(type(page))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到打印结果已经变成XML元素：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;&amp;lt;class &#x27;lxml.etree._Element&#x27;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;字符串转换HTML&lt;/h4&gt;

&lt;p&gt;字符串利用etree.HTML解析成html格式：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;print(etree.tostring(page,encoding=&#x27;utf-8&#x27;).decode(&#x27;utf-8&#x27;))

&lt;/code&gt;&lt;/pre&gt;

&lt;p/&gt;


&lt;p&gt;Process finished with exit code 0&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;p&gt;经过处理可以看到缺失的&lt;code&gt;&amp;lt;/li&amp;gt;&lt;/code&gt;也自动补全了，还自动添加html、body节点。&lt;/p&gt;

&lt;h4&gt;查找绝对路径&lt;/h4&gt;

&lt;p&gt;通过绝对路径获取a标签的所有内容&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;a = page.xpath(&quot;/html/body/div/ul/li/a&quot;)
for i in a:
    print(i.text)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;first item
second item
third item
None
fifth item&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;h4&gt;查找相对路径(常用)&lt;/h4&gt;

&lt;p&gt;查找所有li标签下的a标签内容&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html = etree.HTML(text)
a = html.xpath(&quot;//a/text()&quot;)
print(a)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&#x27;first item&#x27;, &#x27;second item&#x27;, &#x27;third item&#x27;, &#x27;fifth item&#x27;]&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;h4&gt;当前标签节点&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;.&lt;/code&gt; 表示选取当前标签的节点。&lt;/p&gt;

&lt;p&gt;我们先定位 ul 元素节点得到一个列表，打印当前节点列表得到第一个 ul，
接着打印 ul 节点的子节点 li，text()输出。&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;page = etree.HTML(text)
ul = page.xpath(&quot;//ul&quot;)
print(ul)
print(ul[0].xpath(&quot;.&quot;))
print(ul[0].xpath(&quot;./li&quot;))
print(ul[0].xpath(&quot;./li/a/text()&quot;))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&lt;element ul=&quot;&quot; at=&quot;&quot;&gt;]
[&lt;element ul=&quot;&quot; at=&quot;&quot;&gt;]
[&lt;element li=&quot;&quot; at=&quot;&quot;&gt;, &lt;element li=&quot;&quot; at=&quot;&quot;&gt;, &lt;element li=&quot;&quot; at=&quot;&quot;&gt;, &lt;element li=&quot;&quot; at=&quot;&quot;&gt;, &lt;element li=&quot;&quot; at=&quot;&quot;&gt;]
[&#x27;first item&#x27;, &#x27;second item&#x27;, &#x27;third item&#x27;, &#x27;fifth item&#x27;]&lt;/element&gt;&lt;/element&gt;&lt;/element&gt;&lt;/element&gt;&lt;/element&gt;&lt;/element&gt;&lt;/element&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;h4&gt;父节点&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;..&lt;/code&gt; 表示选取当前标签的父节点。&lt;/p&gt;

&lt;p&gt;可以看到得到ul的上一级div&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;page = etree.HTML(text)
ul = page.xpath(&quot;//ul&quot;)
print(ul[0].xpath(&quot;.&quot;))
print(ul[0].xpath(&quot;..&quot;))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&lt;element ul=&quot;&quot; at=&quot;&quot;&gt;]
[&lt;element div=&quot;&quot; at=&quot;&quot;&gt;]&lt;/element&gt;&lt;/element&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;h4&gt;属性匹配&lt;/h4&gt;

&lt;p&gt;匹配时可以用@符号进行属性过滤
查找a标签下属性href值为link2.html的内容&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html = etree.HTML(text)
a = html.xpath(&quot;//a[@href=&#x27;link2.html&#x27;]/text()&quot;)
print(a)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&#x27;second item&#x27;]&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;h4&gt;函数&lt;/h4&gt;

&lt;p&gt;last()：查找最后一个li标签里的a标签的href属性&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html = etree.HTML(text)
a = html.xpath(&quot;//li[last()]/a/text()&quot;)
print(a)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&#x27;fifth item&#x27;]&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;p&gt;contains：查找a标签中属性href包含link的节点，并文本输出&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html = etree.HTML(text)
a = html.xpath(&quot;//a[contains(@href, &#x27;link&#x27;)]/text()&quot;)
print(a)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&#x27;first item&#x27;, &#x27;second item&#x27;, &#x27;third item&#x27;, &#x27;fifth item&#x27;]&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;h2&gt;实战案例&lt;/h2&gt;

&lt;p&gt;上面说完基本用法，接下来做几个实战案例练练手。&lt;/p&gt;

&lt;h3&gt;案例一：豆瓣读书&lt;/h3&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;#  -*-coding:utf8 -*-
# 1.请求并提取需要的字段
# 2.保存需要的数据
import requests
from lxml import etree

class DoubanBook():

    def __init__(self):
        self.base_url = &#x27;https://book.douban.com/chart?subcat=all&amp;amp;icn=index-topchart-popular&#x27;
        self.headers = {
            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#x27;
                          &#x27;Chrome/104.0.0.0 Safari/537.36&#x27;
        }

    # 请求并提取需要的字段
    def crawl(self):
        res = requests.get(self.base_url, headers=self.headers)
        lis = etree.HTML(res.text).xpath(&#x27;//*[@id=&quot;content&quot;]/div/div[1]/ul/li&#x27;)
        # print(type(lis))
        books = []
        for li in lis:
            # print(etree.tostring(li,encoding=&#x27;utf-8&#x27;).decode(&#x27;utf-8&#x27;))
            # print(&quot;==================================================&quot;)
            title = &quot;&quot;.join(li.xpath(&quot;.//a[@class=&#x27;fleft&#x27;]/text()&quot;))
            score = &quot;&quot;.join(li.xpath(&quot;.//p[@class=&#x27;clearfix w250&#x27;]/span[2]/text()&quot;))
            # list输出带有[&#x27;\n                    刘瑜 / 2022-4 / 广西师范大学出版社 / 82.00元 / 精装\n                &#x27;]
            publishing = &quot;&quot;.join(li.xpath(&quot;.//p[@class=&#x27;subject-abstract color-gray&#x27;]/text()&quot;)).strip()
            book = {
                &#x27;title&#x27;: title,
                &#x27;score&#x27;: score,
                &#x27;publishing&#x27;: publishing,
            }
            books.append(book)
        self.save_data(books)

    def save_data(self, datas):
            with open(&#x27;books.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:
                f.write(str(datas))

    def run(self):
        self.crawl()

if __name__ == &#x27;__main__&#x27;:
    DoubanBook().run()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;案例二：彼岸图片下载&lt;/h3&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
# author: 钢铁知识库
# email: 648403020@qq.com

import os
import requests
from lxml import etree

# 彼岸图片下载
class BiAn():

    def __init__(self):
        self.url = &#x27;https://pic.netbian.com&#x27;
        self.headers = {
            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#x27;
                          &#x27;Chrome/104.0.0.0 Safari/537.36&#x27;,
            &#x27;cookie&#x27;: &#x27;__yjs_duid=1_cb922eedbda97280755010e53b2caca41659183144320; Hm_lvt_c59f2e992a863c2744e1ba985abaea6c=1649863747,1660203266; zkhanecookieclassrecord=%2C23%2C54%2C55%2C66%2C60%2C; Hm_lpvt_c59f2e992a863c2744e1ba985abaea6c=1660207771; yjs_js_security_passport=1225f36e8501b4d95592e5e7d5202f4081149e51_1630209607_js&#x27;
        }
        # 如果目录不存在会报错
        if not os.path.exists(&#x27;BianPicture&#x27;):
            os.mkdir(&#x27;BianPicture&#x27;)

    # 请求拿到ul列表
    def crawl(self):
        res = requests.get(self.url, headers=self.headers)
        res.encoding = &#x27;gbk&#x27;
        uls = etree.HTML(res.text).xpath(&#x27;//div[@class=&quot;slist&quot;]/ul[@class=&quot;clearfix&quot;]/li&#x27;)
        # print(etree.tostring(uls,encoding=&#x27;gbk&#x27;).decode(&#x27;gbk&#x27;))

        # 循环拿到图片名、图片地址，拼接请求再次下载到图片
        for ul in uls:
            img_name = ul.xpath(&#x27;.//a/b/text()&#x27;)[0]
            img_src = ul.xpath(&#x27;.//a/span/img/@src&#x27;)[0]
            # print(img_name + img_src)
            img_url = self.url + img_src
            # 拼接后下载图片，转义Bytes
            img_res = requests.get(img_url, headers=self.headers).content
            img_path = &quot;BianPicture/&quot; + img_name + &quot;.jpg&quot;
            data = {
                &#x27;img_res&#x27;: img_res,
                &#x27;img_path&#x27;: img_path
            }
            self.save_data(data)

    # 数据保存逻辑
    def save_data(self, data):
        with open(data[&#x27;img_path&#x27;], &#x27;wb&#x27;) as f:
            f.write(data[&#x27;img_res&#x27;])
        # print(data)

    def run(self):
        self.crawl()

if __name__ == &#x27;__main__&#x27;:
    BiAn().run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/393bf933c5ce91b60536ffa81c991cb4.png&quot; alt=&quot;image-20220812165403134&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;案例三：全国城市名称爬取&lt;/h3&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
# author: 钢铁知识库
# email: 648403020@qq.com
import os

import requests
from lxml import etree

class CityName():
    def __init__(self):
        self.url = &#x27;https://www.aqistudy.cn/historydata/&#x27;
        self.headers = {
            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&#x27;
        }
        # 判断目录是否存在
        if not os.path.exists(&#x27;city_project&#x27;):
            os.mkdir(&#x27;city_project&#x27;)

    def crawl(self):
        res = requests.get(url=self.url, headers=self.headers).text
        uls = etree.HTML(res).xpath(&#x27;//div[@class=&quot;all&quot;]/div[2]/ul/div[2]/li&#x27;)

        all_city_name = list()
        for ul in uls:
            city_name = ul.xpath(&#x27;.//a/text()&#x27;)[0]
            # print(type(city_name))
            all_city_name.append(city_name)
            self.save_data(all_city_name)

    def save_data(self, data):
        with open(&#x27;./city_project/city.txt&#x27;, &#x27;w&#x27;) as f:
            f.write(str(data))

    def run(self):
        self.crawl()

if __name__ == &#x27;__main__&#x27;:
    CityName().run()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;xpath使用工具&lt;/h2&gt;

&lt;h3&gt;chrome生成XPath表达式&lt;/h3&gt;

&lt;p&gt;经常使用chome的朋友都应该知道这功能，在 &lt;code&gt;审查&lt;/code&gt; 状态下(快捷键ctrl+shift+i，F12)，定位到元素(快捷键ctrl+shift+c) ，在Elements选项卡中，右键元素 Copy-&amp;gt;Copy xpath，就能得到该元素的xpath了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/2a6d8f8b9ab4dd09ffc0ef74bcd95316.png&quot; alt=&quot;image-20220808172320534&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;Xpath Helper插件&lt;/h3&gt;

&lt;p&gt;为chome装上XPath Helper就可以很轻松的检验自己的xpath是否正确了。安装插件需要科学上网，安装好插件后，在chrome右上角点插件的图标，调出插件的黑色界面，编辑好xpath表达式，表达式选中的元素被标记为黄色&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/082fcb74e383529f489803f511c98fd0.png&quot; alt=&quot;image-20220808172538959&quot;/&gt;&lt;/p&gt;

&lt;p&gt;---- 钢铁侠的知识库 2022.08.15&lt;/p&gt;

&lt;h2&gt;结语：&lt;/h2&gt;

&lt;p&gt;以上就是利用XPath的所有用法，从常用语法，到案例练习都走了一遍。下一章 钢铁知识库 会继续介绍另一种好用的解析框架，Beautiful Soup，觉得有用点赞加关注，就当你送了红包666&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>