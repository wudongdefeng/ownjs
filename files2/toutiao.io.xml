<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2dd63a1b544a8398cb3cff7a6c05cd5c</guid>
<title>微服务架构下 CI/CD 如何落地</title>
<link>https://toutiao.io/k/303m5ez</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;blockquote&gt;本文系云原生应用最佳实践杭州站活动演讲稿整理。杭州站活动邀请了 Apache APISIX 项目 VP 温铭、又拍云平台开发部高级工程师莫红波、蚂蚁金服技术专家王发康、有赞中间件开发工程师张超，分享云原生落地应用的经验心得，以下是莫红波《微服务架构下 CI/CD 如何落地》分享内容。&lt;/blockquote&gt;&lt;p&gt;莫红波，又拍云平台开发部高级工程师，目前专注于容器及虚拟化技术在又拍云的私有云实践，主要负责又拍云容器云的设计和开发工作。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-be6b7e97fb14baa6e5f2469bc106ef5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;818&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-be6b7e97fb14baa6e5f2469bc106ef5f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;818&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-be6b7e97fb14baa6e5f2469bc106ef5f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-be6b7e97fb14baa6e5f2469bc106ef5f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;大家好，今天分享的主题是《微服务架构下 CI/CD 如何落地》，围绕以下两部分展开：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;理论篇，讨论从单体到微服务的过程中会面临怎样的挑战，以及微服务的测试模型&lt;/li&gt;&lt;li&gt;实践篇，围绕集成测试环境的服务发现需要怎么做，如何落地持续交付和持续部署&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;或许大家对于互联网公司的共同印象是 996，对于我个人而言，互联网公司还有另一个特点，那就是经常需要拥抱变化。在互联网公司，新产品上线、下线、调整，这都是很家常便饭的事情。在这种情况下，一个好的松耦合的架构就显得尤为重要。&lt;/p&gt;&lt;p&gt;刚好我最近就有遇到这个问题，我在做的项目，账号这块是对标 GitHub 的注册制账号机制的。原本的需求是用户注册我们的平台，注册完成后可以创建一个属于自己的团队，并将其他人拉入自己的团队。但是当我们做完这部分内容后发现，客户还是更偏好「账号+子账号」的模式，公司一个总的账号，所有员工单独开子账号进行关联。这让我们已经做好的项目变得非常尴尬，需要立即拥抱变化，需要根据最新的需求进行调整。这时，我就发现拥有一套松耦合的架构的重要性，比如账号这一部分，如果把它单独拎出来，做好足够的抽象，提供必要的对外接口，可能会更加灵活，扩展性更加好。&lt;/p&gt;&lt;p&gt;&lt;b&gt;那怎样拥有一套松耦合的架构？有什么好的方案呢？在我看来有两个，一个是几年前出现的 SOA，即将服务进行单独化，将每一块都进行拆分；另一个就是最近几年火热的微服务了。&lt;/b&gt;我认为，微服务跟 SOA 其实是一回事，只不过微服务比 SOA 拆分粒度更细，功能也更小。&lt;/p&gt;&lt;p&gt;在调研微服务过程中，很多人会有疑问：“我们是一个很小的团队，小团队适不适合上微服务呢？”。因为上微服务就意味着一个服务可能就会被拆分成 10 个、20 个甚至更多个的服务，这就让小团队不得不去考虑自己的测试、部署、更新成本是不是会翻很多倍。&lt;/p&gt;&lt;p&gt;那么我对于“小团队适不适合上微服务”这个问题的答案是什么呢？我认为是完全可以上的，不过你需要注意一点：做好自动化，能交给自动化来实现的，就不要人工介入了。&lt;/p&gt;&lt;p&gt;在聊如何做自动化集成测试（CI）之前，我先和大家谈一谈从单体如何到微服务，服务是如何拆分的，以及微服务的测试一般是怎么做的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;从单体到微服务&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-558bbb277f5d33d1b8b622b521615f7e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;869&quot; data-rawheight=&quot;496&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-558bbb277f5d33d1b8b622b521615f7e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;869&quot; data-rawheight=&quot;496&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-558bbb277f5d33d1b8b622b521615f7e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-558bbb277f5d33d1b8b622b521615f7e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如上图所示，我们可以看到图左边是一个单体服务，右边则是经过微服务拆解后的。我们可以看到它有 4 个特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;根据不同领域拆分&lt;/li&gt;&lt;li&gt;服务之间通过网络协议通信&lt;/li&gt;&lt;li&gt;拥有独立的数据库&lt;/li&gt;&lt;li&gt;拥有特定对外开放的接口&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-701694c6721d9aae9dc6020cc4b120c7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;973&quot; data-rawheight=&quot;512&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-701694c6721d9aae9dc6020cc4b120c7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;973&quot; data-rawheight=&quot;512&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-701694c6721d9aae9dc6020cc4b120c7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-701694c6721d9aae9dc6020cc4b120c7_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 微服务测试模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们都知道，如果需要一个服务能够稳定运行，那测试肯定是少不了的。而就像我们微服务化有一套理论一样，微服务测试也拥有属于自己的金字塔理论：最底层是单元测试，成本相对较低，像我们在 API 认证部分做的签名校验模块，它一般不需要依赖其他东西，因此测试效率也比较高；第二层是集成测试，这一层你就必须要依赖一些第三方的服务模块或者组件，比如我们一般会用到数据库的测试，就属于集成测试的范畴；第三层是 e2e 测试，它会模拟客户端的行为来进行测试，大家也许都接触过这类测试，像K8S 就有一个 e2e 测试，当你去申请 CNCF 的一致性认证时，就需要通过官方提供的 e2e 测试；最上层是 UI 测试，比如对于页面的点击调整是否符合预期，这部分我们现在做的比较弱，还处在人工模式下，但我们也在努力将它更新成自动化。&lt;/p&gt;&lt;p&gt;从这个微服务测试金字塔我们可以看到，越靠近底层成本越低，你只需要几行代码就能完成，效率也非常高。同时越底层它对于三方或组件的依赖也越低，自动化也就越简单。到这里可能就有人想问：“既然越底层的成本越低，那我们能不能只跑单元测试？”在解答这个问题前，大家先看下面这张图。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b4e83ade2740d32abcf00a40d0725b82_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;957&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-b4e83ade2740d32abcf00a40d0725b82_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;957&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-b4e83ade2740d32abcf00a40d0725b82_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b4e83ade2740d32abcf00a40d0725b82_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这两扇窗户，每一扇单独存在的时候都是完好的窗户，可以正常开合。但是两个都安装到墙上后就没有办法正常开合。这就是我们不能只跑单元测试的原因了，不跑集成测试就无法发现一些问题。同理不跑单元测试也会有一些无法发现的问题，所以&lt;b&gt;我们在跑测试的时候，集成测试和单元测试，一项都不能少。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;那具体实践的时候要如何做呢，我推荐大家分成两步来进行：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一步是将底子打好：你需要对你的的微服务进行单元化测试，编写单元化的测试用例，然后再强化集成测试。没有好底子的微服务是不可靠的，任何时候都可能会出问题，而且出问题后的排查会非常费时。&lt;/li&gt;&lt;li&gt;第二步是自动化的持续集成环境：将能够自动化的部分全部进行自动化，减少人工的介入。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;GitLab/CI&lt;/b&gt;&lt;/p&gt;&lt;p&gt;自动化集成环境这块目前已经有很多的开源方案了，比如常见的 Jenkins，还有 GitLab。我们选择的是 GitLab，或者说是选择了 GitLab/CI，选择它的原因有以下几点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;统一的 web 页面&lt;/li&gt;&lt;li&gt;可以再 MR 中跳转查看&lt;/li&gt;&lt;li&gt;Pipeline 编排直观展示&lt;/li&gt;&lt;li&gt;所有操作都在项目中搞定&lt;/li&gt;&lt;li&gt;GitLab 官方支持&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;GitLab WorkFlow&lt;/b&gt;&lt;/p&gt;&lt;p&gt;既然我们选择使用了 GitLab，那我们内部就会严格遵守 GitLab 的 WorkFlow。WorkFlow 主要分为两个部分。&lt;/p&gt;&lt;p&gt;第一部分是面向代码仓库。代码仓库中，我们一般会有三类分支，第一类分支是 master 分支，一般只会有一个，我们会定义 master 分支，并基于这个分支进行线上版本的发布。第二类分支是 develop 分支，一般也只会有一个，develop 分支是从 master 分支中 checkout 出来的，功能比 master 领先，包含一些已经完成功能开发，但是还没有发布的功能。第三类分支是 feature 分支，特性分支，一般会有很多个，新功能都会在这个分支上进行开发，往往一个功能对应一个 feature 分支。最后一类是 hotfix 分支，这个就比较常见了，线上发布后，如果发现了一个需要紧急修复的bug，这时你就可以在 master 分支上 checkout 出来一个 hotfix 分支，把代码改掉。不过进行这个操作时你需要注意，master 分支和 develop 分支都需要进行该 commit 合并，否则就不能算完成了 bug 修复。&lt;/p&gt;&lt;p&gt;第二部分与 CI/CD 有关。以我们的流程举例，研发的同学提交代码到 GitLab 仓库，之后 GitLab 会触发事先约定好的 CI 的 pipeline 进行测试和构建。等待测试和构建成功后再进行 code review 的确认，确认无误后会合并到 develop 分支并最终合并到 master 分支进行发布。这就是 GitLabCI 的一个配置，总结来看可以划分为下图的四个阶段。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dc4e1ba58791fc23afd303818c514a19_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;560&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-dc4e1ba58791fc23afd303818c514a19_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;560&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-dc4e1ba58791fc23afd303818c514a19_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-dc4e1ba58791fc23afd303818c514a19_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;下图是配置文件对应的 pipeline 的展示，大家可以看一下。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4e3aa1ed965d9a696fdc612d2de97c33_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;497&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-4e3aa1ed965d9a696fdc612d2de97c33_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;497&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-4e3aa1ed965d9a696fdc612d2de97c33_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4e3aa1ed965d9a696fdc612d2de97c33_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;微服务下的场景变形&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;其实到目前为止的方案，已经是微服务没有大热前的完备方案了。如果你想要将方案运用到微服务的集成测试里，你还需要做一些变形，不妨参考下图中所示的又拍云现在使用的整套流程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ecf255264c307d4e95fcae4ff2072e5e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;499&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-ecf255264c307d4e95fcae4ff2072e5e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;499&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-ecf255264c307d4e95fcae4ff2072e5e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-ecf255264c307d4e95fcae4ff2072e5e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从图中可以看到，我们目前使用的整套流程相比标准的其实有做一些小的变形，变形主要集中在中间的集成测试环境这一块，我们将每个服务器都部署在了集成环境内，使集成环境变成一个准发布环境。具体流程是，当我们的创建 projectA 后，由它来 push 代码，完成后触发 CI，也就是在 GitLab runner 上进行测试。&lt;/p&gt;&lt;p&gt;在跑测试的过程中，因为 A 服务需要调用 B 和 C 服务，所以通过 API 去请求集成环境中的对应服务。如果测试完成后没有问题，则合并到主线。再通过在 master 分支打 tag 的方式来触发容器构建并推送到 Harbor 镜像仓库。最后我们会做一个线上 release。这个就是我们的大致流程了。&lt;/p&gt;&lt;p&gt;那么接下来我们来具体看一下变形中会遇到的问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;服务发现&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在微服务场景下的变形中遇到了很多问题，我觉得其中值得注意的是“服务发现”。比如我们现在有这样一个场景，A 服务在跑测试时需要依赖 B 服务和 C 服务，面对这个需求，在没有引入 Kubernetes 之前，我们可以通过使用一台共用机器，将服务都布置到这台机器上，并在测试代码里写死 IP 地址，让每一次测试都在这个环境内跑。但这个方法会有下面四个无法忽视的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;服务更新延迟&lt;/li&gt;&lt;li&gt;环境权限混乱&lt;/li&gt;&lt;li&gt;人工操作容易出错&lt;/li&gt;&lt;li&gt;维护成本过高&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此我们引用了 Kubernetes Service 的方案进行优化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Kubernetes Service&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8a70d364f628921d14ad227f39b37f34_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;502&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-8a70d364f628921d14ad227f39b37f34_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;502&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-8a70d364f628921d14ad227f39b37f34_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8a70d364f628921d14ad227f39b37f34_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Kubernetes Service 的流程大家可以大概看一下。我们先定义一个 Service， 我们这边创建的 ClusterIP 类型的，定义了暴露端口 8000，目标端口 8000，协议是 TCP，标签选择器是 app=holdon。通过这种方式，我们可以把一组相同功能的服务，绑定在同一个 Service 下。在 Kubernetes 集群内，定义好 Service 后，会提供内部的 DNS 解析，你可以通过一个固定的域名访问指定的 Service。这样当在跑测试的时候就可以通过这个域名加对应端口，调用到对应服务了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;持续交付&lt;/b&gt;&lt;/p&gt;&lt;p&gt;持续交付（英语：Continuous Delivery，缩写为 CD）。每个项⽬都要有⼀个 Dockerfile，提供了服务运⾏所需的环境，以及服务对应的软件包。当需要发版本的时候，我们会在主线上打上⼀个 tag，触发镜像构建，然后推送到 Harbor 镜像仓库。其中，这个 tag 也会对应到镜像的版本号。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8ecd0a7ffe6f713ccc7fbbff59694357_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;894&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-8ecd0a7ffe6f713ccc7fbbff59694357_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;894&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-8ecd0a7ffe6f713ccc7fbbff59694357_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8ecd0a7ffe6f713ccc7fbbff59694357_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是我们的 CD 流程大家可以参考看一下。需要提一下的是，我们引用 Harbor 的原因是因为它相对官方的 Registry 更安全。大家应该都知道，官方的 Registry 本身不带权限校验，当你公司内部使用的时候，这个问题会导致你的镜像有被其他部门的人覆盖掉的可能性，所以我们引入了 Harbor。但这里也有一个问题，使用同一个 tag 去推依然会被覆盖的情况。不过好歹做到了小组和小组之间、部门和部门之间的隔离。&lt;/p&gt;&lt;p&gt;&lt;b&gt;持续部署&lt;/b&gt;&lt;/p&gt;&lt;p&gt;持续部署（英语：Continuous deployment，缩写为 CD），目前这块，在实践过程中，我们是只针对集成测试环境，线上更新还是走常规的流程。给项⽬增加⼀个 k8s-deploy.yaml 的⽂件，⾥⾯包含了服务相关的配置、部署⽅式、访问⽅式等等，等待镜像构建完成后，apply 该⽂件就可以了 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-63dc2be0e4384be9dc05a9044379ed20_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;981&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-63dc2be0e4384be9dc05a9044379ed20_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;981&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-63dc2be0e4384be9dc05a9044379ed20_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-63dc2be0e4384be9dc05a9044379ed20_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 持续部署流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/p&gt;&lt;p&gt;现在我们再回到服务变形的流程图来看一下，当我们有 A、B、C 三个服务，且 A 服务在测试时需要调用集成环境内的 B 服务与 C 服务时，可以通过 K8S 提供的内部域名进行访问。等待整块测试跑完后，我们在主线上打 tag，让 CI 去帮执行 image build 构建镜像并推送到 Harbor 仓库。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-93ddcc9c8efae07cd91613d1e5ed7800_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;516&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-93ddcc9c8efae07cd91613d1e5ed7800_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;516&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-93ddcc9c8efae07cd91613d1e5ed7800_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-93ddcc9c8efae07cd91613d1e5ed7800_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;其中涉及到的准发布环境，可以通过 kubectl apply 的方式进行部署。由于线上环境更复杂，推荐大家通过自研的容器云平台来进行操作，我们就是这么处理的，通过云平台发布，功能更加全面安全，更加符合线上部署的流程。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;成果展示&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;最后，跟大家分享下最近正在做的项目的情况。从 2019 年 12月 开始到现在，我们每天基本保持在一个较高的 commit 数上，而这其中一共进行了大约 4500 次的测试。想象下，如果没有这套自动化持续集成环境，测试需要怎么来进行，需要投入人力资源。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-30d3b7280a9ce3598a97476f2fcf06c4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;521&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-30d3b7280a9ce3598a97476f2fcf06c4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;521&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-30d3b7280a9ce3598a97476f2fcf06c4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-30d3b7280a9ce3598a97476f2fcf06c4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;现场演讲视频观看及PPT下载：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/opentalk/453.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-36d256b830f5f0beb3ffab6467061974_180x120.jpg&quot; data-image-width=&quot;960&quot; data-image-height=&quot;540&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;微服务架构下 CI/CD 如何落地&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic1.zhimg.com/v2-36d256b830f5f0beb3ffab6467061974_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6c592f6d727992b6eee38cfb97305883</guid>
<title>35 岁以后，不要成为程序员中的钻石</title>
<link>https://toutiao.io/k/gbakyp5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;▲ &lt;/span&gt;&lt;span&gt;点击上方&quot;pointers&quot;&lt;/span&gt;&lt;span&gt;关注公众号&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;成长&amp;amp;认知 &lt;/span&gt;&lt;/span&gt;丨 作者&lt;/span&gt;&lt;span&gt; / &lt;/span&gt;&lt;span&gt;袁吴范&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是&lt;/span&gt;&lt;span&gt;&lt;span&gt;pointers公众号&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的第25篇原创文章&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020年，是一个不同寻常的一年。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从年初爆发的疫情，到全球经济下行的压力，大家都成为了历史的见证者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;让本来就艰辛的成年人们，雪上加霜。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都是社会中的人，在这场经济下行背景下，经济影响会以各种各样的方式最终传递到每个人身上，我们都无法逃避。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仿佛从年初到年末，都充斥着悲观的情绪。裁员的声音，一直环绕在我们每个职场人耳边。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.319047619047619&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XQ0RVoHjpzzBr9mZ9GC1LiaaIva6zccuWkUNXKFgOsibyZeENQfo5uEC9yMFHdB8pMff1106ciclHuehnBX07Bcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;420&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.28451882845188287&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XQ0RVoHjpzzBr9mZ9GC1LiaaIva6zccuAykSbv23ckkg9yBl14ic5NeCenL14x35xE04aOKas85biby9bmzSjuog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;478&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来自某社交平台上爆料&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;他们有一些人是被迫的丢掉了工作。但对于35岁以上的中年人，打击实在太大了。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;明面上都不会说，但是在招聘的时候，确确实实都不考虑“35岁以上的中年人”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如某为在内部宣传词是“35岁以上的优化”，马爸爸的“每年向社会输送1000人才”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;似乎35岁就像每个程序员的一个坎，那为什么会这样呢？我们应该怎样做呢？&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;—&lt;/span&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为什么？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么35岁以后，突然就没有了竞争力了呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为35岁以后，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;有些程序员成为了“程序员中的钻石”&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么意思？什么是钻石？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;就是又贵又没用的东西&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，比喻很难听，但事实就是这样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着年纪的增长，每年都会进行调薪，自然年薪水涨船高，但能力并没有持续提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样导致了什么结果？&lt;/span&gt;&lt;span&gt;&lt;strong&gt;就是性价比太低了&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多人会有疑问了，不是随着年龄的增大，经验也会变得更加丰富吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;或者是已经晋升为管理者了吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;的确，会有很多人能力在持续提升，最后成为了不可或缺的技术专家。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也有许多人，一路披荆斩棘，千军万马过独木桥，最后成功晋升为管理者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但对于另外一撮人来说，他们不是工作了10年，只是这10年重复干了一件应届生都会干的事情，而已！还在基层岗位上，坚守着。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们再想一想自己刚刚毕业的时候，是怎样的状态？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是不是每天都充满了斗志，活力四射，精力充足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对，这就是刚刚毕业的程序员的优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他们正虎视眈眈的看着前面的那批所谓的中年人，中年人行动缓慢，一不留神就被后浪拍在了沙滩上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要知道，我们生活在市场经济下的社会中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也就是说，你所干的岗位价格是由你的稀缺性来决定的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么意思？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;就是你能拿到的工资是能干和你同样的事情的所有人中最便宜的那个人决定的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这句话多看几遍！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就是因为当初的你年轻，有活力，肯吃苦才让你干基础开发工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在有比现在的你要价更低，甚至比你更勤奋，更优秀。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你说你的老板有什么理由，不选择那个吃的少的马呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后呢？然后，曾经的年轻人也会慢慢变老，来到35岁这个节点上，被新的年轻人拍打在沙滩上，这样周而复始，不断循环。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎么破？&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;—&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;明确方向&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们不能改变社会的规律，我们唯一能做的就是改变自己，让自己的能力等到持续的发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个人的追求都不太一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有的人的志向就是想要从事技术相关工作，喜欢这种解决疑难问题带来的成就感。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有的人内心中渴望领导一个团队，带领团队攻坚，突破，拿下一个个大项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不管是喜欢什么方向，最重要的是明确自己的方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为程序员，应该要知道未来的路中有哪些荆棘，分别需要什么能力去克服，从而做大“手中有粮，心中不慌”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我来讲一讲程序员有哪些常见道路可以走。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互联网大厂的晋升通道一般有管理和技术两个通道，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;一边专业路线，一边是管理路线。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术类上&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，是有两个方向：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;架构师和技术专家&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;架构师他的侧重点是在“广”上&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，他主要负责技术的整体和架构，在业务上，需要有很深的理解，有丰富的经验，甚至能做到“走的桥比你吃的盐还多”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在技术上，能够广泛涉略，掌握的技术知识越多，内力就越加深厚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我觉得架构师还需要三点必备能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其一需要有极强的执行力，能够快速的给出合理的方案，推动技术落地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其二需要有极强的判断力，能够准确的找到复杂系统的疑难问题所在，就像武林高手，一眼就看出对方的破绽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后还需要有极强的创新力，能够创造新的解决方案，解决现有技术难题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以从程序员到架构师的成长之路，总的指导原则是：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;积累经验，拓宽视野，深度思考&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;（可以参考我之前文章《&lt;/span&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483826&amp;amp;idx=1&amp;amp;sn=c82601363825ba261b88c0198ee3a91d&amp;amp;chksm=cf2094a0f8571db6b69603ba66b1ac62ef588fc3668ffdcddd4ca2fa62713eb8c614e279290b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;程序员进阶必备能力——深度思考&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术专家他的侧重点是在“专”上&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这个就很好理解，就是在某个领域能够深入，能够熟悉其背后运行原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同的领域都会存在专家，例如：Java专家、前端专家、图像算法专家、Linux内核专家等等。专家相对架构师，更加专注，并不会考虑太多整体方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以从高级开发成长为技术专家，主要是扩展领域内的技术宽度，提升领域内的技术深度。因为领域也不是特别窄的一个面，而是包含多个技术面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举一个例子：Linux内核专家，要想成为Linux内核专家，需要掌握，Linux
CPU调度、内存管理、进程管理、存储管理、文件系统、设备管理和驱动、网络通信、系统调用、系统初始化等技术面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在每个技术面中，同样包含了很多技术点，这些技术都是知识盲区，所以需要提升技术深度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;管理类上&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，也分为了两个方向，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;技术管理和职业管理&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。顾名思义，技术管理更加倾向于技术，而职业管理完全抛开了技术，纯粹的商业方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术管理，这个方向是程序员最自然的选择。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大部分的技术管理者，在其从程序员转为管理岗位的时候，都是在领导或公司的要求下，被动的推到技术经理岗位上的，并非是自己当初有强烈意愿、主动去选择管理岗的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后走上漫漫打怪升级的道路，从技术经理岗到技术总监，带领几十号人的团队冲关，然后到成为技术业务部和事业部的技术副总裁，相当于CTO了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术管理需要在业务上有较深的理解，在技术上能够根据技术发展趋势，进行技术规划。在产品上能够极强的洞察力，进行产品规划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在团队加上能够规划团队建设、组织结构等等，所以这是综合素质的要求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;职业管理者往往更加关心于整体产品业务的团队，不限于技术团队&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如某个事业部的总裁，或者是某个业务部的总裁。大家往往都听过某某事业部空降了领导，这个领导就是属于职业管理者，他的移动性更加强，能力更加通用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个方向是可遇不可求的，有些人一辈子都不可能触及到。这个就是天花板上的别人家的楼板，你说难不难？所以随遇而安，时刻准备着出击！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到现在知道你未来的路是怎样了，需要的能力是怎样的了，你以为这样就行了吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;显然还不够。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;—&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;跟时间做朋友&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们要跟时间做朋友。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;时间是一把杀猪刀，会让一部分变得越来越不值钱，当然也会让一部分越来越值钱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要让时间成为你的好伙伴。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术和管理的路已经给你指明，接下来就要靠你去做了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚毕业的时候，多努力一点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;千万不要贪图安逸却又不甘平庸，内心渴望挑战却又过得四平八稳。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;把体力多花在能力提升上，少看泡沫剧，少刷抖音，将你的体力换成经验，换成脑中的思想。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;35岁之后，我们的体力终将会被年轻人淘汰，否则就是对年轻人的不公平。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这时候我们还剩下什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所谓中年人的优势，就是一路走来，所积攒下来的经验，能力，人脉和思想。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用这些东西，从顶层思考，帮助年轻人成长，我们自然的就成功了。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;—&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们每个人都在经历着从砖头变钻石的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着工龄的增加，你的价格也越来越贵。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你没有找到自己方向，没有在这个方向上让自己更加有价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那变成职场中的钻石是必然的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以每隔一段时间，公司就会把职场上的钻石换成砖头，如此往复，直到这些砖头，再变成新的钻石。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;唯一能改变这个定律的，就是不断输入新的能量，让自己变成不可或缺的角色&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p lang=&quot;en-US&quot;&gt;&lt;span&gt;明白了这一点，就知道要怎么做了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;35岁之后，别成为又贵又没用的钻石。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后希望大家都能成为自己心中的那个人，献上！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我是袁吴范，物联网大厂技术总监，如有疑问，微信私信我：&lt;/span&gt;&lt;span&gt;&lt;span&gt;pointersss&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;span&gt;推荐阅读（干货）&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-right: 8px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__135&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484114&amp;amp;idx=1&amp;amp;sn=8e7dc76fa54087cf0784ef13dc261078&amp;amp;chksm=cf2097c0f8571ed6de8272864698e35cf0c78183bceb109fe71ee450d077f72ba29e5ac819f2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;7年，从“游戏少年”到大厂技术总监的逆袭之路&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-right: 8px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__135&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484027&amp;amp;idx=1&amp;amp;sn=fb6fe35037e1693bf0f1c0a81d059bdc&amp;amp;chksm=cf209769f8571e7f311b5195d1f4c8fc1dc7f6905375bbdc6b0afbec0abc4775889b1012db7c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;程序员成为高级管理者的三次跃升&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-right: 8px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__135&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484011&amp;amp;idx=1&amp;amp;sn=e52d915760314e3300c145039ede831b&amp;amp;chksm=cf209779f8571e6f81be5951b70607c2a2518fd0fc94c80c8f96c3331f82bdd6e07807179ce4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;技术总监7年总结，如何进行正确的沟通？&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16033270487548=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16033270487548=&quot;rgb(77, 77, 77)&quot; data-style=&quot;margin-right: 8px; margin-bottom: 10px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; color: rgb(77, 77, 77); font-size: 16px; background-color: rgb(255, 255, 255); line-height: 25.5px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__141&quot;&gt;&lt;span&gt;从业7年。从软件开发、高级软件开发、技术经理再到技术总监，分享职业发展、技术管理、职场晋升、技术成长等个人多年经验和心得。一起成长！&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16033270487548=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16033270487548=&quot;rgb(77, 77, 77)&quot; data-style=&quot;margin-right: 8px; margin-bottom: 10px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; color: rgb(77, 77, 77); font-size: 16px; background-color: rgb(255, 255, 255); line-height: 25.5px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__148&quot;&gt;&lt;span&gt;&lt;span data-darkmode-bgcolor-16029336602567=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16029336602567=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16029336602567=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16029336602567=&quot;rgb(77, 77, 77)&quot; data-darkmode-bgcolor-16030173785544=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030173785544=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030173785544=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16030173785544=&quot;rgb(77, 77, 77)&quot; data-style=&quot;max-width: 100%; background-color: rgb(255, 255, 255); color: rgb(77, 77, 77); font-size: 14px; letter-spacing: 0.544px; white-space: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__149&quot; data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16033270487548=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16033270487548=&quot;rgb(77, 77, 77)&quot;&gt;关注我&lt;span data-darkmode-bgcolor-16029336602567=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16029336602567=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16029336602567=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16029336602567=&quot;rgb(77, 77, 77)&quot; data-darkmode-bgcolor-16030173785544=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030173785544=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030173785544=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16030173785544=&quot;rgb(77, 77, 77)&quot; data-style=&quot;max-width: 100%; background-color: rgb(255, 255, 255); color: rgb(77, 77, 77); font-size: 14px; letter-spacing: 0.544px; white-space: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__149&quot; data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16033270487548=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16033270487548=&quot;rgb(77, 77, 77)&quot;&gt;↓&lt;/span&gt;&lt;span data-darkmode-bgcolor-16029336602567=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16029336602567=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16029336602567=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16029336602567=&quot;rgb(77, 77, 77)&quot; data-darkmode-bgcolor-16030173785544=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030173785544=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030173785544=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16030173785544=&quot;rgb(77, 77, 77)&quot; data-style=&quot;max-width: 100%; background-color: rgb(255, 255, 255); color: rgb(77, 77, 77); font-size: 14px; letter-spacing: 0.544px; white-space: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__149&quot; data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16033270487548=&quot;rgb(153, 153, 153)&quot; data-darkmode-original-color-16033270487548=&quot;rgb(77, 77, 77)&quot;&gt;↓&lt;/span&gt;，帮你答疑解惑！&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt; &lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4XQ0RVoHjpwwHPUKTfFPuXricWutdgzqDd8IhicA9rFr2MtXU3SaVfxfR9Y5sfhTib9Wq0kkU5bEZj6aSkAQC7zzA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f2f9681dbbf465a1da86ec118bb00bbb</guid>
<title>压箱底笔记：Promise 和 Async/await 的理解和使用</title>
<link>https://toutiao.io/k/iegr5g1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2778649921507064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0APOE4dXIpvXLgmGfqHMfYFF8pRd3Q1wvd1GZNzn7Omibswzysa3wwkIpJhz7zic90hysZ13icEic5ib9xQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;以前学习写的笔记，感觉还不错，现在发出来，希望对你有帮助。如果文章对你有所启发和帮助，可以『一键三连』。哦，对了，我已经脱发了...😭😭&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;1. 前置知识&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1.1 区别实例对象与函数对象&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;1.2 两种类型的回调函数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;1.3 JS的error处理&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;2. Promise 是什么？&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;2.1 理解&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2.2 Promise的状态改变&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2.3 Promise基本流程&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2.4 Promise的基本使用&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;3. 为什么要用Promise？&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;3.1 指定回调函数的方式更加灵活&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3.2 支持链式调用，可以解决回调地狱问题&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;4. Promise的API说明&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;4.1 API 说明&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.2 Promise的几个关键问题&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;5. async与await&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 前置知识&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.1 区别实例对象与函数对象&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例对象：&lt;code&gt;new&lt;/code&gt; 函数产生的对象, 称为实例对象, 简称为对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数对象：将函数作为对象使用时, 简称为函数对象&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Fn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; fn = &lt;span&gt;new&lt;/span&gt; Fn() &lt;span&gt;// fn为实例对象&lt;/span&gt;&lt;br/&gt;Fn.bind({}) &lt;span&gt;// Fn为函数对象&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.2 两种类型的回调函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步回调&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;理解：立即执行, 完全执行完了才结束, 不会放入回调队列中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;例子: 数组遍历相关的回调函数 / Promise 的 excutor 函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步回调&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;理解：不会立即执行, 会放入回调队列中将来执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;例子：定时器回调 / ajax 回调 / Promise 的成功|失败的回调&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; arr = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;arr.forEach(&lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(item)) &lt;span&gt;// 同步回调, 不会放入回调队列, 而是立即执行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;forEatch()之后&#x27;&lt;/span&gt;)&lt;br/&gt;setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;// 异步回调, 会放入回调队列, 所有同步执行完后才可能执行&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;timout 回调&#x27;&lt;/span&gt;)&lt;br/&gt;}, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;setTimeout 之后&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.3 JS的error处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误的类型&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Error：所有错误的父类型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReferenceError：引用的变量不存在&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;console&lt;/span&gt;.log(a) &lt;span&gt;// ReferenceError: a is not defined&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TypeError：数据类型不正确的错误&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; b = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(b.xxx) &lt;span&gt;// TypeError: Cannot read property &#x27;xxx&#x27; of null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RangeError：数据值不在其所允许的范围内&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  fn()&lt;br/&gt;}&lt;br/&gt;fn() &lt;span&gt;// RangeError: Maximum call stack size exceeded&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SyntaxError：语法错误&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; c = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt; &lt;span&gt;// SyntaxError: Unexpected string&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误处理&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;捕获错误：try ... catch&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;抛出错误：throw error&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;error 对象的结构&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;message 属性：错误相关信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;stack 属性：函数调用栈记录信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. Promise 是什么？&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.1 理解&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抽象表达：Promise 是JS中进行异步编程的新的解决方案（旧的是谁？=&amp;gt; 纯回调的形式）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体表达：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从语法上来说：Promise 是一个构造函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从功能上来说：Promise 对象用来封装一个异步操作并可以获取其结果&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.2 Promise的状态改变&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Promise的状态改变只有这2种：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6183368869936035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANBeLLOYKW7NU8bxzq5kBSPby8sCCJ8Vfd5RZX1noQtyAleD8yicpfpG6ujJJ5wERnm5XKFNc6thTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;469&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;且一个 Promise 对象只能改变一次，无论变成成功还是失败，都会有一个结果数据，成功的结果数据一般称为 &lt;code&gt;value&lt;/code&gt;，失败的结果数据一般称为 &lt;code&gt;reason&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.3 Promise基本流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3055286129970902&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANBeLLOYKW7NU8bxzq5kBSPGU6MSna6muvRYkd5D2VrM8pw8HMIX3lJQhMMBwoxegg3oibiaFZOMDRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2062&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;Promise基本流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.4 Promise的基本使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例，如果当前时间是偶数就代表成功，否则代表失败&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 1. 创建一个新的Promise对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; { &lt;span&gt;// 执行器函数，同步执行&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 2. 执行异步操作任务&lt;/span&gt;&lt;br/&gt;  setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; time = &lt;span&gt;Date&lt;/span&gt;.now() &lt;span&gt;// 如果当前时间是偶数就代表成功，否则代表失败&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 3.1 如果成功了，调用resolve(value)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (time % &lt;span&gt;2&lt;/span&gt; === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        resolve(&lt;span&gt;&#x27;成功的数据，value = &#x27;&lt;/span&gt; + time)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 3.2 如果失败了，调用reject(reason)&lt;/span&gt;&lt;br/&gt;        reject(&lt;span&gt;&#x27;失败的数据，reason = &#x27;&lt;/span&gt; + time)&lt;br/&gt;    }&lt;br/&gt;  }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;p.then(&lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 接受得到成功的value数据，专业术语：onResolved&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;成功的回调&#x27;&lt;/span&gt;, value)&lt;br/&gt;}, reason =&amp;gt; {&lt;br/&gt;  &lt;span&gt;// 接受得到失败的reason数据，专业术语：onRejected&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;失败的回调&#x27;&lt;/span&gt;, reason)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 为什么要用Promise？&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 指定回调函数的方式更加灵活&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;旧的：回调函数必须在启动异步任务前指定&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 成功的回调函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;successCallback&lt;/span&gt;(&lt;span&gt;result&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;处理成功:&#x27;&lt;/span&gt; + result)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;failureCallback&lt;/span&gt;(&lt;span&gt;error&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;处理失败:&#x27;&lt;/span&gt; + error)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 使用纯回调函数&lt;/span&gt;&lt;br/&gt;createAudioFileSync(audioSettings, successCallback, failureCallback)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Promise：启动异步任务 =&amp;gt; 返回 Promise 对象 =&amp;gt; 给 Promise 对象绑定回调函数，甚至可以在异步任务结束后指定多个&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 使用 Promise&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; promise = createAudioFileSync(audioSettings)&lt;br/&gt;setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  promise.then(successCallback, failureCallback)&lt;br/&gt;}, &lt;span&gt;3000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 支持链式调用，解决回调地狱问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是回调地狱？回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回掉执行条件，代码是水平向右扩展&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 回调地狱&lt;/span&gt;&lt;br/&gt;doSomething(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;result&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  doSomethingElse(result, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;newResult&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    doThirdThing(newResult, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;finalResult&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Got the final result: &#x27;&lt;/span&gt; + finalResult)&lt;br/&gt;    }, failureCallback)&lt;br/&gt;  }, failureCallback)&lt;br/&gt;},&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回调地狱的缺点：不便阅读，不便于异常处理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决方案：Promise 链式调用，代码水平向下扩展&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;doSomething().then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;result&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; doSomethingElse(result)&lt;br/&gt;})&lt;br/&gt;.then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;newResult&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; doThirdThing(newResult)&lt;br/&gt;})&lt;br/&gt;.then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;finalResult&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Got the final result: &#x27;&lt;/span&gt; + finalResult)&lt;br/&gt;})&lt;br/&gt;.catch(failureCallback)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终极解决方案：&lt;strong&gt;async/await&lt;/strong&gt;，用同步的写法处理异步的操作&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;request&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; doSomething()&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; newResult = &lt;span&gt;await&lt;/span&gt; doSomethingElse(result)&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; finalResult = &lt;span&gt;await&lt;/span&gt; doThirdThing(newResult)&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Got the final result: &#x27;&lt;/span&gt; + finalResult)&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;    failureCallback(error)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Promise的API说明&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.1 API 说明&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise 构造函数&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Promise (excutor) {}&lt;/code&gt;，excutor 会在 Promise 内部立即同步回调,异步操作在执行器中执行&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;excutor 函数：执行器 &lt;code&gt;(resolve, reject) =&amp;gt; {}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;resolve 函数：内部定义成功时我们调用的函数 &lt;code&gt;value =&amp;gt; {}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;reject 函数：内部定义失败时我们调用的函数 &lt;code&gt;reason =&amp;gt; {}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise.prototype.then方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; (onResolved, onRejected) =&amp;gt; {}&lt;/code&gt;，指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调返回一个新的 promise 对象&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;onResolved 函数：成功的回调函数 &lt;code&gt;(value) =&amp;gt; {}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;onRejected 函数：失败的回调函数 &lt;code&gt;(reason) =&amp;gt; {}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise.prototype.catch 方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(onRejected) =&amp;gt; {}&lt;/code&gt;，onRejected 函数：失败的回调函数 &lt;code&gt;(reason) =&amp;gt; {}&lt;/code&gt;，then() 的语法糖, 相当于：&lt;code&gt;then(undefined, onRejected)&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise.resolve方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; (value) =&amp;gt; {}&lt;/code&gt;，value：成功的数据或 promise 对象，返回一个成功/失败的 promise 对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise.reject方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; (reason) =&amp;gt; {}&lt;/code&gt;，reason：失败的原因，返回一个失败的 promise 对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise.all方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(promises) =&amp;gt; {}&lt;/code&gt;，promises：包含 n 个 promise 的数组，返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就直接失败&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Promise.race方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(promises) =&amp;gt; {}&lt;/code&gt;，promises: 包含 n 个 promise 的数组，返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 产生一个成功值为 1 的 Promise 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  resolve(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 产生一个成功值为 2 的 Promise 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p2 = &lt;span&gt;Promise&lt;/span&gt;.resolve(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// 产生一个失败值为 3 的 Promise 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p3 = &lt;span&gt;Promise&lt;/span&gt;.reject(&lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;p1.then(&lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(value))&lt;br/&gt;p2.then(&lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(value))&lt;br/&gt;p3.catch(&lt;span&gt;&lt;span&gt;reason&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.error(reason))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// const pAll = Promise.all([p1, p2])&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; pAll = &lt;span&gt;Promise&lt;/span&gt;.all([p1, p2, p3])&lt;br/&gt;pAll.then(&lt;span&gt;&lt;span&gt;values&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;all onResolved()&#x27;&lt;/span&gt;, values) &lt;span&gt;// all onResolved() [ 1, 2 ]&lt;/span&gt;&lt;br/&gt;}, reason =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;all onRejected()&#x27;&lt;/span&gt;, reason) &lt;span&gt;// all onRejected() 3&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; race = &lt;span&gt;Promise&lt;/span&gt;.race([p1, p2, p3])&lt;br/&gt;race.then(&lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;all onResolved()&#x27;&lt;/span&gt;, value) &lt;br/&gt;}, reason =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;all onRejected()&#x27;&lt;/span&gt;, reason) &lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.2 Promise的几个关键问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.1 如何改变Promise的状态&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;resolve(value)&lt;/strong&gt;，如果当前是 pendding 就会变为 resolved&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;reject(reason)&lt;/strong&gt;，如果当前是 pendding 就会变为 rejected&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;抛出异常&lt;/strong&gt;，如果当前是 pendding 就会变为 rejected&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// resolve(1) // Promise 变为 resolved 成功状态&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// reject(2) // Promise 变为 rejected 失败状态&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Promise 变为 rejected 失败状态，reason为抛出的 error&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;我抛出的异常&#x27;&lt;/span&gt;) &lt;br/&gt;  &lt;span&gt;// 变为 rejected 失败状态，reason为抛出的 3&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// throw 3&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;p.then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {},&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reason :&#x27;&lt;/span&gt;, reason); }&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.2 当一个promise指定多个成功/失败回调函数, 都会调用吗？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 promise 改变为对应状态时都会调用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 变为 rejected 失败状态，reason为抛出的 3&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;p.then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {},&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reason :&#x27;&lt;/span&gt;, reason); }&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;p.then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {},&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reason2 :&#x27;&lt;/span&gt;, reason); }&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 结果：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// reason : 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// reason2 : 3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1606321749162&quot; data-category_id_list=&quot;48|32|26|49|1|27|28|45|46|55|39|8|3|47|35|41|5|31|6|7|24|37|22|11|50|54|53|52|42|29|43|16|17|51|36&quot; data-id=&quot;1606321749162&quot;/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.2.3 改变promise状态和指定回调函数谁先谁后?&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何先改状态再指定回调?&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在执行器中直接调用 resolve()/reject()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延迟更长时间才调用 then()&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么时候才能得到数据?&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 常规：先指定回调函数,后改变状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    resolve(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;// 后改变状态（同时指定数据），异步执行回调函数&lt;/span&gt;&lt;br/&gt;  }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}).then( &lt;span&gt;// 先指定回调函数，保存当前指定的回调函数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {},&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reason :&#x27;&lt;/span&gt;, reason); }&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 先改状态,后指定回调函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  resolve(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;// 先改变状态（同时指定数据）&lt;/span&gt;&lt;br/&gt;}).then( &lt;span&gt;// 后指定回调函数，异步执行回调函数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;value2：&#x27;&lt;/span&gt;, value);},&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reason2 :&#x27;&lt;/span&gt;, reason); }&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  resolve(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;// 先改变状态（同时指定数据）&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  p.then(&lt;br/&gt;    &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;value3：&#x27;&lt;/span&gt;, value);},&lt;br/&gt;    reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reason3 :&#x27;&lt;/span&gt;, reason); }&lt;br/&gt;  )&lt;br/&gt;}, &lt;span&gt;1500&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.4 promise.then()返回的新 promise 的结果状态由什么决定?&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单表达：由 then()指定的回调函数执行的结果决定&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细表达：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  resolve(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;}).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved1()&#x27;&lt;/span&gt;, value); &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// return 1.1 或 &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.resolve(&lt;span&gt;1.1&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;// return Promise.reject(1.1)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// throw 1.1&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  reason =&amp;gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onRejected1()&#x27;&lt;/span&gt;, reason);&lt;br/&gt;  }&lt;br/&gt;).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved2()&#x27;&lt;/span&gt;, value); }, &lt;span&gt;// 1.1&lt;/span&gt;&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onRejected2()&#x27;&lt;/span&gt;, reason) } &lt;span&gt;// 1.1&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.5 promise 如何串连多个操作任务&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;promise 的 &lt;code&gt;then()&lt;/code&gt; 返回一个新的 promise, 可以开成 &lt;code&gt;then()&lt;/code&gt; 的链式调用，通过 then 的链式调用串连多个同步/异步任务。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.6 promise 异常传透&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调，前面任何操作出了异常, 都会传到最后失败的回调中处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的示例代码演示了异常传透&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// resolve(1)&lt;/span&gt;&lt;br/&gt;  reject(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;}).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved1()&#x27;&lt;/span&gt;, value);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved2()&#x27;&lt;/span&gt;, value);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved3()&#x27;&lt;/span&gt;, value);&lt;br/&gt;  }&lt;br/&gt;).catch(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;reason&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onRejected()&#x27;&lt;/span&gt;, reason);  &lt;span&gt;// onRejected() 1&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码会执行 &lt;code&gt;.catch&lt;/code&gt; 中的代码，但实际上代码的执行不是执行到第 3 行就直接跳转到 catch 里面了，而是从第一个 then 调用向下一个个的执行（逐级传递），但是由于我们 then 里面没有处理异常。在 then 里面没写处理异常实际上相当于默认添加了 &lt;code&gt;reason =&amp;gt; { throw reason }&lt;/code&gt; 或者 &lt;code&gt;reason =&amp;gt; Promise.reject(reason)&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  reject(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;}).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; {  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved1()&#x27;&lt;/span&gt;, value); },&lt;br/&gt;  &lt;span&gt;// reason =&amp;gt; { throw reason }&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 或者&lt;/span&gt;&lt;br/&gt;  reason =&amp;gt; &lt;span&gt;Promise&lt;/span&gt;.reject(reason)&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Promise的异常传透示意图&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8196573489630298&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0APyp6OPGNw1Z9EDQMVE6X0uSawq1VP6iaBicqgyIv30BJ7tsbNicibicdAEgMXsmEqibTHKW6jwZ1GRQcvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1109&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;Promise的异常传透&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.7 中断 promise 链&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;办法: 在回调函数中返回一个 &lt;code&gt;pendding&lt;/code&gt; 状态的 promise 对象&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt; resolve(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;}).then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved1()&#x27;&lt;/span&gt;, value);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {}) &lt;span&gt;// 返回一个 pending 的 Promise，中断 promise 链&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;).then( &lt;span&gt;// 这个 then 不会执行力&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt;  { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved2()&#x27;&lt;/span&gt;, value); }&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. async与await&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Async/await 实际上只是一种基于promises的糖衣语法糖，Async/await 和 promises一样，都是非堵塞式的，Async/await 让异步代码更具同步代码风格，这也是其优势所在。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;async function&lt;/code&gt; 用来定义一个返回 &lt;code&gt;AsyncFunction&lt;/code&gt; 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 &lt;code&gt;Promise&lt;/code&gt; 返回其结果，。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。MDN async_function&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;await&lt;/code&gt;  操作符用于等待一个&lt;code&gt;Promise&lt;/code&gt; 对象。它只能在异步函数 &lt;code&gt;async function&lt;/code&gt; 中使用。MDN await&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.1 async函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;async&lt;/code&gt; 函数的返回值为 &lt;code&gt;Promise&lt;/code&gt; 对象，&lt;code&gt;async&lt;/code&gt; 函数返回的 &lt;code&gt;Promise&lt;/code&gt; 的结果由函数执行的结果决定&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn1&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; result = fn1()&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(result) &lt;span&gt;// Promise { 1 }&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在控制台可以看见如下信息&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然是Promise对象，那么我们用 then 来调用，并抛出错误，执行 &lt;code&gt;onRejected()&lt;/code&gt; 且 reason 为错误信息为“我是错误”&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn1&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// return 1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// return Promise.resolve(1)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// return Promise.reject(2)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;&#x27;我是错误&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;fn1().then(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onResolved()&#x27;&lt;/span&gt;, value) },&lt;br/&gt;  reason =&amp;gt; { &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onRejected()&#x27;&lt;/span&gt;, reason) } &lt;span&gt;// onRejected() 我是错误&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.2 await表达式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;await&lt;/code&gt; 右侧的表达式一般为 &lt;code&gt;promise&lt;/code&gt; 对象, 但也可以是其它的值:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果表达式是 &lt;code&gt;promise&lt;/code&gt; 对象, &lt;code&gt;await&lt;/code&gt; 返回的是 &lt;code&gt;promise&lt;/code&gt; 成功的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果表达式是其它值, 直接将此值作为 &lt;code&gt;await&lt;/code&gt; 的返回值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn2&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      resolve(&lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;    }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn4&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn3&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// const value = await fn2() // await 右侧表达式为Promise，得到的结果就是Promise成功的value&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// const value = await &#x27;还可以这样&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; value = &lt;span&gt;await&lt;/span&gt; fn4()&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;value&#x27;&lt;/span&gt;, value)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;fn3() &lt;span&gt;// value 6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;await&lt;/code&gt; 必须写在 &lt;code&gt;async&lt;/code&gt; 函数中, 但 &lt;code&gt;async&lt;/code&gt; 函数中可以没有 &lt;code&gt;await&lt;/code&gt;，如果 &lt;code&gt;await&lt;/code&gt; 的 &lt;code&gt;Promise&lt;/code&gt; 失败了, 就会抛出异常, 需要通过 &lt;code&gt;try...catch&lt;/code&gt; 捕获处理&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn2&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// resolve(1000)&lt;/span&gt;&lt;br/&gt;      reject(&lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;    }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn3&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; value = &lt;span&gt;await&lt;/span&gt; fn2()&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;得到失败的结果&#x27;&lt;/span&gt;, error)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;fn3() &lt;span&gt;// 得到失败的结果 1000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.3 Async/await 比 Promise 更优越的表现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;简洁干净&lt;/strong&gt;，使用async/await能省去写多少行代码&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;错误处理&lt;/strong&gt;，async/wait 能用相同的结构和好用的经典 try/catch 处理同步和异步错误，错误堆栈能指出包含错误的函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;调试&lt;/strong&gt;，async/await 的一个极大优势是它更容易调试，使用async/ await则无需过多箭头函数，并且能像正常的同步调用一样直接跨过await调用。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e3c25d1c85f726c568175abf39aca66e</guid>
<title>聊聊 k8s 调试工具 kt-connect 的实现</title>
<link>https://toutiao.io/k/p6ic0m3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content e-content&quot; itemprop=&quot;description articleBody&quot;&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;版权声明 本站原创文章 由 萌叔 发表
转载请注明 萌叔 | http://vearne.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;1. 引言&lt;/h3&gt;
&lt;p&gt;kt-connect是阿里开源的k8s的调试工具，它的作用类似于VPN，能够打通k8s集群和本地的网络。&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20201202/4f137862-3451-11eb-b64b-784f43a6cab8.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;传送门: &lt;a href=&quot;https://github.com/alibaba/kt-connect&quot;&gt;alibaba/kt-connect&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它有3种模式&lt;br/&gt;
* Connect 本地网络直接访问k8s集群网络&lt;br/&gt;
* Exchange 转发集群流量到本地&lt;br/&gt;
* Service Mesh 支持&lt;/p&gt;
&lt;p&gt;另外它提供了一个Dashboard可以查看k8s集群内的所有可访问的service资源以及正在进行调试的&lt;code&gt;Connect&lt;/code&gt;和&lt;code&gt;Exchange&lt;/code&gt;数量, 用处不大。&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20201202/866fbb52-3453-11eb-9cba-784f43a6cab8.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. 使用介绍&lt;/h3&gt;
&lt;p&gt;这里萌叔只简单介绍&lt;code&gt;Connect&lt;/code&gt;和&lt;code&gt;Exchange&lt;/code&gt;2种模式，更详细的使用说明见参考资料1&lt;/p&gt;
&lt;h4&gt;2.1 &lt;code&gt;Connect&lt;/code&gt;模式&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;sudo ktctl -i ik8share/kt-connect-shadow:stable connect
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: &lt;code&gt;kt-connect&lt;/code&gt; 依赖&lt;code&gt;sshuttle&lt;/code&gt;, 且运行时必须拥有root权限。另外&lt;code&gt;sshuttle&lt;/code&gt; 又依赖了iptables(linux操作系统), ptctl(macOS)&lt;/p&gt;
&lt;p&gt;-i 参数指定镜像的地址&lt;/p&gt;
&lt;p&gt;这里&lt;a href=&quot;https://hub.docker.com/r/ik8share/kt-connect-shadow&quot;&gt;ik8share/kt-connect-shadow:stable&lt;/a&gt;是镜像的名字，阿里默认提供的镜像地址&lt;a href=&quot;https://registry.cn-hangzhou.aliyuncs.com/rdc-incubator/kt-connect-shadow:stable&quot;&gt;rdc-incubator/kt-connect-shadow&lt;/a&gt;在萌叔的测试k8s集群中无法正常拉取。这里提供了一个docker hub的镜像地址。&lt;/p&gt;
&lt;h4&gt;2.2 &lt;code&gt;Exchange&lt;/code&gt;模式&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;sudo ktctl -n test -i ik8share/kt-connect-shadow:stable exchange dm-backend-v0-0-1 --expose 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 这里的&lt;code&gt;dm-backend-v0-0-1&lt;/code&gt; 是k8s集群中&lt;code&gt;Deployment&lt;/code&gt;资源的名称。&lt;/p&gt;
&lt;p&gt;该命令会将所有发往&lt;code&gt;dm-backend-v0-0-1&lt;/code&gt;所属&lt;code&gt;Pod&lt;/code&gt;的3000端口的请求都转发到本地的3000端口上。&lt;/p&gt;
&lt;p&gt;总结：&lt;code&gt;Connect&lt;/code&gt;和&lt;code&gt;Exchange&lt;/code&gt; 模式都是单向的，一个是从集群外部到集群内部，一个是从集群内部到集群外部。&lt;/p&gt;
&lt;h3&gt;3. 原理和实现&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;kt-connect&lt;/code&gt;设计巧妙，且最大限度的避免了重复发明轮子，值得称赞。&lt;/p&gt;
&lt;h4&gt;3.1 &lt;code&gt;Connect&lt;/code&gt;模式&lt;/h4&gt;
&lt;p&gt;我们先来看看&lt;code&gt;Connect&lt;/code&gt;模式要达到的目标&lt;br/&gt;
假定&lt;br/&gt;
&lt;code&gt;Namespace&lt;/code&gt;: test&lt;br/&gt;
&lt;code&gt;Service&lt;/code&gt;: sv-backend-v0-0-1&lt;br/&gt;
&lt;code&gt;Pod&lt;/code&gt;的IP: 172.20.1.29&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;curl http://sv-backend-v0-0-1.test.svc.cluster.local/info
curl 172.20.1.29:3000/info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么显然，&lt;br/&gt;
对于场景1: &lt;code&gt;kt-connect&lt;/code&gt;需要知道sv-backend-v0-0-1.test.svc.cluster.local是k8s集群内的域名，针对此类域名的请求，需要转发到k8s内网&lt;/p&gt;
&lt;p&gt;对于场景1: &lt;code&gt;kt-connect&lt;/code&gt; 需要知道 172.20.1.29，是k8s集群的内网IP，请求需要转发到k8s内网&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kt-connect&lt;/code&gt; 需要能够自动捕获这两类流量，然后转发到k8s内网。&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20201202/b659ca8a-346f-11eb-b218-784f43a6cab8.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;3.1.1 ① 创建Pod&lt;/h5&gt;
&lt;p&gt;此Pod镜像为&lt;a href=&quot;https://registry.cn-hangzhou.aliyuncs.com/rdc-incubator/kt-connect-shadow:stable&quot;&gt;rdc-incubator/kt-connect-shadow&lt;/a&gt;，并且暴露SSH端口&lt;/p&gt;
&lt;h5&gt;3.1.2 ② 在Local和K8s之间建立通道&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;kubectl -n default port-forward kt-connect-daemon-dnwvy-5dbf9cb9c6-l96g6 2222:22
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;3.1.3 ③ 捕获请求，并重新路由&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;sshuttle --dns --to-ns 172.20.3.25 -v -e ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -r root@127.0.0.1:2222 -x 127.0.0.1 172.20.0.0/24 172.20.2.0/24 172.20.1.0/24 172.20.3.0/24 10.68.0.0/16
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sshuttle&lt;/code&gt;内部会调用&lt;code&gt;iptables&lt;/code&gt;或&lt;code&gt;pfctl&lt;/code&gt;修改NAT规则&lt;/p&gt;
&lt;p&gt;–dns –to-ns 172.20.3.25表示DNS解析使用172.20.3.25，实时上这个IP就是&lt;code&gt;Pod&lt;/code&gt; kt-connect-daemon-dnwvy-5dbf9cb9c6-l96g6的IP&lt;/p&gt;
&lt;p&gt;规则形如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;iptables -t nat -A sshuttle-12300 -j REDIRECT --dest 10.68.0.0/16  -p tcp --to-ports 2222 
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;3.1.4 ④ sshuttle重建对目标的连接&lt;/h5&gt;
&lt;p&gt;我们再来梳理一遍流程。当使用curl请求接口时，域名解析会使用自定义的DNS服务器172.20.3.25，因此能够成功解析&lt;code&gt;sv-backend-v0-0-1.test.svc.cluster.local&lt;/code&gt;，解析得到的A记录是10.68.54.179, 显然命中了&lt;code&gt;shuttle&lt;/code&gt;创建的NAT规则(10.68.0.0/16)，于是请求被转发到127.0.0.1:2222端口, 请求又经过&lt;code&gt;port-forward&lt;/code&gt;转发到&lt;code&gt;kt-connect-daemon-dnwvy-5dbf9cb9c6-l96g6&lt;/code&gt;的22端口。在这个Pod中，&lt;code&gt;sshuttle&lt;/code&gt;重建对目标的连接，请求会被转发。&lt;/p&gt;
&lt;h4&gt;3.2 &lt;code&gt;Exchange&lt;/code&gt;模式&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20201202/752680b4-3477-11eb-a73e-784f43a6cab8.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;3.2.1 ① 创建Pod &amp;amp; ② 删除原有Pod&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20201202/878aacd4-3478-11eb-8900-784f43a6cab8.jpeg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
实际上，&lt;code&gt;kt-connect&lt;/code&gt;将原来的&lt;code&gt;Deployment&lt;/code&gt; dm-backend-v0-0-1的&lt;code&gt;replicas&lt;/code&gt;置为0，变相删除了&lt;code&gt;Pod&lt;/code&gt;&lt;br/&gt;
创建了一个新的&lt;code&gt;Deployment&lt;/code&gt; dm-backend-v0-0-1-kt-dfoje, 注意看它使用的镜像是&lt;a href=&quot;https://registry.cn-hangzhou.aliyuncs.com/rdc-incubator/&quot;&gt;kt-connect-shadow&lt;/a&gt;。由它创建的&lt;code&gt;Pod&lt;/code&gt;，使用的&lt;code&gt;Label&lt;/code&gt;和原先的一模一样，这样它就能欺骗k8s，使得对&lt;code&gt;Service&lt;/code&gt; backend的请求都转发到它这里来。&lt;/p&gt;
&lt;h5&gt;3.2.2 ③在Local和K8s之间建立通道&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;kubectl -n test port-forward dm-backend-v0-0-1-kt-dfoje-7ff5d9564-kmklv 2226:22
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问本地的2226端口，相当于访问了dm-backend-v0-0-1-kt-dfoje-7ff5d9564-kmklv的22端口&lt;/p&gt;
&lt;h5&gt;3.2.3 ④ssh 远程转发&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -R 3000:127.0.0.1:3000 root@127.0.0.1 -p2226 sh loop.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ssh自带远程转发功能，它会在dm-backend-v0-0-1-kt-dfoje-7ff5d9564-kmklv中监听3000端口，然后把所有发到3000端口的请求转发到127.0.0.1:3000（见参考资料2）&lt;/p&gt;
&lt;p&gt;我们再来梳理一遍流程。当其他服务访问&lt;code&gt;Service&lt;/code&gt; backend时，由于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;  labels:
    app: backend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只剩由&lt;code&gt;kt-connect&lt;/code&gt;伪造的1个&lt;code&gt;Pod&lt;/code&gt; dm-backend-v0-0-1-kt-dfoje-7ff5d9564-kmklv了，所以流量会被转发到这个&lt;code&gt;Pod&lt;/code&gt;中。请求的3000端口的流量会被SSH的远程转发功能转发给本地的3000端口。&lt;/p&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;p&gt;1.&lt;a href=&quot;https://alibaba.github.io/kt-connect/#/zh-cn/&quot;&gt;Kt Connect Docs&lt;/a&gt;&lt;br/&gt;
2.&lt;a href=&quot;https://jeremyxu2010.github.io/2018/12/ssh%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/&quot;&gt;SSH的三种端口转发&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;打赏我&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/woshiaotian/ohw8kvpn5k7hthgbuol4e4aq/WechatIMG29.jpg&quot; alt=&quot;微信支付码&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;clear&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eba5dd3e2a7c027f76a1692da127f8d7</guid>
<title>Lucene 索引文件的合并（二）：fdx&amp;&amp;fdt&amp;&amp;fdm</title>
<link>https://toutiao.io/k/tknj7hk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;write&quot; class=&quot;&quot;&gt;&lt;p&gt;  &lt;span&gt;本文承接文章&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/Index/2020/1130/180.html&quot;&gt;&lt;span&gt;索引文件的合并（一）之fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，继续介绍剩余的内容，下面先给出索引文件fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm的合并流程图。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;索引文件fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm的合并流程图&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;图1：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/1.png&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;DocMap[ ]数组&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;  &lt;span&gt;继续介绍图1的流程点之前，我们先介绍下DocMap[ &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;数组，如果合并后的段是段内排序的，那么需要在构造MergeState（见文章&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/Index/2020/1130/180.html&quot;&gt;&lt;span&gt;索引文件的合并（一）之fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm&lt;/span&gt;&lt;/a&gt;&lt;span&gt;的介绍）对象期间生成DocMap[ ]数组，数组中的数组元素描述了某个待合并的段的一个映射关系，它描述了段中文档号到新段文档号的映射关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/2.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;图2中描述了待合并的段中的文档号映射到新段后的文档号。其中待合并的第一个段中的文档号3以及待合并的第二个段的文档号2用&lt;/span&gt;&lt;font&gt;&lt;span&gt;红框&lt;/span&gt;&lt;/font&gt;&lt;span&gt;额外标注，它们表示这两篇文档号是被标记为删除的，在合并后的新段中不会出现这两个文档号映射关系（代码中其实有删除文档号到新段文档号的映射，只是在合并的过程中会通过&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/suoyinwenjian/2019/0425/54.html&quot;&gt;&lt;span&gt;索引文件之liv&lt;/span&gt;&lt;/a&gt;&lt;span&gt;过滤，所以相当于没有映射关系）。图2中的映射关系使用DocMap[ ]数组存储：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/3.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;图2中的映射关系是如何生成的：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;回答这个问题前必须再次强调在文章&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/Index/2020/1130/180.html&quot;&gt;&lt;span&gt;索引文件的合并（一）之fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm&lt;/span&gt;&lt;/a&gt;&lt;span&gt;中的内容：待合并的段中的文档号是段内有序的，并且所有的段的排序规则都是相同的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;生成图2的映射关系的大概逻辑就是：&lt;/span&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;把所有的段丢进一个优先级队列中，所以这个队列中的元素数量为待合并的段的数量&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;优先级队列的排序规则为比较文档中的一个或者多个排序域（排序域即跟IndexWriter中的&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/Index/2019/1111/106.html&quot;&gt;&lt;span&gt;IndexSort&lt;/span&gt;&lt;/a&gt;&lt;span&gt;相同域名的域），如果排序域仍然无法比较出结果，那么就根据文档所属段的编号（生成一个段的生成是同步的，先生成的段对应的编号小），编号越小则胜出。&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;每个段按照文档号大小的顺序，每次取出一篇文档中的排序域参与比较，如果胜出，那么这篇文档的文档号建立与新段中的文档号的映射，接着这个段取出下一篇文档中的排序域继续参与比较，随后优先级队列重排&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;  &lt;span&gt;详细的过程可以看源码，实现方式易读易懂：&lt;/span&gt;&lt;a href=&quot;https://github.com/LuXugang/Lucene-7.5.0/blob/master/solr-8.4.0/lucene/core/src/java/org/apache/lucene/index/MultiSorter.java&quot; target=&quot;_blank&quot; class=&quot;url&quot;&gt;https://github.com/LuXugang/Lucene-7.5.0/blob/master/solr-8.4.0/lucene/core/src/java/org/apache/lucene/index/MultiSorter.java&lt;/a&gt;&lt;span&gt;  。虽然是Lucene 8.4.0的链接，但是跟Lucene 8.7.0中的实现是一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/4.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;我们看下MultiSorter的注释，它提到所有的leaf reader必须是有序的并且使用相同的排序规则，即上文中提到的待合并的段中的文档号是段内有序的，并且所有的段的排序规则都是相同的。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;初始化优先级队列&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;图5：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/5.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;当前流程点需要初始化了一个优先级队列，目的在于随后的剩余的流程中我们将通过这个优先级队列有序的取出获得一个文档号，它对应的索引文件信息将被写入到新的索引文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;初始化优先级队列的大概逻辑为：&lt;/span&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;把所有的段丢这个优先级队列中&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;优先级队列的排序规则为比较段中的文档号映射到新段的文档号，我们称之为mappedDocID（源码中的变量名），mappedDocID越小优先级越高。获得mappedDocID的方式正是上文中提到的DocMap[ ]数组&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;是否每个段中的域名信息都相同？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;图6：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/6.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;域名信息的概念在文章&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/Index/2020/1130/180.html&quot;&gt;&lt;span&gt;索引文件的合并（一）之fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm&lt;/span&gt;&lt;/a&gt;&lt;span&gt;中以及介绍，不赘述。如果当前流程点为true，那么能使用比naive merger性能较高的optimized merge。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;执行naive merge&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;图7：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/7.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  &lt;font&gt;&lt;span&gt;naive merge&lt;/span&gt;&lt;/font&gt;&lt;span&gt;同图2中的&lt;/span&gt;&lt;font&gt;&lt;span&gt;optimized merge&lt;/span&gt;&lt;/font&gt;&lt;span&gt;、&lt;/span&gt;&lt;font&gt;&lt;span&gt;bulk merge&lt;/span&gt;&lt;/font&gt;&lt;span&gt;属于索引文件的合并方式。由于索引文件的合并实际是读取旧的索引文件以及生成新的索引文件的过程，所以我们结合&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/Index/2020/1015/170.html&quot;&gt;&lt;span&gt;索引文件fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm的生成&lt;/span&gt;&lt;/a&gt;&lt;span&gt;过程来介绍这几种合并方式的差异。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;执行naive merge的过程可以划分下面几个步骤：&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;第一步：从图5的优先级队列中找到优先级最高的段对应的文档号&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;  &lt;span&gt;由于新的段也是段内排序的，所以我们从优先级队列中有序的取出后再写入到新段，使得新的段也能保持有序&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;第二步：根据文档号从索引文件.fdt中读取一个Chunk，然后这个Chunk中找到这个文档号对应的存储域信息&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;  &lt;span&gt;其读取过程正如文章&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/Search/2020/1102/174.html&quot;&gt;&lt;span&gt;索引文件的读取（十四）之fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm&lt;/span&gt;&lt;/a&gt;&lt;span&gt;中的内容，按照下面的流程图读取：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图8：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/8.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;图8中根据文档号从一个段中取出了对应的存储域的信息，Document描述。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;第三步：将存储域的信息写入到新的索引文件中&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;  &lt;span&gt;其写入过程正如文章&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/Index/2020/1015/170.html&quot;&gt;&lt;span&gt;索引文件的生成（二十三）之fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm&lt;/span&gt;&lt;/a&gt;&lt;span&gt;中的内容，按照下面的流程图写入：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图9：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/9.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;图9中用&lt;/span&gt;&lt;font&gt;&lt;span&gt;红框&lt;/span&gt;&lt;/font&gt;&lt;span&gt;标注的流程点描述了当前步骤需要执行的写入操作。这里标注的目的是为了与其他的合并方式相比较，下文中会展开介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;重复上述3个步骤，直到所有待合并的段中的文档号都被处理结束。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;执行optimized merge&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;图10：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/10.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;执行optimized merge的过程同naive merge一样可以划分为下面的步骤：&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;第一步：从图5的优先级队列中找到优先级最高的段对应的文档号&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;  &lt;span&gt;同naive merge。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;第二步：根据文档号从索引文件.fdt中读取一个Chunk，然后这个Chunk中找到这个文档号对应的存储域信息&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;  &lt;span&gt;同naive merge。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;第三步：将存储域的信息写入到新的索引文件中&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;  &lt;span&gt;其写入过程正如文章&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/Index/2020/1015/170.html&quot;&gt;&lt;span&gt;索引文件的生成（二十三）之fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm&lt;/span&gt;&lt;/a&gt;&lt;span&gt;中的内容，按照下面的流程图写入：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图11：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/11.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;相比较图9，发现optimized merge不需要执行&lt;/span&gt;&lt;code&gt;处理存储域的域值信息&lt;/code&gt;&lt;span&gt;这步骤。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么不用执行&lt;/span&gt;&lt;code&gt;处理存储域的域值信息&lt;/code&gt;&lt;span&gt;这两个流程：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;我们先看下存储域的域值信息包含了什么信息，如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图12：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/12.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;图12中，使用bufferedDocs[ &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;数组存放存储域的域值信息（该数组的详细介绍见文章&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/Index/2020/1015/170.html&quot;&gt;&lt;span&gt;索引文件的生成（二十三）之fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm&lt;/span&gt;&lt;/a&gt;&lt;span&gt;），可见包含了&lt;/span&gt;&lt;font&gt;&lt;span&gt;红框&lt;/span&gt;&lt;/font&gt;&lt;span&gt;标注的域的编号的信息。如果待合并的段集合中某一个或多个段的域的编号信息跟MergeState中的域的编号mergeFieldInfos（见文章&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/Index/2020/1130/180.html&quot;&gt;&lt;span&gt;索引文件的合并（一）之fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm&lt;/span&gt;&lt;/a&gt;&lt;span&gt;的图4）不一致，就需要重新获取域的编号信息，意味着图12中的存储域的域值信息会发生变化。反之，如果某个待合并的段中的域的编号跟MergeState中的域的编号信息一致，则可以&lt;/span&gt;&lt;strong&gt;&lt;span&gt;复用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;图12中的域值信息。那么只要&lt;/span&gt;&lt;strong&gt;&lt;span&gt;拷贝&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;文档对应在图12中的存储域的域值信息（字节流）到新段的bufferedDoc[ &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;数组中即可，即不用通过执行&lt;/span&gt;&lt;code&gt;处理存储域的域值信息&lt;/code&gt;&lt;span&gt;给新段的bufferedDoc[ &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;数组赋值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图13：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.amazingkoala.com.cn/uploads/lucene/index/索引文件的合并/索引文件的合并（二）/13.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;上文中我们提到合并过程是依次处理段中的每篇文档，那么如何根据某个待合并的段中的文档号，找到它对应的存储域的域值信息呢，即如果当前处理的文档号0，如何从找到图13中找到文档号0的存储域的域值信息在索引文件.fdx的数据区间呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  &lt;span&gt;在图8中，当我们执行了流程点&lt;/span&gt;&lt;code&gt;读取一个Chunk&lt;/code&gt;&lt;span&gt;之后，即获得了图13中的DocFieldCounts以及DocLengths字段信息，根据这两个信息就可以获得某篇文档的存储域的信息在索引文件.fdx的数据区间。感兴趣的朋友可以阅读文章&lt;/span&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/Lucene/Index/2020/1015/170.html&quot;&gt;&lt;span&gt;索引文件的生成（二十三）之fdx&amp;amp;&amp;amp;fdt&amp;amp;&amp;amp;fdm&lt;/span&gt;&lt;/a&gt;&lt;span&gt;中的介绍，本文中不赘述。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;  &lt;span&gt;通过上文介绍，我们了解s了为什么要执行不同的合并方式以及&lt;/span&gt;&lt;font&gt;&lt;span&gt;naive merge&lt;/span&gt;&lt;/font&gt;&lt;span&gt;以及&lt;/span&gt;&lt;font&gt;&lt;span&gt;optimized merge&lt;/span&gt;&lt;/font&gt;&lt;span&gt;的区别，其实差别并不是太大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.amazingkoala.com.cn/attachment/Lucene/Index/索引文件的合并/索引文件的合并（二）/索引文件的合并（二）.zip&quot;&gt;&lt;span&gt;点击&lt;/span&gt;&lt;/a&gt;&lt;span&gt;下载附件&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>