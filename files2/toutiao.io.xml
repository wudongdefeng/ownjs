<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b242b634aeb1260fb4001cfecad8ae0a</guid>
<title>Go高性能之方法接收器 - 指针vs值</title>
<link>https://toutiao.io/k/ce3z1rn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body blogpost-body-html&quot;&gt;
&lt;p class=&quot;&quot;&gt;
&lt;h1 id=&quot;044c&quot; class=&quot;pw-post-title it iu iv bn iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr fx&quot; data-selectable-paragraph=&quot;&quot;/&gt;
&lt;/p&gt;
&lt;figure class=&quot;gm go jt ju jv jw gi gj paragraph-image&quot;&gt;

&lt;/figure&gt;
&lt;h2 class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot;&gt;示例&lt;/h2&gt;
&lt;p id=&quot;b728&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;如果您是 Go 新手，那么您一定遇到过方法和函数的概念。让我们找出两者之间的区别-&lt;/p&gt;
&lt;p id=&quot;f211&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;通过指定参数的类型、返回值和函数&lt;/strong&gt;体来声明函数。&lt;/p&gt;
&lt;pre class=&quot;lb lc ld le gu lf bt lg highlighter-hljs&quot;&gt;&lt;code&gt;type Person struct { 
    Name string 
    Age int 
}func NewPerson(name string, age int) *Person { 
  return &amp;amp;Person{ 
     Name: name, 
     Age: age, 
  } 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p id=&quot;c137&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;方法&lt;/strong&gt;只是一个带有接收器参数的函数。它使用相同的语法声明，并添加了&lt;strong class=&quot;kf iw&quot;&gt;接收者&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;lb lc ld le gu lf bt lg highlighter-hljs&quot;&gt;&lt;code&gt;func (p *Person) isAdult bool { 
  return p.Age &amp;gt; 18 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p id=&quot;046b&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;在上面的方法声明中，我们在类型上声明了&lt;code class=&quot;fm ls lt lu lj b&quot;&gt;isAdult&lt;/code&gt;方法。&lt;code class=&quot;fm ls lt lu lj b&quot;&gt;*Person&lt;/code&gt;&lt;/p&gt;
&lt;p id=&quot;8909&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;现在我们将看到值接收器&lt;/strong&gt;和&lt;strong class=&quot;kf iw&quot;&gt;指针&lt;/strong&gt;接收器之间的区别&lt;strong class=&quot;kf iw&quot;&gt;&lt;em class=&quot;lv&quot;&gt;。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p id=&quot;b1d1&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;值接收者&lt;/strong&gt;复制类型并将其传递给函数。函数堆栈现在拥有一个相等的对象，但在内存上的不同位置。这意味着对传递的对象所做的任何更改都将保留在该方法的本地。原始对象将保持不变。&lt;/p&gt;
&lt;p id=&quot;deaf&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;指针接收器&lt;/strong&gt;将类型的地址传递给函数。函数堆栈具有对原始对象的引用。因此对传递对象的任何修改都会修改原始对象。&lt;/p&gt;
&lt;p id=&quot;e874&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;让我们通过示例来理解这一点-&lt;/p&gt;
&lt;pre class=&quot;language-go highlighter-hljs&quot;&gt;&lt;code&gt;package main
import (
  &quot;fmt&quot;
)
type Person struct {
    Name string
    Age  int
}
func ValueReceiver(p Person) {
    p.Name = &quot;John&quot;
    fmt.Println(&quot;Inside ValueReceiver : &quot;, p.Name)
}
func PointerReceiver(p *Person) {
    p.Age = 24
    fmt.Println(&quot;Inside PointerReceiver model: &quot;, p.Age)
}
func main() {
    p := Person{&quot;Tom&quot;, 28}
    p1:= &amp;amp;Person{&quot;Patric&quot;, 68}
    ValueReceiver(p)
fmt.Println(&quot;Inside Main after value receiver : &quot;, p.Name)
    PointerReceiver(p1)
fmt.Println(&quot;Inside Main after value receiver : &quot;, p1.Age)
}

------------
Inside ValueReceiver :  John
Inside Main after value receiver :  Tom
Inside PointerReceiver :  24
Inside Main after pointer receiver :  24&lt;/code&gt;&lt;/pre&gt;
&lt;p id=&quot;5d23&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;这表明具有值接收者的方法修改了对象的副本，而原始对象保持不变。Like- 通过 ValueReceiver 方法将一个人的姓名从 Tom 更改为 John，但这种更改并未反映在 main 方法中。另一方面，带有指针接收器的方法会修改实际对象。Like- 通过 PointerReceiver 方法将人的年龄从 68 岁更改为 24 岁，同样的变化反映在 main 方法中。您可以通过在指针或值接收器操作之前和之后打印出对象的地址来检查事实。&lt;/p&gt;
&lt;p id=&quot;0a49&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;那么如何在 Pointer 和 Value 接收器之间进行选择呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p id=&quot;9f6b&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;如果要更改方法中接收器的状态，操作它的值，请&lt;strong class=&quot;kf iw&quot;&gt;使用指针接收器&lt;/strong&gt;。使用按值复制的值接收器是不可能的。对值接收器的任何修改对于该副本都是本地的。如果您不需要操作接收器值，请&lt;strong class=&quot;kf iw&quot;&gt;使用值接收器&lt;/strong&gt;。&lt;/p&gt;
&lt;p id=&quot;e4fb&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;指针接收器避免在每个方法调用上复制值。如果接收器是一个大型结构，这可能会更有效，&lt;/p&gt;
&lt;p id=&quot;6b48&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;值接收器是并发安全的，而指针接收器不是并发安全的。因此，程序员需要照顾它。&lt;/p&gt;
&lt;h2 id=&quot;32e0&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;汇总：&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;mk ml gq gs mm mn&quot;&gt;
&lt;div class=&quot;mo o fo&quot;&gt;
&lt;div class=&quot;mp o db dy eo mq&quot;&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果接收者是 map、func 或 chan，不要使用指向它的指针。&lt;/li&gt;
&lt;li&gt;尽量对所有方法使用相同的接收器类型。&lt;/li&gt;
&lt;li&gt;如果接收者是一个切片并且该方法没有重新切片或重新分配切片，则不要使用指向它的指针。&lt;/li&gt;
&lt;li&gt;如果方法需要改变接收者，接收者必须是一个指针。&lt;/li&gt;
&lt;li&gt;如果接收者是包含&lt;code&gt;sync.Mutex&lt;/code&gt;或类似同步字段的结构，则接收者必须是指针以避免复制。&lt;/li&gt;
&lt;li&gt;如果接收器是大型结构或数组，则指针接收器效率更高。大有多大？假设它相当于将其所有元素作为参数传递给方法。如果感觉太大，那么对于接收器来说也太大了。&lt;/li&gt;
&lt;li&gt;函数或方法是否可以同时或在从此方法调用时改变接收者？调用方法时，值类型会创建接收器的副本，因此外部更新不会应用于此接收器。如果更改必须在原始接收器中可见，则接收器必须是指针。&lt;/li&gt;
&lt;li&gt;如果接收器是结构体、数组或切片，并且它的任何元素都是指向可能发生变化的东西的指针，则更喜欢指针接收器，因为它会使读者更清楚意图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果接收者是一个小数组或结构，它自然是一个值类型&lt;/strong&gt;（例如，类似&lt;code&gt;time.Time&lt;/code&gt;类型），没有可变字段和指针，或者只是一个简单的基本类型，如 int 或 string，&lt;strong&gt;则值接收器更好&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;值接收器可以减少可以生成的垃圾量；如果将值传递给值方法，则可以使用堆栈上的副本而不是在堆上分配。&lt;/strong&gt;（编译器试图巧妙地避免这种分配，但它并不总是成功。）不要在没有首先进行分析的情况下选择值接收器类型。&lt;/li&gt;
&lt;li&gt;最后，当有疑问时，使用指针接收器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;原文： https://medium.com/globant/go-method-receiver-pointer-vs-value-ffc5ab7acdb&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>00339f9d2c0753da78ec2e1129b5ff09</guid>
<title>8 个常用的 Wireshark 使用技巧，一看就会</title>
<link>https://toutiao.io/k/t6x6cfn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;↓&lt;/span&gt;&lt;span&gt;推荐关注↓&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwNjMxMTgwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/IgylNib7ZE2L6Kv5EcGWb5mYVbzlgzP2R6qdGee7kZ03T7nia7rtkSnKvEvEOwnGxX4Zf2VVrlQNwWVrLlEhn4OQ/0?wx_fmt=png&quot; data-nickname=&quot;Go开发大全&quot; data-alias=&quot;goprogrammer&quot; data-signature=&quot;点击获取6万star的Go开源库。[ Go开发大全 ] 日常分享 Go, 云原生、k8s、Docker和微服务方面的技术文章和行业动态。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;strong&gt;一：数据包过滤&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a. 过滤需要的IP地址 ip.addr==&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12815884476534295&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDFHiarPibvXdr9OnictjWJwj6T9Ubp1eicGPrmgGq4BbIuU4CqntQeuAHcQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b. 在数据包过滤的基础上过滤协议ip.addr==xxx.xxx.xxx.xxx and tcp&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15342960288808663&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDibkQEwicne0qoXYWyDYBbBTQlgWwCbOJP5Fw7S1wdNbXNyuZjNhEleTA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;c. 过滤端口ip.addr==xxx.xxx.xxx.xxx and http and tcp.port==80&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14095238095238094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDUHLTJYUYp0ia5rOiayLUGXvDI80oL5LYaicLwTe5NXaagiaQ5zE5gFhzQA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;525&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;d. 指定源地址 目的地址ip.src==xxx.xxx.xxx.xxx and ip.dst==xxx.xxx.xxx.xxx&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22535211267605634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDmZBW07MYKYiadrmxXh7VKZBJ1MKqwVQDGFEesxuxtL4k3szdQtx9TFw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;568&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;e. SEQ字段（序列号）过滤（定位丢包问题）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP数据包都是有序列号的，在定位问题的时候，我们可以根据这个字段来给TCP报文排序，发现哪个数据包丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SEQ分为相对序列号和绝对序列号，默认是相对序列号显示就是0 1不便于查看，修改成绝对序列号方法请参考第三式。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08483754512635379&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVD4PIhWGU5r7EL0XuOG3u1ia06mNuI8O5awAtDZibnfibmic5Gv329OG4u8g/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;strong&gt;二：修改数据包时间显示方式&lt;/strong&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些同学抓出来的数据包，时间显示的方式不对，不便于查看出现问题的时间点，可以通过View---time display format来进行修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改前：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29061371841155237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDE1D7MicjibZL6DN62BhBCRVVrKT9EcrPkTO5Irkvx33ZfTUjFTO9GZqQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改后：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4337568058076225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVD2HopXZD7IpAfvQzeFoB74lEqNo5vDfpe03w399AapibEjcMe88pp9iag/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;551&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2688888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDcnCHgtxv0ib7F8BjiaMpmyYAJXhic1aeEWPQgfzxNIx3NXwhyew2CY1mQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;450&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;三：确认数据报文顺序&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一些特殊情况，客户的业务源目的IP 源目的端口 源目的mac 都是一样的，有部分业务出现业务不通，我们在交换机上做流统计就不行了，如下图网络架构。箭头是数据流的走向，交换机上作了相关策略PC是不能直接访问SER的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6458797327394209&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDsIAuSicTnm7EMoYoPzf6H6358mZnKQn2jibHOa2BKiaH5VwxoeDzg7ZibA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;449&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们在排查这个问题的时候，我们要了解客户的业务模型和所使用得协议，很巧合这个业务是WEB。我们从而知道TCP报文字段里是有序列号的，我们可以把它当做唯一标示来进行分析，也可以通过序列号进行排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般抓出来的都是相对序列号0 1不容易分析，这里我们通过如下方式进行修改为绝对序列号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Edit-----preference------protocols----tcp---relative sequence numbers&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2833935018050541&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDx6pypozqjpQHCXYmsU37q36xIt9lOBOtDLZPFRqQIoE7s4tKibU8Y1A/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改参数如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5466237942122187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDfGh1zVjfSpicY3HkSFkHOQ7HYpUs3mb8wsibNe76lh76A1UKYaSSoIYA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;311&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我拿TCP协议举例&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3887884267631103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVD6YT0LKLogiam6DcJoEOyW6jKBiaCaLNDyQ6fic50APLEzMicfI39hE8RaA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;553&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把TCP的这个选项去除掉&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30324909747292417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDjzVnHgic24QcVltkeuevMAu0g546ZSiaU1qCuVUL3ddtN4tDxujFaDRA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后的效果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16425992779783394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDapfUrmoZwxkfWUNxIhncibuAHsiaz5iaJpqGRCyYcWf2ChWrtD2ia9ho9A/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;四：过滤出来的数据包保存&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们抓取数据包的时候数据量很大，但对于我们有用的只有几个，我们按条件过滤之后，可以把过滤后的数据包单独保存出来，便于以后来查看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8343949044585988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDvFD5c6Hh61icybqwffUkibPQwxG0fFTqzJnNkoIRwbcN6jxr1t0P5ia1A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;314&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.575812274368231&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDbRHZ4RhV7gLkCL37egvpOP1fgvAd1qA10EicPcic4crT5SPlDBjRibPEg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;五：数据包计数统计&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络里有泛洪攻击的时候，我们可以通过抓包进行数据包个数的统计，来发现哪些数据包较多来进行分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Statistics------conversations&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3614190687361419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVD3uQ0UQiaNTicXbMph1LSB6dwlCUNCCW1x5iakoGmYiayFJAricnGMKfxmMQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;451&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5207956600361664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDr80CsMMMH17bNjF3y6R8R9n8hnsLUZYXzaiaVIjiasSTq5xxQLcXgL0g/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;553&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;六：数据包解码&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IPS发送攻击日至和防病毒日志信息端口号都是30514，SecCenter上只显示攻击日志，不显示防病毒日志。查看IPS本地有病毒日志，我们可以通过在SecCenter抓包分析确定数据包是否发送过来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发过来的数据量比较大，而且无法直接看出是IPS日志还是AV日志，我们先把数据包解码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（由于没有IPS的日志抓包信息，暂用其他代替）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解码前：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16198347107438016&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDPgl6wEbDVOptQ6ngBrElczPEbsU6Gg02aGOAGfQzrbMPQkjuY8xJow/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;605&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解码操作：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7854609929078015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVD0uhgvCBlGzzy3WTJHkMPADmzQVVpdACEdcJUsE5psPltiaERO6WRO2w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;564&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5149384885764499&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDxHKBqGUfrwUMYarzZVbCWyhrW2z2a4HZeFfcN2TtgZXoHj8UncicpkQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;569&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解码后：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2820976491862568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVD0D4NXOG7yhLz8KDV7CmpdzuOiaGgOjyRHxuepaDsRea1wLgt03X3AjA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;553&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;七：TCP数据报文跟踪&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看TCP的交互过程，把数据包整个交互过程提取出来，便于快速整理分析。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8136986301369863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDibU5KPFyGhodBRd3logm3SZ5Mo3nWAHESzDWJamzoTiaUq7UY3Hjmxzw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;365&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8014440433212996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDY9T2rqTS0gkPfPuCI2osdDIW92WE9iaKFdsDaJhLjTu8OJXR8mw00qw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;八：通过Wireshark来查看设备的厂家&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看无线干扰源的时候，我们可以看出干扰源的mac地址，我们可以通过Wireshark来查找是哪个厂商的设备，便于我们快速寻找干扰源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：mac地址是A4-4E-31-30-0B-E0&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26173285198555957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDlQEp43GOianGPJ8BayM2icO8RGcGxJIkoZaStyIJ9ZemJmiaJImgLvlbQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过Wireshark安装目录下的manuf文件来查找&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1967509025270758&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I7vS3FZsGcAcxgKqg8m2xLGTBNAHlsVDBIfTuJBtwnfSppntDxcEoicLQIkrb6wE7jT66A6pLdGMJV1VAZgRJbA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者：&lt;/span&gt;&lt;span&gt;假面生&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/weixin_44767040/article/details/125479067&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;svg&quot; data-w=&quot;150&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/SQd7RF5caa2sRkiaG4Lib8FHMVW1Ne13lrN37SiaB2ibEDF4OD31Vxh71vWXuOC2VaWME2CltDJsGdA5LnsdhdJianUR3GkoXe1Nx/640?wx_fmt=svg&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;加主页君微信，不仅Linux技能+1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;svg&quot; data-w=&quot;150&quot; class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/SQd7RF5caa2sRkiaG4Lib8FHMVW1Ne13lr4b5vuiaNBnGZKzQI3kAgC4XOZVFnBxvvrXI2GOpiaH06UjrJSc4fqoPBZDKzPVRicCN/640?wx_fmt=svg&quot;/&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8666666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzDNI6O6hCFBc2O6VZiaHtzQn9pYBAmTD9EaEHCDBLkxE8Pln85fKLpIy3sRib8FX0Lzoagbs8TYxC5aAgTubZyw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;主页君日常还会在个人微信分享&lt;span&gt;&lt;strong&gt;Linux相关&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;资源&lt;/strong&gt;&lt;/span&gt;和&lt;strong&gt;精选&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;技术文章&lt;/strong&gt;&lt;/span&gt;，不定期分享一些&lt;span&gt;&lt;strong&gt;有意思的活动&lt;/strong&gt;&lt;/span&gt;、&lt;span&gt;&lt;strong&gt;岗位内推&lt;/strong&gt;&lt;/span&gt;以及&lt;span&gt;&lt;strong&gt;如何用技术做业余项目&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;147&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;147&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb19JTKibRMq2ZEp7XsU1dfgNDoHYFn1ic1ibOHjHFlADWjicibkZgL5XG60vbokfpic28IfLUe3Lj6k2uzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span&gt;加个微信，打开一扇窗&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666551688&amp;amp;idx=3&amp;amp;sn=12db62bdafb853d16abc2639cce8ca11&amp;amp;chksm=80dc9d23b7ab143582d9ad4ce237bfd793520bb30d7ea96d26bf318982ae26f017bdb0ddab17&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我是如何使用 wireshark 软件的&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;我是如何使用 wireshark 软件的&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666564239&amp;amp;idx=2&amp;amp;sn=2b9ffe28f04c90a7619f1cf04d745563&amp;amp;chksm=80dc4e24b7abc73260e9af568ca286f8aea66fd1a0c25ff6b52ec65c795709bbcc5b2f9b880c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Linux 网络基础与性能优化&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Linux 网络基础与性能优化&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666564328&amp;amp;idx=1&amp;amp;sn=ec533eec11eb3a1768f693a57b2d4318&amp;amp;chksm=80dc4e43b7abc7554c573b17d82c73615c3b3d5f10dae0524b93dac019ae0c42cbf14f416055&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Linus 这 6 件鲜为人知的趣事&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Linus 这 6 件鲜为人知的趣事&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完&lt;/span&gt;&lt;span&gt;本文有收获？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;推荐关注「Linux 爱好者」，提升Linux技能&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxODI5ODMwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb3sjicd8JxDra10FRIqT54Zke2sfhibTDdtdnVhv5Qh3wLHZmKPjiaD7piahMAzIH6Cnltd1Nco17Ihjw/0?wx_fmt=png&quot; data-nickname=&quot;Linux爱好者&quot; data-alias=&quot;LinuxHub&quot; data-signature=&quot;点击获取《每天一个Linux命令》系列和精选Linux技术资源。「Linux爱好者」日常分享 Linux/Unix 相关内容，包括：工具资源、使用技巧、课程书籍等。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5c78ef803dd7ae0f6e289e7e897303eb</guid>
<title>Spring 常见面试题总结</title>
<link>https://toutiao.io/k/o96473m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-9scqi7&quot; options=&quot;[object Object]&quot;&gt;&lt;blockquote data-first-child=&quot;&quot; data-pid=&quot;7v8EVnCm&quot;&gt;首发于 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide 在线网站&lt;/a&gt;：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spring 常见面试题总结&lt;/a&gt;&lt;/blockquote&gt;&lt;p data-pid=&quot;nudy96yg&quot;&gt;最近在对 JavaGuide 的内容进行重构完善，同步一下最新更新，希望能够帮助你。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring 基础&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;什么是 Spring 框架?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;gK7cNc4l&quot;&gt;Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。&lt;/p&gt;&lt;p data-pid=&quot;9y3MEOYq&quot;&gt;我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f8338a1bb365c97b5514762e1156a7ac_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;361&quot; data-rawheight=&quot;741&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;361&quot; data-rawheight=&quot;741&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f8338a1bb365c97b5514762e1156a7ac_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Wzqeg5Zo&quot;&gt;Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。&lt;/p&gt;&lt;p data-pid=&quot;nkkpEFrV&quot;&gt;Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！&lt;/p&gt;&lt;p data-pid=&quot;KUbDkD9a&quot;&gt;  多提一嘴 ： &lt;b&gt;语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;Z3LwOmca&quot;&gt;Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring 包含的模块有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;tKbFa114&quot;&gt;&lt;b&gt;Spring4.x 版本&lt;/b&gt; ：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring4.x主要模块&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;nXvexO22&quot;&gt;&lt;b&gt;Spring5.x 版本&lt;/b&gt; ：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring5.x主要模块&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;1FFgtFmt&quot;&gt;Spring5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。&lt;/p&gt;&lt;p data-pid=&quot;iLr4QDIn&quot;&gt;Spring 各个模块的依赖关系如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;937&quot; data-rawheight=&quot;738&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;937&quot; data-rawheight=&quot;738&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring 各个模块的依赖关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;Core Container&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;Z_VVMrNv&quot;&gt;Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;K3646QSV&quot;&gt;&lt;b&gt;spring-core&lt;/b&gt; ：Spring 框架基本的核心工具类。&lt;/li&gt;&lt;li data-pid=&quot;9vF9JBGs&quot;&gt;&lt;b&gt;spring-beans&lt;/b&gt; ：提供对 bean 的创建、配置和管理等功能的支持。&lt;/li&gt;&lt;li data-pid=&quot;e_L8kqkr&quot;&gt;&lt;b&gt;spring-context&lt;/b&gt; ：提供对国际化、事件传播、资源加载等功能的支持。&lt;/li&gt;&lt;li data-pid=&quot;FXeHR3NT&quot;&gt;&lt;b&gt;spring-expression&lt;/b&gt; ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;AOP&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;k3Y99d18&quot;&gt;&lt;b&gt;spring-aspects&lt;/b&gt; ：该模块为与 AspectJ 的集成提供支持。&lt;/li&gt;&lt;li data-pid=&quot;huVeaLav&quot;&gt;&lt;b&gt;spring-aop&lt;/b&gt; ：提供了面向切面的编程实现。&lt;/li&gt;&lt;li data-pid=&quot;Ru-XhdwN&quot;&gt;&lt;b&gt;spring-instrument&lt;/b&gt; ：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Data Access/Integration&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;ut4kt8eN&quot;&gt;&lt;b&gt;spring-jdbc&lt;/b&gt; ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。&lt;/li&gt;&lt;li data-pid=&quot;u6CCJnXq&quot;&gt;&lt;b&gt;spring-tx&lt;/b&gt; ：提供对事务的支持。&lt;/li&gt;&lt;li data-pid=&quot;wMXqLx40&quot;&gt;&lt;b&gt;spring-orm&lt;/b&gt; ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。&lt;/li&gt;&lt;li data-pid=&quot;7TWjI5yE&quot;&gt;&lt;b&gt;spring-oxm&lt;/b&gt; ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。&lt;/li&gt;&lt;li data-pid=&quot;PQQ1os_S&quot;&gt;&lt;b&gt;spring-jms&lt;/b&gt; : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Spring Web&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;ixrALGGU&quot;&gt;&lt;b&gt;spring-web&lt;/b&gt; ：对 Web 功能的实现提供一些最基础的支持。&lt;/li&gt;&lt;li data-pid=&quot;Fqkiq7ES&quot;&gt;&lt;b&gt;spring-webmvc&lt;/b&gt; ： 提供对 Spring MVC 的实现。&lt;/li&gt;&lt;li data-pid=&quot;Dm7DFm8K&quot;&gt;&lt;b&gt;spring-websocket&lt;/b&gt; ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。&lt;/li&gt;&lt;li data-pid=&quot;D33QNDHo&quot;&gt;&lt;b&gt;spring-webflux&lt;/b&gt; ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Messaging&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;RT4slfth&quot;&gt;&lt;b&gt;spring-messaging&lt;/b&gt; 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring Test&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;imfUldaz&quot;&gt;Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。&lt;/p&gt;&lt;p data-pid=&quot;e7_s0ZCP&quot;&gt;Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring,Spring MVC,Spring Boot 之间什么关系?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;552oxAOt&quot;&gt;很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。&lt;/p&gt;&lt;p data-pid=&quot;Lo53yncr&quot;&gt;Spring 包含了多个功能模块（上面刚刚提高过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。&lt;/p&gt;&lt;p data-pid=&quot;u94FbZd1&quot;&gt;下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring主要模块&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;sLPRMK7M&quot;&gt;Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;tviio8fC&quot;&gt;使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！&lt;/p&gt;&lt;p data-pid=&quot;_tTViVxb&quot;&gt;Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。&lt;/p&gt;&lt;p data-pid=&quot;2SM3d5Pl&quot;&gt;Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring IoC&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;谈谈自己对于 Spring IoC 的了解&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;SBXNboai&quot;&gt;&lt;b&gt;IoC（Inverse of Control:控制反转）&lt;/b&gt; 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。&lt;/p&gt;&lt;p data-pid=&quot;fW1gtPK6&quot;&gt;&lt;b&gt;为什么叫控制反转？&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;B6SckJBD&quot;&gt;&lt;b&gt;控制&lt;/b&gt; ：指的是对象创建（实例化、管理）的权力&lt;/li&gt;&lt;li data-pid=&quot;GLIM5TGd&quot;&gt;&lt;b&gt;反转&lt;/b&gt; ：控制权交给外部环境（Spring 框架、IoC 容器）&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;392&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;392&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;4LuYZ-w-&quot;&gt;将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。&lt;/p&gt;&lt;p data-pid=&quot;bOszsPJG&quot;&gt;在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。&lt;/p&gt;&lt;p data-pid=&quot;eZbIM2rD&quot;&gt;在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。&lt;/p&gt;&lt;p data-pid=&quot;5kTCxP1X&quot;&gt;Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。&lt;/p&gt;&lt;p data-pid=&quot;FgGYn69z&quot;&gt;相关阅读：&lt;/p&gt;&lt;h3&gt;&lt;b&gt;什么是 Spring Bean？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;FmIDeai2&quot;&gt;简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。&lt;/p&gt;&lt;p data-pid=&quot;ns-UaZHb&quot;&gt;我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;!-- Constructor-arg with &#x27;value&#x27; attribute --&amp;gt;
&amp;lt;bean id=&quot;...&quot; class=&quot;...&quot;&amp;gt;
   &amp;lt;constructor-arg value=&quot;...&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;p7yBC_xT&quot;&gt;下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;498&quot; data-rawheight=&quot;296&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;498&quot; data-rawheight=&quot;296&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;wrhDSNuR&quot;&gt;&lt;code&gt;org.springframework.beans&lt;/code&gt;和 &lt;code&gt;org.springframework.context&lt;/code&gt; 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看&lt;/p&gt;&lt;h3&gt;&lt;b&gt;将一个类声明为 Bean 的注解有哪些?&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;ruYnlbtH&quot;&gt;&lt;code&gt;@Component&lt;/code&gt; ：通用的注解，可标注任意类为 &lt;code&gt;Spring&lt;/code&gt; 组件。如果一个 Bean 不知道属于哪个层，可以使用&lt;code&gt;@Component&lt;/code&gt; 注解标注。&lt;/li&gt;&lt;li data-pid=&quot;pzCmtxnN&quot;&gt;&lt;code&gt;@Repository&lt;/code&gt; : 对应持久层即 Dao 层，主要用于数据库相关操作。&lt;/li&gt;&lt;li data-pid=&quot;L0-1d8MF&quot;&gt;&lt;code&gt;@Service&lt;/code&gt; : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。&lt;/li&gt;&lt;li data-pid=&quot;BvA9rlar&quot;&gt;&lt;code&gt;@Controller&lt;/code&gt; : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;@Component 和 @Bean 的区别是什么？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;II1X1pC6&quot;&gt;&lt;code&gt;@Component&lt;/code&gt; 注解作用于类，而&lt;code&gt;@Bean&lt;/code&gt;注解作用于方法。&lt;/li&gt;&lt;li data-pid=&quot;w2N1fWU2&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 &lt;code&gt;@ComponentScan&lt;/code&gt; 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。&lt;code&gt;@Bean&lt;/code&gt; 注解通常是我们在标有该注解的方法中定义产生这个 bean,&lt;code&gt;@Bean&lt;/code&gt;告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。&lt;/li&gt;&lt;li data-pid=&quot;UKnx-hWg&quot;&gt;&lt;code&gt;@Bean&lt;/code&gt; 注解比 &lt;code&gt;@Component&lt;/code&gt; 注解的自定义性更强，而且很多地方我们只能通过 &lt;code&gt;@Bean&lt;/code&gt; 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 &lt;code&gt;Spring&lt;/code&gt;容器时，则只能通过 &lt;code&gt;@Bean&lt;/code&gt;来实现。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;vVHWsDfQ&quot;&gt;&lt;code&gt;@Bean&lt;/code&gt;注解使用示例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;It87G_W3&quot;&gt;上面的代码相当于下面的 xml 配置&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;beans&amp;gt;
    &amp;lt;bean id=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;FoCf2n4m&quot;&gt;下面这个例子是通过 &lt;code&gt;@Component&lt;/code&gt; 无法实现的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Bean
public OneService getService(status) {
    case (status)  {
        when 1:
                return new serviceImpl1();
        when 2:
                return new serviceImpl2();
        when 3:
                return new serviceImpl3();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;注入 Bean 的注解有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;W8Ny18vq&quot;&gt;Spring 内置的 &lt;code&gt;@Autowired&lt;/code&gt; 以及 JDK 内置的 &lt;code&gt;@Resource&lt;/code&gt; 和 &lt;code&gt;@Inject&lt;/code&gt; 都可以用于注入 Bean。&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Annotaion&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Source&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Autowired&lt;/td&gt;&lt;td&gt;org.springframework.bean.factory&lt;/td&gt;&lt;td&gt;Spring 2.5+&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Resource&lt;/td&gt;&lt;td&gt;javax.annotation&lt;/td&gt;&lt;td&gt;Java JSR-250&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Inject&lt;/td&gt;&lt;td&gt;javax.inject&lt;/td&gt;&lt;td&gt;Java JSR-330&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-pid=&quot;gMlXPbS2&quot;&gt;&lt;code&gt;@Autowired&lt;/code&gt; 和&lt;code&gt;@Resource&lt;/code&gt;使用的比较多一些。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;@Autowired 和 @Resource 的区别是什么？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;db5-J1mv&quot;&gt;&lt;code&gt;Autowired&lt;/code&gt; 属于 Spring 内置的注解，默认的注入方式为&lt;code&gt;byType&lt;/code&gt;（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。&lt;/p&gt;&lt;p data-pid=&quot;xGj9T4Tu&quot;&gt;&lt;b&gt;这会有什么问题呢？&lt;/b&gt; 当一个接口存在多个实现类的话，&lt;code&gt;byType&lt;/code&gt;这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。&lt;/p&gt;&lt;p data-pid=&quot;s5bI6VJh&quot;&gt;这种情况下，注入方式会变为 &lt;code&gt;byName&lt;/code&gt;（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 &lt;code&gt;smsService&lt;/code&gt; 就是我这里所说的名称，这样应该比较好理解了吧。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// smsService 就是我们上面所说的名称
@Autowired
private SmsService smsService;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;C4wWKBB5&quot;&gt;举个例子，&lt;code&gt;SmsService&lt;/code&gt; 接口有两个实现类: &lt;code&gt;SmsServiceImpl1&lt;/code&gt;和 &lt;code&gt;SmsServiceImpl2&lt;/code&gt;，且它们都已经被 Spring 容器所管理。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 报错，byName 和 byType 都无法匹配到 bean
@Autowired
private SmsService smsService;
// 正确注入 SmsServiceImpl1 对象对应的 bean
@Autowired
private SmsService smsServiceImpl1;
// 正确注入  SmsServiceImpl1 对象对应的 bean
// smsServiceImpl1 就是我们上面所说的名称
@Autowired
@Qualifier(value = &quot;smsServiceImpl1&quot;)
private SmsService smsService;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;MHg_onW7&quot;&gt;我们还是建议通过 &lt;code&gt;@Qualifier&lt;/code&gt; 注解来显示指定名称而不是依赖变量的名称。&lt;/p&gt;&lt;p data-pid=&quot;at6SLWxr&quot;&gt;&lt;code&gt;@Resource&lt;/code&gt;属于 JDK 提供的注解，默认注入方式为 &lt;code&gt;byName&lt;/code&gt;。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为&lt;code&gt;byType&lt;/code&gt;。&lt;/p&gt;&lt;p data-pid=&quot;hDkxhPVK&quot;&gt;&lt;code&gt;@Resource&lt;/code&gt; 有两个比较重要且日常开发常用的属性：&lt;code&gt;name&lt;/code&gt;（名称）、&lt;code&gt;type&lt;/code&gt;（类型）。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public @interface Resource {
    String name() default &quot;&quot;;
    Class&amp;lt;?&amp;gt; type() default Object.class;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;G320hATB&quot;&gt;如果仅指定 &lt;code&gt;name&lt;/code&gt; 属性则注入方式为&lt;code&gt;byName&lt;/code&gt;，如果仅指定&lt;code&gt;type&lt;/code&gt;属性则注入方式为&lt;code&gt;byType&lt;/code&gt;，如果同时指定&lt;code&gt;name&lt;/code&gt; 和&lt;code&gt;type&lt;/code&gt;属性（不建议这么做）则注入方式为&lt;code&gt;byType&lt;/code&gt;+&lt;code&gt;byName&lt;/code&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 报错，byName 和 byType 都无法匹配到 bean
@Resource
private SmsService smsService;
// 正确注入 SmsServiceImpl1 对象对应的 bean
@Resource
private SmsService smsServiceImpl1;
// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）
@Resource(name = &quot;smsServiceImpl1&quot;)
private SmsService smsService;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Uj-lq32C&quot;&gt;简单总结一下：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;-31wNBNu&quot;&gt;&lt;code&gt;@Autowired&lt;/code&gt; 是 Spring 提供的注解，&lt;code&gt;@Resource&lt;/code&gt; 是 JDK 提供的注解。&lt;/li&gt;&lt;li data-pid=&quot;HhGDk3pn&quot;&gt;&lt;code&gt;Autowired&lt;/code&gt; 默认的注入方式为&lt;code&gt;byType&lt;/code&gt;（根据类型进行匹配），&lt;code&gt;@Resource&lt;/code&gt;默认注入方式为 &lt;code&gt;byName&lt;/code&gt;（根据名称进行匹配）。&lt;/li&gt;&lt;li data-pid=&quot;t8u991iM&quot;&gt;当一个接口存在多个实现类的情况下，&lt;code&gt;@Autowired&lt;/code&gt; 和&lt;code&gt;@Resource&lt;/code&gt;都需要通过名称才能正确匹配到对应的 Bean。&lt;code&gt;Autowired&lt;/code&gt; 可以通过 &lt;code&gt;@Qualifier&lt;/code&gt; 注解来显示指定名称，&lt;code&gt;@Resource&lt;/code&gt;可以通过 &lt;code&gt;name&lt;/code&gt; 属性来显示指定名称。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Bean 的作用域有哪些?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;sCHfawnI&quot;&gt;Spring 中 Bean 的作用域通常有下面几种：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;adS_Yjmj&quot;&gt;&lt;b&gt;singleton&lt;/b&gt; : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。&lt;/li&gt;&lt;li data-pid=&quot;0x3m0pjU&quot;&gt;&lt;b&gt;prototype&lt;/b&gt; : 每次获取都会创建一个新的 bean 实例。也就是说，连续 &lt;code&gt;getBean()&lt;/code&gt; 两次，得到的是不同的 Bean 实例。&lt;/li&gt;&lt;li data-pid=&quot;wXGEz9oQ&quot;&gt;&lt;b&gt;request&lt;/b&gt; （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。&lt;/li&gt;&lt;li data-pid=&quot;DLjm42Xg&quot;&gt;&lt;b&gt;session&lt;/b&gt; （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。&lt;/li&gt;&lt;li data-pid=&quot;Fgsvnpcm&quot;&gt;&lt;b&gt;application/global-session&lt;/b&gt; （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），，该 bean 仅在当前应用启动时间内有效。&lt;/li&gt;&lt;li data-pid=&quot;3TJKID3u&quot;&gt;&lt;b&gt;websocket&lt;/b&gt; （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;R_JdiDTV&quot;&gt;&lt;b&gt;如何配置 bean 的作用域呢？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;UWfZSu2j&quot;&gt;xml 方式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;wE_O5KFG&quot;&gt;注解方式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Bean
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public Person personPrototype() {
    return new Person();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;单例 Bean 的线程安全问题了解吗？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;1Og03y8Z&quot;&gt;大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。&lt;/p&gt;&lt;p data-pid=&quot;VQMo36iv&quot;&gt;常见的有两种解决办法：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;XhmClV0j&quot;&gt;在 Bean 中尽量避免定义可变的成员变量。&lt;/li&gt;&lt;li data-pid=&quot;qzl9CuAk&quot;&gt;在类中定义一个 &lt;code&gt;ThreadLocal&lt;/code&gt; 成员变量，将需要的可变成员变量保存在 &lt;code&gt;ThreadLocal&lt;/code&gt; 中（推荐的一种方式）。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;0kAYvkuM&quot;&gt;不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Bean 的生命周期了解么?&lt;/b&gt;&lt;/h3&gt;&lt;blockquote data-pid=&quot;IXFhwuGZ&quot;&gt; 下面的内容整理自：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//yemengying.com/2016/07/14/spring-bean-life-cycle/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;yemengying.com/2016/07/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;14/spring-bean-life-cycle/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; ，除了这篇文章，再推荐一篇很不错的文章 ：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cnblogs.com/zrtqsk/p/3735273.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cnblogs.com/zrtqsk/p/37&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;35273.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; 。&lt;br/&gt; &lt;/blockquote&gt;&lt;ul&gt;&lt;li data-pid=&quot;0zN289l-&quot;&gt;Bean 容器找到配置文件中 Spring Bean 的定义。&lt;/li&gt;&lt;li data-pid=&quot;YW1HJtU-&quot;&gt;Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。&lt;/li&gt;&lt;li data-pid=&quot;woHD83m4&quot;&gt;如果涉及到一些属性值 利用 &lt;code&gt;set()&lt;/code&gt;方法设置一些属性值。&lt;/li&gt;&lt;li data-pid=&quot;bZvRUqEQ&quot;&gt;如果 Bean 实现了 &lt;code&gt;BeanNameAware&lt;/code&gt; 接口，调用 &lt;code&gt;setBeanName()&lt;/code&gt;方法，传入 Bean 的名字。&lt;/li&gt;&lt;li data-pid=&quot;4Ej1QW4L&quot;&gt;如果 Bean 实现了 &lt;code&gt;BeanClassLoaderAware&lt;/code&gt; 接口，调用 &lt;code&gt;setBeanClassLoader()&lt;/code&gt;方法，传入 &lt;code&gt;ClassLoader&lt;/code&gt;对象的实例。&lt;/li&gt;&lt;li data-pid=&quot;RC-CumvD&quot;&gt;如果 Bean 实现了 &lt;code&gt;BeanFactoryAware&lt;/code&gt; 接口，调用 &lt;code&gt;setBeanFactory()&lt;/code&gt;方法，传入 &lt;code&gt;BeanFactory&lt;/code&gt;对象的实例。&lt;/li&gt;&lt;li data-pid=&quot;oIYb7yhI&quot;&gt;与上面的类似，如果实现了其他 &lt;code&gt;*.Aware&lt;/code&gt;接口，就调用相应的方法。&lt;/li&gt;&lt;li data-pid=&quot;u4S_QHO8&quot;&gt;如果有和加载这个 Bean 的 Spring 容器相关的 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 对象，执行&lt;code&gt;postProcessBeforeInitialization()&lt;/code&gt; 方法&lt;/li&gt;&lt;li data-pid=&quot;N-pE8a6t&quot;&gt;如果 Bean 实现了&lt;code&gt;InitializingBean&lt;/code&gt;接口，执行&lt;code&gt;afterPropertiesSet()&lt;/code&gt;方法。&lt;/li&gt;&lt;li data-pid=&quot;vlqIqrMO&quot;&gt;如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。&lt;/li&gt;&lt;li data-pid=&quot;TPHP8-71&quot;&gt;如果有和加载这个 Bean 的 Spring 容器相关的 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 对象，执行&lt;code&gt;postProcessAfterInitialization()&lt;/code&gt; 方法&lt;/li&gt;&lt;li data-pid=&quot;H8kPiNZZ&quot;&gt;当要销毁 Bean 的时候，如果 Bean 实现了 &lt;code&gt;DisposableBean&lt;/code&gt; 接口，执行 &lt;code&gt;destroy()&lt;/code&gt; 方法。&lt;/li&gt;&lt;li data-pid=&quot;duK-vT4y&quot;&gt;当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;PGYKHLMf&quot;&gt;图示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1272&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1272&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring Bean 生命周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;HxDrXf6p&quot;&gt;与之比较类似的中文版本:&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;303&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;303&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring Bean 生命周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;Spring AoP&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;谈谈自己对于 AOP 的了解&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;2EIq20fg&quot;&gt;AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。&lt;/p&gt;&lt;p data-pid=&quot;_YhGCITC&quot;&gt;Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 &lt;b&gt;JDK Proxy&lt;/b&gt;，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 &lt;b&gt;Cglib&lt;/b&gt; 生成一个被代理对象的子类来作为代理，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_b.jpg&quot;/&gt;&lt;figcaption&gt;SpringAOPProcess&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;EobvLfPN&quot;&gt;当然你也可以使用 &lt;b&gt;AspectJ&lt;/b&gt; ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。&lt;/p&gt;&lt;p data-pid=&quot;oQUxgQQp&quot;&gt;AOP 切面编程设计到的一些专业术语：&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;术语&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;目标(Target)&lt;/td&gt;&lt;td&gt;被通知的对象&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;代理(Proxy)&lt;/td&gt;&lt;td&gt;向目标对象应用通知之后创建的代理对象&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;连接点(JoinPoint)&lt;/td&gt;&lt;td&gt;目标对象的所属类中，定义的所有方法均为连接点&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;切入点(Pointcut)&lt;/td&gt;&lt;td&gt;被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;通知(Advice)&lt;/td&gt;&lt;td&gt;增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;切面(Aspect)&lt;/td&gt;&lt;td&gt;切入点(Pointcut)+通知(Advice)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Weaving(织入)&lt;/td&gt;&lt;td&gt;将通知应用到目标对象，进而生成代理对象的过程动作&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;&lt;b&gt;Spring AOP 和 AspectJ AOP 有什么区别？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;RGLhiVth&quot;&gt;&lt;b&gt;Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。&lt;/b&gt; Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。&lt;/p&gt;&lt;p data-pid=&quot;blSQt703&quot;&gt;Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，&lt;/p&gt;&lt;p data-pid=&quot;3HI6rsG6&quot;&gt;如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;AspectJ 定义的通知类型有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;F9iI7Ud8&quot;&gt;&lt;b&gt;Before&lt;/b&gt;（前置通知）：目标对象的方法调用之前触发&lt;/li&gt;&lt;li data-pid=&quot;n9Rz_UH1&quot;&gt;&lt;b&gt;After&lt;/b&gt; （后置通知）：目标对象的方法调用之后触发&lt;/li&gt;&lt;li data-pid=&quot;s487XRlG&quot;&gt;&lt;b&gt;AfterReturning&lt;/b&gt;（返回通知）：目标对象的方法调用完成，在返回结果值之后触发&lt;/li&gt;&lt;li data-pid=&quot;-b3mz5md&quot;&gt;&lt;b&gt;AfterThrowing&lt;/b&gt;（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。&lt;/li&gt;&lt;li data-pid=&quot;kKn6PK1p&quot;&gt;&lt;b&gt;Around&lt;/b&gt;： （环绕通知）编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;多个切面的执行顺序如何控制？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;O_cPRsP2&quot;&gt;1、通常使用&lt;code&gt;@Order&lt;/code&gt; 注解直接定义切面顺序&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 值越小优先级越高
@Order(3)
@Component
@Aspect
public class LoggingAspect implements Ordered {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;BlsKQy6r&quot;&gt;&lt;b&gt;2、实现&lt;code&gt;Ordered&lt;/code&gt; 接口重写 &lt;code&gt;getOrder&lt;/code&gt; 方法。&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Component
@Aspect
public class LoggingAspect implements Ordered {

    // ....

    @Override
    public int getOrder() {
        // 返回值越小优先级越高
        return 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;Spring MVC&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;说说自己对于 Spring MVC 了解?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;ZJlpHX35&quot;&gt;MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;oiPJZ9m-&quot;&gt;网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于 MVC 同样是众多设计模式中的一种。**&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/iluwatar/java-design-patterns&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;java-design-patterns&lt;/a&gt;** 项目中就有关于 MVC 的相关介绍。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1156&quot; data-rawheight=&quot;1198&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1156&quot; data-rawheight=&quot;1198&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;KZ-dSm4_&quot;&gt;想要真正理解 Spring MVC，我们先来看看 Model 1 和 Model 2 这两个没有 Spring MVC 的时代。&lt;/p&gt;&lt;p data-pid=&quot;oUCRY22U&quot;&gt;&lt;b&gt;Model 1 时代&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;Ojq4C3dj&quot;&gt;很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。&lt;/p&gt;&lt;p data-pid=&quot;gLAcO_-3&quot;&gt;这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;809&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;809&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_b.jpg&quot;/&gt;&lt;figcaption&gt;mvc-mode1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;uGyosULX&quot;&gt;&lt;b&gt;Model 2 时代&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;SahhrTFO&quot;&gt;学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View）+Servlet（Controller） ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;MfjcX4tw&quot;&gt;Model:系统涉及的数据，也就是 dao 和 bean。&lt;/li&gt;&lt;li data-pid=&quot;gxlxwgIN&quot;&gt;View：展示模型中的数据，只是用来展示。&lt;/li&gt;&lt;li data-pid=&quot;5HwM1_YP&quot;&gt;Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;843&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;843&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;OePaph3H&quot;&gt;Model2 模式下还存在很多问题，Model2 的抽象和封装程度还远远不够，使用 Model2 进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。&lt;/p&gt;&lt;p data-pid=&quot;gj4Z27cK&quot;&gt;于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 Struts2，但是 Struts2 比较笨重。&lt;/p&gt;&lt;p data-pid=&quot;OLeNDf1a&quot;&gt;&lt;b&gt;Spring MVC 时代&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;xB0OW7d3&quot;&gt;随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。&lt;/p&gt;&lt;p data-pid=&quot;KSnlHZP0&quot;&gt;MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring MVC 的核心组件有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;QhbNnULh&quot;&gt;记住了下面这些组件，也就记住了 SpringMVC 的工作原理。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;5jTJ7hnr&quot;&gt;&lt;b&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;&lt;/b&gt; ：&lt;b&gt;核心的中央处理器&lt;/b&gt;，负责接收请求、分发，并给予客户端响应。&lt;/li&gt;&lt;li data-pid=&quot;qhihpBNa&quot;&gt;&lt;b&gt;&lt;code&gt;HandlerMapping&lt;/code&gt;&lt;/b&gt; ：&lt;b&gt;处理器映射器&lt;/b&gt;，根据 uri 去匹配查找能处理的 &lt;code&gt;Handler&lt;/code&gt; ，并会将请求涉及到的拦截器和 &lt;code&gt;Handler&lt;/code&gt; 一起封装。&lt;/li&gt;&lt;li data-pid=&quot;9nTue8Ub&quot;&gt;&lt;b&gt;&lt;code&gt;HandlerAdapter&lt;/code&gt;&lt;/b&gt; ：&lt;b&gt;处理器适配器&lt;/b&gt;，根据 &lt;code&gt;HandlerMapping&lt;/code&gt; 找到的 &lt;code&gt;Handler&lt;/code&gt; ，适配执行对应的 &lt;code&gt;Handler&lt;/code&gt;；&lt;/li&gt;&lt;li data-pid=&quot;vp99gvYb&quot;&gt;&lt;b&gt;&lt;code&gt;Handler&lt;/code&gt;&lt;/b&gt; ：&lt;b&gt;请求处理器&lt;/b&gt;，处理实际请求的处理器。&lt;/li&gt;&lt;li data-pid=&quot;6G4LFGQP&quot;&gt;&lt;b&gt;&lt;code&gt;ViewResolver&lt;/code&gt;&lt;/b&gt; ：&lt;b&gt;视图解析器&lt;/b&gt;，根据 &lt;code&gt;Handler&lt;/code&gt; 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 &lt;code&gt;DispatcherServlet&lt;/code&gt; 响应客户端&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;SpringMVC 工作原理了解吗?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;tCwSMP_H&quot;&gt;&lt;b&gt;Spring MVC 原理如下图所示：&lt;/b&gt;&lt;/p&gt;&lt;blockquote data-pid=&quot;VIpptJmE&quot;&gt; SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。&lt;br/&gt; &lt;/blockquote&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;737&quot; data-rawheight=&quot;419&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;737&quot; data-rawheight=&quot;419&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;ourokoQc&quot;&gt;&lt;b&gt;流程说明（重要）：&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;bJrvA-40&quot;&gt;客户端（浏览器）发送请求， &lt;code&gt;DispatcherServlet&lt;/code&gt;拦截请求。&lt;/li&gt;&lt;li data-pid=&quot;JQtdCpTH&quot;&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 根据请求信息调用 &lt;code&gt;HandlerMapping&lt;/code&gt; 。&lt;code&gt;HandlerMapping&lt;/code&gt; 根据 uri 去匹配查找能处理的 &lt;code&gt;Handler&lt;/code&gt;（也就是我们平常说的 &lt;code&gt;Controller&lt;/code&gt; 控制器） ，并会将请求涉及到的拦截器和 &lt;code&gt;Handler&lt;/code&gt; 一起封装。&lt;/li&gt;&lt;li data-pid=&quot;WBR92Nf0&quot;&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 调用 &lt;code&gt;HandlerAdapter&lt;/code&gt;适配执行 &lt;code&gt;Handler&lt;/code&gt; 。&lt;/li&gt;&lt;li data-pid=&quot;c93y2oez&quot;&gt;&lt;code&gt;Handler&lt;/code&gt; 完成对用户请求的处理后，会返回一个 &lt;code&gt;ModelAndView&lt;/code&gt; 对象给&lt;code&gt;DispatcherServlet&lt;/code&gt;，&lt;code&gt;ModelAndView&lt;/code&gt; 顾名思义，包含了数据模型以及相应的视图的信息。&lt;code&gt;Model&lt;/code&gt; 是返回的数据对象，&lt;code&gt;View&lt;/code&gt; 是个逻辑上的 &lt;code&gt;View&lt;/code&gt;。&lt;/li&gt;&lt;li data-pid=&quot;Lf3tF4cG&quot;&gt;&lt;code&gt;ViewResolver&lt;/code&gt; 会根据逻辑 &lt;code&gt;View&lt;/code&gt; 查找实际的 &lt;code&gt;View&lt;/code&gt;。&lt;/li&gt;&lt;li data-pid=&quot;TUNj9_8G&quot;&gt;&lt;code&gt;DispaterServlet&lt;/code&gt; 把返回的 &lt;code&gt;Model&lt;/code&gt; 传给 &lt;code&gt;View&lt;/code&gt;（视图渲染）。&lt;/li&gt;&lt;li data-pid=&quot;uHwPY_aV&quot;&gt;把 &lt;code&gt;View&lt;/code&gt; 返回给请求者（浏览器）&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;统一异常处理怎么做？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;Hwi9N9X9&quot;&gt;推荐使用注解的方式统一异常处理，具体会使用到 &lt;code&gt;@ControllerAdvice&lt;/code&gt; + &lt;code&gt;@ExceptionHandler&lt;/code&gt; 这两个注解 。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    @ExceptionHandler(BaseException.class)
    public ResponseEntity&amp;lt;?&amp;gt; handleAppException(BaseException ex, HttpServletRequest request) {
      //......
    }

    @ExceptionHandler(value = ResourceNotFoundException.class)
    public ResponseEntity&amp;lt;ErrorReponse&amp;gt; handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {
      //......
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Z07RC1lV&quot;&gt;这种异常处理方式下，会给所有或者指定的 &lt;code&gt;Controller&lt;/code&gt; 织入异常处理的逻辑（AOP），当 &lt;code&gt;Controller&lt;/code&gt; 中的方法抛出异常的时候，由被&lt;code&gt;@ExceptionHandler&lt;/code&gt; 注解修饰的方法进行处理。&lt;/p&gt;&lt;p data-pid=&quot;umFlqXGm&quot;&gt;&lt;code&gt;ExceptionHandlerMethodResolver&lt;/code&gt; 中 &lt;code&gt;getMappedMethod&lt;/code&gt; 方法决定了异常具体被哪个被 &lt;code&gt;@ExceptionHandler&lt;/code&gt; 注解修饰的方法处理异常。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Nullable
 private Method getMappedMethod(Class&amp;lt;? extends Throwable&amp;gt; exceptionType) {
  List&amp;lt;Class&amp;lt;? extends Throwable&amp;gt;&amp;gt; matches = new ArrayList&amp;lt;&amp;gt;();
    //找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系
  for (Class&amp;lt;? extends Throwable&amp;gt; mappedException : this.mappedMethods.keySet()) {
   if (mappedException.isAssignableFrom(exceptionType)) {
    matches.add(mappedException);
   }
  }
    // 不为空说明有方法处理异常
  if (!matches.isEmpty()) {
      // 按照匹配程度从小到大排序
   matches.sort(new ExceptionDepthComparator(exceptionType));
      // 返回处理异常的方法
   return this.mappedMethods.get(matches.get(0));
  }
  else {
   return null;
  }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;wRA5FI7I&quot;&gt;从源代码看出：**&lt;code&gt;getMappedMethod()&lt;/code&gt;会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。**&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring 框架中用到了哪些设计模式？&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;N1K6cL_6&quot;&gt;关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247485303%26idx%3D1%26sn%3D9e4626a1e3f001f9b0d84a6fa0cff04a%26chksm%3Dcea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41%26token%3D255050878%26lang%3Dzh_CN%23rd&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《面试官:“谈谈 Spring 中都用到了那些设计模式?”。》&lt;/a&gt; 。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;IFH1ehuY&quot;&gt;&lt;b&gt;工厂设计模式&lt;/b&gt; : Spring 使用工厂模式通过 &lt;code&gt;BeanFactory&lt;/code&gt;、&lt;code&gt;ApplicationContext&lt;/code&gt; 创建 bean 对象。&lt;/li&gt;&lt;li data-pid=&quot;0hsOyvNS&quot;&gt;&lt;b&gt;代理设计模式&lt;/b&gt; : Spring AOP 功能的实现。&lt;/li&gt;&lt;li data-pid=&quot;L4lOcbGJ&quot;&gt;&lt;b&gt;单例设计模式&lt;/b&gt; : Spring 中的 Bean 默认都是单例的。&lt;/li&gt;&lt;li data-pid=&quot;qrKW9RWB&quot;&gt;&lt;b&gt;模板方法模式&lt;/b&gt; : Spring 中 &lt;code&gt;jdbcTemplate&lt;/code&gt;、&lt;code&gt;hibernateTemplate&lt;/code&gt; 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。&lt;/li&gt;&lt;li data-pid=&quot;cj2iAytq&quot;&gt;&lt;b&gt;包装器设计模式&lt;/b&gt; : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。&lt;/li&gt;&lt;li data-pid=&quot;w7BSWwFR&quot;&gt;&lt;b&gt;观察者模式:&lt;/b&gt; Spring 事件驱动模型就是观察者模式很经典的一个应用。&lt;/li&gt;&lt;li data-pid=&quot;epzq-ctk&quot;&gt;&lt;b&gt;适配器模式&lt;/b&gt; : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配&lt;code&gt;Controller&lt;/code&gt;。&lt;/li&gt;&lt;li data-pid=&quot;oELTsTvK&quot;&gt;......&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;Spring 事务&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;sHH3nNOf&quot;&gt;Spring/SpringBoot 模块下专门有一篇是讲 Spring 事务的，总结的非常详细，通俗易懂。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring 管理事务的方式有几种？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;vktpz016&quot;&gt;&lt;b&gt;编程式事务&lt;/b&gt; ： 在代码中硬编码(不推荐使用) : 通过 &lt;code&gt;TransactionTemplate&lt;/code&gt;或者 &lt;code&gt;TransactionManager&lt;/code&gt; 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。&lt;/li&gt;&lt;li data-pid=&quot;_Getd0bq&quot;&gt;&lt;b&gt;声明式事务&lt;/b&gt; ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于&lt;code&gt;@Transactional&lt;/code&gt; 的全注解方式使用最多）&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Spring 事务中哪几种事务传播行为?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;ZQ4lFy6S&quot;&gt;&lt;b&gt;事务传播行为是为了解决业务层方法之间互相调用的事务问题&lt;/b&gt;。&lt;/p&gt;&lt;p data-pid=&quot;BXBP4lhI&quot;&gt;当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。&lt;/p&gt;&lt;p data-pid=&quot;JCQWQaQH&quot;&gt;正确的事务传播行为可能的值如下:&lt;/p&gt;&lt;p data-pid=&quot;xhfVN7tT&quot;&gt;&lt;b&gt;1.&lt;code&gt;TransactionDefinition.PROPAGATION_REQUIRED&lt;/code&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;ve9qcBie&quot;&gt;使用的最多的一个事务传播行为，我们平时经常使用的&lt;code&gt;@Transactional&lt;/code&gt;注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。&lt;/p&gt;&lt;p data-pid=&quot;q9rmNhUm&quot;&gt;&lt;b&gt;&lt;code&gt;2.TransactionDefinition.PROPAGATION_REQUIRES_NEW&lt;/code&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;l5mDdz-u&quot;&gt;创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，&lt;code&gt;Propagation.REQUIRES_NEW&lt;/code&gt;修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。&lt;/p&gt;&lt;p data-pid=&quot;Ki5-ORmX&quot;&gt;&lt;b&gt;3.&lt;code&gt;TransactionDefinition.PROPAGATION_NESTED&lt;/code&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;buPRR_Z8&quot;&gt;如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于&lt;code&gt;TransactionDefinition.PROPAGATION_REQUIRED&lt;/code&gt;。&lt;/p&gt;&lt;p data-pid=&quot;_yj41NbJ&quot;&gt;&lt;b&gt;4.&lt;code&gt;TransactionDefinition.PROPAGATION_MANDATORY&lt;/code&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;FiurD77R&quot;&gt;如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）&lt;/p&gt;&lt;p data-pid=&quot;BKRzGoB4&quot;&gt;这个使用的很少。&lt;/p&gt;&lt;p data-pid=&quot;GzfyfQT1&quot;&gt;若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;vlWKKDRH&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_SUPPORTS&lt;/code&gt;&lt;/b&gt;: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。&lt;/li&gt;&lt;li data-pid=&quot;TwttbZiH&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_NOT_SUPPORTED&lt;/code&gt;&lt;/b&gt;: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。&lt;/li&gt;&lt;li data-pid=&quot;tg0-Dw4j&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_NEVER&lt;/code&gt;&lt;/b&gt;: 以非事务方式运行，如果当前存在事务，则抛出异常。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Spring 事务中的隔离级别有哪几种?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;wUkJ278g&quot;&gt;和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：&lt;code&gt;Isolation&lt;/code&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public enum Isolation {

    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),

    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),

    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),

    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),

    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);

    private final int value;

    Isolation(int value) {
        this.value = value;
    }

    public int value() {
        return this.value;
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;txkM8Jzd&quot;&gt;下面我依次对每一种事务隔离级别进行介绍：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;B4zKVeby&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.ISOLATION_DEFAULT&lt;/code&gt;&lt;/b&gt; :使用后端数据库默认的隔离级别，MySQL 默认采用的 &lt;code&gt;REPEATABLE_READ&lt;/code&gt; 隔离级别 Oracle 默认采用的 &lt;code&gt;READ_COMMITTED&lt;/code&gt; 隔离级别.&lt;/li&gt;&lt;li data-pid=&quot;T75dNcAo&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.ISOLATION_READ_UNCOMMITTED&lt;/code&gt;&lt;/b&gt; :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，&lt;b&gt;可能会导致脏读、幻读或不可重复读&lt;/b&gt;&lt;/li&gt;&lt;li data-pid=&quot;hHIaSC1u&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.ISOLATION_READ_COMMITTED&lt;/code&gt;&lt;/b&gt; : 允许读取并发事务已经提交的数据，&lt;b&gt;可以阻止脏读，但是幻读或不可重复读仍有可能发生&lt;/b&gt;&lt;/li&gt;&lt;li data-pid=&quot;czKCxWgt&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.ISOLATION_REPEATABLE_READ&lt;/code&gt;&lt;/b&gt; : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，&lt;b&gt;可以阻止脏读和不可重复读，但幻读仍有可能发生。&lt;/b&gt;&lt;/li&gt;&lt;li data-pid=&quot;ckkXmANy&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.ISOLATION_SERIALIZABLE&lt;/code&gt;&lt;/b&gt; : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，&lt;b&gt;该级别可以防止脏读、不可重复读以及幻读&lt;/b&gt;。但是这将严重影响程序的性能。通常情况下也不会用到该级别。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;@Transactional(rollbackFor = Exception.class)注解了解吗？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;T6TirREk&quot;&gt;&lt;code&gt;Exception&lt;/code&gt; 分为运行时异常 &lt;code&gt;RuntimeException&lt;/code&gt; 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。&lt;/p&gt;&lt;p data-pid=&quot;PpatwKyf&quot;&gt;当 &lt;code&gt;@Transactional&lt;/code&gt; 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。&lt;/p&gt;&lt;p data-pid=&quot;yI8Dm1pr&quot;&gt;在 &lt;code&gt;@Transactional&lt;/code&gt; 注解中如果不配置&lt;code&gt;rollbackFor&lt;/code&gt;属性,那么事务只会在遇到&lt;code&gt;RuntimeException&lt;/code&gt;的时候才会回滚，加上 &lt;code&gt;rollbackFor=Exception.class&lt;/code&gt;,可以让事务在遇到非运行时异常时也回滚。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring Data JPA&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;c6TWPk_D&quot;&gt;JPA 重要的是实战，这里仅对小部分知识点进行总结。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;如何使用 JPA 在数据库中非持久化一个字段？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;BRnMc52U&quot;&gt;假如我们有下面一个类：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Entity(name=&quot;USER&quot;)
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = &quot;ID&quot;)
    private Long id;

    @Column(name=&quot;USER_NAME&quot;)
    private String userName;

    @Column(name=&quot;PASSWORD&quot;)
    private String password;

    private String secrect;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;s8m8_zGx&quot;&gt;如果我们想让&lt;code&gt;secrect&lt;/code&gt; 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;static String transient1; // not persistent because of static
final String transient2 = &quot;Satish&quot;; // not persistent because of final
transient String transient3; // not persistent because of transient
@Transient
String transient4; // not persistent because of @Transient
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Z7tzhh1F&quot;&gt;一般使用后面两种方式比较多，我个人使用注解的方式比较多。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;JPA 的审计功能是做什么的？有什么用？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;LxnvjSaw&quot;&gt;审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
@MappedSuperclass
@EntityListeners(value = AuditingEntityListener.class)
public abstract class AbstractAuditBase {

    @CreatedDate
    @Column(updatable = false)
    @JsonIgnore
    private Instant createdAt;

    @LastModifiedDate
    @JsonIgnore
    private Instant updatedAt;

    @CreatedBy
    @Column(updatable = false)
    @JsonIgnore
    private String createdBy;

    @LastModifiedBy
    @JsonIgnore
    private String updatedBy;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li data-pid=&quot;0zq-1zLB&quot;&gt;&lt;code&gt;@CreatedDate&lt;/code&gt;: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值&lt;br/&gt; &lt;/li&gt;&lt;li data-pid=&quot;qreSqpcS&quot;&gt;&lt;code&gt;@CreatedBy&lt;/code&gt; :表示该字段为创建人，在这个实体被 insert 的时候，会设置值&lt;br/&gt; &lt;code&gt;@LastModifiedDate&lt;/code&gt;、&lt;code&gt;@LastModifiedBy&lt;/code&gt;同理。&lt;br/&gt; &lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;实体之间的关联关系注解有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;MuN4kKhM&quot;&gt;&lt;code&gt;@OneToOne&lt;/code&gt; : 一对一。&lt;/li&gt;&lt;li data-pid=&quot;3LShrip3&quot;&gt;&lt;code&gt;@ManyToMany&lt;/code&gt; ：多对多。&lt;/li&gt;&lt;li data-pid=&quot;dcyHumc8&quot;&gt;&lt;code&gt;@OneToMany&lt;/code&gt; : 一对多。&lt;/li&gt;&lt;li data-pid=&quot;m3IL9GJv&quot;&gt;&lt;code&gt;@ManyToOne&lt;/code&gt; ：多对一。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;K_MkmCt8&quot;&gt;利用 &lt;code&gt;@ManyToOne&lt;/code&gt; 和 &lt;code&gt;@OneToMany&lt;/code&gt; 也可以表达多对多的关联关系。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring Security&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;IsLIcFTl&quot;&gt;Spring Security 重要的是实战，这里仅对小部分知识点进行总结。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;有哪些控制请求访问权限的方法？&lt;/b&gt;&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1494db71691bc4cfa4525eea0a0c5c5b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;212&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-1494db71691bc4cfa4525eea0a0c5c5b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;212&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-1494db71691bc4cfa4525eea0a0c5c5b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1494db71691bc4cfa4525eea0a0c5c5b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li data-pid=&quot;-LT3JWv-&quot;&gt;&lt;code&gt;permitAll()&lt;/code&gt; ：无条件允许任何形式访问，不管你登录还是没有登录。&lt;/li&gt;&lt;li data-pid=&quot;CM9ygmAL&quot;&gt;&lt;code&gt;anonymous()&lt;/code&gt; ：允许匿名访问，也就是没有登录才可以访问。&lt;/li&gt;&lt;li data-pid=&quot;0nTDes2c&quot;&gt;&lt;code&gt;denyAll()&lt;/code&gt; ：无条件决绝任何形式的访问。&lt;/li&gt;&lt;li data-pid=&quot;Ecfwp7iV&quot;&gt;&lt;code&gt;authenticated()&lt;/code&gt;：只允许已认证的用户访问。&lt;/li&gt;&lt;li data-pid=&quot;OahMS7UH&quot;&gt;&lt;code&gt;fullyAuthenticated()&lt;/code&gt; ：只允许已经登录或者通过 remember-me 登录的用户访问。&lt;/li&gt;&lt;li data-pid=&quot;Jpudjieh&quot;&gt;&lt;code&gt;hasRole(String)&lt;/code&gt; : 只允许指定的角色访问。&lt;/li&gt;&lt;li data-pid=&quot;CpFnE8BZ&quot;&gt;&lt;code&gt;hasAnyRole(String)&lt;/code&gt; : 指定一个或者多个角色，满足其一的用户即可访问。&lt;/li&gt;&lt;li data-pid=&quot;jchW6Nwy&quot;&gt;&lt;code&gt;hasAuthority(String)&lt;/code&gt; ：只允许具有指定权限的用户访问&lt;/li&gt;&lt;li data-pid=&quot;mss0dgRn&quot;&gt;&lt;code&gt;hasAnyAuthority(String)&lt;/code&gt; ：指定一个或者多个权限，满足其一的用户即可访问。&lt;/li&gt;&lt;li data-pid=&quot;j0yBNGB-&quot;&gt;&lt;code&gt;hasIpAddress(String)&lt;/code&gt; : 只允许指定 ip 的用户访问。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;hasRole 和 hasAuthority 有区别吗？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;0o8psI-O&quot;&gt;可以看看松哥的这篇文章：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/GTNOa2k9_n_H0w24upClRw&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spring Security 中的 hasRole 和 hasAuthority 有区别吗？&lt;/a&gt;，介绍的比较详细。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;如何对密码进行加密？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;NLw9F3cO&quot;&gt;如果我们需要保存密码这类敏感数据到数据库的话，需要先加密再保存。&lt;/p&gt;&lt;p data-pid=&quot;6FQWXC4g&quot;&gt;Spring Security 提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是 &lt;code&gt;PasswordEncoder&lt;/code&gt; ，如果你想要自己实现一个加密算法的话，也需要继承 &lt;code&gt;PasswordEncoder&lt;/code&gt;。&lt;/p&gt;&lt;p data-pid=&quot;wEIbY53p&quot;&gt;&lt;code&gt;PasswordEncoder&lt;/code&gt; 接口一共也就 3 个必须实现的方法。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public interface PasswordEncoder {
    // 加密也就是对原始密码进行编码
    String encode(CharSequence var1);
    // 比对原始密码和数据库中保存的密码
    boolean matches(CharSequence var1, String var2);
    // 判断加密密码是否需要再次进行加密，默认返回 false
    default boolean upgradeEncoding(String encodedPassword) {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-35ae091246ba4aa0a1d5213086866796_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;318&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-35ae091246ba4aa0a1d5213086866796_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;318&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-35ae091246ba4aa0a1d5213086866796_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-35ae091246ba4aa0a1d5213086866796_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;TwLIMkYV&quot;&gt;官方推荐使用基于 bcrypt 强哈希函数的加密算法实现类。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;如何优雅更换系统使用的加密算法？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;4dLndKAH&quot;&gt;如果我们在开发过程中，突然发现现有的加密算法无法满足我们的需求，需要更换成另外一个加密算法，这个时候应该怎么办呢？&lt;/p&gt;&lt;p data-pid=&quot;pXoFTSAR&quot;&gt;推荐的做法是通过 &lt;code&gt;DelegatingPasswordEncoder&lt;/code&gt; 兼容多种不同的密码加密方案，以适应不同的业务需求。&lt;/p&gt;&lt;p data-pid=&quot;sef0XNLm&quot;&gt;从名字也能看出来，&lt;code&gt;DelegatingPasswordEncoder&lt;/code&gt; 其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是代理上面提到的加密算法实现类。在 Spring Security 5.0 之后，默认就是基于 &lt;code&gt;DelegatingPasswordEncoder&lt;/code&gt; 进行密码加密的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;DuEuwVD3&quot;&gt;自荐一个非常不错的 Java 教程类开源项目：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide&lt;/a&gt; 。这是我在大三开始准备秋招面试的时候创建的，已经维护了 4 年多了，目前这个项目在 Github 上收到了 125k+ 的 star。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d31f72b06d90a3b2d206f13addc05536_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d31f72b06d90a3b2d206f13addc05536_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;JvDdHJjF&quot;&gt;并且，这个项目还推出了一个PDF版本：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247486324%26idx%3D1%26sn%3De8b690ddaedabc486bd399310105aad3%26chksm%3Dcea244bff9d5cda9a627fa65235be09e7b089e92cf49c0eb0ceb35b39bbed86c1fab0125f5af%26token%3D1351080357%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;完结撒花！JavaGuide面试突击版来啦！&lt;/a&gt;。&lt;/p&gt;&lt;p data-pid=&quot;I1vmxVEr&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Java 面试指北 》&lt;/a&gt; 是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eb29b2d8245630aa4c87313f77bd4b1f_b.jpg&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-eb29b2d8245630aa4c87313f77bd4b1f_b.jpg&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;_WkIY1YQ&quot;&gt;为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;知识星球&lt;/a&gt;。虽然收费只有培训班/训练营的百分之一，但是&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;知识星球&lt;/a&gt;里的内容质量更高，提供的服务也更全面。&lt;/p&gt;&lt;p data-pid=&quot;yVMURO6o&quot;&gt;欢迎准备 Java 面试以及学习 Java 的同学加入我的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;知识星球&lt;/a&gt;，干货非常多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。&lt;/p&gt;&lt;p data-pid=&quot;LWl-7FBh&quot;&gt;我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5f3021f5262702afffa978a0516182ef</guid>
<title>LowCode 窥探</title>
<link>https://toutiao.io/k/q0m9kvh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybxMWIPvEiaXIvNrdYr0qV2ibhpOqLsqIgxarghhmlkIEZpWhbA8pnvyGt0NXKh04DibbbibEyAelpsNUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;本文是笔者在团队内部做分享整理的资料的一部分，本次分享主要是站在一个服务端开发的视角对（前端）低代码平台的一些调研，已经剔除了一些敏感数据和信息，可放心食用。&lt;/p&gt;&lt;h2&gt;太阳底下无新事&lt;/h2&gt;&lt;h3&gt;Dreamweaver -&amp;gt; Low-Code&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybxMWIPvEiaXIvNrdYr0qV2ibh4mqB0B1xtYsRibY95sSibSSjOUfFYP3Ny7ocervsmQy2OFuZ9QsYKrwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;将时钟拨回到 20 年前，那个时候的开发者对于 html/css/js 还处在望而生畏的阶段，Dreamweaver 的出现仿佛让他们看见了曙光。通过简单的拖拽就可以实时&lt;strong&gt;预览&lt;/strong&gt;编排的页面，点击按钮就可以&lt;strong&gt;自动生成&lt;/strong&gt;对应的前端代码，配置好机器信息就可以一键&lt;strong&gt;部署&lt;/strong&gt;访问…… 这些特性让无数开发者趋之若鹜，然后现在他的境况&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8737864077669902&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybxMWIPvEiaXIvNrdYr0qV2ibhVPlGwMyJ4Zib88ynevtbb30icMcTyQl1jj4OnpQgCxYyPjLwlbz1dUdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;206&quot;/&gt;&lt;/p&gt;&lt;p&gt;现如今，Dreamweaver 几乎已经退出了历史舞台，但 Low-Code 似乎又有卷土重来的迹象……&lt;/p&gt;&lt;h3&gt;Low-Code 是什么？&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;A low-code development platform (LCDP) is software that provides a development environment used to create application software through &lt;strong&gt;graphical user interfaces and configuration&lt;/strong&gt; instead of &lt;strong&gt;traditional hand-coded computer programming&lt;/strong&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;一句话概括就是 👉 &lt;strong&gt;&lt;em&gt;用 GUI+配置取代传统手工编码&lt;/em&gt;&lt;/strong&gt; 技术上，实现低代码平台的关键要素是&lt;strong&gt;模型驱动设计、代码自动生成和可视化编程&lt;/strong&gt;，通过这些手段来隐藏下层的代码细节。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8434343434343434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybxMWIPvEiaXIvNrdYr0qV2ibhR4M0guh3wFJMIaMvibgUlQyRvOVWWdHursq7gTszAORkrbibOd38DRvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;198&quot;/&gt;&lt;/p&gt;&lt;h4&gt;更激进的—— No-Code（零代码）&lt;/h4&gt;&lt;p&gt;Low-Code 更激进的演进方向是 No-Code，主要的差异点如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;平台用户：任何业务人员都能使用无代码平台，而低代码平台面向&lt;strong&gt;开发者&lt;/strong&gt;（尽管专业要求不那么高）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;核心设计：无代码平台倾向于让用户通过拖拽或简单的表达式来操纵完成应用设计，而低代码平台更倾向于通过人工编码来指定应用程序的&lt;strong&gt;核心结构&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户界面：无代码平台为了简化应用设计，一般只支持内置的 UI 库，而低代码平台可能会提供更灵活的 UI 选项，但代价是需要额外编码，使用上的复杂性有所增加&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;为什么目前低代码只在前端领域很火？&lt;/h3&gt;&lt;h4&gt;被资源化的前端开发者&lt;/h4&gt;&lt;p&gt;工作量大，重复性工作较多，因此生产效率成为了必须要解决的问题。&lt;/p&gt;&lt;p&gt;最好的解决办法是&lt;strong&gt;通过工具化、自动化的方式提高生产效率，突破前端资源瓶颈&lt;/strong&gt;。&lt;/p&gt;&lt;h4&gt;前端的技术体系足够开放&lt;/h4&gt;&lt;p&gt;相较于 Native/服务端，前端的技术体系更开放，&lt;strong&gt;前端 low-code 产物都能应用到现有的任何前端应用程序中&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;前端的应用体系更加工程化&lt;/h4&gt;&lt;p&gt;吃饱了才有力气减肥，只有解决了温饱问题，才能转而追求更高的生产效率。&lt;/p&gt;&lt;p&gt;现阶段，前端的工程化愈发成熟 👉 CLI -&amp;gt; GUI 客户端 -&amp;gt; Web IDE 工程化带来的好处是，&lt;strong&gt;编码层面的效率提升已经达到极致，更进一步的生产效率提升需要变革式的突破。&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;现在的 Low-Code 和 20 年前的 Dreamweaver 有什么区别？&lt;/h3&gt;&lt;p&gt;单从表面上看，可视化地自动生成一些代码确实没有太大区别，内在的实质性差异在于：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;目标场景不同：Dreamweaver 更多地聚焦前端开发场景，而在 low-code 开发平台中，前端只是&lt;strong&gt;完整应用程序的一部分&lt;/strong&gt;，服务端数据、路由、逻辑流程等都需要考虑在内&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可视化操作粒度不同：现代 low-code 平台通常有组件、区块、页面、模板等多级复用抽象，Dreamweaver 只面向 HTML 原生标签&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;工程链路完备程度不同：Dreamweaver 仅覆盖到开发、预览、部署（FTP 上传）环节，而现代 low-code 平台大多涵盖了完整的生命周期，包括发布前的&lt;strong&gt;调试、测试，发布后的监控运维&lt;/strong&gt;等各个环节&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;随着前端工程体系的一路演进，现代的 low-code 平台充分考虑了&lt;strong&gt;模块复用、生态接壤、前后端联动、工程管理&lt;/strong&gt;等重要因素，在成熟度和开发效率方面相比 Dreamweaver 都有了质的飞跃。&lt;/p&gt;&lt;h3&gt;阿里巴巴低代码引擎（ALCE）&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;考虑到数据安全，这一部分在原文基础上做了较多改动，基于集团已经开源的信息做介绍，详情可跳转至官网地址 👉https://lowcode-engine.cn&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;低代码平台的底层是&lt;strong&gt;低代码引擎&lt;/strong&gt;，引擎核心在于灵活对接丰富的高质量&lt;strong&gt;物料&lt;/strong&gt;，结合一个优雅、高效的&lt;strong&gt;编排引擎&lt;/strong&gt;，让一个泛技术线的同学用所见即所得的方式，完成页面的&lt;strong&gt;搭建、部署&lt;/strong&gt;，完成快速自交付的闭环，达成预期目标。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6311569301260023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybxMWIPvEiaXIvNrdYr0qV2ibhP4ME0n0mIiafEcoosf1LL8dUh5eRicNSkVQEXGS25o4n1GRhCs9kqcVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1746&quot;/&gt;&lt;/p&gt;&lt;p&gt;其中引擎 SDK，包含 4 个主要模块，即&lt;strong&gt;入料、编排、渲染、出码&lt;/strong&gt;。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;入料：将物料，按照《低代码引擎物料协议规范》进行元数据描述后，导入到设计器中，成为一个可被编排的物料；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;编排：将设计器中的所有物料，进行布局设置、组件设置(CRUD)、交互设置(JS 编写/逻辑编排)后，形成符合业务诉求的 schema 描述，此 schema 遵循 《低代码引擎搭建协议规范》；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;渲染：将编排得到的 schema 渲染成可交互的页面；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;出码：将编排得到的 schema 转成真实的代码结构，比如 Recore / Ice / Remax / Umi 等应用框架结构；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;体验低代码开发后的感受&lt;/h2&gt;&lt;h3&gt;黑盒开发&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.48840579710144927&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybxMWIPvEiaXIvNrdYr0qV2ibhd1ErwgOuhbhQt9G16RqQfvj2fbCDPSEzGicF7vCXvOagXF1KgEmMqqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;因为屏蔽了一些代码，接手的人不知道为什么这个组件在这里，为什么会有这样的效果。心路历程基本如下 👇&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;😄 我写了一段代码，只有我和编译器/解释器看得懂。&lt;/p&gt;&lt;p&gt;🤔 过了一段时间，就只有编译器/解释器看得懂了。&lt;/p&gt;&lt;p&gt;😈 我用低代码平台拖了一些&quot;控件&quot;，最后我发现只有浏览器看得懂。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;学习成本并不低&lt;/h3&gt;&lt;h3&gt;迭代效率提升不明显&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0185185185185186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybxMWIPvEiaXIvNrdYr0qV2ibhPSRIs2bticdib8YWKFHbIgG5SOJH4qNY7Jw9OicTIhtZdV9zialDiaALlEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;216&quot;/&gt;&lt;/p&gt;&lt;p&gt;虽然在画页面、适配样式等方面，低代码平台有非常大的优势，但由于学习成本、黑盒开发等原因，导致在开发时问题的排查效率低下，开发的幸福感大打折扣。&lt;/p&gt;&lt;p&gt;如果官方提供的组件库不满足业务需要时，开发自定义组件/使用第三方组件的成本和手动编写代码相差无几。&lt;/p&gt;&lt;h2&gt;对低代码平台的一些思考&lt;/h2&gt;&lt;h3&gt;服务端编写前端代码的痛点是什么？&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybxMWIPvEiaXIvNrdYr0qV2ibhibgZpAAzWjicOw27LaVRCIcxpdM3I4lDKibxWOwChxO5AkrYGibmJcC1tQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;350&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;前端技术栈多&amp;amp;杂，不知道学习哪一个&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重复性多做较多，布局难适配，css 编写头疼&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上面两个问题，低代码平台可以解决，但是现有的前端技术也可以解决&lt;/p&gt;&lt;h3&gt;可视化编程的效率一定比写代码效率高？&lt;/h3&gt;&lt;p&gt;编程本质上是一种&lt;strong&gt;表达&lt;/strong&gt;，它的工具应该越来越&lt;strong&gt;易于思考，易于理解&lt;/strong&gt;。也许可视化编程是大势所趋，就像机器语言必然被汇编语言取代，汇编语言必然被高级语言取代，但是现阶段的可视化编程的发展还需要更进一步。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3485254691689008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybxMWIPvEiaXIvNrdYr0qV2ibhhTtiaF5SIQuZRAbDY6euK5ARzce4eHDv9Vq6AU2IScnb0uV33eiaz5wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7753623188405797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybxMWIPvEiaXIvNrdYr0qV2ibhldXU4JZD5tNJHvOKlMwfWgkqw0wHU40iaqaZgoFGgz6iaDrjwVbOmVkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/p&gt;&lt;h3&gt;哪些实际的业务场景更适合使用低代码平台？&lt;/h3&gt;&lt;p&gt;低代码的主旨在于&lt;strong&gt;需求简化 + 角色合并&lt;/strong&gt;，通过预制件的形式，最大可能减少参与整个研发流程中的各类角色，一般经常合并的角色有：产品合并设计，后端合并前端。&lt;/p&gt;&lt;p&gt;对于一些只读的，不涉及系统状态变化的，页面/表单数量较少，组件自定义需求较低的场景，例如 trace 工具、开发类的小工具等，很适合使用低代码平台开发。&lt;/p&gt;&lt;p&gt;而在业务初期，人力紧缺，业务需求并不十分复杂的情况下，低代码平台也可承担一些中后台页面的搭建，但随着时间的推移，定制化需求越来越多后，总归是需要回归到 ProCode 的开发模式，前期使用低代码节省的时间后期都会在架构迁移的时候还回来。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aee867b5120273aebf2188b72224eb3d</guid>
<title>RabbitMQ、RocketMQ 和 Kafka 三元归一</title>
<link>https://toutiao.io/k/iji5qc0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23693379790940766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/IP70Vic417DOjMRrV3RrW2HaXlrTFpEI1EYiaJaJkfYOvEuQc3F6RibYXS9oMIvvJNCywron0Wd809g43gmTHlqEA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;574&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;RabbitMQ各组件的功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Broker ：一个RabbitMQ实例就是一个Broker&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Virtual Host ：虚拟主机。&lt;strong&gt;相当于MySQL的DataBase&lt;/strong&gt;，一个Broker上可以存在多个vhost，vhost之间相互隔离。每个vhost都拥有自己的队列、交换机、绑定和权限机制。vhost必须在连接时指定，默认的vhost是/。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Exchange ：交换机，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Queue ：消息队列，用来保存消息直到发送给消费者。它是消息的容器。一个消息可投入一个或多个队列。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Banding ：绑定关系，用于&lt;strong&gt;消息队列和交换机之间的关联&lt;/strong&gt;。通过路由键（&lt;strong&gt;Routing Key&lt;/strong&gt;）将交换机和消息队列关联起来。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Channel ：管道，一条双向数据流通道。不管是发布消息、订阅队列还是接收消息，这些动作都是通过管道完成。因为对于操作系统来说，建立和销毁TCP都是非常昂贵的开销，所以引入了管道的概念，以复用一条TCP连接。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Connection ：生产者/消费者 与broker之间的TCP连接。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Publisher ：消息的生产者。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Consumer ：消息的消费者。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Message ：消息，它是由消息头和消息体组成。消息头则包括&lt;strong&gt;Routing-Key&lt;/strong&gt;、&lt;strong&gt;Priority&lt;/strong&gt;（优先级）等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2636363636363636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx8kx2HROoG0XQ3cMBfu2yIPD6lFudWLBLZNCLzPX6VoZuGrOGzvxT50Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;RabbitMQ的多种交换机类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Exchange 分发消息给 Queue 时， Exchange 的类型对应不同的分发策略，有3种类型的 Exchange ：&lt;strong&gt;Direct&lt;/strong&gt;、&lt;strong&gt;Fanout&lt;/strong&gt;、&lt;strong&gt;Topic&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Direct&lt;/strong&gt;：消息中的 Routing Key 如果和 Binding 中的 Routing Key 完全一致， Exchange 就会将消息分发到对应的队列中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Fanout&lt;/strong&gt;：每个发到 Fanout 类型交换机的消息都会分发到所有绑定的队列上去。Fanout交换机没有 Routing Key 。&lt;strong&gt;它在三种类型的交换机中转发消息是最快的&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Topic&lt;/strong&gt;：Topic交换机通过模式匹配分配消息，将 Routing Key 和某个模式进行匹配。它只能识别两个&lt;strong&gt;通配符&lt;/strong&gt;：&lt;strong&gt;&quot;#&quot;和&quot;*&quot;&lt;/strong&gt;。### 匹配0个或多个单词， * 匹配1个单词。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;TTL&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TTL（Time To Live）：生存时间。RabbitMQ支持消息的过期时间，一共2种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;生产者的消息确认机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Confirm机制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何实现Confirm确认消息？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5218181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx8oyiaFSeu45TJTTLuSqNRFH26wtvFKViaqSjJRlib7prcicdQzicL0eibCoVQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在channel上开启确认模式&lt;/strong&gt;：channel.confirmSelect()&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在channel上开启监听&lt;/strong&gt;：addConfirmListener ，监听成功和失败的处理结果，根据具体的结果对消息进行重新发送或记录日志处理等后续操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425531914893617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx8vQZqppRiaedhb9FDwKx1yPNc48E6IraDHDOh5pE95qod9XKAuYNiaBzg/640?wx_fmt=jpeg&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Return消息机制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Return Listener&lt;strong&gt;用于处理一些不可路由的消息&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的消息生产者，通过指定一个Exchange和Routing，把消息送达到某一个队列中去，然后我们的消费者监听队列进行消息的消费处理操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是在某些情况下，如果我们在发送消息的时候，当前的exchange不存在或者指定的路由key路由不到，这个时候我们需要监听这种不可达消息，就需要使用到Returrn Listener。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基础API中有个关键的配置项 Mandatory ：如果为true，监听器会收到路由不可达的消息，然后进行处理。如果为false，broker端会自动删除该消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同样，通过监听的方式， chennel.addReturnListener(ReturnListener rl) 传入已经重写过handleReturn方法的ReturnListener。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;消费端ACK与NACK&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费端进行消费的时候，如果由于业务异常可以进行日志的记录，然后进行补偿。但是对于服务器宕机等严重问题，我们需要&lt;strong&gt;手动ACK&lt;/strong&gt;保障消费端消费成功。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;// deliveryTag：消息在mq中的唯一标识&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// multiple：是否批量(和qos设置类似的参数)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// requeue：是否需要重回队列。或者丢弃或者重回队首再次消费。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;basicNack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; deliveryTag, &lt;span&gt;boolean&lt;/span&gt; multiple, &lt;span&gt;boolean&lt;/span&gt; requeue)&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;如上代码，消息在&lt;strong&gt;消费端重回队列&lt;/strong&gt;是为了对没有成功处理消息，把消息重新返回到Broker。一般来说，实际应用中都会关闭重回队列（&lt;strong&gt;避免进入死循环&lt;/strong&gt;），也就是设置为false。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;死信队列DLX&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;死信队列（DLX Dead-Letter-Exchange）：当消息在一个队列中变成死信之后，它会被重新推送到另一个队列，这个队列就是死信队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当这个队列中有死信时，&lt;span&gt;RabbitMQ&lt;/span&gt;就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;阿里巴巴双十一官方指定消息产品，支撑阿里巴巴集团所有的消息服务，历经十余年高可用与高可靠的严苛考验，是阿里巴巴交易链路的核心产品。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rocket：火箭的意思。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5727272727272728&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx8Zv0lI93aq2Bjgcj6HicSWRYdY9icNy1fTNafiaqdicLHU5MKAMnFWhb2fQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot;/&gt;&lt;span&gt;&lt;strong&gt;RocketMQ的核心概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他有以下核心概念：Broker 、 Topic 、 Tag 、 MessageQueue 、 NameServer 、 Group 、 Offset 、 Producer 以及 Consumer 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面来详细介绍。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Broker&lt;/strong&gt;：消息中转角色，负责&lt;strong&gt;存储消息&lt;/strong&gt;，转发消息。&lt;strong&gt;Broker&lt;/strong&gt;是具体提供业务的服务器，单个Broker节点与所有的NameServer节点保持长连接及心跳，并会定时将&lt;strong&gt;Topic&lt;/strong&gt;信息注册到NameServer，顺带一提底层的通信和连接都是&lt;strong&gt;基于Netty实现&lt;/strong&gt;的。&lt;strong&gt;Broker&lt;/strong&gt;负责消息存储，以Topic为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型。官网上有数据显示：具有&lt;strong&gt;上亿级消息堆积能力&lt;/strong&gt;，同时可&lt;strong&gt;严格保证消息的有序性&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Topic&lt;/strong&gt;：主题！它是消息的第一级类型。比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个 Topic 。&lt;strong&gt;Topic&lt;/strong&gt;与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。一个 Topic 也可以被 0个、1个、多个消费者订阅。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Tag&lt;/strong&gt;：标签！可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同Topic而不同的&lt;strong&gt;Tag&lt;/strong&gt;来标识。比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有&lt;strong&gt;Tag&lt;/strong&gt;。标签有助于保持您的代码干净和连贯，并且还可以为&lt;span&gt;RabbitMQ&lt;/span&gt;提供的查询系统提供帮助。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;MessageQueue&lt;/strong&gt;：一个Topic下可以设置多个消息队列，发送消息时执行该消息的Topic，RocketMQ会轮询该Topic下的所有队列将消息发出去。消息的物理管理单位。一个Topic下可以有多个Queue，Queue的引入使得消息的存储可以分布式集群化，具有了水平扩展能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;NameServer&lt;/strong&gt;：类似Kafka中的ZooKeeper，但NameServer集群之间是&lt;strong&gt;没有通信&lt;/strong&gt;的，相对ZK来说更加&lt;strong&gt;轻量&lt;/strong&gt;。它主要负责对于源数据的管理，包括了对于&lt;strong&gt;Topic&lt;/strong&gt;和路由信息的管理。每个Broker在启动的时候会到NameServer注册，Producer在发送消息前会根据Topic去NameServer&lt;strong&gt;获取对应Broker的路由信息&lt;/strong&gt;，Consumer也会定时获取 Topic 的路由信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Producer&lt;/strong&gt;：生产者，支持三种方式发送消息：&lt;strong&gt;同步、异步和单向&lt;/strong&gt;单向发送 ：消息发出去后，可以继续发送下一条消息或执行业务代码，不等待服务器回应，且&lt;strong&gt;没有回调函数&lt;/strong&gt;。异步发送 ：消息发出去后，可以继续发送下一条消息或执行业务代码，不等待服务器回应，&lt;strong&gt;有回调函数&lt;/strong&gt;。同步发送 ：消息发出去后，等待服务器响应成功或失败，才能继续后面的操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Consumer&lt;/strong&gt;：消费者，支持 PUSH 和 PULL 两种消费模式，支持&lt;strong&gt;集群消费&lt;/strong&gt;和&lt;strong&gt;广播消费&lt;/strong&gt;集群消费 ：该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。广播消费 ：会发给消费者组中的每一个消费者进行消费。相当于&lt;strong&gt;RabbitMQ&lt;/strong&gt;的发布订阅模式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Group&lt;/strong&gt;：分组，一个组可以订阅多个Topic。分为ProducerGroup，ConsumerGroup，代表某一类的生产者和消费者，一般来说同一个服务可以作为Group，同一个Group一般来说发送和消费的消息都是一样的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Offset&lt;/strong&gt;：在RocketMQ中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用Offset来访问，Offset为Java Long类型，64位，理论上在 100年内不会溢出，所以认为是长度无限。也可以认为Message Queue是一个长度无限的数组，&lt;strong&gt;Offset&lt;/strong&gt;就是下标。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;延时消息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开源版的RocketMQ不支持任意时间精度，仅支持特定的level，例如定时5s，10s，1min等。其中，level=0级表示不延时，level=1表示1级延时，level=2表示2级延时，以此类推。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;延时等级如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;messageDelayLevel=&lt;span&gt;1s&lt;/span&gt; &lt;span&gt;5s&lt;/span&gt; &lt;span&gt;10s&lt;/span&gt; &lt;span&gt;30s&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;m &lt;span&gt;2&lt;/span&gt;m &lt;span&gt;3&lt;/span&gt;m &lt;span&gt;4&lt;/span&gt;m &lt;span&gt;5&lt;/span&gt;m &lt;span&gt;6&lt;/span&gt;m &lt;span&gt;7&lt;/span&gt;m &lt;span&gt;8&lt;/span&gt;m &lt;span&gt;9&lt;/span&gt;m &lt;span&gt;10&lt;/span&gt;m &lt;span&gt;20&lt;/span&gt;m &lt;span&gt;30&lt;/span&gt;m &lt;span&gt;1&lt;/span&gt;h &lt;span&gt;2&lt;/span&gt;h&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;顺序消息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息有序指的是可以按照消息的发送顺序来消费（FIFO）。RocketMQ可以严格的保证消息有序，可以分为 分区有序 或者 全局有序 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;事务消息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30363636363636365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx85jVmCy4mE5EiaXYkRjicsVBnrhX6bhAibXx0qeO9CJ7oUicLa75mfhMLHw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息队列MQ提供类似X/Open XA的分布式事务功能，通过消息队列MQ事务消息能达到分布式事务的最终一致。上图说明了事务消息的大致流程：正常事务消息的发送和提交、事务消息的补偿流程。另外，搜索公众号前端技术精选后台回复“前端”，获取一份惊喜礼包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事务消息发送及提交：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发送half消息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务端响应消息写入结果&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据本地事务状态执行Commit或Rollback（Commit操作生成消息索引，消息对消费者可见）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;事务消息的补偿流程：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Producer收到回查消息，检查回查消息对应的本地事务的状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据本地事务状态，重新Commit或RollBack&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;其中，补偿阶段用于解决消息Commit或Rollback发生超时或者失败的情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事务消息状态：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事务消息共有三种状态：提交状态、回滚状态、中间状态：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TransactionStatus.CommitTransaction：提交事务，它允许消费者消费此消息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TransactionStatus.RollbackTransaction：回滚事务，它代表该消息将被删除，不允许被消费。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TransactionStatus.Unkonwn：中间状态，它代表需要检查消息队列来确定消息状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;RocketMQ的高可用机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RocketMQ是天生支持分布式的，可以配置主从以及水平扩展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息消费的高可用（主从）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Consumer的配置文件中，并不需要设置是从Master读还是从Slave读，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性。&lt;strong&gt;RocketMQ目前还不支持把Slave自动转成Master&lt;/strong&gt;，如果机器资源不足，需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文件，用新的配置文件启动Broker。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息发送高可用（配置多个主节点）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可用后，其他组的Master仍然可用，Producer仍然可以发送消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主从复制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;同步复制&lt;/strong&gt;：同步复制方式是等Master和Slave均写成功后才反馈给客户端写成功状态。如果Master出故障， Slave上有全部的备份数据，容易恢复同步复制会增大数据写入延迟，降低系统吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;异步复制&lt;/strong&gt;：异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;通常情况下，应该把Master和Save配置成同步刷盘方式，主从之间配置成异步的复制方式，这样即使有一台机器出故障，仍然能保证数据不丢，是个不错的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Producer负载均衡：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Producer端，每个实例在发消息的时候，默认会&lt;strong&gt;轮询&lt;/strong&gt;所有的Message Queue发送，以达到让消息平均落在不同的Queue上。而由于Queue可以散落在不同的Broker，所以消息就发送到不同的Broker下，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4618181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx8eXicp5eGicAWOhGnhSRZZguUGSYLFWThVdzVMkuO3jpfkOop3n5BQK4g/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot;/&gt;&lt;span&gt;Consumer负载均衡：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果Consumer实例的数量比Message Queue的总数量还多的话，&lt;strong&gt;多出来的Consumer实例将无法分到Queue&lt;/strong&gt;，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让Queue的总数量大于等于Consumer的数量。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费者的集群模式：启动多个消费者就可以保证消费者的负载均衡（均摊队列）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;默认使用的是均摊队列&lt;/strong&gt;：会按照Queue的数量和实例的数量平均分配Queue给每个实例，这样每个消费者可以均摊消费的队列，如下图所示6个队列和三个生产者。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;另外一种平均的算法&lt;strong&gt;环状轮流分Queue&lt;/strong&gt;的形式，每个消费者，均摊不同主节点的一个消息队列，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;对于广播模式并不是负载均衡的，要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;死信队列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一条消息消费失败，RocketMQ就会自动进行消息重试。而如果消息超过最大重试次数，RocketMQ就会认为这个消息有问题。但是此时，RocketMQ不会立刻将这个有问题的消息丢弃，而会将其发送到这个消费者组对应的一种特殊队列：死信队列。死信队列的名称是 %DLQ%+ConsumGroup 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;死信队列具有以下特性：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个死信队列对应一个Group ID， 而不是对应单个消费者实例。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果一个Group ID未产生死信消息，消息队列RocketMQ不会为其创建相应的死信队列。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个死信队列包含了对应Group ID产生的所有死信消息，不论该消息属于哪个Topic&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Kafka是一个分布式、支持分区的、多副本的，&lt;strong&gt;基于ZooKeeper&lt;/strong&gt;协调的分布式消息系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于Hadoop的批处理系统、低延迟的实时系统、Storm/Spark流式处理引擎，Web/Nginx日志、访问日志，消息服务等等，用&lt;strong&gt;Scala语言编写&lt;/strong&gt;。属于Apache基金会的顶级开源项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先看一下Kafka的架构图 ：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5490909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmdiabXTfZO37o8ksMOz2cxpVbibHjK1CMfaeA83leU7ge8JFj3jbBTL2A/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;Kafka的核心概念&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Kafka中有几个核心概念：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Broker&lt;/strong&gt;：消息中间件处理节点，一个Kafka节点就是一个Broker，一个或者多个Broker可以组成一个Kafka集群&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Topic&lt;/strong&gt;：Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Producer&lt;/strong&gt;：消息生产者，向Broker发送消息的客户端&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Consumer&lt;/strong&gt;：消息消费者，从Broker读取消息的客户端&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ConsumerGroup&lt;/strong&gt;：每个Consumer属于一个特定的ConsumerGroup，一条消息可以被多个不同的ConsumerGroup消费，但是一个ConsumerGroup中只能有一个Consumer能够消费该消息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Partition&lt;/strong&gt;：物理上的概念，一个topic可以分为多个partition，每个partition内部消息是有序的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Leader&lt;/strong&gt;：每个Partition有多个副本，其中有且仅有一个作为Leader，Leader是负责数据读写的Partition。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Follower&lt;/strong&gt;：Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，Leader会把这个Follower从 ISR列表 中删除，重新创建一个Follower。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Offset&lt;/strong&gt;：偏移量。Kafka的存储文件都是按照offset.kafka来命名，用Offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;可以这么来理解Topic，Partition和Broker：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个Topic，代表逻辑上的一个业务数据集，比如订单相关操作消息放入订单Topic，用户相关操作消息放入用户Topic，对于大型网站来说，后端数据都是海量的，订单消息很可能是非常巨量的，比如有几百个G甚至达到TB级别，如果把这么多数据都放在一台机器上可定会有容量限制问题，那么就可以在Topic内部划分多个Partition来分片存储数据，不同的Partition可以位于不同的机器上，相当于&lt;strong&gt;分布式存储&lt;/strong&gt;。每台机器上都运行一个Kafka的进程Broker。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka核心总控制器Controller&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Kafka集群中会有一个或者多个Broker，其中有一个Broker会被选举为控制器（Kafka Controller），可以理解为 Broker-Leader ，它负责管理整个 集群中所有分区和副本的状态。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;Partition-Leader&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;Controller选举机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Kafka集群启动的时候，选举的过程是集群中每个Broker都会尝试在ZooKeeper上创建一个 /controller临时节点，ZooKeeper会保证有且仅有一个Broker能创建成功，这个Broker就会成为集群的总控器Controller。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当这个Controller角色的Broker宕机了，此时ZooKeeper临时节点会消失，集群里其他Broker会一直监听这个临时节 点，发现临时节点消失了，就竞争再次创建临时节点，就是我们上面说的选举机制，ZooKeeper又会保证有一个Broker成为新的Controller。具备控制器身份的Broker需要比其他普通的Broker多一份职责，具体细节如下：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;监听Broker相关的变化&lt;/strong&gt;。为ZooKeeper中的/brokers/ids/节点添加BrokerChangeListener，用来处理Broker增减的变化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;监听Topic相关的变化&lt;/strong&gt;。为ZooKeeper中的/brokers/topics节点添加TopicChangeListener，用来处理Topic增减的变化；为ZooKeeper中的/admin/delete_topics节点添加TopicDeletionListener，用来处理删除Topic的动作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从ZooKeeper中读取获取当前所有与Topic、Partition以及Broker有关的信息并进行相应的管理 。对于所有Topic所对应的ZooKeeper中的/brokers/topics/节点添加PartitionModificationsListener，用来监听Topic中的分区分配变化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;更新集群的元数据信息，同步到其他普通的Broker节点中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;Partition副本选举Leader机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Controller感知到分区Leader所在的Broker挂了，Controller会从ISR列表（参数&lt;br/&gt;unclean.leader.election.enable=false的前提下）里挑第一个Broker作为Leader（第一个Broker最先放进ISR列表，可能是同步数据最多的副本），如果参数unclean.leader.election.enable为true，代表在ISR列表里所有副本都挂了的时候可以在ISR列表以外的副本中选Leader，这种设置，可以提高可用性，但是选出的新Leader有可能数据少很多。副本进入ISR列表有两个条件：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;副本节点不能产生分区，必须能与ZooKeeper保持会话以及跟Leader副本网络连通&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;副本能复制Leader上的所有写操作，并且不能落后太多。（与Leader副本同步滞后的副本，是由replica.lag.time.max.ms配置决定的，超过这个时间都没有跟Leader同步过的一次的副本会被移出ISR列表）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;消费者消费消息的Offset记录机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个Consumer会定期将自己消费分区的Offset提交给Kafka内部Topic：consumer_offsets，提交过去的时候，key是consumerGroupId+topic+分区号，value就是当前Offset的值，Kafka会定期清理Topic里的消息，最后就保留最新的那条数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为__consumer_offsets可能会接收高并发的请求，Kafka默认给其分配50个分区（可以通过&lt;br/&gt;offsets.topic.num.partitions设置），这样可以通过加机器的方式抗大并发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费者Rebalance机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rebalance就是说 如果消费组里的消费者数量有变化或消费的分区数有变化，Kafka会重新分配消费者与消费分区的关系 。比如consumer group中某个消费者挂了，此时会自动把分配给他的分区交给其他的消费者，如果他又重启了，那么又会把一些分区重新交还给他。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：Rebalance只针对subscribe这种不指定分区消费的情况，如果通过assign这种消费方式指定了分区，Kafka不会进行Rebalance。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下情况可能会触发消费者Rebalance：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费组里的Consumer增加或减少了&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;动态给Topic增加了分区&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费组订阅了更多的Topic&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;Rebalance过程中，消费者无法从Kafka消费消息，这对Kafka的TPS会有影响，如果Kafka集群内节点较多，比如数百 个，那重平衡可能会耗时极多，所以应尽量避免在系统高峰期的重平衡发生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rebalance过程如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当有消费者加入消费组时，消费者、消费组及组协调器之间会经历以下几个阶段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx8t9xtcSvqMQEPbwdRkIxRuPBtPVXVEB3CMfHvtiaicqUYW4iaFJMFMz8gg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot;/&gt;&lt;span&gt;&lt;strong&gt;第一阶段：选择组协调器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;组协调器GroupCoordinator：每个consumer group都会选择一个Broker作为自己的组协调器coordinator，负责监控这个消费组里的所有消费者的心跳，以及判断是否宕机，然后开启消费者Rebalance。consumer group中的每个consumer启动时会向Kafka集群中的某个节点发送FindCoordinatorRequest请求来查找对应的组协调器GroupCoordinator，并跟其建立网络连接。组协调器选择方式：通过如下公式可以选出consumer消费的Offset要提交到__consumer_offsets的哪个分区，这个分区Leader对应的Broker就是这个consumer group的coordinator公式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;hash(consumer group id) % 对应主题的分区数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二阶段：加入消费组JOIN GROUP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在成功找到消费组所对应的GroupCoordinator之后就进入加入消费组的阶段，在此阶段的消费者会向GroupCoordinator发送JoinGroupRequest请求，并处理响应。然后GroupCoordinator从一个consumer group中选择第一个加入group的consumer作为Leader（消费组协调器），把consumer group情况发送给这个Leader，接着这个Leader会负责制定分区方案。另外，搜索公众号Python人工智能技术后台回复“名著”，获取一份惊喜礼包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三阶段（SYNC GROUP）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;consumer leader通过给GroupCoordinator发送SyncGroupRequest，接着GroupCoordinator就把分区方案下发给各个consumer，他们会根据指定分区的Leader Broker进行网络连接以及消息消费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费者Rebalance分区分配策略&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要有三种Rebalance的策略：range 、 round-robin 、 sticky 。&lt;strong&gt;默认情况为range分配策略&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设一个主题有10个分区（0-9），现在有三个consumer消费：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;range策略：按照分区序号排序分配 ，假设n＝分区数／消费者数量 = 3， m＝分区数%消费者数量 = 1，那么前 m 个消 费者每个分配 n+1 个分区，后面的（消费者数量－m ）个消费者每个分配 n 个分区。比如分区0~ 3给一个consumer，分区4~ 6给一个consumer，分区7~9给一个consumer。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;round-robin策略：轮询分配 ，比如分区0、3、6、9给一个consumer，分区1、4、7给一个consumer，分区2、5、 8给一个consumer&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;sticky策略：初始时分配策略与round-robin类似，但是在rebalance的时候，需要保证如下两个原则：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分区的分配要尽可能均匀 。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分区的分配尽可能与上次分配的保持相同。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;当两者发生冲突时，第一个目标优先于第二个目标 。这样可以最大程度维持原来的分区分配的策略。比如对于第一种range情况的分配，如果第三个consumer挂了，那么重新用sticky策略分配的结果如下：consumer1除了原有的0~ 3，会再分配一个7 consumer2除了原有的4~ 6，会再分配8和9。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Producer发布消息机制剖析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、写入方式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;producer采用push模式将消息发布到broker，每条消息都被append到patition中，属于顺序写磁盘（&lt;strong&gt;顺序写磁盘 比 随机写 效率要高，保障 kafka 吞吐率&lt;/strong&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;pre mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjYxNDc2OQ==&amp;amp;mid=2247494973&amp;amp;idx=1&amp;amp;sn=3845f08876076eaafe1457a48b752f20&amp;amp;chksm=fbc0f823ccb77135921333d9cd41569f223cd85ffea3095a8ced1e711263f8698e0884a5cce0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍牛逼啊！接私活必备的 N 个开源项目！赶快收藏吧‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;牛逼啊！接私活必备的 N 个开源项目！赶快收藏吧&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;2、消息路由&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;producer发送消息到broker时，会根据分区算法选择将其存储到哪一个partition。其路由机制为：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;hash&lt;/span&gt;(key)%分区数&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;3、写入流程&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8072727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmlFddwXPVicP6tGz7ankHjcOlv6OcQL3w4uMlbwz64SHeVG9IXaUgoMA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;producer先从ZooKeeper的 &quot;/brokers/…/state&quot; 节点找到该partition的leader&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;producer将消息发送给该leader&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;leader将消息写入本地log&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;followers从leader pull消息，写入本地log后向leader发送ACK&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;leader收到所有ISR中的replica的ACK后，增加HW（high watermark，最后commit的offset）并向producer发送ACK&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;HW与LEO&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HW俗称高水位 ，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO（log-end-offset）作为HW， consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状 态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW， 此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。对于来自内部broker的读取请求，没有HW的限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日志分段存储&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka一个分区的消息数据对应存储在一个文件夹下，以topic名称+分区号命名，消息在分区内是分段存储的， 每个段的消息都存储在不一样的log文件里，Kafka规定了一个段位的log文件最大为1G，做这个限制目的是为了方便把log文件加载到内存去操作：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;1 ### 部分消息的&lt;span&gt;offset&lt;/span&gt;索引文件，&lt;span&gt;kafka&lt;/span&gt;每次往分区发4&lt;span&gt;K&lt;/span&gt;(可配置)消息就会记录一条当前消息的&lt;span&gt;offset&lt;/span&gt;到&lt;span&gt;index&lt;/span&gt;文件， &lt;br/&gt;&lt;br/&gt;2 ### 如果要定位消息的&lt;span&gt;offset&lt;/span&gt;会先在这个文件里快速定位，再去&lt;span&gt;log&lt;/span&gt;文件里找具体消息 &lt;br/&gt;&lt;br/&gt;3 00000000000000000000&lt;span&gt;.index&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;4 ### 消息存储文件，主要存&lt;span&gt;offset&lt;/span&gt;和消息体 &lt;br/&gt;&lt;br/&gt;5 00000000000000000000&lt;span&gt;.log&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;6 ### 消息的发送时间索引文件，&lt;span&gt;kafka&lt;/span&gt;每次往分区发4&lt;span&gt;K&lt;/span&gt;(可配置)消息就会记录一条当前消息的发送时间戳与对应的&lt;span&gt;offset&lt;/span&gt;到&lt;span&gt;timeindex&lt;/span&gt;文件， &lt;br/&gt;&lt;br/&gt;7 ### 如果需要按照时间来定位消息的&lt;span&gt;offset&lt;/span&gt;，会先在这个文件里查找 &lt;br/&gt;&lt;br/&gt;8 00000000000000000000&lt;span&gt;.timeindex&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;9 &lt;br/&gt;&lt;br/&gt;10 00000000000005367851&lt;span&gt;.index&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;11 00000000000005367851&lt;span&gt;.log&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;12 00000000000005367851&lt;span&gt;.timeindex&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;13 &lt;br/&gt;&lt;br/&gt;14 00000000000009936472&lt;span&gt;.index&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;15 00000000000009936472&lt;span&gt;.log&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;16 00000000000009936472&lt;span&gt;.timeindex&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这个9936472之类的数字，就是代表了这个日志段文件里包含的起始 Offset，也就说明这个分区里至少都写入了接近1000万条数据了。Kafka Broker有一个参数，log.segment.bytes，限定了每个日志段文件的大小，最大就是1GB。一个日志段文件满了，就自动开一个新的日志段文件来写入，避免单个文件过大，影响文件的读写性能，这个过程叫做log rolling，正在被写入的那个日志段文件，叫做active log segment。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后附一张ZooKeeper节点数据图&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5690909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmrRDONQiaC4jwSibjwtibufRSbznQicJj3ONolhvDbzNAlh6wthsCd9Ubgw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;MQ带来的一些问题、及解决方案&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;如何保证顺序消费？&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;如何实现延迟消费？&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3327272727272727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmplS5SF0nJ7ofXsg8quUjyRWLonV7hSVyDsg0QurFtRLaaH3o57qeuQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;如何保证消息的可靠性投递&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Broker--&amp;gt;消费者：手动ACK&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;生产者--&amp;gt;Broker：两种方案&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;数据库持久化：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;.将业务订单数据和生成的&lt;span&gt;Message&lt;/span&gt;进行持久化操作（一般情况下插入数据库，这里如果分库的话可能涉及到分布式事务）&lt;br/&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;.将&lt;span&gt;Message&lt;/span&gt;发送到Broker服务器中&lt;br/&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;.通过RabbitMQ的Confirm机制，在producer端，监听服务器是否ACK。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;.如果ACK了，就将&lt;span&gt;Message&lt;/span&gt;这条数据状态更新为已发送。如果失败，修改为失败状态。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;.分布式定时任务查询数据库&lt;span&gt;3&lt;/span&gt;分钟（这个具体时间应该根据的时效性来定）之前的发送失败的消息&lt;br/&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;.重新发送消息，记录发送次数&lt;br/&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;.如果发送次数过多仍然失败，那么就需要人工排查之类的操作。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6854545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmy4rhX42iciaolFsTzwNSYJ5qGUdiawRutBQofb7tSUXKFicEuJmfXjFlTQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;优点：能够保证消息百分百不丢失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点：第一步会涉及到分布式事务问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息的延迟投递：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;流程图中，颜色不同的代表不同的&lt;span&gt;message&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;1&lt;/span&gt;.将业务订单持久化&lt;br/&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;.发送一条&lt;span&gt;Message&lt;/span&gt;到broker(称之为主&lt;span&gt;Message&lt;/span&gt;)，再发送相同的一条到不同的队列或者交换机(这条称为确认&lt;span&gt;Message&lt;/span&gt;)中。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;.主&lt;span&gt;Message&lt;/span&gt;由实际业务处理端消费后，生成一条响应&lt;span&gt;Message&lt;/span&gt;。之前的确认&lt;span&gt;Message&lt;/span&gt;由&lt;span&gt;Message&lt;/span&gt; Service应用处理入库。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;~&lt;span&gt;6&lt;/span&gt;.实际业务处理端发送的确认&lt;span&gt;Message&lt;/span&gt;由&lt;span&gt;Message&lt;/span&gt; Service接收后，将原&lt;span&gt;Message&lt;/span&gt;状态修改。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;.如果该条&lt;span&gt;Message&lt;/span&gt;没有被确认，则通过rpc调用重新由producer进行全过程。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33090909090909093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmjEfxDGXNpPLJOygefrkg1f2ar0yciaUlj5QW62535bSO5P6D5OYlwdA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;优点：相对于持久化方案来说响应速度有所提升&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点：系统复杂性有点高，万一消息都失败了，消息存在丢失情况，仍需Confirm机制做补偿。扩展：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjM3MDEyMg==&amp;amp;mid=2247534656&amp;amp;idx=2&amp;amp;sn=2781baec773a9340091436c521430648&amp;amp;chksm=e8dae9e5dfad60f33204393e3c333800e8fb8dd39fd43064d496b665cd31c0a61b742f2f23b2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍接私活儿‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;接私活儿&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;生产者弄丢数据：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Producer在把Message发送Broker的过程中，因为网络问题等发生丢失，或者Message到了Broker，但是出了问题，没有保存下来。针对这个问题，&lt;span&gt;RocketMQ&lt;/span&gt;对Producer发送消息设置了3种方式：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;同步发送&lt;br/&gt;异步发送&lt;br/&gt;单向发送&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;Broker弄丢数据：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Broker接收到Message暂存到内存，Consumer还没来得及消费，Broker挂掉了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以通过 持久化 设置去解决：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;创建Queue的时候设置持久化，保证Broker持久化Queue的元数据，但是不会持久化Queue里面的消息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将Message的deliveryMode设置为2，可以将消息持久化到磁盘，这样只有Message支持化到磁盘之后才会发送通知Producer ack&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这两步过后，即使Broker挂了，Producer肯定收不到ack的，就可以进行重发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费者弄丢数据：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Consumer有消费到Message，但是内部出现问题，Message还没处理，Broker以为Consumer处理完了，只会把后续的消息发送。这时候，就要 关闭autoack，消息处理过后，进行手动ack , 多次消费失败的消息，会进入 死信队列 ，这时候需要人工干预。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;生产者弄丢数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设置了 acks=all ，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Broker弄丢数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时一般是要求起码设置如下 4 个参数：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;replication.factor&lt;br/&gt;min.insync.replicas&lt;br/&gt;acks=all&lt;br/&gt;retries=MAX&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费者弄丢数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要 关闭自动提交 offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是可能会有重复消费，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;如何保证消息的幂等？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;以 RocketMQ 为例，下面列出了消息重复的场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发送时消息重复&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且Message ID也相同的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投递时消息重复&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。为了保证消息至少被消费一次，消息队列&lt;span&gt;RocketMQ&lt;/span&gt;版的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且Message ID也相同的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负载均衡时消息重复（包括但不限于网络抖动、Broker重启以及消费者应用重启）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当消息队列RocketMQ版的Broker或客户端重启、扩容或缩容时，会触发Rebalance，此时消费者可能会收到重复消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，有什么解决方案呢？直接上图。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1189591078066914&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDm2L8ia4D2TFytFpGdcARb3kbKaVLt1p3o0PsZTlibaU0cXSm6LUDAvlag/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1076&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;如何解决消息积压的问题？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;关于这个问题，有几个点需要考虑：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何快速让积压的消息被消费掉？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;临时写一个消息分发的消费者，把积压队列里的消息均匀分发到N个队列中，同时一个队列对应一个消费者，相当于消费速度提高了N倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;修改前：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5664739884393064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmCial2cgvviaOGMyPOzib2E5oxUYZWP4QIpSiczAOFH2rIcfGe3ZpjJLiaIQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1038&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;修改后：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.68&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmCNrHYgLCHZNNDw0TME7uicSsuHnJrhW55gyibuWXyaeeYicEIZe6zw41A/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;积压时间太久，导致部分消息过期，怎么处理？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;批量重导。在业务不繁忙的时候，比如凌晨，提前准备好程序，把丢失的那批消息查出来，重新导入到MQ中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息大量积压，MQ磁盘被写满了，导致新消息进不来了，丢掉了大量消息，怎么处理？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个没办法。谁让【消息分发的消费者】写的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;链接：jianshu.com/p/2975d354fca5&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;（版权归原作者所有，侵删）&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-before-oversubscription-url=&quot;https://mmbiz.qlogo.cn/mmbiz_gif/HbjXqFK3L72957xsibH48vUn4119YSdqKzKaWGu3iaLPF8MpDeGzGJRDyXEjp2hEX6VE5ruWP2uibv4tVibOrwYIaA/0?wx_fmt=gif&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQEfcffueY0reDaT8agHibMbk6Pqc4ibhiccO8Pz07m9jJ4eyuPZVomxWiac5FdicwB3aOub11CqBzXQrjw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7185185185185186&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEa0J6uBEmJSsusCngZf5tUsHnDPvWW0f4RASUkKy4UmdvEhtP7jLfKQoViaCNG39G7AFoh1o8ibTibMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>