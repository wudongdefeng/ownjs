<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a1c5e830222a1a1f975b5c3ef8f61ace</guid>
<title>如何画出一张优秀的架构图？（老鸟必备）</title>
<link>https://toutiao.io/k/xiqybrh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;br/&gt;作者：三画&lt;/p&gt;&lt;p&gt;简介：阿里巴巴技术专家，梓敬、鹏升和余乐对此文亦有贡献。三画曾多年从事工作流引擎研发工作，现专注于高并发移动互联网应用的架构和开发。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术传播的价值，不仅仅体现在通过商业化产品和开源项目来缩短我们构建应用的路径。加速业务的上线速率，也体现在优秀工程师的工作效率提升、产品性能优化和用户体验改善等经验方面的分享，以提高我们的专业能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，阿里巴巴技术专家三画，将分享自己和团队在画好架构图方面的理念和经验，希望对你有所帮助。当我们想用一张或几张图来描述我们的系统时，是不是经常遇到以下情况：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对着画布无从下手、删了又来?如何用一张图描述我的系统，并且让产品、运营、开发都能看明白?画了一半的图还不清楚受众是谁?画出来的图到底是产品图功能图还是技术图又或是大杂烩?图上的框框有点少是不是要找点儿框框加进来?布局怎么画都不满意…&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有同样的困惑，本文将介绍一种画图的方法论，来让架构图更清晰。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;先厘清一些基础概念&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;什么是架构?&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构就是对系统中的实体以及实体之间的关系所进行的抽象描述，是一系列的决策。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构是结构和愿景。系统架构是概念的体现，是对物/信息的功能与形式元素之间的对应情况所做的分配，是对元素之间的关系以及元素同周边环境之间的关系所做的定义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做好架构是个复杂的任务，也是个很大的话题，本篇就不做深入了。有了架构之后，就需要让干系人理解、遵循相关决策。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;什么是架构图?&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统架构图是为了抽象地表示软件系统的整体轮廓和各个组件之间的相互关系和约束边界，以及软件系统的物理部署和软件系统的演进方向的整体视图。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;架构图的作用&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一图胜千言。要让干系人理解、遵循架构决策，就需要把架构信息传递出去。架构图就是一个很好的载体。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，画架构图是为了：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;架构图分类&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搜集了很多资料，分类有很多，有一种比较流行的是 4+1 视图，分别为场景视图、逻辑视图、物理视图、处理流程视图和开发视图。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;场景视图&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景视图用于描述系统的参与者与功能用例间的关系，反映系统的最终需求和交互设计，通常由用例图表示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6516666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0ogYZWsia7scG2TWNQjHDdibwmv5qm6TkAibVIbygicx33N4IL2ZbYmtMuuEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;逻辑视图&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逻辑视图用于描述系统软件功能拆解后的组件关系，组件约束和边界，反映系统整体组成与系统如何构建的过程，通常由 UML 的组件图和类图来表示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0ogXIcazTEgTgIjtzYkXRy2GtAKCxXxCbibicQ96yiah57VFh2QibzJGCoTHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;物理视图&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;物理视图用于描述系统软件到物理硬件的映射关系，反映出系统的组件是如何部署到一组可计算机器节点上，用于指导软件系统的部署实施过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6933333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0ogiafMPyLM1bFSKk8HOuRFrDFvkwT2wqaDTZjz8LoHvK5ibibRmOdFBLt0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;处理流程视图&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;处理流程视图用于描述系统软件组件之间的通信时序，数据的输入输出，反映系统的功能流程与数据流程，通常由时序图和流程图表示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8183333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0oglYE0XGwPQC4eG55oPe7g040xNvVXrRuCtRpwXhATbkkkhUSKLibPDUw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;开发视图&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发视图用于描述系统的模块划分和组成，以及细化到内部包的组成设计，服务于开发人员，反映系统开发实施过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7183333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0ogRe0aANHGDy4icbWSWHgUOC7PRq9dxdYlhf9bXw3ibNEybhLZCuibfEuibA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上 5 种架构视图从不同角度表示一个软件系统的不同特征，组合到一起作为架构蓝图描述系统架构。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;怎样的架构图是好的架构图&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的分类是前人的经验总结，图也是从网上摘来的，那么这些图画的好不好呢?是不是我们要依葫芦画瓢去画这样一些图?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先不去管这些图好不好，我们通过对这些图的分类以及作用，思考了一下，总结下来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们认为，在画出一个好的架构图之前， 首先应该要明确其受众，再想清楚要给他们传递什么信息 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，不要为了画一个物理视图去画物理视图，为了画一个逻辑视图去画逻辑视图，而应该根据受众的不同，传递的信息的不同，用图准确地表达出来，最后的图可能就是在这样一些分类里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，画出的图好不好的一个直接标准就是：受众有没有准确接收到想传递的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明确这两点之后，从受众角度来说，一个好的架构图是不需要解释的，它应该是自描述的，并且要具备一致性和足够的准确性，能够与代码相呼应。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;画架构图遇到的常见问题&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;方框代表什么?&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2757009345794392&quot; data-type=&quot;jpeg&quot; data-w=&quot;428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0ogW97hGIKcuYtMIicHsXA4yCyCQSob780Yyicr4wqLVgEKlmib6MZOgp9FQ/640?wx_fmt=jpeg&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么适用方框而不是圆形，它有什么特殊的含义吗?随意使用方框或者其他形状可能会引起混淆。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;虚线、实线什么意思?箭头什么意思?颜色什么意思?&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0ogGCepPmzZ5yrbgH1bkB9crLChdxUAzEJ19eZIhzsy4ZpKsoIHKzNl0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随意使用线条或者箭头可能会引起误会。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;运行时与编译时冲突?层级冲突?&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0ogGCepPmzZ5yrbgH1bkB9crLChdxUAzEJ19eZIhzsy4ZpKsoIHKzNl0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构是一项复杂的工作，只使用单个图表来表示架构很容易造成莫名其妙的语义混乱。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;本文推荐的画图方法&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0og0R6Hn7DGpTe2urd3h5BvKibBtVtkB3LHUcalXkPm7TYlYcqficrahPgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C4 模型使用容器(应用程序、数据存储、微服务等)、组件和代码来描述一个软件系统的静态结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几种图比较容易画，也给出了画图要点，但最关键的是，我们认为，它明确指出了每种图可能的受众以及意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的案例来自 C4 官网，然后加上了一些我们的理解，来看看如何更好的表达软件架构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;语境图(System Context Diagram)&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7933333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0ogryL1BkLiap39frpRKjXgYLD3ZqnPVAcDia2M3POluc44j7pzNFC0icIvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个想象的待建设的互联网银行系统，它使用外部的大型机银行系统存取客户账户、交易信息，通过外部电邮系统给客户发邮件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，非常简单、清晰，相信不需要解释，都看的明白，里面包含了需要建设的系统本身，系统的客户，和这个系统有交互的周边系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一个简单的图，可以告诉我们，要构建的系统是什么;它的用户是谁，谁会用它，它要如何融入已有的 IT 环境。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个图的受众可以是开发团队的内部人员、外部的技术或非技术人员。即：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;构建的系统是什么&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;谁会用它&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何融入已有的 IT 环境&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么画?中间是自己的系统，周围是用户和其他与之相互作用的系统。这个图的关键就是梳理清楚待建设系统的用户和高层次的依赖，梳理清楚了画下来只需要几分钟时间。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;容器图(Container Diagram)&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容器图是把语境图里待建设的系统做了一个展开。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0ogjUYoXgMyPMHcKEzZJ1dLLInROmlY3n2zr56pXicKM59HPzAmngM8ZGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图中，除了用户和外围系统，要建设的系统包括一个基于 Java\Spring MVC的 Web 应用提供系统的功能入口，基于 Xamarin 架构的手机  App 提供手机端的功能入口，一个基于 Java 的 API 应用提供服务，一个 MySQL 数据库用于存储，各个应用之间的交互都在箭头线上写明了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看这张图的时候，不会去关注到图中是直角方框还是圆角方框，不会关注是实线箭头还是虚线箭头，甚至箭头的指向也没有引起太多注意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们有许多的画图方式，都对框、线的含义做了定义，这就需要画图的人和看图的人都清晰的理解这些定义，才能读全图里的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而现实是，这往往是非常高的一个要求，所以，很多图只能看个大概的含义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个图的受众可以是团队内部或外部的开发人员，也可以是运维人员。用途可以罗列为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;展现了软件系统的整体形态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;体现了高层次的技术决策。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统中的职责是如何分布的，容器间是如何交互的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;告诉开发者在哪里写代码。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么画?用一个框图来表示，内部可能包括名称、技术选择、职责，以及这些框图之间的交互，如果涉及外部系统，最好明确边界。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;组件图(Component Diagram)&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9633333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0ogib62KXSu09oPhotAjpx6ib4ZmlX0c0qVxtrib98YdEmvY6y7ELLs8OibPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组件图是把某个容器进行展开，描述其内部的模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个图主要是给内部开发人员看的，怎么去做代码的组织和构建。其用途有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;描述了系统由哪些组件/服务组成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;厘清了组件之间的关系和依赖&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为软件开发如何分解交付提供了框架&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;类图(Code/Class Diagram)&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7016666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0ogcsuqfZ4EQWjUQGszm3WACm3tc98OtnE2wd6ialXrxZMdDOictqYKUmhw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个图很显然是给技术人员看的，比较常见，就不详细介绍了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;案例分享&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是内部的一个实时数据工具的架构图。作为一个应该自描述的架构图，这里不多做解释了。如果有看不明白的，那肯定是还画的不够好。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7283333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7U1tvx0KcEnghMpHPaibr0ogjtXXt06ZuBPI0T4avgReyCf5KBlHlIfAp9slolqpttEdASTCaazKYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画好架构图可能有许多方法论，本篇主要介绍了 C4 这种方法，C4 的理论也是不断进化的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但不论是哪种画图方法论，我们回到画图初衷，是为了更好的交流，我们在画的过程中不必被条条框框所限制。简而言之，画之前想好：画图给谁看，看什么，怎么样不解释就看懂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画图的工具有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Keynote&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Xmind&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;EdrawMax&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Visio&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OmniGraffle&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Process On&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中物理视图 Download 地址：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Win：http://t.cn/EXAGBDW&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Mac：http://t.cn/EXAqtx&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c0e3dd38669749a0e8082278abfef99e</guid>
<title>网关系统就该这么设计（万能通用），稳的一批</title>
<link>https://toutiao.io/k/30261hg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文准备围绕七个点来讲网关，分别是网关的基本概念、网关设计思路、网关设计重点、流量网关、业务网关、常见网关对比，对基础概念熟悉的朋友可以根据目录查看自己感兴趣的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关，很多地方将网关比如成门， 没什么问题， 但是需要区分网关与网桥的区别，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网桥&lt;/strong&gt; 工作在数据链路层，在不同或相同类型的LAN之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网关&lt;/strong&gt; 是一个大概念，不具体特指一类产品，只要连接两个不同的网络都可以叫网关，网桥一般只转发信息，而网关可能进行包装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据网关的特性，举个例子:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如你要去找集团老板(这儿只是举个例子)， 大家都知道老板肯定不是谁想见就能见的， 也怕坏人嘛， 那么你去老板所在的办公楼，假如是集团总部， 大楼这个门就充当了网关的角色， 大门一般都有看门员 ，看门员会做哪些事情呢?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先所有想见老板的人肯定都得从这个门进(&lt;strong&gt;统一入口&lt;/strong&gt; )， 这个门相当于将办公室和外界隔离了，主要为了保护里面的安全以及正常工作， 来到这个门之后， 门卫肯定会让你出示相关证件(&lt;strong&gt;鉴权检验&lt;/strong&gt; )， 意思就是判断你要见老板这个请求是否合理， 如果不合理直接就拒绝了， 让你回家等消息 ， 如果鉴权之后， 发现你找老板其实只是为了和他谈谈两元店的生意， 门卫会跟你说这个用不着找老板， 你去集团投资部就行了(&lt;strong&gt;动态路由&lt;/strong&gt; ， 将请求路由到不同的后端集群中)， 此时会对你进行一些&lt;strong&gt;包装&lt;/strong&gt; ，例如给你出具一个访问证类似的，然后告诉你路该怎么走，等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看看，网关的作用是不是就是这三个， 最终目的就是减少你与集团的耦合，具体到计算机上就是减少客户端与服务端的耦合，如果没有网关意味着所有请求都会直接调用服务器上的资源，这样耦合太强了，服务器出了问题，客户端会直接报错， 例如老板换工作的地方了，如果没有网关你直接去原来的地方找， 肯定会被告知老板不在这儿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用单体应用程序架构时，客户端（Web 或移动端）通过向后端应用程序发起一次 REST 调用来获取数据。负载均衡器将请求路由给 N 个相同的应用程序实例中的一个。然后应用程序会查询各种数据库表，并将响应返回给客户端。微服务架构下，单体应用被切割成多个微服务，如果将所有的微服务直接对外暴露，势必会出现安全方面的各种问题，另外内外耦合严重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端可以直接向每个微服务发送请求，其问题主要如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端需求和每个微服务暴露的细粒度 API 不匹配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部分服务使用的协议不是Web友好协议。可能使用 Thrift 二进制 RPC，也可能使用 AMQP 消息传递协议。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微服务难以重构。如果合并两个服务，或者将一个服务拆分成两个或更多服务，这类重构就非常困难了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端的各个服务直接暴露给客户端调用势必会引起各种问题。同时，服务端的各个服务可扩展和伸缩性很差。API 网关是微服务架构中的基础组件，位于接入层之下和业务服务层之上，如前所述的这些功能适合在 API 网关实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到我们服务器上，下面图介绍了网关(Gateway)作用，可知 Gateway 方式下的架构，可以细到为每一个服务的实例配置一个自己的 Gateway，也可以粗到为一组服务配置一个，甚至可以粗到为整个架构配置一个接入的 Gateway。于是，整个系统架构的复杂度就会变得简单可控起来。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5165929203539823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfet8BibYa4AKljkpjdd3JbcuFm4pUpNqvusZzKuQks7J0clK3qvBqJzFSdOW7jle02xhRmyWiac2SNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这张图展示了一个多层 Gateway 架构，其中有一个总的 Gateway 接入所有的流量(&lt;strong&gt;流量网关&lt;/strong&gt; )，并分发给不同的子系统，还有第二级 Gateway 用于做各个子系统的接入 Gateway(&lt;strong&gt;业务网关&lt;/strong&gt; )。可以看到，网关所管理的服务粒度可粗可细。通过网关，我们可以把分布式架构组织成一个星型架构，由网络对服务的请求进行路由和分发。下面来聊聊好的网关应该具备哪些功能，也就是网关设计模式。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Boot + MyBatis Plus + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://gitee.com/zhijiantianya/ruoyi-vue-pro&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个网关需要有以下的功能:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关一定要有请求路由的功能。这样一来，对于调用端来说，也是一件非常方便的事情。因为调用端不需要知道自己需要用到的其它服务的地址，全部统一地交给 Gateway 来处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能够代理后面的服务，并把请求路由到正确的位置上，网关应该有服务注册功能，也就是后端的服务实例可以把其提供服务的地址注册、取消注册。一般来说，注册也就是注册一些 API 接口。比如，HTTP 的 Restful 请求，可以注册相应 API 的 URI、方法、HTTP 头。这样，Gateway 就可以根据接收到的请求中的信息来决定路由到哪一个后端的服务上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为一个网关可以接收多个服务实例，所以网关还需要在各个对等的服务实例上做负载均衡策略。简单点就是直接 Round-Robin 轮询，复杂点的可以设置上权重进行分发，再复杂一点还可以做到 session 粘连。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关还可以把弹力设计中的那些异步、重试、幂等、流控、熔断、监视等都可以实现进去。这样，同样可以像 Service Mesh 那样，让应用服务只关心自己的业务逻辑（或是说数据面上的事）而不是控制逻辑（控制面）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SSL 加密及证书管理、Session 验证、授权、数据校验，以及对请求源进行恶意攻击的防范。错误处理越靠前的位置就是越好，所以，网关可以做到一个全站的接入组件来对后端的服务进行保护。当然，网关还可以做更多更有趣的事情，比如：灰度发布、API聚合、API编排。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;灰度发布&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关完全可以做到对相同服务不同版本的实例进行导流，还可以收集相关的数据。这样对于软件质量的提升，甚至产品试错都有非常积极的意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API 聚合&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用网关可以将多个单独请求聚合成一个请求。在微服务体系的架构中，因为服务变小了，所以一个明显的问题是，客户端可能需要多次请求才能得到所有的数据。这样一来，客户端与后端之间的频繁通信会对应用程序的性能和规模产生非常不利的影响。于是，我们可以让网关来帮客户端请求多个后端的服务（有些场景下完全可以并发请求），然后把后端服务的响应结果拼装起来，回传给客户端（当然，这个过程也可以做成异步的，但这需要客户端的配合）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API 编排&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样在微服务的架构下，要走完一个完整的业务流程，我们需要调用一系列 API，就像一种工作流一样，这个事完全可以通过网页来编排这个业务流程。我们可能通过一个 DSL 来定义和编排不同的 API，也可以通过像 AWS Lambda 服务那样的方式来串联不同的 API。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Cloud Alibaba + Gateway + Nacos + RocketMQ + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://gitee.com/zhijiantianya/yudao-cloud&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关设计重点主要是三个， 高性能、高可用、高扩展:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在技术设计上，网关不应该也不能成为性能的瓶颈。对于高性能，最好使用高性能的编程语言来实现，如 C、C++、Go 和 Java。网关对后端的请求，以及对前端的请求的服务一定要使用异步非阻塞的 I/O 来确保后端延迟不会导致应用程序中出现性能问题。C 和 C++ 可以参看 Linux 下的 epoll 和 Windows 的 I/O Completion Port 的异步 IO 模型，Java 下如 Netty、Spring Reactor 的 NIO 框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为所有的流量或调用经过网关，所以网关必须成为一个高可用的技术组件，它的稳定直接关系到了所有服务的稳定。网关如果没有设计，就会成变一个单点故障。因此，一个好的网关至少要做到以下几点。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;集群化&lt;/strong&gt; 。网关要成为一个集群，其最好可以自己组成一个集群，并可以自己同步集群数据，而不需要依赖于一个第三方系统来同步数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;服务化&lt;/strong&gt; 。网关还需要做到在不间断的情况下修改配置，一种是像 Nginx reload 配置那样，可以做到不停服务，另一种是最好做到服务化。也就是说，得要有自己的 Admin API 来在运行时修改自己的配置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;持续化&lt;/strong&gt; 。比如重启，就是像 Nginx 那样优雅地重启。有一个主管请求分发的主进程。当我们需要重启时，新的请求被分配到新的进程中，而老的进程处理完正在处理的请求后就退出。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为网关需要承接所有的业务流量和请求，所以一定会有或多或少的业务逻辑。而我们都知道，业务逻辑是多变和不确定的。比如，需要在网关上加入一些和业务相关的东西。因此，一个好的 Gateway 还需要是可以扩展的，并能进行二次开发的。当然，像 Nginx 那样通过 Module 进行二次开发的固然可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，在&lt;strong&gt;运维方面&lt;/strong&gt; ，网关应该有以下几个设计原则。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;业务松耦合，协议紧耦合&lt;/strong&gt; 。在业务设计上，网关不应与后面的服务之间形成服务耦合，也不应该有业务逻辑。网关应该是在网络应用层上的组件，不应该处理通讯协议体，只应该解析和处理通讯协议头。另外，除了服务发现外，网关不应该有第三方服务的依赖。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;应用监视，提供分析数据&lt;/strong&gt; 。网关上需要考虑应用性能的监控，除了有相应后端服务的高可用的统计之外，还需要使用 Tracing ID 实施分布式链路跟踪，并统计好一定时间内每个 API 的吞吐量、响应时间和返回码，以便启动弹力设计中的相应策略。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;用弹力设计保护后端服务&lt;/strong&gt; 。网关上一定要实现熔断、限流、重试和超时等弹力设计。如果一个或多个服务调用花费的时间过长，那么可接受超时并返回一部分数据，或是返回一个网关里的缓存的上一次成功请求的数据。你可以考虑一下这样的设计。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;DevOps&lt;/strong&gt; 。因为网关这个组件太关键了，所以需要 DevOps 这样的东西，将其发生故障的概率降到最低。这个软件需要经过精良的测试，包括功能和性能的测试，还有浸泡测试。还需要有一系列自动化运维的管控工具。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不要在网关中的代码里内置聚合后端服务的功能，而应考虑将聚合服务放在网关核心代码之外。可以使用 Plugin 的方式，也可以放在网关后面形成一个 Serverless 服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关应该靠近后端服务，并和后端服务使用同一个内网，这样可以保证网关和后端服务调用的低延迟，并可以减少很多网络上的问题。这里多说一句，网关处理的静态内容应该靠近用户（应该放到 CDN 上），而网关和此时的动态服务应该靠近后端服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关也需要做容量扩展，所以需要成为一个集群来分担前端带来的流量。这一点，要么通过 DNS 轮询的方式实现，要么通过 CDN 来做流量调度，或者通过更为底层的性能更高的负载均衡设备。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于服务发现，可以做一个时间不长的缓存，这样不需要每次请求都去查一下相关的服务所在的地方。当然，如果你的系统不复杂，可以考虑把服务发现的功能直接集成进网关中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为网关考虑 bulkhead 设计方式。用不同的网关服务不同的后端服务，或是用不同的网关服务前端不同的客户。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，因为网关是为用户请求和后端服务的桥接装置，所以需要考虑一些安全方面的事宜。具体如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;加密数据&lt;/strong&gt; 。可以把 SSL 相关的证书放到网关上，由网关做统一的 SSL 传输管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;校验用户的请求&lt;/strong&gt; 。一些基本的用户验证可以放在网关上来做，比如用户是否已登录，用户请求中的 token 是否合法等。但是，我们需要权衡一下，网关是否需要校验用户的输入。因为这样一来，网关就需要从只关心协议头，到需要关心协议体。而协议体中的东西一方面不像协议头是标准的，另一方面解析协议体还要耗费大量的运行时间，从而降低网关的性能。对此，我想说的是，看具体需求，一方面如果协议体是标准的，那么可以干；另一方面，对于解析协议所带来的性能问题，需要做相应的隔离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;检测异常访问&lt;/strong&gt; 。网关需要检测一些异常访问，比如，在一段比较短的时间内请求次数超过一定数值；还比如，同一客户端的 4xx 请求出错率太高……对于这样的一些请求访问，网关一方面要把这样的请求屏蔽掉，另一方面需要发出警告，有可能会是一些比较重大的安全问题，如被黑客攻击。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流量网关，顾名思义就是控制流量进入集群的网关，有很多工作需要在这一步做，对于一个服务集群，势必有很多非法的请求或者无效的请求，这时候要将请求拒之门外，降低集群的流量压力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7321212121212122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfet8BibYa4AKljkpjdd3JbcuZVyW353MHYNzzgzPhNv6nlcld7B7VDcLkYibg5qcQALsmctJpx9f2Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;825&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义全局性的、跟具体的后端业务应用和服务完全无关的策略网关就是上图所示的架构模型——流量网关。流量网关通常只专注于全局的Api管理策略，比如全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等，有点类似防火墙。&lt;strong&gt;Kong 就是典型的流量网关。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是kong的架构图，来自官网：https://konghq.com&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8998144712430427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfet8BibYa4AKljkpjdd3Jbcu7v9S1Zp5sNIwHw7AEsQLsiaK0FZVBhTibjUAicmLta58Q9Xe67kC8mLQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要补充一点的是，业务网关一般部署在流量网关之后、业务系统之前，比流量网关更靠近业务系统。通常API网指的是业务网关。有时候我们也会模糊流量网关和业务网关，让一个网关承担所有的工作，所以这两者之间并没有严格的界线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个单体应用被拆分成许许多多的微服务应用后，也带来了一些问题。一些与业务非强相关的功能，比如权限控制、日志输出、数据加密、熔断限流等，每个微服务应用都需要，因此存在着大量重复的代码实现。而且由于系统的迭代、人员的更替，各个微服务中这些功能的实现细节出现了较大的差异，导致维护成本变高。另一方面，原先单体应用下非常容易做的接口管理，在服务拆分后没有了一个集中管理的地方，无法统计已存在哪些接口、接口定义是什么、运行状态如何。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关就是为了解决上述问题。作为微服务体系中的核心基础设施，一般需要具备接口管理、协议适配、熔断限流、安全防护等功能，各种开源的网关产品（比如 zuul）都提供了优秀高可扩展性的架构、可以很方便的实现我们需要的一些功能、比如鉴权、日志监控、熔断限流等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与流量网关相对应的就是业务网关，业务网关更靠近我们的业务，也就是与服务器应用层打交道，那么有很多应用层需要考虑的事情就可以依托业务网关，例如在线程模型、协议适配、熔断限流，服务编排等。下面看看业务网关体系结构:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5492341356673961&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfet8BibYa4AKljkpjdd3JbcucAqp4cCvzRJTYhp6Gt4LwwWS45Uzn2FsF8mAYavObJumpC761Fxmicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个途中可以看出业务网关主要职责以及所做的事情， 目前业务网关比较成熟的 API 网关框架产品有三个 分别是:Zuul1、Zuul2 和 SpringCloud Gateway， 后面再进行对比。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然对比，就先宏观上对各种网关有一个了解，后面再挑一些常用的或者说应用广泛的详细了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前常见的开源网关大致上按照语言分类有如下几类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Nginx+lua&lt;/strong&gt; ：OpenResty、Kong、Orange、Abtesting gateway 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Java&lt;/strong&gt; ：Zuul/Zuul2、Spring Cloud Gateway、Kaazing KWG、gravitee、Dromara soul 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Go&lt;/strong&gt; ：Janus、fagongzi、Grpc-gateway&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Dotnet&lt;/strong&gt; ：Ocelot&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;NodeJS&lt;/strong&gt; ：Express Gateway、Micro Gateway&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照使用数量、成熟度等来划分，主流的有 5个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;OpenResty&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kong&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Zuul、Zuul2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Cloud Gateway&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty是一个流量网关，根据前面对流量网关的介绍就可以知道流量网关的指责。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty基于 Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过揉和众多设计良好的 Nginx 模块，OpenResty 有效地把 Nginx 服务器转变为一个强大的 Web 应用服务器，基于它开发人员可以使用 Lua 编程语言对 Nginx 核心以及现有的各种 Nginx C 模块进行脚本编程，构建出可以处理一万以上并发请求的极端高性能的 Web 应用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty 最早是顺应 OpenAPI 的潮流做的，所以 Open 取自“开放”之意，而Resty便是 REST 风格的意思。虽然后来也可以基于 ngx_openresty 实现任何形式的 web service 或者传统的 web 应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说 Nginx 不再是一个简单的静态网页服务器，也不再是一个简单的反向代理了。第二代的 openresty 致力于通过一系列 nginx 模块，把nginx扩展为全功能的 web 应用服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ngx_openresty 是用户驱动的项目，后来也有不少国内用户的参与，从 openresty.org 的点击量分布上看，国内和国外的点击量基本持平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ngx_openresty 目前有两大应用目标：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通用目的的 web 应用服务器。在这个目标下，现有的 web 应用技术都可以算是和 OpenResty 或多或少有些类似，比如 Nodejs， PHP 等等。ngx_openresty 的性能（包括内存使用和 CPU 效率）算是最大的卖点之一。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Nginx 的脚本扩展编程，用于构建灵活的 Web 应用网关和 Web 应用防火墙。有些类似的是 NetScaler。其优势在于 Lua 编程带来的巨大灵活性。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong基于OpenResty开发，也是流量层网关， 是一个云原生、快速、可扩展、分布式的Api 网关。继承了OpenResty的高性能、易扩展性等特点。Kong通过简单的增加机器节点，可以很容易的水平扩展。同时功能插件化，可通过插件来扩展其能力。而且在任何基础架构上都可以运行。具有以下特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;提供了多样化的认证层来保护Api。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可对出入流量进行管制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供了可视化的流量检查、监视分析Api。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够及时的转换请求和相应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供log解决方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可通过api调用Serverless 函数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kong解决了什么问题&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们决定对应用进行微服务改造时，应用客户端如何与微服务交互的问题也随之而来，毕竟服务数量的增加会直接导致部署授权、负载均衡、通信管理、分析和改变的难度增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面对以上问题，API GATEWAY是一个不错的解决方案，其所提供的访问限制、安全、流量控制、分析监控、日志、请求转发、合成和协议转换功能，可以解放开发者去把精力集中在具体逻辑的代码，而不是把时间花费在考虑如何解决应用和其他微服务链接的问题上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图片来自Kong官网:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6813559322033899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfet8BibYa4AKljkpjdd3Jbcu2iaFibIibIV90EHMBZJE5lC9qcrHHBjqY7eq0eBnNuuIasaWNtVcSsSHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到Kong解决的问题。专注于全局的Api管理策略，全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kong的优点以及性能&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在众多 API GATEWAY 框架中，Mashape 开源的高性能高可用API网关和API服务管理层——KONG（基于 NGINX+Lua）特点尤为突出，它可以通过插件扩展已有功能，这些插件（使用 lua 编写）在API请求响应循环的生命周期中被执行。于此同时，KONG本身提供包括 HTTP 基本认证、密钥认证、CORS、TCP、UDP、文件日志、API请求限流、请求转发及 NGINX 监控等基本功能。目前，Kong 在 Mashape 管理了超过 15，000 个 API，为 200，000 开发者提供了每月数十亿的请求支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kong架构&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong提供一些列的服务，这就不得不谈谈内部的架构:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.257602862254025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfet8BibYa4AKljkpjdd3Jbcuf7jebMUicw47Tj6L3KicbStcSY0iborIqN4V7sMzzVK3LtxO25FPq0CuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;559&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先最底层是基于Nginx， Nginx是高性能的基础层， 一个良好的负载均衡、反向代理器，然后在此基础上增加Lua脚本库，形成了OpenResty，拦截请求， 响应生命周期，可以通过Lua编写脚本，所以插件比较丰富。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;“&lt;/p&gt;&lt;p&gt;关于Kong的一些插件库以及如何配置，可以参考简书:开源API网关系统（Kong教程）入门到精通：https://www.jianshu.com/p/a68e45bcadb6&lt;/p&gt;&lt;p&gt;”&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul是所有从设备和web站点到Netflix流媒体应用程序后端请求的前门。作为一个边缘服务应用程序，Zuul被构建来支持动态路由、监视、弹性和安全性。它还可以根据需要将请求路由到多个Amazon自动伸缩组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul使用了一系列不同类型的过滤器，使我们能够快速灵活地将功能应用到服务中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;过滤器&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过滤器是Zuul的核心功能。它们负责应用程序的业务逻辑，可以执行各种任务。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Type&lt;/strong&gt; ：通常定义过滤器应用在哪个阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Async&lt;/strong&gt; ：定义过滤器是同步还是异步&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Execution Order&lt;/strong&gt; ：执行顺序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Criteria&lt;/strong&gt; ：过滤器执行的条件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Action&lt;/strong&gt; ：如果条件满足，过滤器执行的动作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul提供了一个动态读取、编译和运行这些过滤器的框架。过滤器之间不直接通信，而是通过每个请求特有的RequestContext共享状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是Zuul的一些过滤器:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Incoming&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Incoming过滤器在请求被代理到Origin之前执行。这通常是执行大部分业务逻辑的地方。例如:认证、动态路由、速率限制、DDoS保护、指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Endpoint&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Endpoint过滤器负责基于incoming过滤器的执行来处理请求。Zuul有一个内置的过滤器（ProxyEndpoint），用于将请求代理到后端服务器，因此这些过滤器的典型用途是用于静态端点。例如:健康检查响应，静态错误响应，404响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Outgoing&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Outgoing过滤器在从后端接收到响应以后执行处理操作。通常情况下，它们更多地用于形成响应和添加指标，而不是用于任何繁重的工作。例如:存储统计信息、添加/剥离标准标题、向实时流发送事件、gziping响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;过滤器类型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是与一个请求典型的生命周期对应的标准的过滤器类型：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;PRE&lt;/strong&gt; ：路由到Origin之前执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ROUTING&lt;/strong&gt; ：路由到Origin期间执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;POST&lt;/strong&gt; ：请求被路由到Origin之后执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ERROR&lt;/strong&gt; ：发生错误的时候执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些过滤器帮助我们执行以下功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;身份验证和安全性&lt;/strong&gt; ：识别每个资源的身份验证需求，并拒绝不满足它们的请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;监控&lt;/strong&gt; ：在边缘跟踪有意义的数据和统计数据，以便给我们一个准确的生产视图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;动态路由&lt;/strong&gt; ：动态路由请求到不同的后端集群&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;压力测试&lt;/strong&gt; ：逐渐增加集群的流量，以评估性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;限流&lt;/strong&gt; ：为每种请求类型分配容量，并丢弃超过限制的请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;静态响应处理&lt;/strong&gt; ：直接在边缘构建一些响应，而不是将它们转发到内部集群&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Zuul 1.0 请求生命周期&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6525229357798165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfet8BibYa4AKljkpjdd3JbculGDckWGshgUKI8T02T3RK1s0iagFYRY6GKv2HusbNHw1wfjdOdh1NwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netflix宣布了通用API网关Zuul的架构转型。Zuul原本采用同步阻塞架构，转型后叫作Zuul2，采用异步非阻塞架构。Zuul2和Zuul1在架构方面的主要区别在于，Zuul2运行在异步非阻塞的框架上，比如Netty。Zuul1依赖多线程来支持吞吐量的增长，而Zuul 2使用的Netty框架依赖事件循环和回调函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul 2.0 架构图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8235294117647058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfet8BibYa4AKljkpjdd3JbcuRGHk1RG91tBCTDSwlibREDlibTVeFkuE27SJWKQf7o89QLicsYfOhpeeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是Zuul2的架构，和Zuul1没有本质区别，两点变化：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;前端用Netty Server代替Servlet，目的是支持前端异步。后端用Netty Client代替Http Client，目的是支持后端异步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;过滤器换了一下名字，用Inbound Filters代替Pre-routing Filters，用Endpoint Filter代替Routing Filter，用Outbound Filters代替Post-routing Filters。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Inbound Filters&lt;/strong&gt; ：路由到 Origin 之前执行，可以用于身份验证、路由和装饰请求&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Endpoint Filters&lt;/strong&gt; ：可用于返回静态响应，否则内置的ProxyEndpoint过滤器将请求路由到Origin&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Outbound Filters&lt;/strong&gt; ：从Origin那里获取响应后执行，可以用于度量、装饰用户的响应或添加自定义header&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种类型的过滤器：sync 和 async。因为Zuul是运行在一个事件循环之上的，因此从来不要在过滤中阻塞。如果你非要阻塞，可以在一个异步过滤器中这样做，并且在一个单独的线程池上运行，否则可以使用同步过滤器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提到过&lt;strong&gt;Zuul2开始采用了异步模型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优势&lt;/strong&gt; 是异步非阻塞模式启动的线程很少，基本上一个CPU core上只需启一个事件环处理线程，它使用的线程资源就很少，上下文切换(Context Switch)开销也少。非阻塞模式可以接受的连接数大大增加，可以简单理解为请求来了只需要进队列，这个队列的容量可以设得很大，只要不超时，队列中的请求都会被依次处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不足&lt;/strong&gt; ，异步模式让编程模型变得复杂。一方面Zuul2本身的代码要比Zuul1复杂很多，Zuul1的代码比较容易看懂，Zuul2的代码看起来就比较费劲。另一方面异步模型没有一个明确清晰的请求-&amp;gt;处理-&amp;gt;响应执行流程(call flow)，它的流程是通过事件触发的，请求处理的流程随时可能被切换断开，内部实现要通过一些关联id机制才能把整个执行流再串联起来，这就给开发调试运维引入了很多复杂性，比如你在IDE里头调试异步请求流就非常困难。另外ThreadLocal机制在这种异步模式下就不能简单工作，因为只有一个事件环线程，不是每个请求一个线程，也就没有线程局部的概念，所以对于CAT这种依赖于ThreadLocal才能工作的监控工具，调用链埋点就不好搞(实际可以工作但需要进行特殊处理)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体上，异步非阻塞模式比较适用于IO密集型(IO bound)场景，这种场景下系统大部分时间在处理IO，CPU计算比较轻，少量事件环线程就能处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Zuul 与 Zuul 2 性能对比&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5895061728395061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfet8BibYa4AKljkpjdd3Jbcu5vvUAVkXu6IrrzibVlBXxoe8SLvDr0ibibxCgPqTuSMjCvn4En11IEfKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;648&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netflix给出了一个比较模糊的数据，&lt;strong&gt;大致Zuul2的性能比Zuul1好20%左右&lt;/strong&gt; ，这里的性能主要指每节点每秒处理的请求数。为什么说模糊呢？因为这个数据受实际测试环境，流量场景模式等众多因素影响，你很难复现这个测试数据。即便这个20%的性能提升是确实的，其实这个性能提升也并不大，和异步引入的复杂性相比，这20%的提升是否值得是个问题。Netflix本身在其博文22和ppt11中也是有点含糊其词，甚至自身都有一些疑问的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringCloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 2.0之前的非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spring Cloud Gateway 底层使用了高性能的通信框架Netty&lt;/strong&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SpringCloud Gateway 特征&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringCloud官方，对SpringCloud Gateway 特征介绍如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）集成 Hystrix 断路器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）集成 Spring Cloud DiscoveryClient&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）Predicates 和 Filters 作用于特定路由，易于编写的 Predicates 和 Filters&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）具备一些网关的高级功能：动态路由、限流、路径重写&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从以上的特征来说，和Zuul的特征差别不大。SpringCloud Gateway和Zuul主要的区别，还是在底层的通信框架上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说明一下上文中的三个术语：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Filter&lt;/strong&gt; （过滤器）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和Zuul的过滤器在概念上类似，可以使用它拦截和修改请求，并且对上游的响应，进行二次处理。过滤器为org.springframework.cloud.gateway.filter.GatewayFilter类的实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Route&lt;/strong&gt; （路由）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关配置的基本组成模块，和Zuul的路由配置模块类似。一个&lt;strong&gt;Route模块&lt;/strong&gt; 由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Predicate&lt;/strong&gt; （断言）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个 Java 8 的 Predicate，可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。&lt;strong&gt;断言的&lt;/strong&gt; 输入类型是一个 ServerWebExchange。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5711135611907387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfet8BibYa4AKljkpjdd3JbcuDbhaQxqsw9ibnJJqqx8nul0pqcsaDuLeaE9zfbHL9wFYCBCkfc3rKkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d5916a5999d9367632b7223d60aebc2d</guid>
<title>基于「结构化思考」的研发管理实践</title>
<link>https://toutiao.io/k/va06enl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;h1&gt;为什么想到要「结构化」&lt;/h1&gt;&lt;hr/&gt;&lt;h2&gt;人&lt;/h2&gt;&lt;p&gt;前几年，有幸读过一本书《高效能人士的七个习惯》（想了解的同学，自己豆瓣搜下），其中讲到做人非常重要的一个逻辑&lt;strong&gt;「以终为始」&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;主要是告诉我们，做人需要以&lt;strong&gt;原则为中心&lt;/strong&gt;，不要被事件、表象所左右，需要有做人的原则，这个原则应该是稳定的，指引我们人生的。&lt;/p&gt;&lt;h2&gt;团队&lt;/h2&gt;&lt;p&gt;其实，管理团队也是一样的。作为Leader，需要甄别关键任务，带领团队在正确的方向上持续前进。所以，也需要&lt;strong&gt;「以终为始」&lt;/strong&gt;，找到适合研发团队的稳定的原则。然后，已一个稳定的结构化方式进行输出，围绕原则进行产品能力、团队能力的提升，持续进步。&lt;/p&gt;&lt;h1&gt;指北针&lt;/h1&gt;&lt;hr/&gt;&lt;p&gt;团队工作的「指北针」，指导团队的工作决策。&lt;/p&gt;&lt;p&gt;我们应该遵循「以终为始」的原则，为工作中的各种「选择」、「决策」，提供稳定的结构化的思考框架和工作框架。&lt;/p&gt;&lt;p&gt;「指北针」核心存在的意义就在于此。&lt;/p&gt;&lt;h2&gt;组成&lt;/h2&gt;&lt;h3&gt;&lt;strong&gt;&lt;strong&gt;研发效能指标&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;❗ 目的：「持续快速交付价值的能力」是效能改进的核心目标。&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;指标项&lt;/td&gt;&lt;td&gt;指标子项&lt;/td&gt;&lt;td&gt;说明&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;交付吞吐量&lt;/td&gt;&lt;td&gt;单位时间交付的版本数量&lt;/td&gt;&lt;td&gt;1个月或1个季度内，交付的各个版本的数量（统计意义上看趋势）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;需求响应时间&lt;/td&gt;&lt;td&gt;交付周期&lt;/td&gt;&lt;td&gt;需求启动到发布上线的平均时长&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;研发周期&lt;/td&gt;&lt;td&gt;编码开始到发布上线的平均时长&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;交付质量&lt;/td&gt;&lt;td&gt;单位故事点 / 功能点Bug数量&lt;/td&gt;&lt;td&gt;针对不同类型迭代计算方式不一样&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;单位时间修复的线上问题数量&lt;/td&gt;&lt;td&gt;1个月或1个季度内，修复的线上问题数量&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;持续发布能力&lt;/td&gt;&lt;td&gt;发布频率&lt;/td&gt;&lt;td&gt;1个月或1个季度内，发布次数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;发布时间&lt;/td&gt;&lt;td&gt;从合并代码完成，到发布到线上的平均时长&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;strong&gt;系统可用性指标&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;❗ 目的：全面体现系统的健康程度，构建SLI、SLO，给用户提供极高的稳定性和可用性。&lt;/p&gt;&lt;p&gt;依据谷歌SRE理论，通过SLI、SLO、SLA，进行系统健康程度的观测&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;SLI&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;SLO&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;SLA&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;工作逻辑&lt;/h1&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;❗ 我们团队负责的是一个SaaS产品，所以针对我们团队的工作逻辑，进行了下面的结构化抽象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jq6sJhMhoXWuFbqUdR33kOdn1hCAPJJTFoGiacSKBZ4rEUq9pSCbuibJ0VuPIyaFL0m7mYj8rg5YIaefCBgfdMTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1&gt;研发能力分层&lt;/h1&gt;&lt;hr/&gt;&lt;p&gt;目前等级：&lt;strong&gt;Poor（不好）&lt;/strong&gt;、&lt;strong&gt;Fair（凑合）&lt;/strong&gt;、&lt;strong&gt;Average（中等）&lt;/strong&gt;、&lt;strong&gt;Good（不错）&lt;/strong&gt;、&lt;strong&gt;NB（牛XX）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jq6sJhMhoXWuFbqUdR33kOdn1hCAPJJT3dCXcVJ4yHFDrYvJIMujeS5WuX0vbUo7HBXUJnMsHDVK23TLI0l9icw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1&gt;收获&lt;/h1&gt;&lt;hr/&gt;&lt;p&gt;目前，我们这个抽象的结构化工作逻辑，已经持续了一段时间，产生了一些效果，比如&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;在规划上，我们有了稳定的结构，可以持续改进某个方面的能力&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;在目标上，团队清楚未来2个季度的整体规划&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;在决策上，我们会依据「结构化」「原则」进行关键任务的甄别&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>63d6aa2dff65c1b674c7444e677335b6</guid>
<title>Docker + WebAssembly 集成简介</title>
<link>https://toutiao.io/k/duazmjs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Docker+Wasm&lt;/code&gt; 的技术预览版现在已经发布了，Wasm 最近引起了很多轰动，该功能将使你更容易快速构建针对 Wasm 运行时的应用程序。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/z9BgVMEm7YtOtNjSN8BxVibsGN8H3SHN6nBNq59gpPicuzybFS8PAOrWsicQPbeeZ69BOgia5jLWouYN4ianHRMdIiaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为本次发布的一部分，我们也很高兴地宣布 Docker 将作为投票成员加入&lt;span&gt;字节码联盟&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，字节码联盟是一个非营利组织，致力于在 WebAssembly 和 WebAssembly 系统接口（WASI）等标准的基础上，创建安全的新软件基础。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是 Wasm?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;WebAssembly&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，通常简称为 Wasm，是一种相对较新的技术，它允许你编译用 40 多种语言（包括 Rust、C、C++、JavaScript 和 Golang）编写的应用程序代码，并在沙盒环境中运行它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最初的用例主要是在 Web 浏览器中运行本地代码，例如 Figma、AutoCAD 和 Photoshop。而实际上，fastq.bio 将其基于 Web 的 DNA 序列质量分析仪转换为 Wasm 时，速度提高了 20 倍。迪士尼在 Wasm 之上构建了他们的 Disney+ 应用程序开发工具包。浏览器的好处是显而易见的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是由于 WebAssembly 系统接口（WASI）的存在，Wasm 正在迅速向浏览器之外扩展，Vercel、Fastly、Shopify 和 Cloudflare 等公司支持使用 Wasm 在边缘运行代码，而 Fermyon 正在构建一个平台，以在云上运行 Wasm 微服务。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么是 Docker？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Docker，我们的目标是通过克服应用程序开发的复杂性，来帮助开发人员将他们的想法变为现实。无论底层技术如何，我们都努力使构建、共享和运行你的应用程序变得更容易。通过让所有人都可以使用容器，我们证明了我们有能力让开发者的生活更轻松，并被公认为是第一大最受喜爱的开发者工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将 Wasm 视为 &lt;span&gt;Linux 容器的补充技术&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;，开发人员可以根据使用情况选择使用哪种技术（或两者都使用！）。随着社区探索 Wasm 的可能性，我们希望帮助使 Wasm 应用程序更容易开发、构建和运行，使用你所熟悉和喜爱的经验和工具。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何获取预览版？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你是否已经准备好开始来亲自尝试了吗？很好！但在此之前，你需要记住几个注意事项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;重要事项 #1&lt;/strong&gt;：这是 Docker Desktop 的技术预览版本，可能无法按预期工作，请务必在继续之前备份你的容器和镜像。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;重要事项 #2&lt;/strong&gt;：该预览版启用了 containerd 镜像存储，并且不能被禁用。如果您当前未使用 containerd 镜像存储，则将无法访问预先存在的镜像和容器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以在下面下载 Docker Desktop 的技术预览版本：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;macOS Apple Silicon&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;macOS Intel&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Windows AMD64&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux Arm64 (&lt;span&gt;deb&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux AMD64 (&lt;span&gt;deb&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;, &lt;span&gt;rpm&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;, &lt;span&gt;tar&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;是否有一些限制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的！这是一个早期的技术预览版本，我们仍在努力使体验尽可能流畅，但这里有一些你应该注意的事情：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当中断时，Docker Compose 可能无法干净退出&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;解决方法：通过向 docker-compose 进程发送 &lt;code&gt;SIGKILL（killall -9 docker-compose）&lt;/code&gt;来清理它们&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;推送到 Hub 可能会出现错误，类似于这样的错误信息 &lt;code&gt;server message: insufficient_scope: authorization failed&lt;/code&gt;，即使在使用 Docker Desktop 登录后也是如此&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;解决方法：在 CLI 中运行 &lt;code&gt;docker login&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们需要提醒你，由于这是一个技术预览，事情可能会很快发生变化，但这是它目前的工作方式。&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1666946880410&quot; data-category_id_list=&quot;1|16|17|2|21|24|28|29|31|35|36|37|39|41|42|43|46|47|48|5|50|51|55|56|57|58|59|6|60|61|62|63|64|65|66|7|8&quot; data-id=&quot;1666946880410&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;我们正在利用我们最近的工作，将镜像管理迁移到 containerd，因为它提供了使用与 OCI 兼容的工件和 containerd shims 的能力。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们与 &lt;span&gt;WasmEdge&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt; 合作创建了一个 containerd shim。此 shim 从 OCI 工件中提取 Wasm 模块并使用 WasmEdge 运行时运行它。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们添加了对声明 Wasm 运行时的支持，这将允许使用这个新的 shim。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5994236311239193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtOtNjSN8BxVibsGN8H3SHN6Z8Ra79ohLjUoHty3wb2vGBHH4H95UdHOg4jSIY4nroHQPiahWByAibZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用 &lt;code&gt;docker run&lt;/code&gt; 启动 Wasm 应用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装预览版后，我们可以运行以下命令来启动一个 Wasm 示例应用程序：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker run -dp 8080:8080 --name=wasm-example --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm32 michaelirwin244/wasm-example&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到有一些参数可能不是很熟悉，让我们来解释下它们的作用。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--runtime=io.containerd.wasmedge.v1&lt;/code&gt; - 这会通知 Docker 引擎，我们要使用 Wasm containerd shim，而不是标准的 Linux 容器运行时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--platform=wasi/wasm32&lt;/code&gt; – 这指定了我们要使用的镜像的架构，通过利用 Wasm 架构，我们不需要为不同的架构构建单独的镜像，Wasm 运行时将做最后一步，将 Wasm 二进制文件转换为机器指令。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拉取镜像后，运行时读取镜像的 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 来定位并提取 Wasm 模块。然后该模块被加载到 Wasm 运行时中，启动并配置网络。现在我们的机器上运行了一个 Wasm 应用程序！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该示例应用是一个简单的 Web 服务器，它会显示 &lt;code&gt;Hello world！&lt;/code&gt; 并将数据回显给我们，为了验证它是否正常工作，让我们首先查看日志。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker logs wasm-example&lt;br/&gt;Server is now running&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过打开 &lt;code&gt;http://localhost:8080&lt;/code&gt; 或使用 curl 来获取 &lt;code&gt;Hello world&lt;/code&gt; 消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ curl localhost:8080&lt;br/&gt;Hello world from Rust running with Wasm! Send POST data to /&lt;span&gt;echo&lt;/span&gt; to have it echoed back to you&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将数据发送到 echo 端点，我们可以使用 curl 命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ curl localhost:8080/&lt;span&gt;echo&lt;/span&gt; -d &lt;span&gt;&#x27;{&quot;message&quot;:&quot;Hi there&quot;}&#x27;&lt;/span&gt; -H &lt;span&gt;&quot;Content-type: application/json&quot;&lt;/span&gt;&lt;br/&gt;{&lt;span&gt;&quot;message&quot;&lt;/span&gt;:&lt;span&gt;&quot;Hi there&quot;&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要删除应用程序，可以像执行任何其他 Docker 服务一样删除它：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker rm -f wasm-example&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的集成意味着你可以在 Linux 容器旁边运行 Wasm 应用程序（甚至使用 Compose）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用 Compose 启动 Wasm 应用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的我们也可以使用 Docker Compose 来运行 Wasm 应用，如下所示的 Compose 文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;services:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;app:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;michaelirwin244/wasm-example&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;platform:&lt;/span&gt; &lt;span&gt;wasi/wasm32&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;runtime:&lt;/span&gt; &lt;span&gt;io.container.wasmedge.v1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;8080&lt;/span&gt;&lt;span&gt;:8080&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后使用如下所示的命令即可启动该应用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker compose up&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用 Wasm 运行多服务应用程序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络的工作方式与你对 Linux 容器的预期相同，让你可以灵活地将 Wasm 应用与其他容器化工作负载（例如数据库）组合在单个应用程序堆栈中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以下示例中，Wasm 应用程序利用了在容器中运行的 MariaDB 数据库。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Clone 示例仓&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ git &lt;span&gt;clone&lt;/span&gt; https://github.com/second-state/microservice-rust-mysql.git&lt;br/&gt;Cloning into &lt;span&gt;&#x27;microservice-rust-mysql&#x27;&lt;/span&gt;...&lt;br/&gt;remote: Enumerating objects: 75, &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;remote: Counting objects: 100% (75/75), &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;remote: Compressing objects: 100% (42/42), &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;remote: Total 75 (delta 29), reused 48 (delta 14), pack-reused 0&lt;br/&gt;Receiving objects: 100% (75/75), 19.09 KiB | 1.74 MiB/s, &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;Resolving deltas: 100% (29/29), &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;导航到项目根目录并使用 Docker Compose 启动项目。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ &lt;span&gt;cd&lt;/span&gt; microservice-rust-mysql&lt;br/&gt;$ docker compose up&lt;br/&gt; [+] Running 0/1&lt;br/&gt; ⠿ server Warning                                                                                                  0.4s&lt;br/&gt; [+] Building 4.8s (13/15)&lt;br/&gt; ...&lt;br/&gt; microservice-rust-mysql-db-1      | 2022-10-19 19:54:45 0 [Note] mariadbd: ready &lt;span&gt;for&lt;/span&gt; connections.&lt;br/&gt; microservice-rust-mysql-db-1      | Version: &lt;span&gt;&#x27;10.9.3-MariaDB-1:10.9.3+maria~ubu2204&#x27;&lt;/span&gt;  socket: &lt;span&gt;&#x27;/run/mysqld/mysqld.sock&#x27;&lt;/span&gt;  port: 3306  mariadb.org binary distribution&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在另一个终端中，我们可以看到创建的 Wasm 镜像。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker images&lt;br/&gt; REPOSITORY   TAG       IMAGE ID       CREATED         SIZE&lt;br/&gt; server       latest    2c798ddecfa1   2 minutes ago   3MB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;检查镜像显示镜像是否具有 &lt;code&gt;wasi/wasm32&lt;/code&gt; 平台，操作系统和架构的组合。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker image inspect server | grep -A 3 &lt;span&gt;&quot;Architecture&quot;&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;&quot;Architecture&quot;&lt;/span&gt;: &lt;span&gt;&quot;wasm32&quot;&lt;/span&gt;,&lt;br/&gt;         &lt;span&gt;&quot;Os&quot;&lt;/span&gt;: &lt;span&gt;&quot;wasi&quot;&lt;/span&gt;,&lt;br/&gt;         &lt;span&gt;&quot;Size&quot;&lt;/span&gt;: 3001146,&lt;br/&gt;         &lt;span&gt;&quot;VirtualSize&quot;&lt;/span&gt;: 3001146,&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在 &lt;code&gt;http://localhost:8090&lt;/code&gt; 打开网站并创建一些示例订单，所有这些都是与 Wasm 服务器交互。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;完成后，在你启动应用程序的终端中按 Ctrl+C 将所有内容删除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;构建和推送 Wasm 模块&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建一个构建 Wasm 应用程序的 Dockerfile，当然这取决于你使用的语言。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在 Dockerfile 的单独阶段中，提取模块并将其设置为 &lt;code&gt;ENTRYPOINT&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;FROM scratch&lt;br/&gt; COPY --from=build /build/hello_world.wasm /hello_world.wasm&lt;br/&gt; ENTRYPOINT [ &lt;span&gt;&quot;hello_world.wasm&quot;&lt;/span&gt; ]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;构建并推送指定 &lt;code&gt;wasi/wasm32&lt;/code&gt; 架构的镜像，Buildx 使这在单个命令中变得容易。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker buildx build --platform wasi/wasm32 -t username/hello-world .&lt;br/&gt; ...&lt;br/&gt; =&amp;gt; exporting to image                                                                             0.0s&lt;br/&gt; =&amp;gt; =&amp;gt; exporting layers                                                                            0.0s&lt;br/&gt; =&amp;gt; =&amp;gt; exporting manifest sha256:2ca02b5be86607511da8dc688234a5a00ab4d58294ab9f6beaba48ab3ba8de56  0.0s&lt;br/&gt; =&amp;gt; =&amp;gt; exporting config sha256:a45b465c3b6760a1a9fd2eda9112bc7e3169c9722bf9e77cf8c20b37295f954b    0.0s&lt;br/&gt; =&amp;gt; =&amp;gt; naming to docker.io/username/hello-world:latest                                            0.0s&lt;br/&gt; =&amp;gt; =&amp;gt; unpacking to docker.io/username/hello-world:latest                                         0.0s&lt;br/&gt;docker push username/hello-world&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Wasm 和 Docker 的下一步&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wasm 正在快速成长和发展，包括探索如何支持多线程、垃圾收集等。还有许多仍待解决的问题，包括缩短开发人员反馈循环和可能的生产路径。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，请自己尝试一下，然后让我们知道你对&lt;span&gt;路线图&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;的想法或反馈。我们很乐意听取您的意见！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考链接&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://www.docker.com/blog/docker-wasm-technical-preview/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://docs.docker.com/desktop/wasm/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;字节码联盟: &lt;span&gt;https://bytecodealliance.org/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;WebAssembly: &lt;span&gt;https://webassembly.org/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Linux 容器的补充技术: &lt;span&gt;https://www.docker.com/blog/why-containers-and-webassembly-work-well-together/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;macOS Apple Silicon: &lt;span&gt;https://dockr.ly/3sf56vH&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;macOS Intel: &lt;span&gt;https://dockr.ly/3VF6uFB&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;Windows AMD64: &lt;span&gt;https://dockr.ly/3ShlsP0&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;Linux Arm64 deb: &lt;span&gt;https://dockr.ly/3TDcjRV&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;Linux AMD64 deb: &lt;span&gt;https://dockr.ly/3TgpWH8&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Linux AMD64 rpm: &lt;span&gt;https://dockr.ly/3eG6Mvp&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;Linux AMD64 tar: &lt;span&gt;https://dockr.ly/3yUhdCk&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;WasmEdge: &lt;span&gt;https://wasmedge.org/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;路线图: &lt;span&gt;https://github.com/docker/roadmap/issues/426&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>389e99f077e364ea195de0f330507c68</guid>
<title>iOS OOM 问题分析与优化实践</title>
<link>https://toutiao.io/k/vxf1dza</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一、iOS内存机制介绍&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二、&lt;span&gt;OOM介绍&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、&lt;/span&gt;&lt;span&gt;OOM常见原因&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;四、&lt;span&gt;内存泄漏监控&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五、内存异常增长捕捉&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;六、优化成果&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;七、展望&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;在iOS开发过程或者用户反馈中，可能会经常看到这样的情况，用着用着就崩溃了，而在后台查看崩溃栈的时候，找不到崩溃日志。其实这大多数的可能是系统产生了低内存崩溃，也就是OOM；所以内存问题一直是导致系统崩溃的重要原因，绝大部分的原因可能是因为开发者在开发过程中往往会忽视内存问题，我们经常专注于使用而忘了深究，在进行深入之前我们先了解一下iOS的内存机制。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一. iOS内存机制介绍&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;虚拟内存&lt;/p&gt;&lt;p&gt;iOS 和大多数桌面操作系统一样，使用了虚拟内存机制，保护了每个进程的地址空间、简化了内存管理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单应用可用内存有限&lt;/p&gt;&lt;p&gt;对于移动设备来说，受限于客观条件，物理内存容量本身就小，而 iPhone 的 RAM 本身也是偏小的，例如 iPhone XS Max 也才有 4GB，横向对比小米 9 可达 8GB，华为 P30 也是 8GB。根据 List of iPhones 可以查看历代 iPhone 的内存大小。但是与其他手机不同的是，iOS 系统给每个进程分配的虚拟内存空间非常大。据官方文档的说法，iOS 为每个 32 位的进程都会提供高达 4GB 的可寻址空间，这已经算非常大的了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;没有内存交换机制&lt;/p&gt;&lt;p&gt;虚拟内存远大于物理内存，那如果物理内存不够用了该怎么办呢？例如其他桌面操作系统（比如 OS X）有内存交换机制，在需要时能将物理内存中的一部分内容交换到硬盘上去，利用硬盘空间拓展内存空间，这也是使用虚拟内存带来的优势之一。&lt;span&gt;然而 iOS 并不支持内存交换机制，大多数移动设备都不支持内存交换机制。&lt;/span&gt;&lt;span&gt;移动设备上的大容量存储器通常是闪存（Flash），它的读写速度远远小于电脑所使用的硬盘，这就导致了在移动设备就算使用内存交换机制也并不能提升性能。&lt;/span&gt;&lt;span&gt;其次，移动设备的容量本身就经常短缺、闪存的读写寿命也是有限的，所以这种情况下还拿闪存来做内存交换，就有点太过奢侈了。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内存警告&lt;/p&gt;&lt;p&gt;当内存不够用时，iOS 的处理是会发出内存警告，告知进程去清理自己的内存。iOS 上一个进程就对应一个 app。代码中的 didReceiveMemoryWarning() 方法就是在内存警告发生时被触发，app 应该去清理一些不必要的内存，来释放一定的空间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;OOM 崩溃&lt;/p&gt;&lt;p&gt;如果 App 在发生了内存警告，并进行了清理之后，物理内存还是不够用了，那么就会发生 OOM 崩溃，也就是 Out of Memory Crash。在 stack overflow 上，有人对单个 app 能够使用的最大内存做了统计：iOS app max memory budget。以 iPhone XS Max 为例，总共的可用内存是 3735 MB（比硬件大小小一些，因为系统本身也会消耗一部分内存），而单个 app 可用内存达到 2039 MB，达到了 55%。当 app 使用的内存超过这个临界值，就会发生 OOM 崩溃。可以看出，单个 app 的可用物理内存实际上还是很大的，要发生 OOM 崩溃，绝大多数情况下都是程序本身出了问题，分析了iOS 内存机制的特点之后，我们能够意识到合理控制 app 使用的内存是非常重要的一件事。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二. OOM 介绍&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;造成OOM的直接原因是iOS的 Jetsam 机制造成的，在Apple的中解释了具体的运行情况：当内存不足时，系统向当前运行中的App发起applicationDidReceiveMemoryWarning(_ application: UIApplication) 调用和 UIApplication.didReceiveMemoryWarningNotification 通知，如果内存仍然不够用则会杀掉一些后台进程，如果仍然吃紧就会杀掉当前App。&lt;/section&gt;&lt;section&gt;OOM 分为两大类，Foreground OOM / Background OOM，简写为 FOOM 以及 BOOM。而其中 FOOM 是指 app 在前台时由于消耗内存过大，而被系统杀死，直接表现为 crash。BOOM则是由于当前设备在后台中，比如用户正在使用拍照功能进行大量的拍照和图像特效时，此时内存使用量大幅度增加，为了保证正在进行的进程有足够的内存可供使用，系统会根据优先级以及内存占用会关闭一些进程。以下内容主要是围绕FOOM介绍。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三. OOM 常见原因&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;持久化对象&lt;/p&gt;&lt;p&gt;关于持久化对象这里主要指的是类似于App进入后在主界面永远不会释放的对象，以及某些单例对象。基本上不kill整个app是无法释放的，但是如果因为设计原因又在首页有大量这样的持久对象那么OOM的问题理论上更加难以解决，因为此时要修改整个App结构几乎是不可能的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;UIWebview 缺陷&lt;/p&gt;&lt;p&gt;无论是打开网页，还是执行一段简单的 js 代码， UIWebView 都会占用大量内存，同时旧版本的 css 动画也会导致大 量问题，所以最好使用 WKWebView 。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内存泄漏&lt;/p&gt;&lt;p&gt;内存泄漏造成内存被持久占用无法释放，对OOM的影响可大可小，多数情况下并非泄漏的类直接造成大内存占用，而是无法释放的类引用了比较大的资源造成连锁反应最终形成OOM。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内存异常增长&lt;/p&gt;&lt;p&gt;缩放、绘制分辨率高的大图片，播放 gif 图，以及渲染本身 size 过大的视图（例如超长的 TextView）等，都会占用大量内存，有时会不恰当的操作会造成内存的异常增长出现OOM，尽管这部分内存可能一会就被释放掉，并不会长久的占用内存， 可能在解析、渲染的过程中发生 OOM。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本章内容主要从以下两个层面监控iOS OOM问题&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四. 内存泄漏监控&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏（memory leak）：是指申请的内存空间使用完毕之后未回收，
一次内存泄&lt;span&gt;漏&lt;/span&gt;危害可以忽略，但若一直泄漏，无论有多少内存，迟早都会被占用光，最终导致程序crash。（因此，开发中我们要尽量避免内存泄漏的出现）&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;项目现状&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;需要手动去统计泄漏信息，缺少自动整合&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存泄漏人工排查，难发现、发现晚&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;仅限于开发环境的排查，针对线上的泄漏问题难以监控和捕捉&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检测内存泄漏的方法&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;工具检测，使用 Xcode 自带的工具进行检测&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动化检测，自动检测出发生内存泄漏的地方，并打印出对应的信息&lt;/section&gt;&lt;section&gt;选择 Xcode -&amp;gt; Product -&amp;gt; Profile，选择 Leaks&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4504830917874396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUWQX1xF5SQzZuAmKpyAs0xicIgibM2EvETicKib3mO9aVKyetS8mY4QibPd7rBRdLJlUPKAmqVKo4ia3VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选中 Leaks，在 Leaks 所在栏中选择 CallTree&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Call Tree 会给我们大概的位置，这个时候需要缩小范围、筛选数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;点击下方的 CallTree ，发现有这几个筛选项：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Separate by Thread ：按线程分开做分析，这样更容易揪出那些吃资源的问题线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Invert Call Tree ：反向输出调用树。把调用层级最深的方法显示在最上面，更容易找到最耗时的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Hide System Libraries：隐藏系统库文件。过滤掉各种系统调用，只显示自己的代码调用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Flattern Recursion：拼合递归。将同一递归函数产生的多条堆栈（因为递归函数会调用自己）合并为一条。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;工具检测的不足：&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;虽然 Xcode 的 Instrucment 提供了 Leaks 和 Allocations 工具能精准地定位内存泄漏问题，但是这种方式相对比较繁琐，需要开发人员频繁地去操作应用界面，以触发泄漏场景，所以 Leaks 和 Allocations 更加适合定期组织的大排查，作为监测手段，则显得笨重&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只能统计开发模式下的泄漏问题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方案选型&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;对于内存泄漏的监测，很显然Xcode自带工具在发现泄漏问题的过程中还是需要人工不断去干预，不能达到一个自动化监测的状态，所以通过结合项目本身的需求以及后期的可扩展，我们选用业内已经有了两款成熟的开源工具为 MLeaksFinder + FBRetainCycleDetector组合，并在组合的基础上做更适合当前需求的二次开发，更高效的帮助我们发现并解决项目中出现的泄漏问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MLeaksFinder&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;MLeaksFinder 是 WeRead团队开源的一款检测 iOS 内存泄漏的框架，对代码没有侵入性，而且其使用非常简单，只需要引入项目中，如果有内存泄漏，2秒后自动弹出 alert 来显示捕捉的信息。它默认只检测应用里 UIViewController 和 UIView 对象的泄漏情况。因为一般应用里内存泄漏影响最严重的就是这两种内存占用比较高的对象，它也可以在代码里设置扩展以检测其他类型的对象泄漏情况。&lt;/section&gt;&lt;section&gt;一般情况下，当一个 UIViewController 被 pop 或者 dismiss 掉后，它的 view 和 view 的subview等也会很快地被释放掉，除非我们把它设置为单例或者还有强引用指向它。&lt;span&gt;MLeaksFinder 的做法就是根据这种基本情况，在一个 UIViewController 被 pop 或者 dismiss 掉2秒后，看看它的 view 和 view 的 subview 等是否还存在，如果还存在，就意味着有可能有内存泄漏发生。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;具体的方法是，为基类 NSObject 添加一个方法 -willDealloc 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(2秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接弹框提醒该对象可能存在内存泄漏。&lt;/span&gt;&lt;/section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.361353711790393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUWQX1xF5SQzZuAmKpyAs0x1ZdicraKd5E9PoKScNE8SQ6wrp321LtHJsDZgQOsv0YmMAWMtw86xzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;916&quot;/&gt;&lt;section&gt;MLeaksFinder 虽然帮我们找到了内存泄漏的对象，但是我们具体不知道引起循环引用的链条，还要自己去看代码进行排查，这是很浪费时间的。因为内存泄漏一般都是循环引用导致的。&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;FBRetainCycleDetector&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;FBRetainCycleDetector是FaceBook开源的用于检测强引用循环的工具。默认是在DEBUG环境中启用，当然你也可以通过设置RETAIN_CYCLE_DETECTOR_ENABLED以始终开启。使用这个工具可以传入应用内存里的任意一个 Objective-C 对象，FBRetainCycleDetector 会查找以该对象为根节点的强引用树中有没有循环引用。&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;检测核心代码&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8801711840228246&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUWQX1xF5SQzZuAmKpyAs0xKPom0d92Xh6ZFR43tibZPNBkt2wUJiapJWgq7NiarzA6gKha3eguibmaIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;&lt;/figure&gt;&lt;section&gt;这两个工具一起搭配使用很容易排查出内存的问题，先用 MLeaksFinder 找出泄漏的对象，然后再用 FBRetainCycleDetector 检测该对象有没有循环引用，如果有，根据找出来的循环引用链条去查看修改代码。&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方案设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为当前所支持的功能并不完全能解决项目的现状问题，所以需要进行拓展&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;信息收集&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每一条泄漏数据是转换成唯一的key值，所有的操作都针对于在当前key值下进行存储、更新&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9475524475524476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUWQX1xF5SQzZuAmKpyAs0xUu4QEFDIjicwJBic3vEbib3u5GWibUxviaicSYgXW3Gt5ZXJbjE4YFd2Xznw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;572&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在发生泄漏问题的时候进行数据存储和转换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4522111269614836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUWQX1xF5SQzZuAmKpyAs0xldqT6nWibvWiaZRTPXek8Mw1d0FSEm7RyZUMLBaYsicp8WYw9XOu0jHhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;本地维护文件格式如下，记录了当前类、泄漏周期以及发生次数，最终通过该文件数据进行格式转换后导出和上传&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9457236842105263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUWQX1xF5SQzZuAmKpyAs0xhYqqVAg6bnKEuqCSvWvsmk37SicbTKicAByC64F0jicdpB2iadfaX8ocvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题归类&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;本地plist统计文件的可视化导出，直观发现问题并归类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实时监控&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;支持线上统计文件的上传功能，分析线上泄漏问题，进行分类并解决&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;内存泄露这种问题，最好在应用初期就开始着手监测和解决，否则当应用功能代码逐渐增多后，回过头来处理这种问题费时费力，还是比较麻烦的。&lt;/section&gt;&lt;section&gt;基于 MLeaksFinder 和  FBRetainCycleDetector监测工具的基础上，结合团队业务情况，进行了一些的改造，添加了适用于当前项目的一些功能，解决了当前项目的不足，做到了自动化的监控和收集，优化了部分有问题的代码，在一定程度上提升了工具的可用性。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五. 内存异常增长捕捉&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;日常开发中方法使用不当或者异常大图的渲染都会产生内存异常增长的问题，而带来的影响轻则造成卡顿，重则直接发生崩溃&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;FOOM 因为用户的感知更明显，所以对用户的体验的伤害更大，导致用户流失的话对业务损失更大，所以更有必要建立线上的监控手段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存占用过高即使没导致 FOOM 也可能会导致其他应用 BOOM 的概率变大，导致应用重启，对用户来说，体验是非常糟糕的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;项目现状&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;bugly信息有限，并且当我们在调试阶段遇到这种崩溃的时候，从设备设置-&amp;gt;隐私-&amp;gt;分析与改进中是找不到普通类型的崩溃日志，所以难以定位产生问题的原因&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有线上监控OOM崩溃以及内存异常增长的的有效方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开发过程中没有提前预防的功能和措施&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;为了解决当前现状的问题，所以我们需要借助一些第三方的工具来辅助我们发现和收集内存异常增长的问题，形成一套完整的线上化监控方案；所以我们调研了业界比较流行的以下几个工具。&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Allocation&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;苹果官方提供的Allocation内存分析工具，在开发调试阶段，可以用Allocation详细分析App各模块内存占用。Allocation对App的内存监控比较全面，能监控到所有堆内存以及部分VM内存分配。&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;FBAllocationTracker&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;FBAllocationTracker是Facebook开源的内存分析工具，它的原理是用 Method Swizzling替换原本的alloc方法，这样可以在App运行时记录所有OC实例的分配信息，帮助App在运行阶段发现一些OC对象的异常增长问题。相比Allocation，FBAllocationTracker对App性能影响较低，可以在App中独立运行。&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;OOMDetector&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;OOMDetector是腾讯研发的一个内存监控组件。通过Hook系统底层的内存分配方法，能够记录到进程所有内存分配的堆栈信息，同时组件能够在对性能流畅度影响不大的情况下保证在App中独立运行，可以方便分析和监控线上用户的内存问题。&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;监控OOM，Dump引起爆内存的堆栈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大内存分配监控 监控单次大块内存分配，提供分配堆栈信息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Allocation&lt;/th&gt;&lt;th&gt;FBAllocationTracker&lt;/th&gt;&lt;th&gt;OOMDetector&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;使用场景&lt;/td&gt;&lt;td&gt;连接Mac用&lt;/td&gt;&lt;td&gt;App中独立运行&lt;/td&gt;&lt;td&gt;App中独立运行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;监控范围&lt;/td&gt;&lt;td&gt;所有内存对象&lt;/td&gt;&lt;td&gt;只监控OC对象&lt;/td&gt;&lt;td&gt;所有内存对象&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;性能影响&lt;/td&gt;&lt;td&gt;性能影响高&lt;/td&gt;&lt;td&gt;性能影响低&lt;/td&gt;&lt;td&gt;性能影响低&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方案选型&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;通过结合项目本身的需求以及工具的优缺点，选用方案为OOMDetector工具，除了对比的三个维度的优势外，该工具对堆栈的回溯进行了优化，耗时低于1us。&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方案设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;信息收集&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;记录每个页面的浏览轨迹，以及页面的内存消耗情况做自动统计，记录数据到本地文件，当发生OOM问题产生崩溃后，获取当前调用堆栈，进行数据重组，下次启动APP时进行上传操作。&lt;/p&gt;&lt;p&gt;目前针对于每个页面内存消耗情况，只是根据页面内存差值进行计算，后续会考虑多种因素（比如上一个页面的未完成操作导致的内存增长）再具体优化。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7018544935805991&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUWQX1xF5SQzZuAmKpyAs0xoq7zSZl34T7d9GGCgkkujuAgn7TQoXbsbLEYDKQMs3pI10yqNQeJKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实时监控&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;线上通过设置阈值，当超出阈值后，获取当前调用堆栈，存储到文件，下一次启动APP时进行上传操作。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1440185830429733&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUWQX1xF5SQzZuAmKpyAs0xmkltDvL0F8icMAtOlU9VYHDwMRnpd1CnQdtqBpNZ5OlRTbYJ0OQbVnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1722&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线下预防&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;debug模式下实时检测内存增长情况，如果当大于设定阈值的时候，需要进行异常提醒，能够在开发阶段就能避免一些内存异常增长的问题。&lt;/p&gt;&lt;p&gt;实时内存的更新&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5514285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUWQX1xF5SQzZuAmKpyAs0x6ycmrY8fUnbsy2PU492HI3Kw1gPdNsLLv3JV6Cb8ZcT5KraoHWQAMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;通过对以上两个工具的拓展开发，为了后期维护和接入，我们把两个工具整合成一个独立的模块，模块结构如下：&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9329268292682927&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUWQX1xF5SQzZuAmKpyAs0x3NMwdu1IUdibtL9rdGBL7KQ5iayXEr5CSU4Fo7iaiciahu9tLPaxGtu2Z5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;六. 优化成果&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8012170385395537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUWQX1xF5SQzZuAmKpyAs0xIiaj8GgHnqEQz0ibpt9j6WplOMU5S44u84KZ9Jz4SwId9kdJdxYXfLCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;493&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;解决了代码中内存泄漏的几类问题以及超大图片加载内存暴增的问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;输出了统一代码规范，跟版进行常态化的跟进&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对每个版本内存泄漏出现的概率减少60%&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单独抽离成SDK，其它App能够快速接入&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;七. 展望&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;会对更多产生异常崩溃的场景进行监控，例如卡死崩溃（watchdog），这类因为进程外的指令强制退出导致的异常，原有的监控原理是覆盖不到的，导致此类问题长时间被忽略，所以下一个优化方向是针对卡死崩溃的发现以及治理。&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMzg1ODMwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJXiceZGCcxwiaBWCsfyZjibdQfkhbOKqgNPJkHWNwibaGupDicA7sXCUs9jCM8lTeYaribatAd9NaibGBj3A/0?wx_fmt=png&quot; data-nickname=&quot;达达集团技术&quot; data-alias=&quot;dada-tech&quot; data-signature=&quot;分享达达集团大研发部在打磨产品、精进技术方面的心得体会，与极客们互相切磋、共同成长&quot; data-from=&quot;1&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>