<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>32a31475933efd5f22aa96143d4d3eae</guid>
<title>if 我是前端Leader，谈谈前端框架体系建设</title>
<link>https://toutiao.io/k/60knhfk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot; itemprop=&quot;articleBody&quot;&gt;
    &lt;p&gt;这期来聊一聊前端框架。&lt;/p&gt;
&lt;p&gt;“if 我是前端 Leader” 是我的一个文章系列，说说我人在其位，欲谋其职的一些点点滴滴感悟。跟前端 Leader 只有那么一丢丢关系，干货不多，但老少皆宜，不要被标题给唬住了。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章大纲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;



&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是框架&quot;&gt;&lt;a href=&quot;#什么是框架&quot; class=&quot;headerlink&quot; title=&quot;什么是框架?&quot;/&gt;什么是框架?&lt;/h2&gt;&lt;p&gt;这应该不是我第一次谈‘框架‘了。React 是一个框架吗？ Vue 是一个框架吗？ 严格来说不是，它们只是一个视图解决方案，这里面算得上是框架的估计只有 Angular。&lt;/p&gt;
&lt;p&gt;如果说后端框架围绕着&lt;code&gt;数据存储&lt;/code&gt;建立起来，那么前端框架的基础就是视图库，毕竟前端的本质工作就是视图。这是为什么前端生态圈一般是围绕着视图库展开的。所以说，&lt;strong&gt;前端框架的基础是‘视图’库&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果跟后端框架比起来，成熟的前端框架其实不多。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是框架？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;看个例子。打开 &lt;a href=&quot;https://umijs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UmiJS&lt;/a&gt;, 它对自己的描述是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;可插拔的企业级 react 应用框架&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键字是&lt;strong&gt;企业级&lt;/strong&gt;。什么是企业级，我自己也说不清楚。我只知道 React 没有说自己是企业级，Koa、Express 也没有，然而 &lt;a href=&quot;https://eggjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Eggjs&lt;/a&gt; 和 &lt;a href=&quot;https://umijs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Umijs&lt;/a&gt; 都说它们是&lt;strong&gt;企业级框架&lt;/strong&gt;；Angular 通常也常常跟企业级这个概念联系在一起；语言层面有 Java。&lt;/p&gt;
&lt;p&gt;对比一下他们就知道了，我觉得企业级表示它是 &lt;strong&gt;面向企业生产，目的是提高企业的生产力&lt;/strong&gt;。总结一下有以下特点：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是高效 + 成熟方案的整合&lt;/li&gt;
&lt;li&gt;关注生产的整个链路，而不是某个环节&lt;/li&gt;
&lt;li&gt;有更强的约束和限制&lt;/li&gt;
&lt;li&gt;更严苛的要求。性能、可扩展性(以应对不同的需求)、健壮性、稳定性、可用性、安全性&lt;/li&gt;
&lt;li&gt;标准化&lt;/li&gt;
&lt;li&gt;经过生产环境验证, 有较多用例保证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;归根到底还是成本问题，框架最本质的目的就是要减低各类成本。让更少的人可以做更多的事情、且能保证质量、降低维护成本，且能保证不断优化和演进。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给个定义吧。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前端框架体系的建立离不开前端工程化成熟和‘最佳实践‘的沉淀’。你可以认为框架就是一个整合的方案，提供一个前端‘最佳‘的组合配置。开发者需要做的就是在这个框架约束下填充自己业务代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;效率提升。让开发者关注业务开发&lt;/li&gt;
&lt;li&gt;学习成本降低。框架封装了很多底层复杂性&lt;/li&gt;
&lt;li&gt;更强的约束。所有动作必须按照框架规定的执行, 避免干坏事、蠢事。更强的约束也意味着框架集成度更高、框架内部可以做更多事情，但灵活性也更低。&lt;/li&gt;
&lt;li&gt;产品质量。框架内部会自动处理很多事情，例如性能优化、安全性处理&lt;/li&gt;
&lt;li&gt;可维护性。所有项目都按照一致的、标准化的规范开发，升级迭代方便。这一点对团队项目的可维护性很重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;坏处:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;灵活性。不能满足所有人的需求，最佳实践这种东西有点武断&lt;/li&gt;
&lt;li&gt;滞后性。具体方案可能会滞后。&lt;/li&gt;
&lt;li&gt;大而全。对于某些项目可能过重。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前端‘框架’的发展历程&quot;&gt;&lt;a href=&quot;#前端‘框架’的发展历程&quot; class=&quot;headerlink&quot; title=&quot;前端‘框架’的发展历程&quot;/&gt;前端‘框架’的发展历程&lt;/h2&gt;&lt;h3 id=&quot;前端框架启蒙阶段&quot;&gt;&lt;a href=&quot;#前端框架启蒙阶段&quot; class=&quot;headerlink&quot; title=&quot;前端框架启蒙阶段&quot;/&gt;前端框架启蒙阶段&lt;/h3&gt;&lt;p&gt;在 React、Vue 流行之前已经有许多‘前端框架‘，例如 Angular、Ember、Backbone…&lt;/p&gt;
&lt;p&gt;它们大部分都受到后端框架的启发，因为当年也正是后端框架最火的时候，例如 Rails。所以在它们身上会看到很多后端框架的影子。&lt;/p&gt;
&lt;p&gt;但是很多后端的开发模式，在前端有点吃不开。更本质的原因是前端工程化还不成熟，基础相对薄弱，难以支撑上层建筑的发展。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;野蛮生长期&quot;&gt;&lt;a href=&quot;#野蛮生长期&quot; class=&quot;headerlink&quot; title=&quot;野蛮生长期&quot;/&gt;野蛮生长期&lt;/h3&gt;&lt;p&gt;随着 NodeJS 的普及、JavaScript 语言日益强大，前端工程化逐步深化。 React 这类视图库出来后，很多东西被打碎重构, 正所谓百花齐放，欣欣向荣。&lt;/p&gt;
&lt;p&gt;围绕着三大视图库各种各样的库百花齐放，前端也拓展到了浏览器以外的领域。人们都乐于造轮子，使用最新的技术。&lt;/p&gt;
&lt;p&gt;由于发展得太快，所谓的框架/最佳实践很难被广泛接受，或者很容易就过时了，每个人每个团队更热衷于创造自己的组合方案，往往也只限于团队内部。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;前端框架整合期&quot;&gt;&lt;a href=&quot;#前端框架整合期&quot; class=&quot;headerlink&quot; title=&quot;前端框架整合期&quot;/&gt;前端框架整合期&lt;/h3&gt;&lt;p&gt;几乎每个团队都会重复走这样的路子：&lt;em&gt;稳定技术栈、工程化建设、基础库/组件库建设、沉淀自己的最佳实践&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;团队没有一定的工程能力和资源其实是很难将这些零散的实践体系化、有机地粘合起来, 长期有效的维护更新更是一件难事, 半途而废的居多。&lt;/p&gt;
&lt;p&gt;现在前端发展开始进入平稳阶段。所以大一统的前端‘框架’再一次进入人们的视野。就像 Umi 的作者 &lt;a href=&quot;https://www.zhihu.com/people/chenchengpro/activities&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;云谦&lt;/a&gt; 说的: &lt;em&gt;现在是工业化时代, 框架像是一个魔法球，把各种技术栈吸到一起，加工后吐给用户，以此来支撑业务&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fe-framework/bigfish.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;em&gt;上图来源于&amp;lt;蚂蚁前端研发最佳实践&amp;gt; PPT&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;框架就是将各种技术栈方案、基础设施整合起来, 暴露标准的、一致性的接口, 让开发者专注业务开发。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;现有的框架都有什么？&quot;&gt;&lt;a href=&quot;#现有的框架都有什么？&quot; class=&quot;headerlink&quot; title=&quot;现有的框架都有什么？&quot;/&gt;现有的框架都有什么？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一个前端开发框架应该涵盖前端开发链路的各个环节。为约束和简化业务开发、提供有用的指导&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看看现有‘前端框架‘吧，现在社区上比较流行的‘框架’有 Angular、Next.js、Nuxt、Umi。我们横向对比一下它们的一些特性，发现基本上包含这些东西：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fe-framework/framework-content.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;跟衣服的标准码一样。社区开源的都是通用类型框架，可以预知的是它们没有办法满足所有团队的要求。我们往往需要根据自己业务情况量身定制框架。&lt;/p&gt;
&lt;p&gt;为了应对这些需求，不同的框架也有不同的应对策略:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;更开放&lt;/strong&gt;。框架只提供核心功能，附加几乎什么事情都能干的&lt;strong&gt;插件机制&lt;/strong&gt;。插件可以干预框架的整个生命周期，不满足的需求可以自己定制自己的插件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更决断&lt;/strong&gt;。我给你提供的就是最好的，能满足你的尽量满足你，其他的你不要管太多，也没有必要管, 专注你的业务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;我们也有自己的选择策略:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自己搞。例如大厂团队，有资源、有丰富的实践经验。他们有能力将自己的‘最佳实践’体系化。他们会选择创建自己的框架。同时他们也乐于将经验分享出来，也可以利用社区完善自己的作品。个人，基于学习和折腾的目的, 也可以搞一套。&lt;/li&gt;
&lt;li&gt;基于开源框架扩展。可以将开源框架作为基础，根据自己团队情况进行扩展开发。&lt;/li&gt;
&lt;li&gt;完全使用开源框架。开源框架可以满足许多通用的需求, 适合简单的应用场景。&lt;strong&gt;我们选择一个框架主要有两个原因：① 我们要提高工作效率；② 我们需要一个标准&lt;/strong&gt;。 为了标准，其实可妥协一些事情。更重要的是这些框架是在不断发展和演进的, 从而我们团队的技术也可以免费地跟随他们演进和发展。将开源框架的默认最佳实践开发视为标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;我一直坚信&lt;strong&gt;专业的人做专业的事。要善于将事情外包出去，腾空自己去做重要的事情&lt;/strong&gt;。大厂有专门的团队在做工具、建设基础设施，社区上开源的框架也由一大帮牛人在维护，而且通常开发迭代很活跃。所以说社区已经有的方案，可以直接拿来用，不要自己去造轮子，因为你一般没那么多精力。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;谈谈前端团队框架体系的建设&quot;&gt;&lt;a href=&quot;#谈谈前端团队框架体系的建设&quot; class=&quot;headerlink&quot; title=&quot;谈谈前端团队框架体系的建设&quot;/&gt;谈谈前端团队框架体系的建设&lt;/h2&gt;&lt;p&gt;前端开发的时间都花在了哪里?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fe-framework/time.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;em&gt;上图来源于&amp;lt;蚂蚁前端研发最佳实践&amp;gt; PPT&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;对于前端团队来说，开源前端框架只是一个基础，只是涉及前端开发的某个很小的部分，它就像一艘船。你要航线穿越大西洋，还有做很多工作、需要紧密高效的协作、可靠的后勤保障、目标和方向、坚定的领导… 路还很长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在来聊聊‘广义的‘框架体系，它集成自身业务，涉及前端开发完整链路，关注点从前端应用上升到了前端团队研发体系&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fe-framework/framework-order.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;九层之台，起于累土。 前端团队框架体系的建设是一个渐进式的过程，首先从基础设施开始、接着就是应用开发技术栈组合，再到组件体系，后面是上层的业务开发方案… 上层以下层为基础，共同构建出完整的框架体系。&lt;/p&gt;
&lt;p&gt;我觉得前端团队可以按照这样的分层结构，分阶段来完成这些建设任务。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一阶段-前端工程化-基础设施&quot;&gt;&lt;a href=&quot;#第一阶段-前端工程化-基础设施&quot; class=&quot;headerlink&quot; title=&quot;第一阶段: 前端工程化 / 基础设施&quot;/&gt;第一阶段: 前端工程化 / 基础设施&lt;/h3&gt;&lt;p&gt;最基础的阶段，关注前端的基础设施建设。这个阶段已经比较成熟，社区上有很多开箱即用的方案，例如 Umi、Next.js、Vue-CLI、Create-React-App 等等。主要内容有:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fe-framework/base.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h3 id=&quot;第二阶段-应用开发方案整合&quot;&gt;&lt;a href=&quot;#第二阶段-应用开发方案整合&quot; class=&quot;headerlink&quot; title=&quot;第二阶段: 应用开发方案整合&quot;/&gt;第二阶段: 应用开发方案整合&lt;/h3&gt;&lt;p&gt;在完善基础设施的同时，团队的应用开发技术栈组合方案也应该稳定下来，成为框架的一部分。这些组合也非常重要，它会影响上层的组件建设和业务开发。主要内容有:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fe-framework/app-dev.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h3 id=&quot;第三阶段-组件体系&quot;&gt;&lt;a href=&quot;#第三阶段-组件体系&quot; class=&quot;headerlink&quot; title=&quot;第三阶段: 组件体系&quot;/&gt;第三阶段: 组件体系&lt;/h3&gt;&lt;p&gt;组件化现在是前端主流开发模式，这里还有很多工作可以做，还有很大的提效空间。&lt;/p&gt;
&lt;p&gt;整个组件体系也是一个分层式的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fe-framework/component.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础组件。越底层，就说明可复用的程度越高、越通用。Ant-Design、Element-UI、iView、Material-UI 这些就属于基础组件库，有能力的团队也可以开发一套符合自己设计风格的组件库。&lt;/li&gt;
&lt;li&gt;业务组件。在基础组件之上封装的、耦合自己业务的组件。它们一般从重复的业务场景中抽象出来。&lt;/li&gt;
&lt;li&gt;区块。再往上，就很难用模块化的组件去组织了。于是有人(阿里前端)提出了‘区块’的概念，&lt;strong&gt;你可以认为‘区块’是：代码片段、代码示例、代码模板…&lt;/strong&gt; 这么看来，这并不是一种新的概念? 还没完! &lt;strong&gt;区块还要配套‘区块市场’才能展现它的用处。区块市场是一个代码片段分享平台，维护着大量的区块，试图覆盖大部分常见的使用场景。对于开发者来说就是找到尽量匹配自己场景的区块，拷贝过来，稍微改改就行了。这是一种 ‘Ctrl+C，Ctrl+V’ 编程哲学的完美实践啊&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;页面。和区块差不多，快速生成页面和路由。约定式的路由可以给页面自动化创建带来一些便利。&lt;/li&gt;
&lt;li&gt;布局。例如后台的整体布局。&lt;/li&gt;
&lt;li&gt;项目。项目的整体结构。可以通过‘脚手架‘ 来快速生成项目模板。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fe-framework/icework.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;像区块、页面生成这些操作需要一些工具辅助。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成器。生成不同级别的元件&lt;ul&gt;
&lt;li&gt;项目(项目模板)。 俗称脚手架, 支持不同的项目类型：应用、组件库、程序库、 插件&lt;/li&gt;
&lt;li&gt;页面/路由&lt;/li&gt;
&lt;li&gt;区块&lt;/li&gt;
&lt;li&gt;组件&lt;/li&gt;
&lt;li&gt;数据模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可视化工具。可视化的项目编排工具, 如飞冰。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h3 id=&quot;第四阶段：打通上下游&quot;&gt;&lt;a href=&quot;#第四阶段：打通上下游&quot; class=&quot;headerlink&quot; title=&quot;第四阶段：打通上下游&quot;/&gt;第四阶段：打通上下游&lt;/h3&gt;&lt;p&gt;前端只是研发流程的一环，只是前端自嗨，上下游没有资源支持，是很难走远的。&lt;/p&gt;
&lt;p&gt;对于前端来说，通常上游指的是 UI、下游指的是后端。&lt;/p&gt;
&lt;p&gt;对于 UI。上面说的组件体系，其实是建立在稳定的、一致的、统一的 UI 设计语言之上的。否则一切都是空谈。所以我们要求 UI 设计团队要有良好的设计规范、能和前端组件体系绑定并良性迭代。&lt;/p&gt;
&lt;p&gt;对于 后端。可以促进建立更标准的接口范式、封装通用的服务(有利于业务组件复用)、更深的有业务中台、BFF…&lt;/p&gt;
&lt;p&gt;上下游的打通，对前端生产力的解放也有非常大的促进作用。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h3 id=&quot;未来-ai&quot;&gt;&lt;a href=&quot;#未来-ai&quot; class=&quot;headerlink&quot; title=&quot;未来: AI?&quot;/&gt;未来: AI?&lt;/h3&gt;&lt;p&gt;AI 自动生成前端代码？ 太高大上了，还是把话筒交给它吧： &lt;a href=&quot;https://mp.weixin.qq.com/s/EktHbvCnghkywZE8rOvMhw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《双 11 模块 79.34% 的代码是怎样智能生成的？》&lt;/a&gt;， 溜了&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;扩展资料&quot;&gt;&lt;a href=&quot;#扩展资料&quot; class=&quot;headerlink&quot; title=&quot;扩展资料&quot;/&gt;扩展资料&lt;/h2&gt;

  &lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3c440f640d3d6191803a85a77f0b1975</guid>
<title>Netty如何做到单机百万并发？</title>
<link>https://toutiao.io/k/e190j0v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sXiaukvjR0RDZueicpEq2fZUlkrxNGTX7urTlpjNiaOkOGuPRKwUdQjozUNXib37tBiaY4gC2AxjmBXjSpqkb3nGlfA/640?wx_fmt=jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信很多人知道石中剑这个典故，在此典故中，天命注定的亚瑟很容易的就拔出了这把石中剑，但是由于资历不被其他人认可，所以他颇费了一番周折才成为了真正意义上的英格兰全境之王，亚瑟王。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说道这把剑，剑身上铭刻着这样一句话：ONLY THE KING CAN TAKE THE SWORD FROM THE STONE。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然典故中的 the king 是指英明之主亚瑟王，但是在本章中，这个 king 就是读者自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们今天不仅要从百万并发基石上拔出这把 epoll 之剑，也就是 Netty，而且要利用这把剑大杀四方，一如当年的亚瑟王凭借此剑统一了英格兰全境一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到石中剑 Netty，我们知道他极其强悍的性能以及纯异步模型，释放出了极强的生产力，内置的各种编解码编排，心跳包检测，粘包拆包处理等，高效且易于使用，以至于很多耳熟能详的组件都在使用，比如 Hadoop，Dubbo 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是他是如何做到这些的呢？本章将会以庖丁解牛的方式，一步一步的来拔出此剑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说起 Netty 的异步模型，我相信大多数人，只要是写过服务端的话，都是耳熟能详的，bossGroup 和 workerGroup 被 ServerBootstrap 所驱动，用起来简直是如虎添翼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再加上各种配置化的 handler 加持，组装起来也是行云流水，俯拾即是。但是，任何一个好的架构，都不是一蹴而就实现的，那她经历了怎样的心路历程呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2711670480549199&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCDQkZvQcriaALdbnlMzQQhIaiaOaeBT9JlKtfsIjqG6l5c04R0trJQDtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此模型中，服务端起来后，客户端连接到服务端，服务端会为每个客户端开启一个线程来进行后续的读写操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端少的时候，整体性能和功能还是可以的，但是如果客户端非常多的时候，线程的创建将会导致内存的急剧飙升从而导致服务端的性能下降，严重者会导致新客户端连接不上来，更有甚者，服务器直接宕机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此模型虽然简单，但是由于其简单粗暴，所以难堪大用，建议在写服务端的时候，要彻底的避免此种写法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于多线程模型难堪大用，所以更好的模型一直在研究之中，Reactor 模型，作为天选之子，也被引入了进来，由于其强大的基于事件处理的特性，使得其成为异步模型的不二之选。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Reactor 模型由于是基于事件处理的，所以一旦有事件被触发，将会派发到对应的 event handler 中进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在此模型中，有两个最重要的参与者，列举如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Reactor：&lt;/strong&gt; 主要用来将 IO 事件派发到相对应的 handler 中，可以将其想象为打电话时候的分发总机，你先打电话到总机号码，然后通过总机，你可以分拨到各个分机号码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Handlers：&lt;/strong&gt; 主要用来处理 IO 事件相关的具体业务，可以将其想象为拨通分机号码后，实际上为你处理事件的员工。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6294820717131474&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCPK1lYY8qWcy9hMu8fX5XdMQKceB7EZQkkdRmRMEPcDaibzlXD2aSk0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;753&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图为 Reactor 模型的描述图，具体来说一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Initiation Dispatcher 其实扮演的就是 Reactor 的角色，主要进行 Event Demultiplexer，即事件派发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而其内部一般都有一个 Acceptor，用于通过对系统资源的操纵来获取资源句柄，然后交由 Reactor，通过 handle_events 方法派发至具体的 EventHandler 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Synchronous Event Demultiplexer 其实就是 Acceptor 的角色，此角色内部通过调用系统的方法来进行资源操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说，假如客户端连接上来，那么将会获得当前连接，假如需要删除文件，那么将会获得当前待操作的文件句柄等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些句柄实际上是要返回给 Reactor 的，然后经由 Reactor 派发下放给具体的 EventHandler。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Event Handler 这里，其实就是具体的事件操作了。其内部针对不同的业务逻辑，拥有不同的操作方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说，鉴权 EventHandler 会检测传入的连接，验证其是否在白名单，心跳包 EventHanler 会检测管道是否空闲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务 EventHandler 会进行具体的业务处理，编解码 EventHandler 会对当前连接传输的内容进行编码解码操作等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Netty 是 Reactor 模型的具体实现，所以在编码的时候，我们可以非常清楚明白的理解 Reactor 的具体使用方式，这里暂时不讲，后面会提到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Doug Lea 写过一篇关于 NIO 的文章，整体总结的极好，所以这里我们就结合他的文章来详细分析一下 Reactor 模型的演化过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39520333680917624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCpvJgdL5WtATqEDDgiaWnHrjLsKdm1Fpqia6lZPmV7VgJLpKcE3BfZmGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;959&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图模型为单线程 Reator 模型，Reactor 模型会利用给定的 selectionKeys 进行派发操作，派发到给定的 handler。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后当有客户端连接上来的时候，acceptor 会进行 accept 接收操作，之后将接收到的连接和之前派发的 handler 进行组合并启动。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7006048387096774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCh4pYhOicoq2jZpVBYMezyRicovH5R1wWIDAw4Xc9EziapLFJ7dhZ1ibP3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;992&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图模型为池化 Reactor 模型，此模型将读操作和写操作解耦了出来，当有数据过来的时候，将 handler 的系列操作扔到线程池中来进行，极大的提到了整体的吞吐量和处理速度。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6917670682730924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkC5WY6LdvUj1RKiayLycPMJTdkeJ1pQ7nlj2tvrYTQHuwaWXZKFaKFnxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;996&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图模型为多 Reactor 模型，此模型中，将原本单个 Reactor 一分为二，分别为 mainReactor 和 subReactor。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 mainReactor 主要进行客户端连接方面的处理，客户端 accept 后发送给 subReactor 进行后续处理处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模型的好处就是整体职责更加明确，同时对于多 CPU 的机器，系统资源的利用更加高一些。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.654296875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCHibK2WcicFI1mUic9yG5GWU4zbJjC6uyNkv9d36em1xaj9oAWujgLfwQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Netty 写的 server 端，就可以看出，boss worker group 对应的正是主副 Reactor。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后 ServerBootstrap 进行 Reactor 的创建操作，里面的 group，channel，option 等进行初始化操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而设置的 childHandler 则是具体的业务操作，其底层的事件分发器则通过调用 Linux 系统级接口 epoll 来实现连接并将其传给 Reactor。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Boot + MyBatis Plus + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://gitee.com/zhijiantianya/ruoyi-vue-pro&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty 之剑之所以锋利，不仅仅因为其纯异步的编排模型，避免了各种阻塞式的操作，同时其内部各种设计精良的组件，终成一统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;且不说让人眼前一亮的缓冲池设计，读写标随心而动，摒弃了繁冗复杂的边界检测，用起来着实舒服之极。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原生的流控和高低水位设计，让流速控制真的是随心所欲，铸就了一道相当坚固的护城河。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;齐全的粘包拆包处理方式，让每一笔数据都能够清晰明了；而高效的空闲检测机制，则让心跳包和断线重连等设计方案变得如此俯拾即是。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上层的设计如此优秀，其性能又怎能甘居下风。由于底层通讯方式完全是 C 语言编写，然后利用 JNI 机制进行处理，所以整体的性能可以说是达到了原生 C 语言性能的强悍程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说道 JNI，这里我觉得有必要详细说一下，他是我们利用 Java 直接调用 C 语言原生代码的关键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JNI，全称为Java Native Interface，翻译过来就是 Java 本地接口，他是 Java 调用 C 语言的一套规范。具体来看看怎么做的吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤一，先来写一个简单的 Java 调用函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; shichaoyang&lt;br/&gt; * &lt;span&gt;@Description&lt;/span&gt;: 数据同步器&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2020-10-14 19:41&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DataSynchronizer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 加载本地底层C实现库&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;        System.loadLibrary(&lt;span&gt;&quot;synchronizer&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 底层数据同步方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; String &lt;span&gt;syncData&lt;/span&gt;&lt;span&gt;(String status)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 程序启动，调用底层数据同步方法&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; args&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String... args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String rst = &lt;span&gt;new&lt;/span&gt; DataSynchronizer().syncData(&lt;span&gt;&quot;ProcessStep2&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;The execute result from C is : &quot;&lt;/span&gt; + rst);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，是一个非常简单的 Java 类，此类中，syncData 方法前面带了 native 修饰，代表此方法最终将会调用底层 C 语言实现。main 方法是启动类，将 C 语言执行的结果接收并打印出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，打开我们的 Linux 环境，这里由于我用的是 linux mint，依次执行如下命令来设置环境：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;执行apt install &lt;span&gt;default&lt;/span&gt;-jdk 安装java环境，安装完毕。&lt;br/&gt;&lt;br/&gt;通过update-alternatives --list java 获取java安装路径，这里为：/usr/lib/jvm/java-&lt;span&gt;11&lt;/span&gt;-openjdk-amd64   &lt;br/&gt;&lt;br/&gt;设置java环境变量 export JAVA_HOME=/usr/lib/jvm/java-&lt;span&gt;11&lt;/span&gt;-openjdk-amd64&lt;br/&gt;&lt;br/&gt;环境设置完毕之后，就可以开始进行下一步了。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤二，编译，首先，进入到代码 DataSynchronizer.c 所在的目录，然后运行如下命令来编译 Java 源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;javac -h . DataSynchronizer.java&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译完毕之后，可以看到当前目录出现了如下几个文件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3251366120218579&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCaicRxWqNb704DfdiaTK76icSkBuF8f4wwwYYoOfTnx7ea6UwDAtia0tmaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;366&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 DataSynchronizer.h 是生成的头文件，这个文件尽量不要修改，整体内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/* DO NOT EDIT THIS FILE - it is machine generated */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;jni.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/* Header for class DataSynchronizer */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;ifndef&lt;/span&gt; _Included_DataSynchronizer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; _Included_DataSynchronizer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;ifdef&lt;/span&gt; __cplusplus&lt;/span&gt;&lt;br/&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;C&quot;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/*&lt;br/&gt; * Class:     DataSynchronizer&lt;br/&gt; * Method:    syncData&lt;br/&gt; * Signature: (Ljava/lang/String;)Ljava/lang/String;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;JNIEXPORT jstring JNICALL &lt;span&gt;Java_DataSynchronizer_syncData&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;(JNIEnv *, jobject, jstring)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;ifdef&lt;/span&gt; __cplusplus&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 JNIEXPORT jstring JNICALL Java_DataSynchronizer_syncData 方法，就是给我们生成的本地 C 语言方法，我们这里只需要创建一个 C 语言文件，名称为 DataSynchronizer.c。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将此头文件加载进来，实现此方法即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;jni.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;DataSynchronizer.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;JNIEXPORT jstring JNICALL &lt;span&gt;Java_DataSynchronizer_syncData&lt;/span&gt;&lt;span&gt;(JNIEnv *env, jobject obj, jstring str)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;// Step 1: Convert the JNI String (jstring) into C-String (char*)&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *inCStr = (*env)-&amp;gt;GetStringUTFChars(env, str, &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;NULL&lt;/span&gt; == inCStr) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// Step 2: Perform its intended operations&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;In C, the received string is: %s\n&quot;&lt;/span&gt;, inCStr);&lt;br/&gt;   (*env)-&amp;gt;ReleaseStringUTFChars(env, str, inCStr);  &lt;span&gt;// release resources&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// Prompt user for a C-string&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;char&lt;/span&gt; outCStr[&lt;span&gt;128&lt;/span&gt;];&lt;br/&gt;   &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Enter a String: &quot;&lt;/span&gt;);&lt;br/&gt;   &lt;span&gt;scanf&lt;/span&gt;(&lt;span&gt;&quot;%s&quot;&lt;/span&gt;, outCStr);&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// Step 3: Convert the C-string (char*) into JNI String (jstring) and return&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; (*env)-&amp;gt;NewStringUTF(env, outCStr);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中需要注意的是，JNIEnv* 变量，实际上指的是当前的 JNI 环境。而 jobject 变量则类似 Java 中的 this 关键字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jstring 则是 C 语言层面上的字符串，相当于 Java 中的 String。整体对应如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7001953125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkC14lSthyjh5VAIGI02ucOkQW5yq4580nia6gUUsV0CWBGk6mpHEnSsPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们来编译一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;gcc -fPIC -I&lt;span&gt;&quot;$JAVA_HOME/include&quot;&lt;/span&gt; -I&lt;span&gt;&quot;$JAVA_HOME/include/linux&quot;&lt;/span&gt; -shared -o libsynchronizer.so DataSynchronizer.c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译完毕后，可以看到当前目录下又多了一个 libsynchronizer.so 文件（这个文件类似 Windows 上编译后生成的 .dll 类库文件）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19543973941368079&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCW7pUkf4GygNLdw8TfJiaG5EYg9TlfsfBlxcytYxU4Ne8nDbQzhWEz3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我们可以运行了，运行如下命令进行运行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -Djava.library.path=. DataSynchronizer&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得到结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -Djava.library.path=. DataSynchronizer&lt;br/&gt;In C, the received string is: ProcessStep2&lt;br/&gt;Enter a String: sdfsdf&lt;br/&gt;The execute result from C is : sdfsdf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这里看到，我们正确的通过 java jni 技术，调用了 C 语言底层的逻辑，然后获取到结果，打印了出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Netty 中，也是利用了 jni 的技术，然后通过调用底层的 C 语言逻辑实现，来实现高效的网络通讯的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感兴趣的同学可以扒拉下 Netty 源码，在 transport-native-epoll 模块中，就可以见到具体的实现方法了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.212890625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCcdYwZ153wRIVfZHZqicicltbggXI4qYuHzMZDklu8NoqIYibiakquTCvFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Cloud Alibaba + Gateway + Nacos + RocketMQ + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://gitee.com/zhijiantianya/yudao-cloud&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;石中剑，之所以能荡平英格兰全境，自然有其最强悍的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相应的，Netty，则也是不遑多让，之所以能够被各大知名的组件所采用，自然也有其最强悍的地方，而本章节的 IO 多路复用模型，则是其强悍的理由之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在说 IO 多路复用模型之前，我们先来大致了解下 Linux 文件系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 系统中，不论是你的鼠标，键盘，还是打印机，甚至于连接到本机的 socket client 端，都是以文件描述符的形式存在于系统中，诸如此类，等等等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以可以这么说，一切皆文件。来看一下系统定义的文件描述符说明：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23613312202852615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCkXrGznqlF5EGHSCC8RaeyR78TMA53KGqib9RfZkOwOQs1zj3z9U1IXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;631&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的列表可以看到，文件描述符 0，1，2 都已经被系统占用了，当系统启动的时候，这三个描述符就存在了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 0 代表标准输入，1 代表标准输出，2 代表错误输出。当我们创建新的文件描述符的时候，就会在 2 的基础上进行递增。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以这么说，文件描述符是为了管理被打开的文件而创建的系统索引，他代表了文件的身份 ID。对标 Windows 的话，你可以认为和句柄类似，这样就更容易理解一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于网上对 Linux 文件这块的原理描述的文章已经非常多了，所以这里我不再做过多的赘述，感兴趣的同学可以从 Wikipedia 翻阅一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这块内容比较复杂，不属于本文普及的内容，建议读者另行自研。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此模型是 IO 多路复用的最早期使用的模型之一，距今已经几十年了，但是现在依旧有不少应用还在采用此种方式，可见其长生不老。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先来看下其具体的定义（来源于 man 二类文档）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里解释下其具体参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;参数一：nfds，&lt;/strong&gt; 也即 maxfd，最大的文件描述符递增一。这里之所以传最大描述符，为的就是在遍历 fd_set 的时候，限定遍历范围。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;参数二：readfds，&lt;/strong&gt; 可读文件描述符集合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;参数三：writefds，&lt;/strong&gt; 可写文件描述符集合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;参数四：errorfds，&lt;/strong&gt; 异常文件描述符集合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;参数五：timeout，&lt;/strong&gt; 超时时间。在这段时间内没有检测到描述符被触发，则返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的宏处理，可以对 fd_set 集合（准确的说是 bitmap，一个描述符有变更，则会在描述符对应的索引处置 1）进行操作：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;FD_CLR(inr fd,fd_set* set) ：&lt;/strong&gt; 用来清除描述词组 set 中相关 fd 的位，即 bitmap 结构中索引值为 fd 的值置为 0。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;FD_ISSET(int fd,fd_set *set)：&lt;/strong&gt; 用来测试描述词组 set 中相关 fd 的位是否为真，即 bitmap 结构中某一位是否为 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;FD_SET（int fd,fd_set*set）：&lt;/strong&gt; 用来设置描述词组 set 中相关 fd 的位，即将 bitmap 结构中某一位设置为 1，索引值为 fd。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;FD_ZERO（fd_set *set）：&lt;/strong&gt; 用来清除描述词组 set 的全部位，即将 bitmap 结构全部清零。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先来看一段服务端采用了 select 模型的示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//创建server端套接字，获取文件描述符&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; listenfd = socket(PF_INET,SOCK_STREAM,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(listenfd &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//绑定服务器&lt;/span&gt;&lt;br/&gt;    bind(listenfd,(struct sockaddr*)&amp;amp;address,sizeof(address));&lt;br/&gt;    &lt;span&gt;//监听服务器&lt;/span&gt;&lt;br/&gt;    listen(listenfd,&lt;span&gt;5&lt;/span&gt;); &lt;br/&gt;&lt;br/&gt;    struct sockaddr_in client;&lt;br/&gt;    socklen_t addr_len = sizeof(client);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//接收客户端连接&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; connfd = accept(listenfd,(struct sockaddr*)&amp;amp;client,&amp;amp;addr_len);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//读缓冲区&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; buff[&lt;span&gt;1024&lt;/span&gt;]; &lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//读文件操作符&lt;/span&gt;&lt;br/&gt;    fd_set read_fds;  &lt;br/&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        memset(buff,&lt;span&gt;0&lt;/span&gt;,sizeof(buff));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//注意：每次调用select之前都要重新设置文件描述符connfd，因为文件描述符表会在内核中被修改&lt;/span&gt;&lt;br/&gt;        FD_ZERO(&amp;amp;read_fds);&lt;br/&gt;        FD_SET(connfd,&amp;amp;read_fds);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//注意：select会将用户态中的文件描述符表放到内核中进行修改，内核修改完毕后再返回给用户态，开销较大&lt;/span&gt;&lt;br/&gt;        ret = select(connfd+&lt;span&gt;1&lt;/span&gt;,&amp;amp;read_fds,NULL,NULL,NULL);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(ret &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        {&lt;br/&gt;            printf(&lt;span&gt;&quot;Fail to select!\n&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//检测文件描述符表中相关请求是否可读&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(FD_ISSET(connfd, &amp;amp;read_fds))&lt;br/&gt;        {&lt;br/&gt;            ret = recv(connfd,buff,sizeof(buff)-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;            printf(&lt;span&gt;&quot;receive %d bytes from client: %s \n&quot;&lt;/span&gt;,ret,buff);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码我加了比较详细的注释了，大家应该很容易看明白，说白了大概流程其实如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先，创建 socket 套接字，创建完毕后，会获取到此套接字的文件描述符。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，bind 到指定的地址进行监听 listen。这样，服务端就在特定的端口启动起来并进行监听了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之后，利用开启 accept 方法来监听客户端的连接请求。一旦有客户端连接，则将获取到当前客户端连接的 connection 文件描述符。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双方建立连接之后，就可以进行数据互传了。需要注意的是，在循环开始的时候，务必每次都要重新设置当前 connection 的文件描述符，是因为文件描描述符表在内核中被修改过，如果不重置，将会导致异常的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新设置文件描述符后，就可以利用 select 函数从文件描述符表中，来轮询哪些文件描述符就绪了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时系统会将用户态的文件描述符表发送到内核态进行调整，即将准备就绪的文件描述符进行置位，然后再发送给用户态的应用中来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户通过 FD_ISSET 方法来轮询文件描述符，如果数据可读，则读取数据即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，假设此时连接上来了 3 个客户端，connection 的文件描述符分别为 4，8，12。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么其 read_fds 文件描述符表（bitmap 结构）的大致结构为 00010001000100000....0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 read_fds 文件描述符的长度为 1024 位，所以最多允许 1024 个连接。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15680473372781065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCEEGAkPQo4p4P6cE7RFAhzMPx9lCmjPib25vfx6HdmHZUZjJCibA74TAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;676&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 select 的时候，涉及到用户态和内核态的转换，所以整体转换方式如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5373737373737374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkC4UJb5cUqdZ0QNz6u0f5o8Lich07picPTn8kznnwKo1PjuOoTGH9Pmq8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，综合起来，select 整体还是比较高效和稳定的，但是呈现出来的问题也不少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些问题进一步限制了其性能发挥：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;文件描述符表为 bitmap 结构，且有长度为 1024 的限制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;fdset 无法做到重用，每次循环必须重新创建。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;频繁的用户态和内核态拷贝，性能开销较大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要对文件描述符表进行遍历，O(n) 的轮询时间复杂度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到 select 模型的几个限制，后来进行了改进，这也就是 poll 模型，既然是 select 模型的改进版，那么肯定有其亮眼的地方，一起来看看吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这次我们依旧是先翻阅 linux man 二类文档，因为这是官方的文档，对其有着最为精准的定义。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;poll&lt;/span&gt;&lt;span&gt;(struct pollfd *fds, nfds_t nfds, &lt;span&gt;int&lt;/span&gt; timeout)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，从运行机制上说来，poll 所做的功能和 select 是基本上一样的，都是等待并检测一组文件描述符就绪，然后在进行后续的 IO 处理工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只不过不同的是，select 中，采用的是 bitmap 结构，长度限定在 1024 位的文件描述符表，而 poll 模型则采用的是 pollfd 结构的数组 fds。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也正是由于 poll 模型采用了数组结构，则不会有 1024 长度限制，使其能够承受更高的并发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pollfd 结构内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pollfd&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt;   fd;         &lt;span&gt;/* 文件描述符 */&lt;/span&gt;&lt;br/&gt;    short events;     &lt;span&gt;/* 关心的事件 */&lt;/span&gt;&lt;br/&gt;    short revents;    &lt;span&gt;/* 实际返回的事件 */&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的结构可以看出，fd 很明显就是指文件描述符，也就是当客户端连接上来后，fd 会将生成的文件描述符保存到这里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 events 则是指用户想关注的事件；revents 则是指实际返回的事件，是由系统内核填充并返回，如果当前的 fd 文件描述符有状态变化，则 revents 的值就会有相应的变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;events 事件列表如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCGJicWuohPMGsBdDBaQgGb0kv72FfxYLcGFuWvTfOwkRuNRoF8ItS1qA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;405&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;revents 事件列表如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.167487684729064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCdZicFdkcicLibOS248Y5elbfIWrSOHBfyZ1SIGXZ9j2BsdGtp11bxjYpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;406&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从列表中可以看出，revents 是包含 events 的。接下来结合示例来看一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;//创建server端套接字，获取文件描述符&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; listenfd = socket(PF_INET,SOCK_STREAM,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(listenfd &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//绑定服务器&lt;/span&gt;&lt;br/&gt;    bind(listenfd,(struct sockaddr*)&amp;amp;address,sizeof(address));&lt;br/&gt;    &lt;span&gt;//监听服务器&lt;/span&gt;&lt;br/&gt;    listen(listenfd,&lt;span&gt;5&lt;/span&gt;); &lt;br/&gt;&lt;br/&gt;    struct pollfd pollfds[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;    socklen_t addr_len = sizeof(client);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//接收客户端连接&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; connfd = accept(listenfd,(struct sockaddr*)&amp;amp;client,&amp;amp;addr_len);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//放入fd数组&lt;/span&gt;&lt;br/&gt;    pollfds[&lt;span&gt;0&lt;/span&gt;].fd = connfd;&lt;br/&gt;    pollfds[&lt;span&gt;0&lt;/span&gt;].events = POLLIN;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//读缓冲区&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; buff[&lt;span&gt;1024&lt;/span&gt;]; &lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//读文件操作符&lt;/span&gt;&lt;br/&gt;    fd_set read_fds;  &lt;br/&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        memset(buff,&lt;span&gt;0&lt;/span&gt;,sizeof(buff));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         ** SELECT模型专用&lt;br/&gt;         ** 注意：每次调用select之前都要重新设置文件描述符connfd，因为文件描述符表会在内核中被修改&lt;br/&gt;         ** FD_ZERO(&amp;amp;read_fds);&lt;br/&gt;         ** FD_SET(connfd,&amp;amp;read_fds);&lt;br/&gt;        ** 注意：select会将用户态中的文件描述符表放到内核中进行修改，内核修改完毕后再返回给用户态，开销较大&lt;br/&gt;        ** ret = select(connfd+1,&amp;amp;read_fds,NULL,NULL,NULL);&lt;br/&gt;        **/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        ret = poll(pollfds, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(ret &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        {&lt;br/&gt;            printf(&lt;span&gt;&quot;Fail to poll!\n&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         ** SELECT模型专用&lt;br/&gt;         ** 检测文件描述符表中相关请求是否可读&lt;br/&gt;         ** if(FD_ISSET(connfd, &amp;amp;read_fds))&lt;br/&gt;         ** {&lt;br/&gt;         **   ret = recv(connfd,buff,sizeof(buff)-1,0);&lt;br/&gt;         **   printf(&quot;receive %d bytes from client: %s \n&quot;,ret,buff);&lt;br/&gt;         ** }&lt;br/&gt;         **/&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//检测文件描述符数组中相关请求&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(pollfds[&lt;span&gt;0&lt;/span&gt;].revents &amp;amp; POLLIN){&lt;br/&gt;            pollfds[&lt;span&gt;0&lt;/span&gt;].revents = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            ret = recv(connfd,buff,sizeof(buff)-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;            printf(&lt;span&gt;&quot;receive %d bytes from client: %s \n&quot;&lt;/span&gt;,ret,buff);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于源码中，我做了比较详细的注释，同时将和 select 模型不一样的地方都列了出来，这里就不再详细解释了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体说来，poll 模型比 select 模型要好用一些，去掉了一些限制，但是仍然避免不了如下的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户态和内核态仍需要频繁切换，因为 revents 的赋值是在内核态进行的，然后再推送到用户态，和 select 类似，整体开销较大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;仍需要遍历数组，时间复杂度为 O（N）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说 select 模型和 poll 模型是早期的产物，在性能上有诸多不尽人意之处，那么自 Linux 2.6 之后新增的 epoll 模型，则彻底解决了性能问题，一举使得单机承受百万并发的课题变得极为容易。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在可以这么说，只需要一些简单的设置更改，然后配合上 epoll 的性能，实现单机百万并发轻而易举。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，由于 epoll 整体的优化，使得之前的几个比较耗费性能的问题不再成为羁绊，所以也成为了 Linux 平台上进行网络通讯的首选模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲解之前，还是 linux man 文档镇楼：linux man epoll 4 类文档 linux man epoll 7 类文档，俩文档结合着读，会对 epoll 有个大概的了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和之前提到的 select 和 poll 不同的是，此二者皆属于系统调用函数，但是 epoll 则不然，他是存在于内核中的数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过 epoll_create，epoll_ctl 及 epoll_wait 三个函数结合来对此数据结构进行操控。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到 epoll_create 函数，其作用是在内核中创建一个 epoll 数据结构实例，然后将返回此实例在系统中的文件描述符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此 epoll 数据结构的组成其实是一个链表结构，我们称之为 interest list，里面会注册连接上来的 client 的文件描述符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其简化工作机制如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7770897832817337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCAdiaudrsft6RwVMho6Quj31iaPc0MmymibW8mQA6Tszjia0ZqguEMIAW8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;646&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说道 epoll_ctl 函数，其作用则是对 epoll 实例进行增删改查操作。有些类似我们常用的 CRUD 操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数操作的对象其实就是 epoll 数据结构，当有新的 client 连接上来的时候，他会将此 client 注册到 epoll 中的 interest list 中，此操作通过附加 EPOLL_CTL_ADD 标记来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当已有的 client 掉线或者主动下线的时候，他会将下线的 client从epoll 的 interest list 中移除，此操作通过附加 EPOLL_CTL_DEL 标记来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当有 client 的文件描述符有变更的时候，他会将 events 中的对应的文件描述符进行更新，此操作通过附加 EPOLL_CTL_MOD 来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 interest list 中有 client 已经准备好了，可以进行 IO 操作的时候，他会将这些 clients 拿出来，然后放到一个新的 ready list 里面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其简化工作机制如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8524844720496895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCDJPIodNX8Jzctjx1PeEL7wIID6CtHoZZjpOrWXe60C6icJHlDoKJWyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;644&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说道 epoll_wait 函数，其作用就是扫描 ready list，处理准备就绪的 client IO，其返回结果即为准备好进行 IO 的 client 的个数。通过遍历这些准备好的 client，就可以轻松进行 IO 处理了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这三个函数是 epoll 操作的基本函数，但是，想要彻底理解 epoll，则需要先了解这三块内容，即：inode，链表，红黑树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 内核中，针对当前打开的文件，有一个 open file table，里面记录的是所有打开的文件描述符信息；同时也有一个 inode table，里面则记录的是底层的文件描述符信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里假如文件描述符 B fork 了文件描述符 A，虽然在 open file table 中，我们看新增了一个文件描述符 B，但是实际上，在 inode table 中，A 和 B 的底层是一模一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，将 inode table 中的内容理解为 Windows 中的文件属性，会更加贴切和易懂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样存储的好处就是，无论上层文件描述符怎么变化，由于 epoll 监控的数据永远是 inode table 的底层数据，那么我就可以一直能够监控到文件的各种变化信息，这也是 epoll 高效的基础。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简化流程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7851662404092071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCq3CH2icCOQk5VQBTkNibLsUmYOPWqibd4icscibzTAp4XpQwaNOSI4PdxtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;391&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据存储这块解决了，那么针对连接上来的客户端 socket，该用什么数据结构保存进来呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里用到了红黑树，由于客户端 socket 会有频繁的新增和删除操作，而红黑树这块时间复杂度仅仅为 O(logN)，还是挺高效的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人会问为啥不用哈希表呢？当大量的连接频繁的进行接入或者断开的时候，扩容或者其他行为将会产生不少的 rehash 操作，而且还要考虑哈希冲突的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然查询速度的确可以达到 o(1)，但是 rehash 或者哈希冲突是不可控的，所以基于这些考量，我认为红黑树占优一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端 socket 怎么管理这块解决了，接下来，当有 socket 有数据需要进行读写事件处理的时候，系统会将已经就绪的 socket 添加到双向链表中，然后通过 epoll_wait 方法检测的时候。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实检查的就是这个双向链表，由于链表中都是就绪的数据，所以避免了针对整个客户端 socket 列表进行遍历的情况，使得整体效率大大提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体的操作流程为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先，利用 epoll_create 在内核中创建一个 epoll 对象。其实这个 epoll 对象，就是一个可以存储客户端连接的数据结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，客户端 socket 连接上来，会通过 epoll_ctl 操作将结果添加到 epoll 对象的红黑树数据结构中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，一旦有 socket 有事件发生，则会通过回调函数将其添加到 ready list 双向链表中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，epoll_wait 会遍历链表来处理已经准备好的 socket，然后通过预先设置的水平触发或者边缘触发来进行数据的感知操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的细节可以看出，由于 epoll 内部监控的是底层的文件描述符信息，可以将变更的描述符直接加入到 ready list，无需用户将所有的描述符再进行传入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时由于 epoll_wait 扫描的是已经就绪的文件描述符，避免了很多无效的遍历查询，使得 epoll 的整体性能大大提升，可以说现在只要谈论 Linux 平台的 IO 多路复用，epoll 已经成为了不二之选。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到了 epoll，主要讲解了 client 端怎么连进来，但是并未详细的讲解 epoll_wait 怎么被唤醒的，这里我将来详细的讲解一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;水平触发，意即 Level Trigger，边缘触发，意即 Edge Trigger，如果单从字面意思上理解，则不太容易，但是如果将硬件设计中的水平沿，上升沿，下降沿的概念引进来，则理解起来就容易多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们可以这样认为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3856920684292379&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCbgQBnjYFuSibgeBjhcVBowNs7DFuS2e4ibw3arDBXNRCwoicFEpu1AWuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将上图中的方块看做是 buffer 的话，那么理解起来则就更加容易了，比如针对水平触发，buffer 只要是一直有数据，则一直通知；而边缘触发，则 buffer 容量发生变化的时候，才会通知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然可以这样简单的理解，但是实际上，其细节处理部分，比图示中展现的更加精细，这里来详细的说一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对读操作，也就是当前 fd 处于 EPOLLIN 模式下，即可读。此时意味着有新的数据到来，接收缓冲区可读，以下 buffer 都指接收缓冲区：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;buffer 由空变为非空，意即有数据进来的时候，此过程会触发通知：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48493975903614456&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCG7vJb1v0tILU0Lr9IK4v8E53ftcMdAOaGGL2blGwvAqvqx6t6AQuhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;332&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;buffer 原本有些数据，这时候又有新数据进来的时候，数据变多，此过程会触发通知：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4815950920245399&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCAMBwRB1p4gOficZRvA6QjsT6XticWfnOZltNWKicColgK9jqpQGsccVOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;326&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;buffer 中有数据，此时用户对操作的 fd 注册 EPOLL_CTL_MOD 事件的时候，会触发通知：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7071428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkClHOInsobpXWWrtTzcFwxj0HpTVF7iah28StxXoSHWDHD4WGwzeZU10A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对写操作，也就是当前 fd 处于 EPOLLOUT 模式下，即可写。此时意味着缓冲区可以写了，以下 buffer 都指发送缓冲区：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;buffer 满了，这时候发送出去一些数据，数据变少，此过程会触发通知：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48024316109422494&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCQwpuSE9QKRgL43ia0ozc3mf730CteLTLia6Pic0MpwK7GbiajFdL61eWGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;329&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;buffer 原本有些数据，这时候又发送出去一些数据，数据变少，此过程会触发通知：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4783950617283951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCRBZzLJWGU1CJgcRxdoxpqFTQ28KClK1ggcUXCTXg7dmibDBsh0px3DQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;324&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就是 ET 这种模式触发的几种情形，可以看出，基本上都是围绕着接收缓冲区或者发送缓冲区的状态变化来进行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;晦涩难懂？不存在的，举个栗子：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在服务端，我们开启边缘触发模式，然后将 buffer size 设为 10 个字节，来看看具体的表现形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端开启，客户端连接，发送单字符 A 到服务端，输出结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;--&amp;gt;ET Mode: it was triggered once&lt;br/&gt;&lt;br/&gt;get &lt;span&gt;1&lt;/span&gt; bytes of content: A&lt;br/&gt;&lt;br/&gt;--&amp;gt;wait to read!&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，由于 buffer 从空到非空，边缘触发通知产生，之后在 epoll_wait 处阻塞，继续等待后续事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们变一下，输入 ABCDEFGHIJKLMNOPQ，可以看到，客户端发送的字符长度超过了服务端 buffer size，那么输出结果将是怎么样的呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;--&amp;gt;ET Mode: it was triggered once&lt;br/&gt;&lt;br/&gt;get &lt;span&gt;9&lt;/span&gt; bytes of content: ABCDEFGHI&lt;br/&gt;&lt;br/&gt;get &lt;span&gt;8&lt;/span&gt; bytes of content: JKLMNOPQ&lt;br/&gt;&lt;br/&gt;--&amp;gt;wait to read!&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，这次发送，由于发送的长度大于 buffer size，所以内容被折成两段进行接收，由于用了边缘触发方式，buffer 的情况是从空到非空，所以只会产生一次通知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;水平触发则简单多了，他包含了边缘触发的所有场景，简而言之如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当接收缓冲区不为空的时候，有数据可读，则读事件会一直触发：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4357142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCs7EicNElej2KSW977TY1IBCbkNZFFMPGLefDPqowT6ANpow8JkjxZnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发送缓冲区未满的时候，可以继续写入数据，则写事件一直会触发：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4076655052264808&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdwgY37UZhRES22EqBibBfkCp0icNBoky945AouHwxUh07iaS13ZqFuT8JDMIgpylfwcOn5eYgSnqeqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;287&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的，为了使表达更清晰，我们也来举个栗子，按照上述入输入方式来进行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端开启，客户端连接并发送单字符 A，可以看到服务端输出情况如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;--&amp;gt;LT Mode: it was triggered once!&lt;br/&gt;&lt;br/&gt;get &lt;span&gt;1&lt;/span&gt; bytes of content: A&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个输出结果，毋庸置疑，由于 buffer 中有数据，所以水平模式触发，输出了结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端开启，客户端连接并发送 ABCDEFGHIJKLMNOPQ，可以看到服务端输出情况如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;--&amp;gt;LT Mode: it was triggered once!&lt;br/&gt;&lt;br/&gt;get &lt;span&gt;9&lt;/span&gt; bytes of content: ABCDEFGHI&lt;br/&gt;&lt;br/&gt;--&amp;gt;LT Mode: it was triggered once!&lt;br/&gt;&lt;br/&gt;get &lt;span&gt;8&lt;/span&gt; bytes of content: JKLMNOPQ&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果中，可以看出，由于 buffer 中数据读取完毕后，还有未读完的数据，所以水平模式会一直触发，这也是为啥这里水平模式被触发了两次的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这两个栗子的比对，不知道聪明的你，get 到二者的区别了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际开发过程中，实际上 LT 更易用一些，毕竟系统帮助我们做了大部分校验通知工作，之前提到的 SELECT 和 POLL，默认采用的也都是这个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是需要注意的是，当有成千上万个客户端连接上来开始进行数据发送，由于 LT 的特性，内核会频繁的处理通知操作，导致其相对于 ET 来说，比较的耗费系统资源，所以，随着客户端的增多，其性能也就越差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而边缘触发，由于监控的是 FD 的状态变化，所以整体的系统通知并没有那么频繁，高并发下整体的性能表现也要好很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是由于此模式下，用户需要积极的处理好每一笔数据，带来的维护代价也是相当大的，稍微不注意就有可能出错。所以使用起来须要非常小心才行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于二者如何抉择，诸位就仁者见仁智者见智吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;行文到这里，关于 epoll 的讲解基本上完毕了，大家从中是不是学到了很多干货呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于从 Netty 研究到 linux epoll 底层，其难度非常大，可以用曲高和寡来形容，所以在这块探索的文章是比较少的，很多东西需要自己照着 man 文档和源码一点一点的琢磨（linux 源码详见 eventpoll.c 等）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我来纠正一下搜索引擎上，说 epoll 高性能是因为利用 mmap 技术实现了用户态和内核态的内存共享，所以性能好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我前期被这个观点误导了好久，后来下来了 Linux 源码，翻了一下，并没有在 epoll 中翻到 mmap 的技术点，所以这个观点是错误的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些错误观点的文章，国内不少，国外也不少，希望大家能审慎抉择，避免被错误带偏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，epoll 高性能的根本就是，其高效的文件描述符处理方式加上颇具特性边的缘触发处理模式，以极少的内核态和用户态的切换，实现了真正意义上的高并发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实践是最好的老师，我们现在已经知道了 epoll 之剑怎么嵌入到石头中的，现在就让我们不妨尝试着拔一下看看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手写 epoll 服务器，具体细节如下（非 C 语言 coder，代码有参考）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;netinet/in.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/epoll.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdbool.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; MAX_EVENT_NUMBER 1024   &lt;span&gt;//事件总数量&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; BUFFER_SIZE 10          &lt;span&gt;//缓冲区大小，这里为10个字节&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; ENABLE_ET 0             &lt;span&gt;//ET模式&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/* 文件描述符设为非阻塞状态&lt;br/&gt; * 注意：这个设置很重要，否则体现不出高性能&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;SetNonblocking&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; fd)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; old_option = fcntl(fd, F_GETFL);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; new_option = old_option | O_NONBLOCK;&lt;br/&gt;    fcntl(fd, F_SETFL, new_option);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; old_option;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/* 将文件描述符fd放入到内核中的epoll数据结构中并将fd设置为EPOLLIN可读，同时根据ET开关来决定使用水平触发还是边缘触发模式 &lt;br/&gt; * 注意：默认为水平触发，或上EPOLLET则为边缘触发&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;AddFd&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; epoll_fd, &lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;bool&lt;/span&gt; enable_et)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epoll_event&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;;&lt;/span&gt;  &lt;span&gt;//为当前fd设置事件&lt;/span&gt;&lt;br/&gt;    event.data.fd = fd;        &lt;span&gt;//指向当前fd&lt;/span&gt;&lt;br/&gt;    event.events = EPOLLIN;    &lt;span&gt;//使得fd可读&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(enable_et)&lt;br/&gt;    {&lt;br/&gt;        event.events |= EPOLLET; &lt;span&gt;//设置为边缘触发&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;amp;event);  &lt;span&gt;//将fd添加到内核中的epoll实例中&lt;/span&gt;&lt;br/&gt;    SetNonblocking(fd);  &lt;span&gt;//设为非阻塞模式                      &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/*  LT水平触发 &lt;br/&gt; *  注意：水平触发简单易用，性能不高，适合低并发场合&lt;br/&gt; *        一旦缓冲区有数据，则会重复不停的进行通知，直至缓冲区数据读写完毕&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;lt_process&lt;/span&gt;&lt;span&gt;(struct epoll_event* events, &lt;span&gt;int&lt;/span&gt; number, &lt;span&gt;int&lt;/span&gt; epoll_fd, &lt;span&gt;int&lt;/span&gt; listen_fd)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; buf[BUFFER_SIZE];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; number; i++) &lt;span&gt;//已经就绪的事件，这些时间可读或者可写&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; sockfd = events[i].data.fd; &lt;span&gt;//获取描述符&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(sockfd == listen_fd)  &lt;span&gt;//如果监听类型的描述符，则代表有新的client接入，则将其添加到内核中的epoll结构中&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;sockaddr_in&lt;/span&gt; &lt;span&gt;client_address&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;socklen_t&lt;/span&gt; client_addrlength = &lt;span&gt;sizeof&lt;/span&gt;(client_address);&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; connfd = accept(listen_fd, (struct sockaddr*)&amp;amp;client_address, &amp;amp;client_addrlength); &lt;span&gt;//创建连接并返回文件描述符（实际进行的三次握手过程）&lt;/span&gt;&lt;br/&gt;            AddFd(epoll_fd, connfd, &lt;span&gt;false&lt;/span&gt;);  &lt;span&gt;//添加到epoll结构中并初始化为LT模式&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(events[i].events &amp;amp; EPOLLIN) &lt;span&gt;//如果客户端有数据过来&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;--&amp;gt;LT Mode: it was triggered once!\n&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;memset&lt;/span&gt;(buf, &lt;span&gt;0&lt;/span&gt;, BUFFER_SIZE); &lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; ret = recv(sockfd, buf, BUFFER_SIZE - &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(ret &amp;lt;= &lt;span&gt;0&lt;/span&gt;)  &lt;span&gt;//读取数据完毕后，关闭当前描述符&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                close(sockfd);&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;get %d bytes of content: %s\n&quot;&lt;/span&gt;, ret, buf);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;something unexpected happened!\n&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/*  ET Work mode features: efficient but potentially dangerous */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/*  ET边缘触发&lt;br/&gt; *  注意：边缘触发由于内核不会频繁通知，所以高效，适合高并发场合，但是处理不当将会导致严重事故&lt;br/&gt;          其通知机制和触发方式参见之前讲解，由于不会重复触发，所以需要处理好缓冲区中的数据，避免脏读脏写或者数据丢失等&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;et_process&lt;/span&gt;&lt;span&gt;(struct epoll_event* events, &lt;span&gt;int&lt;/span&gt; number, &lt;span&gt;int&lt;/span&gt; epoll_fd, &lt;span&gt;int&lt;/span&gt; listen_fd)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; buf[BUFFER_SIZE];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; number; i++)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; sockfd = events[i].data.fd;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(sockfd == listen_fd) &lt;span&gt;//如果有新客户端请求过来，将其添加到内核中的epoll结构中并默认置为ET模式&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;sockaddr_in&lt;/span&gt; &lt;span&gt;client_address&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;socklen_t&lt;/span&gt; client_addrlength = &lt;span&gt;sizeof&lt;/span&gt;(client_address);&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; connfd = accept(listen_fd, (struct sockaddr*)&amp;amp;client_address, &amp;amp;client_addrlength);&lt;br/&gt;            AddFd(epoll_fd, connfd, &lt;span&gt;true&lt;/span&gt;); &lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(events[i].events &amp;amp; EPOLLIN) &lt;span&gt;//如果客户端有数据过来&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;--&amp;gt;ET Mode: it was triggered once\n&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;//循环等待&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;memset&lt;/span&gt;(buf, &lt;span&gt;0&lt;/span&gt;, BUFFER_SIZE);&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; ret = recv(sockfd, buf, BUFFER_SIZE - &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt;(ret &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt;(errno == EAGAIN || errno == EWOULDBLOCK) &lt;span&gt;//通过EAGAIN检测，确认数据读取完毕&lt;/span&gt;&lt;br/&gt;                    {&lt;br/&gt;                        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;--&amp;gt;wait to read!\n&quot;&lt;/span&gt;);&lt;br/&gt;                        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;                    close(sockfd);&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ret == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;//数据读取完毕，关闭描述符&lt;/span&gt;&lt;br/&gt;                {&lt;br/&gt;                    close(sockfd);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;//数据未读取完毕，继续读取&lt;/span&gt;&lt;br/&gt;                {&lt;br/&gt;                    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;get %d bytes of content: %s\n&quot;&lt;/span&gt;, ret, buf);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;something unexpected happened!\n&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;* argv[])&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* ip = &lt;span&gt;&quot;10.0.76.135&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; port = &lt;span&gt;9999&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//套接字设置这块，参见https://www.gta.ufrj.br/ensino/eel878/sockets/sockaddr_inman.html&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; ret = &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;sockaddr_in&lt;/span&gt; &lt;span&gt;address&lt;/span&gt;;&lt;/span&gt; &lt;br/&gt;    bzero(&amp;amp;address, &lt;span&gt;sizeof&lt;/span&gt;(address));&lt;br/&gt;    address.sin_family = AF_INET;&lt;br/&gt;    inet_pton(AF_INET, ip, &amp;amp;address.sin_addr);&lt;br/&gt;    address.sin_port = htons(port);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; listen_fd = socket(PF_INET, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;);    &lt;span&gt;//创建套接字并返回描述符&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(listen_fd &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;fail to create socket!\n&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    ret = bind(listen_fd, (struct sockaddr*)&amp;amp;address, &lt;span&gt;sizeof&lt;/span&gt;(address)); &lt;span&gt;//绑定本机&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(ret == &lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;fail to bind socket!\n&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    ret = listen(listen_fd, &lt;span&gt;5&lt;/span&gt;); &lt;span&gt;//在端口上监听&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(ret == &lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;fail to listen socket!\n&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epoll_event&lt;/span&gt; &lt;span&gt;events&lt;/span&gt;[&lt;span&gt;MAX_EVENT_NUMBER&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; epoll_fd = epoll_create(&lt;span&gt;5&lt;/span&gt;);  &lt;span&gt;//在内核中创建epoll实例，flag为5只是为了分配空间用，实际可以不用带&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(epoll_fd == &lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;fail to create epoll!\n&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    AddFd(epoll_fd, listen_fd, &lt;span&gt;true&lt;/span&gt;); &lt;span&gt;//添加文件描述符到epoll对象中&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER, &lt;span&gt;-1&lt;/span&gt;); &lt;span&gt;//拿出就绪的文件描述符并进行处理&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(ret &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;epoll failure!\n&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(ENABLE_ET) &lt;span&gt;//ET处理方式&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            et_process(events, ret, epoll_fd, listen_fd);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;  &lt;span&gt;//LT处理方式&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            lt_process(events, ret, epoll_fd, listen_fd);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    close(listen_fd); &lt;span&gt;//退出监听&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细的注释我都已经写上去了，这就是整个 epoll server 端全部源码了，仅仅只有 200 行左右，是不是很惊讶。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来让我们来测试下性能，看看能够达到我们所说的单机百万并发吗？其实悄悄的给你说，Netty 底层的 C 语言实现，和这个是差不多的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际测试过程中，由于要实现高并发，那么肯定得使用 ET 模式了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是由于这块内容更多的是 Linux 配置的调整，且前人已经有了具体的文章了，所以这里就不做过多的解释了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们主要是利用 VMware 虚拟机一主三从，参数调优，来实现百万并发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此块内容由于比较复杂，先暂时放一放，后续将会搭建环境并对此手写 server 进行压测。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>031e78b49ca1629181a54f6ce19dfcfb</guid>
<title>SQL优化万能公式：5 大步骤 + 10 个案例</title>
<link>https://toutiao.io/k/4p8xa6s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;pre data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNTc3OTAxOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/3TjM42ia414lQnF4ENA0riaCzVYHKsQYcR4sj5tjzqb0TTuia6tibAEYom6NZBM72txYbZ6pPnyXBkbIJKwL7GPrIw/0?wx_fmt=png&quot; data-nickname=&quot;架构师修行之路&quot; data-alias=&quot;jiagoushixiuxing&quot; data-signature=&quot;一个坚持把架构做到极致的技术人，热衷于互联网技术。混迹互联网十几年，热衷于高性能、高并发、分布式技术领域的研究。 不忘初心，每篇文章都精心打磨，助力10万程序员成为更合格的架构师。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;109777&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;1&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在应用开发的早期，数据量少，开发人员开发功能时更重视功能上的实现，随着生产数据的增长，很多SQL语句开始暴露出性能问题，对生产的影响也越来越大，有时可能这些有问题的SQL就是整个系统性能的瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;109777&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;2&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SQL优化一般步骤&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、通过慢查日志等定位那些执行效率较低的SQL语句&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、explain 分析SQL的执行计划&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要重点关注type、rows、filtered、extra。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;type由上至下，效率越来越高&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ALL 全表扫描&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;index 索引全扫描&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;range 索引范围扫描，常用语&amp;lt;,&amp;lt;=,&amp;gt;=,between,in等操作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;const/system 单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;null MySQL不访问任何表或索引，直接返回结果&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;虽然上至下，效率越来越高，但是根据cost模型，假设有两个索引idx1(a, b, c),idx2(a, c)，SQL为&quot;select * from t where a = 1 and b in (1, 2) order by c&quot;;如果走idx1，那么是type为range，如果走idx2，那么type是ref；当需要扫描的行数，使用idx2大约是idx1的5倍以上时，会用idx1，否则会用idx2&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Extra&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Using filesort：MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Using temporary：使用了临时表保存中间结果，性能特别差，需要重点优化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Using index：表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，意味着无法直接通过索引查找来查询到符合条件的数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Using index condition：MySQL5.6之后新增的ICP，using index condtion就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、show profile 分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;了解SQL执行的线程的状态及消耗的时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;默认是关闭的，开启语句“set profiling = 1;”&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;SHOW&lt;/span&gt; &lt;span&gt;PROFILES&lt;/span&gt; ;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;SHOW&lt;/span&gt; PROFILE &lt;span&gt;FOR&lt;/span&gt; &lt;span&gt;QUERY&lt;/span&gt;  #{&lt;span&gt;id&lt;/span&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、trace&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;trace分析优化器如何选择执行计划，通过trace文件能够进一步了解为什么优惠券选择A执行计划而不选择B执行计划。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;set&lt;/span&gt; optimizer_trace=&lt;span&gt;&quot;enabled=on&quot;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;set&lt;/span&gt; optimizer_trace_max_mem_size=&lt;span&gt;1000000&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; information_schema.optimizer_trace;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、确定问题并采用相应的措施&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;109777&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;场景分析&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;案例1、最左匹配&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;索引&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;KEY &lt;span&gt;`idx_shopid_orderno`&lt;/span&gt; (&lt;span&gt;`shop_id`&lt;/span&gt;,&lt;span&gt;`order_no`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SQL语句&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; _t &lt;span&gt;where&lt;/span&gt; orderno=&lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询匹配从左往右匹配，要使用order_no走索引，必须查询条件携带shop_id或者索引(shop_id,order_no)调换前后顺序&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;案例2、隐式转换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;索引&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;KEY &lt;span&gt;`idx_mobile`&lt;/span&gt; (&lt;span&gt;`mobile`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SQL语句&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; _user &lt;span&gt;where&lt;/span&gt; mobile=&lt;span&gt;12345678901&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;隐式转换相当于在索引上做运算，会让索引失效。mobile是字符类型，使用了数字，应该使用字符串匹配，否则MySQL会用到隐式替换，导致索引失效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;案例3、大分页&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;索引&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;KEY &lt;span&gt;`idx_a_b_c`&lt;/span&gt; (&lt;span&gt;`a`&lt;/span&gt;, &lt;span&gt;`b`&lt;/span&gt;, &lt;span&gt;`c`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SQL语句&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; _t &lt;span&gt;where&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; b = &lt;span&gt;2&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于大分页的场景，可以优先让产品优化需求，如果没有优化的，有如下两种优化方式，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一种是把上一次的最后一条数据，也即上面的c传过来，然后做“c &amp;lt; xxx”处理，但是这种一般需要改接口协议，并不一定可行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一种是采用延迟关联的方式进行处理，减少SQL回表，但是要记得索引需要完全覆盖才有效果，SQL改动如下&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;select&lt;/span&gt; t1.* &lt;span&gt;from&lt;/span&gt; _t t1, (&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; _t &lt;span&gt;where&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; b = &lt;span&gt;2&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;) t2 &lt;span&gt;where&lt;/span&gt; t1.id = t2.id;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;案例4、in + order by&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;索引&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;KEY &lt;span&gt;`idx_shopid_status_created`&lt;/span&gt; (&lt;span&gt;`shop_id`&lt;/span&gt;, &lt;span&gt;`order_status`&lt;/span&gt;, &lt;span&gt;`created_at`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SQL语句&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; _order &lt;span&gt;where&lt;/span&gt; shop_id = &lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; order_status &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; created_at &lt;span&gt;desc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;in查询在MySQL底层是通过n*m的方式去搜索，类似union，但是效率比union高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;in查询在进行cost代价计算时（代价 = 元组数 * IO平均值），是通过将in包含的数值，一条条去查询获取元组数的，因此这个计算过程会比较的慢，所以MySQL设置了个临界值(eq_range_index_dive_limit)，5.6之后超过这个临界值后该列的cost就不参与计算了。因此会导致执行计划选择不准确。默认是200，即in条件超过了200个数据，会导致in的代价计算存在问题，可能会导致Mysql选择的索引不准确。微信搜索公众号：Java项目精选，回复：java 领取资料 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;处理方式，可以(order_status, created_at)互换前后顺序，并且调整SQL为延迟关联。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;案例5、范围查询阻断，后续字段不能走索引&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;索引&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;KEY &lt;span&gt;`idx_shopid_created_status`&lt;/span&gt; (&lt;span&gt;`shop_id`&lt;/span&gt;, &lt;span&gt;`created_at`&lt;/span&gt;, &lt;span&gt;`order_status`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SQL语句&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; _order &lt;span&gt;where&lt;/span&gt; shop_id = &lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; created_at &amp;gt; &lt;span&gt;&#x27;2021-01-01 00:00:00&#x27;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; order_status = &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;范围查询还有“IN、between”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;案例6、不等于、不包含不能用到索引的快速搜索。（可以用到ICP）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; _order &lt;span&gt;where&lt;/span&gt; shop_id=&lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; order_status &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; _order &lt;span&gt;where&lt;/span&gt; shop_id=&lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; order_status != &lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在索引上，避免使用NOT、!=、&amp;lt;&amp;gt;、!&amp;lt;、!&amp;gt;、NOT EXISTS、NOT IN、NOT LIKE等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;案例7、优化器选择不使用索引的情况&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果要求访问的数据量很小，则优化器还是会选择辅助索引，但是当访问的数据占整个表中数据的蛮大一部分时（一般是20%左右），优化器会选择通过聚集索引来查找数据。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; _order &lt;span&gt;where&lt;/span&gt;  order_status = &lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询出所有未支付的订单，一般这种订单是很少的，即使建了索引，也没法使用索引。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;案例8、复杂查询&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;(amt) &lt;span&gt;from&lt;/span&gt; _t &lt;span&gt;where&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; b &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &lt;span&gt;and&lt;/span&gt; c &amp;gt; &lt;span&gt;&#x27;2020-01-01&#x27;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; _t &lt;span&gt;where&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; b &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &lt;span&gt;and&lt;/span&gt; c &amp;gt; &lt;span&gt;&#x27;2020-01-01&#x27;&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果是统计某些数据，可能改用数仓进行解决；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是业务上就有那么复杂的查询，可能就不建议继续走SQL了，而是采用其他的方式进行解决，比如使用ES等进行解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;案例9、asc和desc混用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; _t &lt;span&gt;where&lt;/span&gt; a=&lt;span&gt;1&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; b &lt;span&gt;desc&lt;/span&gt;, c &lt;span&gt;asc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;desc 和asc混用时会导致索引失效&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;案例10、大数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于推送业务的数据存储，可能数据量会很大，如果在方案的选择上，最终选择存储在MySQL上，并且做7天等有效期的保存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么需要注意，频繁的清理数据，会照成数据碎片，需要联系DBA进行数据碎片处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：cnblogs.com/powercto/p/14410128.html&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;109531&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;END&lt;/strong&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;47&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/bsIqp34icDAgp8Jl95vOP1MiaEfSueibqnDQjkFaq7Uf31BNwpg6gSy15a1JV7wmibt1KQwA4n5ViaJQUMJwAYoJapQ/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>72a09b41a0b5d3886da200730c7154a2</guid>
<title>终极 C++避坑指南</title>
<link>https://toutiao.io/k/8m9f19e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：boreholehu，腾讯 WXG 后台开发工程师&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++是一门古老的语言，但仍然在不间断更新中，不断引用新特性。但与此同时 C++又甩不掉巨大的历史包袱，并且 C++的设计初衷和理念造成了 C++异常复杂，还出现了很多不合理的“缺陷”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要有 3 个目的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;总结一些 C++晦涩难懂的语法现象，解释其背后原因，作为防踩坑之用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;和一些其他的编程语言进行比较，列举它们的优劣；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发表一些我自己作为 C++程序员的看法和感受。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;来自 C 语言的历史包袱&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++有一个很大的历史包袱，就是 C 语言。C 语言诞生时间很早，并且它是为了编写 OS 而诞生的，语法更加底层。有人说，C 并不是针对程序员友好的语言，而是针对编译期友好的语言。有些场景在 C 语言本身可能并没有什么不合理，但放到 C++当中会“爆炸”，或者说，会迅速变成一种“缺陷”，让人异常费解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++在演变过程中一直在吸收其他语言的优势，不断提供新的语法、工具来进行优化。但为了兼容性（不仅仅是语法的兼容，还有一些设计理念的兼容），还是会留下很多坑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数组&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组本身其实没有什么问题，这种语法也非常常用，主要是表示连续一组相同的数据构成的集合。但数组类型在待遇上却和其他类型（比如说结构体）非常不一样。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数组的复制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，结构体类型是可以很轻松的复制的，比如说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;St&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; m1;&lt;br/&gt;  &lt;span&gt;double&lt;/span&gt; m2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  St st1;&lt;br/&gt;  St st2 = st1; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;  St st3;&lt;br/&gt;  st1 = st3; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但数组却并不可以，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; arr1[&lt;span&gt;5&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; arr2[&lt;span&gt;5&lt;/span&gt;] = arr1; &lt;span&gt;// ERR&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明明这里 arr2 和 arr1 同为&lt;code&gt;int[5]&lt;/code&gt;类型，但是并不支持复制。照理说，数组应当比结构体更加适合复制场景，因为需求是很明确的，就是元素按位复制。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数组类型传参&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于数组不可以复制，导致了数组同样不支持传参，因此我们只能采用“首地址+长度”的方式来传递数组：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; *arr, &lt;span&gt;size_t&lt;/span&gt; size)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; arr[&lt;span&gt;5&lt;/span&gt;];&lt;br/&gt;  f1(arr, &lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而为了方便程序员进行这种方式的传参，C 又做了额外的 2 件事：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;提供一种隐式类型转换，支持将数组类型转换为首元素指针类型（比如说这里 arr 是&lt;code&gt;int[5]&lt;/code&gt;类型，传参时自动转换为&lt;code&gt;int *&lt;/code&gt;类型）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数参数的语法糖，如果在函数参数写数组类型，那么会自动转换成元素指针类型，比如说下面这几种写法都完全等价：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; *arr)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arr[])&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arr[&lt;span&gt;5&lt;/span&gt;])&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arr[&lt;span&gt;100&lt;/span&gt;])&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里非常容易误导人的就在这个语法糖中，&lt;strong&gt;无论中括号里写多少，或者不写，这个值都是会被忽略的&lt;/strong&gt;，要想知道数组的边界，你就必须要通过额外的参数来传递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但通过参数传递这是一种软约束，你无法保证调用者传的就是数组元素个数，这里的危害详见后面“指针偏移”的章节。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分析和思考&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以 C 的数组会出现这种奇怪现象，我猜测，作者考虑的是数组的实际使用场景，是经常会进行切段截取的，也就是说，一个数组类型并不总是完全整体使用，我们可能更多时候用的是其中的一段。举个简单的例子，如果数组是整体复制、传递的话，做数组排序递归的时候会不会很尴尬？首先，排序函数的参数难以书写，因为要指定数组个数，我们总不能针对于 1,2,3,4,5,6,...元素个数的数组都分别写一个排序函数吧？其次，如果取子数组就会复制出一个新数组的话，也就不能对原数组进行排序了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以综合考虑，干脆这里就不支持复制，强迫程序员使用指针+长度这种方式来操作数组，反而更加符合数组的实际使用场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，在 C++中有了引用语法，我们还是可以把数组类型进行传递的，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; (&amp;amp;arr)[&lt;span&gt;5&lt;/span&gt;])&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 必须传int[5]类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; arr1[&lt;span&gt;5&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; arr2[&lt;span&gt;8&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;  f1(arr1); &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;  f1(arr2); &lt;span&gt;// ERR&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但绝大多数的场景似乎都不会这样去用。一些新兴语言（比如说 Go）就注意到了这一点，因此将其进行了区分。在 Go 语言中，区分了“数组”和“切片”的概念，数组就是长度固定的，整体来传递；而切片则类似于首地址+长度的方式传递（只不过没有单独用参数，而是用 len 函数来获取）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;(arr [5]&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;(arr []&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面例子里，f1 就必须传递长度是 5 的数组类型，而 f2 则可以传递任意长度的切片类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 C++其实也注意到了这一点，但由于兼容问题，它只能通过 STL 提供容器的方式来解决，&lt;code&gt;std::array&lt;/code&gt;就是定长数组，而&lt;code&gt;std::vector&lt;/code&gt;就是变长数组，跟上述 Go 语言中的数组和切片的概念是基本类似的。这也是 C++中更加推荐使用 vector 而不是 C 风格数组的原因。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类型说明符&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类型不是从左向右说明&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C/C++中的类型说明符其实设计得很不合理，除了最简单的变量定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a; &lt;span&gt;// 定义一个int类型的变量a&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个还是很清晰明了的，但稍微复杂一点的，就比较奇怪了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; arr[&lt;span&gt;5&lt;/span&gt;]; &lt;span&gt;// 定义一个int[5]类型的变量arr&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;arr 明明是&lt;code&gt;int[5]&lt;/code&gt;类型，但是这里的 int 和[5]却并没有写到一起，如果这个还不算很容易造成迷惑的话，那来看看下面的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; *a1[&lt;span&gt;5&lt;/span&gt;]; &lt;span&gt;// 定义了一个数组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; (*a2)[&lt;span&gt;5&lt;/span&gt;]; &lt;span&gt;// 定义了一个指针&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a1 是&lt;code&gt;int *[5]&lt;/code&gt;类型，表示 a1 是个数组，有 5 个元素，每个元素都是指针类型的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a2 是&lt;code&gt;int (*)[5]&lt;/code&gt;类型，是一个指针，指针指向了一个&lt;code&gt;int[5]&lt;/code&gt;类型的数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里离谱的就在这个&lt;code&gt;int (*)[5]&lt;/code&gt;类型上，也就是说，“指向&lt;code&gt;int[5]&lt;/code&gt;类型的指针”并不是&lt;code&gt;int[5]*&lt;/code&gt;，而是&lt;code&gt;int (*)[5]&lt;/code&gt;，类型说明符是从里往外描述的，而不是从左往右。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类型说明符同时承担了动作语义&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的另一个问题就是，C/C++并没有把“定义变量”和“变量的类型”这两件事分开，而是用类型说明符来同时承担了。也就是说，“定义一个 int 类型变量”这件事中，int 这一个关键字不仅表示“int 类型”，还表示了“定义变量”这个意义。这件事放在定义变量这件事上可能还不算明显，但放到定义函数上就不一样了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个例子中，int 和()共同表示了“定义函数”这个意义。也就是说，看到 int 这个关键字，并不一定是表示定义变量，还有可能是定义函数，定义函数时 int 表示了函数的返回值的类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是由于 C/C++中，类型说明符具有多重含义，才造成一些复杂语法简直让人崩溃，比如说定义高阶函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 输入一个函数，输出这个函数的导函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;double&lt;/span&gt; (*DC(&lt;span&gt;double&lt;/span&gt; (*)(&lt;span&gt;double&lt;/span&gt;)))(&lt;span&gt;double&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DC 是一个函数，它有一个参数，是&lt;code&gt;double (*)(double)&lt;/code&gt;类型的函数指针，它的返回值是一个&lt;code&gt;double (*)(double)&lt;/code&gt;类型的函数指针。但从直观性上来说，上面的写法完全毫无可读性，如果没有那一行注释，相信大家很难看得出这个语法到底是在做什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++引入了返回值右置的语法，从一定程度上可以解决这个问题：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;auto&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;auto&lt;/span&gt; &lt;span&gt;DC&lt;/span&gt;&lt;span&gt;(&lt;span&gt;auto&lt;/span&gt; (*)(&lt;span&gt;double&lt;/span&gt;) -&amp;gt; &lt;span&gt;double&lt;/span&gt;)&lt;/span&gt; -&amp;gt; &lt;span&gt;auto&lt;/span&gt; &lt;span&gt;(*)&lt;/span&gt;&lt;span&gt;(&lt;span&gt;double&lt;/span&gt;)&lt;/span&gt; -&amp;gt; &lt;span&gt;double&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但用 auto 作为占位符仍然还是有些突兀和晦涩的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;将类型符和动作语义分离的语言&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一看其他语言是如何弥补这个缺陷的，最简单的做法就是把“类型”和“动作”这两件事分开，用不同的关键字来表示。
Go 语言：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 定义变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a1 &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a2 []&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a3 *&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a4 []*&lt;span&gt;int&lt;/span&gt; &lt;span&gt;// 元素为指针的数组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a5 *[]&lt;span&gt;int&lt;/span&gt; &lt;span&gt;// 数组的指针&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 定义函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 高阶函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;DC&lt;/span&gt;&lt;span&gt;(f &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;float64&lt;/span&gt;)&lt;/span&gt;&lt;span&gt;float64&lt;/span&gt;) &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;span&gt;float64&lt;/span&gt;)&lt;/span&gt;&lt;span&gt;float64&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Swift 语言：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 定义变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a1: &lt;span&gt;Int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a2: [&lt;span&gt;Int&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 定义函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span&gt;Int&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 高阶函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;DC&lt;/span&gt;&lt;span&gt;(f: &lt;span&gt;(Double, Double)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;-&amp;gt;&lt;span&gt;Double&lt;/span&gt;) -&amp;gt; (&lt;span&gt;Double&lt;/span&gt;, &lt;span&gt;Double&lt;/span&gt;)-&amp;gt;&lt;span&gt;Double&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JavaScript 语言：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 定义变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a1 = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a2 = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;// 定义函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 高阶函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;DC&lt;/span&gt;(&lt;span&gt;f&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;指针偏移&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指针的偏移运算让指针操作有了较大的自由度，但同时也会引入越界问题：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; arr[&lt;span&gt;5&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; *p1 = arr + &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;*p1 = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;// 越界&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; *p2 = &amp;amp;a;&lt;br/&gt;a[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;10&lt;/span&gt;; &lt;span&gt;// 越界&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，指针的偏移是完全随意的，静态检测永远不会去判断当前指针的位置是否合法。这个与之前章节提到的数组传参的问题结合起来，会更加容易发生并且更加不容易发现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; *arr, &lt;span&gt;size_t&lt;/span&gt; size)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; arr[&lt;span&gt;5&lt;/span&gt;];&lt;br/&gt;  f(arr, &lt;span&gt;6&lt;/span&gt;); &lt;span&gt;// 可能导致越界&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为参数中的值和数组的实际长度并没有要求强一致。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他语言的指针&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在其他语言中，有的语言（例如 java、C#）直接取消了指针的相关语法，但由此就必须引入“值类型”和“引用类型”的概念。
例如在 java 中，存在“实”和“名”的概念：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;10&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt;[] arr2 = arr; &lt;span&gt;// “名”的复制，浅复制&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt;[] arr3 = Arrays.copyOf(arr, arr.length); &lt;span&gt;// 用库方法进行深复制&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上来说，这个“名”就是栈空间上的一个指针，而“实”则是堆空间中的实际数据。如果取消指针概念的话，就要强行区分哪些类型是“值类型”，会完全复制，哪些是“引用类型”，只会浅复制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C#中的结构体和类的概念恰好如此，结构体是值类型，整体复制，而类是引用类型，要用库函数来复制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而还有一些语言保留了指针的概念（例如 Go、Swift），但仅仅用于明确指向和引用的含义，并不提供指针偏移运算，来防止出现越界问题。例如 go 中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; a &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; p *&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  p = &amp;amp;a &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;  r1 := *p &lt;span&gt;// 直接解指针是OK的&lt;/span&gt;&lt;br/&gt;  r2 := *(p + &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;// ERR，指针不可以偏移&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;swift 中虽然仍然支持指针，但非常弱化了它的概念，从语法本身就能看出，不到迫不得已并不推荐使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;(&lt;span&gt;_&lt;/span&gt; ptr: UnsafeMutablePointer&amp;lt;Int&amp;gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  ptr.pointee += &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// 给指针所指向的值加1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; a: &lt;span&gt;Int&lt;/span&gt; = &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;  f1(&amp;amp;a)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OC 中的指针更加特殊和“奇葩”，首先，OC 完全保留了 C 中的指针用法，而额外扩展的“类”类型则不允许出现在栈中，也就是说，所有对象都强制放在堆中，栈上只保留指针对其引用。虽然 OC 中的指针仍然是 C 指针，但由于操作对象的“奇葩”语法，倒是并不需要太担心指针偏移的问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt; demo() {&lt;br/&gt;  &lt;span&gt;NSObject&lt;/span&gt; *obj = [[&lt;span&gt;NSObject&lt;/span&gt; alloc] init];&lt;br/&gt;  &lt;span&gt;// 例如调用obj的description方法&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;NSString&lt;/span&gt; *desc = [obj description];&lt;br/&gt;  &lt;span&gt;// 指针仍可偏移，但几乎不会有人这样来写：&lt;/span&gt;&lt;br/&gt;  [(obj+&lt;span&gt;1&lt;/span&gt;) description]; &lt;span&gt;// 也会越界&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;隐式类型转换&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;隐式类型转换在一些场景下会让程序更加简洁，降低代码编写难度。比如说下面这些场景：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;double&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;// int-&amp;gt;double&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; b = a * a; &lt;span&gt;// double-&amp;gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;&#x27;5&#x27;&lt;/span&gt; - &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;; &lt;span&gt;// char-&amp;gt;int&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是有的时候隐式类型转化却会引发很奇怪的问题，比如说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; ARR_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; arr[&lt;span&gt;5&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; size = ARR_SIZE(arr); &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arr[])&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; size = ARR_SIZE(arr); &lt;span&gt;// WRONG&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合之前所说，函数参数中的数组其实是数组首元素指针的语法糖，所以&lt;code&gt;f2&lt;/code&gt;中的&lt;code&gt;arr&lt;/code&gt;其实是&lt;code&gt;int *&lt;/code&gt;类型，这时候再对其进行&lt;code&gt;sizeof&lt;/code&gt;运算，结果是指针的大小，而并非数组的大小。如果程序员不能意识到这里发生了&lt;code&gt;int [N]&lt;/code&gt;-&amp;gt;&lt;code&gt;int *&lt;/code&gt;的隐式类型转换，那么就可能出错。
还有一些隐式类型转换也很离谱，比如说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; b = a &amp;gt; &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;// 可能原本想写a / 2，把/写成了&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里发生的隐式转换是 bool-&amp;gt;int，同样可能不符合预期。关于布尔类型详见后面章节。
C 中的这些隐式转换可能影响并不算大，但拓展到 C++中就可能有爆炸性的影响，详见后面“隐式构造”和“多态转换”的相关章节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;赋值语句的返回值&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C/C++的赋值语句自带返回值，这一定算得上一大缺陷，在 C 中赋值语句返回值，在 C++中赋值语句返回左值引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这件事造成的最大影响就在&lt;code&gt;=&lt;/code&gt;和&lt;code&gt;==&lt;/code&gt;这两个符号上，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a1, a2;&lt;br/&gt;&lt;span&gt;bool&lt;/span&gt; b = a1 = a2;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里原本想写&lt;code&gt;b = a1 == a2&lt;/code&gt;，但是错把&lt;code&gt;==&lt;/code&gt;写成了&lt;code&gt;=&lt;/code&gt;，但编译是可以完全通过的，因为&lt;code&gt;a1 = a2&lt;/code&gt;本身返回了 a1 的引用，再触发一次隐式类型转换，把 bool 转化为 int（这里详见后面非布尔类型的布尔意义章节）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更有可能的是写在 if 表达式中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (a = &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，&lt;code&gt;a = 1&lt;/code&gt;执行后 a 的值变为 1，返回的 a 的值就是 1，所以这里的&lt;code&gt;if&lt;/code&gt;变成了恒为真。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++为了兼容这一特性，又不得不要求自定义类型要定义赋值函数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Test &amp;amp;&lt;span&gt;operator&lt;/span&gt; =(&lt;span&gt;const&lt;/span&gt; Test &amp;amp;); &lt;span&gt;// 拷贝赋值函数&lt;/span&gt;&lt;br/&gt;  Test &amp;amp;&lt;span&gt;operator&lt;/span&gt; =(Test &amp;amp;&amp;amp;); &lt;span&gt;// 移动赋值函数&lt;/span&gt;&lt;br/&gt;  Test &amp;amp;&lt;span&gt;operator&lt;/span&gt; =(&lt;span&gt;int&lt;/span&gt; a); &lt;span&gt;// 其他的赋值函数&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里赋值函数的返回值强制要求定义为当前类型的左值引用，一来会让人觉得有些无厘头，记不住这里的写法，二来在发生继承关系的时候非常容易忘记处理父类的赋值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Base&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Base &amp;amp;&lt;span&gt;operator&lt;/span&gt; =(&lt;span&gt;const&lt;/span&gt; Base &amp;amp;);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Ch&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Base {&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Ch &amp;amp;opeartor =(&lt;span&gt;const&lt;/span&gt; Ch &amp;amp;ch) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;-&amp;gt;Base::&lt;span&gt;operator&lt;/span&gt; =(ch);&lt;br/&gt;    &lt;span&gt;// 或者写成 *static_cast&amp;lt;Base *&amp;gt;(this) = ch;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他语言的赋值语句&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;古老一些的 C 系扩展语言基本还是保留了赋值语句的返回值（例如 java、OC），但一些新兴语言（例如 Go、Swift）则是直接取消了赋值语句的返回值，比如说在 swift 中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; b: &lt;span&gt;Int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;: &lt;span&gt;Int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;c&lt;/span&gt; = (b = a) &lt;span&gt;// ERR&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;b = a&lt;/code&gt;会返回&lt;code&gt;Void&lt;/code&gt;，所以再赋值给 c 时会报错&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;非布尔类型的布尔意义&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在原始 C 当中，其实并没有“布尔”类型，所有表示是非都是用 int 来做的。所以，int 类型就赋予了布尔意义，0 表示 false，非 0 都表示 true，由此也诞生了很多“野路子”的编程技巧：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; *p;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (!p) {} &lt;span&gt;// 指针→bool&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;) {} &lt;span&gt;// int→bool&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; n;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (~&lt;span&gt;scanf&lt;/span&gt;(&lt;span&gt;&quot;%d&quot;&lt;/span&gt;, &amp;amp;n)) {} &lt;span&gt;// int→bool&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有表示判断逻辑的语法，都可以用非布尔类型的值传入，这样的写法其实是很反人类直觉的，更严重的问题就是与 true 常量比较的问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; judge = &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;// 用了int表示了判断逻辑&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (judge == &lt;span&gt;true&lt;/span&gt;) {} &lt;span&gt;// 但这里的条件其实是false，因为true会转为1，2 == 1是false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是由于非布尔类型具有了布尔意义，才会造成一些非常反直觉的事情，比如说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;true&lt;/span&gt; + &lt;span&gt;true&lt;/span&gt; != &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;!!&lt;span&gt;2&lt;/span&gt; == &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;(&lt;span&gt;2&lt;/span&gt; == &lt;span&gt;true&lt;/span&gt;) == &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他语言的布尔类型&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上除了 C++和一些弱类型脚本语言（比如 js）以外，其他语言都取消了非布尔类型的布尔意义，要想转换为布尔值，一定要通过布尔运算才可以，例如在 Go 中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  a := &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// int类型&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (a) { &lt;span&gt;// ERR，if表达式要求布尔类型&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (a != &lt;span&gt;0&lt;/span&gt;) { &lt;span&gt;// OK，通过逻辑运算得到布尔类型&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样其实更符合直觉，也可以一定程度上避免出现写成类似于&lt;code&gt;if (a = 1)&lt;/code&gt;出现的问题。C++中正是由于“赋值语句有返回值”和“非布尔类型有布尔意义”同时生效，才会在这里出现问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解指针类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 C/C++到底是强类型语言还是弱类型语言，业界一直争论不休。有人认为，变量的类型从定义后就不能改变，并且每个变量都有固定的类型，所以 C/C++应该是强类型语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有人持相反意见，是因为这个类型，仅仅是“表面上”不可变，但其实是可变的，比如说看下面例程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;300&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;uint8_t&lt;/span&gt; *p = &lt;span&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span&gt;uint8_t&lt;/span&gt; *&amp;gt;(&amp;amp;a);&lt;br/&gt;*p = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// 这里其实就是把a变成了uint8_t类型&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根源就在于，指针的解类型是可以改变的，原本&lt;code&gt;int&lt;/code&gt;类型的变量，我们只要把它的首地址保存下来，然后按照另一种类型来解，那么就可以做到“改变 a 的类型”的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就意味着，指针类型是不安全的，因为你不一定能保证现在解指针的类型和指针指向数据的真实类型是匹配的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有更野一点的操作，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;S1&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  short a, b;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;S2&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  S2 s2;&lt;br/&gt;  S1 *p = &lt;span&gt;reinterpret_cast&lt;/span&gt;&amp;lt;S1 *&amp;gt;(&amp;amp;s2);&lt;br/&gt;  p-&amp;gt;a = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  p-&amp;gt;b = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; s2.a; &lt;span&gt;// 猜猜这里会输出多少？&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的指针类型问题和前面章节提到的指针偏移问题，综合起来就是说 C/C++的指针操作的自由度过高，提升了语言的灵活度，同时也增加了其复杂度。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后置自增/自减&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果仅仅在 C 的角度上，后置自增/自减语法并没有带来太多的副作用，有时候在程序中作为一些小技巧反而可以让程序更加精简，比如说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;AttrCnt&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; count++ &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这个特性继承到 C++后问题就会被放大，比如说下面的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;auto&lt;/span&gt; iter = ve.begin(); iter != ve.end(); iter++) {&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码看似特别正常，但仔细想想，iter 作为一个对象类型，如果后置&lt;code&gt;++&lt;/code&gt;，一定会发生复制。后置&lt;code&gt;++&lt;/code&gt;原本的目的就是在表达式的位置先返回原值，表达式执行完后再进行自增。但如果放在类类型来说，就必须要临时保存一份原本的值。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Element&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;：&lt;br/&gt;  &lt;span&gt;// 前置++&lt;/span&gt;&lt;br/&gt;  Element &amp;amp;&lt;span&gt;operator&lt;/span&gt; ++() {&lt;br/&gt;   ele++;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 后置++&lt;/span&gt;&lt;br/&gt;  Element &lt;span&gt;operator&lt;/span&gt; ++(&lt;span&gt;int&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// 为了最终返回原值，所以必需保存一份快照用于返回&lt;/span&gt;&lt;br/&gt;    Element tmp = *&lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;    ele++;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; tmp;&lt;br/&gt;  }&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; ele;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也从侧面解释了，为什么前置&lt;code&gt;++&lt;/code&gt;要求返回引用，而后置&lt;code&gt;++&lt;/code&gt;则是返回非引用，因为这里需要复制一份快照用于返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，写在 for 循环中的后置&lt;code&gt;++&lt;/code&gt;就会平白无故发生一次复制，又因为返回值没有接收，再被析构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++保留的&lt;code&gt;++&lt;/code&gt;和&lt;code&gt;--&lt;/code&gt;的语义，也是因为它和&lt;code&gt;+=1&lt;/code&gt;或&lt;code&gt;-=1&lt;/code&gt;语义并不完全等价。我们可以用顺序迭代器来解释。对于顺序迭代器（比如说链表的迭代器），&lt;code&gt;++&lt;/code&gt;表示取下一个节点，&lt;code&gt;--&lt;/code&gt;表示取上一个节点。而&lt;code&gt;+n&lt;/code&gt;或者&lt;code&gt;-n&lt;/code&gt;则表示偏移了，这种语义更适合随机访问（所以说随机迭代器支持&lt;code&gt;+=&lt;/code&gt;和&lt;code&gt;-=&lt;/code&gt;，但顺序迭代器只支持&lt;code&gt;++&lt;/code&gt;和&lt;code&gt;--&lt;/code&gt;）。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他语言的自增/自减&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他语言的做法基本分两种，一种就是保留自增/自减语法，但不再提供返回值，也就不用区分前置和后置，例如 Go：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a := &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;a++ &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;b := a++ &lt;span&gt;// ERR，自增语句没有返回值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种就是干脆删除自增/自减语法，只提供普通的操作赋值语句，例如 Swift：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;a++ &lt;span&gt;// ERR，没有这种语法&lt;/span&gt;&lt;br/&gt;a += &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// OK，只能用这种方式自增&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类型长度&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里说的类型长度指的是相同类型在不同环境下长度不一致的情况，下面总结表格&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;32 位环境长度&lt;/th&gt;&lt;th&gt;64 位环境长度&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;int/unsigned&lt;/td&gt;&lt;td&gt;4B&lt;/td&gt;&lt;td&gt;4B&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;long/unsigned long&lt;/td&gt;&lt;td&gt;4B&lt;/td&gt;&lt;td&gt;8B&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;long long/ unsigned long long&lt;/td&gt;&lt;td&gt;8B&lt;/td&gt;&lt;td&gt;8B&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这里出现了 32 位和 64 位环境下长度不一致的情况，C 语言特意提供了&lt;code&gt;stdint.h&lt;/code&gt;头文件(C++中在 cstddef 中引用)，定义了定长类型，例如&lt;code&gt;int64_t&lt;/code&gt;在 32 位环境下其实是&lt;code&gt;long long&lt;/code&gt;，而在 64 位环境下其实是&lt;code&gt;long&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这里的问题点在于：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 并没有定长格式符&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如&lt;code&gt;uint64_t&lt;/code&gt;在 32 位环境下对应的格式符是&lt;code&gt;%llu&lt;/code&gt;，但是在 64 位环境下对应的格式符是&lt;code&gt;%lu&lt;/code&gt;。有一种折中的解决办法是自定义一个宏：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;if&lt;/span&gt;(sizeof(void*) == 8)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; u64 &lt;span&gt;&quot;%lu&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; u64 &lt;span&gt;&quot;%llu&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;uint64_t&lt;/span&gt; a;&lt;br/&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;a=&quot;&lt;/span&gt;u64, a);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这样会让字符串字面量从中间断开，非常不直观。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 类型不一致&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如在 64 位环境下，&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;long long&lt;/code&gt;都是 64 位长，但编译器会识别为不同类型，在一些类型推导的场景会出现和预期不一致的情况，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; func&amp;lt;&lt;span&gt;int64_t&lt;/span&gt;&amp;gt;(&lt;span&gt;int64_t&lt;/span&gt; t) {}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;  func(a); &lt;span&gt;// 会匹配通用模板，而匹配不到特例&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述例子表明，&lt;code&gt;func&amp;lt;int64_t&amp;gt;&lt;/code&gt;和&lt;code&gt;func&amp;lt;long long&amp;gt;&lt;/code&gt;是不同实例，尽管在 64 位环境下&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;long long&lt;/code&gt;真的看不出什么区别，但是编译器就是会识别成不同类型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;格式化字符串&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;格式化字符串算是非常经典的 C 的产物，不仅是 C++，非常多的语言都是支持这种格式符的，例如 java、Go、python 等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 C++中的格式化字符串可以说完全就是 C 的那一套，根本没有任何扩展。换句话说，除了基本数据类型和 0 结尾的字符串以外，其他任何类型都没有用于匹配的格式符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，对于结构体类型、数组、元组类型等等，都没法匹配到格式符：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;double&lt;/span&gt; x, y;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 打印Point&lt;/span&gt;&lt;br/&gt;  Point p {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2.5&lt;/span&gt;};&lt;br/&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;(%lf,%lf)&quot;&lt;/span&gt;, p.x, p.y); &lt;span&gt;// 无法直接打印p&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 打印数组&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; arr[] = {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;};&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%d, &quot;&lt;/span&gt;, arr[i]); &lt;span&gt;// 无法直接打印整个数组&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 打印元组&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;std&lt;/span&gt;::tuple &lt;span&gt;tu&lt;/span&gt;&lt;span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2.5&lt;/span&gt;, &lt;span&gt;&quot;abc&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;(%d,%lf,%s)&quot;&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::get&amp;lt;&lt;span&gt;0&lt;/span&gt;&amp;gt;(tu), &lt;span&gt;std&lt;/span&gt;::get&amp;lt;&lt;span&gt;1&lt;/span&gt;&amp;gt;(tu), &lt;span&gt;std&lt;/span&gt;::get&amp;lt;&lt;span&gt;2&lt;/span&gt;&amp;gt;(tu)); &lt;span&gt;// 无法直接打印整个元组&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这些组合类型，我们就不得不手动去访问内部成员，或者用循环访问，非常不方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对于字符串，还会有一个严重的潜在问题，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; str = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;str.push_back(&lt;span&gt;&#x27;\0&#x27;&lt;/span&gt;);&lt;br/&gt;str.append(&lt;span&gt;&quot;abc&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;32&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;sprintf&lt;/span&gt;(buf, &lt;span&gt;&quot;str=%s&quot;&lt;/span&gt;, str.c_str());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 str 中出现了&lt;code&gt;&#x27;\0&#x27;&lt;/code&gt;，如果用&lt;code&gt;%s&lt;/code&gt;格式符来匹配的话，会在 0 的位置截断，也就是说&lt;code&gt;buf&lt;/code&gt;其实只获取到了&lt;code&gt;str&lt;/code&gt;中的第一个 abc，第二个 abc 就被丢失了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他语言中的格式符&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而一些其他语言则是扩展了格式符功能用于解决上述问题，例如 OC 引入了&lt;code&gt;%@&lt;/code&gt;格式符，用于调用对象的&lt;code&gt;description&lt;/code&gt;方法来拼接字符串：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@interface&lt;/span&gt; &lt;span&gt;Point2D&lt;/span&gt; : &lt;span&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@property&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; x;&lt;br/&gt;&lt;span&gt;@property&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; y;&lt;br/&gt;- (&lt;span&gt;NSString&lt;/span&gt; *)description;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@implementation&lt;/span&gt; &lt;span&gt;Point2D&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;NSString&lt;/span&gt; *)description {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; [[&lt;span&gt;NSString&lt;/span&gt; alloc] initWithFormat:&lt;span&gt;@&quot;(%lf, %lf)&quot;&lt;/span&gt;, &lt;span&gt;self&lt;/span&gt;.x, &lt;span&gt;self&lt;/span&gt;.y];&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; Demo() {&lt;br/&gt;  Point2D *p = [[Point2D alloc] init];&lt;br/&gt;  [p setX:&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;  [p setY:&lt;span&gt;2.5&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;NSLog&lt;/span&gt;(&lt;span&gt;@&quot;p=%@&quot;&lt;/span&gt;, p); &lt;span&gt;// 会调用p的description方法来获取字符串，用于匹配%@&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 Go 语言引入了更加方便的&lt;code&gt;%v&lt;/code&gt;格式符，可以用来匹配任意类型，用它的默认方式打印。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Test &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; m1 &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; m2 &lt;span&gt;float32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  a1 := &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;  a2 := &lt;span&gt;2.6&lt;/span&gt;&lt;br/&gt;  a3 := []&lt;span&gt;int&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;}&lt;br/&gt;  a4 := &lt;span&gt;&quot;123abc&quot;&lt;/span&gt;&lt;br/&gt;  a5 := Test{&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1.5&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;a1=%v, a2=%v, a3=%v, a4=%v, a5=%v\n&quot;&lt;/span&gt;, a1, a2, a3, a4, a5)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python 则是用&lt;code&gt;%s&lt;/code&gt;作为万能格式符来使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;     a1 = &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;     a2 = &lt;span&gt;2.5&lt;/span&gt;&lt;br/&gt;     a3 = &lt;span&gt;&quot;abc123&quot;&lt;/span&gt;&lt;br/&gt;     a4 = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;     print(&lt;span&gt;&quot;%s, %s, %s, %s&quot;&lt;/span&gt;%(a1, a2, a3, a4)) &lt;span&gt;#这里没有特殊格式要求时都可以用%s来匹配&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;枚举&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;枚举类型原本是用于解决固定范围取值的类型表示，但由于在 C 语言中被定义为了整型类型的一种语法糖，导致枚举类型的使用上出现了一些问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 无法前置声明&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;枚举类型无法先声明后定义，例如下面这段代码会编译报错：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Season;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Data&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  Season se; &lt;span&gt;// ERR&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;enum&lt;/span&gt; Season {&lt;br/&gt;  Spring,&lt;br/&gt;  Summer,&lt;br/&gt;  Autumn,&lt;br/&gt;  Winter&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是因为&lt;code&gt;enum&lt;/code&gt;类型是动态选择基础类型的，比如这里只有 4 个取值，那么可能会选取&lt;code&gt;int16_t&lt;/code&gt;，而如果定义的取值范围比较大，或者中间出现大枚举值的成员，那么可能会选取&lt;code&gt;int32_t&lt;/code&gt;或者&lt;code&gt;int64_t&lt;/code&gt;。也就是说，枚举类型如果没定义完，编译期是不知道它的长度的，因此就没法前置声明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++中允许指定枚举的基础类型，制定后可以前置声明:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Season : &lt;span&gt;int&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Data&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  Season se; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;enum&lt;/span&gt; Season : &lt;span&gt;int&lt;/span&gt; {&lt;br/&gt;  Spring,&lt;br/&gt;  Summer,&lt;br/&gt;  Autumn,&lt;br/&gt;  Winter&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你是在调别人写的库的时候，人家的枚举没有指定基础类型的话，那你也没辙了，就是不能前置声明。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 无法确认枚举值的范围&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，我没有办法判断某个值是不是合法的枚举值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Season {&lt;br/&gt;  Spring,&lt;br/&gt;  Summer,&lt;br/&gt;  Autumn,&lt;br/&gt;  Winter&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Season s = &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;Season&amp;gt;(&lt;span&gt;5&lt;/span&gt;); &lt;span&gt;// 不会报错&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 枚举值可以相同&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Test {&lt;br/&gt;  Ele1 = &lt;span&gt;10&lt;/span&gt;,&lt;br/&gt;  Ele2,&lt;br/&gt;  Ele3 = &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;bool&lt;/span&gt; judge = (Ele1 == Ele3); &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. C 风格的枚举还存在“成员名称全局有效”和“可以隐式转换为整型”的缺陷&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但因为 C++提供了&lt;code&gt;enum class&lt;/code&gt;风格的枚举类型，解决了这两个问题，因此这里不再额外讨论。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;宏&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;宏这个东西，完全就是针对编译器友好的，编译器非常方便地在宏的指导下，替换源代码中的内容。但这个玩意对程序员（尤其是阅读代码的人）来说是极其不友好的，由于是预处理指令，因此任何的静态检测均无法生效。一个经典的例子就是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; MUL(x, y) x * y&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a = MUL(&lt;span&gt;1&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;4&lt;/span&gt;); &lt;span&gt;// 11&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为宏就是简单粗暴地替换而已，并没有任何逻辑判断在里面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;宏因为它很“好用”，所以非常容易被滥用，下面列举了一些宏滥用的情况供参考：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 用宏来定义类成员&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; DEFAULT_MEM     \&lt;br/&gt;public:                 \&lt;br/&gt;int GetX() {return x_;} \&lt;br/&gt;private:                \&lt;br/&gt;int x_;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;DEFAULT_MEM;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种用法相当于屏蔽了内部实现，对阅读者非常不友好，与此同时加不加 DEFAULT_MEM 是一种软约束，实际开发时极容易出错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如这种的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; SINGLE_INST(class_name)                        \&lt;br/&gt; public:                                               \&lt;br/&gt;  static class_name &amp;amp;GetInstance() {                   \&lt;br/&gt;    static class_name instance;                        \&lt;br/&gt;    return instance;                                   \&lt;br/&gt;  }                                                    \&lt;br/&gt;  class_name(const class_name&amp;amp;) = delete;              \&lt;br/&gt;  class_name &amp;amp;operator =(const class_name &amp;amp;) = delete; \&lt;br/&gt; private:                                              \&lt;br/&gt;  class_name();&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  SINGLE_INST(Test)&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这位同学，我理解你是想封装一下单例的实现，但咱是不是可以考虑一下更好的方式？（比如用模板）&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 用宏来屏蔽参数&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; strcpy_s(dst, dst_buf_size, src) strcpy(dst, src)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这位同学，咱要是真想写一个安全版本的函数，咱就好好去判断 dst_buf_size 如何？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 用宏来拼接函数处理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; COPY_IF_EXSITS(dst, src, field) \&lt;br/&gt;do {                                    \&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (src.has_##field()) {              \&lt;br/&gt;    dst.set_##field(dst.field());       \&lt;br/&gt;  }                                     \&lt;br/&gt;} while (false)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Pb1 pb1;&lt;br/&gt;  Pb2 pb2;&lt;br/&gt;&lt;br/&gt;  COPY_IF_EXSITS(pb2, pb1, f1);&lt;br/&gt;  COPY_IF_EXSITS(pb2, pb1, f2);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种用宏来做函数名的拼接看似方便，但最容易出的问题就是类型不一致，加入&lt;code&gt;pb1&lt;/code&gt;和&lt;code&gt;pb2&lt;/code&gt;中虽然都有&lt;code&gt;f1&lt;/code&gt;这个字段，但类型不一样，那么这样用就可能造成类型转换。试想&lt;code&gt;pb1.f1&lt;/code&gt;是&lt;code&gt;uint64_t&lt;/code&gt;类型，而&lt;code&gt;pb2.f1&lt;/code&gt;是&lt;code&gt;uint32_t&lt;/code&gt;类型，这样做是不是有可能造成数据的截断呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 用宏来改变语法风格&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; IF(con) &lt;span&gt;if&lt;/span&gt; (con) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; END_IF }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; ELIF(con) } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (con) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; ELSE } &lt;span&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;  IF(a &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    Process1();&lt;br/&gt;  ELIF(a &amp;lt; &lt;span&gt;-3&lt;/span&gt;)&lt;br/&gt;    Process2();&lt;br/&gt;  &lt;span&gt;ELSE&lt;br/&gt;    &lt;span&gt;Process3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这位同学你到底是写 python 写惯了不适应 C 语法呢，还是说你为了让代码扫描工具扫不出来你的圈复杂度才出此下策的呢~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;共合体&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共合体的所有成员共用内存空间，也就是说它们的首地址相同。在很多人眼中，共合体仅仅在“多选一”的场景下才会使用，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;union&lt;/span&gt; QueryKey {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; name[&lt;span&gt;16&lt;/span&gt;];&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;Query&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; QueryKey &amp;amp;key)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上例中用于查找某个数据的 key，可以通过 id 查找，也可以通过 name，但只能二选一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种场景确实可以使用共合体来节省空间，但缺点在于，共合体的本质就是同一个数据的不同解类型，换句话说，程序是不知道当前的数据是什么类型的，共合体的成员访问完全可以用更换解指针类型的方式来处理，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;union&lt;/span&gt; Un {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; m1;&lt;br/&gt;  &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; m2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Un un;&lt;br/&gt;  un.m1 = &lt;span&gt;888&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; un.m2 &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 等价于&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; n1 = &lt;span&gt;888&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; *&lt;span&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&amp;gt;(&amp;amp;n1) &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共合体只不过把有可能需要的解类型提前写出来罢了。所以说，共合体并不是用来“多选一”的，笔者认为这是大家曲解的用法。毕竟真正要做到“多选一”，你就得知道当前选的是哪一个，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;QueryKey&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;union&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; name[&lt;span&gt;16&lt;/span&gt;];&lt;br/&gt;  } key;&lt;br/&gt;  &lt;span&gt;enum&lt;/span&gt; {&lt;br/&gt;    kCaseId,&lt;br/&gt;    kCaseName&lt;br/&gt;  } key_case;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用过 google protobuf 的读者一定很熟悉上面的写法，这个就是 proto 中&lt;code&gt;oneof&lt;/code&gt;语法的实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 C++17 中提供了&lt;code&gt;std::variant&lt;/code&gt;，正是为了解决“多选一”问题存在的，它其实并不是为了代替共合体，因为共合体原本就不是为了这种需求的，把共合体用做“多选一”实在是有点“屈才”了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更加贴合共合体本意的用法，是我最早是在阅读处理网络报文的代码中看到的，例如某种协议的报文有如下规定（例子是我随便写的）：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;二进制位&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0~3&lt;/td&gt;&lt;td&gt;协议版本号&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4~5&lt;/td&gt;&lt;td&gt;超时时间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;协商次数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;&lt;td&gt;保留位，固定 为 0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;8~15&lt;/td&gt;&lt;td&gt;业务数据&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里能看出来，整个报文有 2 字节，一般的处理时，我们可能只需要关注这个报文的这 2 个字节值是多少（比如说用十六进制表示），而在排错的时候，才会关注报文中每一位的含义，因此，“整体数据”和“内部数据”就成为了这段报文的两种获取方式，这种场景下非常适合用共合体：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;union&lt;/span&gt; Pack {&lt;br/&gt;  &lt;span&gt;uint16_t&lt;/span&gt; data; &lt;span&gt;// 直接操作报文数据&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; version : &lt;span&gt;4&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; timeout : &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; retry_times : &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; block : &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;uint8_t&lt;/span&gt; bus_data;&lt;br/&gt;  } part; &lt;span&gt;// 操作报文内部数据&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 例如有一个从网络获取到的报文&lt;/span&gt;&lt;br/&gt;  Pack pack;&lt;br/&gt;  GetPackFromNetwork(pack);&lt;br/&gt;  &lt;span&gt;// 打印一下报文的值&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%X&quot;&lt;/span&gt;, pack.data);&lt;br/&gt;  &lt;span&gt;// 更改一下业务数据&lt;/span&gt;&lt;br/&gt;  pack.part.bus_data = &lt;span&gt;0xFF&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 把报文内容扔到处理流中&lt;/span&gt;&lt;br/&gt;  DataFlow() &amp;lt;&amp;lt; pack.data;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，这里的需求就是“用两种方式来访问同一份数据”，才是完全符合共合体定义的用法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共合体应该是 C 语言的特色了，其他任何高级语言都没有类似的语法，主要还是因为 C 语言更加面相底层，C++仅仅是继承了 C 的语法而已。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;const 引用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;先说说 const&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来吐槽一件事，就是 C/C++中&lt;code&gt;const&lt;/code&gt;这个关键字，这个名字起的非常非常不好！为什么这样说呢？const 是 constant 的缩写，翻译成中文就是“常量”，但其实在 C/C++中，&lt;code&gt;const&lt;/code&gt;并不是表示“常量”的意思。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来明确一件事，什么是“常量”，什么是“变量”？常量其实就是衡量，比如说&lt;code&gt;1&lt;/code&gt;就是常量，它永远都是这个值。再比如&lt;code&gt;&#x27;A&#x27;&lt;/code&gt;就是个常量，同样，它永远都是和它 ASCII 码对应的值。
“变量”其实是指存储在内存当中的数据，起了一个名字罢了。如果我们用汇编，则不存在“变量”的概念，而是直接编写内存地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mov ax, 05FAh&lt;br/&gt;mov ds, ax&lt;br/&gt;mov al, ds:[3Fh]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这个&lt;code&gt;05FA:3F&lt;/code&gt;地址太突兀了，也很难记，另一个缺点就是，内存地址如果固定了，进程加载时动态分配内存的操作空间会下降（尽管可以通过相对内存的方式，但程序员仍需要管理偏移地址），所以在略高级一点的语言中，都会让程序员有个更方便的工具来管理内存，最简单的方法就是给内存地址起个名字，然后编译器来负责翻译成相对地址。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a; &lt;span&gt;// 其实就是让编译器帮忙找4字节的连续内存，并且起了个名字叫a&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以“变量”其实指“内存变量”，它一定拥有一个内存地址，和可变不可变没啥关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，C 语言中&lt;code&gt;const&lt;/code&gt;用于修饰的一定是“变量”，来控制这个变量不可变而已。用&lt;code&gt;const&lt;/code&gt;修饰的变量，其实应当说是一种“只读变量”，这跟“常量”根本挨不上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是笔者吐槽这个&lt;code&gt;const&lt;/code&gt;关键字的原因，你叫个&lt;code&gt;read_only&lt;/code&gt;之类的不是就没有歧义了么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C#就引入了&lt;code&gt;readonly&lt;/code&gt;关键字来表示“只读变量”，而&lt;code&gt;const&lt;/code&gt;则更像是给常量取了个别名（可以类比为 C++中的宏定义，或者&lt;code&gt;constexpr&lt;/code&gt;，后面章节会详细介绍&lt;code&gt;constexpr&lt;/code&gt;）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; pi = &lt;span&gt;3.14159&lt;/span&gt;; &lt;span&gt;// 常量的别名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;}; &lt;span&gt;// 只读变量&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;左右值&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++由于保留了 C 当中的&lt;code&gt;const&lt;/code&gt;关键字，但更希望表达其“不可变”的含义，因此着重在“左右值”的方向上进行了区分。左右值的概念来源于赋值表达式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var = val; &lt;span&gt;// 赋值表达式&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;赋值表达式的左边表示即将改变的变量，右边表示从什么地方获取这个值。因此，很自然地，右值不会改变，而左值会改变。那么在这个定义下，“常量”自然是只能做右值，因为常量仅仅有“值”，并没有“存储”或者“地址”的概念。而对于变量而言，“只读变量”也只能做右值，原因很简单，因为它是“只读”的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然常量和只读变量是不同的含义，但它们都是用来“读取值”的，也就是用来做右值的，所以，C++引入了“const 引用”的概念来统一这两点。&lt;strong&gt;所谓 const 引用包含了 2 个方面的含义&lt;/strong&gt;:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;作为只读变量的引用（指针的语法糖）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作为只读变量&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换言之，const 引用&lt;strong&gt;可能是引用&lt;/strong&gt;，也&lt;strong&gt;可能只是个普通变量&lt;/strong&gt;，如何理解呢？请看例程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;// a是一个只读变量&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &amp;amp;r1 = a; &lt;span&gt;// r1是a的引用，所以r1是引用&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &amp;amp;r2 = &lt;span&gt;8&lt;/span&gt;; &lt;span&gt;// 8是一个常量，因此r2并不是引用，而是一个只读变量&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，当用一个 const 引用来接收一个变量的时候，这时的引用是真正的引用，其实在&lt;code&gt;r1&lt;/code&gt;内部保存了&lt;code&gt;a&lt;/code&gt;的地址，当我们操作&lt;code&gt;r&lt;/code&gt;的时候，会通过解指针的语法来访问到&lt;code&gt;a&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &amp;amp;r1 = a;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; r1;&lt;br/&gt;&lt;span&gt;// 等价于&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *p1 = &amp;amp;a; &lt;span&gt;// 引用初始化其实是指针的语法糖&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; *p1; &lt;span&gt;// 使用引用其实是解指针的语法糖&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但与此同时，const 引用还可以接收常量，这时，由于常量根本不是变量，自然也不会有内存地址，也就不可能转换成上面那种指针的语法糖。那怎么办？这时，就只能去重新定义一个变量来保存这个常量的值了，所以这时的 const 引用，&lt;strong&gt;其实根本不是引用&lt;/strong&gt;，就是一个普通的只读变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &amp;amp;r1 = &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 等价于&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c1 = &lt;span&gt;8&lt;/span&gt;; &lt;span&gt;// r1其实就是个独立的变量，而并不是谁的引用&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;思考&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;const 引用的这种设计，更多考虑的是语义上的，而不是实现上的。如果我们理解了 const 引用，那么也就不难理解为什么会有“将亡值”和“隐式构造”的问题了，因为搭配 const 引用，可以实现语义上的统一，但代价就是同一语法可能会做不同的事，会令人有疑惑甚至对人有误导。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在后面“右值引用”和“因式构造”的章节会继续详细介绍它们和 const 引用的联动，以及可能出现的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;右值引用与移动语义&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++11 的右值引用语法的引入，其实也完全是针对于底层实现的，而不是针对于上层的语义友好。换句话说，右值引用是为了优化性能的，而并不是让程序变得更易读的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;右值引用&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;右值引用跟 const 引用类似，仍然是同一语法不同意义，并且右值引用的定义强依赖“右值”的定义。根据上一节对“左右值”的定义，我们知道，左右值来源于赋值语句，常量只能做右值，而变量做右值时仅会读取，不会修改。按照这个定义来理解，“右值引用”就是对“右值”的引用了，而右值可能是常量，也可能是变量，那么右值引用自然也是分两种情况来不同处理：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;右值引用绑定一个常量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;右值引用绑定一个变量&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看右值引用绑定常量的情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;r1 = &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;// 右值引用绑定常量&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 const 引用一样，常量没有地址，没有存储位置，只有值，因此，要把这个值保存下来的话，同样得按照“新定义变量”的形式，因此，当右值引用绑定常量时，相当于定义了一个普通变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;r1 = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 等价于&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; v1 = &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;// r1就是个普通的int变量而已，并不是引用&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这时的右值引用并不是谁的引用，而是一个普普通通的变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看看右值引用绑定变量的情况:
这里的关键问题在于，&lt;strong&gt;什么样的变量适合用右值引用绑定？&lt;/strong&gt; 如果对于普通的变量，C++不允许用右值引用来绑定，但这是为什么呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;r = a; &lt;span&gt;// ERR，为什么不允许右值引用绑定普通变量？&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们按照上面对左右值的分析，&lt;strong&gt;当一个变量做右值时，该变量只读，不会被修改&lt;/strong&gt;，那么，“引用”这个变量自然是想让引用成为这个变量的替身，而如果我们希望这里做的事情是“当通过这个引用来操作实体的时候，实体不能被改变”的话，使用 const 引用就已经可以达成目的了，没必要引入一个新的语法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，&lt;strong&gt;右值引用并不是为了让引用的对象只能做右值&lt;/strong&gt;（这其实是 const 引用做的事情），相反，右值引用本身是可以做左值的。这就是右值引用最迷惑人的地方，也是笔者认为“右值引用”这个名字取得迷惑人的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;右值引用到底是想解决什么问题呢？请看下面示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt; &lt;span&gt;// 随便写一个结构体，大家可以脑补这个里面有很多复杂的成员&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a, b;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;Test &lt;span&gt;GetAnObj&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// 一个函数，返回一个结构体类型&lt;/span&gt;&lt;br/&gt;  Test t {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;};  &lt;span&gt;// 大家可以脑补这里面做了一些复杂的操作&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; t; &lt;span&gt;// 最终返回了这个对象&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Test t1 = GetAnObj();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们忽略编译器的优化问题，只分析 C++语言本身。在&lt;code&gt;GetAnObj&lt;/code&gt;函数内部，&lt;code&gt;t&lt;/code&gt;是一个局部变量，局部变量的生命周期是从创建到&lt;strong&gt;当前代码块结束&lt;/strong&gt;，也就是说，当&lt;code&gt;GetAnObj&lt;/code&gt;函数结束时，这个&lt;code&gt;t&lt;/code&gt;&lt;strong&gt;一定会被释放掉&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然这个局部变量会被释放掉，那么函数如何返回呢？这就涉及了“值赋值”的问题，假如&lt;code&gt;t&lt;/code&gt;是一个整数，那么函数返回的时候容易理解，就是返回它的值。具体来说，就是把这个值推到寄存器中，在跳转会调用方代码的时候，再把寄存器中的值读出来：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; t = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译成汇编就是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;push    rbp&lt;br/&gt;mov     rbp, rsp&lt;br/&gt;mov     DWORD PTR [rbp-4], 5     ; 这里[rbp-4]就是局部变量t&lt;br/&gt;mov     eax, DWORD PTR [rbp-4]   ; 把t的值放到eax里，作为返回值&lt;br/&gt;pop     rbp&lt;br/&gt;ret&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以能这样返回，主要就是 eax 放得下 t 的值。但如果 t 是结构体的话，一个 eax 寄存器自然是放不下了，那怎么返回？（这里汇编代码比较长，而且跟编译器的优化参数强相关，就不放代码了，有兴趣的读者可以自己汇编看结果。）简单来说，因为寄存器放不下整个数据，这个数据就只能放到内存中，作为一个临时区域，然后在寄存器里放一个临时区域的内存地址。等函数返回结束以后，再把这个临时区域释放掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们再回来看这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a, b;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;Test &lt;span&gt;GetAnObj&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Test t {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;};&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; t; &lt;span&gt;// 首先开辟一片临时空间，把t复制过去，再把临时空间的地址写入寄存器&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// 代码块结束，局部变量t被释放&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Test t1 = GetAnObj(); &lt;span&gt;// 读取寄存器中的地址，找到临时空间，再把临时空间的数据复制给t1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 函数调用结束，临时空间释放&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么整个过程发生了 2 次复制和 2 次释放，如果我们按照程序的实际行为来改写一下代码，那么其实应该是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a, b;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;GetAnObj&lt;/span&gt;&lt;span&gt;(Test *tmp)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// tmp要指向临时空间&lt;/span&gt;&lt;br/&gt;  Test t{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;};&lt;br/&gt;  *tmp = t; &lt;span&gt;// 把t复制给临时空间&lt;/span&gt;&lt;br/&gt;}  &lt;span&gt;// 代码块结束，局部变量t被释放&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Test *tmp = (Test *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(Test)); &lt;span&gt;// 临时空间&lt;/span&gt;&lt;br/&gt;  GetAnObj(tmp); &lt;span&gt;// 让函数处理临时空间的数据&lt;/span&gt;&lt;br/&gt;  Test t1 = *tmp; &lt;span&gt;// 把临时空间的数据复制给这里的局部变量t1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;free&lt;/span&gt;(tmp); &lt;span&gt;// 释放临时空间&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我真的把代码写成这样，相信一定会被各位前辈骂死，质疑我为啥不直接用出参。的确，用出参是可以解决这种多次无意义复制的问题，所以 C++11 以前并没有要去从语法层面来解决，但这样做就会让代码不得不“面相底层实现”来编程。C++11 引入的右值引用，就是希望从“语法层面”解决这种问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想，这片非常短命的临时空间，究竟是否有必要存在？既然这片空间是用来返回的，返回完就会被释放，那我何必还要单独再搞个变量来接收，如果这片临时空间可以持续使用的话，不就可以减少一次复制吗？于是，“右值引用”的概念被引入。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a, b;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;Test &lt;span&gt;GetAnObj&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Test t {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;};&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; t; &lt;span&gt;// t会复制给临时空间&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Test &amp;amp;&amp;amp;t1 = GetAnObj(); &lt;span&gt;// 我设法引用这篇临时空间，并且让他不要立刻释放&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 临时空间被t1引用了，并不会立刻释放&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// 等代码块结束，t1被释放了，才让临时空间释放&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，右值引用的目的是为了&lt;strong&gt;延长临时变量的生命周期&lt;/strong&gt;，如果我们把函数返回的临时空间中的对象视为“临时对象”的话，正常情况下，当函数调用结束以后，临时对象就会被释放，所以我们管这个短命的对象叫做“&lt;strong&gt;将亡对象&lt;/strong&gt;”，简单粗暴理解为“马上就要挂了的对象”，它的使命就是让外部的&lt;code&gt;t1&lt;/code&gt;复制一下，然后它就死了，所以这时候你对他做什么操作都是没意义的，他就是让人来复制的，自然就是个只读的值了，所以才被归结为“右值”。我们为了让它不要死那么快，而给它延长了生命周期，因此使用了右值引用。所以，右值引用是不是应该叫“续命引用”更加合适呢~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用右值引用捕获一个将亡对象的时候，对象的生命周期从“将亡”变成了“与右值引用共存亡”，这就是右值引用的根本意义，这时的右值引用就是“将亡对象的引用”，又因为这时的将亡对象已经不再“将亡”了，那它既然不再“将亡”，我们再对它进行操作（改变成员的值）自然就是有意义的啦，所以，这里的右值引用其实就&lt;strong&gt;等价于一个普通的引用&lt;/strong&gt;而已。既然就是个普通的引用，而且没用 const 修饰，自然，可以做左值咯。右值引用做左值的时候，其实就是它所指对象做左值而已。不过又因为普通引用并不会影响原本对象的生命周期，但右值引用会，因此，右值引用更像是&lt;strong&gt;一个普通的变量&lt;/strong&gt;，但我们要知道，它本质上还是引用（底层是指针实现的）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结来说就是，右值引用绑定常量时相当于“给一个常量提供了生命周期”，这时的“右值引用”并不是谁的引用，而是相当于一个普通变量；而右值引用绑定将亡对象时，相当于“给将亡对象延长了生命周期”，这时的“右值引用”并不是“右值的引用”，而是“对需要续命的对象”的引用，生命周期变为了右值引用本身的生命周期（或者理解为“接管”了这个引用的对象，成为了一个普通的变量）。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;const 引用绑定将亡对象&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要知道的是，const 引用也是可以绑定将亡对象的，正如上文所说，既然将亡对象定义为了“右值”，也就是只读不可变的，那么自然就符合 const 引用的语义。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 省略Test的定义，见上节&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; Test &amp;amp;t1 = GetAnObj(); &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样看来，const 引用同样可以让将亡对象延长生命周期，但其实这里的出发点并不同，const 引用更倾向于“引用一个不可变的量”，既然这里的将亡对象是一个“不可变的值”，那么，我就可以用 const 引用来保存“这个值”，或者这里的“值”也可以理解为这个对象的“快照”。所以，&lt;strong&gt;当一个 const 引用绑定一个将亡值时，const 引用相当于这个对象的“快照”&lt;/strong&gt;，但背后还是间接地延长了它的生命周期，但只不过是不可变的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;移动语义&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在解释移动语义之前，我们先来看这样一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Buffer&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;：&lt;br/&gt;  Buffer(&lt;span&gt;size_t&lt;/span&gt; size);&lt;br/&gt;  Buffer(&lt;span&gt;const&lt;/span&gt; Buffer &amp;amp;ob);&lt;br/&gt;  ~Buffer();&lt;br/&gt;  &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt;at&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; index)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;：&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; buf_size_;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; *buf_;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;Buffer::Buffer(&lt;span&gt;size_t&lt;/span&gt; size) : buf_size_(size), buf_(&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;) * size)) {}&lt;br/&gt;Buffer::Buffer(&lt;span&gt;const&lt;/span&gt; Buffer &amp;amp;ob) :buf_size_(ob.buf_size_),&lt;br/&gt;                                  buf_(&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;) * ob.buf_size_)) {&lt;br/&gt;  &lt;span&gt;memcpy&lt;/span&gt;(buf_, ob.buf_, ob.buf_size_);&lt;br/&gt;}&lt;br/&gt;Buffer::~Buffer() {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (buf_ != &lt;span&gt;nullptr&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;free&lt;/span&gt;(buf_);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt;Buffer::at&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; buf_[index];&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;ProcessBuf&lt;/span&gt;&lt;span&gt;(Buffer buf)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  buf.at(&lt;span&gt;2&lt;/span&gt;) = &lt;span&gt;100&lt;/span&gt;; &lt;span&gt;// 对buf做一些操作&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  ProcessBuf(Buffer{&lt;span&gt;16&lt;/span&gt;}); &lt;span&gt;// 创建一个16个int的buffer&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这段代码定义了一个非常简单的缓冲区处理类，&lt;code&gt;ProcessBuf&lt;/code&gt;函数想做的事是传进来一个 buffer，然后对这个 buffer 做一些修改的操作，最后可能把这个 buffer 输出出去之类的（代码中没有体现，但是一般业务肯定会有）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果像上面这样写，会出现什么问题？不难发现在于&lt;code&gt;ProcessBuf&lt;/code&gt;的参数，这里会发生复制。由于我们在&lt;code&gt;Buffer&lt;/code&gt;类中定义了拷贝构造函数来实现深复制，那么任何传入的 buffer 都会在这里进行一次拷贝构造（深复制）。再观察&lt;code&gt;Demo&lt;/code&gt;中调用，仅仅是传了一个临时对象而已。临时对象本身也是将亡对象，复制给&lt;code&gt;buf&lt;/code&gt;后，就会被释放，也就是说，我们进行了一次无意义的深复制。
有人可能会说，那这里参数用引用能不能解决问题？比如这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;ProcessBuf&lt;/span&gt;&lt;span&gt;(Buffer &amp;amp;buf)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  buf.at(&lt;span&gt;2&lt;/span&gt;) = &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  ProcessBuf(Buffer{&lt;span&gt;16&lt;/span&gt;}); &lt;span&gt;// ERR，普通引用不可接收将亡对象&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里需要我们注意的是，C++当中，并不只有在显式调用&lt;code&gt;=&lt;/code&gt;的时候才会赋值，在函数传参的时候仍然由赋值语义（也就是实参赋值给形参）。所以上面就相当于:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Buffer &amp;amp;buf = Buffer{&lt;span&gt;16&lt;/span&gt;}; &lt;span&gt;// ERR&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以自然不合法。那，用 const 引用可以吗？由于 const 引用可以接收将亡对象，那自然可以用于传参，但&lt;code&gt;ProcessBuf&lt;/code&gt;函数中却对对象进行了修改操作，所以 const 引用不能满足要求：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;ProcessBuf&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Buffer &amp;amp;buf)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  buf.at(&lt;span&gt;2&lt;/span&gt;) = &lt;span&gt;100&lt;/span&gt;; &lt;span&gt;// 但是这里会报错&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  ProcessBuf(Buffer{&lt;span&gt;16&lt;/span&gt;}); &lt;span&gt;// 这里确实OK了&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如上一节描述，const 引用倾向于表达“保存快照”的意义，因此，虽然这个对象仍然是放在内存中的，但 const 引用并不希望它发生改变（否则就不叫快照了），因此，这里最合适的，仍然是右值引用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;ProcessBuf&lt;/span&gt;&lt;span&gt;(Buffer &amp;amp;&amp;amp;buf)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  buf.at(&lt;span&gt;2&lt;/span&gt;) = &lt;span&gt;100&lt;/span&gt;; &lt;span&gt;// 右值引用完成绑定后，相当于普通引用，所以这里操作OK&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  ProcessBuf(Buffer{&lt;span&gt;16&lt;/span&gt;}); &lt;span&gt;// 用右值引用绑定将亡对象，OK&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看下面的场景：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Buffer buf1{&lt;span&gt;16&lt;/span&gt;};&lt;br/&gt;  &lt;span&gt;// 对buf进行一些操作&lt;/span&gt;&lt;br/&gt;  buf1.at(&lt;span&gt;2&lt;/span&gt;) = &lt;span&gt;50&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 再把buf传给ProcessBuf&lt;/span&gt;&lt;br/&gt;  ProcessBuf(buf1); &lt;span&gt;// ERR，相当于Buffer &amp;amp;&amp;amp;buf= buf1;右值引用绑定非将亡对象&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为右值引用是要来绑定将亡对象的，但这里的&lt;code&gt;buf1&lt;/code&gt;是&lt;code&gt;Demo&lt;/code&gt;函数的局部变量，并不是将亡的，所以右值引用不能接受。但如果我有这样的需求，就是说&lt;code&gt;buf1&lt;/code&gt;我不打算用了，我想把它的控制权交给&lt;code&gt;ProcessBuf&lt;/code&gt;函数中的&lt;code&gt;buf&lt;/code&gt;，相当于，我主动让&lt;code&gt;buf1&lt;/code&gt;提前“亡”，是否可以强制把它弄成将亡对象呢？STL 提供了&lt;code&gt;std::move&lt;/code&gt;函数来完成这件事，“期望强制把一个对象变成将亡对象”：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Buffer buf1{&lt;span&gt;16&lt;/span&gt;};&lt;br/&gt;  &lt;span&gt;// 对buf进行一些操作&lt;/span&gt;&lt;br/&gt;  buf1.at(&lt;span&gt;2&lt;/span&gt;) = &lt;span&gt;50&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 再把buf传给ProcessBuf&lt;/span&gt;&lt;br/&gt;  ProcessBuf(&lt;span&gt;std&lt;/span&gt;::move(buf1)); &lt;span&gt;// OK，强制让buf1将亡，那么右值引用就可以接收&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// 但如果读者尝试的话，在这里会出ERROR&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;std::move&lt;/code&gt;的本意是提前让一个对象“将亡”，然后把控制权“&lt;strong&gt;移交&lt;/strong&gt;”给右值引用，所以才叫「move」，也就是“移动语义”。但很可惜，C++并不能真正让一个对象提前“亡”，所以这里的“移动”仅仅是“语义”上的，并不是实际的。如果我们看一下&lt;code&gt;std::move&lt;/code&gt;的实现就知道了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;remove_reference_t&lt;/span&gt;&amp;lt;T&amp;gt; &amp;amp;&amp;amp;&lt;span&gt;move&lt;/span&gt;&lt;span&gt;(T &amp;amp;&amp;amp;ref)&lt;/span&gt; &lt;span&gt;noexcept&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;remove_reference_t&lt;/span&gt;&amp;lt;T&amp;gt; &amp;amp;&amp;amp;&amp;gt;(ref);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这里参数中的&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;符号让你懵了的话，可以参考后面“引用折叠”的内容，如果对其他乱七八糟的语法还是没整明白的话，没关系，我来简化一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;T &amp;amp;&amp;amp;&lt;span&gt;move&lt;/span&gt;&lt;span&gt;(T &amp;amp;ref)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;T &amp;amp;&amp;amp;&amp;gt;(ref);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈？就这么简单？是的！真的就这么简单，这个&lt;code&gt;std::move&lt;/code&gt;不是什么多高大上的处理，就是简单把普通引用给强制转换成了右值引用，就这么简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我上线才说“C++并不能真正让一个对象提前亡”，这里的&lt;code&gt;std::move&lt;/code&gt;就是&lt;strong&gt;跟编译器玩了一个文字游戏&lt;/strong&gt;罢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，C++的移动语义仅仅是在语义上，在使用时必须要注意，一旦将一个对象 move 给了一个右值引用，那么不可以再操作原本的对象，但这种约束是一种软约束，操作了也并不会有报错，但是就可能会出现奇怪的问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;移动构造、移动赋值&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了右值引用和移动语义，C++还引入了移动构造和移动赋值，这里简单来解释一下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Buffer buf1{&lt;span&gt;16&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;Buffer &lt;span&gt;buf2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;std&lt;/span&gt;::move(buf1))&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 把buf1强制“亡”，但用它的“遗体”构造新的buf2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  Buffer buf3{&lt;span&gt;8&lt;/span&gt;};&lt;br/&gt;  buf3 = &lt;span&gt;std&lt;/span&gt;::move(buf2); &lt;span&gt;// 把buf2强制“亡”，把“遗体”转交个buf3，buf3原本的东西不要了&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决用一个将亡对象来构造/赋值另一个对象的情况，引入了移动构造和移动赋值函数，既然是用一个将亡对象，那么参数自然是右值引用来接收了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Buffer&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;：&lt;br/&gt;  Buffer(&lt;span&gt;size_t&lt;/span&gt; size);&lt;br/&gt;  Buffer(&lt;span&gt;const&lt;/span&gt; Buffer &amp;amp;ob);&lt;br/&gt;  Buffer(Buffer &amp;amp;&amp;amp;ob); &lt;span&gt;// 移动构造函数&lt;/span&gt;&lt;br/&gt;  ~Buffer();&lt;br/&gt;  Buffer &amp;amp;&lt;span&gt;operator&lt;/span&gt; =(Buffer &amp;amp;&amp;amp;ob); &lt;span&gt;// 移动赋值函数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt;at&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; index)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;：&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; buf_size_;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; *buf_;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要考虑的问题是，既然是用将亡对象来构造新对象，那么我们应当尽可能多得利用将亡对象的“遗体”，在将亡对象中有一个&lt;code&gt;buf_&lt;/code&gt;指针，指向了一片堆空间，那这片堆空间就可以直接利用起来，而不用再复制一份了，因此，移动构造和移动赋值应该这样实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Buffer::Buffer(Buffer &amp;amp;&amp;amp;ob) : buf_size_(ob.buf_size_), &lt;span&gt;// 基本类型数据，只能简单拷贝了&lt;/span&gt;&lt;br/&gt;                              buf_(ob.buf_) { &lt;span&gt;// 直接把ob中指向的堆空间接管过来&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 为了防止ob中的空间被重复释放，将其置空&lt;/span&gt;&lt;br/&gt;    ob.buf_ = &lt;span&gt;nullptr&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;Buffer &amp;amp;Buffer::&lt;span&gt;operator&lt;/span&gt; =(Buffer &amp;amp;&amp;amp;ob) {&lt;br/&gt;  &lt;span&gt;// 先把自己原来持有的空间释放掉&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (buf_ != &lt;span&gt;nullptr&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;free&lt;/span&gt;(buf_);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 然后继承ob的buf_&lt;/span&gt;&lt;br/&gt;  buf_ = ob.buf_;&lt;br/&gt;  &lt;span&gt;// 为了防止ob中的空间被重复释放，将其置空&lt;/span&gt;&lt;br/&gt;  ob.buf_ = &lt;span&gt;nullptr&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细心的读者应该能发现，所谓的“移动构造/赋值”，其实就是一个“浅复制”而已。当出现移动语义的时候，我们想象中是“把旧对象里的东西 &lt;strong&gt;移动&lt;/strong&gt; 到新对象中”，但其实没法做到这种移动，只能是“把旧对象&lt;strong&gt;引用&lt;/strong&gt;的东西&lt;strong&gt;转为&lt;/strong&gt;新对象来&lt;strong&gt;引用&lt;/strong&gt;”，本质就是一次&lt;strong&gt;浅复制&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引用折叠&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用折叠指的是在模板参数以及 auto 类型推导时遇到多重引用时进行的映射关系，我们先从最简单的例子来说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(T &amp;amp;t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  f&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(a);&lt;br/&gt;  f&amp;lt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;gt;(a);&lt;br/&gt;  f&amp;lt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;&amp;gt;(a);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;T&lt;/code&gt;实例化为&lt;code&gt;int&lt;/code&gt;时，函数变成了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; &amp;amp;t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果&lt;code&gt;T&lt;/code&gt;实例化为&lt;code&gt;int &amp;amp;&lt;/code&gt;和&lt;code&gt;int &amp;amp;&amp;amp;&lt;/code&gt;时呢？难道是这样吗？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; &amp;amp; &amp;amp;t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp; &amp;amp;t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们发现，这种情况下编译并没有出错，&lt;code&gt;T&lt;/code&gt;本身带引用时，再跟参数后面的引用符结合，也是可以正常通过编译的。这就是所谓的引用折叠，简单理解为“两个引用撞一起了，以谁为准”的问题。引用折叠满足下面规律：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;左值引用短路右值引用&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说就是，除非是两个右值引用遇到一起，会推导出右值引用以外，其他情况都会推导出左值引用，所以是左值引用优先。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;amp; + &amp;amp; -&amp;gt; &amp;amp;&lt;br/&gt;&amp;amp; + &amp;amp;&amp;amp; -&amp;gt; &amp;amp;&lt;br/&gt;&amp;amp;&amp;amp; + &amp;amp; -&amp;gt; &amp;amp;&lt;br/&gt;&amp;amp;&amp;amp; + &amp;amp;&amp;amp; -&amp;gt; &amp;amp;&amp;amp;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;auto &amp;amp;&amp;amp;&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种规律同样同样适用于&lt;code&gt;auto &amp;amp;&amp;amp;&lt;/code&gt;，当&lt;code&gt;auto &amp;amp;&amp;amp;&lt;/code&gt;遇到左值时会推导出左值引用，遇到右值时才会推导出右值引用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;&amp;amp;r1 = &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;// 绑定常量，推导出int &amp;amp;&amp;amp;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;&amp;amp;r2 = a; &lt;span&gt;// 绑定变量，推导出int &amp;amp;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;b = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;&amp;amp;r3 = b; &lt;span&gt;// 右值引用一旦绑定，则相当于普通变量，所以绑定变量，推导出int &amp;amp;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;&amp;amp;&lt;/code&gt;比&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;优先级高，因此&lt;code&gt;auto &amp;amp;&lt;/code&gt;一定推出左值引用，如果用&lt;code&gt;auto &amp;amp;&lt;/code&gt;绑定常量或将亡对象则会报错：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;r1 = &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;// ERR，左值引用不能绑定常量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;r2 = GetAnObj(); &lt;span&gt;// ERR，左值引用不能绑定将亡对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;b = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;r3 = b; &lt;span&gt;// OK，左值引用可以绑定右值引用（因为右值引用一旦绑定后，相当于左值）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;r4 = r3; &lt;span&gt;// OK，左值引用可以绑定左值引用（相当于绑定r4的引用源）&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;右值引用传递时失去右性&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的章节笔者频繁强调一个概念：右值引用一旦绑定，则相当于普通的引用（左值）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就意味着，“右值”性质无法传递，请看例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;t1)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;t2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f1(t2); &lt;span&gt;// 注意这里&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f2(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Demo&lt;/code&gt;函数中调用&lt;code&gt;f2&lt;/code&gt;，&lt;code&gt;f2&lt;/code&gt;的参数是&lt;code&gt;int &amp;amp;&amp;amp;&lt;/code&gt;，用来绑定常量&lt;code&gt;5&lt;/code&gt;没问题，但是，在&lt;code&gt;f2&lt;/code&gt;函数内，&lt;code&gt;t2&lt;/code&gt;是一个右值引用，而右值引用一旦绑定，则相当于左值，因此，不能再用右值引用去接收。所以&lt;code&gt;f2&lt;/code&gt;内部调&lt;code&gt;f1&lt;/code&gt;的过程会报错。这就是所谓“右值引用传递时会失去右性”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何保持右性呢？很无奈，只能层层转换：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;t1)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;t2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f1(&lt;span&gt;std&lt;/span&gt;::move(t2)); &lt;span&gt;// 保证右性&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f2(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我们来考虑另一个场景，在模板函数中这件事会怎么样？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;(T &amp;amp;&amp;amp;t1)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;(T &amp;amp;&amp;amp;t2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f1&amp;lt;T&amp;gt;(t2);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f2&amp;lt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;&amp;gt;(&lt;span&gt;5&lt;/span&gt;); &lt;span&gt;// 传右值&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;  f2&amp;lt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;gt;(a); &lt;span&gt;// 传左值&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;f1&lt;/code&gt;和&lt;code&gt;f2&lt;/code&gt;都是模板，因此，传入左值和传入右值的可能性都要有的，我们没法在&lt;code&gt;f2&lt;/code&gt;中再强制&lt;code&gt;std::move&lt;/code&gt;了，因为这样做会让左值变成右值传递下去，我们希望的是保持其左右性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果不这样做，当我向&lt;code&gt;f2&lt;/code&gt;传递右值时，右性无法传递下去，也就是&lt;code&gt;t2&lt;/code&gt;是&lt;code&gt;int &amp;amp;&amp;amp;&lt;/code&gt;类型，但是传递给&lt;code&gt;f1&lt;/code&gt;的时候，&lt;code&gt;t1&lt;/code&gt;变成了&lt;code&gt;int &amp;amp;&lt;/code&gt;类型，这时&lt;code&gt;t1&lt;/code&gt;是&lt;code&gt;t2&lt;/code&gt;的引用（就是左值引用绑定右值引用的场景），并不是我们想要的。那怎么解决，如何让这种左右性质传递下去呢？就要用到模板元编程来完成了:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;T &amp;amp;&lt;span&gt;forward&lt;/span&gt;&lt;span&gt;(T &amp;amp;t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; t; &lt;span&gt;// 如果传左值，那么直接传出&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;T &amp;amp;&amp;amp;&lt;span&gt;forward&lt;/span&gt;&lt;span&gt;(T &amp;amp;&amp;amp;t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::move(t); &lt;span&gt;// 如果传右值，那么保持右值性质传出&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;(T &amp;amp;&amp;amp;t1)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;(T &amp;amp;&amp;amp;t2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f1(forward&amp;lt;T&amp;gt;(t2));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f2&amp;lt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;&amp;gt;(&lt;span&gt;5&lt;/span&gt;); &lt;span&gt;// 传右值&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;  f2&amp;lt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;gt;(a); &lt;span&gt;// 传左值&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面展示的是&lt;code&gt;std::forward&lt;/code&gt;的一个示例型的代码，便于读者理解，实际实现要稍微复杂一点。思路就是，根据传入的参数来判断，如果是左值引用就直接传出，如果是右值引用就&lt;code&gt;std::move&lt;/code&gt;变成右值再传出，保证其左右性。&lt;code&gt;std::forward&lt;/code&gt;又被称为“完美转发”，意义就在于传递引用时能保持其左右性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;auto 推导策略&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++11 提供了&lt;code&gt;auto&lt;/code&gt;来自动推导类型，很大程度上提升了代码的直观性，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;unordered_map&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt; data_map;&lt;br/&gt;&lt;span&gt;// 不用auto&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;unordered_map&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;::iterator iter = data_map.begin();&lt;br/&gt;&lt;span&gt;// 使用auto推导&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; iter = data_map.begin();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 auto 的推导仍然引入了不少奇怪的问题。首先，&lt;code&gt;auto&lt;/code&gt;关键字仅仅是用来代替“类型符”的，它并没有改变“C++类型说明符具有多重意义”这件事，在前面“类型说明符”的章节我曾介绍过，C++中，类型说明符除了表示“类型”以外，还承担了“定义动作”的任务，&lt;code&gt;auto&lt;/code&gt;可以视为一种&lt;strong&gt;带有类型推导的类型说明符&lt;/strong&gt;，其本质仍然是类型说明符，所以，它同样承担了定义动作的任务，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;auto&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;// auto承担了“定义变量”的任务&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但&lt;code&gt;auto&lt;/code&gt;却不可以和&lt;code&gt;[]&lt;/code&gt;组合定义数组，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;auto&lt;/span&gt; arr[] = {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;}; &lt;span&gt;// ERR&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在定义函数上，更加有趣，在 C++14 以前，并不支持用&lt;code&gt;auto&lt;/code&gt;推导函数返回值类型，但是却支持返回值后置语法，所以在这种场景下，&lt;code&gt;auto&lt;/code&gt;仅仅是一个占位符而已，它&lt;strong&gt;既不表示类型&lt;/strong&gt;，&lt;strong&gt;也不表示定义动作&lt;/strong&gt;，仅仅就是为了结构完整占位而已：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;auto&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// () -&amp;gt; int表示定义函数，int表示函数返回值类型&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到了 C++14 才支持了返回值类型自动推导，但并不支持自动生成多种类型的返回值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;auto&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; cmd)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (cmd &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;// 用5推导返回值为int&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;(&lt;span&gt;&quot;123&quot;&lt;/span&gt;); &lt;span&gt;// ERR，返回值已经推导为int了，不能多类型返回&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;auto 的语义&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样还是出自这句话“auto 是用来代替类型说明符的”，因此&lt;code&gt;auto&lt;/code&gt;在语义上也更加倾向于“用它代替类型说明符”这种行为，尤其是它和引用、指针类型结合时，这种特性更加明显：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;9&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &amp;amp;r = a;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; b = a; &lt;span&gt;// auto-&amp;gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; c = &lt;span&gt;4&lt;/span&gt;; &lt;span&gt;// auto-&amp;gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; d = k; &lt;span&gt;// auto-&amp;gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; e = r; &lt;span&gt;// auto-&amp;gt;int&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到，无论用普通变量、只读变量、引用、常量去初始化 auto 变量时，&lt;code&gt;auto&lt;/code&gt;都只会推导其类型，而不会带有左右性、只读性这些内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，&lt;code&gt;auto&lt;/code&gt;的类型推导，并不是“&lt;strong&gt;推导某个表达式的类型&lt;/strong&gt;”，而是“&lt;strong&gt;推导当前位置合适的类型&lt;/strong&gt;”，或者可以理解为“&lt;strong&gt;这里最简单可以是什么类型&lt;/strong&gt;”。比如说上面&lt;code&gt;auto c = 4&lt;/code&gt;这里，&lt;code&gt;auto&lt;/code&gt;可以推导为&lt;code&gt;int&lt;/code&gt;,&lt;code&gt;int &amp;amp;&amp;amp;&lt;/code&gt;,&lt;code&gt;const int&lt;/code&gt;,&lt;code&gt;const int &amp;amp;&lt;/code&gt;,&lt;code&gt;const int &amp;amp;&amp;amp;&lt;/code&gt;，而&lt;code&gt;auto&lt;/code&gt;选择的是里面&lt;strong&gt;最简单&lt;/strong&gt;的那一种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;auto&lt;/code&gt;还可以跟指针符、引用符结合，而这种时候它还是满足上面“最简单”的这种原则，并且此时指的是“&lt;code&gt;auto&lt;/code&gt;本身最简单”，举例来说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; p1 = &amp;amp;a; &lt;span&gt;// auto-&amp;gt;int *&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; *p2 = &amp;amp;a; &lt;span&gt;// auto-&amp;gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;r1 = a; &lt;span&gt;// auto-&amp;gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; *p3 = &amp;amp;p2; &lt;span&gt;// auto-&amp;gt;int *&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; p4 = &amp;amp;p2; &lt;span&gt;// auto-&amp;gt; int **&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;p1&lt;/code&gt;和&lt;code&gt;p2&lt;/code&gt;都是指针，但&lt;code&gt;auto&lt;/code&gt;都是用最简原则来推导的，&lt;code&gt;p2&lt;/code&gt;这里因为我们已经显式写了一个&lt;code&gt;*&lt;/code&gt;了，所以&lt;code&gt;auto&lt;/code&gt;只会推导出&lt;code&gt;int&lt;/code&gt;，因此&lt;code&gt;p2&lt;/code&gt;最终类型仍然是&lt;code&gt;int *&lt;/code&gt;而不会变成&lt;code&gt;int **&lt;/code&gt;。同样的道理在&lt;code&gt;p3&lt;/code&gt;和&lt;code&gt;p4&lt;/code&gt;上也成立。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一些将“类型”和“动作”语义分离的语言中，就完全不会有 auto 的这种困扰，它们可以用“省略类型符”来表示“自动类型推导”的语义，而起“定义”语义的关键字得以保留而不受影响，例如在 swift 中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt; &lt;span&gt;// Int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; b = &lt;span&gt;5.6&lt;/span&gt; &lt;span&gt;// 只读Double&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;: &lt;span&gt;Double&lt;/span&gt; = &lt;span&gt;8&lt;/span&gt; &lt;span&gt;// 显式指定类型&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中也是类似的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;2.5&lt;/span&gt; &lt;span&gt;// var表示“定义变量”动作，自动推导a的类型为float64&lt;/span&gt;&lt;br/&gt;b := &lt;span&gt;5&lt;/span&gt; &lt;span&gt;// 自动推导类型为int，:=符号表示了“定义动作”语义&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; c = &lt;span&gt;7&lt;/span&gt; &lt;span&gt;// const表示“定义只读变量”动作，自动推导c类型为int&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; d &lt;span&gt;float32&lt;/span&gt; = &lt;span&gt;9&lt;/span&gt; &lt;span&gt;// 显式指定类型&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;auto 引用&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面“引用折叠”的章节曾经提到过&lt;code&gt;auto &amp;amp;&amp;amp;&lt;/code&gt;的推导原则，有可能会推导出左值引用来，所以&lt;code&gt;auto &amp;amp;&amp;amp;&lt;/code&gt;并不是要“定义一个右值引用”，而是“定义一个保持左右性的引用”，也就是说，绑定一个左值时会推导出左值引用，绑定一个右值时会推导出右值引用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &amp;amp;r1 = a;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &amp;amp;&amp;amp;r2 = &lt;span&gt;4&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;&amp;amp;y1 = a; &lt;span&gt;// int &amp;amp;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;&amp;amp;y2 = r1; &lt;span&gt;// int &amp;amp;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;&amp;amp;y3 = r2; &lt;span&gt;// int &amp;amp;（注意右值引用本身是左值）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;&amp;amp;y4 = &lt;span&gt;3&lt;/span&gt;; &lt;span&gt;// int &amp;amp;&amp;amp;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &amp;amp;&amp;amp;y5 = &lt;span&gt;std&lt;/span&gt;::move(r1); &lt;span&gt;// int &amp;amp;&amp;amp;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更详细的内容可以参考前面“引用折叠”的章节。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;C 语言曾经的 auto&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信大家现在看到&lt;code&gt;auto&lt;/code&gt;都第一印象是 C++当中的“自动类型推导”，但其实&lt;code&gt;auto&lt;/code&gt;并不是 C++11 引入的新关键在，在原始 C 语言中就有这一关键字的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在原始 C 中，&lt;code&gt;auto&lt;/code&gt;表示“自动变量位置”，与之对应的是&lt;code&gt;register&lt;/code&gt;。在之前“const 引用”章节中笔者曾经提到，“变量就是内存变量”，但其实在原始 C 中，除了内存变量以外，还有一种变量叫做“寄存器变量”，也就是直接将这个数据放到 CPU 的寄存器中。也就是说，编译器可以控制这个变量的位置，如果更加需要读写速度，那么放到寄存器中更合适，因此&lt;code&gt;auto&lt;/code&gt;表示让编译器自动决定放内存中，还是放寄存器中。而&lt;code&gt;register&lt;/code&gt;修饰的则表示人工指定放在寄存器中。至于没有关键字修饰的，则表示希望放到内存中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a; &lt;span&gt;// 内存变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;register&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; b; &lt;span&gt;// 寄存器变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c; &lt;span&gt;// 由编译器自动决定放在哪里&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，寄存器变量不能取址。这个很好理解，因为只有内存才有地址（地址本来指的就是内存地址），寄存器是没有的。因此，&lt;code&gt;auto&lt;/code&gt;修饰的变量如果被取址了，那么一定会放在内存中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;auto&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a; &lt;span&gt;// 有可能放在内存中，也有可能放在寄存器中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; b;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; *p = &amp;amp;b; &lt;span&gt;// 这里b被取址了，因此b一定只能放在内存中&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;register&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; *p2 = &amp;amp;c; &lt;span&gt;// ERR，对寄存器变量取址，会报错&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而在 C++中，几乎不会人工来控制变量的存放位置了，毕竟 C++更加上层一些，这样超底层的语法就被摒弃了（C++11 取消了&lt;code&gt;register&lt;/code&gt;关键字，而&lt;code&gt;auto&lt;/code&gt;关键字也失去其本意，变为了“自动类型推导”的占位符）。而关于变量的存储位置则是全权交给了编译器，也就是说我们可以理解为，在 C++11 以后，所有的变量都是自动变量，存储位置由编译器决定。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;static&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者在前面章节吐槽了&lt;code&gt;const&lt;/code&gt;这个命名，也吐槽了“右值引用”这个命名。那么&lt;code&gt;static&lt;/code&gt;就是笔者下一个要重点吐槽的命名了。&lt;code&gt;static&lt;/code&gt;这个词本身没有什么问题，其主要的槽点就在于“一词多用”，也就是说，这个词在不同场景下表示的是完全不同的含义。（作者可能是出于节省关键词的目的吧，明明是不同的含义，却没有用不同的关键词）。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在局部变量前的&lt;code&gt;static&lt;/code&gt;，限定的是变量的生命周期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在全局变量/函数前的&lt;code&gt;static&lt;/code&gt;，限定的变量/函数的作用域&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在成员变量前的&lt;code&gt;static&lt;/code&gt;，限定的是成员变量的生命周期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在成员函数前的&lt;code&gt;static&lt;/code&gt;，限定的是成员函数的调用方（或隐藏参数）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是&lt;code&gt;static&lt;/code&gt;关键字的 4 种不同含义，接下来逐一我会解释。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;静态局部变量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用&lt;code&gt;static&lt;/code&gt;修饰局部变量时，&lt;code&gt;static&lt;/code&gt;表示其生命周期：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  count++;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上例中，&lt;code&gt;count&lt;/code&gt;是一个局部变量，既然已经是“局部变量”了，那么它的作用域很明显，就是&lt;code&gt;f&lt;/code&gt;函数内部。而这里的&lt;code&gt;static&lt;/code&gt;表示的是其生命周期。普通的全局变量在其所在函数(或代码块)结束时会被释放。而用&lt;code&gt;static&lt;/code&gt;修饰的则不会，我们将其称为“静态局部变量”。
静态局部变量会在首次执行到定义语句时初始化，在主函数执行结束后释放，在程序执行过程中遇到定义（和初始化）语句时会忽略。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;   count++;&lt;br/&gt;   &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; count &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *argv[])&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f(); &lt;span&gt;// 第一次执行时count被定义，并且初始化为0，执行后count值为1，并且不会释放&lt;/span&gt;&lt;br/&gt;  f(); &lt;span&gt;// 第二次执行时由于count已经存在，因此初始化语句会无视，执行后count值为2，并且不会释放&lt;/span&gt;&lt;br/&gt;  f(); &lt;span&gt;// 同上，执行后count值为3，不会释放&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// 主函数执行结束后会释放f中的count&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如上面例程的输出结果会是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细的说明已经在注释中，这里不再赘述。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内部全局变量/函数&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;static&lt;/code&gt;修饰全局变量或函数时，用于限定其作用域为“当前文件内”。同理，由于已经是“全局”变量了，生命周期一定是符合全局的，也就是“主函数执行前构造，主函数执行结束后释放”。至于全局函数就不用说了，函数都是全局生命周期的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，这时候的&lt;code&gt;static&lt;/code&gt;不会再对生命周期有影响，而是限定了其作用域。与之对应的是&lt;code&gt;extern&lt;/code&gt;。用&lt;code&gt;extern&lt;/code&gt;修饰的全局变量/函数作用于整个程序内，换句话说，就是可以跨文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// a1.cc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; g_val = &lt;span&gt;4&lt;/span&gt;; &lt;span&gt;// 定义全局变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// a2.cc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; g_val; &lt;span&gt;// 声明全局变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; g_val &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;; &lt;span&gt;// 使用了在另一个文件中定义的全局变量&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而用&lt;code&gt;static&lt;/code&gt;修饰的全局变量/函数则只能在当前文件中使用，不同文件间的&lt;code&gt;static&lt;/code&gt;全局变量/函数可以同名，并且互相独立。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// a1.cc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; s_val1 = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// 定义内部全局变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; s_val2 = &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;// 定义内部全局变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// 定义内部函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// a2.cc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; s_val1 = &lt;span&gt;6&lt;/span&gt;; &lt;span&gt;// 定义内部全局变量，与a1.cc中的互不影响&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; s_val2; &lt;span&gt;// 这里会视为定义了新的内部全局变量，而不会视为“声明”&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 声明了一个内部函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; s_val1 &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;; &lt;span&gt;// 输出6，与a1.cc中的s_val1没有关系&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; s_val2 &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;; &lt;span&gt;// 输出0，同样不会访问到a1.cc中的s_val2&lt;/span&gt;&lt;br/&gt;  f1(); &lt;span&gt;// ERR，这里链接会报错，因为在a2.cc中没有找到f1的定义，并不会链接到a1.cc中的f1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们发现，在这种场景下，&lt;code&gt;static&lt;/code&gt;并不表示“静态”的含义，而是表示“内部”的含义，所以，为什么不再引入个类似于&lt;code&gt;inner&lt;/code&gt;的关键字呢？这里很容易让程序员造成迷惑。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;静态成员变量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态成员变量指的是用&lt;code&gt;static&lt;/code&gt;修饰的成员变量。普通的成员变量其生命周期是跟其所属对象绑定的。构造对象时构造成员变量，析构对象时释放成员变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a; &lt;span&gt;// 普通成员变量&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *argv[])&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Test t; &lt;span&gt;// 同时构造t.a&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;auto&lt;/span&gt; t2 = &lt;span&gt;new&lt;/span&gt; Test; &lt;span&gt;// 同时构造t2-&amp;gt;a&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;delete&lt;/span&gt; t2; &lt;span&gt;// t2所指对象析构，同时释放t2-&amp;gt;a&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// t析构，同时释放t.a&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而用&lt;code&gt;static&lt;/code&gt;修饰后，其声明周期变为全局，也就是“主函数执行前构造，主函数执行结束后释放”，并且不再跟随对象，而是全局一份。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a; &lt;span&gt;// 静态成员变量（基本等同于声明全局变量）&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; Test::a = &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;// 初始化静态成员变量（主函数前执行，基本等同于初始化全局变量）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *argv[])&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; Test::a &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;; &lt;span&gt;// 直接访问静态成员变量&lt;/span&gt;&lt;br/&gt;  Test t;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; t.a &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;; &lt;span&gt;// 通过任意对象实例访问静态成员变量&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// 主函数结束时释放Test::a&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以静态成员变量基本就相当于一个全局变量，而这时的类更像一个命名空间了。唯一的区别在于，通过类的实例（对象）也可以访问到这个静态成员变量，就像上面的&lt;code&gt;t.a&lt;/code&gt;和&lt;code&gt;Test::a&lt;/code&gt;完全等价。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;静态成员函数&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;static&lt;/code&gt;关键字修饰在成员函数前面，称为“静态成员函数”。我们知道普通的成员函数要以对象为主调方，对象本身其实是函数的一个隐藏参数（this 指针）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 非静态成员函数&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Test::f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;this&lt;/span&gt;-&amp;gt;a &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Test t;&lt;br/&gt;  t.f(); &lt;span&gt;// 用对象主调成员函数&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面其实等价于：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(Test *&lt;span&gt;this&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;this&lt;/span&gt;-&amp;gt;a &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Test t;&lt;br/&gt;  f(&amp;amp;t); &lt;span&gt;// 其实对象就是函数的隐藏参数&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，&lt;code&gt;obj.f(arg)&lt;/code&gt;本质上就是&lt;code&gt;f(&amp;amp;obj, arg)&lt;/code&gt;，并且这个参数强制叫做&lt;code&gt;this&lt;/code&gt;。这个特性在 Go 语言中尤为明显，Go 不支持封装到类内的成员函数，也不会自动添加隐藏参数，这些行为都是显式的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Test &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  a &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(t *Test)&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  fmt.Println(t.a)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  t := &lt;span&gt;new&lt;/span&gt;(Test)&lt;br/&gt;  t.f()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到 C++的静态成员函数这里来。用&lt;code&gt;static&lt;/code&gt;修饰的成员函数表示“不需要对象作为主调方”，也就是说没有那个隐藏的&lt;code&gt;this&lt;/code&gt;参数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 静态成员函数&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Test::f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 没有this，没有对象，只能做对象无关操作&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 也可以操作静态成员变量和其他静态成员函数&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，这时的静态成员函数，其实就相当于一个普通函数而已。这时的类同样相当于一个命名空间，而区别在于，如果这个函数传入了同类型的参数时，可以访问私有成员，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;   &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Test &amp;amp;t1, &lt;span&gt;const&lt;/span&gt; Test &amp;amp;t2)&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 静态成员函数&lt;/span&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; a; &lt;span&gt;// 私有成员&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Test::f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Test &amp;amp;t1, &lt;span&gt;const&lt;/span&gt; Test &amp;amp;t2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// t1和t2是通过参数传进来的，但因为是Test类型，因此可以访问其私有成员&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; t1.a + t2.a &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者我们可以把静态成员函数理解为&lt;strong&gt;一个友元函数&lt;/strong&gt;，只不过从设计角度上来说，与这个类型的关联度应该是更高的。但是从语法层面来解释，基本相当于“写在类里的普通函数”。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 C++中&lt;code&gt;static&lt;/code&gt;造成的迷惑，同样也是因为 C 中的缺陷被放大导致的。毕竟在 C 中不存在构造、析构和引用链的问题。说到这个引用链，其实 C++中的静态成员变量、静态局部变量和全局变量还存在一个链路顺序问题，可能会导致内存重复释放、访问野指针等情况的发生。这部分的内容详见后面“平凡、标准布局”的章节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，我们需要了解&lt;code&gt;static&lt;/code&gt;关键字有多义性，了解其在不同场景下的不同含义，更有助于我们理解 C++语言，防止踩坑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;平凡、标准布局&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前阵子我和一个同事对这样一个问题进行了非常激烈的讨论：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;到底应不应该定义 std::string 类型的全局变量&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题乍一看好像没什么值得讨论的地方，我相信很多程序员都在不经意间写过类似的代码，并且确实没有发现什么执行上的问题，所以可能从来没有意识到，这件事还有可能出什么问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们和我同事之所以激烈讨论这个问题，一切的根源来源于谷歌的 C++编程规范，其中有一条是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Static or global variables of class &lt;span&gt;type&lt;/span&gt; are forbidden: they cause hard-to-find bugs due to indeterminate order of construction and destruction.&lt;br/&gt;Objects with static storage duration, including global variables, static variables, static class member variables, and &lt;span&gt;function&lt;/span&gt; static variables, must be Plain Old Data (POD): only ints, chars, floats, or pointers, or arrays/structs of POD.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致翻译一下就是说：不允许非 POD 类型的全局变量、静态全局变量、静态成员变量和静态局部变量，因为可能会导致难以定位的 bug。而&lt;code&gt;std::string&lt;/code&gt;是非 POD 类型的，自然，按照规范，也不允许&lt;code&gt;std::string&lt;/code&gt;类型的全局变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果我们真的写了，貌似也从来没有遇到过什么问题，程序也不会出现任何 bug 或者异常，甚至下面的几种写法都是在日常开发中经常遇到的，但都不符合这谷歌的这条代码规范。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; ip = &lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;uint16_t&lt;/span&gt; port = &lt;span&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 开启某个网络连接&lt;/span&gt;&lt;br/&gt;  SocketSvr svr{ip, port};&lt;br/&gt;  &lt;span&gt;// 记录日志&lt;/span&gt;&lt;br/&gt;  WriteLog(&lt;span&gt;&quot;net linked: ip:port={%s:%hu}&quot;&lt;/span&gt;, ip.c_str(), port);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &lt;span&gt;GetDesc&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;unordered_map&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;gt; ma {&lt;br/&gt;    {&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;DATA_NOT_FOUND&quot;&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;STYLE_ILLEGEL&quot;&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;-1&lt;/span&gt;, &lt;span&gt;&quot;SYSTEM_ERR&quot;&lt;/span&gt;}&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;auto&lt;/span&gt; res = ma.find(code); res != ma.end()) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res-&amp;gt;second;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;UNKNOWN&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SingleObj&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;：&lt;br/&gt;  &lt;span&gt;SingleObj &amp;amp;&lt;span&gt;GetInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  SingleObj(&lt;span&gt;const&lt;/span&gt; SingleObj &amp;amp;) = &lt;span&gt;delete&lt;/span&gt;;&lt;br/&gt;  SingleObj &amp;amp;&lt;span&gt;operator&lt;/span&gt; =(&lt;span&gt;const&lt;/span&gt; SingleObj &amp;amp;) = &lt;span&gt;delete&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;   SingleObj();&lt;br/&gt;   ~SingleObj();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SingleObj &amp;amp;&lt;span&gt;SingleObj::GetInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; SingleObj single_obj;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; single_obj;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的几个例子都存在“非 POD 类型全局或静态变量”的情况。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;全局、静态的生命周期问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然谷歌规范中禁止这种情况，那一定意味着，这种写法存在潜在风险，我们需要搞明白风险点在哪里。
首先明确变量生命周期的问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;全局变量和静态成员变量在主函数执行前构造，在主函数执行结束后释放；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;静态局部变量在第一次执行到定义位置时构造，在主函数执行后释放。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这件事如果在 C 语言中，并没有什么问题，设计也很合理。但是 C++就是这样悲催，很多 C 当中合理的问题在 C++中会变得不合理，并且缺陷会被放大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 C 当中的变量仅仅是数据，因此，它的“构造”和“释放”都没有什么副作用。但在 C++当中，“构造”是要调用构造函数来完成的，“释放”之前也是要先调用析构函数。这就是问题所在！照理说，&lt;strong&gt;主函数应该是程序入口&lt;/strong&gt;，那么在主函数之前不应该调用任何自定义的函数才对。但这件事放到 C++当中就不一定成立了，我们看一下下面例程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;：&lt;br/&gt;  Test();&lt;br/&gt;  ~Test();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;Test::Test() {&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;create&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;Test::~Test() {&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;destroy&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;Test g_test; &lt;span&gt;// 全局变量&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *argv[])&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;main function&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面程序会得到以下输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;create&lt;br/&gt;main &lt;span&gt;function&lt;/span&gt;&lt;br/&gt;destroy&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，Test 的构造函数在主函数前被调用了。解释起来也很简单，因为“全局变量在主函数执行之前构造，主函数执行结束后释放”，而因为&lt;code&gt;Test&lt;/code&gt;类型是类类型，“构造”时要调用构造函数，“释放”时要调用析构函数。所以上面的现象也就不奇怪了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种单一个的全局变量其实并不会出现什么问题，但如果有多变量的依赖，这件事就不可控了，比如下面例程:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;test.h&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test1&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;extern&lt;/span&gt; Test1 g_test1; &lt;span&gt;// 声明全局变量&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;test.cc&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Test1 g_test1 {&lt;span&gt;4&lt;/span&gt;}; &lt;span&gt;// 定义全局变量&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main.cc&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;test.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Test2(&lt;span&gt;const&lt;/span&gt; Test1 &amp;amp;test1); &lt;span&gt;// 传Test1类型参数&lt;/span&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; m_;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;Test2::Test2(&lt;span&gt;const&lt;/span&gt; Test1 &amp;amp;test1): m_(test1.a) {}&lt;br/&gt;&lt;br/&gt;Test2 g_test2{g_test1}; &lt;span&gt;// 用一个全局变量来初始化另一个全局变量&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *argv)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这种情况，程序编译、链接都是没问题的，但运行时会&lt;strong&gt;概率性出错&lt;/strong&gt;，问题就在于，&lt;code&gt;g_test1&lt;/code&gt;和&lt;code&gt;g_test2&lt;/code&gt;都是全局变量，并且是在不同文件中定义的，并且由于全局变量构造在主函数前，因此其&lt;strong&gt;初始化顺序是随机的&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如&lt;code&gt;g_test1&lt;/code&gt;在&lt;code&gt;g_test2&lt;/code&gt;之前初始化，那么整个程序不会出现任何问题，但如果&lt;code&gt;g_test2&lt;/code&gt;在&lt;code&gt;g_test1&lt;/code&gt;前初始化，那么在&lt;code&gt;Test2&lt;/code&gt;的构造函数中，得到的就是一个未初始化的&lt;code&gt;test1&lt;/code&gt;引用，这时候访问&lt;code&gt;test1.a&lt;/code&gt;就是操作野指针了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我们就能发现，全局变量出问题的根源在于&lt;strong&gt;全局变量的初始化顺序不可控，是随机的&lt;/strong&gt;，因此，如果出现依赖，则会导致问题。
同理，析构发生在主函数后，那么析构顺序也是随机的，可能出问题，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test1&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; count;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Test2(Test1 *test1);&lt;br/&gt;  ~Test2();&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  Test1 *test1_;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;Test2::Test2(Test1 *test1): test1_(test1) {&lt;br/&gt;  test1_-&amp;gt;count++;&lt;br/&gt;}&lt;br/&gt;Test2::~Test2() {&lt;br/&gt;  test1_-&amp;gt;count--;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;Test1 g_test1 {&lt;span&gt;0&lt;/span&gt;}; &lt;span&gt;// 全局变量&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; Test2 t2{&amp;amp;g_test1}; &lt;span&gt;// 静态局部变量&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *argv[])&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Demo(); &lt;span&gt;// 构造了t2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面示例中，构造&lt;code&gt;t2&lt;/code&gt;的时候使用了&lt;code&gt;g_test1&lt;/code&gt;，由于&lt;code&gt;t2&lt;/code&gt;是静态局部变量，因此是在第一个调用时（主函数中调用&lt;code&gt;Demo&lt;/code&gt;时）构造。这时已经是主函数执行过程中了，因此&lt;code&gt;g_test1&lt;/code&gt;已经构造完毕的，所以构造时不会出现问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，静态成员变量是在主函数执行完成后析构，这和全局变量相同，因此，&lt;code&gt;t2&lt;/code&gt;和&lt;code&gt;g_test1&lt;/code&gt;的&lt;strong&gt;析构顺序&lt;/strong&gt;无法控制。如果&lt;code&gt;t2&lt;/code&gt;比&lt;code&gt;g_test1&lt;/code&gt;先析构，那么不会出现任何问题。但如果&lt;code&gt;g_test1&lt;/code&gt;比&lt;code&gt;t2&lt;/code&gt;先析构，那么在析构&lt;code&gt;t2&lt;/code&gt;时，对&lt;code&gt;test1_&lt;/code&gt;访问&lt;code&gt;count&lt;/code&gt;成员这一步，就会访问野指针。因为&lt;code&gt;test1_&lt;/code&gt;所指向的&lt;code&gt;g_test1&lt;/code&gt;已经先行析构了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个时候我们就可以确定，全局变量、静态变量之间不能出现依赖关系，否则，由于其构造、析构顺序不可控，因此可能会出现问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;谷歌标准中的规定&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到我们刚才提到的谷歌标准，这里标准的制定者正是因为担心这样的问题发生，才禁止了非 POD 类型的全局或静态变量。但我们分析后得知，也并不是说所有的类类型全局或静态变量都会出现问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，谷歌规范中的“POD 类型”的限定也过于广泛了。所谓“POD 类型”指的是“平凡”+“标准内存布局”，这里我来解释一下这两种性质，并且分析分析为什么谷歌标准允许 POD 类型的全局或静态变量。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;平凡&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“平凡(trivial)”指的是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;拥有默认无参构造函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拥有默认析构函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拥有默认拷贝构造函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拥有默认移动构造函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拥有默认拷贝赋值函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拥有默认移动赋值函数&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，六大特殊函数都是默认的。这里要区分 2 个概念，我们要的是“语法上的平凡”还是“实际意义上的平凡”。语法上的平凡就是说能够被编译期识别、认可的平凡。而实际意义上的平凡就是说里面没有额外操作。
比如说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test1&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Test1() = &lt;span&gt;default&lt;/span&gt;; &lt;span&gt;// 默认无参构造函数&lt;/span&gt;&lt;br/&gt;  Test1(&lt;span&gt;const&lt;/span&gt; Test1 &amp;amp;) = &lt;span&gt;default&lt;/span&gt;; &lt;span&gt;// 默认拷贝构造函数&lt;/span&gt;&lt;br/&gt;  Test &amp;amp;&lt;span&gt;operator&lt;/span&gt; =(&lt;span&gt;const&lt;/span&gt; Test1 &amp;amp;) = &lt;span&gt;default&lt;/span&gt;; &lt;span&gt;// 默认拷贝赋值函数&lt;/span&gt;&lt;br/&gt;  ~Test1() = &lt;span&gt;default&lt;/span&gt;; &lt;span&gt;// 默认析构函数&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Test2() {} &lt;span&gt;// 自定义无参构造函数，但实际内容为空&lt;/span&gt;&lt;br/&gt;  ~Test2() {&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;destory\n&quot;&lt;/span&gt;);} &lt;span&gt;// 自定义析构函数，但实际内容只有打印&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子中，&lt;code&gt;Test1&lt;/code&gt;就是个真正意义上的平凡类型，语法上是平凡的，因此编译器也会认为其是平凡的。我们可以用 STL 中的工具来判断一个类型是否是平凡的:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;bool&lt;/span&gt; is_test1_tri = &lt;span&gt;std&lt;/span&gt;::is_trivial_v&amp;lt;Test1&amp;gt;; &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这里的 Test2，由于我们自定义了其无参构造函数和析构函数，那么对编译器来说，它就是非平凡的，我们用&lt;code&gt;std::is_trivial&lt;/code&gt;来判断也会得到&lt;code&gt;false_value&lt;/code&gt;。但其实内部并没有什么外链操作，所以其实我们把&lt;code&gt;Test2&lt;/code&gt;类型定义全局变量时也不会出现任何问题，这就是所谓“实际意义上的平凡”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++对“平凡”的定义比较严格，但实际上我们看看如果要做全局变量或静态变量的时候，是不需要这样严格定义的。对于全局变量来说，只要&lt;strong&gt;定义全局变量时，使用的是“实际意义上平凡”的构造函数&lt;/strong&gt;，并且&lt;strong&gt;拥有“实际意义上平凡”的析构函数&lt;/strong&gt;，那这个全局变量定义就不会有任何问题。而对于静态局部变量来说，只要&lt;strong&gt;拥有“实际意义上平凡”的析构函数&lt;/strong&gt;的就一定不会出问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;标准内存布局&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标准内存布局的定义是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;所有成员拥有相同的权限（比如说都&lt;code&gt;public&lt;/code&gt;，或都&lt;code&gt;protected&lt;/code&gt;，或都&lt;code&gt;private&lt;/code&gt;）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不含虚基类、虚函数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果含有基类，基类必须都是标准内存布局；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果函数成员变量，成员的类型也必须是标准内存布局。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们同样可以用 STL 中的&lt;code&gt;std::is_standard_layout&lt;/code&gt;来判断一个类型是否是标准内存布局的。这里的定义比较简单，不在赘述。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;POD(Plain Old Data)类型&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓 POD 类型就是同时符合“平凡”和“标准内存布局”的类型。符合这个类型的基本就是基本数据类型，加上一个普通 C 语言的结构体。换句话说，符合“旧类型（C 语言中的类型）行为的类型”，它不存在虚函数指针、不存在虚表，可以视为普通二进制来操作的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，在 C++中，只有 POD 类型可以用&lt;code&gt;memcpy&lt;/code&gt;这种二进制方法来复制而不会产生副作用，其他类型的都必须用用调用拷贝构造。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前有人向笔者提出疑问，为何&lt;code&gt;vector&lt;/code&gt;扩容时不直接用类似于&lt;code&gt;memcpy&lt;/code&gt;的方式来复制，而是要以此调用拷贝构造。原因正是在此，对于非 POD 类型的对象，其中可能会包含虚表、虚函数指针等数据，复制时这些内容可能会重置，并且内部可能会含有一些类似于“计数”这样操作其他引用对象的行为，因为一定要用拷贝构造函数来保证这些行为是正常的，而不能简单粗暴地用二进制方式进行拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;STL 中可以用&lt;code&gt;std::is_pod&lt;/code&gt;来判断是个类型是否是 POD 的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再回到谷歌规范中，POD 的限制比较多，因此，确实 POD 类型的全局/静态变量是肯定不会出问题的，但直接将非 POD 类型的一棍子打死，笔者个人认为有点过了，没必要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，笔者认为更加精确的限定应该是：对于全局变量、静态成员变量来说，初始化时必须调用的是&lt;strong&gt;平凡的构造函数&lt;/strong&gt;，并且其应当拥有&lt;strong&gt;平凡的析构函数&lt;/strong&gt;，而且这里的“平凡”是指实际意义上的平凡，也就是说可以自定义，但是在内部&lt;strong&gt;没有对任何其他的对象&lt;/strong&gt;进行操作；对于静态局部变量来说，其应当拥有&lt;strong&gt;平凡的析构函数&lt;/strong&gt;，同样指的是实际意义上的平凡，也就是它的析构函数中没有对任何其他的对象进行操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后举几个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test1&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Test1(&lt;span&gt;int&lt;/span&gt; a): m_(a) {}&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;show&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;/span&gt;{&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%d\n&quot;&lt;/span&gt;, m_);}&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; m_;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Test2(Test1 *t): m_(t) {}&lt;br/&gt;  Test2(&lt;span&gt;int&lt;/span&gt; a): m_(&lt;span&gt;nullptr&lt;/span&gt;) {}&lt;br/&gt;  ~Test2() {}&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  Test1 *m_;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test3&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;   Test3(&lt;span&gt;const&lt;/span&gt; Test1 &amp;amp;t): m_(&amp;amp;t) {}&lt;br/&gt;   ~Test3() {m_-&amp;gt;show();}&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;   Test1 *m_;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test4&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Test4(&lt;span&gt;int&lt;/span&gt; a): m_(a) {}&lt;br/&gt;  ~Test4() = &lt;span&gt;default&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;：&lt;br/&gt;  Test1 m_;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Test1&lt;/code&gt;是非平凡的（因为无参构造函数没有定义），但它仍然可以定义全局/静态变量，因为&lt;code&gt;Test1(int)&lt;/code&gt;构造函数是“实际意义上平凡”的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Test2&lt;/code&gt;是非平凡的，并且&lt;code&gt;Test2(Test1 *)&lt;/code&gt;构造函数需要引用其他类型，因此它不能通过&lt;code&gt;Test2(Test1 *)&lt;/code&gt;定义全局变量或静态成员变量，但可以通过&lt;code&gt;Test2(int)&lt;/code&gt;来定义全局变量或静态成员变量，因为这是一个“实际意义上平凡”的构造函数。而且因为它的析构函数是“实际意义上平凡”的，因此&lt;code&gt;Test2&lt;/code&gt;类型可以定义静态局部变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Test3&lt;/code&gt;是非平凡的，构造函数对&lt;code&gt;Test1&lt;/code&gt;有引用，并且析构函数中调用了&lt;code&gt;Test1::show&lt;/code&gt;方法，因此&lt;code&gt;Test3&lt;/code&gt;类型不能用来定义局部/静态变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Test4&lt;/code&gt;也是非平凡的，并且内部存在同样非平凡的&lt;code&gt;Test1&lt;/code&gt;类型成员，但是因为&lt;code&gt;m1_&lt;/code&gt;不是引用或指针，一定会随着&lt;code&gt;Test4&lt;/code&gt;类型的对象的构造而构造，析构而析构，不存在顺序依赖问题，因此&lt;code&gt;Test4&lt;/code&gt;可以用来定义全局/静态变量。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;所以全局 std::string 变量到底可以不可以？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后回到这个问题上，笔者认为定义一个全局的&lt;code&gt;std::string&lt;/code&gt;类型的变量并不会出现什么问题，在&lt;code&gt;std::string&lt;/code&gt;的内部，数据空间是通过&lt;code&gt;new&lt;/code&gt;的方式申请的，并且一般情况下都不会被其他全局变量所引用，在&lt;code&gt;std::string&lt;/code&gt;对象析构时，对这片空间会进行&lt;code&gt;delete&lt;/code&gt;，所以并不会出现析构顺序问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果你用的不是默认的内存分配器，而是自定义了内存分配器的话，那确实要考虑构造析构顺序的问题了，你要保证在对象构造前，内存分配器是存在的，并且内存分配器的析构要在所有对象之后。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，如果你仅仅是想给字符串常量起个别名的话，有一种更好的方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *ip = &lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;毕竟指针一定是平凡类型，而且用&lt;code&gt;constexpr&lt;/code&gt;修饰后可以变为编译期常量。这里详情可以在后面“constexpr”的章节了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而至于其他类型的静态局部变量（比如说单例模式，或者局部内的&lt;code&gt;map&lt;/code&gt;之类的映射表），只要让它不被析构就好了，所以可以用堆空间的方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; Test &amp;amp;&lt;span&gt;Test::GetInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; Test &amp;amp;inst = *&lt;span&gt;new&lt;/span&gt; Test;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; inst;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &lt;span&gt;GetDesc&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;auto&lt;/span&gt; &amp;amp;desc = *&lt;span&gt;new&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;map&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;gt; {&lt;br/&gt;    {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;desc1&quot;&lt;/span&gt;},&lt;br/&gt; {&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;desc2&quot;&lt;/span&gt;},&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;auto&lt;/span&gt; iter = desc.find(code);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; iter == desc.end() ? &lt;span&gt;&quot;no_desc&quot;&lt;/span&gt; : iter-&amp;gt;second;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;非平凡析构类型的移动语义&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讨论完平凡类型后，我们发现平凡析构其实是更加值得关注的场景。这里就引申出非平凡析构的移动语义问题，请看例程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Buffer&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Buffer(&lt;span&gt;size_t&lt;/span&gt; size): buf(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[size]), size(size) {}&lt;br/&gt;  ~Buffer() {&lt;span&gt;delete&lt;/span&gt; [] buf;}&lt;br/&gt;  Buffer(&lt;span&gt;const&lt;/span&gt; Buffer &amp;amp;ob): buf(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[ob.size]), size(ob.size) {}&lt;br/&gt;  Buffer(Buffer &amp;amp;&amp;amp;ob): buf(ob.buf), size(ob.size) {}&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; *buf;&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; size;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Buffer buf{&lt;span&gt;16&lt;/span&gt;};&lt;br/&gt;  Buffer nb = &lt;span&gt;std&lt;/span&gt;::move(buf);&lt;br/&gt;} &lt;span&gt;// 这里会报错&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是这个简单的缓冲区的例子，如果我们调用&lt;code&gt;Demo&lt;/code&gt;函数，那么结束时会报重复释放内存的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在上面例子中，&lt;code&gt;buf&lt;/code&gt;和&lt;code&gt;nb&lt;/code&gt;中的&lt;code&gt;buf&lt;/code&gt;指向的是同一片空间，当&lt;code&gt;Demo&lt;/code&gt;函数结束时，&lt;code&gt;buf&lt;/code&gt;销毁会触发一次&lt;code&gt;Buffer&lt;/code&gt;的析构，&lt;code&gt;nb&lt;/code&gt;析构时也会触发一次&lt;code&gt;Buffer&lt;/code&gt;的析构。而析构函数中是&lt;code&gt;delete&lt;/code&gt;操作，所以堆空间会被释放两次，导致报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就是说，&lt;strong&gt;对于非平凡析构类型，其发生移动语义后，应当放弃对原始空间的控制&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们修改一下代码，那么这种问题就不会发生：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Buffer&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Buffer(&lt;span&gt;size_t&lt;/span&gt; size): buf(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[size]), size(size) {}&lt;br/&gt;  ~Buffer();&lt;br/&gt;  Buffer(&lt;span&gt;const&lt;/span&gt; Buffer &amp;amp;ob): buf(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[ob.size]), size(ob.size) {}&lt;br/&gt;  Buffer(Buffer &amp;amp;&amp;amp;ob): buf(ob.buf), size(ob.size) {ob.buf = &lt;span&gt;nullptr&lt;/span&gt;;} &lt;span&gt;// 重点在这里&lt;/span&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; *buf;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;Buffer::~Buffer() {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (buf != &lt;span&gt;nullptr&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;delete&lt;/span&gt; [] buf;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Buffer buf{&lt;span&gt;16&lt;/span&gt;};&lt;br/&gt;  Buffer nb = &lt;span&gt;std&lt;/span&gt;::move(buf);&lt;br/&gt;} &lt;span&gt;// OK，没有问题&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于移动构造函数和移动赋值函数是我们可以自定义的，因此，可以把重复析构产生的问题在这个里面考虑好。例如上面的把对应指针置空，而析构时再进行判空即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们得出的结论是&lt;strong&gt;并不是说非平凡析构的类型就不可以使用移动语义&lt;/strong&gt;，而是&lt;strong&gt;非平凡析构类型进行移动构造或移动赋值时，要考虑引用权释放问题&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;私有继承和多继承&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;C++是多范式语言&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讲解私有继承和多继承之前，笔者要先澄清一件事：&lt;strong&gt;C++不是单纯的面相对象的语言&lt;/strong&gt;。同样地，它也不是单纯的面向过程的语言，也不是函数式语言，也不是接口型语言……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真的要说，C++是一个多范式语言，也就是说它并不是为了某种编程范式来创建的。C++的语法体系完整且庞大，很多范式都可以用 C++来展现。因此，&lt;strong&gt;不要试图用任一一种语言范式来解释 C++语法&lt;/strong&gt;，不然你总能找到各种漏洞和奇怪的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例来说，C++中的“继承”指的是一种语法现象，而面向对象理论中的“继承”指的是一种类之间的关系。这二者是有本质区别的，请读者一定一定要区分清楚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以面向对象为例，C++当然可以面向对象编程（OOP），但由于 C++并不是专为 OOP 创建的语言，自然就有 OOP 理论解释不了的语法现象。比如说多继承，比如说私有继承。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++与 java 不同，java 是完全按照 OOP 理论来创建的，因此所谓“抽象类”，“接口（协议）类”的语义是明确可以和 OOP 对应上的，并且，在 OOP 理论中，“继承”关系应当是&quot;A is a B&quot;的关系，所以不会存在 A 既是 B 又是 C 的这种情况，自然也就不会出现“多继承”这样的语法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在 C++中，考虑的是对象的布局，而不是 OOP 的理论，所以出现私有继承、多继承等这样的语法也就不奇怪了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者曾经听有人持有下面这样类似的观点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;虚函数都应该是纯虚的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;含有虚函数的类不应当支持实例化（创建对象）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能实例化的类不应当被继承，有子类的类不应当被实例化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个类至多有一个“属性父类”，但可以有多个“协议父类”&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等等这些观点，它们其实都有一个共同的前提，那就是“我要用 C++来支持 OOP 范式”。如果我们用 OOP 范式来约束 C++，那么上面这些观点都是非常正确的，否则将不符合 OOP 的理论，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Pet&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Pet {};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Pet {};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Pet pet; &lt;span&gt;// 一个不属于猫、狗等具体类型，仅仅属于“宠物”的实例，显然不合理&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Pet&lt;/code&gt;既然作为一个抽象概念存在，自然就不应当有实体。同理，如果一个类含有未完全实现的虚函数，就证明这个类属于某种抽象，它就不应该允许创建实例。而可以创建实例的类，一定就是最“具象”的定义了，它就不应当再被继承。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 OOP 的理论下，多继承也是不合理的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SomeProperty&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Cat, &lt;span&gt;public&lt;/span&gt; Dog {}; &lt;span&gt;// 啥玩意会既是猫也是狗？&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果是“协议父类”的多继承就是合理的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Pet&lt;/span&gt; {&lt;/span&gt; &lt;span&gt;// 协议类&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Feed&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;// 定义了喂养方式就可以成为宠物&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Animal, &lt;span&gt;public&lt;/span&gt; Pet { &lt;span&gt;// 遵守协议，实现其需方法&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Feed&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 实现协议方法&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面例子中，&lt;code&gt;Cat&lt;/code&gt;虽然有 2 个父类，但&lt;code&gt;Animal&lt;/code&gt;才是真正意义上的父类，也就是&lt;code&gt;Cat is a (kind of) Animal&lt;/code&gt;的关系，而&lt;code&gt;Pet&lt;/code&gt;是协议父类，也就是&lt;code&gt;Cat could be a Pet&lt;/code&gt;，只要一个类型可以完成某些行为，那么它就可以“作为”这样一种类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 java 中，这两种类型是被严格区分开的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Pet&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// 接口类&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Feed&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// 抽象类，不可创建实例&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Pet&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Feed&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子类与父类的关系叫“继承”，与协议（或者叫接口）的关系叫“实现”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 C++同源的 Objective-C 同样是 C 的超集，但从名称上就可看出，这是“面向对象的 C”，语法自然也是针对 OOP 理论的，所以 OC 仍然只支持单继承链，但可以定义协议类（类似于 java 中的接口类），“继承”和“遵守（类似于 java 中的实现语义）”仍然是两个分离的概念：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@protocol&lt;/span&gt; &lt;span&gt;Pet&lt;/span&gt; &amp;lt;&lt;span&gt;NSObject&lt;/span&gt;&amp;gt; // 定义协议&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)Feed;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@interface&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; : &lt;span&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@interface&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt; : &lt;span&gt;Animal&lt;/span&gt;&amp;lt;&lt;span&gt;Pet&lt;/span&gt;&amp;gt; // 继承自&lt;span&gt;Animal&lt;/span&gt;类，遵守&lt;span&gt;Pet&lt;/span&gt;协议&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)Feed;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@implementation&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)Feed {&lt;br/&gt;  &lt;span&gt;// 实现协议接口&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比，C++只能说“可以”用做 OOP 编程，但 OOP 并不是其唯一范式，也就不会针对于 OOP 理论来限制其语法。这一点，希望读者一定要明白。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;私有继承与 EBO&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;私有继承本质不是「继承」&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此强调，这个标题中，第一个“继承”指的是一种 C++语法，也就是&lt;code&gt;class A : B {};&lt;/code&gt;这种写法。而第二个“继承”指的是 OOP（面向对象编程）的理论，也就是 A is a B 的抽象关系，类似于“狗”继承自“动物”的这种关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们说，私有继承本质是表示组合的，而不是继承关系，要验证这个说法，只需要做一个小实验即可。我们知道最能体现继承关系的应该就是多态了，如果父类指针能够指向子类对象，那么即可实现多态效应。请看下面的例程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Base&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Base {};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Base {};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;C&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; Base {};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  A a;&lt;br/&gt;  B b;&lt;br/&gt;  C c;&lt;br/&gt;&lt;br/&gt;  Base *p = &amp;amp;a; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;  p = &amp;amp;b; &lt;span&gt;// ERR&lt;/span&gt;&lt;br/&gt;  p = &amp;amp;c; &lt;span&gt;// ERR&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们给&lt;code&gt;Base&lt;/code&gt;类分别编写了&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;、&lt;code&gt;C&lt;/code&gt;三个子类，分别是&lt;code&gt;public&lt;/code&gt;、&lt;code&gt;private&lt;/code&gt;和&lt;code&gt;protected&lt;/code&gt;继承。然后用&lt;code&gt;Base *&lt;/code&gt;类型的指针去分别指向&lt;code&gt;a&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt;、&lt;code&gt;c&lt;/code&gt;。发现只有&lt;code&gt;public&lt;/code&gt;继承的&lt;code&gt;a&lt;/code&gt;对象可以用&lt;code&gt;p&lt;/code&gt;直接指向，而&lt;code&gt;b&lt;/code&gt;和&lt;code&gt;c&lt;/code&gt;都会报这样的错：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Cannot cast &lt;span&gt;&#x27;B&#x27;&lt;/span&gt; to its private base class &lt;span&gt;&#x27;Base&#x27;&lt;/span&gt;&lt;br/&gt;Cannot cast &lt;span&gt;&#x27;C&#x27;&lt;/span&gt; to its protected base class &lt;span&gt;&#x27;Base&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，私有继承是不支持多态的，那么也就印证了，他并不是 OOP 理论中的“继承关系”，但是，由于私有继承会继承成员变量，也就是可以通过&lt;code&gt;b&lt;/code&gt;和&lt;code&gt;c&lt;/code&gt;去使用&lt;code&gt;a&lt;/code&gt;的成员，那么其实这是一种组合关系。或者，大家可以理解为，把&lt;code&gt;b.a.member&lt;/code&gt;改写成了&lt;code&gt;b.A::member&lt;/code&gt;而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么私有继承既然是用来表示组合关系的，那我们为什么不直接用成员对象呢？为什么要使用私有继承？这是因为用成员对象在某种情况下是有缺陷的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;空类大小&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在解释私有继承的意义之前，我们先来看一个问题，请看下面例程&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;T&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;// sizeof(T) = ?&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;T&lt;/code&gt;是一个空类，里面什么都没有，那么这时&lt;code&gt;T&lt;/code&gt;的大小是多少？照理说，空类的大小就是应该是&lt;code&gt;0&lt;/code&gt;，但如果真的设置为&lt;code&gt;0&lt;/code&gt;的话，会有很严重的副作用，请看例程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;T&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  T arr[&lt;span&gt;10&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;sizeof&lt;/span&gt;(arr); &lt;span&gt;// 0&lt;/span&gt;&lt;br/&gt;  T *p = arr + &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 此时p==arr&lt;/span&gt;&lt;br/&gt;  p++; &lt;span&gt;// ++其实无效&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现了吗？假如&lt;code&gt;T&lt;/code&gt;的大小是&lt;code&gt;0&lt;/code&gt;，那么&lt;code&gt;T&lt;/code&gt;指针的偏移量就永远是&lt;code&gt;0&lt;/code&gt;，&lt;code&gt;T&lt;/code&gt;类型的数组大小也将是&lt;code&gt;0&lt;/code&gt;，而如果它成为了一个成员的话，问题会更严重：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  T t;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;// t和a首地址相同&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;T&lt;/code&gt;是&lt;code&gt;0&lt;/code&gt;大小，那么此时&lt;code&gt;Test&lt;/code&gt;结构体中，&lt;code&gt;t&lt;/code&gt;和&lt;code&gt;a&lt;/code&gt;就会在同一首地址。
所以，为了避免这种 0 长的问题，编译器会针对于空类自动补一个字节的大小，也就是说&lt;strong&gt;其实&lt;code&gt;sizeof(T)&lt;/code&gt;是 1，而不是 0&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要注意的是，不仅是绝对的空类会有这样的问题，只要是不含有非静态成员变量的类都有同样的问题，例如下面例程中的几个类都可以认为是空类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; m1;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;C&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  C();&lt;br/&gt;  ~C();&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;double&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了自动补 1 字节，&lt;code&gt;T&lt;/code&gt;的长度变成了 1，那么&lt;code&gt;T*&lt;/code&gt;的偏移量也会变成 1，就不会出现 0 长的问题。但是，这么做就会引入另一个问题，请看例程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Empty&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  Empty m1;&lt;br/&gt;  &lt;span&gt;long&lt;/span&gt; m2;&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;// sizeof(Test)==16&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;Empty&lt;/code&gt;是空类，编译器补了 1 字节，所以此时&lt;code&gt;m1&lt;/code&gt;是 1 字节，而&lt;code&gt;m2&lt;/code&gt;是 8 字节，&lt;code&gt;m1&lt;/code&gt;之后要进行字节对齐，因此&lt;code&gt;Test&lt;/code&gt;变成了 16 字节。如果&lt;code&gt;Test&lt;/code&gt;中出现了很多空类成员，这种问题就会被继续放大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是用成员对象来表示组合关系时，可能会出现的问题，而私有继承就是为了解决这个问题的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;空基类成员压缩（EBO，Empty Base Class Optimization）&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一节最后的历程中，为了让&lt;code&gt;m1&lt;/code&gt;不再占用空间，但又能让&lt;code&gt;Test&lt;/code&gt;中继承&lt;code&gt;Empty&lt;/code&gt;类的其他内容（例如函数、类型重定义等），我们考虑将其改为继承来实现，EBO 就是说，当父类为空类的时候，子类中不会再去分配父类的空间，也就是说这种情况下编译器不会再去补那 1 字节了，节省了空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果使用&lt;code&gt;public&lt;/code&gt;继承会怎么样？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Empty&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Empty {&lt;br/&gt;  &lt;span&gt;long&lt;/span&gt; m2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 假如这里有一个函数让传Empty类对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Empty &amp;amp;obj)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;// 那么下面的调用将会合法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Test t;&lt;br/&gt;  f(t); &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Test&lt;/code&gt;由于是&lt;code&gt;Empty&lt;/code&gt;的子类，所以会触发多态性，&lt;code&gt;t&lt;/code&gt;会当做&lt;code&gt;Empty&lt;/code&gt;类型传入&lt;code&gt;f&lt;/code&gt;中。这显然问题很大呀！如果用这个例子看不出问题的话，我们换一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Alloc&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;Create&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Vector&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Alloc {&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 这个函数用来创建buffer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;CreateBuffer&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Alloc &amp;amp;alloc)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;void&lt;/span&gt; *buffer = alloc.Create(); &lt;span&gt;// 调用分配器的Create方法创建空间&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Vector ve; &lt;span&gt;// 这是一个容器&lt;/span&gt;&lt;br/&gt;  CreateBuffer(ve); &lt;span&gt;// 语法上是可以通过的，但是显然不合理&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存分配器往往就是个空类，因为它只提供一些方法，不提供具体成员。&lt;code&gt;Vector&lt;/code&gt;是一个容器，如果这里用&lt;code&gt;public&lt;/code&gt;继承，那么容器将成为分配器的一种，然后调用&lt;code&gt;CreateBuffer&lt;/code&gt;的时候可以传一个容器进去，这显然很不合理呀！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么此时，用私有继承就可以完美解决这个问题了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Alloc&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;Create&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Vector&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Alloc {&lt;br/&gt;&lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;void&lt;/span&gt; *buffer;&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; size;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 这个函数用来创建buffer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;CreateBuffer&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Alloc &amp;amp;alloc)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;void&lt;/span&gt; *buffer = alloc.Create(); &lt;span&gt;// 调用分配器的Create方法创建空间&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Vector ve; &lt;span&gt;// 这是一个容器&lt;/span&gt;&lt;br/&gt;  CreateBuffer(ve); &lt;span&gt;// ERR，会报错，私有继承关系不可触发多态&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，由于私有继承不可触发多态，那么&lt;code&gt;Vector&lt;/code&gt;就并不是&lt;code&gt;Alloc&lt;/code&gt;的一种，也就是说，从 OOP 理论上来说，他们并不是继承关系。而由于有了私有继承，在&lt;code&gt;Vector&lt;/code&gt;中可以调用&lt;code&gt;Alloc&lt;/code&gt;里的方法以及类型重命名，所以这其实是一种组合关系。
而又因为 EBO，所以也不用担心&lt;code&gt;Alloc&lt;/code&gt;占用&lt;code&gt;Vector&lt;/code&gt;的成员空间的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谷歌规范中规定了继承必须是&lt;code&gt;public&lt;/code&gt;的，这主要还是在贴近 OOP 理论。另一方面就是说，虽然使用私有继承是为了压缩空间，但一定程度上也是牺牲了代码的可读性，让我们不太容易看得出两种类型之间的关系，因此在绝大多数情况下，还是应当使用&lt;code&gt;public&lt;/code&gt;继承。不过笔者仍然持有“万事皆不可一棒子打死”的观点，如果我们确实需要 EBO 的特性否则会大幅度牺牲性能的话，那么还是应当允许使用私有继承。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多继承&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与私有继承类似，C++的多继承同样是“语法上”的继承，而实际意义上可能并不是 OOP 中的“继承”关系。再以前面章节的 Pet 为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Pet&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Feed&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Animal, &lt;span&gt;public&lt;/span&gt; Pet {&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Feed&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从形式上来说，&lt;code&gt;Cat&lt;/code&gt;同时继承自&lt;code&gt;Anmial&lt;/code&gt;和&lt;code&gt;Pet&lt;/code&gt;，但从 OOP 理论上来说，&lt;code&gt;Cat&lt;/code&gt;和&lt;code&gt;Animal&lt;/code&gt;是继承关系，而和&lt;code&gt;Pet&lt;/code&gt;是实现关系，前面章节已经介绍得很详细了，这里不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于 C++并不是完全针对 OOP 的，因此支持真正意义上的多继承，也就是说，即便父类不是这种纯虚类，也同样支持集成，从语义上来说，类似于“交叉分类”。请看示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Organic&lt;/span&gt; {&lt;/span&gt; &lt;span&gt;// 有机物&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Inorganic&lt;/span&gt; {&lt;/span&gt; &lt;span&gt;// 无机物&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Acid&lt;/span&gt; {&lt;/span&gt; &lt;span&gt;// 酸&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Salt&lt;/span&gt; {&lt;/span&gt; &lt;span&gt;// 盐&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AceticAcid&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Organic, &lt;span&gt;public&lt;/span&gt; Acid { &lt;span&gt;// 乙酸&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HydrochloricAcid&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Inorganic, &lt;span&gt;public&lt;/span&gt; Acid { &lt;span&gt;// 盐酸&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SodiumCarbonate&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Inorganic, &lt;span&gt;public&lt;/span&gt; Salt { &lt;span&gt;// 碳酸钠&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面就是一个交叉分类法的例子，使用多继承语法合情合理。如果换做其他 OOP 语言，可能会强行把“酸”或者“有机物”定义为协议类，然后用继承+实现的方式来完成。但如果从化学分类上来看，无论是“酸碱盐”还是“有机物无机物”，都是一种强分类，比如说“碳酸钠”，它就是一种“无机物”，也是一种“盐”，你并不能用类似于“猫是一种动物，可以作为宠物”的理论来解释，不能说“碳酸钠是一种盐，可以作为一种无机物”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此 C++中的多继承是哪种具体意义，取决于父类本身是什么。如果父类是个协议类，那这里就是“实现”语义，而如果父类本身就是个实际类，那这里就是“继承”语义。当然了，像私有继承的话表示是“组合”语义。不过 C++本身并不在意这种语义，有时为了方便，我们也可能用公有继承来表示组合语义，比如说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;double&lt;/span&gt; x, y;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Circle&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Point {&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;double&lt;/span&gt; r; &lt;span&gt;// 半径&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里&lt;code&gt;Circle&lt;/code&gt;继承了&lt;code&gt;Point&lt;/code&gt;，但显然不是说“圆是一个点”，这里想表达的就是圆类“包含了”点类的成员，所以只是为了复用。从意义上来说，&lt;code&gt;Circle&lt;/code&gt;类中继承来的&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;显然表达的是圆心的坐标。不过这样写并不符合设计规范，但笔者用这个例子希望解释的是&lt;strong&gt;C++并不在意类之间实际是什么关系，它在意的是数据复用&lt;/strong&gt;，因此我们更需要了解一下多继承体系中的内存布局。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个普通的类来说，内存布局就是按照成员的声明顺序来布局的，与 C 语言中结构体布局相同，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test1&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; a;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; b;&lt;br/&gt;  short c;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么&lt;code&gt;Test1&lt;/code&gt;的内存布局就是&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字节编号&lt;/th&gt;&lt;th&gt;内容&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;a&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1~3&lt;/td&gt;&lt;td&gt;内存对齐保留字节&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4~7&lt;/td&gt;&lt;td&gt;b&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;8~9&lt;/td&gt;&lt;td&gt;c&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;9~11&lt;/td&gt;&lt;td&gt;内存对齐保留字节&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果类中含有虚函数，那么还会在末尾添加虚函数表的指针，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test1&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; a;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; b;&lt;br/&gt;  short c;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字节编号&lt;/th&gt;&lt;th&gt;内容&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;a&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1~3&lt;/td&gt;&lt;td&gt;内存对齐保留字节&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4~7&lt;/td&gt;&lt;td&gt;b&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;8~9&lt;/td&gt;&lt;td&gt;c&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;9~15&lt;/td&gt;&lt;td&gt;内存对齐保留字节&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;16~23&lt;/td&gt;&lt;td&gt;虚函数表指针&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多继承时，第一父类的虚函数表会与本类合并，其他父类的虚函数表&lt;strong&gt;单独存在&lt;/strong&gt;，并排列在本类成员的后面。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;菱形继承与虚拟继承&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++由于支持“普适意义上的多继承”，那么就会有一种特殊情况——菱形继承，请看例程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a1, a2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; :&lt;/span&gt; A {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; b1, b2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;C&lt;/span&gt; :&lt;/span&gt; A {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; c1, c2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;D&lt;/span&gt; :&lt;/span&gt; B, C {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; d1, d2;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据内存布局原则，&lt;code&gt;D&lt;/code&gt;类首先是&lt;code&gt;B&lt;/code&gt;类的元素，然后&lt;code&gt;D&lt;/code&gt;类自己的元素，最后是&lt;code&gt;C&lt;/code&gt;类元素：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字节序号&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0~15&lt;/td&gt;&lt;td&gt;B 类元素&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;16~19&lt;/td&gt;&lt;td&gt;d1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;20~23&lt;/td&gt;&lt;td&gt;d2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;24~31&lt;/td&gt;&lt;td&gt;C 类元素&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果再展开，会变成这样：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字节序号&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0~3&lt;/td&gt;&lt;td&gt;a1（B 类继承自 A 类的）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4~7&lt;/td&gt;&lt;td&gt;a2（B 类继承自 A 类的）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;8~11&lt;/td&gt;&lt;td&gt;b1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;12~15&lt;/td&gt;&lt;td&gt;b2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;16~19&lt;/td&gt;&lt;td&gt;d1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;20~23&lt;/td&gt;&lt;td&gt;d2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;24~27&lt;/td&gt;&lt;td&gt;a1（C 类继承自 A 类的）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;28~31&lt;/td&gt;&lt;td&gt;a1（C 类继承自 A 类的）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;32~35&lt;/td&gt;&lt;td&gt;c1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;36~39&lt;/td&gt;&lt;td&gt;c2&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现，A 类的成员出现了 2 份，这就是所谓“菱形继承”产生的副作用。这也是 C++的内存布局当中的一种缺陷，多继承时第一个父类作为主父类合并，而其余父类则是直接向后扩写，这个过程中没有去重的逻辑（详情参考上一节）。这样的话不仅浪费空间，还会出现二义性问题，例如&lt;code&gt;d.a1&lt;/code&gt;到底是指从&lt;code&gt;B&lt;/code&gt;继承来的&lt;code&gt;a1&lt;/code&gt;还是从&lt;code&gt;C&lt;/code&gt;里继承来的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++引入虚拟继承的概念就是为了解决这一问题。但怎么说呢，C++的复杂性往往都是因为&lt;strong&gt;为了解决一种缺陷而引入了另一种缺陷&lt;/strong&gt;，虚拟继承就是非常典型的例子，如果你直接去解释虚拟继承（比如说和普通继承的区别）你一定会觉得莫名其妙，为什么要引入一种这样奇怪的继承方式。所以这里需要我们了解到，它是为了解决菱形继承时空间爆炸的问题而不得不引入的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来看一下普通的继承和虚拟继承的区别：
普通继承：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a1, a2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; :&lt;/span&gt; A {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; b1, b2;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;B&lt;/code&gt;的对象模型应该是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0935185185185186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavksacmwyadfgq1gj1bPsh3CmqsSYicTa88tSeOTD3vLSfiaA08ADShf4k50SiaAgfbvia50GmVKzabWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而如果使用虚拟继承:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a1, a2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; A {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; b1, b2;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象模型是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0787037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavksacmwyadfgq1gj1bPsh34xjKkaaGq1EBDrvV2VIib0EfUmefKdibjDPrIPMedwp0DXO6ic7CsLToA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟继承的排布方式就类似于虚函数的排布，子类对象会自动生成一个虚基表来指向虚基类成员的首地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像刚才说的那样，单纯的虚拟继承看上去很离谱，因为完全没有必要强行更换这样的内存布局，所以绝大多数情况下我们是不会用虚拟继承的。但是菱形继承的情况，就不一样了，普通的菱形继承会这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a1, a2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; :&lt;/span&gt; A {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; b1, b2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;C&lt;/span&gt; :&lt;/span&gt; A {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; c1, c2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;D&lt;/span&gt; :&lt;/span&gt; B, C {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; d1, d2;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;D&lt;/code&gt;的对象模型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8296296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavksacmwyadfgq1gj1bPsh3Yicg00TeNsLiaecAtoUJrkMUTic9TWaDMMnuyn3rvwS4qMExjOAG7FjQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果使用虚拟继承，则可以把每个类单独的东西抽出来，重复的内容则用指针来指向：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a1, a2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; A {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; b1, b2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;C&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; A {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; c1, c2;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;D&lt;/span&gt; :&lt;/span&gt; B, C {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; d1, d2;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;D&lt;/code&gt;的对象模型将会变成：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.6854368932038835&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavksacmwyadfgq1gj1bPsh3iaeRum7iaRGZibJndZpTOqvvQHkUupoNCQ6UYCAY7wGeubQEY4OyUapqg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1030&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说此时，共有的虚基类只会保存一份，这样就不会有二义性，同时也节省了空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但需要注意的是，&lt;code&gt;D&lt;/code&gt;继承自&lt;code&gt;B&lt;/code&gt;和&lt;code&gt;C&lt;/code&gt;时是普通继承，如果用了虚拟继承，则会在 D 内部又额外添加一份虚基表指针。要虚拟继承的是&lt;code&gt;B&lt;/code&gt;和&lt;code&gt;C&lt;/code&gt;对&lt;code&gt;A&lt;/code&gt;的继承，这也是虚拟继承语法非常迷惑的地方，也就是说，菱形继承的&lt;strong&gt;分支处要用虚拟继承&lt;/strong&gt;，而&lt;strong&gt;汇聚处要用普通继承&lt;/strong&gt;。所以我们还是要明白其底层原理，以及引入这个语法的原因（针对解决的问题），才能更好的使用这个语法，避免出错。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;隐式构造&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;隐式构造指的就是隐式调用构造函数。换句话说，我们不用写出类型名，而是仅仅给出构造参数，编译期就会自动用它来构造对象。举例来说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Test(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b) {}&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Test &amp;amp;t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; f({&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;}); &lt;span&gt;// 隐式构造Test临时对象，相当于f(Test{a, b})&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面例子中，&lt;code&gt;f&lt;/code&gt;需要接受的是&lt;code&gt;Test&lt;/code&gt;类型的对象，然而我们在调用时仅仅使用了构造参数，并没有指定类型，但编译器会进行隐式构造。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其，当构造参数只有 1 个的时候，可以省略大括号：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;：&lt;br/&gt;  Test(&lt;span&gt;int&lt;/span&gt; a) {}&lt;br/&gt;  Test(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b) {}&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Test &amp;amp;t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f(&lt;span&gt;1&lt;/span&gt;); &lt;span&gt;// 隐式构造Test{1}，单参时可以省略大括号&lt;/span&gt;&lt;br/&gt;  f({&lt;span&gt;2&lt;/span&gt;}); &lt;span&gt;// 隐式构造Test{2}&lt;/span&gt;&lt;br/&gt;  f({&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;}); &lt;span&gt;// 隐式构造Test{1, 2}&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的好处显而易见，就是可以让代码简化，尤其是在构造&lt;code&gt;string&lt;/code&gt;或者&lt;code&gt;vector&lt;/code&gt;的时候更加明显：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &amp;amp;str)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; &amp;amp;ve)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f1(&lt;span&gt;&quot;123&quot;&lt;/span&gt;); &lt;span&gt;// 隐式构造std::string{&quot;123&quot;}，注意字符串常量是const char *类型&lt;/span&gt;&lt;br/&gt;  f2({&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;}); &lt;span&gt;// 隐式构造std::vector，注意这里是initialize_list构造&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果遇到函数重载，原类型的优先级大于隐式构造，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Test(&lt;span&gt;int&lt;/span&gt; a) {}&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Test &amp;amp;t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f(&lt;span&gt;5&lt;/span&gt;); &lt;span&gt;// 会输出2&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果有多种类型的隐式构造则会报二义性错误：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test1&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Test1(&lt;span&gt;int&lt;/span&gt; a) {}&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  Test2(&lt;span&gt;int&lt;/span&gt; a) {}&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Test1 &amp;amp;t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Test2 &amp;amp;t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f(&lt;span&gt;5&lt;/span&gt;); &lt;span&gt;// ERR，二义性错误&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在返回值场景也支持隐式构造，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;err_t&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; err_code;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *err_msg;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;err_t&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;success&quot;&lt;/span&gt;}; &lt;span&gt;// 隐式构造err_t&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但隐式构造有时会让代码含义模糊，导致意义不清晰的问题（尤其是单参的构造函数），例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;System&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  System(&lt;span&gt;int&lt;/span&gt; version);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Operate&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; System &amp;amp;sys, &lt;span&gt;int&lt;/span&gt; cmd)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Operate(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;); &lt;span&gt;// 意义不明确，不容易让人意识到隐式构造&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上例中，&lt;code&gt;System&lt;/code&gt;表示一个系统，其构造参数是这个系统的版本号。那么这时用版本号的隐式构造就显得很突兀，而且只通过&lt;code&gt;Operate(1, 2)&lt;/code&gt;这种调用很难让人想到第一个参数竟然是&lt;code&gt;System&lt;/code&gt;类型的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，是否应当隐式构造，取决于隐式构造的场景，例如我们用&lt;code&gt;const char *&lt;/code&gt;来构造&lt;code&gt;std::string&lt;/code&gt;就很自然，用一组数据来构造一个&lt;code&gt;std::vector&lt;/code&gt;也很自然，或者说，代码的阅读者非常直观地能反应出来这里发生了隐式构造，那么这里就适合隐式构造，否则，这里就应当限定必须显式构造。用&lt;code&gt;explicit&lt;/code&gt;关键字限定的构造函数不支持隐式构造：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;：&lt;br/&gt;  &lt;span&gt;&lt;span&gt;explicit&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;explicit&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  Test(&lt;span&gt;int&lt;/span&gt; *p);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Test &amp;amp;t)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f(&lt;span&gt;1&lt;/span&gt;); &lt;span&gt;// ERR，f不存在int参数重载，Test的隐式构造不允许用（因为有explicit限定），所以匹配失败&lt;/span&gt;&lt;br/&gt;  f(Test{&lt;span&gt;1&lt;/span&gt;}); &lt;span&gt;// OK，显式构造&lt;/span&gt;&lt;br/&gt;  f({&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;}); &lt;span&gt;// ERR，同理，f不存在int, int参数重载，Test隐式构造不许用（因为有explicit限定），匹配失败&lt;/span&gt;&lt;br/&gt;  f(Test{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;}); &lt;span&gt;// OK，显式构造&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;  f(&amp;amp;a); &lt;span&gt;// OK，隐式构造，调用Test(int *)构造函数&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种情况就是，对于变参的构造函数来说，更要优先考虑要不要加&lt;code&gt;explicit&lt;/code&gt;，因为变参包括了单参，并且默认情况下所有类型的构造（模板的所有实例，任意类型、任意个数）都会支持隐式构造，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt;... Args&amp;gt;&lt;br/&gt;  Test(Args&amp;amp;&amp;amp;... args);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Test &amp;amp;t)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f(&lt;span&gt;1&lt;/span&gt;); &lt;span&gt;// 隐式构造Test{1}&lt;/span&gt;&lt;br/&gt;  f({&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;}); &lt;span&gt;// 隐式构造Test{1, 2}&lt;/span&gt;&lt;br/&gt;  f(&lt;span&gt;&quot;abc&quot;&lt;/span&gt;); &lt;span&gt;// 隐式构造Test{&quot;abc&quot;}&lt;/span&gt;&lt;br/&gt;  f({&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;abc&quot;&lt;/span&gt;}); &lt;span&gt;// 隐式构造Test{0, &quot;abc&quot;}&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以避免爆炸（生成很多不可控的隐式构造），对于变参构造最好还是加上&lt;code&gt;explicit&lt;/code&gt;，如果不加的话一定要慎重考虑其可能实例化的每一种情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在谷歌规范中，单参数构造函数必须用&lt;code&gt;explicit&lt;/code&gt;限定，但笔者认为这个规范并不完全合理，在个别情况隐式构造意义非常明确的时候，还是应当允许使用隐式构造。另外，即便是多参数的构造函数，如果当隐式构造意义不明确时，同样也应当用&lt;code&gt;explicit&lt;/code&gt;来限定。所以还是要视情况而定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++支持隐式构造，自然考虑的是一些场景下代码更简洁，但归根结底在于&lt;strong&gt;C++主要靠 STL 来扩展功能，而不是语法&lt;/strong&gt;。举例来说，在 Swift 中，原生语法支持数组、map、字符串等：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; arr = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;] &lt;span&gt;// 数组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; &lt;span&gt;map&lt;/span&gt; = [&lt;span&gt;1&lt;/span&gt; : &lt;span&gt;&quot;abc&quot;&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt; : &lt;span&gt;&quot;hhh&quot;&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt; : &lt;span&gt;&quot;fail&quot;&lt;/span&gt;] &lt;span&gt;// map&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; str = &lt;span&gt;&quot;123abc&quot;&lt;/span&gt; &lt;span&gt;// 字符串&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，它并不需要所谓隐式构造的场景，因为语法本身已经表明了它的类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 C++不同，C++并没有原生支持&lt;code&gt;std::vector&lt;/code&gt;、&lt;code&gt;std::map&lt;/code&gt;、&lt;code&gt;std::string&lt;/code&gt;等的语法，这就会让我们在使用这些基础工具的时候很头疼，因此引入隐式构造来简化语法。所以归根结底，C++语言本身考虑的是语法层面的功能，而数据逻辑层面靠 STL 来解决，二者并不耦合。但又希望程序员能够更加方便地使用 STL，因此引入了一些语言层面的功能，但它却像全体类型开放了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例来说，Swift 中，&lt;code&gt;[1, 2, 3]&lt;/code&gt;的语法强绑定&lt;code&gt;Array&lt;/code&gt;类型，&lt;code&gt;[k1:v1, k2,v2]&lt;/code&gt;的语法强绑定&lt;code&gt;Map&lt;/code&gt;类型，因此这里的“语言”和“工具”是耦合的。但 C++并不和 STL 耦合，他的思路是&lt;code&gt;{x, y, z}&lt;/code&gt;就是构造参数，哪种类型都可以用，你交给&lt;code&gt;vector&lt;/code&gt;时就是表示数组，你交给&lt;code&gt;map&lt;/code&gt;时就是表示 kv 对，并不会将“语法”和“类型”做任何强绑定。因此把隐式构造和&lt;code&gt;explicit&lt;/code&gt;都提供出来，交给开发者自行处理是否支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我们需要体会的 C++设计理念，当然，也可以算是 C++的缺陷。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;C 风格字符串&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串同样是 C++特别容易踩坑的位置。出于对 C 语言兼容、以及上一节所介绍的 C++希望将“语言”和“类型”解耦的设计理念的目的，在 C++中，字符串并没有映射为&lt;code&gt;std::string&lt;/code&gt;类型，而是保留 C 语言当中的处理方式。编译期会将字符串常量存储在一个全局区，然后再使用字符串常量的位置用一个指针代替。所以基本可以等价认为，字符串常量（字面量）是&lt;code&gt;const char *&lt;/code&gt;类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，更多的场景下，我们都会使用&lt;code&gt;std::string&lt;/code&gt;类型来保存和处理字符串，因为它功能更强大，使用更方便。得益于隐式构造，我们可以把一个字符串常量轻松转化为&lt;code&gt;std::string&lt;/code&gt;类型来处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但本质上来说，&lt;code&gt;std::string&lt;/code&gt;和&lt;code&gt;const char *&lt;/code&gt;是两种类型，所以一些场景下它还是会出问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类型推导问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进行类型推导时，字符串常量会按&lt;code&gt;const char *&lt;/code&gt;来处理，有时会导致问题，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(T *t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  f(&lt;span&gt;&quot;123&quot;&lt;/span&gt;);&lt;br/&gt;  f(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;123&quot;&lt;/span&gt;});&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的原意是将“值类型”和“指针类型”分开处理，至于字符串，照理说应当是一个“对象”，所以要按照值类型来处理。但如果我们用的是字符串常量，则会识别为&lt;code&gt;const char *&lt;/code&gt;类型，直接匹配到了指针处理方式，而并不会触发隐式构造。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;截断问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C 风格字符串有一个约定，就是以 0 结尾。它并不会去单独存储数据长度，而是很暴力地从首地址向后查找，找到 0 为止。但&lt;code&gt;std::string&lt;/code&gt;不同，其内部有统计个数的成员，因此不会受 0 值得影响：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; str1{&lt;span&gt;&quot;123\0abc&quot;&lt;/span&gt;}; &lt;span&gt;// 0处会截断&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; str2{&lt;span&gt;&quot;123\0abc&quot;&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;}; &lt;span&gt;// 不会截断&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截断问题在传参时更加明显，比如说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *str)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; str2{&lt;span&gt;&quot;123\0abc&quot;&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;};&lt;br/&gt;  &lt;span&gt;// 由于f只支持C风格字符串，因此转化后传入&lt;/span&gt;&lt;br/&gt;  f(str2.c_str()); &lt;span&gt;// 但其实已经被截断了&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的章节曾经提到过，C++没有引入额外的格式符，因此把&lt;code&gt;std::string&lt;/code&gt;传入格式化函数的时候，也容易发生截断问题：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &lt;span&gt;MakeDesc&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &amp;amp;head, &lt;span&gt;double&lt;/span&gt; data)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 拼凑一个xxx:ff%的形式&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;128&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;sprintf&lt;/span&gt;(buf, &lt;span&gt;&quot;%s:%lf%%&quot;&lt;/span&gt;, head.c_str(), data); &lt;span&gt;// 这里有可能截断&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; buf; &lt;span&gt;// 这里也有可能截断&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，C 风格的字符串永远难逃 0 值截断问题，而又因为 C++中仍然保留了 C 风格字符串的所有行为，并没有在语言层面直接关联&lt;code&gt;std::string&lt;/code&gt;，因此在使用时一定要小心截断问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;指针意义不明问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 C++保留了 C 风格字符串的行为，因此在很多场景下，把&lt;code&gt;const char *&lt;/code&gt;就默认为了字符串，都会按照字符串去解析。但有时可能会遇到一个真正的指针，那么此时就会有问题，比如说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; b;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;; &lt;span&gt;// 流接受指针，打印指针的值&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;b &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;; &lt;span&gt;// 流接收char *，按字符串处理&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;STL 中所有流接收到&lt;code&gt;char *&lt;/code&gt;或&lt;code&gt;const char *&lt;/code&gt;时，并不会按指针来解析，而是按照字符串解析。在上面例子中，&lt;code&gt;&amp;amp;b&lt;/code&gt;本身应当就是个单纯指针，但是输出流却将其按照字符串处理了，也就是会持续向后搜索找到 0 值为止，那这里显然是发生越界了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，如果我们给&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;signed char&lt;/code&gt;、&lt;code&gt;unsigned char&lt;/code&gt;类型取地址时，一定要考虑会不会被识别为字符串。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;int8_t 和 uint8_t&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原本&lt;code&gt;int8_t&lt;/code&gt;和&lt;code&gt;uint8_t&lt;/code&gt;是用来表示“8 位整数”的，但是不巧的是，他们的定义是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;int8_t&lt;/span&gt; = &lt;span&gt;signed&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;uint8_t&lt;/span&gt; = &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 C 语言历史原因，ASCII 码只有 7 位，所以“字符”类型有无符号是没区别的，而当时没有定制规范，因此不同编译器可能有不同处理。到后来干脆把&lt;code&gt;char&lt;/code&gt;当做独立类型了。所以&lt;code&gt;char&lt;/code&gt;和&lt;code&gt;signed char&lt;/code&gt;以及&lt;code&gt;unsigned char&lt;/code&gt;是不同类型。这与其他类型不同，例如&lt;code&gt;int&lt;/code&gt;和&lt;code&gt;signed int&lt;/code&gt;是同一类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是类似于流的处理中，却没有把&lt;code&gt;signed char&lt;/code&gt;和&lt;code&gt;unsigned char&lt;/code&gt;单独拿出来处理，都是按照字符来处理了（这里笔者也不知道什么原因）。而&lt;code&gt;int8_t&lt;/code&gt;和&lt;code&gt;uint8_t&lt;/code&gt;又是基于此定义的，所以也会出现奇怪问题，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;uint8_t&lt;/span&gt; n = &lt;span&gt;56&lt;/span&gt;; &lt;span&gt;// 这里是单纯想放一个整数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;; &lt;span&gt;// 但这里会打印出8，而不是56&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原本&lt;code&gt;uint8_t&lt;/code&gt;是想屏蔽掉&lt;code&gt;char&lt;/code&gt;这层含义，让它单纯地表示 8 位整数的，但是在 STL 的解析中，却又让它有了“字符”的含义，去按照 ASCII 码来解析了，让&lt;code&gt;uint8_t&lt;/code&gt;的定义又失去了原本该有的含义，所以这里也是很容易踩坑的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（这一点笔者真的没想明白为什么，明明是不同类型，但为什么没有区分开。可能同样是历史原因吧，总之这个点可以算得上真正意义上的“缺陷”了。）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;new 和 delete&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;new&lt;/code&gt;这个运算符相信大家一定不陌生，即便是非 C++系其他语言一般都会保留&lt;code&gt;new&lt;/code&gt;这个关键字。而且这个已经成为业界的一个哏了，比如说“没有对象怎么办？不怕，new 一个！”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从字面意思就能看得出，这是“新建”的意思，不过在 C++中，&lt;code&gt;new&lt;/code&gt;远不止字面看上去这么简单。而且，&lt;code&gt;delete&lt;/code&gt;关键字基本算得上是 C++的特色了，其他语言中基本见不到。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分配和释放空间&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“堆空间”的概念同样继承自 C 语言，它是提供给程序手动管理、调用的内存空间。在 C 语言中，&lt;code&gt;malloc&lt;/code&gt;用于分配堆空间，&lt;code&gt;free&lt;/code&gt;用于回收。自然，在 C++中仍然可以用&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但使用&lt;code&gt;malloc&lt;/code&gt;有一个不方便的地方，我们来看一下&lt;code&gt;malloc&lt;/code&gt;的函数原型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;malloc&lt;/code&gt;接收的是字节数，也就是我们需要手动计算出我们需要的空间是多少字节。它不能方便地通过某种类型直接算出空间，通常需要&lt;code&gt;sizeof&lt;/code&gt;运算。&lt;code&gt;malloc&lt;/code&gt;返回值是&lt;code&gt;void *&lt;/code&gt;类型，是一个泛型指针，也就是没有指定默认解类型的，使用时通常需要类型转换，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; *data = (&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;new&lt;/code&gt;运算符可以完美解决上面的问题，注意，在 C++中&lt;code&gt;new&lt;/code&gt;是一个&lt;strong&gt;运算符&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; *data = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，&lt;code&gt;delete&lt;/code&gt;也是一个&lt;strong&gt;运算符&lt;/strong&gt;，用于释放空间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;delete&lt;/span&gt; data;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;运算符本质是函数调用&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟悉 C++运算符重载的读者一定清楚，C++中运算符的本质其实就是一个函数的语法糖，例如&lt;code&gt;a + b&lt;/code&gt;实际上就是&lt;code&gt;operator +(a, b)&lt;/code&gt;，&lt;code&gt;a++&lt;/code&gt;实际上就是&lt;code&gt;a.operator++()&lt;/code&gt;，甚至仿函数、下标运算也都是函数调用，比如&lt;code&gt;f()&lt;/code&gt;就是&lt;code&gt;f.operator()()&lt;/code&gt;，&lt;code&gt;a[i]&lt;/code&gt;就是&lt;code&gt;a.operator[](i)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;也是运算符，那么它就应当也符合这个原理，一定有一个&lt;code&gt;operator new&lt;/code&gt;的函数存在，下面是它的函数原型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; size, &lt;span&gt;void&lt;/span&gt; *ptr)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个跟我们直观想象可能有点不一样，它的返回值仍然是&lt;code&gt;void *&lt;/code&gt;，也并不是一个模板函数用来判断大小。所以，&lt;code&gt;new&lt;/code&gt;运算符跟其他运算符并不一样，它并不只是单纯映射成&lt;code&gt;operator new&lt;/code&gt;，而是做了一些额外操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，这个拥有 2 个参数的重载又是怎么回事呢？这个等一会再来解释。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统内置的&lt;code&gt;operator new&lt;/code&gt;本质上就是&lt;code&gt;malloc&lt;/code&gt;，所以如果我们直接调&lt;code&gt;operator new&lt;/code&gt;和&lt;code&gt;operator delete&lt;/code&gt;的话，本质上来说，和&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;其实没什么区别：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; *data = &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt; *&amp;gt;(&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;)));&lt;br/&gt;&lt;span&gt;&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(data)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而当我们用运算符的形式来书写时，编译器会自动处理类型的大小，以及返回值。&lt;code&gt;new&lt;/code&gt;运算符必须作用于一个类型，编译器会将这个类型的 size 作为参数传给&lt;code&gt;operator new&lt;/code&gt;，并把返回值转换为这个类型的指针，也就是说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; T;&lt;br/&gt;&lt;span&gt;// 等价于&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static_cast&lt;/span&gt;&amp;lt;T *&amp;gt;(&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(T)))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;delete&lt;/code&gt;运算符要作用于一个指针，编译器会将这个指针作为参数传给&lt;code&gt;operator delete&lt;/code&gt;，也就是说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;delete&lt;/span&gt; ptr;&lt;br/&gt;&lt;span&gt;// 等价于&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(ptr)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;重载 new 和 delete&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以要引入&lt;code&gt;operator new&lt;/code&gt;和&lt;code&gt;operator delete&lt;/code&gt;还有一个原因，就是可以重载。默认情况下，它们操作的是堆空间，但是我们也可以通过重载来使得其操作自己的内存池。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;std&lt;/span&gt;::byte buffer[&lt;span&gt;16&lt;/span&gt;][&lt;span&gt;64&lt;/span&gt;]; &lt;span&gt;// 一个手动的内存池&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;array&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt; *, 16&amp;gt; buf_mark {&lt;span&gt;nullptr&lt;/span&gt;}; &lt;span&gt;// 统计已经使用的内存池单元&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a, b;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; size)&lt;/span&gt; &lt;span&gt;noexcept&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 重载operator new&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *ptr)&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 重载operator delete&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *Test::&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; size)&lt;/span&gt; &lt;span&gt;noexcept&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 从buffer中分配资源&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;16&lt;/span&gt;; i++) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (buf_mark.at(i) == &lt;span&gt;nullptr&lt;/span&gt;) {&lt;br/&gt;      buf_mark.at(i) = buffer[i];&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; buffer[i];&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nullptr&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; Test::&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *ptr)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;16&lt;/span&gt;; i++) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (buf_mark.at(i) == ptr) {&lt;br/&gt;      buf_mark.at(i) = &lt;span&gt;nullptr&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Test *t1 = &lt;span&gt;new&lt;/span&gt; Test; &lt;span&gt;// 会在buffer中分配&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;delete&lt;/span&gt; t1; &lt;span&gt;// 释放buffer中的资源&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个点，相信大家已经发现了，&lt;code&gt;operator new&lt;/code&gt;和&lt;code&gt;operator delete&lt;/code&gt;是支持异常抛出的，而我们这里引用直接用空指针来表示分配失败的情况了，于是加上了&lt;code&gt;noexcept&lt;/code&gt;修饰。而默认的情况下，可以通过接收异常来判断是否分配成功，而不用每次都对指针进行判空。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;构造函数和 placement new&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;malloc&lt;/code&gt;的另一个问题就是处理非平凡构造的类类型。当一个类是非平凡构造时，它可能含有虚函数表、虚基表，还有可能含有一些额外的构造动作（比如说分配空间等等），我们拿一个最简单的字符串处理类为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  String(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *str);&lt;br/&gt;  ~String();&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; *buf;&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; size;&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; capicity;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;String::String(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *str):&lt;br/&gt;    buf((&lt;span&gt;char&lt;/span&gt; *)&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;strlen&lt;/span&gt;(str) + &lt;span&gt;1&lt;/span&gt;)),&lt;br/&gt;    size(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;strlen&lt;/span&gt;(str)),&lt;br/&gt;    capicity(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;strlen&lt;/span&gt;(str) + &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;memcpy&lt;/span&gt;(buf, str, capicity);&lt;br/&gt;}&lt;br/&gt;String::~String() {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (buf != &lt;span&gt;nullptr&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;free&lt;/span&gt;(buf);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  String *str = (String *)&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(String));&lt;br/&gt;  &lt;span&gt;// 再使用str一定是有问题的，因为没有正常构造&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面例子中，&lt;code&gt;String&lt;/code&gt;就是一个非平凡的类型，它在构造函数中创建了堆空间。如果我们直接通过&lt;code&gt;malloc&lt;/code&gt;分配一片&lt;code&gt;String&lt;/code&gt;大小的空间，然后就直接用的话，显然是会出问题的，因为构造函数没有执行，其中&lt;code&gt;buf&lt;/code&gt;管理的堆空间也是没有进行分配的。
所以，在 C++中，创建一个对象应该分 2 步：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;分配内存空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用构造函数&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，释放一个对象也应该分 2 步：&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;调用析构函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;释放内存空间&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个理念在 OC 语言中贯彻得非常彻底，OC 中没有默认的构造函数，都是通过实现一个类方法来进行构造的，因此构造前要先分配空间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;NSString&lt;/span&gt; *str = [&lt;span&gt;NSString&lt;/span&gt; alloc]; &lt;span&gt;// 分配NSString大小的内存空间&lt;/span&gt;&lt;br/&gt;[str init]; &lt;span&gt;// 调用初始化函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 通常简写为：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;NSString&lt;/span&gt; *str = [[&lt;span&gt;NSString&lt;/span&gt; alloc] init];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在 C++中，初始化方法并不是一个普通的类方法，而是特殊的构造函数，那如何手动调用构造函数呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，要想调用构造函数（构造一个对象），我们首先需要一个分配好的内存空间。因此，要拿着&lt;strong&gt;用于构造的内存空间&lt;/strong&gt;，以构造参数，才能构造一个对象（也就是调用构造函数）。C++管这种语法叫做&lt;strong&gt;就地构造（placement new）&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String *str = &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;String *&amp;gt;(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(String))); &lt;span&gt;// 分配内存空间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt;(str) String(&lt;span&gt;&quot;abc&quot;&lt;/span&gt;); &lt;span&gt;// 在str指向的位置调用String的构造函数&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就地构造的语法就是&lt;code&gt;new(addr) T(args...)&lt;/code&gt;，看得出，这也是&lt;code&gt;new&lt;/code&gt;运算符的一种。这时我们再回去看&lt;code&gt;operator new&lt;/code&gt;的一个重载，应该就能猜到它是干什么的了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; size, &lt;span&gt;void&lt;/span&gt; *ptr)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是用于支持就地构造的函数。
要注意的是，如果是通过就地构造方式构造的对象，需要再回收内存空间之前进行析构。以上面&lt;code&gt;String&lt;/code&gt;为例，如果不析构直接回收，那么&lt;code&gt;buf&lt;/code&gt;所指的空间就不能得到释放，从而造成内存泄漏：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;str-&amp;gt;~String(); &lt;span&gt;// 析构&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;free&lt;/span&gt;(str); &lt;span&gt;// 释放内存空间&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;new = operator new + placement new&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到本节的标题，相信读者会恍然大悟。C++中&lt;code&gt;new&lt;/code&gt;运算符同时承担了“分配空间”和“构造对象”的任务。上一节的例子中我们是通过&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;来管理的，自然，通过&lt;code&gt;operator new&lt;/code&gt;和&lt;code&gt;operator delete&lt;/code&gt;也是一样的，而且它们还支持针对类型的重载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们说，一次&lt;code&gt;new&lt;/code&gt;，相当于先&lt;code&gt;operator new&lt;/code&gt;（分配空间）加&lt;code&gt;placement new&lt;/code&gt;（调用构造函数）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String *str = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;abc&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 等价于&lt;/span&gt;&lt;br/&gt;String *str = &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;String *&amp;gt;(&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(String)));&lt;br/&gt;&lt;span&gt;new&lt;/span&gt;(str) String(&lt;span&gt;&quot;abc&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，一次&lt;code&gt;delete&lt;/code&gt;相当于先“析构”，再&lt;code&gt;operator delete&lt;/code&gt;（释放空间）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;delete&lt;/span&gt; str;&lt;br/&gt;&lt;span&gt;// 等价于&lt;/span&gt;&lt;br/&gt;str-&amp;gt;~String();&lt;br/&gt;&lt;span&gt;&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(str)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;的神秘面纱，它确实和普通的运算符不一样，除了对应的&lt;code&gt;operator&lt;/code&gt;函数外，还有对构造、析构的处理。
但也正是由于 C++总是进行一些隐藏操作，才会复杂度激增，有时也会出现一些难以发现的问题，所以我们一定要弄清楚它的本质。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;new []和 delete []&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;new []&lt;/code&gt;和&lt;code&gt;delete []&lt;/code&gt;的语法看起来是“创建/删除数组”的语法。但其实它们也并不特殊，就是封装了一层的&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;[](&lt;span&gt;size_t&lt;/span&gt; size);&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;[](&lt;span&gt;void&lt;/span&gt; *ptr);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，&lt;code&gt;operator new[]&lt;/code&gt;和&lt;code&gt;operator new&lt;/code&gt;完全一样，&lt;code&gt;opeator delete[]&lt;/code&gt;和&lt;code&gt;operator delete&lt;/code&gt;也完全一样，所以区别应当在编译器的解释上。&lt;code&gt;operator new T[size]&lt;/code&gt;的时候，会计算出&lt;code&gt;size&lt;/code&gt;个&lt;code&gt;T&lt;/code&gt;类型的总大小，然后调用&lt;code&gt;operator new[]&lt;/code&gt;，之后，会依次对每个元素进行构造。也就是说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String *arr_str = &lt;span&gt;new&lt;/span&gt; String [&lt;span&gt;4&lt;/span&gt;] {&lt;span&gt;&quot;abc&quot;&lt;/span&gt;, &lt;span&gt;&quot;def&quot;&lt;/span&gt;, &lt;span&gt;&quot;123&quot;&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;// 等价于&lt;/span&gt;&lt;br/&gt;String *arr_str = &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;String *&amp;gt;(opeartor &lt;span&gt;new&lt;/span&gt;[](&lt;span&gt;sizeof&lt;/span&gt;(String) * &lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;new&lt;/span&gt;(arr_str) String(&lt;span&gt;&quot;abc&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;new&lt;/span&gt;(arr_str + &lt;span&gt;1&lt;/span&gt;) String(&lt;span&gt;&quot;def&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;new&lt;/span&gt;(arr_str + &lt;span&gt;2&lt;/span&gt;) String(&lt;span&gt;&quot;123&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;new&lt;/span&gt;(arr_str + &lt;span&gt;3&lt;/span&gt;) String; &lt;span&gt;// 没有写在列表中的会用无参构造函数&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，&lt;code&gt;delete []&lt;/code&gt;会首先依次调用析构，然后再调用&lt;code&gt;operator delete []&lt;/code&gt;来释放空间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;delete&lt;/span&gt; [] arr_str;&lt;br/&gt;&lt;span&gt;// 等价于&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++) {&lt;br/&gt;  arr_str[i].~String();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;operator&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;[] (arr_str);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结下来&lt;code&gt;new []&lt;/code&gt;相当于一次内存分配加多次就地构造，&lt;code&gt;delete []&lt;/code&gt;运算符相当于多次析构加一次内存释放。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;constexpr&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;constexpr&lt;/code&gt;全程叫“常量表达式（constant expression）”，顾名思义，将一个表达式定义为“常量”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于“常量”的概念笔者在前面“const 引用”的章节已经详细叙述过，只有像&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;&#x27;a&#x27;&lt;/code&gt;，&lt;code&gt;2.5f&lt;/code&gt;之类的才是真正的常量。储存在内存中的数据都应当叫做“变量”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但很多时候我们在程序编写的时候，会遇到一些&lt;strong&gt;编译期就能确定的量&lt;/strong&gt;，但&lt;strong&gt;不方便直接用常量表达&lt;/strong&gt;的情况。最简单的一个例子就是“魔鬼数字”：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;err_t&lt;/span&gt; = &lt;span&gt;int&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;err_t&lt;/span&gt; &lt;span&gt;Process&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 某些错误&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;25&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为错误码的时候，我们只能知道业界约定&lt;code&gt;0&lt;/code&gt;表示成功，但其他的错误码就不知道什么含义了，比如这里的&lt;code&gt;25&lt;/code&gt;号错误码，非常突兀，根本不知道它是什么含义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C 中的解决的办法就是定义宏，又有宏是预编译期进行替换的，因此它在编译的时候一定是作为常量存在的，我们又可以通过宏名称来增加可读性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; ERR_DATA_NOT_FOUNT 25&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; SUCC 0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;err_t&lt;/span&gt; = &lt;span&gt;int&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;err_t&lt;/span&gt; &lt;span&gt;Process&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 某些错误&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ERR_DATA_NOT_FOUNT;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; SUCC;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（对于错误码的场景当然还可以用枚举来实现，这里就不再赘述了。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用宏虽然可以解决魔数问题，但是宏本身是不推荐使用的，详情大家可以参考前面“宏”的章节，里面介绍了很多宏滥用的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过最主要的一点就是宏不是类型安全的。我们既希望定义一个类型安全的数据，又不希望这个数据成为“变量”来占用内存空间。这时，就可以使用 C++11 引入的&lt;code&gt;constexpr&lt;/code&gt;概念。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; pi = &lt;span&gt;3.141592654&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;double&lt;/span&gt; &lt;span&gt;Squ&lt;/span&gt;&lt;span&gt;(&lt;span&gt;double&lt;/span&gt; r)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; pi * r * r;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;code&gt;pi&lt;/code&gt;虽然是&lt;code&gt;double&lt;/code&gt;类型的，类型安全，但因为用&lt;code&gt;constexpr&lt;/code&gt;修饰了，因此它会在编译期间成为“常量”，而不会占用内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用&lt;code&gt;constexpr&lt;/code&gt;修饰的表达式，会保留其原有的作用域和类型（例如上面的&lt;code&gt;pi&lt;/code&gt;就跟全局变量的作用域是一样的），只是会变成编译期常量。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;constexpr 可以当做常量使用&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然&lt;code&gt;constexpr&lt;/code&gt;叫“常量表达式”，那么也就是说有一些编译期参数只能用常量，用&lt;code&gt;constexpr&lt;/code&gt;修饰的表达式也可以充当。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例来说，模板参数必须是一个编译期确定的量，那么除了常量外，&lt;code&gt;constexpr&lt;/code&gt;修饰的表达式也可以：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;int&lt;/span&gt; N&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; data[N];&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; default_size = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; g_size = &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Array&amp;lt;&lt;span&gt;8&lt;/span&gt;&amp;gt; a1; &lt;span&gt;// 常量OK&lt;/span&gt;&lt;br/&gt;  Array&amp;lt;default_size&amp;gt; a2; &lt;span&gt;// 常量表达式OK&lt;/span&gt;&lt;br/&gt;  Array&amp;lt;g_size&amp;gt; a3; &lt;span&gt;// ERR，非常量不可以，只读变量不是常量&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于其他类型的表达式，也支持&lt;code&gt;constexpr&lt;/code&gt;，原则在于它必须要是编译期可以确定的类型，比如说 POD 类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; arr[] {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;array&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; arr2 {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;(*fp)&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;= f;&lt;br/&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *str = &lt;span&gt;&quot;abc123&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; g_val = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *pg = &amp;amp;g_val;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里可能有一些和直觉不太一样的地方，我来解释一下。首先，数组类型是编译期可确定的（你可以单纯理解为一组数，使用时按对应位置替换为值，并不会真的分配空间）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;std::array&lt;/code&gt;是 POD 类型，那么就跟普通的结构体、数组一样，所以都可以作为编译期常量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面几个指针需要重点解释一下。用&lt;code&gt;constexpr&lt;/code&gt;修饰的除了可以是绝对的常量外，在编译期能确定的量也可以视为常量。比如这里的&lt;code&gt;fp&lt;/code&gt;，由于函数&lt;code&gt;f&lt;/code&gt;的地址，在运行期间是不会改变的，编译期间尽管不能确定其绝对地址，但可以确定它的相对地址，那么作为函数指针&lt;code&gt;fp&lt;/code&gt;，它就是&lt;code&gt;f&lt;/code&gt;将要保存的地址，所以，这就是编译期可以确定的量，也可用&lt;code&gt;constexpr&lt;/code&gt;修饰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，&lt;code&gt;str&lt;/code&gt;指向的是一个字符串常量，字符串常量同样是有一个固定存放地址的，位置不会改变，所以用于指向这个数据的指针&lt;code&gt;str&lt;/code&gt;也可以用&lt;code&gt;constexpr&lt;/code&gt;修饰。要注意的是：&lt;code&gt;constexpr&lt;/code&gt;表达式有固定的书写位置，&lt;strong&gt;与&lt;code&gt;const&lt;/code&gt;的位置不一定相同&lt;/strong&gt;。比如说这里如果定义只读变量应该是&lt;code&gt;const char *const str&lt;/code&gt;，后面的&lt;code&gt;const&lt;/code&gt;修饰&lt;code&gt;str&lt;/code&gt;，前面的&lt;code&gt;const&lt;/code&gt;修饰&lt;code&gt;char&lt;/code&gt;。但换成常量表达式时，&lt;code&gt;constexpr&lt;/code&gt;要放在最前，因此不能写成&lt;code&gt;const char *constexpr str&lt;/code&gt;，而是要写成&lt;code&gt;constexpr const char *str&lt;/code&gt;。当然，少了这个&lt;code&gt;const&lt;/code&gt;也是不对的，因为不仅是指针不可变，指针所指数据也不可变。这个也是 C++中推荐的定义字符串常量别名的方式，优于宏定义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后的这个&lt;code&gt;pg&lt;/code&gt;也是一样的道理，因为全局变量的地址也是固定的，运行期间不会改变，因此&lt;code&gt;pg&lt;/code&gt;也可以用常量表达式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果运行期间可能发生改变的量（也就是编译期间不能确定的量）就不可以用常量表达式，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;  &lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *p = &amp;amp;a; &lt;span&gt;// ERR，局部变量地址编译期间不能确定&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; b;&lt;br/&gt;  &lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *p2 = &amp;amp;b; &lt;span&gt;// OK，静态变量地址可以确定&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; str = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;; &lt;span&gt;// ERR，非平凡POD类型不能编译期确定内部行为&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;constexpr 表达式也可能变成变量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望读者看到这一节标题的时候不要崩溃，C++就是这么难以捉摸。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，虽然&lt;code&gt;constexpr&lt;/code&gt;已经是常量表达式了，但是用&lt;code&gt;constexpr&lt;/code&gt;修饰变量的时候，它仍然是“定义变量”的语法，因此 C++希望它能够兼容只读变量的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当且仅当一种情况下，&lt;code&gt;constexpr&lt;/code&gt;定义的变量会真的成为变量，那就是这个变量被取址的时候：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *p = &amp;amp;a; &lt;span&gt;// 会让a退化为const int类型&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;道理也很简单，因为只有变量才能取址。上面例子中，由于对&lt;code&gt;a&lt;/code&gt;进行了取地址操作，因此，&lt;code&gt;a&lt;/code&gt;不得不真正成为一个变量，也就是变为&lt;code&gt;const int&lt;/code&gt;类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那另一个问题就出现了，如果说，我对一个常量表达式既取了地址，又用到编译期语法中了怎么办？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;int&lt;/span&gt; N&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;  Test&amp;lt;a&amp;gt; t; &lt;span&gt;// 用做常量&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *p = &amp;amp;a; &lt;span&gt;// 用做变量&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没关系，编译器会让它在编译期视为常量去给那些编译期语法（比如模板实例化）使用，之后，再把它用作变量写到内存中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，在编译期，这里的&lt;code&gt;a&lt;/code&gt;相当于一个宏，所有的编译期语法会用&lt;code&gt;5&lt;/code&gt;替换&lt;code&gt;a&lt;/code&gt;，&lt;code&gt;Test&amp;lt;a&amp;gt;&lt;/code&gt;就变成了&lt;code&gt;Test&amp;lt;5&amp;gt;&lt;/code&gt;。之后，又会让&lt;code&gt;a&lt;/code&gt;成为一个只读变量写到内存中，也就变成了&lt;code&gt;const int a = 5;&lt;/code&gt;那么&lt;code&gt;const int *p = &amp;amp;a;&lt;/code&gt;自然就是合法的了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;就地构造&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“就地构造”这个词本身就很 C++。很多程序员都能发现，到处纠结对象有没有拷贝，纠结出参还是返回值的只有 C++程序员。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无奈，C++确实没法完全摆脱底层考虑，C++程序员也会更倾向于高性能代码的编写。当出现嵌套结构的时候，就会考虑复制问题了。
举个最简单的例子，给一个&lt;code&gt;vector&lt;/code&gt;进行&lt;code&gt;push_back&lt;/code&gt;操作时，会发生一次复制：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a, b;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;Test&amp;gt; ve;&lt;br/&gt;  ve.push_back(Test{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;}); &lt;span&gt;// 用1,2构造临时对象，再移动构造&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因就在于，&lt;code&gt;push_back&lt;/code&gt;的原型是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;vector&lt;/span&gt;&amp;lt;T&amp;gt;::push_back(&lt;span&gt;const&lt;/span&gt; T &amp;amp;);&lt;br/&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;vector&lt;/span&gt;&amp;lt;T&amp;gt;::push_back(T &amp;amp;&amp;amp;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果传入左值，则会进行拷贝构造，传入右值会移动构造。但是对于&lt;code&gt;Test&lt;/code&gt;来说，无论深浅复制，都是相同的复制。这多构造一次&lt;code&gt;Test&lt;/code&gt;临时对象本身就是多余的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然，我们已经有&lt;code&gt;{1, 2}&lt;/code&gt;的构造参数了，能否想办法跳过这一次临时对象，而是直接在&lt;code&gt;vector&lt;/code&gt;末尾的空间上进行构造呢？这就涉及了就地构造的问题。我们在前面“new 和 delete”的章节介绍过，“分配空间”和“构造对象”的步骤可以拆解开来做。首先对&lt;code&gt;vector&lt;/code&gt;的&lt;code&gt;buffer&lt;/code&gt;进行扩容（如果需要的话），确定了要放置新对象的空间以后，直接使用&lt;code&gt;placement new&lt;/code&gt;进行就地构造。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如针对&lt;code&gt;Test&lt;/code&gt;的&lt;code&gt;vector&lt;/code&gt;我们可以这样写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;vector&lt;/span&gt;&amp;lt;Test&amp;gt;::emplace_back(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b) {&lt;br/&gt;  &lt;span&gt;// 需要时扩容&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// new_ptr表示末尾为新对象分配的空间&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt;(new_ptr) Test{a, b};&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;STL 中把容器的就地构造方法叫做&lt;code&gt;emplace&lt;/code&gt;，原理就是通过传递构造参数，直接在对应位置就地构造。所以更加通用的方法应该是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T, &lt;span&gt;typename&lt;/span&gt;... Args&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;vector&lt;/span&gt;&amp;lt;T&amp;gt;::emplace_back(Args &amp;amp;&amp;amp;...args) {&lt;br/&gt;  &lt;span&gt;// new_ptr表示末尾为新对象分配的空间&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt;(new_ptr) T{&lt;span&gt;std&lt;/span&gt;::forward&amp;lt;Args&amp;gt;(args)...};&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;嵌套就地构造&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就地构造确实能在一定程度上解决多余的对象复制问题，但如果是嵌套形式就实则没办法了，举例来说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a, b;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::tuple&amp;lt;&lt;span&gt;int&lt;/span&gt;, Test&amp;gt;&amp;gt; ve;&lt;br/&gt;  ve.emplace_back(&lt;span&gt;1&lt;/span&gt;, Test{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;}); &lt;span&gt;// tuple嵌套的Test没法就地构造&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，我们没法在就地构造对象时对参数再就地构造。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这件事情放在&lt;code&gt;map&lt;/code&gt;或者&lt;code&gt;unordered_map&lt;/code&gt;上更加有趣，因为这两个容器的成员都是&lt;code&gt;std::pair&lt;/code&gt;，所以对它进行&lt;code&gt;emplace&lt;/code&gt;的时候，就地构造的是&lt;code&gt;pair&lt;/code&gt;而不是内部的对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a, b;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;map&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, Test&amp;gt; ma;&lt;br/&gt;  ma.emplace(&lt;span&gt;1&lt;/span&gt;, Test{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;}); &lt;span&gt;// 这里emplace的对象是pair&amp;lt;int, Test&amp;gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过好在，&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;unordered_map&lt;/code&gt;提供了&lt;code&gt;try_emplace&lt;/code&gt;方法，可以在一定程度上解决这个问题，函数原型是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; K, &lt;span&gt;typename&lt;/span&gt; V, &lt;span&gt;typename&lt;/span&gt;... Args&amp;gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::pair&amp;lt;iterator, &lt;span&gt;bool&lt;/span&gt;&amp;gt; &lt;span&gt;map&lt;/span&gt;&amp;lt;K, V&amp;gt;::try_emplace(&lt;span&gt;const&lt;/span&gt; K &amp;amp;key, Args &amp;amp;&amp;amp;...args);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里把&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;拆开了，前者还是只能通过复制的方式传递，但后者可以就地构造。（实际使用时，&lt;code&gt;value&lt;/code&gt;更需要就地构造，一般来说&lt;code&gt;key&lt;/code&gt;都是整数、字符串这些。）那么我们可用它代替&lt;code&gt;emplace&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;map&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, Test&amp;gt; ma;&lt;br/&gt;  ma.try_emplace(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;); &lt;span&gt;// 1, 2用于构造Test&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但看这个函数名也能猜到，它是“不覆盖逻辑”。也就是如果容器中已有对应的&lt;code&gt;key&lt;/code&gt;，则不会覆盖。返回值中第一项表示对应项迭代器（如果是新增，就返回新增这一条的迭代器，如果是已有&lt;code&gt;key&lt;/code&gt;则放弃新增，并返回原项的迭代器），第二项表示是否成功新增（如果已有&lt;code&gt;key&lt;/code&gt;会返回&lt;code&gt;false&lt;/code&gt;）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;map&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, Test&amp;gt; ma {{1, Test{1, 2}}};&lt;br/&gt;  &lt;span&gt;auto&lt;/span&gt; [iter, is_insert] = ma.try_emplace(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;auto&lt;/span&gt; &amp;amp;current_test = iter-&amp;gt;second;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; current_test.a &amp;lt;&amp;lt; &lt;span&gt;&quot;, &quot;&lt;/span&gt; &amp;lt;&amp;lt; current_test.b &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;; &lt;span&gt;// 会打印1, 2&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过有一些场景利用&lt;code&gt;try_emplace&lt;/code&gt;会很方便，比如处理多重&lt;code&gt;key&lt;/code&gt;时使用&lt;code&gt;map&lt;/code&gt;嵌套&lt;code&gt;map&lt;/code&gt;的场景，如果用&lt;code&gt;emplace&lt;/code&gt;要写成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;map&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;map&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; ma;&lt;br/&gt;  &lt;span&gt;// 例如想给key为(1, 2)新增value为&quot;abc&quot;的&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 由于无法确定外层key为1是否已经有了，所以要单独判断&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (ma.count(&lt;span&gt;1&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    ma.emplace(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;map&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;gt;{});&lt;br/&gt;  }&lt;br/&gt;  ma.at(&lt;span&gt;1&lt;/span&gt;).emplace(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;abc&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是利用&lt;code&gt;try_emplace&lt;/code&gt;就可以更取巧一些：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;map&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;map&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; ma;&lt;br/&gt;  ma.try_emplace(&lt;span&gt;1&lt;/span&gt;).first-&amp;gt;second.try_emplace(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;abc&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解释一下，如果&lt;code&gt;ma&lt;/code&gt;含有&lt;code&gt;key&lt;/code&gt;为&lt;code&gt;1&lt;/code&gt;的项，就返回对应迭代器，如果没有的话则会新增（由于没指定后面的参数，所以会构造一个空&lt;code&gt;map&lt;/code&gt;），并返回迭代器。迭代器在返回值的第一项，所以取&lt;code&gt;first&lt;/code&gt;得到迭代器，迭代器指向的是&lt;code&gt;map&lt;/code&gt;内部的&lt;code&gt;pair&lt;/code&gt;，取&lt;code&gt;second&lt;/code&gt;得到内部的&lt;code&gt;map&lt;/code&gt;，再对其进行一次&lt;code&gt;try_emplace&lt;/code&gt;插入内部的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，这么做确实可读性会下降很多，具体使用时还需要自行取舍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;曾经有很多朋友问过我，C++适不适合入门？C++适不适合干活？我学 C++跟我学 java 哪个更赚钱啊？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者持有这样的观点：&lt;strong&gt;C++并不是最适合生产的语言，但 C++一定是最值得学习的语言&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说你单纯就是想干活，享受产出的快乐，那我不建议你学 C++，因为太容易劝退，找一些新语言，语法简单清晰容易上手，自然干活效率会高很多；但如果你希望更多地理解编程语言，全面了解一些自底层到上层的原理和进程，希望享受研究和开悟的快乐，那非 C++莫属了。掌握了 C++再去看其他语言，相信你一定会有不同的见解的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以到现在这个时间点，应该说，C++仍然还是我的信仰，我认为 C++将会在将来很长一段时间存在，并且以一个长老的身份发挥其在业界的作用和价值，但同时也会有越来越多新语言的诞生，他们在自己适合的地方发挥着不一样的光彩。我也不再会否认 C++的确有设计不合理的地方，不会否认其存在不擅长的领域，也不会再去鄙视那些吐槽 C++复杂的人。与此同时，我也不会拒绝涉足其他的领域，我认为，只有不断学习比较，不断总结沉淀，才能持续进步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你能读到这里的话，那非常感激你的支持，听我说谢谢你，因为有你……咳咳~。这篇文章作为我学习 C++多年的一个沉淀，也希望借此把我的想法分享给读者，如果你有任何疑问或者建议，欢迎评论区留言！针对更多 C++的特性的用法、编程技巧等内容，请期待我其他系列的文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp wxw_wechannel_card_not_horizontal&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAsRwGIP-UDQAAAAstQy6ubaLX4KHWvLEZgBPEraNEQVsOdtaCzNPgMIvUZkKhc5uBRCEEzm69hds_&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiaB1dSj2LnznPmy4NejfSsTtVL5LSsRLwdmojCSBt3gAvaW6xR8MsqE7A5qnsVzZvibMKicMYzo7zNapoPkXpb1zcw&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdWyYCtQrra3c5afyU5cian5Dibh5iaIsYoHNkojznRD2c9Q2om681libFyJjrRxHzuKhuw&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;不论是剪辑小白还是视频老手，&amp;#10;都不可错过的一款视频创作工具——智影。&amp;#10;性能强大且免费使用，&amp;#10;多人在线剪辑功能更是堪称视频界的“腾讯文档”。&amp;#10;&amp;#10;小调查：你最看重视频剪辑工具的什么功能呢？&amp;#10;&amp;#10;#视频剪辑 #剪辑教程 #智影&quot; data-nonceid=&quot;16512590610368279506&quot; data-type=&quot;video&quot; data-width=&quot;1080&quot; data-height=&quot;1920&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a4546a5691cb217f3fbdad2782bee2a6</guid>
<title>NetCore开发的分布式文件上传系统</title>
<link>https://toutiao.io/k/aakuiz2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;span&gt;日常如果是上传一些小文件，在程序实现中，我们都是直接上传，一般都没什么问题。如果&lt;span&gt;针对大文件上传的业务中，就会面临着：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、网速问题，导致文件上传超时，而导致失败。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、效率问题，上传大文件等待时间过长，如果是需要上传多个，就会更慢。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、体验问题，用户无法预知上传还需花费的时间，系统没有及时反馈，用户无法判断文件是否还在上传，还是断开。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这时候就需要采用分布式文件上传系统。&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;项目简介&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;这是一个基于.Net Core&lt;span pingfang=&quot;pingfang&quot; sc=&quot;sc&quot; hiragino=&quot;hiragino&quot; sans=&quot;sans&quot; gb=&quot;gb&quot; microsoft=&quot;microsoft&quot; yahei=&quot;yahei&quot; wenquanyi=&quot;wenquanyi&quot; micro=&quot;micro&quot; hei=&quot;hei&quot; helvetica=&quot;helvetica&quot; neue=&quot;neue&quot; arial=&quot;arial&quot; sans-serif=&quot;sans-serif&quot;&gt;构建的简单、跨平台分布式文件上传系统，支持分块上传、多个项目同时上传、接口权限控制采用JWT机制。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;1、跨平台：这是基于.Net Core开发的系统，可以部署在Docker, Windows, Linux, Mac。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、.Net 2.1 + Jwt + simple-uploader&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;项目结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.5767790262172285&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiar51JOsOLMhbXbSv5l1w9FgeKiaciaeXbORia6lTfD6JibCyXicke9pCQ6GcvDAMKtbiaict1d96yT8Qpib9Q/640?wx_fmt=png&quot; data-w=&quot;267&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;项目分为分块上传与一般上传Demo，Web、控制台上传Demo。ufs项目是分布式文件上传的统一接口，ufs会根据配置把上传的文件发到ufs.node节点，ufs.node会把上传成功路径返回给ufs并存储，用户访问的时候，ufs会访问对应节点返回资源。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;UploadServer为一般文件上传接口，UploadServer.FrontEndDemo为Web上传文件Demo。&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;1、配置&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;配置允许上传域名、服务接口地址、允许的文件格式、文件大小、存储路径等信息。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;AllowedHosts&quot;: &quot;*&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;urls&quot;: &quot;http://localhost:6001&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;uploadServer&quot;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;rootUrl&quot;: &quot;http://localhost:6001&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;entryPoint1&quot;: &quot;/upload&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;entryPoint2&quot;: &quot;/chunkUpload&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;virtualPath&quot;: &quot;&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;physicalPath&quot;: &quot;/Users/loogn/Desktop/uploader&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;appendMimes&quot;: &quot;.htm3:text/html;&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;responseCache&quot;: 604800,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;jwtSecret&quot;: &quot;1234561234&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;limitSize&quot;: &quot;20mb&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;allowExts&quot;: &quot;.txt;.jpg;.jpeg;.png;.doc;.docx;.xls;.xlsx;.ppt;.pptx;.pdf&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;apps&quot;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;default&quot;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;allowOrigins&quot;: &quot;&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;enableThumbnail&quot;: true,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;limitExts&quot;: &quot;.exe;&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;thumbnailExts&quot;: &quot;.jpg;.jpeg;.png;&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;app1&quot;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;allowOrigins&quot;: &quot;*&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、前端&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般上传代码&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$(&quot;#file1&quot;).change(function () {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        $.ajaxFileUpload({&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            fileElementId: &#x27;file1&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            url: &#x27;http://localhost:6001/upload&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            dataType: &#x27;text&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            //&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            success: function (data) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                console.log(&quot;上传成功：&quot;, data);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            data: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &quot;jwt&quot;: jwt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;分块上传&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var uploader = new Uploader({&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        target: &#x27;http://localhost:6001/chunkupload&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        headers: {jwt: jwt}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uploader.assignBrowse(document.getElementById(&#x27;browseButton&#x27;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //uploader.assignBrowse(document.getElementById(&#x27;folderButton&#x27;), true);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 文件添加 单个文件&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uploader.on(&#x27;fileAdded&#x27;, function (file, event) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        console.log(&quot;fileAdded:&quot;, file, event)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 单个文件上传成功&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uploader.on(&#x27;fileSuccess&#x27;, function (rootFile, file, message) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        console.log(&quot;fileSuccess：&quot;, rootFile, file, message)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 根下的单个文件（文件夹）上传完成&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uploader.on(&#x27;fileComplete&#x27;, function (rootFile) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        console.log(&quot;fileComplete:&quot;, rootFile)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 某个文件上传失败了&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uploader.on(&#x27;fileError&#x27;, function (rootFile, file, message) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        console.log(&quot;fileError:&quot;, rootFile, file, message)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、后端&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般上传&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; public async Task InvokeAsync(HttpContext context, RequestDelegate next)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            context.Response.Headers.Add(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            context.Response.Headers.Add(&quot;Access-Control-Allow-Headers&quot;, &quot;content-type,jwt,origin&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (context.Request.Method.Equals(HttpMethods.Options, StringComparison.OrdinalIgnoreCase))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                context.Response.StatusCode = (int) HttpStatusCode.OK;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            else if (context.Request.Method.Equals(HttpMethods.Post, StringComparison.OrdinalIgnoreCase))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                //验证jwt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                string token = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (context.Request.Headers.TryGetValue(&quot;jwt&quot;, out StringValues jwt))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    token = jwt.ToString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                else if (context.Request.Form.TryGetValue(&quot;jwt&quot;, out jwt))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    token = jwt.ToString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg = &quot;No JWT in the header and form&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                try&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var payload = new JwtBuilder().WithSecret(_config.JWTSecret).MustVerifySignature()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        .Decode&amp;lt;JwtPayload&amp;gt;(token);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var msg = payload.validate();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (msg != null)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            msg = msg&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    //特定的配置&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var appConfig = _config.GetAppConfig(payload.app);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    //跨域&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    context.Request.Headers.TryGetValue(&quot;Origin&quot;, out var origins);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var origin = origins.ToString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (!string.IsNullOrEmpty(origin) &amp;amp;&amp;amp; appConfig.IsAllowOrigin(origin))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        context.Response.Headers.Add(&quot;Access-Control-Allow-Origin&quot;, origin);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    //获取上传的文件&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var file = context.Request.Form.Files.FirstOrDefault();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (file == null || file.Length == 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            msg = &quot;There is no file data&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    //大小验证&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (file.Length &amp;gt; (payload.GetByteSize() ?? _config.GetByteSize()))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            msg = &quot;The file is too big&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    //后缀验证&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var ext = Path.GetExtension(file.FileName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (!(payload.exts + _config.AllowExts).Contains(ext, StringComparison.OrdinalIgnoreCase)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        || appConfig.LimitExts.Contains(ext, StringComparison.OrdinalIgnoreCase))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            msg = &quot;File extension is not allowed&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    //上传逻辑&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var now = DateTime.Now;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var yy = now.ToString(&quot;yyyy&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var mm = now.ToString(&quot;MM&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var dd = now.ToString(&quot;dd&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var fileName = Guid.NewGuid().ToString(&quot;n&quot;) + ext;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var folder = Path.Combine(_config.PhysicalPath, payload.app, yy, mm, dd);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (!Directory.Exists(folder))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        Directory.CreateDirectory(folder);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var filePath = Path.Combine(folder, fileName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    using (var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        file.CopyTo(fileStream);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        fileStream.Flush(true);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var fileUrl = _config.RootUrl + &quot;/&quot; + payload.app + &quot;/&quot; + yy + &quot;/&quot; + mm +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                  &quot;/&quot; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                  dd +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                  &quot;/&quot; + fileName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        ok = true,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        url = fileUrl&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                catch (TokenExpiredException)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg = &quot;Token has expired&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                catch (SignatureVerificationException)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg = &quot;Token has invalid signature&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    msg = $&quot;Request method &#x27;{context.Request.Method}&#x27; is not supported&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分块上传&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public async Task InvokeAsync(HttpContext context, RequestDelegate next)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            context.Response.Headers.Add(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            context.Response.Headers.Add(&quot;Access-Control-Allow-Headers&quot;, &quot;content-type,jwt,origin&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (context.Request.Method.Equals(HttpMethods.Options, StringComparison.OrdinalIgnoreCase))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                context.Response.StatusCode = (int)HttpStatusCode.OK;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            else if (context.Request.Method.Equals(HttpMethods.Get, StringComparison.OrdinalIgnoreCase))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                //简单实现&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                context.Request.Query.TryGetValue(&quot;chunkNumber&quot;, out var chunkNumbers);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                int.TryParse(chunkNumbers.ToString(), out var chunkNumber);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                context.Request.Query.TryGetValue(&quot;identifier&quot;, out var identifiers);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (chunkNumber == 0 || string.IsNullOrEmpty(identifiers))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    context.Response.StatusCode = 204;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var chunkFilename = getChunkFilename(_config.PhysicalPath, chunkNumber, identifiers);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (File.Exists(chunkFilename))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        await context.Response.WriteAsync(&quot;found&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        context.Response.StatusCode = 204;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            else if (context.Request.Method.Equals(HttpMethods.Post, StringComparison.OrdinalIgnoreCase))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                //验证jwt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                string token = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (context.Request.Headers.TryGetValue(&quot;jwt&quot;, out StringValues jwt))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    token = jwt.ToString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                else if (context.Request.Form.TryGetValue(&quot;jwt&quot;, out jwt))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    token = jwt.ToString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg = &quot;No JWT in the header and form&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                try&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var payload = new JwtBuilder().WithSecret(_config.JWTSecret).MustVerifySignature()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        .Decode&amp;lt;JwtPayload&amp;gt;(token);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var msg = payload.validate();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (msg != null)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            msg = msg&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    //特定的配置&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var appConfig = _config.GetAppConfig(payload.app);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    //跨域&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    context.Request.Headers.TryGetValue(&quot;Origin&quot;, out var origins);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var origin = origins.ToString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (!string.IsNullOrEmpty(origin) &amp;amp;&amp;amp; appConfig.IsAllowOrigin(origin))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        context.Response.Headers.Add(&quot;Access-Control-Allow-Origin&quot;, origin);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    //获取上传的文件分片&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var file = context.Request.Form.Files.FirstOrDefault();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (file == null || file.Length == 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            msg = &quot;There is no file data&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    //后缀验证&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var ext = Path.GetExtension(file.FileName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (!(payload.exts + _config.AllowExts).Contains(ext, StringComparison.OrdinalIgnoreCase)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        || appConfig.LimitExts.Contains(ext, StringComparison.OrdinalIgnoreCase))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            msg = &quot;File extension is not allowed&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    //获取参数                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    getParams(context, out var chunkNumber, out var chunkSize, out var totalSize, out string identifier,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        out string filename, out int totalChunks);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    //验证参数&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    var validMsg = validateRequest(chunkNumber, chunkSize, totalSize, identifier, filename, file.Length, totalChunks, payload.GetByteSize() ?? _config.GetByteSize());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (validMsg != null)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            msg = validMsg&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        var chunkFilename = getChunkFilename(_config.PhysicalPath, chunkNumber, identifier);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        try&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            using (var fileStream = File.OpenWrite(chunkFilename))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                var stream = file.OpenReadStream();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                stream.CopyTo(fileStream);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                fileStream.Flush(true);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                countDict.AddOrUpdate(identifier, 1, (key, oldValue) =&amp;gt; oldValue + 1);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            if (chunkNumber == totalChunks)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                //验证块的完整性&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                while (true)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    if (countDict.GetValueOrDefault(identifier) &amp;lt; totalChunks)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                        await Task.Delay(TimeSpan.FromMilliseconds(500));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                        countDict.Remove(identifier, out _);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                        break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                //merge file;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                string[] chunkFiles = Directory.GetFiles(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    Path.Combine(_config.PhysicalPath, temporaryFolder),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    &quot;uploader-&quot; + identifier + &quot;.*&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    SearchOption.TopDirectoryOnly);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                var fileUrl = await MergeChunkFiles(payload, ext, chunkFiles);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    ok = true,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    url = fileUrl&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                await context.Response.WriteAsync(&quot;partly_done&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        catch (Exception exp)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                msg = exp.Message&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                catch (TokenExpiredException)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg = &quot;Token has expired&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                catch (SignatureVerificationException)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    await context.Response.WriteAsync(new UploadResult()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg = &quot;Token has invalid signature&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }.toJson());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                context.Response.StatusCode = (int)HttpStatusCode.MethodNotAllowed;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                await context.Response.WriteAsync($&quot;Request method &#x27;{context.Request.Method}&#x27; is not supported&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;4、上传结果&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;上传成功&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&quot;ok&quot;:true,&quot;msg&quot;:null,&quot;url&quot;:&quot;http://localhost:6001/test/2019/06/17/abcd.jpg&quot;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上传失败&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&quot;ok&quot;:false,&quot;msg&quot;:&quot;The file is too big&quot;,&quot;url&quot;:null}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4320855614973262&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiar51JOsOLMhbXbSv5l1w9FgZxPLiakibPMpjN8fuveAG4xf6fHFQIQ3E33xrIRLoq9skNZicgpoia711w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;935&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;43&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;Gitee：https://gitee.com/loogn/UploadServer&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;- End -&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;专注分享编程知识、热门有用有趣的开源项目&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5MDE5MDM5NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaoiaJkdNNMfIKwQBC4fGYyxicqesxYXOCOOnGtiaibfu39oV4XbCUt6JewstuFjGQtjvzhX7hiaweZeYFA/0?wx_fmt=png&quot; data-nickname=&quot;编程乐趣&quot; data-alias=&quot;zhaobiaonews&quot; data-signature=&quot;分享编程知识、有趣热门的开源项目。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;觉得好看 点个&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;在看👇&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>