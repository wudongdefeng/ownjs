<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8a8896830c54b4bc69267c7fbe0cb288</guid>
<title>6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理</title>
<link>https://toutiao.io/k/f6e4akr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇给大家带来的是微服务框架中非常重要的一个组件：API 网关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文已收录至&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAwMjI0ODk0NA==&amp;amp;action=getalbum&amp;amp;album_id=2083392961806925826#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《深入剖析 Spring Cloud 底层架构原理》&lt;/a&gt;，已更新 16 讲。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6450549450549451&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEwQibSZVERpJAjGve11zyhoQ5sgV16pmhJMc3H5ibWHiaTVT1qSaQTmBkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1820&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 PassJava 项目中，我用到了 Spring Cloud Gateway 作为 API 网关，客户端的所有的请求都是先经过网关，然后再转发到会员微服务、题目微服务等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 API 网关和会员微服务对应的访问地址如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;API 网关地址：http://localhost:8060&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会员微服务地址：http://localhost:14000&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端请求都是访问的 API 网关，然后网关转发到会员微服务，客户端无需知道会员微服务的地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇将会以 PassJava 作为案例进行讲解。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PassJava 开源地址：https://github.com/Jackson0714/PassJava-Platform&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么需要 API 网关&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 SpringBoot 单体架构中，一般只有一个后端服务，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6771653543307087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFE4Tb61OSkuVWzRXEzVavqxl3psibMoRnwicmIacZ68I9uNSTfIr3iacZ0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;figcaption&gt;单体架构访问示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在 SpringCloud 微服务架构中，往往有多个微服务，这些微服务可能部署在不同的机器上，而且一个微服务可能会扩容成多个相同的微服务，组成微服务集群。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8391472868217055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFE8HON8fPcfoPjzLQQomPqqwMgh8S8PTpJlyBkViarHUmiaH7YJ5GkibSXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1032&quot;/&gt;&lt;figcaption&gt;微服务架构访问示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况下，会存在如下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果需要添加鉴权功能，则需要对每个微服务进行改造。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果需要对流量进行控制，则需要对每个微服务进行改造。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;跨域问题，需要对每个微服务进行改造。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存在安全问题，每个微服务需要暴露自己的 Endpoint 给客户端。Endpoint 就是服务的访问地址 + 端口。比如下面的地址：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;http://order.passjava.cn:8000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;灰度发布、动态路由需要对每个微服务进行改造。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题的痛点是各个微服务都是一个入口，有没有办法统一入口呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决这个问题的方式就是在客户端和服务器之间加个中间商就好了呀，只有中间商一个入口，这个中间商就是网关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;还有一个细节问题&lt;/strong&gt;：多个微服务之间是如何通信的？这就要用到远程调用组件了，比如 OpenFeign。但是服务之间的调用是需要知道对方的 Endpoint 的，如果一个服务有多个微服务，就需要通过负载均衡组件进行流量分发。那微服务之间不就暴露 Endpoint 了吗？这个没有问题，毕竟只是后端服务知道，外界是不知道的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9978260869565218&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFE31faEsZ3Ool3l6tjI2fXTo2fM308qOvHyLDghNXew5ibn3zFvpjVdxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了帮助大家更容易理解网关的作用，这里有个网关、客户端、微服务的三方通话。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关对话&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网关&lt;/strong&gt;：客户端你好，你现在可以只跟我通信了，我可以将你本来想发给微服务的流量进行转发，微服务处理完之后，将结果返回给我，我再给你。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端&lt;/strong&gt;：你没有赚差价吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API 网关&lt;/strong&gt;：我可能会加些请求头、做下认证、鉴权、限流等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端&lt;/strong&gt;：微服务不是自己可以做吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API 网关&lt;/strong&gt;：但是每个微服务都得自己加，这就很麻烦了，都交给我就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;微服务&lt;/strong&gt;：网关你好，你会为我保密我的地址对吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API 网关&lt;/strong&gt;：当然，我给客户端看的是我自己的地址，客户端不需要知道你的地址，只需要知道你的 API 是哪个就行，剩下的交给我来转发给你。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;API 网关选型对比&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界比较出名的网关：Spring Cloud Gateway、Netflix Zuul、Nginx、Kong、Alibaba Tengine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为 Spring Cloud 全家桶中的一款组件，当然选择 Spring Cloud Gateway 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最开始 Spring Cloud 推荐的网关是 Netflix Zuul 1.x，但是停止维护了，后来又有 Zuul 2.0，但是因为开发延期比较严重，Spring Cloud 官方自己开发了 Spring Cloud Gateway 网关组件，用于代替 Zuul 网关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以本篇我们只会讲解 Spring Cloud Gateway 网关组件。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Cloud Gateway 的工作流程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Gateway 的工作流程如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.6977777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEPsQuxIDpVy9JvicAQU0QrAia23nVlS1P4GHyDfjAMAtcLILibpicj9vvPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;① &lt;strong&gt;路由判断&lt;/strong&gt;；客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;② &lt;strong&gt;请求过滤&lt;/strong&gt;：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在...之前”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;③ &lt;strong&gt;服务处理&lt;/strong&gt;：后端服务会对请求进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;④ &lt;strong&gt;响应过滤&lt;/strong&gt;：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在...之后”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⑤ &lt;strong&gt;响应返回&lt;/strong&gt;：响应经过过滤处理后，返回给客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小结：客户端的请求先通过匹配规则找到合适的路由，就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次经过过滤器处理，最后返回给客户端。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Cloud Gateway 的断言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言（Predicate）这个词听起来极其深奥，它是一种编程术语，我们生活中根本就不会用它。说白了它就是对一个表达式进行 if 判断，结果为真或假，如果为真则做这件事，否则做那件事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Gateway 中，如果客户端发送的请求满足了断言的条件，则映射到指定的路由器，就能转发到指定的服务上进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言配置的示例如下，配置了两个路由规则，有一个 predicates 断言配置，当请求 url 中包含 api/thirdparty，就匹配到了第一个路由 route_thirdparty。（代码示例来自我的开源项目 PassJava）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5961070559610706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEic5vckEJFXibibcEWpdJatZjFeNT1z7hEhibNv9PSIfbJiaTI32rdGV730Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1644&quot;/&gt;&lt;figcaption&gt;断言配置&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们看下 Route 路由和 Predicate 断言的对应关系：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1076923076923078&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFE5ibAUpeUvSzmt3b1EspgaaVMXUjzoQVGiaeLzKVLiaibjDSW2ibnhDibgSFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1690&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;断言和路由的对应关系原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;一对多&lt;/strong&gt;：一个路由规则可以包含多个断言。如上图中路由 Route1 配置了三个断言 Predicate。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;同时满足&lt;/strong&gt;：如果一个路由规则中有多个断言，则需要同时满足才能匹配。如上图中路由 Route2 配置了两个断言，客户端发送的请求必须同时满足这两个断言，才能匹配路由 Route2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;第一个匹配成功&lt;/strong&gt;：如果一个请求可以匹配多个路由，则映射第一个匹配成功的路由。如上图所示，客户端发送的请求满足 Route3 和 Route4 的断言，但是 Route3 的配置在配置文件中靠前，所以只会匹配 Route3。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的 Predicate 断言配置如下所示，假设匹配路由成功后，转发到 http://localhost:9001&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44811858608893956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEibXBYVziaGNjrm6RXLqQh6UyJRQ2gJJJpor8bbfEpB0ZVMWPd5GA4aTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1754&quot;/&gt;&lt;figcaption&gt;常见的 Predicate 断言配置&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面演示 Gateway 中通过断言来匹配路由的例子。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新建一个 Maven 工程，引入 Gateway 依赖。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-gateway&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新建 application.yml 文件，添加 Gateway 的路由规则。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cloud:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;gateway:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;routes:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;route_qq&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;uri:&lt;/span&gt; &lt;span&gt;http://www.qq.com&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;predicates:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;Query=url,qq&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;route_baidu&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;uri:&lt;/span&gt; &lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;predicates:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;Query=url,baidu&lt;/span&gt;&lt;br/&gt;&lt;span&gt;server:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8060&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一条路由规则：断言为 Query=url,qq，表示当请求路径中包含 url=qq，则跳转到http://www.qq.com&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二条路由规则：当请求路径中包含 url=baidu，则跳转到http://www.baidu.com&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Cloud Gateway 动态路由&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务架构中，我们不会直接通过 IP + 端口的方式访问微服务，而是通过服务名的方式来访问。如下图所示，微服务中加入了注册中心，多个微服务将自己注册到了注册中心，这样注册中心就保存了服务名和 IP+端口的映射关系。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.549492385786802&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEalWia3m8AooW7me9qibFibyzBeHKAianFTSSvoxBIribibYVq3QDwvlHK4Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;figcaption&gt;微服务注册到注册中心&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来看下加入 Gateway 后，请求是如何进行转发的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端先将请求发送给 Nginx，然后转发到网关，网关经过断言匹配到一个路由后，将请求转发给指定 uri，这个 uri 可以配置成 微服务的名字，比如 passjava-member。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个服务名具体要转发到哪个 IP 地址和端口上呢？这个就依赖注册中心的注册表了，Gateway 从注册中心拉取注册表，就能知道服务名对应具体的 IP + 端口，如果一个服务部署了多台机器，则还可以通过负载均衡进行请求的转发。原理如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3469985358711567&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEKxBHgZySMxA6oggOXc7dbzJSIibo6kEJuYMWbb2pf9yrRDm7HIrV8Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1366&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;网关+注册中心&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的配置为 uri 字段如下所示&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3412887828162291&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFECMPnoViaj4kgicfvLHNHbjj8SsXkXoJBBl6CJiaU5GbuEiad5L8ODbbIQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1676&quot;/&gt;&lt;strong&gt;uri: lb://passjava-question&lt;/strong&gt;，表示将请求转发给 passjava-question 微服务，且支持负载均衡。lb 是 loadbalance（负载均衡) 单词的缩写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那什么叫动态路由呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 passjava-question 服务添加一个微服务，或者 IP 地址更换了，Gateway 都是可以感知到的，但是配置是不需要更新的。这里的动态指的是微服务的集群个数、IP 和端口是动态可变的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码示例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例：调用 OSS 第三方服务，上传文件到 OSS。（基于 PassJava 项目）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前提：前端页面配置的统一访问路径是网关的地址：http://localhost:8060/api/，OSS 服务对应的地址是http://localhost:14000。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;期望结果：将前端请求&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http:&lt;span&gt;//localhost:8060/api/thirdparty/v1/admin/oss/getPolicy&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;转发到 OSS 服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http:&lt;span&gt;//localhost:14000/thirdparty/v1/admin/oss/getPolicy&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置网关：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cloud:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;gateway:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;routes:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;route_thirdparty&lt;/span&gt; &lt;span&gt;# 第三方微服务路由规则&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;uri:&lt;/span&gt; &lt;span&gt;lb://passjava-thirdparty&lt;/span&gt; &lt;span&gt;# 负载均衡，将请求转发到注册中心注册的 passjava-thirdparty 服务&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;predicates:&lt;/span&gt; &lt;span&gt;# 断言&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;Path=/api/thirdparty/**&lt;/span&gt; &lt;span&gt;# 如果前端请求路径包含 api/thirdparty，则应用这条路由规则&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;filters:&lt;/span&gt; &lt;span&gt;#过滤器&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;RewritePath=/api/(?&amp;lt;segment&amp;gt;.*),/$\{segment}&lt;/span&gt; &lt;span&gt;# 将跳转路径中包含的api替换成空&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试上传文件成功。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48898216159496327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEDEBAA6iaefeuvWF7T45hMkLMleB9icMcGL5x1InOy2goEaXia5agglDew/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;953&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们看下 Gateway 非常重要且核心的功能：过滤器。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Cloud Gateway 的过滤器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关，顾名思义，就是网络中的一道关卡，可以统一对请求和响应进行一些操作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;过滤器 Filter 的分类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过滤器 Filter 按照请求和响应可以分为两种：&lt;code&gt;Pre&lt;/code&gt; 类型和 &lt;code&gt;Post&lt;/code&gt; 类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Pre 类型&lt;/strong&gt;：在请求被转发到微服务之前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Post 类型&lt;/strong&gt;：微服务处理完请求后，返回响应给网关，网关可以再次进行处理，例如修改响应内容或响应头、日志输出、流量监控等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一种分类是按照过滤器 Filter 作用的范围进行划分：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GlobalFilter&lt;/strong&gt;：全局过滤器，应用在所有路由上的过滤器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;局部过滤器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GatewayFilter&lt;/strong&gt;：局部过滤器，应用在单个路由或一组路由上的过滤器。标红色表示比较常用的过滤器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整理了一份 27 种自带的 GatwayFilter 过滤器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5580389329488104&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEiaIqIPUzn4dnib0eNsGwVk7icczYjtDicuspL5m95tS0N7Dleo6MKfgyrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2774&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体怎么用呢，这里有个示例，如果 URL 匹配成功，则去掉 URL 中的 “api”。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;filters:&lt;/span&gt; &lt;span&gt;#过滤器&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;-&lt;/span&gt; &lt;span&gt;RewritePath=/api/(?&amp;lt;segment&amp;gt;.*),/$\{segment}&lt;/span&gt; &lt;span&gt;# 将跳转路径中包含的 “api” 替换成空&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然我们也可以自定义过滤器，本篇不做展开。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;全局过滤器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整理了一份全局过滤器的表格，具体用法可以参照官方文档。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;官方文档：https://cloud.spring.io/spring-cloud-static/Greenwich.SR2/single/spring-cloud.html&lt;span&gt;#_global_filters&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5067178502879078&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFELTuzAEYOFib71ytc2He3RIcwfHSTFEbY2bV4IULIqvmKoYv59nAfzOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1042&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局过滤器最常见的用法是进行负载均衡。配置如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;spring:&lt;br/&gt;  cloud:&lt;br/&gt;    gateway:&lt;br/&gt;      routes:&lt;br/&gt;        - id: route_member # 第三方微服务路由规则&lt;br/&gt;          &lt;span&gt;uri&lt;/span&gt;: lb:&lt;span&gt;//passjava-member # 负载均衡，将请求转发到注册中心注册的 passjava-member 服务&lt;/span&gt;&lt;br/&gt;          predicates: # 断言&lt;br/&gt;            - Path=&lt;span&gt;/api/m&lt;/span&gt;ember&lt;span&gt;/** # 如果前端请求路径包含 api/member，则应用这条路由规则&lt;br/&gt;          filters: #过滤器&lt;br/&gt;            - RewritePath=/api/(?&amp;lt;segment&amp;gt;.*),/$\{segment} # 将跳转路径中包含的api替换成空&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个关键字 &lt;code&gt;lb&lt;/code&gt;，用到了全局过滤器 &lt;code&gt;LoadBalancerClientFilter&lt;/code&gt;，当匹配到这个路由后，会将请求转发到 passjava-member 服务，且支持负载均衡转发，也就是先将 passjava-member 解析成实际的微服务的 host 和 port，然后再转发给实际的微服务。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现简单的 token 认证&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用 Gateway 做登录认证的时候，通常需要我们自定义一个过滤器做登录认证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如客户端登录时，将用户名和密码发送给网关，网关转发给认证服务器后，如果账号密码正确，则拿到一个 JWT token，然后客户端再访问应用服务时，先将请求发送给网关，网关统一做 JWT 认证，如果 JWT 符合条件，再将请求转发给应用服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理如下图所示，红色框框的部分就是待会我要演示的部分。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2046296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEIricWzXQWoQ9P2WIcgsKicf6jjbTsZz0UPOtsEl7bZWF2gQW28iaasFvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;案例演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面做一个简单的认证实例。客户端携带 token 访问 member 服务，网关会先校验 token 的合法性，验证规则如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当请求的 header 中包含 token，且 token = admin，则认证通过。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当验证通过后，就会将请求转发给 member 服务。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码示例&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先定义一个全局过滤器，验证 token 的合法性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalLoginFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;GlobalFilter&lt;/span&gt;, &lt;span&gt;Ordered&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;Void&amp;gt; &lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(ServerWebExchange exchange, GatewayFilterChain chain)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ServerHttpRequest request= exchange.getRequest();&lt;br/&gt;        String token = request.getHeaders().getFirst(&lt;span&gt;&quot;token&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(!StringUtils.isEmpty(token)){&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;&quot;admin&quot;&lt;/span&gt;.equals(token)){&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; chain.filter(exchange);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; exchange.getResponse().setComplete();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getOrder&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先测试在 header 中添加 token=123，响应结果为 401  Unauthorized，没有权限。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEWXJD5G4Rd9PnpHMYicCvPnaeSvqNYEHEXZyA3RWMHuzmtBTiabEFpPhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.44537037037037036&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后测试在 header 中添加 token=admin，正常返回响应数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7326607818411097&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFESRoDJ5wdGKt4Tmgic4LoJApibVAuoEvgib9y2ic2kScHibWu979fL4WUOqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1586&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下一篇：如何用 Gateway 做登录鉴权：SpringCloud Gateway + JWT Token&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20d96adf1cb7b3d3062a87d1dfaf47a1</guid>
<title>工作流引擎架构设计</title>
<link>https://toutiao.io/k/9c3wejl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近开发的安全管理平台新增了很多工单申请流程需求，比如加白申请，开通申请等等。最开始的两个需求，为了方便，也没多想，就直接开发了对应的业务代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但随着同类需求不断增多，感觉再这样写可要累死人，于是开始了工作流引擎的开发之路。查找了一些资料之后，开发了现阶段的工作流引擎，文章后面会有介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然现在基本上能满足日常的需求，但感觉还不够智能，还有很多的优化空间，所以正好借此机会，详细了解了一些完善的工作流引擎框架，以及在架构设计上需要注意的点，形成了这篇文章，分享给大家。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是工作流&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看一下维基百科对于工作流的定义：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;工作流（Workflow），是对工作流程及其各操作步骤之间业务规则的抽象、概括描述。工作流建模，即将工作流程中的工作如何前后组织在一起的逻辑和规则，在计算机中以恰当的模型表达并对其实施计算。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流要解决的主要问题是：为实现某个业务目标，利用计算机在多个参与者之间按某种预定规则自动传递文档、信息或者任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，工作流就是对业务的流程化抽象。WFMC（工作流程管理联盟） 给出了工作流参考模型如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5433070866141733&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;635&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEokSpu8KwKQPJwWBPwhuTyZFVT34SWGu2RQolwXpwZV4G2DeIeROUNg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个例子，比如公司办公的 OA 系统，就存在大量的申请审批流程。而在处理这些流程时，如果每一个流程都对应一套代码，显然是不现实的，这样会造成很大程度上的代码冗余，而且开发工作量也会骤增。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候就需要一个业务无关的，高度抽象和封装的引擎来统一处理。通过这个引擎，可以灵活配置工作流程，并且可以自动化的根据配置进行状态变更和流程流转，这就是工作流引擎。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简单的工作流&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，一个工作流引擎需要支持哪些功能呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题并没有一个标准答案，需要根据实际的业务场景和需求来分析。在这里，我通过一个工单流程的演进，从简单到复杂，循序渐进地介绍一下都需要包含哪些基础功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;最简单流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.09712722298221614&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;731&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoECpiaicvSibehzpdJ1seOwBcN8kPt6ZTib8C3U4RN5dETL9j5iaIFXBbRY9g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最简单的一个流程工单，申请人发起流程，每个节点审批人逐个审批，最终流程结束。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;会签&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45010183299389&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEmUXyTRmY77t4Iibian48pFibkcAwJhDoEg2mVUziay5916wuUt4kt1LRPQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个过程中，节点分成了两大类：简单节点和复杂节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单节点处理逻辑不变，依然是处理完之后自动到下一个节点。复杂节点比如说会签节点，则不同，需要其下的所有子节点都处理完成，才能到下一个节点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;并行&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45010183299389&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEFtuMh4mZTEkvodA5aicfGr5B8ibOkibUuc4ZmoVnDiaqvfIhiaMqubVysbA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样属于复杂节点，其任何一个子节点处理完成后，都可以进入到下一个节点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;条件判断&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45010183299389&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEsMU8VtVneq8EHgOaSHSCUmMpzRC3PzbGuvkf0mtDjBPiabHZaVZbB6A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要根据不同的表单内容进入不同的分支流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个例子，比如在进行休假申请时，请假一天需要直属领导审批，如果大于三天则需要部门领导审批。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;动态审批人&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23392612859097128&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;731&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEeVVM21bkiaOBnFMwqcJibDB4afAicThzeoiaUyQ8pyzOtekmknVInaC6kw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审批节点的审批人需要动态获取，并且可配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审批人的获取方式可以分以下几种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;固定审批人&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从申请表单中获取&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据组织架构，动态获取&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从配置的角色组或者权限组中获取&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;撤销和驳回&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2913816689466484&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;731&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoE2nic6tSSxvCKh5absaFWhz5MfL0pibOsoMoaGias0T0FTn3AVDZ3IusRA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节点状态变更可以有申请人撤回，审批人同意，审批人驳回。那么在驳回时，可以直接驳回到开始节点，流程结束，也可以到上一个节点。更复杂一些，甚至可以到前面流程的任意一个节点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自动化节点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22024623803009577&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;731&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEtYG6zS97Ab7k4R50BxdAibNfgoTibZ8qSLfdMXkBREBSiawtibGRuO00LA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一些节点是不需要人工参与的，比如说联动其他系统自动处理，或者审批节点有时间限制，超时自动失效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;个性化通知&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节点审批之后，可以配置不同的通知方式来通知相关人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是我列举的一些比较常见的需求点，还有像加签，代理，脚本执行等功能，如果都实现的话，应该会是一个庞大的工作量。当然了，如果目标是做一个商业化产品的话，功能还是需要更丰富一些的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但把这些常见需求点都实现的话，应该基本可以满足大部分的需求了，至少对于我们系统的工单流程来说，目前是可以满足的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;工作流引擎对比&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然这是一个常见的需求，那么需要我们自己来开发吗？市面上有开源项目可以使用吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是肯定的，目前，市场上比较有名的开源流程引擎有 Osworkflow、Jbpm、Activiti、Flowable、Camunda 等等。其中：Jbpm、Activiti、Flowable、Camunda 四个框架同宗同源，祖先都是 Jbpm4，开发者只要用过其中一个框架，基本上就会用其它三个了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Osworkflow&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Osworkflow 是一个轻量化的流程引擎，基于状态机机制，数据库表很少。Osworkflow 提供的工作流构成元素有：步骤（step）、条件（conditions）、循环（loops）、分支（spilts）、合并（joins）等，但不支持会签、跳转、退回、加签等这些操作，需要自己扩展开发，有一定难度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果流程比较简单，Osworkflow 是一个很不错的选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;JBPM&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JBPM 由 JBoss 公司开发，目前最高版本是 JPBM7，不过从 JBPM5 开始已经跟之前不是同一个产品了，JBPM5 的代码基础不是 JBPM4，而是从 Drools Flow 重新开始的。基于 Drools Flow 技术在国内市场上用的很少，所有不建议选择 JBPM5 以后版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JBPM4 诞生的比较早，后来 JBPM4 创建者 Tom Baeyens 离开 JBoss，加入 Alfresco 后很快推出了新的基于 JBPM4 的开源工作流系统 Activiti，另外 JBPM 以 hibernate 作为数据持久化 ORM 也已不是主流技术。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Activiti&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Activiti 由 Alfresco 软件开发，目前最高版本 Activiti7。Activiti 的版本比较复杂，有 Activiti5、Activiti6、Activiti7 几个主流版本，选型时让人晕头转向，有必要先了解一下 Activiti 这几个版本的发展历史。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Activiti5 和 Activiti6 的核心 leader 是 Tijs Rademakers，由于团队内部分歧，在 2017 年 Tijs Rademakers 离开团队，创建了后来的 Flowable。Activiti6 以及 Activiti5 代码已经交接给了 Salaboy 团队，Activiti6 以及 Activiti5 的代码官方已经暂停维护了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Salaboy 团队目前在开发 Activiti7 框架，Activiti7 内核使用的还是 Activiti6，并没有为引擎注入更多的新特性，只是在 Activiti 之外的上层封装了一些应用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Flowable&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flowable 是一个使用 Java 编写的轻量级业务流程引擎，使用 Apache V2 license 协议开源。2016 年 10 月，Activiti 工作流引擎的主要开发者离开 Alfresco 公司并在 Activiti 分支基础上开启了 Flowable 开源项目。基于 Activiti v6 beta4 发布的第一个 Flowable release 版本为 6.0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flowable 项目中包括 BPMN（Business Process Model and Notation）引擎、CMMN（Case Management Model and Notation）引擎、DMN（Decision Model and Notation）引擎、表单引擎（Form Engine）等模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对开源版，其商业版的功能会更强大。以 Flowable6.4.1 版本为分水岭，大力发展其商业版产品，开源版本维护不及时，部分功能已经不再开源版发布，比如表单生成器（表单引擎）、历史数据同步至其他数据源、ES 等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Camunda&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Camunda 基于 Activiti5，所以其保留了 PVM，最新版本 Camunda7.15，保持每年发布两个小版本的节奏，开发团队也是从 Activiti 中分裂出来的，发展轨迹与 Flowable 相似，同时也提供了商业版，不过对于一般企业应用，开源版本也足够了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是每个项目的一个大概介绍，接下来主要对比一下 Jbpm、Activiti、Flowable 和 Camunda。只看文字的话可能对它们之间的关系还不是很清楚，所以我画了一张图，可以更清晰地体现每个项目的发展轨迹。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4676165803108808&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;772&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEafXvEvIxELIgIVslEqWIOliaZvMD8ly0XnzXwj7FSia0nlkAiavIzicBtA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如果想要选择其中一个项目来使用的话，应该如何选择呢？我罗列了几项我比较关注的点，做了一张对比表格，如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Activiti 7&lt;/th&gt;&lt;th&gt;Flowable 6&lt;/th&gt;&lt;th&gt;Camunda&lt;/th&gt;&lt;th&gt;JBPM 7&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;流程协议&lt;/td&gt;&lt;td&gt;BPMN2.0、XPDL、PDL&lt;/td&gt;&lt;td&gt;BPMN2.0、XPDL、XPDL&lt;/td&gt;&lt;td&gt;BPMN2.0、XPDL、XPDL&lt;/td&gt;&lt;td&gt;BPMN2.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;开源情况&lt;/td&gt;&lt;td&gt;开源&lt;/td&gt;&lt;td&gt;商业和开源版&lt;/td&gt;&lt;td&gt;商业和开源版&lt;/td&gt;&lt;td&gt;开源&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;开发基础&lt;/td&gt;&lt;td&gt;JBPM4&lt;/td&gt;&lt;td&gt;Activiti 5 &amp;amp; 6&lt;/td&gt;&lt;td&gt;Activiti 5&lt;/td&gt;&lt;td&gt;版本 5 之后 Drools Flow&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据库&lt;/td&gt;&lt;td&gt;Oracle、SQL Server、MySQL&lt;/td&gt;&lt;td&gt;Oracle、SQL Server、MySQL、postgre&lt;/td&gt;&lt;td&gt;Oracle、SQL Server、MySQL、postgre&lt;/td&gt;&lt;td&gt;MySQL，postgre&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;架构&lt;/td&gt;&lt;td&gt;spring boot 2&lt;/td&gt;&lt;td&gt;spring boot 1.5&lt;/td&gt;&lt;td&gt;spring boot 2&lt;/td&gt;&lt;td&gt;Kie&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;运行模式&lt;/td&gt;&lt;td&gt;独立运行和内嵌&lt;/td&gt;&lt;td&gt;独立运行和内嵌&lt;/td&gt;&lt;td&gt;独立运行和内嵌&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;流程设计器&lt;/td&gt;&lt;td&gt;AngularJS&lt;/td&gt;&lt;td&gt;AngularJS&lt;/td&gt;&lt;td&gt;bpmn.js&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;活跃度&lt;/td&gt;&lt;td&gt;活跃&lt;/td&gt;&lt;td&gt;相对活跃&lt;/td&gt;&lt;td&gt;相对活跃&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;表数量&lt;/td&gt;&lt;td&gt;引入 25 张表&lt;/td&gt;&lt;td&gt;引入 47 张表&lt;/td&gt;&lt;td&gt;引入 19 张表&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jar 包数量&lt;/td&gt;&lt;td&gt;引入 10 个 jar&lt;/td&gt;&lt;td&gt;引入 37 个 jar&lt;/td&gt;&lt;td&gt;引入 15 个 jar&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Flowable 应用举例&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果选择使用开源项目来开发自己的引擎，或者嵌入到现有的项目中，应该如何使用呢？这里通过 Flowable 来举例说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Flowable 可以有两种方式，分别是内嵌和独立部署方式，现在来分别说明：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;内嵌模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建 maven 工程&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先建一个普通的 maven 工程，加入 Flowable 引擎的依赖以及 h2 内嵌数据库的依赖，也可以使用 MySQL 数据库来做持久化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.flowable/flowable-engine --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.flowable&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;flowable-engine&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;6.7.2&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.h2database&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;h2&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.4.192&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建流程引擎实例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; org.flowable.engine.ProcessEngine;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.flowable.engine.ProcessEngineConfiguration;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HolidayRequest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ProcessEngineConfiguration cfg = &lt;span&gt;new&lt;/span&gt; StandaloneProcessEngineConfiguration()&lt;br/&gt;      .setJdbcUrl(&lt;span&gt;&quot;jdbc:h2:mem:flowable;DB_CLOSE_DELAY=-1&quot;&lt;/span&gt;)&lt;br/&gt;      .setJdbcUsername(&lt;span&gt;&quot;sa&quot;&lt;/span&gt;)&lt;br/&gt;      .setJdbcPassword(&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt;      .setJdbcDriver(&lt;span&gt;&quot;org.h2.Driver&quot;&lt;/span&gt;)&lt;br/&gt;      .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);&lt;br/&gt;&lt;br/&gt;    ProcessEngine processEngine = cfg.buildProcessEngine();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们就可以往这个引擎实例上部署一个流程 xml。比如，我们想建立一个员工请假流程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;definitions&lt;/span&gt; &lt;span&gt;xmlns&lt;/span&gt;=&lt;span&gt;&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;xmlns:activiti&lt;/span&gt;=&lt;span&gt;&quot;http://activiti.org/bpmn&quot;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;typeLanguage&lt;/span&gt;=&lt;span&gt;&quot;http://www.w3.org/2001/XMLSchema&quot;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;expressionLanguage&lt;/span&gt;=&lt;span&gt;&quot;http://www.w3.org/1999/XPath&quot;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;targetNamespace&lt;/span&gt;=&lt;span&gt;&quot;http://www.flowable.org/processdef&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;process&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;holidayRequest&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Holiday Request&quot;&lt;/span&gt; &lt;span&gt;isExecutable&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;startEvent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;startEvent&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;startEvent&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;approveTask&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!--        &amp;lt;userTask id=&quot;approveTask&quot; name=&quot;Approve or reject request&quot;/&amp;gt;--&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;userTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;approveTask&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Approve or reject request&quot;&lt;/span&gt; &lt;span&gt;activiti:candidateGroups&lt;/span&gt;=&lt;span&gt;&quot;managers&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;approveTask&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;decision&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;exclusiveGateway&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;decision&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;decision&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;externalSystemCall&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;conditionExpression&lt;/span&gt; &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;tFormalExpression&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &amp;lt;![CDATA[&lt;br/&gt;          ${approved}&lt;br/&gt;        ]]&amp;gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;conditionExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;sequenceFlow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;decision&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;sendRejectionMail&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;conditionExpression&lt;/span&gt; &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;tFormalExpression&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &amp;lt;![CDATA[&lt;br/&gt;          ${!approved}&lt;br/&gt;        ]]&amp;gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;conditionExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;sequenceFlow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;serviceTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;externalSystemCall&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Enter holidays in external system&quot;&lt;/span&gt;&lt;br/&gt;                     &lt;span&gt;activiti:class&lt;/span&gt;=&lt;span&gt;&quot;org.example.CallExternalSystemDelegate&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;externalSystemCall&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;holidayApprovedTask&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!--        &amp;lt;userTask id=&quot;holidayApprovedTask&quot; name=&quot;Holiday approved&quot;/&amp;gt;--&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;userTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;holidayApprovedTask&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Holiday approved&quot;&lt;/span&gt; &lt;span&gt;activiti:assignee&lt;/span&gt;=&lt;span&gt;&quot;${employee}&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;holidayApprovedTask&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;approveEnd&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;serviceTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;sendRejectionMail&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Send out rejection email&quot;&lt;/span&gt;&lt;br/&gt;                     &lt;span&gt;activiti:class&lt;/span&gt;=&lt;span&gt;&quot;org.flowable.SendRejectionMail&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;sendRejectionMail&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;rejectEnd&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;endEvent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;approveEnd&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;endEvent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;rejectEnd&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;process&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;definitions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此 xml 是符合 bpmn2.0 规范的一种标准格式，其对应的流程图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37898936170212766&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoE8x1ibHZJY4Jdey0TlmvDibanictLnozVGibDjQxekdgSibll16DLkoAGsXg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们就把这个文件传给流程引擎，让它基于该文件，创建一个工作流。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;RepositoryService repositoryService = processEngine.getRepositoryService();&lt;br/&gt;Deployment deployment = repositoryService.createDeployment()&lt;br/&gt;  .addClasspathResource(&lt;span&gt;&quot;holiday-request.bpmn20.xml&quot;&lt;/span&gt;)&lt;br/&gt;  .deploy();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建后，实际就写到内存数据库 h2 了，我们还可以把它查出来：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()&lt;br/&gt;  .deploymentId(deployment.getId())&lt;br/&gt;  .singleResult();&lt;br/&gt;System.out.println(&lt;span&gt;&quot;Found process definition : &quot;&lt;/span&gt; + processDefinition.getName());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建工作流实例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建工作流实例，需要提供一些输入参数，比如我们创建的员工请假流程，参数就需要：员工姓名、请假天数、事由等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Scanner scanner= &lt;span&gt;new&lt;/span&gt; Scanner(System.in);&lt;br/&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;Who are you?&quot;&lt;/span&gt;);&lt;br/&gt;String employee = scanner.nextLine();&lt;br/&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;How many holidays do you want to request?&quot;&lt;/span&gt;);&lt;br/&gt;Integer nrOfHolidays = Integer.valueOf(scanner.nextLine());&lt;br/&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;Why do you need them?&quot;&lt;/span&gt;);&lt;br/&gt;String description = scanner.nextLine();&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;RuntimeService runtimeService = processEngine.getRuntimeService();&lt;br/&gt;&lt;br/&gt;Map&amp;lt;String, Object&amp;gt; variables = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;();&lt;br/&gt;variables.put(&lt;span&gt;&quot;employee&quot;&lt;/span&gt;, employee);&lt;br/&gt;variables.put(&lt;span&gt;&quot;nrOfHolidays&quot;&lt;/span&gt;, nrOfHolidays);&lt;br/&gt;variables.put(&lt;span&gt;&quot;description&quot;&lt;/span&gt;, description);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数准备好后，就可以传给工作流了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ProcessInstance processInstance =&lt;br/&gt;    runtimeService.startProcessInstanceByKey(&lt;span&gt;&quot;holidayRequest&quot;&lt;/span&gt;, variables);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，就会根据流程定义里的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;userTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;approveTask&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Approve or reject request&quot;&lt;/span&gt; &lt;span&gt;activiti:candidateGroups&lt;/span&gt;=&lt;span&gt;&quot;managers&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个任务，任务有个标签，就是 &lt;code&gt;candidateGroups&lt;/code&gt;，这里的 &lt;code&gt;managers&lt;/code&gt;，可以猜得出，是给 &lt;code&gt;managers&lt;/code&gt; 建了个审批任务。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;查询并审批任务&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 manager 查询任务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;TaskService taskService = processEngine.getTaskService();&lt;br/&gt;List&amp;lt;Task&amp;gt; tasks = taskService.createTaskQuery().taskCandidateGroup(&lt;span&gt;&quot;managers&quot;&lt;/span&gt;).list();&lt;br/&gt;System.out.println(&lt;span&gt;&quot;You have &quot;&lt;/span&gt; + tasks.size() + &lt;span&gt;&quot; tasks:&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;tasks.size(); i++) {&lt;br/&gt;  System.out.println((i+&lt;span&gt;1&lt;/span&gt;) + &lt;span&gt;&quot;) &quot;&lt;/span&gt; + tasks.get(i).getName());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审批任务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;boolean&lt;/span&gt; approved = scanner.nextLine().toLowerCase().equals(&lt;span&gt;&quot;y&quot;&lt;/span&gt;);&lt;br/&gt;variables = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;();&lt;br/&gt;variables.put(&lt;span&gt;&quot;approved&quot;&lt;/span&gt;, approved);&lt;br/&gt;taskService.complete(task.getId(), variables);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就是把全局变量 &lt;code&gt;approved&lt;/code&gt;，设为了 &lt;code&gt;true&lt;/code&gt;，然后提交给引擎。引擎就会根据这里的变量是 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt;，选择走不同分支。如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;decision&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;externalSystemCall&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;conditionExpression&lt;/span&gt; &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;tFormalExpression&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &amp;lt;![CDATA[&lt;br/&gt;  ${approved}&lt;br/&gt;]]&amp;gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;conditionExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;sequenceFlow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;decision&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;sendRejectionMail&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;conditionExpression&lt;/span&gt; &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;tFormalExpression&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &amp;lt;![CDATA[&lt;br/&gt;  ${!approved}&lt;br/&gt;]]&amp;gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;conditionExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;sequenceFlow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回调用户代码&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审批后，就会进入下一个节点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;serviceTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;externalSystemCall&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Enter holidays in external system&quot;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;activiti:class&lt;/span&gt;=&lt;span&gt;&quot;org.example.CallExternalSystemDelegate&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个 &lt;code&gt;class&lt;/code&gt;，就是需要我们自己实现的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.27611664820967147&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2709&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEuWhdjibY85LibMwia2HzYsm5ePHvWRfDbXZYgL9EvxhykfpgaUX6JicBxw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，流程就走完结束了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;REST API 模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍的方式是其作为一个 jar，内嵌到我们的程序里。创建引擎实例后，由我们业务程序去驱动引擎的运行。引擎和业务代码在同一个进程里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种方式，Flowable 也可以作为一个独立服务运行，提供 REST API 接口，这样的话，非 Java 语言开发的系统就也可以使用该引擎了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个只需要我们下载官方的 zip 包，里面有个 rest 的 war 包，可以直接放到 tomcat 里运行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;部署工作流&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种方式下，如果要实现上面举例的员工请假流程，可以通过调接口来实现：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25798438608942514&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoE1F1s7fcbAEuLlfRUSEYjsS34TSXgoHcQsmvhso0ficKY2VDK78Smynw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动工作流：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4304581097812629&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2423&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEkQIsQCHMrak55e4NzI1TNlQZrfzCX071PHxViaJ8IibukIj26CY7E4Lw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他接口就不一一展示了，可以参考官方文档。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;通过页面进行流程建模&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截止到目前，创建工作流程都是通过建立 xml 来实现的，这样还是非常不方便的。因此，系统也提供了通过页面可视化的方式来创建流程，使用鼠标拖拽相应组件即可完成。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46255506607929514&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEBKdoOoc7ZxEQ5zjK0NoxYzuTXPP0LSyOSdBTpXIic6pfzjicC9GODL6A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是体验下来还是比较辛苦的，功能很多，名词更多，有很多都不知道是什么意思，只能不断尝试来理解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开源 VS 自研&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然已经有成熟的开源产品了，还需要自研吗？这算是一个老生常谈的问题了。那到底应该如何选择呢？其实并不困难，归根结底就是要符合自身的业务特点，以及实际的需求。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3442622950819672&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;671&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoE2JM9obqkfh6nC9GKRZNne0nk5x3tJ1ibgA6UmicoTaib7CicvoDFBcaEMQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;开源优势：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入门门槛低，有很多可以复用的成果。通常而言，功能比较丰富，周边生态也比较完善，投入产出比比较高。&lt;strong&gt;一句话总结，投入少，见效快。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;开源劣势：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核不容易掌控，门槛较高，通常开源的功能和实际业务并不会完全匹配，很多开源产品开箱即用做的不够好，需要大量调优。&lt;strong&gt;一句话总结，入门容易掌控难。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;自研优势：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品核心技术掌控程度高，可以更好的贴着业务需求做，可以定制的更好，基于上述两点，通常更容易做到良好的性能表现。&lt;strong&gt;一句话总结，量身定制。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;自研劣势：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;投入产出比略低，且对团队成员的能力曲线要求较高。此外封闭的生态会导致周边支持缺乏，当需要一些新需求时，往往都需要定制开发。&lt;strong&gt;一句话总结，啥事都要靠自己。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上的分析，再结合我们自身业务，我总结了以下几点可供参考：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;开源项目均为 Java 技术栈，而我们使用 Python 和 Go 比较多，技术栈不匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开源项目功能丰富，而我们业务相对简单，使用起来比较重&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开源项目并非开箱即用，需要结合业务特点做定制开发，学习成本和维护成本比较高&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上所述，我觉得自研更适合我们现阶段的产品特点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;工作流引擎架构设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果选择自研，架构应该如何设计呢？有哪些比较重要的模块和需要注意的点呢？下面来详细说说。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;BPMN&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BPMN 全称是 Business Process Model And Notation，即业务流程模型和符号。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4838507369081217&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;3189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoE0JDoYulZz74Dao4mlib8KtsRiaXRF7RpTib60iakNeMRZGcaGpVmUCgtJw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以理解成一种规范，在这个规范里，哪些地方用空心圆，哪些地方用矩形，哪些地方用菱形，都是有明确定义的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，只要是基于这个规范开发的系统，其所创建的流程就都是可以通用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，如果只是开发一个内部系统，不遵守这个规范也没有问题。但要是做一个产品的话，为了通用性更强，最好还是遵守这个规范。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;流程设计器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于工作流引擎来说，流程设计器的选型至关重要，它提供了可视化的流程编排能力，决定了用户体验的好坏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前主流的流程设计器有 Activiti-Modeler，mxGraph，bpmn-js 等，下面来做一个简单介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Activiti-Modeler&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Activiti 开源版本中带了 Web 版流程设计器，在 Activiti-explorer 项目中有 Activiti-Modeler，优点是集成简单，开发工作量小，缺点是界面不美观，用户体验差。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6623711340206185&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEFUJl7beaEw7ay6yyBZqhbxceibJg8DqIFLicqRdxa4j89ia4RYGiassQjA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;mxGraph&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mxGraph 是一个强大的 JavaScript 流程图前端库，可以快速创建交互式图表和图表应用程序，国内外著名的 ProcessOne 和 draw.io 都是使用该库创建的强大的在线流程图绘制网站。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 mxGraph 是一个开放的 js 绘图开发框架，我们可以开发出很炫的样式，或者完全按照项目需求定制。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6822742474916388&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEOuWjeb6XQZKoax07RD7BH21LNxRjyeibht5U92lYBQBbNagKliaRDZQw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方网站：http://jgraph.github.io/mxgrap&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;bpmn-js&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bpmn-js 是 BPMN2.0 渲染工具包和 Web 模型。bpmn-js 正在努力成为 Camunda BPM 的一部分。bpmn-js 使用 Web 建模工具可以很方便的构建 BPMN 图表，可以把 BPMN 图表嵌入到你的项目中，容易扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bpmn-js 是基于原生 js 开发，支持集成到 vue、react 等开源框架中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38113207547169814&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoETJL5oibK862N9KwEdO6rBcKFA9GtXVjCplMLvE6M6icHf26yXPn0MTMA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方网站：https://bpmn.io/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上介绍的都属于是功能强大且完善的框架，除此之外，还有其他基于 Vue 或者 React 开发的可视化编辑工具，大家也可以根据自己的实际需求进行选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;流程引擎&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后来说说流程引擎，整个系统的核心。引擎设计的好坏决定了整个系统的稳定性，可用性，扩展性等等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6747967479674797&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;861&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEV2UlNNSic16BlkJttOVUhadkPZ8HdGIK0MHc5hSyehxItTR6TYKk5Qg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体架构如图所示，主要包括一下几个部分：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一、&lt;strong&gt;流程设计器&lt;/strong&gt;主要通过一系列工具创建一个计算机可以处理的工作流程描述，流程建模通常由许多离散的节点步骤组成，需要包含所有关于流程的必要信息，这些信息包括流程的起始和结束条件，节点之间的流转，要承担的用户任务，被调用的应用程序等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二、&lt;strong&gt;流程引擎&lt;/strong&gt;主要负责流程实例化、流程控制、节点实例化、节点调度等。在执行过程中，工作流引擎提供流程的相关信息，管理流程的运行，监控流程的运行状态，并记录流程运行的历史数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三、&lt;strong&gt;存储服务&lt;/strong&gt;提供具体模型及流程流转产生的信息的存储空间，工作流系统通常需要支持各种常见的数据库存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;四、&lt;strong&gt;组织模型&lt;/strong&gt;不属于工作流系统的建设范围，但流程设计器在建模的过程中会引用组织模型，如定义任务节点的参与者。还有就是在流程流转的过程中同样也需要引用组织模型，如在进行任务指派时，需要从组织模型中确定任务的执行者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流引擎内部可以使用平台自身的统一用户组织架构，也可以适配第三方提供的用户组织架构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;五、工作流引擎作为一项基础支撑服务提供给各业务系统使用，对第三方系统开放标准的 &lt;strong&gt;RESTful 服务&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后记&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来说说我现在开发的系统支持到了什么程度，以及未来可能的发展方向。由于毕竟不是一个专门的工单系统，工单申请也只是其中的一个模块，所以在整体的功能上肯定和完整的工作流引擎有很大差距。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;第一版&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一版并没有流程引擎，开发方式简单粗暴，每增加一个流程，就需要重新开发对应的表和业务代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的缺点是非常明显的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每个流程需要单独开发，工作量大，开发效率低&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流程功能相近，代码重复量大，冗余，不利于维护&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定制化开发，缺少扩展性#&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;第二版&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二版，也就是目前的版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着工单流程逐渐增多，工作量逐渐增大，于是开始对流程进行优化，开发了现阶段的工作流引擎。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.578125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt6wu6Lcialicmn80jiaoLvIQ3cT8jd1rLjuibXwwVJ2DNMJTgriaZuCQJCjPKYRNjZbTtd8886E3lEFNQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在新增一个工单流程时，需要先进行工作流配置，配置其基础信息，自定义字段，状态和流转这些信息。还支持配置自动化节点，可以根据条件由程序自动完成相关操作并审批。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置好之后，后端无需开发，由统一的引擎代码进行处理，包括节点审批流转，状态变更等。只需要开发前端的创建和查询页面即可，相比于第一版，已经在很大程度上提高了开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前版本需要优化的点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;缺少可视化流程设计器，无法做到拖拽式设计流程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点之间状态流转不够灵活&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺少分布式事物支持，以及异常处理机制&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;下一个版本&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对以上不足，下一个版本准备主要优化三点，如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;需要支持可视化流程设计器，使流程设计更加简单，灵活&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据流程配置自动生成前端页面，做到新增一种类型的工单，无需开发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加节点自动化能力，异常处理机制，提高系统的稳定性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是本文的全部内容，如果觉得还不错的话欢迎&lt;strong&gt;点赞&lt;/strong&gt;，&lt;strong&gt;转发&lt;/strong&gt;和&lt;strong&gt;关注&lt;/strong&gt;，感谢支持。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考文章：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://www.cnblogs.com/grey-wolf/p/15963839.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.cnblogs.com/duck-and-duck/p/14436373.html#!comments&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://zhuanlan.zhihu.com/p/369761832&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://zhuanlan.zhihu.com/p/143739835&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://bbs.qolome.com/?p=365&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://workflowengine.io/blog/java-workflow-engines-comparison/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a4593c1788940a37c3221448fb11555a</guid>
<title>HelloGitHub 最受欢迎的开源项目 Top10</title>
<link>https://toutiao.io/k/1xbjvq3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;419&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaojUMxmwJwbic50SSINcPiaH7q2QsoUuZN2zNgNomCcexFmNKxrVtr4UKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再见 2022，你好 2023！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HelloGitHub 也随着 2023 年的到来，更新到了&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5MzYyNzQ0MQ==&amp;amp;mid=2247514679&amp;amp;idx=1&amp;amp;sn=1a83ccfe8292ce2b8b8c9dd79ac08480&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第‍ 81 期&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;第 81 期&lt;/a&gt;开始迈向第 7 个年头啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在过去的 2022 年，我们一共发布了 12 期月刊、分享了 502 个开源项目，HelloGitHub 能够分享这么多有趣、好玩的开源项目，离不开开源爱好者的推荐、项目作者的自荐以及团队成员的贡献。在 2022 年发布过的众多开源项目中，你最喜欢哪个开源项目呢？哪些开源项目让你印象深刻？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就让我们一起来看看 2022 年&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;amp;__biz=MzA5MzYyNzQ0MQ==&amp;amp;scene=1&amp;amp;album_id=1331197538447310849&amp;amp;count=3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《HelloGitHub‍ 月刊》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《HelloGitHub 月刊》&lt;/a&gt;最受欢迎的 10 个开源项目，为了尽量涵盖较多的类别，就从 C++、Python、Java、JavaScript、Go、C#、C、Rust、CSS 每个类别挑选一个组成了 &lt;strong&gt;Top10 开源项目&lt;/strong&gt;。排名并不重要，重要是的是不能让你错过这些好玩的开源项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话不多说，开始今年的 HelloGitHub 年度盘点！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、《金庸群侠传》C++ 复刻版&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38071065989847713&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaohmoNrgR4CYiatT8Jr8Vs1bbaaxuc45slC2qich7JKvWvSGUWoog9ARrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;591&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：1.9K｜&lt;strong&gt;编程语言&lt;/strong&gt;：C++&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一款基于 SDL2 开发的 2D 游戏，作为《金庸群侠传》C++ 复刻版，它的资源大部分来自《金庸群侠传》DOS 版本，复刻版除了经典的回合制战斗系统，还在加入了受《黑帝斯》启发的即时战斗系统。或许大佬们的重温经典，就是用自己擅长的编程语言把游戏重新实现一遍吧。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6549707602339181&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaoH8sjzRKqCebEysmUW7s4Yic6ytQBKwZpUCclAwnLVjQAjfEKiaRx45IA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/scarsty/kys-cpp&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、异步的 Python 聊天机器人框架&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32742316784869974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaoL01UBicL39RaI5O4zrHD9oXdRey1A7OZT7TqaYzW7AlY1fmSChhtCWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1692&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：3.2K｜&lt;strong&gt;编程语言&lt;/strong&gt;：Python&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是基于 Python 的异步特性构建的聊天机器人框架，可以轻松处理大量的消息。还提供了命令行脚手架，仅用几条命令就可以完成项目搭建。支持多种 IM 平台，有效地帮助开发人员快速构建聊天机器人、消息通知等项目。该项目代码质量高、社区活跃，它上得了生产环境，下能搞定一次性脚本。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6852300242130751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaokpxHLGDWPniaicYfJ2LjUdapaHmbCSxTZHQ5Fk3c7PJC9gDia06icPoPEw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;826&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/nonebot/nonebot2&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、JVM 沙箱容器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16205128205128205&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaoDvISfA2S1btCRHtUyYLyd0AAnoZZZDXHdy1lKnUEsYzGq17TM6Bqnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;975&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：5.5K｜&lt;strong&gt;编程语言&lt;/strong&gt;：Java&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一种 JVM 的非侵入式运行期 AOP 解决方案。简单地说就是如果线上 Java 服务出现故障，需要加一条日志定位问题，通过该项目就可以在不重启服务的情况下，完成增加日志的操作。它还支持线上故障模拟、请求录制和结果回放等功能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.440625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiao3XNNrBucPWbrTZDPnmIibRmn9rbjvnTyHzh1lYWVlic9uWbCTwcFXYcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/alibaba/jvm-sandbox&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、称手的 JSON 可视化工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaoLyuuVM5C341XhDplJGDvbXWBiaYHL9DF9UgrIAtpzRib6FmognUD3Xcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：20.6K｜&lt;strong&gt;编程语言&lt;/strong&gt;：TypeScript&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一款改变你查看 JSON 数据习惯的工具，它不是简单地格式化 JSON 数据，而是将其数据转化成节点，通过类似脑图的形式展示。支持放大/缩小、展开/收缩、搜索节点、导出图片等操作，你还可以通过部署服务，将它变成免费的在线服务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.71875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaoArwPeT6nnaoPZXU1NPnz3xor8NBvl1RYT6ZKko5iadD4hhzW6YM2Nug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2624&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/AykutSarac/jsoncrack.com&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、极简的订阅工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2684563758389262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaojf4ImByeMhXa2J1N4sVwCWt2oWsOvEC8Mn09ldy6shmPrhN8IJVDNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：4.4K｜&lt;strong&gt;编程语言&lt;/strong&gt;：Go&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个极简主义的 feed 阅读器，它的“简”是由内而外，内部代码部分不使用 Web 框架和 ORM 仅采用 Go+PostgreSQL+JS 实现，界面朴实无华、功能精简实用，支持快速自建、源管理、自动获取内容、快捷键、用户系统等，这一切不多不少刚刚好。Go 初学者可以通过阅读不依赖任何框架、“纯粹”的 Go 代码，看清 Web 开发的原理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6388888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaoamjMPr3dDTGUg380TozAvRSibZDFZU3kW6VcLUXAHM3bV2ta5wfrdcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/miniflux/v2&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6、强大的媒体库管理工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26832151300236406&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiao2QNiblbtxxpGutzNZjq8YbPhDlvFydGWVXAvtGLmzNyxK2n1AhEQmww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1692&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：19.2K｜&lt;strong&gt;编程语言&lt;/strong&gt;：C#&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一款完全免费、支持中文、安装简单、跨平台、功能齐全的媒体库管理系统。它能把原本躺在文件夹里的视频文件，变成包含封面、描述、评分、演员表等信息的“影碟”，让视频整整齐齐、赏心悦目，还支持视频续播、订阅更新、多端可看，让你可以远离广告优雅地追剧。要说缺点的话，我感觉就是得花时间折腾一番才能感受到它的魅力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.552999178307313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaoOUP3NaYKMAkEnMMLasib5ALiat0aet7V71Ee4fibzTnQAp6FRHeqEwDZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2434&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/jellyfin/jellyfin&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7、好玩的 GB 游戏制作工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6477611940298508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaoIQoZZEDeib7FvjSyxhgdc6CFBaO4essGicia9EMQzgaL1rIHn4M5EFYAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1340&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：6.7K｜&lt;strong&gt;编程语言&lt;/strong&gt;：C&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一款可视化开发游戏的工具，可用于快速构建复古冒险游戏。通过该项目可以实现仅仅拖拽的方式，就能制作出复古风格的 Game Boy 游戏，不会编程也可以开发游戏。还支持导出 ROM 或发布成在线游戏，适用于 macOS、Linux 和 Windows 操作系统。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaohkcQ3G1Aqp30BCexAbqAXQuB2sprxW6RwrZWPC0IQfYtiaiabrEryAew/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/chrismaltby/gb-studio&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8、Markdown 电子书构建工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：11.6K｜&lt;strong&gt;编程语言&lt;/strong&gt;：Rust&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该项目是 Rust 官方开源的制作 Markdown 电子书工具，功能上类似 Gitbook。它可以将 Markdown 文件制作成在线书籍，支持代码高亮、可集成搜索、多主题等功能，简单易用非常适合创建教程、API 文档、开源书籍等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaoV8K20kKzmLGddjdlRdsnUc9Rx5rN6IicIC8lBPAaHh4p2Upic7GK3XVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1960&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/rust-lang/mdBook&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9、按钮样式集合&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5635416666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaonpfcRevGHjSXIWibnGbUyAgiaqNFORqHLekVwkWmReP8iaoD4fGKqRqGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：2.6K｜&lt;strong&gt;编程语言&lt;/strong&gt;：CSS&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该项目提供了 100 种不同样式按钮的 CSS 源码，不仅如此还支持在线查看效果以及调试。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6870229007633588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaoeIkIjfT0f5iaI9HBvibkOb5WvAKT34t0M41YLYVsaj8KFafP4bB0Q0hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1834&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/ui-buttons/core&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10、大学计算机没有的一课&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6083333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaopy981Xnm4kgN5uHOUKGoSfskZZDfGHzwSSibicJ0sWt7ib3XdXDAia5v6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Star 数&lt;/strong&gt;：3.3K｜&lt;strong&gt;编程语言&lt;/strong&gt;：Other&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大学里的计算机课程往往只专注于讲授数据结构、操作系统这些知识，对于编程开发中常用的工具则留给学生自行学习。在 MIT 这个课程中，你可以了解和掌握命令行(shell)、文本编辑器(Vim)、版本控制系统(Git)等强大的工具，越早接触越能更加熟练地使用它们，有助于未来的职业生涯。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4946401225114854&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNNRK93loibTVe5ibubBhlzdiaoZCfk2CwK9mUwC1XOdztibkxD5XfOiad8DADLvywCZ4vwyVEwIygUNphw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1306&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：https://github.com/missing-semester/missing-semester&lt;/p&gt;&lt;p&gt;中文：https://missing-semester-cn.github.io/&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HelloGitHub 的年度 Top10 榜单，并不是简单地根据项目访问数拉个表单就完事儿了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了让更多人在 HelloGitHub 找到喜欢的开源项目，不管擅长什么编程语言、职业是学生还是程序员。我多花了几倍的时间，从多个主流分类中挑选出几个较为受欢迎的几个开源项目，然后根据大家的评价、留言、访问比等数据层层筛选，最终每个分类只留一个开源项目，反复多次才制作出这个榜单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HelloGitHub 一直秉承着分享 GitHub 上有趣、入门级的开源项目，我们做的一切都是为了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;让你找到喜欢的开源项目，爱上开源参与开源。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一切美好风景都在路上，希望你和开源最美的那张合影上有 HelloGitHub。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于篇幅有限，还有很多优秀的项目没能入选，你可以在往期的&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;amp;__biz=MzA5MzYyNzQ0MQ==&amp;amp;scene=1&amp;amp;album_id=1331197538447310849&amp;amp;count=3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《He‍lloGitHub 月刊》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《HelloGitHub 月刊》&lt;/a&gt;中找到它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是本文的所有内容，如果您觉得这篇文章写得还不错，就请给我点一个&lt;strong&gt;赞&lt;/strong&gt;，您的支持就是我更新的动力。我们下期见～&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzA5MzYyNzQ0MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOqkqThUJBICyFBlvLvTyOCgBpibwWotSxGExfnOYFfPiaL9yn3GMUOCEVYN2RNslGCdQwgZy6ticdyA/0?wx_fmt=png&quot; data-nickname=&quot;HelloGitHub&quot; data-alias=&quot;GitHub520&quot; data-signature=&quot;分享 GitHub 上有趣、入门级的开源项目。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>15f6d06d0496d497ba91de39223fa6e4</guid>
<title>Jupyter Notebook 入门指南</title>
<link>https://toutiao.io/k/3qcyw39</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h6&gt;作者：京东科技隐私计算产品部 孙晓军&lt;/h6&gt;

&lt;h1&gt;&lt;strong&gt;1. Jupyter Notebook介绍&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0fd0cb99ada45f5ac32b7a1aa7881b5%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图1 Jupter项目整体架构&lt;/p&gt;

&lt;p&gt;[&lt;a href=&quot;https://docs.jupyter.org/en/latest/projects/architecture/content-architecture.html&quot;&gt;https://docs.jupyter.org/en/latest/projects/architecture/content-architecture.html&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Jupyter Notebook是一套基于web的交互式开发环境。用户可以在线开发和分享包含代码和输出的交互式文档，支持实时代码，数学方程，可视化和 markdown等。用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等。&lt;/p&gt;

&lt;p&gt;Jupyter Notebook内部通过内核维护状态并运行代码片段，浏览器显示代码片段和其执行的结果。Jupyter Notebook提供了一个用户交互式的开发环境，用户可以通过执行一部分代码片段，并观察执行结果。这种交互式设计，使得Jupyter Notebook非常适合数据科学和机器学习的开发工作。&lt;/p&gt;

&lt;p&gt;注意本文的代码和脚本，均基于Jupyter Notebook v6.5.2稳定版本。&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;2. Jupyter的工作方式&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e5ff3f79ea24257a2c626f0a2ebda36%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图2 Jupter Notebook工作方式&lt;/p&gt;

&lt;p&gt;[&lt;a href=&quot;https://docs.jupyter.org/en/latest/projects/architecture/content-architecture.html&quot;&gt;https://docs.jupyter.org/en/latest/projects/architecture/content-architecture.html&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Jupyter的主要工作单元是Jupyter Server和Kernel。其中Jupyter Server用来提供基于Web的界面和API服务，Kernel用来执行代码片段。浏览器通过Http和Websockets的方式和Jupyter Server进行交互，Jupyter Server和kernel之间，通过ZeroMQ进行数据通信。&lt;/p&gt;

&lt;p&gt;Jupyter Server采用经典的MVC模式，使用了tornado作为web服务器，用来提供地址映射和控制器逻辑，使用jinja2来提供模板视图功能。&lt;/p&gt;

&lt;p&gt;Jupyter Notebook（v6.5.2）项目的主要模块结构如下：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模块&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;notebook&lt;/td&gt;
&lt;td&gt;Notebook功能模块。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;terminal&lt;/td&gt;
&lt;td&gt;终端模块。为Jupyter提供控制台交互能力。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;view&lt;/td&gt;
&lt;td&gt;文件可视化模块。比如pdf文件的显示。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tree&lt;/td&gt;
&lt;td&gt;工作区目录树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nbconvert&lt;/td&gt;
&lt;td&gt;格式转换模块，可以把Jupyter Notebook转换成html，pdf等格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kernel&lt;/td&gt;
&lt;td&gt;Jupyter Notebook 内核&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;services&lt;/td&gt;
&lt;td&gt;Jupyter Notebook REST API模块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i18n&lt;/td&gt;
&lt;td&gt;Jupyter Notebook多语言资源&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h1&gt;&lt;strong&gt;3. 安装Jupyter Notebook&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;前置条件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python和pip&lt;/p&gt;

&lt;p&gt;不同的Jupyter Notebook对Python有不同的版本要求。我们安装的最新的稳定版本v6.5.2的Jupyter Notebook，要求Python的最低版本为3.6。注意这个Python的版本，不同于内核的Python版本。对于Jupyter内核来说，支持的Python版本和Jupyter Notebook依赖的Python版本没有关系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在Linux系统下安装Jupyter Notebook&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用pip安装Jupyter notebook非常简单。如果服务器同时拥有Python2和Python3的pip，注意需要使用pip3来替换命令中的pip。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 更新pip
pip install --upgrade pip
# 安装jupyter
pip install jupyter
# 检查安装的jupyter
jupyter --version
//输出 notebook  : 6.5.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;&lt;strong&gt;4. 配置和启动Jupyter&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Jupyter提供了大量的启动参数，用来配置Jupyter Server。我们可以在启动Jupyter服务时，通过命令行参数的方式配置当前启动的服务，但更普遍的方式是使用Jupyter的配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 生成配置文件
jupyter notebook --generate-config
// 默认生成的配置文件位置：
/root/.jupyter/jupyter_notebook_config.py

# 修改Jupyter配置文件...

# 启动jupyter
jupyter notebook
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jupyter直接使用一个Python文件来配置Jupyter服务，所有的配置项均通过Python代码来完成。常用的配置项及其说明如下：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.allow_root&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;为了安全，Jupyter默认不允许使用root用户启动。如果需要以root用户的身份启动Jupyter，需要开启此设定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.allow_origin&lt;/td&gt;
&lt;td&gt;&#x27;&#x27;&lt;/td&gt;
&lt;td&gt;当需要Jupyter内嵌到iframe时，可以设置为“*“来避免跨origin的限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.ip&lt;/td&gt;
&lt;td&gt;localhost&lt;/td&gt;
&lt;td&gt;当需要通过外网地址来访问Jupyter服务时，需要设置一个有效的服务器IP地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.port&lt;/td&gt;
&lt;td&gt;8888&lt;/td&gt;
&lt;td&gt;Jupyter server对外服务端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.notebook_dir&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;Jupyter的工作空间，默认可以访问服务器上当前用户的所有文件系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.open_browser&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;启动服务后是否立即通过浏览器打开服务地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.default_url&lt;/td&gt;
&lt;td&gt;/tree&lt;/td&gt;
&lt;td&gt;Jupyter服务的默认地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.extra_static_paths&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;扩展静态文件目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.extra_template_paths&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;扩展模板文件目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.KernelSpecManager.allowed_kernelspecs&lt;/td&gt;
&lt;td&gt;set()&lt;/td&gt;
&lt;td&gt;默认允许使用所有的kernel&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.nbserver_extensions&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;td&gt;允许加载的Jupyter Server扩展&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h1&gt;5. 使用Jupyter&lt;/h1&gt;

&lt;h2&gt;5.1. 创建Notebook&lt;/h2&gt;

&lt;p&gt;启动Jupyter 后，在浏览器内输入 http://服务器地址:端口/，Jupyter会默认重定向到.default_url指定的工作区目录树地址，默认是工作区目录树的界面。&lt;/p&gt;

&lt;p&gt;如果在访问的过程中，使用了默认的token作为其认证方式，那么在首次打开时，需要输入Jupyter Notebook的token值，这个值可以在启动Jupyter时的控制台输出中找到，或者使用Jupyter命令来查询&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 查询运行的jupyter notebook
jupyter notebook list
//返回结果中包含了http://x.x.x.x:8899?token=ABC 的信息，其中的ABC就是我们需要的token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bd1619d943a459a80efde5b961aca66%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;图3 Jupter Notebook的默认工作区目录树页面&lt;/p&gt;

&lt;p&gt;Jupyter Notebook通过Jupyter Server提供基于Web的平台无关的工作方式，这使得跨平台开发和协作，代码分享等能力变得比传统IDE更加容易。&lt;/p&gt;

&lt;p&gt;在Jupyter 工作区管理界面，用户可以灵活地以类似文件系统的方式管理工作区的数据。可以创建文件和文件夹，编辑文件和文件夹，可以上传和下载文件。通过选择一个Jupyter内核，可以创建一个Notebook文件。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/782dd77ebc1e4fd78da31d82053620b4%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图4 通过Jupyter内核创建一个Notebook&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;5.2. 使用Notebook&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;使用Python3内核创建一个Notebook后，我们得到一个xxx.ipynb（IPython Notebook）文件。这个文件是一个json格式的文本文件，其中包含了我们在Notebook中编写的代码和文本内容，也包含了界面上没有显示的元数据信息。通过在工作区目录界面选择一个notebook文件，点击编辑，我们可以查看到ipynb文件的原始内容。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b66a3240cac142df9c4a8bf7f7879ff6%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图5 ipynb文件的原始内容&lt;/p&gt;

&lt;p&gt;我们可以像使用其它IDE类似的方式来使用Notebook，在使用Notebook上，我们主要关注下Jupyter内核和单元格。&lt;/p&gt;

&lt;p&gt;内核是执行单元格代码的核心进程，不同的内核，决定了我们在单元格中能够编写哪些语言的代码，以及对应了指定的编程语言的哪个版本等信息。&lt;/p&gt;

&lt;p&gt;单元格是整个Notebook的核心组成部分，我们编写的代码和文本，通过一些列Notebook单元格来组成。Notebook提供了Code，Markdown, Raw NBConvert, Heading四种类型的单元格。&lt;/p&gt;

&lt;p&gt;•Code单元格。用来编写内核指定语言的程序代码&lt;/p&gt;

&lt;p&gt;•Markdown单元格。使用Markdown编辑器的语法来编辑富文本&lt;/p&gt;

&lt;p&gt;•Raw NBConvert单元格。原始的文本，不会被当作代码或markdown被解释执行&lt;/p&gt;

&lt;p&gt;•Heading单元格。Heading是Mardown的一个子集，对应了Markdown中的标题编写语法&lt;/p&gt;

&lt;p&gt;Jupyter Notebook使用了机器学习中检查点的概念，在我们修改Notebook的过程中，Jupyter会自动保存我们的修改，我们也可以通过【文件】-&amp;gt;【保存】来手动保存检查点。检查点文件包含了我们编写的Notebook内容，以及执行代码单元格之后的输出。我们可以在工作空间的“.ipynb_checkpoints”文件夹下，找到这些检查点文件。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a9c22e7990b45889298ae10edbc60c9%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图6 使用Jupyter单元格来编写交互式代码&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;5.3. 分享Notebook&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;相较于使用传统的IDE编写的代码，基于Web服务的Jupyter Notebook在代码分享上拥有着天然的优势。&lt;/p&gt;

&lt;p&gt;在Jupyter Notebook中，我们可以通过两种不同的方式分享我们创作的nootbook。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;交互式Notebook文档&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;传统的技术文档或者说明书，通过静态的文本，配合图片和视频，来描述和讲解特定的技术或功能。有了Jupyter Notebook后，我们仍然可以使用Notebook来编写类似传统的技术文档。在此基础上，我们可以加入更生动的代码交互单元格，用户通过查看文档说明，并与文档中提供的代码进行互动，可以更生动地介绍产品中的功能和技术。每个Jupyter Notebook的ipynb文件，都对应了一个独立的访问地址： &lt;a href=&quot;http://x.x.x.x:8899/notebooks/my_notebook.ipynb&quot;&gt;http://x.x.x.x:8899/notebooks/my_notebook.ipynb&lt;/a&gt; ,通过分享此文件的地址，其他用户可以方便地使用包含了富文本和可执行的代码的交互式Notebook文档。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;离线Notebook文档&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们通过逐步执行文档中的所有单元格，得到一个包含了我们编写的说明和代码，以及代码执行的输出结果的完整文档。之后点击【文件】-&amp;gt; 【另存为】，选择一种合适的文件格式。我们可以把文档导出为一份静态文件，通过共享此静态文件，我们实现了Notebook文档的离线分享。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;5.4. 魔法函数&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Jupyter Notebook提供了一些列魔法函数来增强Jupyter Code单元格的功能，通过魔法函数，我们能够执行javascript脚本，html代码，运行另一个可执行程序等许多额外的功能。&lt;/p&gt;

&lt;p&gt;我们可以在Jupyter代码单元格中使用 %lsmagic命令来查看所有的魔法函数，如果要阅读详细的魔法函数的使用说明，可以参考： &lt;a href=&quot;https://ipython.readthedocs.io/en/stable/interactive/magics.html&quot;&gt;https://ipython.readthedocs.io/en/stable/interactive/magics.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;魔法函数分为行魔法函数，单元格魔法函数和会话魔法函数。顾名思义，行魔法函数只对当前行起作用，而单元格魔法函数则作用于整个单元格，会话魔法函数则作用于整个会话期间。&lt;/p&gt;

&lt;p&gt;一些常用的魔法函数：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;%matplotlib&lt;/td&gt;
&lt;td&gt;设置matplot绘图的显示模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%%javascript&lt;/td&gt;
&lt;td&gt;单元格内的代码被识别为javascript代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%%html&lt;/td&gt;
&lt;td&gt;单元格内的代码被识别为html代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%run&lt;/td&gt;
&lt;td&gt;执行外部脚本文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%pwd&lt;/td&gt;
&lt;td&gt;获取当前工作的目录位置（非工作空间目录位置）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%writefile&lt;/td&gt;
&lt;td&gt;以文件形式保存当前单元格代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%timeit&lt;/td&gt;
&lt;td&gt;获取本行代码的执行时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%debug&lt;/td&gt;
&lt;td&gt;激活调试模式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h1&gt;&lt;strong&gt;6. 管理Jupyter&lt;/strong&gt;&lt;/h1&gt;

&lt;h2&gt;&lt;strong&gt;6.1. 多语言&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Jupyter Notebook使用i18n目录下的资源来进行多语言翻译。在Jupyter Notebook启动时，会加载i18n目录下的多语言资源。之后根据http请求指定的语言，为响应数据提供对应的多语言翻译。如果没有对应的翻译，则保留原始的多语言标签值（英文）。如果调整了多语言翻译，需要重新启动Jupyter Notebook才能使用新的语言包。&lt;/p&gt;

&lt;p&gt;Jupyter Notebook的翻译资源主要分布在三个po文件中：&lt;/p&gt;

&lt;p&gt;•nbjs.po - js文件中的多语言数据&lt;/p&gt;

&lt;p&gt;•nbui.po - UI界面中的多语言数据&lt;/p&gt;

&lt;p&gt;•notebook.po - notebook中的多语言数据&lt;/p&gt;

&lt;p&gt;原始的po文件，需要通过pybabel工具，把po文件编译成mo文件，之后部署在$notebook/i18n/${LANG}/LC_MESSAGES/目录下（$notebook是notebook的安装目录），才能在Jupyter Notebook中作为多语言的资源包来使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 使用pybabel编译多语言po文件
pybabel compile -D notebook -f -l ${LANG} -i ${LANG}/LC_MESSAGES/notebook.po -o ${LANG}/LC_MESSAGES/notebook.mo
pybabel compile -D nbui -f -l ${LANG} -i ${LANG}/LC_MESSAGES/nbui.po -o ${LANG}/LC_MESSAGES/nbui.mo
pybabel compile -D nbjs -f -l ${LANG} -i ${LANG}/LC_MESSAGES/nbjs.po -o ${LANG}/LC_MESSAGES/nbjs.mo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbbc1e9e4dba45079c45f89ed18a6856%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图7 使用了中文语言包后的中文Notebook界面&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;6.2. 内核管理&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;内核（kernel）是独立于jupyter服务和界面之外的用来运行Jupyter代码单元格的进程，Jupyter默认提供了ipykernel内核来支持Python开发语言。Jupyter社区提供了jupyterC, IJava，xeus-cling, xeus-sql等众多其它编程语言的内核，用来支持C/C++, Java, SQL等编程语言。&lt;/p&gt;

&lt;p&gt;ipykernel默认使用系统环境下的Python来提供服务。我们可以使用ipykernel安装多个Python kernel来提供Python2.x, Python3.x等多个Python内核环境。&lt;/p&gt;

&lt;p&gt;安装kernel后，kernel的信息被保存在kernel.json文件中，我们可以在 /usr/local/share/jupyter/kernels 目录，找到Jupyter安装的所有kernel以及对应的kernel.json文件。&lt;/p&gt;

&lt;p&gt;kernel可以直接继承自安装kernel的Python指令，也可以使用Python虚拟环境。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 1.直接继承自Python指令的kernel安装
# 安装ipykernel
pip install ipykernel
# 安装kernel
python -m ipykernel install --name tensorflow2 --display-name &quot;tensorflow2&quot;

# 2. 在Python虚拟环境下的kernel安装
# 激活虚拟环境
source activate myenv
# 安装ipykernel
pip install ipykernel
# 安装kernel
python -m ipykernel install --name myenv --display-name &quot;Python3 (myenv)&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要查看当前的kernel列表，以及删除已经安装的kernel，可以使用如下的Jupyter命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 查看已经安装的kernel列表
jupyter kernelspec list
# 删除列表中指定的kernel
jupyter kernelspec remove kernelname
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;6.3. REST API&lt;/h2&gt;

&lt;p&gt;Jupyter提供了REST API接口来和Jupyter server进行交互。借助REST API的能力，我们可以以编程的方式和Jupyter Server进行交互，灵活地管理Jupyter Server。另外REST API为现代化的软件开发提供了一个优秀的能力：自动化。&lt;/p&gt;

&lt;p&gt;借助Jupyter Notebook REST API，可以实现文件的上传和下载，检查点管理，会话管理，内核管理，终端管理等一些列管理能力。完整的Jupyter REST API接口列表可以参考： &lt;a href=&quot;https://jupyter-server.readthedocs.io/en/latest/developers/rest-api.html&quot;&gt;https://jupyter-server.readthedocs.io/en/latest/developers/rest-api.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;要使用REST API，需要在请求中携带认证信息。Jupyter支持直接把token作为query string的方式来认证，也可以使用标准的Http Authorization头信息来完成认证。使用Authorization头来认证的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Authrozation: token 527a9f1430ccfed995ebcf15517583a2547c2469bc3c47a6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a788d8d789bb4816b29296607036c44d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图8 使用Postman来调用Jupyter REST API接口&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;6.4. 安全管理与多人协作&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Jupyter提供了灵活强大的能力，用以支持在线的交互式文档和代码的编写。但Jupyter项目自身没有提供精细化的安全管理体系，用以支持多用户下灵活地使用Jupyter Notebook的功能。对于文件安全，Jupyter依赖于启动服务的linux用户，合理地配置启动Jupyter的用户的权限，才能保证使用Jupyter的用户，不会对系统或项目造成破坏。Jupyter工作空间的设定，仅起到了方便Jupyter使用者管理必要文件的易用性，不能阻挡用户访问和管理工作空间外的文件系统。另外，配合使用Python虚拟环境，可以防止Jupyter Notebook提供的 pip install ,pip uninstall功能，对现有项目环境造成破坏。&lt;/p&gt;

&lt;p&gt;在多人协作方面，JupyterHub项目提供了多人协作Jupyter Notebook和Jupyter lab开发的能力。使用JupyterHub,不同职能的用户可以在自己独立的空间内进行Notebook的编写工作，不同用户间也可以方便地分享各自的Notebook。&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;7. 扩展Jupyter&lt;/strong&gt;&lt;/h1&gt;

&lt;h2&gt;&lt;strong&gt;7.1. 前端扩展&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Jupyter Notebook前端扩展(front end extension)是使用Javascript语言编写的异步模块，可以用来绘制Jupyter界面的仪表盘，Notebook，工具栏等，。定义一个前端扩展必须要实现一个load_ipython_extension方法，当前端控件被加载时，Jupyter client会调用load_ipython_extension方法。&lt;/p&gt;

&lt;p&gt;Jupyter Notebook前端扩展能力目前还不是一个稳定的版本，不保证代码能够向后兼容。Jupyter的JS API目前也没有官方的文档，需要通过源代码或者实际加载的JS来查看Jupyter前端脚本的成员和方法。&lt;/p&gt;

&lt;p&gt;我们实现一个简单的前端扩展脚本，在jupyter前端的工具条中，添加一个自定义工具，当点击自定义工具时，弹出提示信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([
    &#x27;base/js/namespace&#x27;
], function(
    Jupyter
) {
    function load_ipython_extension() {

        var handler = function () {
            alert(&#x27;欢迎使用前端扩展!&#x27;);
        };

        var action = {
            icon: &#x27;fa-comment-o&#x27;,
            help    : &#x27;前端扩展&#x27;,
            help_index : &#x27;zz&#x27;,
            handler : handler
        };
        var prefix = &#x27;my_extension&#x27;;
        var action_name = &#x27;show-alert&#x27;;

        var full_action_name = Jupyter.actions.register(action, action_name, prefix); // returns &#x27;my_extension:show-alert&#x27;
        Jupyter.toolbar.add_buttons_group([full_action_name]);
    }

    return {
        load_ipython_extension: load_ipython_extension
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完前端扩展代码后，我们把脚本保存到main.js文件，放置在/opt/my_extension目录下。接下来我们使用jupyter nbextension工具来安装和启用前端扩展&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 安装前端扩展
jupyter nbextension install /opt/my_extension
# 启用前端扩展
jupyter nbextension enable my_extension/main
# 禁用前端扩展
jupyter nbextension disable my_extension/main
# 查看前端扩展列表
jupyter nbextension list
# 卸载前端扩展
jupyter nbextension uninstall my_extension
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e21b3ef928244ba2850af8ca0e211a00%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图9 在Notebook工具条中加入的前端扩展&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;7.2. 服务端扩展&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Jupyter服务端扩展（server extension）是使用Python语言编写的模块，可以用来处理发送到Jupyter Server的Http请求。使用Jupyter服务端扩展，可以更改现有Jupyter请求的数据和行为，也可以为jupyter Server定义新的服务处理程序。&lt;/p&gt;

&lt;p&gt;定义一个服务端扩展模块要实现一个load_jupyter_server_extension方法，其中包含一个类型为notebook.notebookapp.NotebookApp的参数serverapp，serverapp的详细属性和方法可以通过Jupyter Notebook源代码中的notebookapp.py文件来查看。当服务端扩展被加载时，Jupyter Server会调用load_jupyter_server_extension方法。在load_jupyter_server_extension方法中，我们可以通过调用serverapp的web_app属性的add_handlers方法来注册处理程序，用来处理特定的服务端请求。处理程序类需要继承自Jupyter的IPythonHandler类。在处理程序的方法中，可以使用Jupyter提供的@web.authenticated装饰器来为方法增加身份认证保护。&lt;/p&gt;

&lt;p&gt;通过服务端扩展，还可以与前端扩展联动，实现一个功能丰富的Jupyter Notebook前端控件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 定义一个处理程序
from tornado import (
    gen, web,
)
from notebook.base.handlers import IPythonHandler

class HelloWorldHandler(IPythonHandler):
    @web.authenticated
    @gen.coroutine
    def get(self):
        self.finish(f&#x27;Hello, world!&#x27;)


# 实现load_jupyter_server_extension方法并注册处理程序
def load_jupyter_server_extension(serverapp):
    handlers = [
        (&#x27;/myextension/hello&#x27;, HelloWorldHandler)
    ]
    serverapp.web_app.add_handlers(&#x27;.*$&#x27;, handlers)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成服务端扩展代码后，我们把代码保存为&lt;strong&gt;init&lt;/strong&gt;.py文件，要在Jupyter Notebook中使用处理程序，我们还需要进行服务端扩展的安装和启用。不同于前端扩展，服务端扩展不能直接使用指令来安装，需要我们手动编写安装程序。此外，Jupyter提供了自动启用服务端扩展和前端扩展的方法，需要我们在脚本的根目录提供启用扩展的配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jupyter-config/
├── jupyter_notebook_config.d/
│   └── my_server_extension.json
└── nbconfig/
    └── notebook.d/
        └── my_front_extension.json
 setup.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入了自动启用扩展的配置，我们的服务端扩展目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hello-extension/
├── __init__.py
jupyter-config/
├── jupyter_notebook_config.d/
    └── hello_extension.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hello_extension.json文件的内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;ServerApp&quot;: {
        &quot;jpserver_extensions&quot;: {
            &quot;hello_extension&quot;: true
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们通过安装程序，安装服务端扩展的信息保存在/root/.jupyter/jupyter_notebook_config.json文件中。在安装完成后，我们可以通过jupyter serverextesion工具来股那里服务端扩展&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 启用服务端扩展
jupyter serverextension enable hello_extension
# 禁用服务端扩展
jupyter serverextension disable hello_extension

# 服务端扩展直接卸载的方法，需要我们通过pip uninstall 卸载安装程序，
# 再通过手工修改/root/.jupyter/jupyter_notebook_config.json文件删除扩展信息来完成卸载
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7b8f85d24fe41429b6993f5ab81e8fb%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图10 在浏览器中测试安装的服务端扩展程序&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;7.3. 界面定制&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Jupyter没有提供标准的界面定制的能力，但我们可以手工调整jupyter生成的模板视图文件和样式文件，达到整条调整jupyter notebook的界面的能力。&lt;/p&gt;

&lt;p&gt;Jupyter Notebook模板文件的位置为：$notebook/templates，样式和脚本定制推荐的方案是使用~/.jupyter/custom/custom.css和~/.jupyter/custom/custom.js文件。我们可以直接在此基础上对文件进行修改，还可以通过extra_template_paths和extra_static_paths来引入其它位置的模板和其它静态文件。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/377c4bbb3ac5442c8130ac671dbfca89%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图11 通过直接调整模板文件加入的界面定制按钮&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;7.4. 小部件&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;小部件（Widgets）是Jupyter交互式可视化数据呈现部件。Jupyter Widgets同时包含了访问后端数据和前端呈现的能力，可以用于在Jupyter Notebook上生动地展示服务端的数据和数据变化。&lt;/p&gt;

&lt;p&gt;在v6.5.2稳定版本上，我们目前只能使用系统提供的小部件，还不能开发自定义小部件。在Jupyter notebook7.x版本中，开始提供了小部件的自定义开发能力。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 确保安装了ipywidgets和traitlets
pip install --upgrade traitlets
pip install --upgrade ipywidgets

# 安装和启用小部件
jupyter nbextension install --py widgetsnbextension
jupyter nbextension enable --py widgetsnbextension
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在安装和启用了小部件后，我们可以在notebook中直接使用系统提供的小部件。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63ca91d9bc4d477598c5b294e1cd15f2%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图12 在Notebook中使用小部件&lt;/p&gt;

&lt;p&gt;完整的小部件列表和使用方式可以参考： &lt;a href=&quot;https://ipywidgets.readthedocs.io/en/7.x/examples/Widget%20List.html&quot;&gt;https://ipywidgets.readthedocs.io/en/7.x/examples/Widget%20List.html&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;8. 总结&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Jupyter Notebook以其丰富的功能，简单易用，强大的交互能力和扩展能力，成为数据科学和机器学习开发中的神器。目前，Jupyter Notebook支持超过40种编程语言，被应用于Google Colab, Kubeflow, 华为云，kaggle等多个知名项目中，大量机器学习和数据科学的论文中使用到了Jupyter。Jupyter在数据可视化，提升工作效率，改善用户体验和丰富文档功能方面显现了巨大的威力。除此之外，Jupyter还提供的灵活强大的扩展能力，更是为Jupyter的深层次使用提供了更广阔的想象空间。如果你还没有开始接触Jupyter，那么就从现在开始吧。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1cf7296baf50908af9059b42426439af</guid>
<title>什么是 Istio ？Istio 是用来做什么的？可以代替 Spring Cloud 吗？</title>
<link>https://toutiao.io/k/won00pk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-4em6pe&quot; options=&quot;[object Object]&quot;&gt;&lt;blockquote data-first-child=&quot;&quot; data-pid=&quot;_Da6VmTL&quot;&gt;北京时间2月23日，在全球首届社区峰会IstioCon 2021中，华为云应用服务网格首席架构师张超盟发表了《Best practice:from Spring Cloud to Istio》主题演讲，分享了Istio在生产中使用的实际案例。&lt;br/&gt;官网链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//events.istio.io/istiocon-2021/sessions/best-practice%25EF%25BC%259Afrom-spring-cloud-to-istio/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;events.istio.io/istioco&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;n-2021/sessions/best-practice%EF%BC%9Afrom-spring-cloud-to-istio/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;以下为演讲全文&lt;/blockquote&gt;&lt;p data-pid=&quot;QGx8pc28&quot;&gt;大家好，我是来自华为云的工程师。很荣幸有机会和大家分享Istio在生产中使用的实际案例。&lt;/p&gt;&lt;p data-pid=&quot;a8l3rG6k&quot;&gt;华为云应用服务网格从2018年在公有云上线， 作为全球最早的几个网格服务之一，经历和见证了从早期对网格的了解、尝试到当前大规模使用的过程。服务的客户越来越多，场景也越来越复杂。这其中的通用功能作为feature大都贡献到Istio社区，解决方案层面的实践也希望通过这样的机会和大家交流。&lt;/p&gt;&lt;p data-pid=&quot;EDqNk4qM&quot;&gt;本次我选取的主题是Spring Cloud to Istio。来自我们客户的Spring cloud的项目和Istio的结合与迁移案例。&lt;/p&gt;&lt;p data-pid=&quot;jm2hAto0&quot;&gt;&lt;b&gt;演讲主要包含四部分的内容：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;uvS12tH4&quot;&gt;1）背景介绍&lt;/p&gt;&lt;p data-pid=&quot;JbbOq0b9&quot;&gt;2）使用Spring cloud微服务框架遇到的问题&lt;/p&gt;&lt;p data-pid=&quot;67Hwkk-E&quot;&gt;3）解决方案&lt;/p&gt;&lt;p data-pid=&quot;PLhrPMiH&quot;&gt;4）通过示例来描述方案的实践细节&lt;/p&gt;&lt;p data-pid=&quot;TvEMVuM9&quot;&gt;相关文章推荐：&lt;/p&gt;&lt;h2&gt;背景介绍&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3b0d5f37df01a526eeefb37905f576ff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-3b0d5f37df01a526eeefb37905f576ff_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-3b0d5f37df01a526eeefb37905f576ff_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3b0d5f37df01a526eeefb37905f576ff_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;yyNqkmkN&quot;&gt;还是以微服务为切入点，微服务的诸多优势非常明显，但相应给整个系统带来的复杂度也非常显著。单体的系统变成了分布式后，网络问题，服务如何找到并访问到对端的服务发现问题，网络访问的容错保护问题等。连当年最简单的通过日志中的调用栈就能实现的问题定位，微服务化后必须要通过分布式调用链才能支持。怎样解决微服务带来的这些挑战？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9b0aea69666b26afda11689d634493c9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;610&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-9b0aea69666b26afda11689d634493c9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;610&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-9b0aea69666b26afda11689d634493c9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9b0aea69666b26afda11689d634493c9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Zakr2OcJ&quot;&gt;微服务SDK曾经是一个常用的解决方案。将微服务化后通用的能力封装在一个开发框架中，开发者使用这个框架开发写自己的业务代码，生成的微服务自然就内置了这些能力。在很长的一段时间内，这种形态是微服务治理的标配，以至于初学者以为只有这些SDK才是微服务。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9a19501df58110a0890eaabf82cdcf0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;603&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-9a19501df58110a0890eaabf82cdcf0a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;603&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-9a19501df58110a0890eaabf82cdcf0a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9a19501df58110a0890eaabf82cdcf0a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;7imVlHRn&quot;&gt;服务网格则通过另一种形态提供治理能力。不同于SDK方式，服务治理的能力在一个独立的代理进程中提供，完全和开发解耦。虽然从图上看两者差异非常小，后面我们将会从架构和实际案例来分析两者在设计理念上的差异，来体会前者是一个开发框架，而后者是一个基础设施。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f3887b9d075b8ce169f7e01652818b67_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-f3887b9d075b8ce169f7e01652818b67_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-f3887b9d075b8ce169f7e01652818b67_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-f3887b9d075b8ce169f7e01652818b67_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;nqGk5or6&quot;&gt;SDK形态中Spring cloud是最有影响力的代表项目。Spring cloud提供了构建分布式应用的开发工具集，如列表所示。其中被大部分开发者熟知的是微服务相关项目，如：服务注册发现eureka、配置管理 config、负载均衡ribbon、熔断容错Hystrix、调用链埋点sleuth、网关zuul或Spring cloud gateway等项目。在本次分享中提到的Spring cloud也特指Spring cloud的微服务开发套件。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c1748daf404cd785afcc16fb0b440c69_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;602&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c1748daf404cd785afcc16fb0b440c69_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;602&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c1748daf404cd785afcc16fb0b440c69_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c1748daf404cd785afcc16fb0b440c69_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;F1bQwTZd&quot;&gt;而网格形态中，最有影响力的项目当属Istio。Istio的这张架构图在这次演讲中会高频出现。作为本次分享的背景，我们只要知道架构上由控制面和数据面组成，控制面管理网格里面的服务和对服务配置的各种规则。数据面上每个服务间的出流量和入流量都会被和服务同POD的数据面代理拦截和执行流量管理的动作。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d81a93b744db85015a5b16472c12021b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-d81a93b744db85015a5b16472c12021b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-d81a93b744db85015a5b16472c12021b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d81a93b744db85015a5b16472c12021b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;dFVt6Y-W&quot;&gt;除了架构外，作为背景的另外一个部分，我们挑两个基础功能稍微打开看下两者的设计和实现上的相同和不同。首先是服务发现和负载均衡。&lt;/p&gt;&lt;p data-pid=&quot;R5KTFbad&quot;&gt;左边是Spring cloud，所有的微服务都会先注册中心，一般是Eureka进行服务注册，然后在服务访问时，consumer去注册中心进行服务发现得到待访问的目标服务的实例列表，使用客户端负载均衡ribbon选择一个服务实例发起访问。&lt;/p&gt;&lt;p data-pid=&quot;AaAp7iEH&quot;&gt;右边Istio不需要服务注册的过程，只需要从运行平台k8s中获取服务和实例的关系，在服务访问时，数据面代理Envoy拦截到流量，选择一个目标实例发送请求。可以看到都是基于服务发现数据进行客户端负载均衡，差别是服务发现数据来源不同，负载均衡的执行体不同。&lt;/p&gt;&lt;p data-pid=&quot;4htdg_1s&quot;&gt;&lt;b&gt;下面比较下熔断：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-00ac848e45d051e9ed0104526397c35b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-00ac848e45d051e9ed0104526397c35b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-00ac848e45d051e9ed0104526397c35b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-00ac848e45d051e9ed0104526397c35b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;rWngFs5m&quot;&gt;左边为经典的Hystrix的状态迁移图。一段时间内实例连续的错误次数超过阈值则进入熔断开启状态，不接受请求；隔离一段时间后，会从熔断状态迁移到半熔断状态，如果正常则进入熔断关闭状态，可以接收请求；如果不正常则还是进入熔断开启状态。&lt;/p&gt;&lt;p data-pid=&quot;svaxKLb_&quot;&gt;Istio中虽然没有显示的提供这样一个状态图，但是大家熟悉Istio规则和行为应该会发现，Istio中OutlierDection的阈值规则也都是这样设计的。两者的不同是Spring cloud的熔断是在SDK中Hystrix执行，Istio中是数据面proxy执行。Hystrix因为在业务代码中，允许用户通过编程做一些控制。&lt;/p&gt;&lt;p data-pid=&quot;ILIzCBiR&quot;&gt;以上分析可以看到服务发现、负载均衡和熔断，能力和机制都是类似的。如果忽略图上的某些细节，粗的看框图模型都是完全一样的，对比表格中也一般只有一项就是执行位置不同，这一点不同在实际应用中带来非常大的差异。&lt;/p&gt;&lt;h2&gt;使用Spring cloud微服务框架遇到的问题&lt;/h2&gt;&lt;p data-pid=&quot;pa1-0p55&quot;&gt;本次演讲的重点是实践。以下是我们客户找到我们TOP的几个的问题，剖析下用户使用传统微服务框架碰到了哪些问题，这些大部分也是他们选择网格的最大动力。&lt;/p&gt;&lt;p data-pid=&quot;XOTb2FxB&quot;&gt;&lt;b&gt;1）多语言问题&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-97aa11b8f8e62831883ecb818fa2c458_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-97aa11b8f8e62831883ecb818fa2c458_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-97aa11b8f8e62831883ecb818fa2c458_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-97aa11b8f8e62831883ecb818fa2c458_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;54IRKIUz&quot;&gt;在企业应用开发下，一个业务使用统一的开发框架是非常合理常见的，很多开发团队为了提升效率，经常还会维护有自己公司或者团队的通用开发框架。当然因为大部分业务系统都是基于Java开发，所以Spring cloud开发框架，或者衍生于Spring cloud的各种开发框架使用的尤其广泛。&lt;/p&gt;&lt;p data-pid=&quot;K0nE4Gd9&quot;&gt;但是在云原生场景下，业务一般更加复杂多样，特别是涉及到很多即存的老系统。我们不能要求为了微服务化将在用的一组成熟服务用Spring cloud重写下。用户非常希望有一种方式不重写原来的系统也能对其进行应用层服务访问管理。&lt;/p&gt;&lt;p data-pid=&quot;p9I7CtXL&quot;&gt;&lt;b&gt;2）将Spring cloud的微服务运行在K8s上会有很大的概率出现服务发现不及时&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-951426814487a341585dc708e00e0048_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-951426814487a341585dc708e00e0048_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-951426814487a341585dc708e00e0048_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-951426814487a341585dc708e00e0048_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;gen-uIWp&quot;&gt;前面介绍过Spring cloud服务发现是基于各个微服务先向注册中心进行服务注册的数据来实现的，在传统Spring cloud场景下，当微服务部署在VM上，服务动态变化要求没有那么高，顶多个别实例运行不正常，通过服务发现的健康检查就足够了。但是在k8s场景下，服务实例动态迁移是非常正常场景。如图示，producer的某个Pod已经从一个节点迁移到另外一个节点了，这时需要新的pod2的producer实例向eureka注册，老实例Pod1要去注册。&lt;/p&gt;&lt;p data-pid=&quot;G2w3ZN4m&quot;&gt;如果该情况频繁发生，会出现注册中心数据维护不及时，导致服务发现和负载均衡到旧的实例pod1上，从而引起访问失败的情况。&lt;/p&gt;&lt;p data-pid=&quot;Akfhya99&quot;&gt;&lt;b&gt;3）升级所有应用以应对服务管理需求变化&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c04a3fda1687eb470ad0e128b35b5040_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-c04a3fda1687eb470ad0e128b35b5040_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-c04a3fda1687eb470ad0e128b35b5040_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c04a3fda1687eb470ad0e128b35b5040_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Q5cZ6ebP&quot;&gt;第三个问题是一个比较典型的问题。客户有一个公共团队专门维护了一套基于Spring cloud的自有开发框架，在每次升级开发框架时，不得不求着业务团队来升级自己的服务。经常会SDK自身修改测试工作量不大，但却要制定很长周期的升级计划，来对上千个基于这个SDK开发的服务分组重新编译，打包，升级，而且经常要陪着业务团队在夜间变更。业务团队因为自身没有什么改动，考虑到这个升级带来的工作量和线上风险，一般也没有什么动力。&lt;/p&gt;&lt;p data-pid=&quot;aOeCxLhg&quot;&gt;&lt;b&gt;4）从单体式架构向微服务架构迁移&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c73c99145c6f4e907b562c037e759d5d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;600&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c73c99145c6f4e907b562c037e759d5d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;600&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c73c99145c6f4e907b562c037e759d5d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c73c99145c6f4e907b562c037e759d5d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;eGvfhJZL&quot;&gt;这是一个比较普遍的问题，就是渐进的微服务化。马丁福勒在著名的文章单体到微服务的拆分中（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//martinfowler.com/articles/break-monolith-into-microservices.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;martinfowler.com/articl&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;es/break-monolith-into-microservices.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; ）也提到了对渐进微服务化的倡议，如何能从业务上将一个大的业务分割，解耦，然后逐步微服务化。马丁福勒强调 “解耦的是业务能力不是代码” ，大神将代码的解耦留给了开发者。&lt;/p&gt;&lt;p data-pid=&quot;y1hQhXBU&quot;&gt;但是站在开发者的角度讲渐进的微服务不是一个容易的事情。以基于Spring cloud框架进行微服务开发为例，为了所有的微服务间进行统一的服务发现、负载均衡，消费和执行同样的治理策略，必须要求所有的微服务基于同样的，甚至是统一版本的SDK来开发。&lt;/p&gt;&lt;p data-pid=&quot;qZl_8C9B&quot;&gt;当然我们客户在这种情况下也有基于API层面做适配，将原有的未微服务化的和已微服务化的并存，使用这种类似于灰度方式，实际操作非常麻烦。&lt;/p&gt;&lt;p data-pid=&quot;olmWD_JA&quot;&gt;曾经有客户问过有没有不用费劲搞两套，是否可以直接有些大的单体微服务化，另外一些单体很长时间内完全不动，直到有时间或者认为安全想动它的时候去动。&lt;/p&gt;&lt;h2&gt;解决方案&lt;/h2&gt;&lt;p data-pid=&quot;CNY3Lph0&quot;&gt;对于客户实际碰到的4个典型的微服务框架的问题，我们推荐的解决方案都是服务网格。下面我们分别看下Istio如何解决上面的几个问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4f019812c7a389677676dceb60c9aab1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;603&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-4f019812c7a389677676dceb60c9aab1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;603&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-4f019812c7a389677676dceb60c9aab1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4f019812c7a389677676dceb60c9aab1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;cndRpxzl&quot;&gt;首先，多语言问题。基于服务网格，业务和治理的数据面无需运行在同一个进程里，也无需一起编译，因此也没有语言和框架上的绑定。无论什么语言开发的服务，只要有一个对外可以被访问和管理的一定应用协议上的端口，都可以被网格进行管理。通过统一的网格控制面，下发统一的治理规则给统一的网格数据面执行，进行统一的治理动作，包括前面介绍到的灰度、流量、安全、可观察性等等。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ebd98685ce7efeb0e259961c9d4f79cd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-ebd98685ce7efeb0e259961c9d4f79cd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-ebd98685ce7efeb0e259961c9d4f79cd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ebd98685ce7efeb0e259961c9d4f79cd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;yE32rQWr&quot;&gt;关于Spring cloud服务在Kubernetes运行时，关于原有的服务注册和发现不及时的问题。根本原因是两套服务发现导致的不一致问题，那么解决办法也比较简单，统一服务发现即可。既然K8s已经在Pod调度的同时维护有服务和实例间的数据，那么就没有必要再单独搞一套名字服务的机制，还要费劲的进行服务注册，然后再发现。&lt;/p&gt;&lt;p data-pid=&quot;Uc4i1XCk&quot;&gt;比较之前Spring cloud注册发现那张图，注册中心没了，服务基于注册中心的服务注册和服务发现的动作也不需要了，Istio直接使用k8s的服务发现数据，但从架构上看也简洁很多。&lt;/p&gt;&lt;p data-pid=&quot;35THFZL1&quot;&gt;我们也总结过，大部分碰到这个问题的场景，都是将微服务框架从VM迁移到k8s时候碰到的，有点把容器当作之前的VM使用，只使用了k8s作为容器部署运行的平台，并没有用到k8s的service。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fc070e261413734c69f855c3b317083c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;608&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fc070e261413734c69f855c3b317083c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;608&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fc070e261413734c69f855c3b317083c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fc070e261413734c69f855c3b317083c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;RC2wRo6V&quot;&gt;对于SDK自身升级导致业务全部重新升级的问题，解决办法就是把服务治理的公共能力和业务解耦。在网格中，将治理能力下沉到基础设施后，业务的开发、部署、升级都和服务治理的基础设施解耦了。业务开发者专注自己的业务部分。只要没有修改业务代码，就无需重新编译和上线变更。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;LXVYLGBL&quot;&gt;当治理能力升级只需基础设施升级即可，基础设施的升级对用户业务完全没有影响。像华为云ASM这样大部分网格服务的服务提供商都能做到一键升级，用户完全感知不到这个过程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1dcdf756e8cb760f3d08820a2672e8e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;605&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-1dcdf756e8cb760f3d08820a2672e8e0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;605&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-1dcdf756e8cb760f3d08820a2672e8e0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-1dcdf756e8cb760f3d08820a2672e8e0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;lZLuoUf1&quot;&gt;关于渐进微服务化的问题，使用Isito服务网格可以非常完美的解决。Istio治理的是服务间的访问，只要一个服务被其他服务访问，就可以通过Istio来进行管理，不管是微服务还是单体。Istio接管了服务的流量后，单体和微服务都可以接收统一的规则进行统一的管理。&lt;/p&gt;&lt;p data-pid=&quot;oIkPNum4&quot;&gt;如图中，在微服务化的过程中，可以对某个单体应用svc1根据业务拆分优先进行微服务化，拆分成三个微服务svc11、svc12和svc13，svc1服务依赖的另外一个单体应用svc2不用做任何变更，在网格中运行起来就可以和另外三个微服务一样的被管理。同样在运行一段时间后，svc2服务可以根据自身的业务需要再进行微服务化。从而尽量避免一次大的重构带来的工作量和业务迁移的风险，真正做到马丁富勒倡导的渐进微服务化的实践。&lt;/p&gt;&lt;h2&gt;实践&lt;/h2&gt;&lt;p data-pid=&quot;aoUkgXO-&quot;&gt;以上是对实际工作中客户的几个典型问题的解决方案。在实践中，怎么把这些解决方案落地呢？下面基于实际客户案例总结，分享具体的实践。&lt;/p&gt;&lt;p data-pid=&quot;3V01oVyS&quot;&gt;我们的主要是思路是解耦和卸载。卸载原有SDK中非开发的功能，SDK只提供代码框架、应用协议等开发功能。涉及到微服务治理的内容都卸载到基础设施去做。&lt;/p&gt;&lt;p data-pid=&quot;ZpfcHF8t&quot;&gt;从图上可以看到开发人员接触到开发框架变薄了，开发人员的学习、使用和维护成本也相应的降低了。而基础设施变得厚重了，除了完成之前需要做的服务运行的基础能力外，还包括非侵入的服务治理能力。即将越来越多的之前认为是业务的能力提炼成通用能力，交给基础设施去做，交给云厂商去做，客户摆脱这些繁琐的非业务的事务，更多的时间和精力投入到业务的创新和开发上。在这种分工下，SDK才真的回归到开发框架的根本职能。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-712d8d29b693ac53146a070158a2cabc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-712d8d29b693ac53146a070158a2cabc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-712d8d29b693ac53146a070158a2cabc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-712d8d29b693ac53146a070158a2cabc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;sujmLmVK&quot;&gt;要使用网格的能力，前提是微服务出来的流量能走到网格的数据面来。主要的迁移工作在微服务的服务调用方。我们推荐3个步骤：&lt;/p&gt;&lt;p data-pid=&quot;Hj0dXTKg&quot;&gt;第一步：废弃原有的微服务注册中心，使用K8S的Service。&lt;/p&gt;&lt;p data-pid=&quot;BdXAmYxl&quot;&gt;第二步：短路SDK中服务发现和负载均衡等逻辑，直接使用k8s的服务名和端口访问目标服务；&lt;/p&gt;&lt;p data-pid=&quot;IJt7BGF7&quot;&gt;第三步：结合自身项目需要，逐步使用网格中的治理能力替换原有SDK中提供的对应功能，当然这步是可选的，如调用链埋点等原有功能使用满足要求，也可以作为应用自身功能保留。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c5494751a3ed3caab036a27120dd9f59_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c5494751a3ed3caab036a27120dd9f59_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c5494751a3ed3caab036a27120dd9f59_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c5494751a3ed3caab036a27120dd9f59_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;p6O1FyKu&quot;&gt;为了达成以上迁移，我们有两种方式，供不同的用户场景采用。&lt;/p&gt;&lt;p data-pid=&quot;nEb2nIj0&quot;&gt;一种是只修改配置的方式：Spring cloud本身除了支持基于Eureka的服务端的服务发现外，还可以给Ribbon配置静态服务实例地址。利用这种机制给对应微服务的后端实例地址中配置服务的Kubernetes服务名和端口。&lt;/p&gt;&lt;p data-pid=&quot;hyCWbp8e&quot;&gt;当Spring cloud框架中还是访问原有的服务端微服务名时，会将请求转发到k8s的服务和端口上。这样访问会被网格数据面拦截，从而走到网格数据面上来。服务发现负载均衡和各种流量规则都可以应用网格的能力。&lt;/p&gt;&lt;p data-pid=&quot;l7d4jItf&quot;&gt;这种方式其实是用最小的修改将SDK的访问链路和网格数据面的访问链路串接起来。在平台中使用时，可以借助流水线工具辅助，减少直接修改配置文件的工作量和操作错误。可以看到我这个实际项目中，只是修改了项目的application.yaml配置文件，其他代码都是0修改。当然对于基于annotation的方式的配置也是同样的语义修改即可。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-422e9d035f000daafcf2e2ff66a133fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-422e9d035f000daafcf2e2ff66a133fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-422e9d035f000daafcf2e2ff66a133fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-422e9d035f000daafcf2e2ff66a133fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;0O89ywD-&quot;&gt;前面一种方式对原有项目的修改比较少，但是Spring cloud的项目依赖都还在。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;21FI_sBV&quot;&gt;我们有些客户选择了另外一种更简单直接的方式，既然原有SDK中服务发现负载均衡包括各种服务治理能力都不需要了，干脆这些依赖也全部干掉。从最终的镜像大小看，整个项目的体量也得到了极大的瘦身。这种方式客户根据自己的实际使用方式，进行各种裁剪，最终大部分是把Spring cloud退化成Spring boot。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6694ec5f96ccca66c51aba0cc383adbe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;605&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-6694ec5f96ccca66c51aba0cc383adbe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;605&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-6694ec5f96ccca66c51aba0cc383adbe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-6694ec5f96ccca66c51aba0cc383adbe_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;iuoU9oxg&quot;&gt;迁移中还有另外一部分比较特殊，就是微服务外部访问的Gateway。&lt;/p&gt;&lt;p data-pid=&quot;c_SrxeJt&quot;&gt;Spring cloud 有两种功能类似的Gateway，Zuul和Spring cloud Gateway。基于Eureka的服务发现，将内部微服务映射成外部服务，并且在入口处提供安全、分流等能力。在切换到k8s和Istio上来时，和内部服务一样，将入口各个服务的服务发现迁移到k8s上来。&lt;/p&gt;&lt;p data-pid=&quot;fseVma2Q&quot;&gt;差别在于对于用户如果在Gateway上开发了很多私有的业务强相关的filter时，这时候Gateway其实是微服务的门面服务，为了业务延续性，方案上可以直接将其当成普通的微服务部署在网格中进行管理。&lt;/p&gt;&lt;p data-pid=&quot;sTW0_RfR&quot;&gt;但是大多数情况下我们推荐使用Istio的Ingress Gateway直接替换这个微服务网关，以非侵入的方式提供外部TLS终止、限流、流量切分等能力。&lt;/p&gt;&lt;p data-pid=&quot;rVRuAJKk&quot;&gt;经过以上的简单改造，各种不同语言、各种不同开发框架开发的服务，只要业务协议相通，彼此可以互相访问，访问协议可以被网格管理，就都可以通过Istio进行统一的管理。&lt;/p&gt;&lt;p data-pid=&quot;of-rpWQO&quot;&gt;控制面上可以配置统一的服务管理规则。数据面上，统一使用Envoy进行服务发现、负载均衡和其他流量、安全、可观察性等相关能力。数据面上的服务即可以运行在容器里，也可以运行在虚机上。并且可以运行在多个k8s集群中。&lt;/p&gt;&lt;p data-pid=&quot;bfAau_OP&quot;&gt;当然在迁移过程中间，我们也支持阶段性的保留原有微服务框架的注册中心，使Istio和其他的服务发现结合使用的中间状态，让网格中的服务可以访问到微服务注册中心的服务。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4ea3467be07de85e52f53f41da1d9e85_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;605&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-4ea3467be07de85e52f53f41da1d9e85_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;605&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-4ea3467be07de85e52f53f41da1d9e85_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4ea3467be07de85e52f53f41da1d9e85_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;9_VX9lPa&quot;&gt;这里是一个Spring cloud开发的服务运行在Istio服务网格上进行灰度发布的示例。上面的日志是服务调用方Sidecar的日志，可以看到网格将流量分发到不同的服务后端上。下面的截图是使用了华为云ASM服务的灰度功能，可以看到这个Spring cloud服务通过网格配置的分流策略，将30%的流量分发到灰度版本上。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3b4adfa35d9a914d6a13315cd4b1c575_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-3b4adfa35d9a914d6a13315cd4b1c575_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-3b4adfa35d9a914d6a13315cd4b1c575_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3b4adfa35d9a914d6a13315cd4b1c575_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;tnrHEC3H&quot;&gt;下面这个示例是Spring cloud开发的服务使用Istio的熔断功能。这个过程就是就是前面原理一节Hystrix的状态迁移图的实践，不同在于这个实现是基于Istio来实现的。基于服务网格不管这里的服务是什么语言或者框架开发的，都可以对访问进行熔断保护。&lt;/p&gt;&lt;p data-pid=&quot;lqqowbNm&quot;&gt;这里的效果截图是来自华为云应用服务网格ASM的应用拓扑，可以非常清新的看到服务级别、服务实例级别流量变化情况，服务和服务实例的健康状态，从而展示故障的Spring cloud实例被隔离的全过程。从拓扑图上可以看到有个实例异常满足熔断阈值，触发了熔断，网格数据面向这个故障实例上分发的流量逐渐减少，直到完全没有流量，即故障实例被隔离。通过这种熔断保护保障服务整体访问的成功率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-422d6fb7e9790702d02915c79a5c80fe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-422d6fb7e9790702d02915c79a5c80fe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-422d6fb7e9790702d02915c79a5c80fe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-422d6fb7e9790702d02915c79a5c80fe_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;wUnCw6Z5&quot;&gt;下面三个流量拓扑演示了故障恢复的过程。&lt;/p&gt;&lt;p data-pid=&quot;Jc73vx2H&quot;&gt;可以看到：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;Uq1P31QP&quot;&gt;初始状态这个故障实例被隔离中，没有流量；&lt;/li&gt;&lt;li data-pid=&quot;nxqqyYiv&quot;&gt;当实例自身正常后，网格数据面在将其隔离配置的间隔后，重新尝试给其分配流量，当满足阈值要求则该实例会被认为是正常实例，可以和其他两个实例一样接收请求。&lt;/li&gt;&lt;li data-pid=&quot;BtRKNZBH&quot;&gt;最终可以看到三个实例上均衡的处理请求。&lt;br/&gt;即实现了故障恢复。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;xRr4Njp_&quot;&gt;&lt;b&gt;最后，通过微服务、容器、k8s和Istio的关系图来总结今天的内容：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f521a1178b34d50f14ed17af2ab44d2c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f521a1178b34d50f14ed17af2ab44d2c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f521a1178b34d50f14ed17af2ab44d2c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f521a1178b34d50f14ed17af2ab44d2c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;RVSkoZJS&quot;&gt;1）微服务和容器都有轻量和敏捷的共同特点，容器是微服务非常适合的一个运行环境；&lt;/p&gt;&lt;p data-pid=&quot;Q7ypUGAJ&quot;&gt;2）在云原生场景下，在微服务场景下，容器从来都不是独立存在的，使用k8s来编排容器已经是一个事实标准；&lt;/p&gt;&lt;p data-pid=&quot;mTeXNwg4&quot;&gt;3）Istio和k8s在架构和应用场景上的紧密结合，一起提供了一个端到端的微服务运行和治理的平台。&lt;/p&gt;&lt;p data-pid=&quot;BKLXJar5&quot;&gt;4）也是我们推荐的方案，使用Istio进行微服务治理正在成为越来越多用户的技术选择。&lt;/p&gt;&lt;p data-pid=&quot;WSK3ru3r&quot;&gt;以上四个关系顺时针结合在一起为我们的解决方案构造一个完整的闭环。&lt;/p&gt;&lt;h2&gt;后记&lt;/h2&gt;&lt;p data-pid=&quot;DCZRDsnx&quot;&gt;自荐一个非常不错的 Java 教程类开源项目：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide&lt;/a&gt; ，目前这个项目在 Github 上收到了 125k+ 的 star。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-728fb636e52fe98ee24dd825f2149932_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1298&quot; data-rawheight=&quot;1206&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-728fb636e52fe98ee24dd825f2149932_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1298&quot; data-rawheight=&quot;1206&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-728fb636e52fe98ee24dd825f2149932_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-728fb636e52fe98ee24dd825f2149932_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;x3TMP6mg&quot;&gt;并且，这个项目还推出了一个 PDF 版本：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247486324%26idx%3D1%26sn%3De8b690ddaedabc486bd399310105aad3%26chksm%3Dcea244bff9d5cda9a627fa65235be09e7b089e92cf49c0eb0ceb35b39bbed86c1fab0125f5af%26token%3D1351080357%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;完结撒花！JavaGuide面试突击版来啦！&lt;/a&gt;。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0b7cfd4801ace2a4034102d62509ae46_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;679&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0b7cfd4801ace2a4034102d62509ae46_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;679&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0b7cfd4801ace2a4034102d62509ae46_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0b7cfd4801ace2a4034102d62509ae46_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>