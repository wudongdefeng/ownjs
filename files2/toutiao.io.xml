<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>08b96984840ba01b293f6672f70643ae</guid>
<title>​打造企业自己代码规范 IDEA 插件（中）</title>
<link>https://toutiao.io/k/i8p0zo4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一些基本概念&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在开始独立研发公司自己的代码规范检查规则之前，先介绍一些相关的基本概念。&lt;/span&gt;&lt;span&gt;阿里巴巴代码规范&lt;/span&gt;&lt;span&gt;&lt;span&gt;很多规则其实都是基于开源框架&lt;/span&gt;&lt;span&gt;PMD&lt;/span&gt;&lt;span&gt;进行的研发。&lt;/span&gt;&lt;span&gt;PMD&lt;/span&gt;&lt;span&gt;用官方的话语介绍来说：&lt;/span&gt;&lt;span&gt;PMD&lt;/span&gt;&lt;span&gt;是一个源代码分析器。它可以发现常见的编程缺陷，如未使用的变量、空&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;块、不必要的对象创建等。它支持多种语言。它可以用自定义规则进行扩展。它使用&lt;/span&gt;&lt;span&gt;JavaCC&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Antlr&lt;/span&gt;&lt;span&gt;将源文件解析为&lt;/span&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;抽象语法树（&lt;/span&gt;&lt;span&gt;AST&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;span&gt;），并对其运行规则以查找冲突。规则可以用&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;编写，也可以使用&lt;/span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;XPath&lt;/span&gt;&lt;span&gt;查询&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;。开源代码库：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;https://github.com/pmd/pmd&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里涉及到一个很关键的概念——&lt;span&gt;AST&lt;/span&gt;抽象语法树&lt;span&gt;(Abstract Syntax Tree)&lt;/span&gt;。&lt;span&gt;AST&lt;/span&gt;运用场景其实非常多，日常我们研发过程中错误提示、代码高亮、代码格式化、代码转译等等实现的基础都基于&lt;span&gt;AST&lt;/span&gt;。简单说，会通过词法分析和语法分析将代码转化成一种类似树样层次结构来进行描述，当然这种描述可以用&lt;span&gt;XML&lt;/span&gt;格式。文字描述比较抽象，不妨看一个“&lt;span&gt;hello world&lt;/span&gt;”的具体&lt;span&gt;AST&lt;/span&gt;语法树（&lt;span&gt;Java 1.8&lt;/span&gt;），这样就很容易进行理解了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5510388437217706&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/BBtdicYK9ribib7s84I52o58IDuQciafESIuZLNeN6KTJLe5aI0lalUf6Xku31gibZUH4W3LHWZyZErtwyHJ75uicjWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1107&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;另外一个概念&lt;/span&gt;&lt;span&gt;XPath &lt;/span&gt;&lt;span&gt;是一门在&lt;/span&gt;&lt;span&gt;XML &lt;/span&gt;&lt;span&gt;文档中查找信息的语言。本身和代码解析没有关系，但当&lt;/span&gt;&lt;span&gt;AST&lt;/span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;XML&lt;/span&gt;&lt;span&gt;格式描述时，&lt;/span&gt;&lt;span&gt;XPath&lt;/span&gt;&lt;span&gt;能够很好完成对相关节点进行查找。两者的结合就能进行违规代码的检查，这就是&lt;/span&gt;&lt;span&gt;XPath&lt;/span&gt;&lt;span&gt;规则代码规范检查基本原理。此外，与其配套的&lt;/span&gt;&lt;span&gt;PMD-Designer&lt;/span&gt;&lt;span&gt;规则可视化工具也很好用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;例如阿里巴巴代码规范中 &lt;/span&gt;&lt;span&gt;PackageNamingRule &lt;/span&gt;&lt;span&gt;就是非常典型的&lt;/span&gt;&lt;span&gt;XPath&lt;/span&gt;&lt;span&gt;规则。包名只能由小写字母、数字来组成，具体的&lt;/span&gt;&lt;span&gt;XPath&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; final &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; XPATH = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;//PackageDeclaration/Name&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;[not (matches(@Image, &#x27;^[a-z0-9]+(\\.[a-z][a-z0-9]*)*$&#x27;))]&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下面先写个规则的例子来感受下自定义规则具体的操作；从&lt;span&gt;检查代码中&lt;/span&gt;&lt;span&gt;System.out &lt;/span&gt;&lt;span&gt;类似的日志输出开始。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Example &lt;/span&gt;&lt;span&gt;：检查代码中&lt;/span&gt;&lt;span&gt;System.out &lt;/span&gt;&lt;span&gt;类似的日志输出。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤一，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;运用&lt;/span&gt;&lt;span&gt;PMD-Designer &lt;/span&gt;&lt;span&gt;来辅助编写具体&lt;/span&gt;&lt;span&gt;XPath&lt;/span&gt;&lt;span&gt;的检查规则；这个工具也可以验证各种代码写法下，规则是否都能起到很好的作用。最终&lt;/span&gt;&lt;span&gt;XPath &lt;/span&gt;&lt;span&gt;具体规则如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;//Name[starts-with(@Image, &#x27;System.out.print&#x27;) &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;or starts-with(@Image, &#x27;System.err.print&#x27;)]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5893501805054152&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/BBtdicYK9ribib7s84I52o58IDuQciafESIuMLg3nKkGdKczmJ1cxAwV6wM60yfDwdp0qeIHP3kNrbCic2icQfftZ8rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤二，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;新建一个具体的规则类，继承&lt;/span&gt;&lt;span&gt;AbstractXpathRule &lt;/span&gt;&lt;span&gt;；其中&lt;/span&gt;&lt;span&gt;AbstractXpathRule &lt;/span&gt;&lt;span&gt;&lt;span&gt;本身是继承&lt;/span&gt; &lt;span&gt;PMD &lt;/span&gt;&lt;span&gt;中 &lt;/span&gt;&lt;span&gt;XPathRule&lt;/span&gt;&lt;span&gt;，主要扩展了多语言的设计。详细如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;package com.alibaba.p3c.pmd.lang.java.rule.emo;  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;public class VoidSystemPrintRule extends AbstractXpathRule {  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    private static final String XPATH =  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &quot;//Name[starts-with(@Image, &#x27;System.out.print&#x27;)&quot;+ &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &quot;or starts-with(@Image, &#x27;System.err.print&#x27;)]&quot;;  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    public VoidSystemPrintRule() {  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        setXPath(XPATH);  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        setVersion(XPATH_2_0);  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    @Override  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    public void addViolation(Object data, Node node, String arg) {  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        ViolationUtils.addViolationWithPrecisePosition(this, node, data,  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                I18nResources.getMessage(&quot;java.naming.VoidSystemPrintRule.violation.msg&quot;, node.getImage()));  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤三,&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在&lt;span&gt;messages.xml &lt;/span&gt;和 &lt;span&gt;messages_en.xml &lt;/span&gt;分别添加检查出错后给出相关中英文提示。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;entry key=&quot;java.naming.VoidSystemPrintRule.violation.msg&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &amp;lt;![CDATA[程序中避免直接使用 System 对相关日志信息输出]]&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/entry&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;——&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;entry key=&quot;java.naming.VoidSystemPrintRule.violation.msg&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &amp;lt;![CDATA[Avoid using system print]]&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/entry&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤四,&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;新建&lt;/span&gt;&lt;span&gt;emo-common.xml &lt;/span&gt;&lt;span&gt;的规则集合，并将实现的规则配置进去。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;ruleset name=&quot;AlibabaJavaNaming&quot; xmlns=&quot;http://pmd.sourceforge.net/ruleset/2.0.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;xsi:schemaLocation=&quot;http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;description&amp;gt;EmoJavaCommonRule&amp;lt;/description&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;rule name=&quot;VoidSystemPrintRule&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;language=&quot;java&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;since=&quot;1.6&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;message=&quot;java.naming.VoidSystemPrintRule.violation.msg&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;class=&quot;com.alibaba.p3c.pmd.lang.java.rule.emo.VoidSystemPrintRule&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;priority&amp;gt;3&amp;lt;/priority&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;example&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &amp;lt;![CDATA[&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                System.out.println(message);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            ]]&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/rule&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/ruleset&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤五,&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;ali-pmd.xml &lt;/span&gt;&lt;span&gt;中引入我们新加的规则集合 &lt;/span&gt;&lt;span&gt;emo-common.xml&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;rule ref=&quot;rulesets/java/emo-common.xml&quot;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后运行下修改完的代码程序，效果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5171480144404332&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/BBtdicYK9ribib7s84I52o58IDuQciafESIu3bEllcPBLg4mMHxvL4MmVD0CK2aRk12cFh2WMZjzy28SA7Juvia6PWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6558265582655827&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/BBtdicYK9ribib7s84I52o58IDuQciafESIuXkbiaAt6NviaJxWKS7Z4kFYXjUUQjvlVQsed1YBwhhK7VBK0TXicGkickw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1107&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综述下关键点，代码规范检查基本原理可以基于&lt;span&gt;AST&lt;/span&gt;语法树来进行实现；&lt;span&gt;AST&lt;/span&gt;结合&lt;span&gt;Xpath&lt;/span&gt;可以方便进行相关规范规则的编写；通过 &lt;span&gt;PMD-Designer &lt;/span&gt;能可视化的帮助我们实现 &lt;span&gt;XPath &lt;/span&gt;的相关代码规范规则以及验证相关规则；给出了一个例子，基于阿里开源代码规范插件源码，编写适用自己公司的代码规范的方式。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;附上相关代码github链接：https://github.com/ariesfly/emo-coding-guardian&lt;/span&gt;&lt;/em&gt;&lt;em&gt;如有遇到问题欢迎公众号私信留言&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8106761ffb102594b8b09e92b332ea71</guid>
<title>研发视角：一个需求应该怎么拆解与实现？</title>
<link>https://toutiao.io/k/27rashp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6279296875&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKSppwdQmmicSPVJriaYc6C6Yh8fLYicEliaMkUhd7f70pcQ36MXS0GMJNdanYB4jboDPj6TicrFzlpIrQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研发过程中，开发同学在接到一个需求后，必须要回答两个问题：&lt;/span&gt;&lt;span&gt;做什么（WHAT）、怎么做（HOW）。&lt;/span&gt;&lt;span&gt;本文就开发与测试在拆解需求时面临的共性问题，结合自己过往的经验，总结的一个实用的方法。&lt;/span&gt;&lt;span&gt;本文不讨论技术选型，仅从思考逻辑上总结应该如何拆解与实现一个给定的需求。&lt;/span&gt;&lt;span&gt;欢迎讨论。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-cangjie-key=&quot;4&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-2&quot;&gt;&lt;section&gt;&lt;span&gt;理解需求拆解的关注点&lt;/span&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以带UI的需求为示例，来看拆解需求过程中的关注点。看下图，停留20秒，思考两个问题：（1）从无到有实现以下需求对应的功能页面，需要做什么？（2）以下页面中只修改指定区域的元素，又需要做什么？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿﻿&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5862361937128292&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrWy37DianDdoKIc6sv2yPRpbCRF4AmH4MoHCx5BXqvmFWiaP6H71ucQSCbYzLeRSicEwUOicHUOyNlQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;上文两个问题代表两种需求类型：&lt;/span&gt;&lt;span&gt;第一个问题对应新功能的实现，第二个问题对应已有功能的修改与维护。&lt;/span&gt;&lt;span&gt;无论是新功能，还是历史功能，都需要关注如下点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;将上文提及的关注点进行抽象与分层后，会得到如下一张图：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.42136498516320475&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;674&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrWy37DianDdoKIc6sv2yPReGic7RicdobhmdSPmvMcR9JPJgMf13nFdAfgUXib4GIZkByxhxoktPUPw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿﻿&lt;/span&gt;&lt;span&gt;抽象后的架构层次图可以帮助我们理解实现的层次划分与结构设计。&lt;/span&gt;&lt;span&gt;但是，一般来说，抽象意味着抹平细节。&lt;/span&gt;&lt;span&gt;对于一个新手开发或者新手测试来说，需求实现或者测试过程，不仅要关注抽象层面的架构设计，更需要关注实现过程中的细节。&lt;/span&gt;&lt;span&gt;接下来对于上文提及到的关注点，下文会展开说明。&lt;/span&gt;&lt;span&gt;（在一个多角色的团队中，实现一个需求，不仅有自己，还有其他角色的开发、测试、PD、运营、数据等，理解关注细节才能保障交付质量）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/section&gt;&lt;h2 data-cangjie-key=&quot;60&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-2&quot;&gt;&lt;section&gt;&lt;span&gt;通过关注点看实现需求要做些什么&lt;/span&gt;&lt;/section&gt;&lt;/h2&gt;&lt;h3 data-cangjie-key=&quot;63&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-3&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注点1：需要多少UI&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;要绘制多少UI组件、要增加多少UI页面，首先取决于“需求文档（PRD）”、“视觉交互设计稿”。&lt;/span&gt;&lt;span&gt;对于开发来说，请重视需求评审、视觉交互评审。&lt;/span&gt;&lt;span&gt;对于质量良好的需求文档或者视觉设计稿，文档中给出的UI组件/页面范围一般就是开发要实现的UI范围；&lt;/span&gt;&lt;span&gt;对于质量差的需求甚至是一句话的需求，UI范围则需要研发“梳理确定”。&lt;/span&gt;&lt;span&gt;无论需求文档或视觉设计稿质量如何，研发人员在需求评审、视觉交互评审、技术设计、编码实现过程中都需重点关注“异常逻辑”。&lt;/span&gt;&lt;span&gt;什么是异常逻辑？&lt;/span&gt;&lt;span&gt;比如，一个查询类的需求，“查询结果为空”“查询时无网络”这类场景就属于“异常逻辑”。&lt;/span&gt;&lt;span&gt;很多时候，新手容易出问题或者遗漏的地方就是异常逻辑的处理与显示。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;需求拆解阶段，关注UI如何实现的同时，也请务必关注UI的展示对象，包括：&lt;/span&gt;&lt;span&gt;图片与多媒体内容（CDN图片、OSS图片文件、base64编码后的图片）、文案（文案的长度、多语言翻译的来源）、RTL（Right to Left）适配。&lt;/span&gt;&lt;span&gt;已一个支持17种语言甚至是更多语言的海外APP开发为示例，这些内容虽不影响开发进度，但是会影响需求在交付时的质量、或者是到了需求实现后期补作业。&lt;/span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实操方法：需求拆解的时，对于UI范围，可以拆解出如下内容用于辅助后续研发实现：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;UI范围：&lt;/span&gt;&lt;span&gt;功能页面范围、页面状态及状态的变化逻辑、界面的异常逻辑态等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;页面元素的拆解：&lt;/span&gt;&lt;span&gt;列表元素、卡片元素、动画元素、UI特效等（这个也是沉淀通用组件的依据）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;UI展示的对象：&lt;/span&gt;&lt;span&gt;文案的范围、多语言翻译的来源、RTL适配的范围、图片、短视频等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注点2：数据从哪里来？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-cangjie-key=&quot;93&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-3&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;这里的数据是包括用户直接感知的数据与富媒体内容流，也包括用户不感知但是用于支撑功能的研发类型的数据。数据的来源包括：网络数据、本地存储的数据、内存数据。不同的数据类型，需求实现的处理有差异，例如：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网络数据：&lt;/span&gt;&lt;span&gt;需求拆解时候重点关注接口文档、接口名称、接口返回的数据字段（包括字段类型、范围、字段名称等等）、接口对应的团队或具体的开发、接口的上下游链路（示例：&lt;/span&gt;&lt;span&gt;搜索的接口会涉及广告、算法等）、接口测试与联调方式等。&lt;/span&gt;&lt;span&gt;对于新手，需求拆解的时候还需要确认：&lt;/span&gt;&lt;span&gt;数据网关类型（MTOP网关、Node编排后的数据、Web网站对应的数据网关等），明确网络数据调度所用的域名（比如，部分APP交易功能的域名与非交易功能的域名是分开的，调度方式也会有差异）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;本地存储数据：&lt;/span&gt;&lt;span&gt;需求拆解阶段，要明确本地存储数据还是自己负责还是使用他人的能力。&lt;/span&gt;&lt;span&gt;如果是自己负责则需要进一步判断数据是写本地数据库，还是写本地文件；&lt;/span&gt;&lt;span&gt;如果是他人负责，数据的读写方式与接口是什么。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存数据：&lt;/span&gt;&lt;span&gt;需求拆解重点关注内存数据的读写方式，数据使用后的释放方式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;富媒体内容流：&lt;/span&gt;&lt;span&gt;图片、短视频、直播等多媒体流。&lt;/span&gt;&lt;span&gt;需求拆解时关注这些内容存储的形式（以图片为示例：&lt;/span&gt;&lt;span&gt;图片是CDN的URL，还是OSS的文件地址或者ID，甚至是base64处理后的编码结果）；&lt;/span&gt;&lt;span&gt;同时还需要判断这些展示能力是已有的还是需要新引入等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;总结来说，“数据从哪里来”很好记忆，但是，在真实的研发过程中，“数据从哪里来”往往是研发过程中最容易出问题的地方。&lt;/span&gt;&lt;span&gt;以网络数据为例，典型的问题有：&lt;/span&gt;&lt;span&gt;联调环境不稳定、接口返回的字段未遵守约定、接口上下游数据链路不通导致无法测试等。&lt;/span&gt;&lt;span&gt;即使需求完成并且交付上线，也还是会有各类问题，比如：&lt;/span&gt;&lt;span&gt;引入了新CDN导致现有的图片/短视频加载过程的优化策略不支持，导致线上反馈性能或者是稳定性问题等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;对于“数据从哪里来”，在拆解需求的时候，一定要关注到每一个字段。&lt;/span&gt;&lt;span&gt;这么强调，既因为这个点既影响实际投入工作量，还特别影响交付的需求的可用性与质量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;实操方法：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;进行需求拆解的时候，围绕数据从哪里来，可以拆解出以下内容：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注点3：数据与UI如何关联？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-cangjie-key=&quot;141&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-3&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;“数据要到哪里去，怎么去”，也可以理解为数据绑定。对于有一定复杂度的需求，“数据与UI如何关联”很大程度上会决定这个功能的实现与维护难易。需求拆解的时候，无论是选择MVC、MVP、还是MVVM，数据绑定这个过程比较考验开发人员的设计能力。我个人将数据绑定总结为如下几种：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单向数据绑定：&lt;/span&gt;&lt;span&gt;数据变化自动驱动UI刷新，代码实现会体现为各种Observer或者Observable等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;双向数据绑定：&lt;/span&gt;&lt;span&gt;数据改变的同时使视图刷新，而视图改变也可以同时改变数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无所谓数据绑定，数据关联到UI是过程式的编程，体现为：&lt;/span&gt;&lt;span&gt;加载数据、加载成功手工代码上屏等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;当然，以上总结是简化后的总结。&lt;/span&gt;&lt;span&gt;对于新功能，建议需求拆解的时候，反复理解所需的数据源、充分理解UI范围，结合控制逻辑，仔细提取关键特征后，充分设计后再进行编码等操作。&lt;/span&gt;&lt;span&gt;设计的时候多借鉴团队内或行业内的最佳实践。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;对于维护类型的需求，特别是有浓重祖传特质的功能（比如2013年功能迭代至2022年&lt;/span&gt;&lt;span&gt;的需求），则要花点时间理解原有的关联关系，这个很有可能是一个不大不小的难点。&lt;/span&gt;&lt;span&gt;比如，有的历史功能在实现的时候，数据与UI的关系是通过EventBus/消息广播类的事件触发；&lt;/span&gt;&lt;span&gt;还有的功能数据在独立进程加载，加载完成后通过进程间通信再通过事件通知机制绑定数据到UI。&lt;/span&gt;&lt;span&gt;总结来说，部分历史功能在最开始的实现，会用到各种酷爽的方案，但是到了后期维护，这类酷爽方法则会以一种超长技术链路或者拗口的技术链路呈现给维护者，变成一座需要咬牙才能翻阅的“山”。&lt;/span&gt;&lt;span&gt;本质上来说，编码不是人与机器的交流，而是人与人之间通过写作的交流。&lt;/span&gt;&lt;span&gt;对于一个维护性质的功能，掌握原有关系的一种方式就是植入各种测试性的代码辅助自己理解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;实操方法：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;拆解时，数据与UI关联，可拆解出的内容（数据与UI的关联，建议将“克制”作为自己的原则）：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;功能的数据流转与逻辑流程图&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码设计、数据关系流转设计等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据状态变化、UI刷新时机等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关联所用的绑定能力、数据变化后的通知机制等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注点4：用户行为响应&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-cangjie-key=&quot;189&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-3&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;相对于上文提及的三个点，这一点相对容易。对于带UI的需求，按照如下范围拆解与实现即可：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;归纳需求文档或设计文档中的用户行动点，包括：&lt;/span&gt;&lt;span&gt;点击、上下滑动、左右滑动、长按、开锁屏、虚实键盘响应、缩放手势等等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;行动点的常见处理：&lt;/span&gt;&lt;span&gt;页面跳转、tips/toast/弹窗等展示、动画处理、界面缩放、界面关闭等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;需约定的接口或规范：&lt;/span&gt;&lt;span&gt;页面跳转的schema/传参、二三方能力唤起的方式等&lt;/span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注点5：用户行为采集&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-cangjie-key=&quot;207&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-3&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;也就是收集用户行为的数据，简称“数据埋点”。比如，用户点击按钮、进入页面、在某区域停留一定时长之类的行为数据。这些行为数据是产品、数据、BI等角色关心并用于分析用户特征的数据。用户行为采集与用户行为响应密切相关。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据埋点作为独立的关注点强调，是因为即使研发在每个需求都会与“页面点”“点击点”“曝光点”“自定义事件点”打交道，同时也是最容易出问题的地方，问题示例：：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;strong&gt;&lt;span&gt;实操方法：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;研发人员在拆解需求的时候，针对用户行为采集，check以下点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;需求是否需要采集埋点数据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;点的名称是否符合产品/数据等消费方的要求&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参数范围与参数值是否有要求&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;需求完成后，数据采集谁验证？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注点6：发布后，如何运维与监控&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-cangjie-key=&quot;243&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-3&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;线上一旦出问题，开发或测试可以用什么工具或者方法进行排查分析。这就涉及到：需求如何发布、交付后的功能如何监控、开发过程中是否要提前布点以支撑排查分析工具的使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;功能发布形式有多种，例如：&lt;/span&gt;&lt;span&gt;灰度、Beta、A/B测试形式发布、动态配置下发、直接全量等。&lt;/span&gt;&lt;span&gt;不同发布形式对于功能发布之初的观测有差异，要支撑不同的发布形式，具体的实现也有差异：&lt;/span&gt;&lt;span&gt;比如，通过Google Play进行APP灰度测试不需要开发人员针对功能做额外处理；&lt;/span&gt;&lt;span&gt;以A/B测试形式上线的功能则需要在编码之初就要考虑通过什么平台能力进行，同时还需要编写对应代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;关于如何监控：&lt;/span&gt;&lt;span&gt;需要区分是技术指标监控，还是业务类指标的监控。&lt;/span&gt;&lt;span&gt;不同的监控范围，在需求拆解的时候就要决定哪个平台进行，比如：&lt;/span&gt;&lt;span&gt;业务类的指标可以在xflush平台上进行（需求拆解时要考虑数据回流xflush是已有的能力，还是需要新建能力）；&lt;/span&gt;&lt;span&gt;性能类指标可以在魔兔/iTrace上观测；&lt;/span&gt;&lt;span&gt;研发问题的排查可以通过SLS进行，还可以自建排查能力。&lt;/span&gt;&lt;span&gt;监控虽可以跟随功能的交付逐步补充完善，考虑需求的完整性，建议是在需求拆解的时候明确监控范围与形式。&lt;/span&gt;&lt;span&gt;毕竟，实现监控也是需要工作量的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;上线后有哪些工具可以用于排查分析问题，在需求实现的时候就需要将能力预置好的。&lt;/span&gt;&lt;span&gt;例如，对于“用户下单”这类容错较低的需求，研发在需求实现过程中如果没有写入足够的日志，一旦线上用户反馈“同一个产品在同一个时间下两个订单”，大概率这个问题就是无头无解问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;总结来说：&lt;/span&gt;&lt;span&gt;需求发布到线上后如何运维与监控，研发人员在拆解需求的时候需要思考明白：&lt;/span&gt;&lt;span&gt;需求发布形式、上线后期望的监控方式、出问题时可用的排查方式与与排查数据。&lt;/span&gt;&lt;span&gt;这些明确后，具体的实现，很容易通过历史功能、咨询、查资料等方式学习到。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/section&gt;&lt;h2 data-cangjie-key=&quot;276&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-2&quot;&gt;&lt;section&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;无论是开发还是测试，对于新手来说，都可以尝试基于“需要多少UI”、“数据从哪里来”、“数据与UI如何关联”、“用户行为响应”、“用户行为采集”、“发布后，如何运维与监控”六个方面进行需求拆解，并且根据拆解后的内容进行需求实现或者是需求测试。这个方法也适用于去分析其他功能的实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个方法是基于有UI的需求进行的总结，还有更多的需求是无UI的：比如，从某个位置同步数据到指定位置并且提供给到其他场景使用；再比如，研发需要一套新的路由框架或需要一套新的资源调度框架。这类需求的拆解与本文总结的方法有相同点，也有不同点，避免本文冗长，不铺开陈述。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上方法，是我个人在工作过程中，在接手需求的时候，用来判断需求影响范围、评估合作方、评估工作量的方法。欢迎实践、欢迎讨论，欢迎补充与更正。&lt;/span&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;明日预告：9月29日18:00精品文章&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👇&lt;strong&gt;&lt;span&gt;&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;阿里云刘伟光：剖析企业数字化的降“本”增效&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;不见不散～&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;GTS云巧乘风者征文大赛上线！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;10月10日前投稿GTS云巧乘风者征文活动，获得38元天猫超市卡！（数量有限）文章内容不限于云巧，只要运用了【组装式应用的理念】就可以投稿！更有机会获得888元猫超卡和天猫精灵Sound～&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;云巧及组装式应用理念是什么？云巧是“组装式应用”理念的落地，助力大家提升交付速度，提高交付质量，降低用工成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;点击阅读原文查看详情。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5a14f84fc3d6715b776b90781e58e46c</guid>
<title>C++20 协程初探</title>
<link>https://toutiao.io/k/pmpq60v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2159406858202039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe94QeANounecCYXmibLibjDT9FyppKGsIuLKTF79kZWAibun7RiaHIO3IFFNJOjIs1jvGoIicMiagIeJDiaqg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;导语 | &lt;/span&gt;&lt;span&gt;本文推选自腾讯云开发者社区-【技思广益 · 腾讯技术人原创集】专栏。该专栏是腾讯云开发者社区为腾讯技术人与广泛开发者打造的分享交流窗口。栏目邀约腾讯技术人分享原创的技术积淀，与广泛开发者互启迪共成长。&lt;span&gt;本文作者是&lt;/span&gt;腾讯后台开发工程师杨良聪。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;协程(coroutine)是在执行过程中可以被挂起，在后续可以被恢复执行的函数。&lt;/span&gt;&lt;span&gt;在C++20中，当一个函数内部出现了co_await、co_yield、co_return中的任何一个时，这个函数就是一个协程&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.37886340977068794&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95Yft4YCFicTVdU1icGRQPiaMp7RbD6oSqXZhN2oh9fDszUf39yKHFJBlia9PISicTepIHBBhNBKzfMkdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1003&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;C++20协程的一个简单的示例代码:&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;coro_ret&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&amp;gt; number_generator(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; begin, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; count) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;number_generator invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i=begin; i&amp;lt;count; ++i) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        co_yield i;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    co_return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* argv[])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; g = number_generator(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;begin to run!&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt;(!g.resume()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;got number:&quot;&lt;/span&gt; &amp;lt;&amp;lt; g.get() &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;coroutine done, return value:&quot;&lt;/span&gt; &amp;lt;&amp;lt; g.get() &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;69814fe855114dcb26db6b58da84c1d71&quot;&gt;&lt;span&gt;number_generator内出现了co_yield和co_return所以这不是一个普通的函数，而是一个协程，每当程序执行到第4行co_yield i；时，协程就会挂起，程序的控制权会回到调用者那里，直到调用者调用resume方法，此时会恢复到上次协程yield的地方，继续开始执行。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FiaZYIGick0nWJJXC1lSLI8zy2asbcicfNgvgJXexvB9rOnicPxbKFdEibPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;e98c58c6c958b0d9ef0ac044d6fa0a36&quot;&gt;&lt;span&gt;Promise&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6095e05d98ce4bfa80ac8a7ea434be6b2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6095e05d98ce4bfa80ac8a7ea434be6b2&quot;&gt;&lt;span&gt;number_generator的返回类型是coro_ret&amp;lt;int&amp;gt;，而协程本身的代码中并没有通过return返回这个类型的数据，这就是C++20里实现协程的一个关键点: 协程的返回类型T中，必须有T::promise_type这个类型定义，这个类型要实现几个接口。还是先看代码:&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;coro_ret&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;promise_type&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;using&lt;/span&gt; handle_type = &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::coroutine_handle&amp;lt;promise_type&amp;gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  handle_type coro_handle_;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;promise_type&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        promise_type() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;promise constructor invoded.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ~promise_type() = &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;get_return_object&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;get_return_object invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; coro_ret&amp;lt;T&amp;gt;{handle_type::from_promise(*&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;)};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;initial_suspend&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;initial_suspend invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::suspend_always{};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;return_void&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;return void invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;yield_value&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; T&amp;amp;amp; v)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yield_value invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return_data_ = v;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::suspend_always{};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;final_suspend&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;noexcept&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;final_suspend invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::suspend_always{};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;unhandled_exception&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;unhandled_exception invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        T return_data_;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    coro_ret(handle_type h)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            : coro_handle_(h)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ~coro_ret()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (coro_handle_)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            coro_handle_.destroy();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!coro_handle_.done()) {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            coro_handle_.resume();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; coro_handle_.done();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; coro_handle_.done();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;T &lt;span class=&quot;code-snippet__title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; coro_handle_.promise().return_data_;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;coro_ret是个自定义的结构，为了能作为协程的返回值，需要定义一个promise_type&lt;/span&gt;&lt;span&gt;。这个类型需要实现如下的接口:&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9F812pnpTVKsrLmlcKHlIuuBvuwqeIqmOLOsD9nTpkow7FlAh45LKRLA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;2a1c319a0a54e82b1a058d0854b565c8&quot;&gt;&lt;span&gt;协程相关对象&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f067af2c4b008df27e776c96c9341dfe2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f067af2c4b008df27e776c96c9341dfe2&quot;&gt;&lt;span&gt;可以看出promise类的工作主要是两个:一是定义协程的执行流程，主要接口是initial_suspend，final_suspend，二是负责协程和调用者之间的数据传递，主要接口是yield_value和return_value。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;877205f4205ef82ec98d8e6145bd48b93&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;877205f4205ef82ec98d8e6145bd48b93&quot;&gt;&lt;span&gt;std::coroutine_handle&amp;lt;promise_type&amp;gt;是协程的控制句柄类，最重要的接口是promise、resume，前者可以获得协程的promise对象，后者可以恢复协程的运行。此外还有destroy接口，用来销毁协程实例，done接口用于返回协程是否已经结束运行。通过std::coroutine_handle&amp;lt;promise_type&amp;gt;::from_promise()方法，可以从promise实例获得对应的handle。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8a60ea4a2c809b06f49b4d87f499995f2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8a60ea4a2c809b06f49b4d87f499995f2&quot;&gt;&lt;span&gt;coro_ret中其他几个接口resume，done和get_data不是必须的，只是为了方便使用而存在。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;d47e93b0a53a92f34b8afbeaea56aee32&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;d47e93b0a53a92f34b8afbeaea56aee32&quot;&gt;&lt;span&gt;总结一下，&lt;/span&gt;&lt;span&gt;一个协程与这几个对象关联在一起&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是个在堆上分配的内部对象，没有暴露给开发者，是用来保存协程内相关数据和状态的，具体来说就是:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9Fl62j5eylelCcZwNOEv5HRg9xicSj2KIwvdQMPbwiau3eqyIUpKbjQ6nA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;ae6dba70cd0182bd0e5016f2dabcd3be&quot;&gt;&lt;span&gt;协程&lt;/span&gt;&lt;span&gt;的创建&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;3.426470588235294&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95Yft4YCFicTVdU1icGRQPiaMpjB5D44WOnEZplBd1qpGic0KniclAjoELJ3hGKk4Omtg600DGNz0VvWaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;340&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FPB6mZB01WGXHsGUE2UYENHAJNeKa8y0qwiajZdfHR5lvk4rjnrQabwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;2d3673083b483abecdb1ed3918817fec&quot;&gt;&lt;span&gt;临时总结&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;d4a807228836477b997d30c0991686d63&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;d4a807228836477b997d30c0991686d63&quot;&gt;&lt;span&gt;要在c++20里实现一个协程，需要定义一个协程的返回类型T，这个T内需要定义一个promise_type的类型，这个类型要实现几个指定的接口，这样就足够了。这样，要开发一个包含异步操作的协程，代码的结构大致会是这样的:&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;coro_return&amp;lt;T&amp;gt; logic() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    some_async_oper();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    co_yield xxx&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; result = get_async_oper_result()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     do_some_thing(result)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     co_return&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; main() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; co_ret = logic();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; result = get_async_result();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (result) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          co_ret.resume()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;d3723338a79436c9283461efa45c5ac51&quot;&gt;&lt;span&gt;可以看到，在协程内部，发起异步操作和获取结果，被yield分割为了两步，和同步代码还是有着明显的区别。这时，co_await就可以发挥它的作用了，使用了co_await后的协程代码会是这样的&lt;/span&gt;&lt;/p&gt;&lt;pre/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;coro_return&amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;logic&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    auto result = &lt;span class=&quot;code-snippet__function&quot;&gt;co_await &lt;span class=&quot;code-snippet__title&quot;&gt;some_async_oper&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    do_some_thing(result);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;5ddd9dec80b8bde4c4adb06f5129a2b91&quot;&gt;&lt;span&gt;这样就和同步代码就基本没有区别了，除了这个co_await&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;b1ac4c98199a6df54a56b17db40c96e24&quot;&gt;&lt;span&gt;co_await最常见的使用方式为auto ret=co_await expr，co_await后跟一个表达式，整个语句的执行过程有多种情况，是比较复杂的。这里描述的是简化版本，主要是简化了promise.await_transform的作用，以及awaitable对象，可以点击下面链接&lt;/span&gt;&lt;span&gt;看完整的描述。&lt;span&gt;这&lt;/span&gt;&lt;span&gt;里假定协程的prom&lt;/span&gt;&lt;span&gt;ise_type没有实现await_transform方法。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://en.cppreference.com/w/cpp/language/coroutines&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;2.720626631853786&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95Yft4YCFicTVdU1icGRQPiaMpguy3iaThVxaIhGXrPia847EibY9nAJlXiaaG0eIxaaqzD4sydpQz88ib24Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;383&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;用代码表达，是这样：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!awaiter.await_ready())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;handle_t&lt;/span&gt; = &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::experimental::coroutine_handle&amp;lt;P&amp;gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;await_suspend_result_t&lt;/span&gt; =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;decltype&lt;/span&gt;(awaiter.await_suspend(&lt;span class=&quot;code-snippet__keyword&quot;&gt;handle_t&lt;/span&gt;::from_promise(p)));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;suspend-coroutine&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::is_void_v&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;await_suspend_result_t&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      awaiter.await_suspend(&lt;span class=&quot;code-snippet__keyword&quot;&gt;handle_t&lt;/span&gt;::from_promise(p));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;-to-caller-&lt;span class=&quot;code-snippet__keyword&quot;&gt;or&lt;/span&gt;-resumer&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;static_assert&lt;/span&gt;(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::is_same_v&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;await_suspend_result_t&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;await_suspend() must return &#x27;void&#x27; or &#x27;bool&#x27;.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (awaiter.await_suspend(&lt;span class=&quot;code-snippet__keyword&quot;&gt;handle_t&lt;/span&gt;::from_promise(p)))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;-to-caller-&lt;span class=&quot;code-snippet__keyword&quot;&gt;or&lt;/span&gt;-resumer&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;resume-point&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; awaiter.await_resume();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a7b87b6154d6b6116a89737320efacf32&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a7b87b6154d6b6116a89737320efacf32&quot;&gt;&lt;span&gt;以封装一个socket的connect操作为例，我们希望能像这样在协程中去connect一个tcp地址:&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;coro_ret&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&amp;gt; connect_addr_example(io_service&amp;amp;amp; service, &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* ip, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int16_t&lt;/span&gt; port)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    coroutine_tcp_client client;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; connect_ret = co_await client.connect(ip, port, &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;, service);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;client.connect return:%d\n&quot;&lt;/span&gt;, connect_ret);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (connect_ret)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;connect failed, coroutine return\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        co_return &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    do_something_with_connect(client);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    co_return &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;2649846b94e17f735e75069edf4f80231&quot;&gt;&lt;span&gt;那么需要做的事情是&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;2649846b94e17f735e75069edf4f80231&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;2649846b94e17f735e75069edf4f80231&quot;&gt;&lt;span&gt;第5行中的client.connect首先发起一个异步连接的请求(设置socket为noneblock，然后connect, 并把socket和自己的指针加入epoll)，返回的类型需要是一个awaiter，也就是要实现这三个接口:await_ready、await_suspend和await_resume&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在await_ready中，判断连接是否已经建立了(某些情况下connect会立刻成功返回)，或者出错了(比如给connect传了非法的参数)，此时需要返回true，协程就完全不会挂起。其他情况需要返回false，让协程挂起&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在await_suspend中，可以保存下传入的协程句柄，然后直接返回true。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在await_resume中，判断下连接的结果，成功返回0，其他情况返回错误码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;协程外的主循环里，使用epoll进行轮询，当对应的句柄有事件时(成功连接、超时、出错)，就取出对应的client指针，设置好连接的结果，并resume协程。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;9027a0165ea3e249ec69dbe1982877611&quot;&gt;&lt;span&gt;大致的代码如下:&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;connect_awaiter&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        coroutine_tcp_client&amp;amp; tcp_client_;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;await_ready&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; status = tcp_client_.status();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;switch&lt;/span&gt;(status)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; ERROR:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;await_ready: status error invalid, should not suspend!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; CONNECTED:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;await_ready: already connected, should not suspend!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;await_ready: status:%d, return false.\n&quot;&lt;/span&gt;, status);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;await_suspend&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::coroutine_handle&amp;lt;&amp;gt; awaiting)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;await_suspend invoked.\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            tcp_client_.handle_ = awaiting;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;await_resume&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ret = tcp_client_.status() == CONNECTED ? &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;awati_resume invoked, ret:%d\n&quot;&lt;/span&gt;, ret);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ret;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    };&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;3c413281ce0e6425754993cc3b29f0202&quot;&gt;&lt;span&gt;了解了co_await之后，可以回头看一下之前的内容，前面多次出现的std::suspend_never和std::suspend_always就是两个预定义好的awaiter，也有那三个接口的定义，有兴趣的同学可以看看对应的源代码。promise对象的initial_suspend、final_suspend、yield_value返回的都是awaiter，实际上系统执行的是 co_await promise.initial_suspend() ，co_yield实际上执行的是 co_await promise.yield_value() 。如果有需要，也可以返回自定义的awaiter。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9F9gEWETfj769ZEnnF4YHYbm1UBFpYldG1ibl6E9owa0M3yRB40WtEqLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;03b104d231d83a3fe7925664fc7b65e4&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看出C++20给出了一个非常灵活、有很强大可定制性的协程机制，但缺少基本的库支持，连写一个最简单的协程都需要开发者付出不少理解和学习的成本，目前的状态只能说是打了一个的地基，在C++23中，为协程提供库的支持是重要的目标之一，可以拭目以待。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/section&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;8a78f98238875951e8f8dff55d866b57&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h1 msthash=&quot;200785&quot; msttexthash=&quot;25598833&quot;&gt;&lt;span&gt;1.协程 （C++20）&lt;/span&gt;&lt;/h1&gt;&lt;h1 itemprop=&quot;name headline&quot; msthash=&quot;1355575&quot; msttexthash=&quot;48227790&quot;&gt;&lt;span&gt;2.C++ 协程：了解运算符co_await&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;3.C++20即将到来的coroutine能否与Golang的goroutine媲美？&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;105&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;105&quot; data-fileid=&quot;100044396&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95Yft4YCFicTVdU1icGRQPiaMpLxmVg5ia6uIWRscbIrbKnn8j33pxsd3fCmw3XNDgibsU1exzfB1Bfm1g/640?wx_fmt=png&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;杨良聪&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯后台开发工程师&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯后台开发工程师，毕业于华中科技大学，目前负责欢乐斗地主后端开发工作，有丰富的后台开发经验。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247545128&amp;amp;idx=1&amp;amp;sn=4dbacff04dbfb71f0675be0fa1cc1923&amp;amp;chksm=eaa82b78dddfa26e560d058f101f51480e98fc2bf72385addd6f7e2833266e0ea49734faa6e7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;GooseFS 在云端数据湖存储上的降本增效实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;GooseFS 在云端数据湖存储上的降本增效实践&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247545128&amp;amp;idx=2&amp;amp;sn=1dfadea0ac7abbfc771ad6a4c9bd0249&amp;amp;chksm=eaa82b78dddfa26ea8eaa74a684b05d98410221f25230a937dc7fb91dd3188f7405cd604ad1e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;新周期重构地产与物业数智化价值，TVP行业大使有话说&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;新周期重构地产与物业数智化价值，TVP行业大使有话说&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247544545&amp;amp;idx=1&amp;amp;sn=52424da68159c07a8260c6cef2bd2d01&amp;amp;chksm=eaa834b1dddfbda7b514c402b36ede3277be26fb05453d3fb2f8cfb99f0320a4d5faff7ed2ed&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;轻松上手！手把手带你掌握从Context到go设计理念&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;轻松上手！手把手带你掌握从Context到go设计理念&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247544454&amp;amp;idx=1&amp;amp;sn=8bf9a22c3402c9f07e248c038b09f3a5&amp;amp;chksm=eaa834d6dddfbdc02478b4f7ae87640cd2e2e705eba517eaa1bfd0458895f63e40e71c2d44aa&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;深入浅出带你走进Redis！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;深入浅出带你走进Redis！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;280&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40444444444444444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe940MSFL1oCgmdY94xonPZxOZqHFPx02lrZBs8SHygWCrAU9Fs3sYiap0kiaubmtBLZetqLAlQVsUb5Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;👇&lt;/span&gt;&lt;span&gt;点击&lt;/span&gt;&lt;span&gt;「阅读原文」&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;span&gt;注册成为社&lt;/span&gt;&lt;span&gt;区创作者，认识大咖，打造你的技术影响力！&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>64d029970d76b5e1b2edf57da439a1a3</guid>
<title>1.3w 字，一文详解死锁</title>
<link>https://toutiao.io/k/cpuopkj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁（Dead Lock）指的是两个或两个以上的运算单元（进程、线程或协程），都在等待对方停止执行，以取得系统资源，但是没有一方提前退出，就称为死锁。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6460554371002132&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmADlLgGMVtju1L72obicjJsoUVDIkORVCz6Po9llajtEEpiaFqpGYAlTRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.死锁演示&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁的形成分为两个方面，一个是使用内置锁 synchronized 形成的死锁，另一种是使用显式锁 Lock 实现的死锁，接下来我们分别来看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1 死锁 synchronized 版&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object lockA = &lt;span&gt;new&lt;/span&gt; Object(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Object lockB = &lt;span&gt;new&lt;/span&gt; Object(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 先获取锁 A&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (lockA) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;// 尝试获取锁 B&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;synchronized&lt;/span&gt; (lockB) {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 先获取锁 B&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (lockB) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;// 尝试获取锁 A&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;synchronized&lt;/span&gt; (lockA) {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上程序的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41688654353562005&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAWNw06AfA6YYPMcibDJ9UsBw8tk6fhdVnibKf27nIhOY5ruHcFW1PG4rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;从上述结果可以看出，线程 1 和线程 2 都在等待对方释放锁，这样就造成了死锁问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2 死锁 Lock 版&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.Lock;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DeadLockByReentrantLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lockA = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Lock lockB = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                    lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上程序的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41688654353562005&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAWNw06AfA6YYPMcibDJ9UsBw8tk6fhdVnibKf27nIhOY5ruHcFW1PG4rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.死锁产生原因&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上示例，我们可以得出结论，要产生&lt;strong&gt;死锁需要满足以下 4 个条件&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;互斥条件&lt;/strong&gt;：指运算单元（进程、线程或协程）对所分配到的资源具有排它性，也就是说在一段时间内某个锁资源只能被一个运算单元所占用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;请求和保持条件&lt;/strong&gt;：指运算单元已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它运算单元占有，此时请求运算单元阻塞，但又对自己已获得的其它资源保持不放。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不可剥夺条件&lt;/strong&gt;：指运算单元已获得的资源，在未使用完之前，不能被剥夺。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;环路等待条件&lt;/strong&gt;：指在发生死锁时，必然存在运算单元和资源的环形链，即运算单元正在等待另一个运算单元占用的资源，而对方又在等待自己占用的资源，从而造成环路等待的情况。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有以上 4 个条件同时满足，才会造成死锁问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.死锁排查工具&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果程序出现死锁问题，可通过以下 4 种方案中的任意一种进行分析和排查。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 jstack&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在使用 jstack 之前，先要通过 jps 得到运行程序的进程 ID，使用方法如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6194444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmA3QaQWB4jZMFNhMjvuPwLfvvyWicbP3jEDypmKIny407dB7OHvZMYdyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;“jps -l”可以查询本机所有的 Java 程序，jps（Java Virtual Machine Process Status Tool）是 Java 提供的一个显示当前所有 Java 进程 pid 的命令，适合在 linux/unix/windows 平台上简单查看当前 Java 进程的一些简单情况，“-l”用于输出进程 pid 和运行程序完整路径名（包名和类名）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了进程 ID（PID）之后，我们就可以使用“jstack -l PID”来发现死锁问题了，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7745358090185677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAabvmyOjnDpMp6KALrrI1ib0UcUQcnmm1iaUwSrXAVicZA9LTvlfcFLMDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1508&quot;/&gt;jstack 用于生成 Java 虚拟机当前时刻的线程快照，“-l”表示长列表（long），打印关于锁的附加信息。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PS：可以使用 jstack -help 查看更多命令使用说明。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 jconsole&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 jconsole 需要打开 JDK 的 bin 目录，找到 jconsole 并双击打开，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAOxHZ25JWwsRZCThOeuG3n6IF1CO2pnul211zaQMxd55vx45hLbKU3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6953703703703704&quot; data-w=&quot;1080&quot;/&gt;然后选择要调试的程序，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmA2LdjK4R8KvlvcTvvyPrP2FnnhB4KVawVUuEQtpUwuzrhn5gib2f85Rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;之后点击连接进入，选择“不安全的连接”进入监控主页，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAcbqu64dB7NaW3aWGpKmeLtFYBd8TNJtVp1DXibFpMOfYx51ZY765LeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAI97AjUVA3Wz9LkPP40EmHb5yUr7FjW2bVDibAdqHHUVRCu6ky42GdSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;之后切换到“线程”模块，点击“检测死锁”按钮，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAtzoA9uevcSAoDIpZ9BOkkdr8VIAvFuhSrIrJOHdgTAg5G1iap9JKmeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;之后稍等片刻就会检测出死锁的相关信息，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAenPE43qnS8qdjiaI6equszPqsWZ3xkc4ick3dRCfQmnpEJibXcYGrJXGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 jvisualvm&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jvisualvm 也在 JDK 的 bin 目录中，同样是双击打开：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmA2lnQfdLDgDEZEJ5lSLn0sRV7R45gbMCRG98gtNYGn4hvZs0YLQadhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6953703703703704&quot; data-w=&quot;1080&quot;/&gt;稍等几秒之后，jvisualvm 中就会出现本地的所有 Java 程序，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmA8SSQovwJwKIxEOE1hlNUMVG2EgPtjT6ING2P0IhD581ic5jp3w2ziapw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6185185185185185&quot; data-w=&quot;1080&quot;/&gt;双击选择要调试的程序：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6181506849315068&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAIKiaeogwiclesYGBaicVicKZkibKoCNVduHF3mQwgvWMJ4q6jOEU7UnQeYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2336&quot;/&gt;单击鼠标进入“线程”模块，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAaRv8wldSVEMDa5chlBoKgVNUnN0DNT73DASC4Ac5cwc2R9sYA0CyVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6185185185185185&quot; data-w=&quot;1080&quot;/&gt;从上图可以看出，当我们切换到线程一栏之后就会直接显示出死锁信息，之后点击“线程 Dump”生成死锁的详情信息，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmA6ltTBqQXUiacRGBtR65RTptAibn02DibLUte7hprOCibXoEWVvwLZbS7mQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6185185185185185&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 jmc&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jmc 是 Oracle Java Mission Control 的缩写，是一个对 Java 程序进行管理、监控、概要分析和故障排查的工具套件。它也是在 JDK 的 bin 目录中，同样是双击启动，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6953703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAU6A7Yicia7YT7uoSGnemEnIzoZESTXPJNd62uQjrBAyDCl0NibQrAG8WQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;jmc 主页信息如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6086956521739131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmANfC5BF035qc964qL44pJfvKQ4FSE9iagHyq1Zib8qcL2JNgqaWxTicsKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot;/&gt;之后选中要排查的程序，右键“启动 JMX 控制台”查看此程序的详细内容，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6515580736543909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAb56Ly9Zpzul29f4NbZiaqDibwvaVibyYsgfhRgUNPlmoZQrWCLAricibWVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6086956521739131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmA0icrzw7icLWqb2KClL3NQOHFciafToiboicMqtYwVkbMdESoVvbZBo7JyLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot;/&gt;然后点击“线程”，勾中“死锁检测”就可以发现死锁和死锁的详情信息，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6086956521739131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAYm6icJuP9JnxUA0ZqiacBjNRX69FFib3IGHRRZznMic2PoV6mY9tCOIMug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.死锁解决方案&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 死锁解决方案分析&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来分析一下，产生死锁的 4 个条件，哪些是可以破坏的？哪些是不能被破坏的？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;互斥条件：系统特性，不能被破坏。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求和保持条件：可以被破坏。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不可剥夺条件：系统特性，不能被破坏。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环路等待条件：可以被破坏。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述分析，我们可以得出结论，我们只能通过破坏请求和保持条件或者是环路等待条件，从而来解决死锁的问题，那上线，我们就先从破坏“环路等待条件”开始来解决死锁问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 解决方案1：顺序锁&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的顺序锁指的是通过有顺序的获取锁，从而避免产生环路等待条件，从而解决死锁问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们没有使用顺序锁时，程序的执行可能是这样的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6460554371002132&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmADlLgGMVtju1L72obicjJsoUVDIkORVCz6Po9llajtEEpiaFqpGYAlTRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;线程 1 先获取了锁 A，再获取锁 B，线程 2 与 线程 1 同时执行，线程 2 先获取锁 B，再获取锁 A，这样双方都先占用了各自的资源（锁 A 和锁 B）之后，再尝试获取对方的锁，从而造成了环路等待问题，最后造成了死锁的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我们只需要将线程 1 和线程 2 获取锁的顺序进行统一，也就是线程 1 和线程 2 同时执行之后，都先获取锁 A，再获取锁 B，执行流程如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0923482849604222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAKSzO7Smo3OmLiaWHVA4FaBtJh1nrqn76YYrxZSH4L6FGtOBF65mu4iaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;因为只有一个线程能成功获取到锁 A，没有获取到锁 A 的线程就会等待先获取锁 A，此时得到锁 A 的线程继续获取锁 B，因为没有线程争抢和拥有锁 B，那么得到锁 A 的线程就会顺利的拥有锁 B，之后执行相应的代码再将锁资源全部释放，然后另一个等待获取锁 A 的线程就可以成功获取到锁资源，执行后续的代码，这样就不会出现死锁的问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺序锁的实现代码如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SolveDeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object lockA = &lt;span&gt;new&lt;/span&gt; Object(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Object lockB = &lt;span&gt;new&lt;/span&gt; Object(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (lockA) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;synchronized&lt;/span&gt; (lockB) {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (lockA) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:等待获取B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;synchronized&lt;/span&gt; (lockB) {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上程序的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5751633986928104&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAEAVGBq0M7rnOxXictCml63iccu23A7Ia3h738bGGEN643DufUS4BjMcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;从上述执行结果可以看出，程序并没有出现死锁的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3 解决方案2：轮询锁&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轮询锁是通过打破“请求和保持条件”来避免造成死锁的，它的实现思路简单来说就是通过轮询来尝试获取锁，如果有一个锁获取失败，则释放当前线程拥有的所有锁，等待下一轮再尝试获取锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轮询锁的实现需要使用到 ReentrantLock 的 tryLock 方法，具体实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.Lock;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SolveDeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lockA = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Lock lockB = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1(使用轮询锁)&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 调用轮询锁&lt;/span&gt;&lt;br/&gt;                pollingLock(lockA, lockB);&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                    lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;     &lt;span&gt;/**&lt;br/&gt;     * 轮询锁&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pollingLock&lt;/span&gt;&lt;span&gt;(Lock lockA, Lock lockB)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (lockA.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (lockB.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:释放锁 B.&quot;&lt;/span&gt;);&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:释放锁 A.&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 等待一秒再继续执行&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上程序的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8703296703296703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAdPciams7e43Zju1N6HL7CGmNeOT7yjNgcnkgfpLhebMPkPOA7iaJ63Bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;从上述结果可以看出，以上代码也没有出现死锁的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.4 轮询锁优化&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用轮询锁虽然可以解决死锁的问题，但并不是完美无缺的，比如以下这些问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.4.1 问题1：死循环&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上简易版的轮询锁，如果遇到有一个线程一直霸占或者长时间霸占锁资源的情况，就会导致这个轮询锁进入死循环的状态，它会尝试一直获取锁资源，这样就会造成新的问题，带来不必要的性能开销，具体示例如下。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;反例&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.Lock;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SolveDeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lockA = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Lock lockB = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1(使用轮询锁)&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 调用轮询锁&lt;/span&gt;&lt;br/&gt;                pollingLock(lockA, lockB);&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                    lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;// 如果此处代码未执行，线程 2 一直未释放锁资源&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;// lockB.unlock(); &lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 轮询锁&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pollingLock&lt;/span&gt;&lt;span&gt;(Lock lockA, Lock lockB)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (lockA.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (lockB.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:释放锁 B.&quot;&lt;/span&gt;);&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:释放锁 A.&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 等待一秒再继续执行&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmASibUaDRFvZ8zrdfNhPJiaxmw5t1KqfY8vmiaAVNxlpASDn7NLHPnucCCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;2.9918367346938775&quot; data-w=&quot;490&quot;/&gt;从上述结果可以看出，线程 1 轮询锁进入了死循环的状态。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;优化版&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对以上死循环的情况，我们可以改进的思路有以下两种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;添加最大次数限制：如果经过了 n 次尝试获取锁之后，还未获取到锁，则认为获取锁失败，执行失败策略之后终止轮询（失败策略可以是记录日志或其他操作）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加最大时长限制：如果经过了 n 秒尝试获取锁之后，还未获取到锁，则认为获取锁失败，执行失败策略之后终止轮询。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上策略任选其一就可以解决死循环的问题，出于实现成本的考虑，我们可以采用轮询最大次数的方式来改进轮询锁，具体实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.Lock;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SolveDeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lockA = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Lock lockB = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1(使用轮询锁)&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 调用轮询锁&lt;/span&gt;&lt;br/&gt;                pollingLock(lockA, lockB, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                    lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;// 线程 2 忘记释放锁资源&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;// lockB.unlock(); // 释放锁&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 轮询锁&lt;br/&gt;     *&lt;br/&gt;     * maxCount：最大轮询次数&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pollingLock&lt;/span&gt;&lt;span&gt;(Lock lockA, Lock lockB, &lt;span&gt;int&lt;/span&gt; maxCount)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 轮询次数计数器&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (lockA.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (lockB.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:释放锁 B.&quot;&lt;/span&gt;);&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:释放锁 A.&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 判断是否已经超过最大次数限制&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (count++ &amp;gt; maxCount) {&lt;br/&gt;                &lt;span&gt;// 终止循环&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;轮询锁获取失败,记录日志或执行其他失败策略&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 等待一秒再继续尝试获取锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAOsUTCiarn4ictmmUaic3v6853JzZicf7thKlBKAUHZfnulKszYAB0776Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;840&quot;/&gt;从以上结果可以看出，当我们改进之后，轮询锁就不会出现死循环的问题了，它会尝试一定次数之后终止执行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.4.2 问题2：线程饿死&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以上的轮询锁的轮询等待时间是固定时间，如下代码所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 等待 1s 再尝试获取（轮询）锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;    e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在特殊情况下会造成线程饿死的问题，也就是轮询锁一直获取不到锁的问题，比如以下示例。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;反例&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.Lock;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SolveDeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lockA = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Lock lockB = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1(使用轮询锁)&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 调用轮询锁&lt;/span&gt;&lt;br/&gt;                pollingLock(lockA, lockB, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                        lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                        }&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;// 等待一秒之后继续执行&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 轮询锁&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pollingLock&lt;/span&gt;&lt;span&gt;(Lock lockA, Lock lockB, &lt;span&gt;int&lt;/span&gt; maxCount)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 循环次数计数器&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (lockA.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;100&lt;/span&gt;); &lt;span&gt;// 等待 0.1s(获取锁需要的时间)&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (lockB.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:释放锁 B.&quot;&lt;/span&gt;);&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:释放锁 A.&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 判断是否已经超过最大次数限制&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (count++ &amp;gt; maxCount) {&lt;br/&gt;                &lt;span&gt;// 终止循环&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;轮询锁获取失败,记录日志或执行其他失败策略&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 等待一秒再继续尝试获取锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;3.0347222222222223&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAWpt9S5dIFeZEKSeQ0wCwaZRSHJyPrVPMicrfwBRvs91cHFNa3cGrEsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;从上述结果可以看出，线程 1（轮询锁）一直未成功获取到锁，造成这种结果的原因是：线程 1 每次轮询的等待时间为固定的 1s，而线程 2 也是相同的频率，每 1s 获取一次锁，这样就会导致线程 2 会一直先成功获取到锁，而线程 1 则会一直处于“饿死”的情况，执行流程如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7983539094650205&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAicdBygnNOUXI62gicyIwgjXlTbKxeEib8W9NLnSZ95y1PQJmVggJqY2HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;优化版&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们可以将轮询锁的固定等待时间，&lt;strong&gt;改进为固定时间 + 随机时间的方式&lt;/strong&gt;，这样就可以避免因为获取锁的频率一致，而造成轮询锁“饿死”的问题了，具体实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.Random;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.Lock;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SolveDeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Random rdm = &lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lockA = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Lock lockB = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1(使用轮询锁)&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 调用轮询锁&lt;/span&gt;&lt;br/&gt;                pollingLock(lockA, lockB, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                        lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                        }&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;// 等待一秒之后继续执行&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 轮询锁&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pollingLock&lt;/span&gt;&lt;span&gt;(Lock lockA, Lock lockB, &lt;span&gt;int&lt;/span&gt; maxCount)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 循环次数计数器&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (lockA.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;100&lt;/span&gt;); &lt;span&gt;// 等待 0.1s(获取锁需要的时间)&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (lockB.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:释放锁 B.&quot;&lt;/span&gt;);&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:释放锁 A.&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 判断是否已经超过最大次数限制&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (count++ &amp;gt; maxCount) {&lt;br/&gt;                &lt;span&gt;// 终止循环&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;轮询锁获取失败,记录日志或执行其他失败策略&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 等待一定时间(固定时间 + 随机时间)之后再继续尝试获取锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;300&lt;/span&gt; + rdm.nextInt(&lt;span&gt;8&lt;/span&gt;) * &lt;span&gt;100&lt;/span&gt;); &lt;span&gt;// 固定时间 + 随机时间&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.108695652173913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAKBibFoVl4y1CRVyxCicIBOH5RVkrZHmIewsyw8QEA6stkqh6Uibf70xJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;736&quot;/&gt;从上述结果可以看出，线程 1（轮询锁）加入随机等待时间之后就不会出现线程饿死的问题了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了死锁的概念，以及产生死锁的 4 个条件，排查死锁可以通过本文提供的 4 种工具中的任意一种来检测，从易用性和性能方面来考虑，推荐使用 jconsole 或 jvisualvm，最后我们介绍了死锁问题的两种解决方案：顺序锁和轮询锁。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;---END---&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>122ed7cd9a11c0684d5f36508fdc2249</guid>
<title>软件开发人员如何提高个人和团队工作效率</title>
<link>https://toutiao.io/k/zxfp2qa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05669291338582677&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nr1VNxfeqxVOw2nPJHVH4xeZibzPY5F4ibOuOZLMsUMrzIibGB6KMw7EurSKv6DkrtLzuhYdBa30A9Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;107290&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 334.6 286.9&quot;&gt;&lt;polygon points=&quot;334.6,286.9 185.3,286.9 185.3,0.4 334.6,150.4 &quot;/&gt;&lt;polygon points=&quot;147.6,283.9 3.3,283.9 3.3,7.4 147.6,150.4 &quot;/&gt;&lt;/svg&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;一个程序员如何提高&lt;/span&gt;&lt;span&gt;其&lt;/span&gt;&lt;span&gt;生产力，从而成为一个卓越的程序员。关于这个主&lt;/span&gt;&lt;span&gt;题可以写（而且已经写了）一整本书。本文会介绍一些可以用来&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;提高个人和团队工作效率的技术。文末再推荐一本软&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;工好书给你，不能错过！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;108122&quot;&gt;&lt;section hm_fix=&quot;223:473&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;合理选择选件开发工具&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;作为一个软件开发人员，你将大部分时间花费在使用软件开发工具上，并且工具的质量对生产力有巨大的影响。遗憾的是，选择开发工具的主要标准似乎是对工具的熟悉程度，而不是工具对当前项目的适用程度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;请记住，当你在项目开始时选择工具的时候，你可能需要在整个项目期间（甚至更长时间）都必须使用这些工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如，一旦你开始使用缺陷跟踪系统，由于数据库文件格式不兼容，你可能就很难切换到其他系统，源代码控制系统也是如此。幸运的是，软件开发工具（尤其是IDE）现在已经相对成熟，而且许多工具之间都是可互操作的，因此你不太会做出错误的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽管如此，但是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在项目开始时仔细考虑如何选择工具，可以为你省去很多后续的烦恼。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于一个软件开发项目来说，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最重要的工具是选择使用哪种编程语言，以及使用哪种编译器/解释器/转换器。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;选择最佳的语言是一个很难解决的问题。你很容易证明一些编程语言是正确的，因为你熟悉它们，你不需要再去学习它们；然而，未来新的工程师在学习编程语言的同时还要维护代码，他们的工作效率可能会低得多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，选择某些语言可以简化开发过程，充分提高生产力，以弥补学习语言所损失的时间。正如前面所提到的，选择一种糟糕的语言可能会浪费很多开发时间，直到你发现它不适合这个项目，于是不得不重新开始。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;编译器性能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;（每秒可以处理一个普通源文件的多少行代码）会对你的生产效率产生巨大的影响。如果编译器平均编译一个源文件只需要2秒钟而不是2分钟，那么使用更快的编译器可能会提高效率（尽管更快的编译器可能会缺少一些特性，从而在其他方面降低了效率）。工具处理代码的时间越少，留给设计、测试、调试和优化代码的时间就越多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用一系列能够很好地&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;协同工作的工具&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;也很重要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天，我们认为使用集成开发环境（IDE）是理所当然的，它将编辑器、编译器、调试器、源代码浏览器和其他工具集成到一个单独的程序中。这使得我们可以在屏幕的同一个窗口内，快速地在编辑器中进行更改，重新编译源代码模块，并在调试器中运行结果，极大地提高了工作效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而，你经常不得不在IDE之外处理项目的某些工作。例如，有些IDE不支持源代码控制或者缺陷跟踪（尽管许多IDE都支持）。大多数IDE没有提供用于编写文档的文字处理程序，也没有提供简单的数据库或者电子表格功能来维护需求列表、设计文档或者用户文档。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最有可能的是，你不得不使用一些IDE之外的程序，例如文字处理、电子表格、绘图/图形工具、Web设计工具和数据库程序等，来完成项目所需的所有工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在IDE之外运行程序不是问题，只要确保你选择的应用程序，与你的开发过程和IDE生成的文件是兼容的即可（反之亦然）。如果在IDE和外部应用程序之间移动文件，你必须不断运行一个转换程序，那么你的生产效率将会降低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我能为你推荐一些工具吗？不能。因为项目的需求多种多样，所以我在这里无法给出这种建议。我的建议是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在项目开始时就注意到这些问题。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是我可以给出一个建议，就是在选择开发工具时&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;避免有“为什么我们不尝试这种新技术”的想法。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在使用了一个开发工具6个月之后（并基于它来编写源代码），如果你发现它不能够完成工作，那么后果可能是灾难性的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了考虑产品开发，你还要认真评估这些工具，只有在确信新工具确实有用之后，才能选择使用它们。苹果公司的Swift编程语言就是一个典型的例子。在Swift v5.0发布之前（大约在Swift首次发布的4年之后），使用Swift语言一直是令人沮丧的。每年苹果公司都会发布一个与之前版本代码不兼容的新版本，迫使你不得不修改旧的程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，该语言的早期版本中缺少许多功能，并且一些功能并不完善。直到5.0版本（在编写本书时发布）以后，Swift语言才变得相对稳定。然而，那些早期迎合这一潮流的可怜的人，为该语言的不成熟发展付出了代价。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;遗憾的是，在许多项目中，你自己无法选择开发工具。这个决定来自上级的命令，或者你沿用产品以前的工具。抱怨它不仅会浪费时间和精力，还会降低你的工作效率。相反，你应当充分利用你所拥有的工具集，并成为使用它的专家。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;108122&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;管理开销&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;对于任何项目，我们都可以将工作分为两种类型：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;与项目直接相关的工作（例如，为项目编写代码或者文档）和与项目间接相关的工作。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;间接的活动包括会议、阅读和回复电子邮件、填写考勤卡和更新日程安排。这些都是日常开销活动，它们增加了项目的时间和成本，但是并不直接有助于完成工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过遵循Watts S. Humphrey在Personal Software Engineering（《个人软件工程》）中介绍的方法，你可以跟踪在项目期间将时间都花费在了何处，并且很容易地看到直接花费在项目上的时间，以及花费在间接的开销活动上的时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果你的开销活动时间超过总时间的10%，那么你应当重新考虑日常活动。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;你应当试着减少或者整合这些活动，来降低它们对你的工作效率的影响。如果你没有跟踪项目之外花费的时间，那么就会错过通过减少管理开销来提高生产力的机会。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;108122&quot;&gt;&lt;section hm_fix=&quot;239:467&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;3&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;设置明确的目标和里程碑&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;如果不是最后期限迫在眉睫，人们往往会放慢工作节奏，当最后期限临近时，他们又会进入“超级模式”，这是人类的天性。如果没有目标，那么人们就很难高效地完成工作。如果没有最后期限，那么人们就很难有动力及时去实现这些目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，为了提高你的工作效率，一定要有明确的目标和子目标，并将其附加到里程碑上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从项目管理的观点来看，里程碑是项目中的一个标记点，它代表了工作的进展程度。一个好的管理者总是会在项目进度中设定目标和里程碑。然而，很少有时间进度计划会为单个程序员提供有用的目标。这就是个人软件工程需要发挥作用的地方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;要想成为一个超级高效的程序员，你需要对自己项目中的目标和里程碑进行微管理。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一些简单的目标，例如，“我要在吃午饭之前完成这个功能”或者“我要在今天回家之前找到这个错误的根源”，可以让你集中注意力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而另一些更大的目标，例如，“下周二我将完成这个模块的测试”或者“今天我将运行至少20个测试程序”，可以帮助你评估生产力，并确定你是否实现了自己的目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;108122&quot;&gt;&lt;section hm_fix=&quot;239:467&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;4&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;练习自我激励&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;能否提高工作效率取决于你的态度。虽然别人可以帮助你更好地管理时间，或者在你陷入困境时帮助你，但是最重要的是你必须主动改善自己。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你需要时刻注意自己的节奏，不断努力提高自己的表现。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;通过跟踪自己的目标、努力和进步，你会知道什么时候需要“让自己振作起来”，通过更努力地工作来提高工作效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;缺乏动力可能是提高工作效率的最大障碍之一。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;如果你的态度是“啊，我今天还要做这件事”，那么你完成这个任务所花费的时间可能比你的态度是“哇！这是最棒的部分！这将会很有趣！”更多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，你做的每一个任务并不都是有趣的。这是个人软件工程需要介入的一个领域。如果你想要保持高于平均水平的生产力，那么当一个项目让你感到“缺乏动力”时，你需要有足够的自我激励。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;试着创造一些理由让这份工作更有吸引力。例如，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;为自己创造一些小挑战，并在完成后奖励自己。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一个高效的软件工程师会经常练习自我激励：你对一个项目保持动力的时间越长，你的工作效率就越高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;108122&quot;&gt;&lt;section hm_fix=&quot;239:467&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;5&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;集中注意力，消除干扰&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;专注于一个任务并消除干扰，是另一种能够显著提高生产力的方法。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;你应当能够“进入状态”。通过这种方式工作的软件工程师比那些一心多用的人更有效率。为了提高工作效率，你应尽可能长时间地专注于某一个任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在没有任何视觉刺激（除了显示屏）的安静环境中，专注于一个任务是最容易的。有时候，工作环境并不利于让你专注。在这种情况下，戴上耳机，播放背景音乐可能有助于消除干扰。如果音乐太让人分心，则可以试着听听白噪声，网络上有一些白噪声的应用程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无论什么时候你在工作中被打断了，你都需要时间恢复状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事实上，你可能需要半个小时才能完全集中精力工作。当你需要集中精力完成一个任务时，可以贴一个告示说只有紧急的事情才能打断你，或者在你的工作台附近贴上“办公时间”，即你可以被打断的时间，例如，你可以允许别人打断你5分钟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回答同事们自己能想明白的问题，可以节省其10分钟的时间，但是这可能会浪费你半个小时。你必须作为团队的一部分工作，成为一个好队友，然而，同样重要的是，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;需要确保过度的团队互动不会降低你（和其他人）的生产力。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在一个典型的工作日中，会有许多已经预定的工作中断时间，例如用餐时间、休息时间、会议、行政管理（如处理电子邮件和时间核算）等。如果可能的话，你可以试着在这些事件周围安排其他活动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如，关闭任何邮件提醒，因为在几秒钟内回复邮件很少是必需的，而且如果有紧急情况，别人会亲自找到你或者打电话给你。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果别人确实希望你能快速回复，那么你可以设置一个闹钟，提醒自己在固定时间查收邮件（对待短信和其他干扰也是如此）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当你接到很多非紧急电话时，你可以考虑把手机调成静音，在休息时每隔1小时左右查看一下短信。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何做取决于你的个人和职业生活，但是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你受到的干扰越少，你的工作效率就越高。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;108122&quot;&gt;&lt;section hm_fix=&quot;239:467&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;6&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果你觉得无聊，那就做点别的事儿&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;有时候，无论你多么有动力，你都会对自己的工作感到无聊，也很难集中注意力，你的工作效率会大幅下降。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你不能进入状态，无法将注意力集中在任务上，那么就休息一下，做一些其他事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不要以无聊为借口，在一个又一个任务之间来回奔波，却又完成不了多少工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，当你真的遇到障碍，无法前进时，不妨试着换一些你可以做得更有成效的事情。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;108122&quot;&gt;&lt;section hm_fix=&quot;239:467&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;7&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;尽可能自立&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你应该尽力尝试处理所有分配给你的任务。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;虽然这不会提高你的工作效率，但是如果你不断地向其他工程师寻求帮助，则可能会降低他们的生产力（记住，他们也需要保持专注，避免干扰）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你正在做一个需要更多知识的任务，而你又不想经常打断其他工程师，那么你可以有以下几种选择：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;花点时间自学，这样你就能完成任务了。虽然这可能会影响到你短期的工作效率，但是你所获得的知识将帮助你完成未来类似的任务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;去见你的经理，解释你遇到的问题。讨论一下是否可能把任务重新分配给更有经验的人，然后给你分配一个你能够更好地处理的任务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;与你的经理安排一次会议，在不太影响其他工程师工作效率的时间（例如，在工作日的早上）寻求帮助。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;108122&quot;&gt;&lt;section hm_fix=&quot;239:467&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;8&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;识别何时需要帮助&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;有时候，你的自立态度可能会有点过头。你可能在一个问题上花费了太多的时间，而你的队友只需要几分钟就能解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;成为一个卓越程序员的一个方面是，认识到自己陷入困境，需要帮助才能继续前进。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当你被困住的时候，最好的方法是设置一个定时闹钟——在被困在这个问题上几分钟、几小时甚至几天之后，寻求帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果你知道该向谁寻求帮助，那么就直接寻求帮助。如果你不确定，那么就和你的经理谈谈。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;最有可能的情况是，你的经理会指引你找到合适的人，这样你就不会打扰到那些无论如何也帮不了你的人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;团队会议（每天或每周）是向团队成员寻求帮助的好地方。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;如果你手头上有好几个任务要做，而你又被困在一个特定的任务上，那么可以把它放在一边，做其他任务（如果可能的话），然后把你的问题留到团队会议上来问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你在会议之前把工作做完了，则可以让你的经理分配一些其他工作，这样你就不必打扰别人了。此外，在处理其他任务时，你可能也会找到解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;108122&quot;&gt;&lt;section hm_fix=&quot;239:467&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;9&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;克服士气低落&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;没有什么比团队成员士气低落能更快地扼杀一个项目了。这里有一些建议可以帮助你克服士气低落：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;了解项目的商业价值。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;通过了解或提醒自己项目的实际用途，你将对项目投入更多的热情，也更感兴趣。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;对项目（你的部分）负责。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;当你对这个项目负责时，你的骄傲和荣誉就与它绑在一起了。不管发生什么事情，请确保你总是可以谈论自己对项目所做的贡献。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;避免在你无法控制的项目问题上投入精力。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;例如，如果管理层做出了一些影响项目进度或者设计的糟糕决定，那么就在这些限制范围内尽最大努力工作。当你可以努力去解决问题时，不要只是坐在那里抱怨那些管理决定。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果你的个性给你的士气带来了问题，请与你的经理和其他受影响的人员讨论一下。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;沟通是关键。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;任由问题继续下去，只会导致更大的士气问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;时刻警惕可能会降低士气的情况和态度。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一旦项目团队的士气开始下降，通常就很难恢复。你越早处理士气问题，就越容易解决它们。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;有时候，财务、资源或者个人问题都会降低项目参与者的士气。&lt;strong&gt;作为一个卓越的程序员，你的工作就是躬身入局，战胜挑战，继续编写卓越的代码，并且鼓励项目中的其他人也这么做。&lt;/strong&gt;这样做并不总是容易的，但是没有人说过成为一个卓越的程序员是容易的。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;7&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-autoskip=&quot;1&quot; hm_fix=&quot;254:407&quot;&gt;本文节选自&lt;strong&gt;《编程卓越之道（卷3）：软件工程化》&lt;/strong&gt;一书！&lt;/p&gt;&lt;p data-autoskip=&quot;1&quot; hm_fix=&quot;254:407&quot;&gt;想要了解如何更好地进行软件开发，走向卓越吗？&lt;/p&gt;&lt;p data-autoskip=&quot;1&quot; hm_fix=&quot;254:407&quot;&gt;推荐阅读本书！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;88355&quot;&gt;&lt;section hm_fix=&quot;255:284&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;88355&quot;&gt;&lt;section hm_fix=&quot;255:284&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9922680412371134&quot; data-type=&quot;gif&quot; data-w=&quot;388&quot; data-width=&quot;100%&quot; title=&quot;圆形渐变分割线&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PW0wIHxgg3lY81OBXD87AC30eXxwOOxqAIAOJSm19LfP7vGvbp42kM6AAFZibC0KZwDkGohYRnu568qtljL91eQ/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;292&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;292&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kvSnlZvbtWKFGSmO6Aia5GPr6vVvWQ0MLEjoNTUCDDXsicmLH6e3QfylBy20RSyCicbGhbxVKb0prug/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-width=&quot;345px&quot; title=&quot;9787121439933.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;▊&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;《&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;编程卓越之道（卷3）：软件工程化》&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;[美] Randall Hyde（兰德尔・海德） 著&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;张若飞 译&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;90239&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;媲美高德纳&lt;/span&gt;&lt;span&gt;TAOCP&lt;/span&gt;&lt;span&gt;的程序设计领域经典系列&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;本书都没有讲明白的事情被这本书说清楚了&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;机器原理→底层语言→高级代码→团队生产力&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本书深入介绍了从开发方法、生产力到面向对象的设计需求和系统文档的方方面面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过本书，你将学习到：为什么遵循软件匠艺模型可以让你做到最好；如何利用可追溯性来加强文档的一致性；如何通过用例分析来创建自己的UML需求；如何利用IEEE文档标准开发出更好的软件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过对高质量软件开发中技能、态度和道德方面的深入讲解，本书揭示了如何将工程原理应用于编程的正确方法。在这个过程中，Hyde不仅会教给你规则，还会告诉你什么时候该打破规则。他不仅会启发你认识什么是最佳实践，同时还会让你发现适合自己的最佳实践。本书中包含了大量的资源和示例，它是你编写代码的最佳指南，将让你从同行中脱颖而出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;118&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;118&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lY81OBXD87AC30eXxwOOxqaS3F0zQm3E95ls1LpnZhty1s6zrR0fBqpg0bewZtrmFc0PnfNqicksw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;300&quot; data-width=&quot;118px&quot; title=&quot;编程卓越之道二维码 (1).png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span/&gt;限时下单立减50，快快扫码抢购吧&lt;span&gt;！&lt;/span&gt;&lt;span/&gt;）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-traceid=&quot;1774976a-8123-4c4b-ab71-4213017e2752&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;104_2096723781&quot; data-appuin=&quot;2395946309&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:106,&amp;quot;pid&amp;quot;:&amp;quot;104_2096723781&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;2395946309&amp;quot;,&amp;quot;trace_id&amp;quot;:&amp;quot;1774976a-8123-4c4b-ab71-4213017e2752&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;104_2096723781&amp;quot;,&amp;quot;source_id&amp;quot;:4,&amp;quot;source_name&amp;quot;:&amp;quot;有赞&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://pcm-img.zhls.qq.com/productcenter-3f2f7a1b--1014995-1724289742498346218/22711561322092022/c3fcf55e01ed92b23b51bd6ec7f6bc61.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;官方正版 编程卓越之道（卷3）：软件工程化&amp;quot;,&amp;quot;current_price&amp;quot;:6900,&amp;quot;first_category_id&amp;quot;:&amp;quot;106&amp;quot;,&amp;quot;product_label_name_list&amp;quot;:[],&amp;quot;appuin&amp;quot;:&amp;quot;2395946309&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;发布：刘恩惠&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;审核：陈歆懿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Puv74VHDtgNjyJbpQvt1gicgSpjrlpDy6BheYoAmtjiaF7cdIuPkuUlFkw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1920&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;29.8961937716263&quot; data-ratio=&quot;0.01574074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Pu8DQL5f0FQIuDZC87yrAuNLy4frEdlMeWkthrlzczb0RbMOBQCAwDrA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如果喜欢本文&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;欢迎&lt;/span&gt; &lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;留言&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享至朋友圈&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 三连&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;92644&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt; &lt;strong&gt;热文推荐 &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;574&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;244&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3m3jibtjia3lCrCvUY6N19QMZ3FjCcpuHouXkdLicQVUiaLicgR8cgSbk7RA8G427GKowhbEvVefuJp53g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▼点击阅读原文，了解本书详情~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>