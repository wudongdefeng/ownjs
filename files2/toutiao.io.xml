<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>90db304e88eed55714a76c2a84006c1e</guid>
<title>P5~P9 应该具备的核心能力是什么</title>
<link>https://toutiao.io/k/7ga7vcn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;👆&lt;/span&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;span&gt;博文视点Broadview&lt;/span&gt;&lt;span&gt;”，获取更多书讯&lt;/span&gt;&lt;/p&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05669291338582677&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nr1VNxfeqxVOw2nPJHVH4xeZibzPY5F4ibOuOZLMsUMrzIibGB6KMw7EurSKv6DkrtLzuhYdBa30A9Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以阿里的职级体系为标杆&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，先给大家对比几个知名公司的职级体系，以及与阿里职级&lt;/span&gt;&lt;span&gt;对应关系，这样首先能够&lt;/span&gt;&lt;span&gt;帮助你更好地评估自己在行业中大概的水平和位置。&lt;/span&gt;&lt;span&gt;这几家公司的职级对应关系如下表所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3442028985507246&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kLDUqiaAMQafH2icPM4icClrkibARhicweiaYXCOG9NHicMyBSessZuicP1zqCicqKnpuyl0iaUuRBWtp4FI4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可能还是不清楚每个级别的要求到底是什么。在这之前，我想先通过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三个类比带你纵向透视职级档次&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，对不同档次的核心能力建立一个形象的认知，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45535714285714285&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kLDUqiaAMQafH2icPM4icClrkPGPVDRjkEedmRXsMvybI0Rwl0drVHQKcZIL2JeH0IxFicCaDfAkrzJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;113244&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;217:759&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;P5/P6:专业工匠&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;P5/P6 这一档相当于“专业工匠”&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，就像木匠、铁匠、粉刷匠一样，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;核心能力是完成任务。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的任务是指每个岗位需要完成的事情，比如开发岗位需要完成代码的编写，测试&lt;/span&gt;&lt;span&gt;岗位需要完成测试用例的执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;P5 和 P6 的职责一样，比较简单，不需要太多解读。这两个级别的区别是，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;P5 需要在&lt;/span&gt;&lt;span&gt;别人的指导下完成工作，而 &lt;/span&gt;&lt;span&gt;P6 &lt;/span&gt;&lt;span&gt;可以独立完成工作。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;其实只要有意愿在技术领域发展，基本&lt;/span&gt;&lt;span&gt;上每个人都能达到 P6 的水平。&lt;/span&gt;&lt;span&gt;P5/P6 &lt;/span&gt;&lt;span&gt;的核心职责如下表所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3475836431226766&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kLDUqiaAMQafH2icPM4icClrkZiaKSoLjjSpEibFgLIkn8iad5zdgb5LicDFNPmXOOeLyXntRvhGVziaQ8kQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;538&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要强调的是，这里列举的只是一个岗位的核心职责，并不代表这个岗位只做这些事情，比如开发岗位的 P7/P8 也是要参与编码的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，这里只列举了开发、测试和运维这些技术岗位的职责。产品、运营和市场等非技术岗位的人员，也可以根据你掌握的信息来整理你所在岗位的核心职责表格。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;113244&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;217:759&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;P7/P8:乐团指挥&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;P7/P8 这一档相当于“乐团指挥”，核心能力是指挥团队。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么要这么类比呢？因为 P7/P8 的职责和乐团指挥的职责非常相似。&lt;strong&gt;乐团指挥的核心工作职责可以分为以下三个阶段：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一阶段是总谱研究&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，对总谱进行深入细致的研究分析，识别和标注演奏的重点、难点与风险点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二阶段是排练准备&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，明确演奏需要的人手和乐器，根据乐团情况制定排练计划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三阶段是正式排练&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，拆解具体排练步骤（比如个体练习、分声部练习和全体排练等），抓好每一个关键环节的落实，做好风险预防措施，推动整个乐团完成演奏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;P7/P8 的任务和乐团指挥非常像，也可以分为三个阶段，与乐团指挥的三个阶段正好一一对应。你只要把总谱换成团队的工作目标，把人手和乐器换成资源，把演奏排练换成工作目标落地就行了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是分析阶段，对应乐团指挥的总谱研究；然后是计划阶段，对应排练准备；最后是落地阶段，对应正式排练。具体的对应关系如下表所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2747826086956522&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kLDUqiaAMQafH2icPM4icClrkw1lJiczI0SWGySQVrNXVfQE9UmBSJ3l72d70O0drQdKcvMOfcuOInVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;那么 P7 和 P8 的区别是什么呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;P7 只需要指挥单个团队，而 P8 往往要指挥多个团队。另外还需要补充一点，这里说的“团队”，包括以下两种类型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）狭义上的团队：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;组织结构上的行政级别团队，比如 P7 担任的 3～10 个人团队的Team Leader，负责团队管理、团队规划、团队考核和团队建设等管理职责。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）广义上的团队：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;为了完成某个目标而成立的虚拟团队（或者说临时团队），比如某个项目投入的人员组成了“项目团队”（由公司立项成立），某个专项任务投入的人员组成了“专项团队”（由管理者安排，比如“研发效能提升工作组”）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;P7/P8 的核心职责如下表所示。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.07908611599297&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kLDUqiaAMQafH2icPM4icClrk7xIUv9A26LBbd5uucZK01QAJNSRZIP1IGTZIl62RAP6S1OBmEdvC0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;569&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;113244&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;217:759&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;P9/P10:电影导演&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;P9/P10 这一档相当于“电影导演”，核心能力是导演作品。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么要这么类比呢？因为P9/P10的工作跟电影导演很像，具体表现在以下三个方面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一，他们的工作都具有一定的规模。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如你只是拍一段 60 秒的 vlog（中文名是微录，是博客的一种类型，全称是 video blog&lt;/span&gt;&lt;span&gt;或 &lt;/span&gt;&lt;span&gt;video log&lt;/span&gt;&lt;span&gt;，意思是视频记录、视频博客、视频网络日志），还算不上电影导演；真正的&lt;/span&gt;&lt;span&gt;电影导演拍出来的是几十分钟以上，剧本、服饰、化妆、道具、表演、运镜和剪辑都非常&lt;/span&gt;&lt;span&gt;成熟的作品。同样地，&lt;/span&gt;&lt;span&gt;P5&lt;/span&gt;&lt;span&gt;～&lt;/span&gt;&lt;span&gt;P8 &lt;/span&gt;&lt;span&gt;这几个级别的工作都会产出一些成果，但这些成果在规模上&lt;/span&gt;&lt;span&gt;还不足以同 &lt;/span&gt;&lt;span&gt;P9/P10 &lt;/span&gt;&lt;span&gt;这个级别相比。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二，他们都是总决策者。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在一个剧组里，一般情况下导演拥有绝对的话语权。同样地，虽然 P6 可以指导别人，&lt;/span&gt;&lt;span&gt;P7/P8 &lt;/span&gt;&lt;span&gt;可以带团队，但工作仍然在很大程度上受到制约，关键的目标制定、资源整合和关键&lt;/span&gt;&lt;span&gt;决策的工作，还是得由 &lt;/span&gt;&lt;span&gt;P9/P10 &lt;/span&gt;&lt;span&gt;来完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体一点说，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;P9/P10 需要制定有挑战的业务目标；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;整合不同的团队，包括多个技术团&lt;/span&gt;&lt;span&gt;队（比如 &lt;/span&gt;&lt;span&gt;Android&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;iOS&lt;/span&gt;&lt;span&gt;、前端、&lt;/span&gt;&lt;span&gt;Java &lt;/span&gt;&lt;span&gt;后端、测试、运维等）和多个业务团队（比如腾讯的&lt;/span&gt;&lt;span&gt;广告平台的某个业务，可能涉及 &lt;/span&gt;&lt;span&gt;QQ&lt;/span&gt;&lt;span&gt;、微信和应用宝等多个业务团队）；做出关键决策（例&lt;/span&gt;&lt;span&gt;如要做什么、不做什么、先做什么和后做什么）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三，他们都是总负责人。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一部电影作品会打上导演的烙印，甚至呈现出强烈的导演个人风格。电影拍得不好，&lt;/span&gt;&lt;span&gt;观众首先批评的就是导演；拍得好，赞美和荣誉也首先给到导演身上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同样地，P9/P10 的水平、眼界、价值观和做事风格，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;直接决定了一条业务线的质量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;因为这些因素会体现在工作过程中的各种决策里面，决定了最终的呈现效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，导演往往有自己擅长的题材，比如文艺片、喜剧片；而 P9/P10 一般也都聚焦于&lt;/span&gt;&lt;span&gt;某个业务或者专业领域，比如电商业务、出行业务、安全领域、算法领域，很少有跨领域&lt;/span&gt;&lt;span&gt;样样精通的人才。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;P9 和 P10 的核心差异在于成果质量。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;还是以电影导演来类比，P9 是成熟的导演，能&lt;/span&gt;&lt;span&gt;拍出 7 分以上的作品（基本合格）；P10 是成名的导演，能拍出 8 分以上的作品（比较优&lt;/span&gt;&lt;span&gt;质）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然对于 P9/P10 的工作成果，并没有一个通用的打分机制，但是公司能通过一些硬指&lt;/span&gt;&lt;span&gt;标来衡量，最典型的就是直接看业务结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你负责的业务结果实现了既定的业务目标，那么你就是成熟的导演，可以胜任 P9；&lt;/span&gt;&lt;span&gt;如果你负责的业务结果按照某个标准（用户量、收入和权威机构的测评等），进入了业界&lt;/span&gt;&lt;span&gt;前列，有一定的名气和影响力，那么你就是成名的导演，可以胜任 P10。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;P9/P10 的核心职责如下表所示。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8784530386740331&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kLDUqiaAMQafH2icPM4icClrkbSBkKKVHYzViagVIPAaDH4djDPX6woLUYGV4B0W73PKotCc5YrbDL1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;543&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;这些类比有什么用&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文使用了&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;“专业工匠”“乐团指挥”和“电影导演”&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;三种形象来类比不同的职级档次，但这仅仅是针对职责的相似度来说的。这种档次划分对应了行政级别的高低，但不代表艺术成就的高低。比如 P9/P10 的级别高于 P8/P7，但并不意味着电影导演的艺术成就一定高于乐团指挥。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之所以要把职级档次与你熟悉的职业角色建立联系，是希望&lt;strong&gt;通过形象思维的方式帮助你快速建立对每个级别的具体认知。&lt;/strong&gt;以后我们再说到某个级别的时候，你就能迅速了解它的核心要求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意的是，本章的类比只是宏观层面的特征提炼。如果你想了解每个级别能力的细节要求，还是需要参考职级详解部分关于每个级别的详细解读。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后推荐&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《互联网大厂晋升指南：从P5到P9的升级攻略》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;这本书给在互联网职场拼搏中的你。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这本书针对晋升需求为你&lt;/span&gt;&lt;span&gt;介绍了一套系统的晋升方法论，涵盖“理解晋升→准备晋升→参与晋升→获得晋升”这条完整的晋升链条，深入剖析了晋升背后的规则、“潜规则”、技巧和套路，以便帮你找到正确的发力点，顺利通过晋升，获得更好的职业发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PW0wIHxgg3kFra98vflticZia2VkcsFaePvn80lFRYLHeZa5V84XiaskrRJiaV9StVdRIPhPRdctAicu5cpHNlhz5eA/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; data-type=&quot;gif&quot; data-w=&quot;55&quot; data-width=&quot;10%&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6621621621621622&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3kFra98vflticZia2VkcsFaePbKsfJXpVgL3aDtic7UIm15qWB20r64HzAWFlsLiaD4GroAolwnd5EZUg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;740&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;P5提升攻略：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如何快速从学生转变为“打工人”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;P6提升攻略：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如何成为独立自主的“项目能手”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;P7提升攻略：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如何成为让人信服的“团队专家”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;P8提升攻略：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如何成为有影响力的“领域专家”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;P9提升攻略：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如何成为跨域整合的“业务导演”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;阿里&lt;span&gt;前&lt;/span&gt;资深技术专家李运华把这些干货都写在了这本升职秘籍里……&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.0329113924050635&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3kFra98vflticZia2VkcsFaePzP73icuiasuibMVflcJSPTazGDNZx43SPeWYUIxxvcv16k8InCsKIoojA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;790&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，这里也给大家争取到了本书的&lt;/span&gt;&lt;strong&gt;全网最低价&lt;/strong&gt;&lt;span&gt;，扫码或点击阅读原文都可以去京东下单，有晋升需求的你冲就行了！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kFra98vflticZia2VkcsFaePQyuhoFW83GmvDniaImP4h8XRDlryG2WdcP69d8uDQFbcowLNyxAVUFg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;粉丝专享五折，快快扫码抢购吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发布：刘恩惠&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;审核：陈歆懿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Puv74VHDtgNjyJbpQvt1gicgSpjrlpDy6BheYoAmtjiaF7cdIuPkuUlFkw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1920&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;29.8961937716263&quot; data-ratio=&quot;0.01574074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Pu8DQL5f0FQIuDZC87yrAuNLy4frEdlMeWkthrlzczb0RbMOBQCAwDrA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如果喜欢本文&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;欢迎&lt;/span&gt; &lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;留言&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享至朋友圈&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 三连&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;92644&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt; &lt;strong&gt;热文推荐 &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;574&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;244&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3m3jibtjia3lCrCvUY6N19QMZ3FjCcpuHouXkdLicQVUiaLicgR8cgSbk7RA8G427GKowhbEvVefuJp53g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▼点击阅读原文，了解本书详情~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0cd857d3dcfe4b3be45b56276bd8ac33</guid>
<title>Rust 太难？那是你没看到这套 Rust 语言学习总结（上）</title>
<link>https://toutiao.io/k/8w3ph2c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;cloud-blog-detail-content blog-content-block-0&quot; id=&quot;blogContent&quot;&gt;&amp;#13;
            &lt;h1&gt;&lt;b&gt;&lt;span&gt;一、&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;开发环境指南&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span&gt; 1.1 Rust&lt;/span&gt;&lt;span&gt;代码执行&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据编译原理知识，编译器不是直接将源语言翻译为目标语言，而是翻译为一种&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;中间语言&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，编译器从业人员称之为&lt;/span&gt;&lt;span&gt;“IR”--&lt;/span&gt;&lt;span&gt;指令集，之后再由中间语言，利用后端程序和设备翻译为目标平台的汇编语言。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;代码执行：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;代码经过分词和解析，生成&lt;/span&gt;&lt;span&gt;AST&lt;/span&gt;&lt;span&gt;（抽象语法树）。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2)&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;然后把&lt;/span&gt;&lt;span&gt;AST&lt;/span&gt;&lt;span&gt;进一步简化处理为&lt;/span&gt;&lt;span&gt;HIR&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;High-level IR&lt;/span&gt;&lt;span&gt;），目的是让编译器更方便的做类型检查。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3)&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;HIR&lt;/span&gt;&lt;span&gt;会进一步被编译为&lt;/span&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Middle IR&lt;/span&gt;&lt;span&gt;），这是一种中间表示，主要目的是：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;a)&lt;/span&gt;&lt;span/&gt;&lt;span&gt;缩短编译时间；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;b)&lt;/span&gt;&lt;span/&gt;&lt;span&gt;缩短执行时间；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;c)&lt;/span&gt;&lt;span/&gt;&lt;span&gt;更精确的类型检查。&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;4)&lt;/span&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;最终&lt;/span&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;会被翻译为&lt;/span&gt;&lt;span&gt;LLVM IR&lt;/span&gt;&lt;span&gt;，然后被&lt;/span&gt;&lt;span&gt;LLVM&lt;/span&gt;&lt;span&gt;的处理编译为能在各个平台上运行的目标机器码。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;IR&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：中间语言&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;HIR&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：高级中间语言&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：中级中间语言&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;LLVM &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;Low Level Virtual Machine&lt;/span&gt;&lt;span&gt;，底层虚拟机。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;LLVM&lt;/span&gt;&lt;span&gt;是构架&lt;/span&gt;&lt;u&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;span&gt;编译器&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/u&gt;&lt;span&gt;(compiler)&lt;/span&gt;&lt;span&gt;的框架系统，以&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;编写而成，用于优化以任意程序语言编写的程序的编译时间&lt;/span&gt;&lt;span&gt;(compile-time)&lt;/span&gt;&lt;span&gt;、链接时间&lt;/span&gt;&lt;span&gt;(link-time)&lt;/span&gt;&lt;span&gt;、运行时间&lt;/span&gt;&lt;span&gt;(run-time)&lt;/span&gt;&lt;span&gt;以及空闲时间&lt;/span&gt;&lt;span&gt;(idle-time)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无疑，不同编译器的中间语言&lt;/span&gt;&lt;span&gt;IR&lt;/span&gt;&lt;span&gt;是不一样的，而&lt;/span&gt;&lt;span&gt;IR&lt;/span&gt;&lt;span&gt;可以说是集中体现了这款编译器的特征：他的算法，优化方式，汇编流程等等，想要完全掌握某种编译器的工作和运行原理，分析和学习这款编译器的中间语言无疑是重要手段。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于中间语言相当于一款编译器前端和后端的&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;桥梁&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，如果我们想进行基于&lt;/span&gt;&lt;span&gt;LLVM&lt;/span&gt;&lt;span&gt;的后端移植，无疑需要开发出对应目标平台的编译器后端，想要顺利完成这一工作，透彻了解&lt;/span&gt;&lt;span&gt;LLVM&lt;/span&gt;&lt;span&gt;的中间语言无疑是非常必要的工作。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LLVM&lt;/span&gt;&lt;span&gt;相对于&lt;/span&gt;&lt;span&gt;gcc&lt;/span&gt;&lt;span&gt;的一大改进就是大大提高了中间语言的生成效率和可读性，&lt;/span&gt;&lt;span&gt; LLVM&lt;/span&gt;&lt;span&gt;的中间语言是一种介于&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;语言和汇编语言的格式，他既有高级语言的可读性，又能比较全面地反映计算机底层数据的运算和传输的情况，精炼而又高效。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;b&gt;&lt;span&gt;1.1.1&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;  &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;是基于控制流图（&lt;/span&gt;&lt;span&gt;Control Flow Graph&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;CFG&lt;/span&gt;&lt;span&gt;）的抽象数据结构，它用&lt;/span&gt;&lt;span&gt;有向图（&lt;/span&gt;&lt;span&gt;DAG&lt;/span&gt;&lt;span&gt;）形式包含了程序执行过程中所有可能的流程&lt;/span&gt;&lt;span&gt;。所以将基于&lt;/span&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;的借用检查称为非词法作用域的生命周期。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;由一下关键部分组成：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;基本块（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Basic block&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;，&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;bb&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，他是控制流图的基本单位，&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;语句（&lt;/span&gt;&lt;span&gt;statement&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;终止句（&lt;/span&gt;&lt;span&gt;Terminator&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;本地变量&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，占中内存的位置，比如函数参数、局部变量等。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;位置（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Place&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，在内存中标识未知的额表达式。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;右值（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;RValue&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，产生值的表达式。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的工作原理见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以在&lt;/span&gt;&lt;span&gt;play.runst-lang.org&lt;/span&gt;&lt;span&gt;中生成&lt;/span&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;代码。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;b&gt;&lt;span&gt;1.1&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;安装&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span&gt;Ø&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;方法一：见&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;官方的&lt;/span&gt;&lt;u&gt;&lt;span&gt;&lt;a rel=&quot;nofollow&quot;&gt;installation&lt;span&gt;章节&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/u&gt;&lt;span&gt;介绍。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上就是调用该命令来安装即可：&lt;/span&gt;&lt;b&gt;&lt;span&gt;curl https://sh.rustup.rs -sSf | sh&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;方法二：下载离线的安装包来安装，具体的可见&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;官方的&lt;/span&gt;&lt;u&gt;&lt;span&gt;&lt;a rel=&quot;nofollow&quot;&gt;Other Rust Installation Methods&lt;span&gt;章节&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/u&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;b&gt;&lt;span&gt;1.2 Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;编译&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;运行&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;1.2.1 Cargo&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;包管理&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中的包管理工具，第三方包叫做&lt;/span&gt;&lt;b&gt;&lt;span&gt;crate&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;/b&gt;&lt;span&gt;一共做了四件事：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;使用两个元数据（&lt;/span&gt;&lt;b&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;/b&gt;&lt;span&gt;）文件来记录各种项目信息&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;获取并构建项目的依赖关系&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;使用正确的参数调用&lt;/span&gt;&lt;b&gt;&lt;span&gt;rustc&lt;/span&gt;&lt;/b&gt;&lt;span&gt;或其他构建工具来构建项目&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;生态系统开发建议了统一标准的工作流&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;b&gt;&lt;span&gt;文件：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Cargo.lock&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：只记录依赖包的详细信息，不需要开发者维护，而是由&lt;/span&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;span&gt;自动维护&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Cargo.toml&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：描述项目所需要的各种信息，包括第三方包的依赖&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;cargo&lt;/span&gt;&lt;span&gt;编译默认为&lt;/span&gt;&lt;b&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;/b&gt;&lt;span&gt;模式，在该模式下编译器不会对代码进行任何优化。也可以使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;--release&lt;/span&gt;&lt;/b&gt;&lt;span&gt;参数来使用发布模式。&lt;/span&gt;&lt;b&gt;&lt;span&gt;release&lt;/span&gt;&lt;/b&gt;&lt;span&gt;模式，编译器会对代码进行优化，使得编译时间变慢，但是代码运行速度会变快。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官方编译器&lt;/span&gt;&lt;b&gt;&lt;span&gt;rustc&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，负责将&lt;/span&gt;&lt;span&gt;rust&lt;/span&gt;&lt;span&gt;源码编译为可执行的文件或其他文件（&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;.so&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;.lib&lt;/span&gt;&lt;span&gt;等）。例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt;rustc box.rs&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;还提供了包管理器&lt;/span&gt;&lt;b&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来管理整个工作流程。例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo new &lt;/span&gt;&lt;/b&gt;&lt;span&gt;first_pro_create&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建名为&lt;/span&gt;&lt;span&gt;first_pro_create&lt;/span&gt;&lt;span&gt;的项目&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo new --lib &lt;/span&gt;&lt;/b&gt;&lt;span&gt;first_lib_create&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建命令&lt;/span&gt;&lt;span&gt;first_lib_create&lt;/span&gt;&lt;span&gt;的库项目&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;cargo doc&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;l&lt;/span&gt;&lt;b&gt;&lt;span&gt;cargo doc --open&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo test&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo test -- --test-threads=1&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo build&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo build --release&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo run&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo install --path&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo uninstall &lt;/span&gt;&lt;/b&gt;&lt;span&gt;first_pro_create&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo new –bin use_regex&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;&lt;img class=&quot;mce_image lazyload&quot; id=&quot;images_160915033098778&quot; src=&quot;https://res.hc-cdn.com/ecology/7.9.205/v2_resources/ydcomm/libs/images/loading.gif&quot; data-src=&quot;https://bbs-img.huaweicloud.com/blogs/img/1609150332903039875.png&quot; referrerpolicy=&quot;no-referrer&quot;/&gt;&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&lt;img class=&quot;mce_image lazyload&quot; id=&quot;images_160915034091142&quot; src=&quot;https://res.hc-cdn.com/ecology/7.9.205/v2_resources/ydcomm/libs/images/loading.gif&quot; data-src=&quot;https://bbs-img.huaweicloud.com/blogs/img/1609150341600035174.png&quot; referrerpolicy=&quot;no-referrer&quot;/&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;1.2.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;使用第三方包&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;可以在&lt;/span&gt;&lt;b&gt;&lt;span&gt;Cargo.toml&lt;/span&gt;&lt;/b&gt;&lt;span&gt;中的&lt;/span&gt;&lt;b&gt;&lt;span&gt;[dependencies]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;下添加想依赖的包来使用第三方包。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后在&lt;/span&gt;&lt;b&gt;&lt;span&gt;src/main.rs&lt;/span&gt;&lt;/b&gt;&lt;span&gt;或&lt;/span&gt;&lt;b&gt;&lt;span&gt;src/lib.rs&lt;/span&gt;&lt;/b&gt;&lt;span&gt;文件中，使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;extern crate&lt;/span&gt;&lt;/b&gt;&lt;span&gt;命令声明引入该包即可使用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;mce_image lazyload&quot; id=&quot;images_160915035931413&quot; src=&quot;https://res.hc-cdn.com/ecology/7.9.205/v2_resources/ydcomm/libs/images/loading.gif&quot; data-src=&quot;https://bbs-img.huaweicloud.com/blogs/img/1609150360012033321.png&quot; referrerpolicy=&quot;no-referrer&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;值得注意的是，使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;extern crate&lt;/span&gt;&lt;/b&gt;&lt;span&gt;声明包的名称是&lt;/span&gt;&lt;span&gt;linked_list&lt;/span&gt;&lt;span&gt;，用的是&lt;/span&gt;&lt;b&gt;&lt;span&gt;下划线&lt;/span&gt;&lt;/b&gt;&lt;span&gt;“&lt;/span&gt;&lt;b&gt;&lt;span&gt;_&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”，而在&lt;/span&gt;&lt;span&gt;Cargo.toml&lt;/span&gt;&lt;span&gt;中用的是&lt;/span&gt;&lt;b&gt;&lt;span&gt;连字符&lt;/span&gt;&lt;/b&gt;&lt;span&gt;“&lt;/span&gt;&lt;b&gt;&lt;span&gt;-&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”。其实&lt;/span&gt;&lt;b&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;默认会把&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;连字符&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;转换成&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;下划线&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;也不建议以“&lt;/span&gt;&lt;b&gt;&lt;span&gt;-rs&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”或“&lt;/span&gt;&lt;b&gt;&lt;span&gt;_rs&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”为后缀来命名包名，而且会强制性的将此后缀去掉。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;323&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;b&gt;&lt;span&gt;1.4 Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;常用命令&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;b&gt;&lt;span&gt;1.5 Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;命令规范&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;蛇形&lt;/span&gt;&lt;span&gt;命名法（&lt;/span&gt;&lt;span&gt;snake_case&lt;/span&gt;&lt;span&gt;），例如：&lt;/span&gt;&lt;span&gt;func_name()&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;文件名&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;蛇形&lt;/span&gt;&lt;span&gt;命名法（&lt;/span&gt;&lt;span&gt;snake_case&lt;/span&gt;&lt;span&gt;），例如&lt;/span&gt;&lt;span&gt;file_name.rs&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;main.rs&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;临时变量名&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;蛇形&lt;/span&gt;&lt;span&gt;命名法（&lt;/span&gt;&lt;span&gt;snake_case&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;全局变量名&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;结构体&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;大驼峰&lt;/span&gt;&lt;span&gt;命名法，例如：&lt;/span&gt;&lt;span&gt;struct FirstName { name: String}&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;enum&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;:  &lt;/span&gt;&lt;span&gt;大驼峰&lt;/span&gt;&lt;span&gt;命名法。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;关联常量&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：常量名必须全部大写。什么是关联常量见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;span&gt;默认会把&lt;/span&gt;&lt;b&gt;&lt;span&gt;连字符&lt;/span&gt;&lt;/b&gt;&lt;span&gt;“&lt;/span&gt;&lt;b&gt;&lt;span&gt;-&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”转换成&lt;/span&gt;&lt;b&gt;&lt;span&gt;下划线&lt;/span&gt;&lt;/b&gt;&lt;span&gt;“&lt;/span&gt;&lt;b&gt;&lt;span&gt;_&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;也不建议以“&lt;/span&gt;&lt;b&gt;&lt;span&gt;-rs&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”或“&lt;/span&gt;&lt;b&gt;&lt;span&gt;_rs&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”为后缀来命名包名，而且会强制性的将此后缀去掉。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;h1&gt;&lt;b&gt;&lt;span&gt;二、&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;语法&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;疑问&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.1.1 Copy&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;语义&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; &amp;amp;&amp;amp; Move&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;语义（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Move&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;语义必须转移所有权）&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;类型越来越丰富，值类型和引用类型难以描述全部情况，所以引入了：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;复制以后，两个数据对象拥有的存储空间是独立的，互不影响。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;基本的&lt;/span&gt;&lt;/b&gt;&lt;span&gt;原生类型&lt;/span&gt;&lt;b&gt;&lt;span&gt;都是&lt;/span&gt;&lt;/b&gt;&lt;span&gt;值语义&lt;/span&gt;&lt;span&gt;，这些类型也被称为&lt;/span&gt;&lt;span&gt;POD&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Plain old data&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span&gt;POD&lt;/span&gt;&lt;span&gt;类型都是值语义，但是值语义类型并不一定都是&lt;/span&gt;&lt;span&gt;POD&lt;/span&gt;&lt;span&gt;类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;具有值语义的原生类型，在其作为右值进行赋值操作时，编译器会对其进行按位复制&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;复制以后，两个数据对象互为别名。操作其中任意一个数据对象，则会影响另外一个。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;智能指针&lt;/span&gt;&lt;b&gt;&lt;span&gt;Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;封装了原生指针，是典型的引用类型。&lt;/span&gt;&lt;b&gt;&lt;span&gt;Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;无法实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;，意味着它被&lt;/span&gt;&lt;span&gt;rust&lt;/span&gt;&lt;span&gt;标记为了&lt;/span&gt;&lt;b&gt;&lt;span&gt;引用语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，禁止按位复制。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用语义类型不能实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;，但可以实现&lt;/span&gt;&lt;span&gt;Clone&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;clone&lt;/span&gt;&lt;span&gt;方法，以实现深复制。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中，可以通过&lt;/span&gt;&lt;span&gt;是否实现&lt;/span&gt;&lt;span&gt;Copy trait&lt;/span&gt;&lt;span&gt;来区分&lt;/span&gt;&lt;span&gt;数据类型的&lt;/span&gt;&lt;b&gt;&lt;span&gt;值语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;引用语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。但为了更加精准，&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;也引用了新的语义：&lt;/span&gt;&lt;b&gt;&lt;span&gt;复制（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;移动（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Move&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：对应值语义，即实现了&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;的类型在进行按位复制时是安全的。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Move&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：对应引用语义。在&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中不允许按位复制，&lt;/span&gt;&lt;b&gt;&lt;span&gt;只允许移动所有权&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.1.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;结构体&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：当成员都是复制语义类型时，不会自动实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;枚举体&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：当成员都是复制语义类型时，不会自动实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;结构体&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &amp;amp;&amp;amp; &lt;/span&gt;&lt;b&gt;&lt;span&gt;枚举体&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1)&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;所有成员都是复制语义类型时，需要添加属性&lt;/span&gt;&lt;b&gt;&lt;span&gt;#[derive(Debug,Copy,Clone)]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2)&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;如果有移动语义类型的成员，则无法实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;元组类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：本身实现了&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。如果元素均为复制语义类型，则默认是按位复制，否则执行移动语义。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;字符串字面量&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; &amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;支持按位复制。例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt;c = “hello”;&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;则&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;就是字符串字面量。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.1.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些未实现&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;字符串对象&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;String &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;b&gt;&lt;span&gt;to_string() &lt;/span&gt;&lt;/b&gt;&lt;span&gt;可以将字符串字面量转换为字符串对象。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.1.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Copy trait&lt;/span&gt;&lt;/b&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;对于实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;的类型，其&lt;/span&gt;&lt;span&gt;clone&lt;/span&gt;&lt;span&gt;方法只需要简单的实现按位复制即可。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.1.5 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些未实现&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Copy trait&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Copy trait&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;，有什么作用？&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;Copy trait&lt;/span&gt;&lt;span&gt;的类型同时拥有&lt;/span&gt;&lt;span&gt;复制语义&lt;/span&gt;&lt;span&gt;，在进行赋值或者传入函数等操作时，默认会进行&lt;/span&gt;&lt;span&gt;按位复制&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;对于默认可以安全的在栈上进行按位复制的类型，就只需要按位复制，也&lt;/span&gt;&lt;span&gt;方便管理内存&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;对于默认只可在堆上存储的数据，必须进行&lt;/span&gt;&lt;span&gt;深度复制&lt;/span&gt;&lt;span&gt;。深度复制需要&lt;/span&gt;&lt;span&gt;在堆内存中重新开辟空间，这会带来更多的性能开销&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.1.6 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些是在栈上的？哪些是在堆上的？&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.1.7 let&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;绑定&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;声明的&lt;/span&gt;&lt;b&gt;&lt;span&gt;绑定默认为不可变&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果需要修改，可以用&lt;/span&gt;&lt;b&gt;&lt;span&gt;mut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来声明绑定是可变的。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;数据类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;很多编程语言中的数据类型是分为两类：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一般是指可以将数据都保存在同一位置的类型。例如数值、布尔值、结构体等都是值类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;值类型有：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;引用类型&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;会存在一个指向实际存储区的指针。比如通常一些引用类型会将数据存储在堆中，而栈中只存放指向堆中数据的地址（指针）。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;引用类型有：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;基本数据类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;布尔类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;类型只有两个值：&lt;/span&gt;&lt;b&gt;&lt;span&gt;true&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;false&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;基本数字类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要关注取值范围，具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;字符类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;用&lt;/span&gt;&lt;b&gt;&lt;span&gt;单引号&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来定义字符（&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;）类型。字符类型代表一个&lt;/span&gt;&lt;b&gt;&lt;span&gt;Unicode&lt;/span&gt;&lt;/b&gt;&lt;span&gt;标量值，每个字节占&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;个字节。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;数组类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;数组的类型签名为&lt;/span&gt;&lt;b&gt;&lt;span&gt;[T; N]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;b&gt;&lt;span&gt;T&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是一个泛型标记，代表数组中元素的某个具体类型。&lt;/span&gt;&lt;b&gt;&lt;span&gt;N&lt;/span&gt;&lt;/b&gt;&lt;span&gt;代表数组长度，在编译时必须确定其值。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组特点：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;切片类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;切片（&lt;/span&gt;&lt;span&gt;Slice&lt;/span&gt;&lt;span&gt;）类型是对一个数组的引用片段。在底层，切片代表一个指向数组起始位置的指针和数组长度。用&lt;/span&gt;&lt;b&gt;&lt;span&gt;[T]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型表示连续序列，那么切片类型就是&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;[T]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;mut[T]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;str&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;字符串类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串类型&lt;/span&gt;&lt;b&gt;&lt;span&gt;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，通常是以&lt;/span&gt;&lt;span&gt;不可变借用&lt;/span&gt;&lt;span&gt;的形式存在，即&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;（字符串切片）。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;将字符串分为两种：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1)&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：固定长度字符串&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2)&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;String&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：可以随意改变其长度。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;字符串类型由两部分组成：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;指向字符串序列的指针；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;记录长度的值。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;存储于&lt;/span&gt;&lt;span&gt;栈&lt;/span&gt;&lt;span&gt;上，&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;字符串序列存储于程序的&lt;/span&gt;&lt;span&gt;静态只读数据段&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;堆内存&lt;/span&gt;&lt;span&gt;中。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是一种&lt;/span&gt;&lt;b&gt;&lt;span&gt;胖指针&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;never&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;never&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型，即&lt;/span&gt;&lt;b&gt;&lt;span&gt;!&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。该类型用于表示永远不可能有返回值的计算类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;其他（此部分不属于基本数据类型）&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此部分不属于基本数据类型，由于编排问题，暂时先放在此处。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;胖指针&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;胖指针&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：包含了动态&lt;/span&gt;&lt;span&gt;大小类型地址信息&lt;/span&gt;&lt;span&gt;和携带了&lt;/span&gt;&lt;span&gt;长度信息&lt;/span&gt;&lt;span&gt;的指针。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;零大小类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;零大小类型（&lt;/span&gt;&lt;span&gt;Zero sized Type&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;ZST&lt;/span&gt;&lt;span&gt;）的特点是：&lt;/span&gt;&lt;span&gt;它们的值就是其本身，运行时并不占用内存空间&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;单元类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;单元结构体&lt;/span&gt;&lt;/b&gt;&lt;span&gt;大小为零，由单元类型组成的数组大小也是零。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ZST&lt;/span&gt;&lt;span&gt;类型代表的意义是“&lt;/span&gt;&lt;b&gt;&lt;span&gt;空&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;底类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;底类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;其实是介绍过的&lt;/span&gt;&lt;b&gt;&lt;span&gt;never&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型，用&lt;/span&gt;&lt;b&gt;&lt;span&gt;叹号&lt;/span&gt;&lt;/b&gt;&lt;span&gt;（&lt;/span&gt;&lt;b&gt;&lt;span&gt;!&lt;/span&gt;&lt;/b&gt;&lt;span&gt;）表示。它的特点是：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果说&lt;/span&gt;&lt;span&gt;ZST&lt;/span&gt;&lt;span&gt;类型表示“&lt;/span&gt;&lt;b&gt;&lt;span&gt;空&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”的话，那么底类型就表示“&lt;/span&gt;&lt;b&gt;&lt;span&gt;无&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;底类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;无值，而且它可以&lt;/span&gt;&lt;span&gt;等价于任意类型&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;复合数据类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;元组&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;提供了&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;中复合数据类型：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;元组（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Tuple&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;结构体（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Struct&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;枚举体（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Enum&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;联合体（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Union&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;先来介绍元组。&lt;/span&gt;&lt;b&gt;&lt;span&gt;元组&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是一种&lt;/span&gt;&lt;span&gt;异构有限&lt;/span&gt;&lt;span&gt;序列，形如&lt;/span&gt;&lt;b&gt;&lt;span&gt;(T,U,M,N)&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。所谓异构，就是指元组内的元素&lt;/span&gt;&lt;span&gt;可以是不同类型&lt;/span&gt;&lt;span&gt;。所谓有限，是指元组有固定的长度。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;空元组&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;()&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;只有一个值时，需要加逗号：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;(0,)&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;结构体&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;提供了&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;中结构体：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;struct People {      &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    name: &amp;amp;’static str,&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;}                       &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;struct Color(i32, i32, i32);&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个元组结构体只有一个字段的时候，称为&lt;/span&gt;&lt;b&gt;&lt;span&gt;New Type&lt;/span&gt;&lt;/b&gt;&lt;span&gt;模式。例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;struct Integer(u32);&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;单元结构体&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：没有任何字段的结构体。单元结构体实例就是其本身。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;struct Empty;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;结构体更新语法&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;Struct&lt;/span&gt;&lt;span&gt;更新语法（&lt;/span&gt;&lt;b&gt;&lt;span&gt;..&lt;/span&gt;&lt;/b&gt;&lt;span&gt;）从其他实例创建新实例。当新实例使用旧实例的大部分值时，可以使用&lt;/span&gt;&lt;span&gt;struct update&lt;/span&gt;&lt;span&gt;语法。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td valign=&quot;top&quot;&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;#[derive(Debug,Copy,Clone)]&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;struct Book&amp;lt;’a&amp;gt; {&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;name: &amp;amp;’a str,&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;isbn:  i32,&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;version: i32,&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;}&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;let book = Book {&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;    name: “Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;编程之道&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;”,  isbn: 20181212, version: 1&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;};&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;let book2 = Book {version: 2, &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;..&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;book};&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt; &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;如果结构体使用了移动语义的成员字段，则不允许实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;不允许包含了&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;类型字段的结构体实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;更新语法会转移字段的所有权。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;枚举体&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;该类型包含了全部可能的情况，可以有效的&lt;/span&gt;&lt;span&gt;防止用户提供无效值&lt;/span&gt;&lt;span&gt;。例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;enum Number {&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    Zero,   &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    One,    &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;}             &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Rust&lt;/span&gt;&lt;span&gt;还支持携带类型参数的枚举体。这样的枚举值本质上属于函数类型，他可以通过显式的指定类型来转换为函数指针类型。例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;enum IpAddr {          &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    V4(u8, u8, u8, u8),&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    V6(String),         &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;}                        &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;枚举体在&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中属于非常重要的类型之一。例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt;Option&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;枚举&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;联合体&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;常用集合类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;线性序列：向量&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;标准库&lt;/span&gt;&lt;span&gt;std::collections&lt;/span&gt;&lt;span&gt;模块下有&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;中通用集合类型，分别如下：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;线性序列&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;b&gt;&lt;span&gt;向量（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Vec&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;双端队列（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;VecDeque&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;链表（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;LinkedList&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Key-Value&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;映射表&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;b&gt;&lt;span&gt;无序哈希表（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;有序映射表（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;BTreeMap&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;集合类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;b&gt;&lt;span&gt;无序集合（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;有序集合（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;BTreeSet&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;优先队列&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;b&gt;&lt;span&gt;二叉堆（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;BinaryHeap&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;&lt;span&gt;页和&lt;/span&gt;&lt;span&gt;271&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;向量也是一种数组，和基本数据类型中的数组的区别在于：&lt;/span&gt;&lt;b&gt;&lt;span&gt;向量可动态增长&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;let mut v1 = &lt;/span&gt;&lt;b&gt;&lt;span&gt;vec![];&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;let mut v2 = &lt;/span&gt;&lt;b&gt;&lt;span&gt;vec![0; 10];&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;let mut v3 = &lt;/span&gt;&lt;b&gt;&lt;span&gt;Vec::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;vec!&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是一个宏，用来创建向量字面量。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;线性序列：双端队列&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;双端队列（&lt;/span&gt;&lt;span&gt;Double-ended Queue&lt;/span&gt;&lt;span&gt;，缩写&lt;/span&gt;&lt;span&gt;Deque&lt;/span&gt;&lt;span&gt;）是一种同时具有队列（先进先出）和栈（后进先出）性质的数据结构。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;双端队列中的元素可以从两端弹出，插入和删除操作被限定在队列的两端进行。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;use std::collections::VecDeque;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;let mut buf = &lt;/span&gt;&lt;b&gt;&lt;span&gt;VecDeque::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;buf.push_front(1);             &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;buf.get(0);                    &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;buf.push_back(2);             &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;线性序列：链表&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Rust&lt;/span&gt;&lt;span&gt;提供的链表是双向链表，允许在任意一端插入或弹出元素。最好使用&lt;/span&gt;&lt;span&gt;Vec&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;VecDeque&lt;/span&gt;&lt;span&gt;类型，他们比链表更加快速，内存访问效率更高。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;use std::collections::LinkedList;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;let mut list = LinkedList::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;list.push_front(‘a’);             &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;list.append(&amp;amp;mut list2);         &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;list.push_back(‘b’);             &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Key-Value&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;映射表：&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;和&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;BTreeMap&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;     =&amp;gt; &lt;/span&gt;&lt;span&gt;无序&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;BTreeMap&amp;lt;K, V&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;   =&amp;gt; &lt;/span&gt;&lt;span&gt;有序&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;要求&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;是必须&lt;/span&gt;&lt;span&gt;可哈希&lt;/span&gt;&lt;span&gt;的类型，&lt;/span&gt;&lt;span&gt;BTreeMap&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;必须是&lt;/span&gt;&lt;span&gt;可排序&lt;/span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;必须是&lt;/span&gt;&lt;span&gt;在编译期已知大小&lt;/span&gt;&lt;span&gt;的类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;use std::collections::BTreeMap;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;use std::collections::HashMap;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;let mut hmap = HashMap::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;let mut bmap = BTreeMap::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;hmap.insert(1,”a”);           &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;bmap.insert(1,”a”);           &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;集合：&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;和&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;BTreeSet&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;HashSet&amp;lt;K&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;BTreeSet&amp;lt;K&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;其实就是&lt;/span&gt;&lt;b&gt;&lt;span&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;BTreeMap&amp;lt;K, V&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;把&lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;设置为&lt;/span&gt;&lt;b&gt;&lt;span&gt;空元组&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的特定类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;集合中的元素应该是&lt;/span&gt;&lt;span&gt;唯一&lt;/span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;/b&gt;&lt;span&gt;中的元素都是&lt;/span&gt;&lt;span&gt;可哈希&lt;/span&gt;&lt;span&gt;的类型，&lt;/span&gt;&lt;b&gt;&lt;span&gt;BTreeSet&lt;/span&gt;&lt;/b&gt;&lt;span&gt;中的元素必须是&lt;/span&gt;&lt;span&gt;可排序&lt;/span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;/b&gt;&lt;span&gt;应该是&lt;/span&gt;&lt;span&gt;无序&lt;/span&gt;&lt;span&gt;的，&lt;/span&gt;&lt;b&gt;&lt;span&gt;BTreeSet&lt;/span&gt;&lt;/b&gt;&lt;span&gt;应该是&lt;/span&gt;&lt;span&gt;有序&lt;/span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;use std::collections::BTreeSet;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;use std::collections::HashSet;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;let mut hset = HashSet::new();  &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;let mut bset = BTreeSet::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;hset.insert(”This is a hset.”);&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;bset.insert(”This is a bset”);&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;优先队列：&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;BinaryHeap&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;提供的优先队列是基于&lt;/span&gt;&lt;b&gt;&lt;span&gt;二叉最大堆（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Binary Heap&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;实现的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;use std::collections::BinaryHeap;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;let mut heap = BinaryHeap::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;heap.peek();                           &lt;/span&gt;&lt;/b&gt;&lt;span&gt;=&amp;gt; peek&lt;/span&gt;&lt;span&gt;是取出堆中最大的元素&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;heap.push(98);                     &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;容量（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Capacity&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）和大小（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Size/Len&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无论是&lt;/span&gt;&lt;span&gt;Vec&lt;/span&gt;&lt;span&gt;还是&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;，使用这些集合容器类型，最重要的是理解&lt;/span&gt;&lt;b&gt;&lt;span&gt;容量（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Capacity&lt;/span&gt;&lt;/b&gt;&lt;span&gt;）和&lt;/span&gt;&lt;b&gt;&lt;span&gt;大小（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Size/Len&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;容量&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是指为集合容器分配的&lt;/span&gt;&lt;span&gt;内存容量&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;大小&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是指集合中包含的&lt;/span&gt;&lt;span&gt;元素数量&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.2.4 Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;字符串&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;字符串分为以下几种类型：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示固定长度的字符串&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;String&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示可增长的字符串&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;CStr&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示由&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;分配而被&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;借用的字符串。这是为了兼容&lt;/span&gt;&lt;span&gt;windows&lt;/span&gt;&lt;span&gt;系统。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;CString&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示由&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;分配且可以传递给&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;函数使用的&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;字符串，同样用于和&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;语言交互。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;OsStr&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示和操作系统相关的字符串。这是为了兼容&lt;/span&gt;&lt;span&gt;windows&lt;/span&gt;&lt;span&gt;系统。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;OsString&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示&lt;/span&gt;&lt;span&gt;OsStr&lt;/span&gt;&lt;span&gt;的可变版本。与&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;字符串可以相互交换。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;Path&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示路径，定义于&lt;/span&gt;&lt;span&gt;std::path&lt;/span&gt;&lt;span&gt;模块中。&lt;/span&gt;&lt;span&gt;Path&lt;/span&gt;&lt;span&gt;包装了&lt;/span&gt;&lt;span&gt;OsStr&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;PathBuf&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：跟&lt;/span&gt;&lt;span&gt;Path&lt;/span&gt;&lt;span&gt;配对，是&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;的可变版本。&lt;/span&gt;&lt;span&gt;PathBuf&lt;/span&gt;&lt;span&gt;包装了&lt;/span&gt;&lt;span&gt;OsString&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;属于&lt;/span&gt;&lt;b&gt;&lt;span&gt;动态大小类型（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;DST&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;），&lt;/span&gt;&lt;/b&gt;&lt;span&gt;在编译期并不能确定其大小。所以在程序中最常见的是&lt;/span&gt;&lt;b&gt;&lt;span&gt;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的切片（&lt;/span&gt;&lt;span&gt;Slice&lt;/span&gt;&lt;span&gt;）类型&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;。&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;代表的是不可变的&lt;/span&gt;&lt;b&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;/b&gt;&lt;span&gt;字节序列，创建后无法再为其追加内容或更改其内容。&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型的字符串可以存储在任意地方：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;String&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型本质是一个成员变量为&lt;/span&gt;&lt;b&gt;&lt;span&gt;Vec&amp;lt;u8&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型的结构体，所以它是直接将字符内容存放于堆中的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;String&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型由三部分组成：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;执行堆中字节序列的指针（&lt;/span&gt;&lt;span&gt;as_ptr&lt;/span&gt;&lt;span&gt;方法）&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;记录堆中字节序列的字节长度（&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;方法）&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;堆分配的容量（&lt;/span&gt;&lt;span&gt;capacity&lt;/span&gt;&lt;span&gt;方法）&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.4.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;字符串处理方式&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中的字符串不能使用索引访问其中的字符，可以通过&lt;/span&gt;&lt;b&gt;&lt;span&gt;bytes&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;chars&lt;/span&gt;&lt;/b&gt;&lt;span&gt;两个方法来分别返回&lt;/span&gt;&lt;b&gt;&lt;span&gt;按字节&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;按字符&lt;/span&gt;&lt;/b&gt;&lt;span&gt;迭代的迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;提供了另外两种方法：&lt;/span&gt;&lt;b&gt;&lt;span&gt;get&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;get_mut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来通过指定索引范围来获取字符串切片。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.4.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;字符串修改&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;追加字符串：&lt;/span&gt;&lt;b&gt;&lt;span&gt;push&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;push_str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，以及&lt;/span&gt;&lt;b&gt;&lt;span&gt;extend&lt;/span&gt;&lt;/b&gt;&lt;span&gt;迭代器&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;插入字符串：&lt;/span&gt;&lt;b&gt;&lt;span&gt;insert&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;insert_str&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;连接字符串：&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;Add&amp;lt;&amp;amp;str&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;AddAssign&amp;lt;&amp;amp;str&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;两个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;，所以可以使用“&lt;/span&gt;&lt;b&gt;&lt;span&gt;+&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”和“&lt;/span&gt;&lt;b&gt;&lt;span&gt;+=&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”来连接字符串&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;更新字符串：通过迭代器或者某些&lt;/span&gt;&lt;span&gt;unsafe&lt;/span&gt;&lt;span&gt;的方法&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;删除字符串：&lt;/span&gt;&lt;b&gt;&lt;span&gt;remove&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;pop&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;truncate&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;clear&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;drain&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.4.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;字符串的查找&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;总共提供了&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;个方法涵盖了以下几种字符串匹配操作：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;存在性判断&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;位置匹配&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;分割字符串&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;捕获匹配&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;删除匹配&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;替代匹配&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.4.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;类型转换&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;parse&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：将字符串转换为指定的类型&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;format!&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;宏&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：将其他类型转成成字符串&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.5 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;格式化规则&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;填充字符串宽度：&lt;/span&gt;&lt;b&gt;&lt;span&gt;{:&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;5&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;}&lt;/span&gt;&lt;/b&gt;&lt;span&gt;,5&lt;/span&gt;&lt;span&gt;是指宽度为&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;截取字符串：&lt;/span&gt;&lt;b&gt;&lt;span&gt;{:.&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;5&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;}&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;对齐字符串：&lt;/span&gt;&lt;b&gt;&lt;span&gt;{:&amp;gt;}&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;{:^}&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;{:&amp;lt;}&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，分别表示&lt;/span&gt;&lt;b&gt;&lt;span&gt;左对齐&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;位于中间&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;右对齐&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;{:*^&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;5&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;} &lt;/span&gt;&lt;/b&gt;&lt;span&gt;使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;*&lt;/span&gt;&lt;/b&gt;&lt;span&gt;替代默认&lt;/span&gt;&lt;b&gt;&lt;span&gt;空格&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来填充&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;符号&lt;/span&gt;&lt;b&gt;&lt;span&gt;+&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示强制输出整数的正负符号&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;符号&lt;/span&gt;&lt;b&gt;&lt;span&gt;#&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：用于显示进制的前缀。比如：十六进制&lt;/span&gt;&lt;span&gt;0x&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;数字&lt;/span&gt;&lt;b&gt;&lt;span&gt;0&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：用于把默认填充的空格替换成数字&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;{:x} &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：转换成&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;进制输出&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;{:b} &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：转换成二进制输出&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;{:.5}&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：指定小数点后有效位是&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;{:e}&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：科学计数法表示&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.6 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;原生字符串声明语法：&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;r”…”&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原生字符串声明语法（&lt;/span&gt;&lt;b&gt;&lt;span&gt;r”…”&lt;/span&gt;&lt;/b&gt;&lt;span&gt;）可以保留原来字符串中的特殊符号。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.7 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;全局类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;支持两种全局类型：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;普通常量（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Constant&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;静态变量（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Static&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;区别：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;都是在&lt;/span&gt;&lt;b&gt;&lt;span&gt;编译期&lt;/span&gt;&lt;/b&gt;&lt;span&gt;求值的，所以不能用于存储需要动态分配内存的类型&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;普通常量&lt;/span&gt;&lt;b&gt;&lt;span&gt;可以被内联&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的，它没有确定的内存地址，不可变&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;静态变量&lt;/span&gt;&lt;b&gt;&lt;span&gt;不能被内联&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，它有精确的内存地址，拥有静态生命周期&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;静态变量可以通过内部包含&lt;/span&gt;&lt;span&gt;UnsafeCell&lt;/span&gt;&lt;span&gt;等容器&lt;/span&gt;&lt;b&gt;&lt;span&gt;实现内部可变性&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;静态变量还有其他限制，具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;326&lt;/span&gt;&lt;span&gt;页&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;普通常量也不能引用静态变量&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;在存储的&lt;/span&gt;&lt;b&gt;&lt;span&gt;数据比较大&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，&lt;/span&gt;&lt;b&gt;&lt;span&gt;需要引用地址&lt;/span&gt;&lt;/b&gt;&lt;span&gt;或&lt;/span&gt;&lt;b&gt;&lt;span&gt;具有可变性&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的情况下使用静态变量。否则，应该优先使用普通常量。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但也有一些情况是这两种全局类型无法满足的，比如想要使用全局的&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;，在这种情况下，推荐使用&lt;/span&gt;&lt;span&gt;lazy_static&lt;/span&gt;&lt;span&gt;包。利用&lt;/span&gt;&lt;span&gt;lazy_static&lt;/span&gt;&lt;span&gt;包可以把&lt;/span&gt;&lt;b&gt;&lt;span&gt;定义全局静态变量延迟到运行&lt;/span&gt;&lt;/b&gt;&lt;span&gt;时，而&lt;/span&gt;&lt;b&gt;&lt;span&gt;非编译&lt;/span&gt;&lt;/b&gt;&lt;span&gt;时。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.3 trait&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;b&gt;&lt;span&gt;对类型行为的抽象&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;实现零成本抽象的基石，它有如下机制：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;唯一的接口抽象方式；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;可以静态分发，也可以动态分发；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;可以当做标记类型拥有某些特定行为的“标签”来使用。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;struct Duck;                &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;struct Pig;                 &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;trait &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Fly {                 &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    fn fly(&amp;amp;self) -&amp;gt; bool;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;}                            &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;impl Fly for Duck&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; {        &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    fn fly(&amp;amp;self) -&amp;gt; bool {&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;         return true;       &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    }                         &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;}                            &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;impl Fly for Pig&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; {         &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    fn fly(&amp;amp;self) -&amp;gt; bool {&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;         return false;      &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    }                        &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;}                            &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;静态分发和动态分发的具体介绍可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;trait&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;限定&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下这些需要继续深入理解第三章并总结。待后续继续补充。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;trait&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;标签&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;trait&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Copy trait&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Deref&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;解引用&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;as&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;操作符&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;From&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;和&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Into&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;指针&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.3.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;引用&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp; mut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;操作符来创建。受&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;的安全检查规则的限制。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用是&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;提供的一种指针语义。引用是基于指针的实现，他与指针的区别是：&lt;/span&gt;&lt;span&gt;指针保存的是其指向内存的地址&lt;/span&gt;&lt;span&gt;，而&lt;/span&gt;&lt;span&gt;引用可以看做某块内存的别名（&lt;/span&gt;&lt;span&gt;Alias&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在所有权系统中，引用&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;x&lt;/span&gt;&lt;/b&gt;&lt;span&gt;也可以称为&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;的借用（&lt;/span&gt;&lt;span&gt;Borrowing&lt;/span&gt;&lt;span&gt;）。通过&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;操作符来完成&lt;/span&gt;&lt;b&gt;&lt;u&gt;&lt;span&gt;&lt;a href=&quot;http://3ms.huawei.com/km/groups/1501725/blogs/details/7729437#_1.2.3.2_%E6%89%80%E6%9C%89%E6%9D%83%E5%80%9F%E7%94%A8&quot;&gt;&lt;span&gt;所有权租借&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/u&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.3.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;原生指针（裸指针）&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;*const T&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;*mut T&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。可以在&lt;/span&gt;&lt;b&gt;&lt;span&gt;unsafe&lt;/span&gt;&lt;/b&gt;&lt;span&gt;块下任意使用，不受&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;的安全检查规则的限制。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.3.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;智能指针&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上是一种结构体，只是行为类似指针。智能指针是对指针的一层封装，提供了一些额外的功能，比如自动释放堆内存。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;智能指针区别于常规结构体的特性在于：它实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;Deref&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;Drop&lt;/span&gt;&lt;/b&gt;&lt;span&gt;这两个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Deref&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：提供了解引用能力&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Drop&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：提供了自动析构的能力&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.3.3.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;智能指针有哪些&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;智能指针&lt;/span&gt;&lt;b&gt;&lt;span&gt;拥有资源的所有权&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，而普通引用只是对&lt;/span&gt;&lt;b&gt;&lt;span&gt;所有权的借用&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;。&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中的值默认被分配到&lt;/span&gt;&lt;b&gt;&lt;span&gt;栈内存&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。可以通过&lt;/span&gt;&lt;span&gt;Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;将值装箱（在&lt;/span&gt;&lt;b&gt;&lt;span&gt;堆内存&lt;/span&gt;&lt;/b&gt;&lt;span&gt;中分配）。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;String&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型和&lt;/span&gt;&lt;b&gt;&lt;span&gt;Vec&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型的值都是被&lt;/span&gt;&lt;b&gt;&lt;span&gt;分配到堆内存&lt;/span&gt;&lt;/b&gt;&lt;span&gt;并&lt;/span&gt;&lt;b&gt;&lt;span&gt;返回指针&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的，通过将返回的指针封装来实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;Deref&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;Drop&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;是指向类型为&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;堆内存&lt;/span&gt;&lt;span&gt;分配值的&lt;/span&gt;&lt;span&gt;智能指针&lt;/span&gt;&lt;span&gt;。当&lt;/span&gt;&lt;span&gt;Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;超出作用域范围时，将调用其析构函数，销毁内部对象，并&lt;/span&gt;&lt;span&gt;自动释放堆中的内存&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;单线程&lt;/span&gt;&lt;/b&gt;&lt;span&gt;引用计数指针，不是线程安全的类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以将多个所有权共享给多个变量，每当共享一个所有权时，计数就会增加一次。具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;是&lt;/span&gt;&lt;b&gt;&lt;span&gt;RC&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的另一个版本。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过&lt;span&gt;clone&lt;/span&gt;方法共享的引用所有权称为&lt;/span&gt;&lt;b&gt;&lt;span&gt;强引用&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，&lt;/span&gt;&lt;b&gt;&lt;span&gt;RC&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是强引用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Weak&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;共享的指针&lt;/span&gt;&lt;span&gt;没有所有权&lt;/span&gt;&lt;span&gt;，属于&lt;/span&gt;&lt;b&gt;&lt;span&gt;弱引用&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;实现字段级内部可变的情况。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;适合复制语义类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;适合移动语义类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cell&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;和&lt;span&gt;RefCell&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;b&gt;&lt;span&gt;本质上不属于智能指针&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，只是提供内不可变性的容器。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cell&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;和&lt;span&gt;RefCell&amp;lt;T&amp;gt;&lt;/span&gt;使用最多的场景就是配合只读引用来使用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见&lt;/span&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Copy on write&lt;/span&gt;&lt;span&gt;：一种枚举体的智能指针。&lt;/span&gt;&lt;span&gt;Cow&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;表示的是所有权的“借用”和“拥有”。&lt;/span&gt;&lt;span&gt;Cow&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;的功能是：以不可变的方式访问借用内容，以及在需要可变借用或所有权的时候再克隆一份数据。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cow&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;旨在&lt;/span&gt;&lt;span&gt;减少复制操作，提高性能&lt;/span&gt;&lt;span&gt;，一般用于&lt;/span&gt;&lt;span&gt;读多写少&lt;/span&gt;&lt;span&gt;的场景。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cow&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;的另一个用处是统一实现规范。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.3.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;解引用&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;deref&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解引用会获得所有权。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解引用操作符：&lt;/span&gt;&lt;span&gt; *&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;哪些实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;deref&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：源码见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;Cow&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：意味着可以直接调用其包含数据的不可变方法。具体的要点可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;Box&amp;lt;T &amp;gt;&lt;/span&gt;&lt;span&gt;支持解引用移动，&lt;/span&gt;&lt;span&gt; Rc&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Arc&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;智能指针不支持解引用移动。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;所有权机制（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;ownership&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中分配的每块内存都有其所有者，所有者负责该内存的释放和读写权限，并且每次每个值只能有唯一的所有者。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在进行赋值操作时，对于可以&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;的复制语义类型，所有权并未改变&lt;/span&gt;&lt;span&gt;。对于复合类型来说，是复制还是移动，取决于其成员的类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：如果数组的元素都是基本的数字类型，则该数组是复制语义，则会按位复制。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;词法作用域（生命周期）&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;match&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;for&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;loop&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;while&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;if let&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;while let&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;花括号&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/b&gt;&lt;span&gt;都会创建新的作用域，相应绑定的所有权会被转移，具体的可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数体本身是独立的词法作用域：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;当复制语义类型作为函数参数时，会按位复制。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果是移动语义作为函数参数，则会转移所有权。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;非词法作用域声明周期&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;借用规则&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;借用方&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的生命周期不能长于&lt;/span&gt;&lt;b&gt;&lt;span&gt;出借方&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的生命周期。用例见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为以上的规则，经常导致实际开发不便，所以引入了&lt;/span&gt;&lt;b&gt;&lt;span&gt;非词法作用域生命周期（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Non-Lexical Lifetime&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;，&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;NLL&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来改善。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;是基于控制流图（&lt;/span&gt;&lt;span&gt;Control Flow Graph&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;CFG&lt;/span&gt;&lt;span&gt;）的抽象数据结构，它用&lt;/span&gt;&lt;span&gt;有向图（&lt;/span&gt;&lt;span&gt;DAG&lt;/span&gt;&lt;span&gt;）形式包含了程序执行过程中所有可能的流程&lt;/span&gt;&lt;span&gt;。所以将基于&lt;/span&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;的借用检查称为非词法作用域的生命周期。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;所有权借用&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用可变借用的前提是：出借所有权的绑定变量必须是一个可变绑定。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在所有权系统中，引用&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;x&lt;/span&gt;&lt;/b&gt;&lt;span&gt;也可以称为&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;的借用（&lt;/span&gt;&lt;span&gt;Borrowing&lt;/span&gt;&lt;span&gt;）。通过&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;操作符来完成&lt;/span&gt;&lt;b&gt;&lt;span&gt;所有权租借&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。所以引用并不会造成绑定变量所有权的转移。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用在离开作用域之时，就是其归还所有权之时。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;不可变借用（引用）不能再次出借为可变借用。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;不可变借用可以被出借多次。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;可变借用只能出借一次。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;不可变借用和可变借用不能同时存在，针对同一个绑定而言。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;借用的生命周期不能长于出借方的生命周期。具体的举例见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;核心原则：&lt;/span&gt;&lt;b&gt;&lt;span&gt;共享不可变，可变不共享&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为&lt;/span&gt;&lt;b&gt;&lt;span&gt;解引用操作会获得所有权&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，所以在需要对移动语义类型（如&lt;/span&gt;&lt;span&gt;&amp;amp;String&lt;/span&gt;&lt;span&gt;）进行解引用时需要特别注意。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编译器的借用检查机制无法对跨函数的借用进行检查，因为当前借用的有效性依赖于词法作用域。所以，需要开发者显式的对借用的生命周期参数进行标注。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;显式生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;生命周期参数必须是以&lt;/span&gt;&lt;b&gt;&lt;span&gt;单引号&lt;/span&gt;&lt;/b&gt;&lt;span&gt;开头；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;参数名通常都是&lt;/span&gt;&lt;b&gt;&lt;span&gt;小写字母&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt;；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;生命周期参数&lt;/span&gt;&lt;b&gt;&lt;span&gt;位于引用符号&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;后面&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，并使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;空格&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来分割生命周期参数和类型。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;标注生命周期参数是由于&lt;/span&gt;&lt;span&gt;borrowed pointers&lt;/span&gt;&lt;span&gt;导致的。因为有&lt;/span&gt;&lt;span&gt;borrowed pointers&lt;/span&gt;&lt;span&gt;，当函数返回&lt;/span&gt;&lt;span&gt;borrowed pointers&lt;/span&gt;&lt;span&gt;时，为了保证内存安全，需要关注被借用的内存的生命周期&lt;/span&gt;&lt;span&gt;(lifetime)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;标注生命周期参数并不能改变任何引用的生命周期长短，它&lt;/span&gt;&lt;b&gt;&lt;span&gt;只用于编译器的借用检查&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，来防止悬垂指针。即：生命周期参数的目的是&lt;/span&gt;&lt;b&gt;&lt;span&gt;帮助借用检查器验证合法的引用，消除悬垂指针&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;i32;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;  ==&amp;gt; &lt;/span&gt;&lt;span&gt;引用&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a i32;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;    ==&amp;gt; &lt;/span&gt;&lt;span&gt;标注生命周期参数的引用&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a mut i32;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;    ==&amp;gt; &lt;/span&gt;&lt;span&gt;标注生命周期参数的可变引用&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;允许使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a str;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的地方，使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;static str;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;也是合法的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;&lt;b&gt;&lt;span&gt;&#x27;static&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：当&lt;/span&gt;&lt;span&gt;borrowed pointers&lt;/span&gt;&lt;span&gt;指向&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;对象时需要声明&lt;/span&gt;&lt;span&gt;&#x27;static lifetime&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;static STRING: &amp;amp;&#x27;static str = &quot;bitstring&quot;;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;函数签名中的生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fn foo&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;lt;&#x27;a&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;(s: &lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt; str, t: &lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt; str) -&amp;gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt; str;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数名后的&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;lt;&#x27;a&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;为生命周期参数的声明。函数或方法参数的生命周期叫做&lt;/span&gt;&lt;b&gt;&lt;span&gt;输入生命周期（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;input lifetime&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，而返回值的生命周期被称为&lt;/span&gt;&lt;b&gt;&lt;span&gt;输出生命周期（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;output lifetime&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;规则：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;禁止在没有任何输入参数的情况下返回引用，因为会造成悬垂指针。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;从函数中返回（输出）一个引用，其生命周期参数必须与函数的参数（输入）相匹配，否则，标注生命周期参数也毫无意义。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;对于多个输入参数的情况，也可以标注不同的生命周期参数。具体的举例见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;结构体定义中的生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结构体在含有引用类型成员的时候也需要标注生命周期参数，否则编译失败。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td valign=&quot;top&quot;&gt; &lt;p&gt;struct Foo&lt;b&gt;&lt;span&gt;&amp;lt;&#x27;a&amp;gt;&lt;/span&gt;&lt;/b&gt; {&lt;/p&gt; &lt;p&gt;            part: &lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a str&lt;/span&gt;&lt;/b&gt;,&lt;/p&gt; &lt;p&gt;}&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt;
&lt;p&gt;&lt;span&gt;这里生命周期参数标记，实际上是和编译器约定了一个规则：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;结构体实例的生命周期应短于或等于任意一个成员的生命周期。&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;方法定义中的生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结构体中包含引用类型成员时，需要标注生命周期参数，则在&lt;/span&gt;&lt;span&gt;impl&lt;/span&gt;&lt;span&gt;关键字之后也需要声明生命周期参数，并在结构体名称之后使用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td valign=&quot;top&quot;&gt; &lt;p&gt;impl&lt;b&gt;&lt;span&gt;&amp;lt;&#x27;a&amp;gt;&lt;/span&gt;&lt;/b&gt; Foo&lt;b&gt;&lt;span&gt;&amp;lt;&#x27;a&amp;gt;&lt;/span&gt;&lt;/b&gt; {&lt;/p&gt; &lt;p&gt;         fn split_first(s: &lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a str&lt;/span&gt;&lt;/b&gt;) -&amp;gt; &lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a str &lt;/span&gt;&lt;/b&gt;{&lt;/p&gt; &lt;p&gt;                   …&lt;/p&gt; &lt;p&gt;}&lt;/p&gt; &lt;p&gt;}&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt;
&lt;p&gt;&lt;span&gt;在添加生命周期参数&lt;/span&gt;&lt;b&gt;&lt;span&gt;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt;之后，结束了输入引用的生命周期长度要长于结构体&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;实例的生命周期长度。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/b&gt;&lt;span&gt;枚举体和结构体对生命周期参数的处理方式是一样的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.5 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;静态生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;静态生命周期&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; &#x27;static&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：是&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;内置的一种特殊的生命周期。&lt;/span&gt;&lt;b&gt;&lt;span&gt;&#x27;static&lt;/span&gt;&lt;/b&gt;&lt;span&gt;生命周期存活于整个程序运行期间。所有的字符串字面量都有生命周期，类型为&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp; &#x27;static str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串字面量是全局静态类型，他的数据和程序代码一起存储在可执行文件的数据段中，其地址在编译期是已知的，并且是只读的，无法更改。&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.6 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;省略生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;满足以下三条规则时，可以省略生命周期参数。该场景下，是将其硬编码到&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编译器重，以便编译期可以自动补齐函数签名中的生命周期参数。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生命周期省略规则：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;每一个在输入位置省略的生命周期都将成为一个不同的生命周期参数。即对应一个唯一的生命周期参数。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果只有一个输入的生命周期位置（无论省略还是没省略），则该生命周期都将分配给输出生命周期。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果有多个输入生命周期位置，而其中包含着&lt;/span&gt;&lt;span&gt; &amp;amp;self &lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt; &amp;amp;mut self&lt;/span&gt;&lt;span&gt;，那么&lt;/span&gt;&lt;span&gt; self &lt;/span&gt;&lt;span&gt;的生命周期都将分配给输出生命周期。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;以上这部分规则还没理解透彻&lt;/span&gt;&lt;span&gt;，需要继续熟读《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.7 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;生命周期限定&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生命周期参数可以向&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;那样作为泛型的限定，有以下两种形式：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;T: &#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，表示&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;类型中的任何引用都要“获得”和&lt;/span&gt;&lt;b&gt;&lt;span&gt;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt;一样长。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;T: Trait + &#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，表示&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;类型必须实现&lt;/span&gt;&lt;span&gt;Trait&lt;/span&gt;&lt;span&gt;这个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;，并且&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;类型中任何引用都要“活的”和&lt;/span&gt;&lt;b&gt;&lt;span&gt;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt;一样长。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体的举例见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.8 trait&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;对象的生命周期&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的举例见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.9 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;高阶生命周期&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;还提供了&lt;/span&gt;&lt;b&gt;&lt;span&gt;高阶生命周期（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Higher-Ranked Lifetime&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;方案，该方案也叫&lt;/span&gt;&lt;b&gt;&lt;span&gt;高阶&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;trait&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;限定（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Higher-Ranked Trait Bound&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;，&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;HRTB&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。该方案提供了&lt;/span&gt;&lt;b&gt;&lt;span&gt;for&amp;lt;&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;语法。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;for&amp;lt;&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;语法整体表示此生命周期参数只针对其后面所跟着的“对象”。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.5 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;并发安全与所有权&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.5.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;标签&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;trait&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;：&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Send&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;和&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Sync&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;如果类型&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;Send&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;就是告诉编译器该类型的实例可以&lt;/span&gt;&lt;b&gt;&lt;span&gt;在线程间安全传递所有权&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果类型&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;Sync&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：就是向编译器表明该类型的实例&lt;/span&gt;&lt;b&gt;&lt;span&gt;在多线程并发中&lt;span&gt;不可能&lt;/span&gt;导致内存不安全&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，所以&lt;/span&gt;&lt;b&gt;&lt;span&gt;可以安全的跨线程共享&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.5.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些类型实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Send&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.5.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些类型实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Sync&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&amp;#13;
        &lt;/div&gt;&amp;#13;
        &amp;#13;
&amp;#13;
        &amp;#13;
        &amp;#13;
            &amp;#13;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f499b11fb1ab33aad79a45229cde7326</guid>
<title>日志记录的最佳实践</title>
<link>https://toutiao.io/k/0w9hsc7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;日志（Log）是由系统在运行过程中产生的结构化或者非结构化的文字信息。通常情况，可以将其视为应用程序对某个事件（Event）的记录。日志通常可以帮助我们发现一些微服务架构系统的非预期或突发的行为。 Logging作为 Observability（可观察性，在IT和云计算中，它是根据系统生成的数据，例如日志、指标和数据链追踪等来衡量系统当前状态的能力）的重要组成部分，在我们的系统开发、维护中起到无法替代的作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/09/one.png&quot; alt=&quot;Pillars of Observability&quot;/&gt;&lt;br/&gt;
Pillars of Observability&lt;/p&gt;
&lt;h3&gt;日志的重要性&lt;/h3&gt;
&lt;p&gt;要理解为什么日志在产品或者系统中扮演着重要的角色，我们必须了解它的价值。至少到现在，日志被应用最广泛的是&lt;strong&gt;报警、故障排除和业务数据可视化&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;报警&lt;/h4&gt;
&lt;p&gt;日志可以作为我们业务系统监控的重要数据来源；成熟的产品系统都有报警系统，如果系统中出现超过某个已定义的某个指标的问题，日志系统会自动将报警信息发送到通知平台，On-call 的人就可以根据报警信息定位解决问题了。&lt;/p&gt;
&lt;h4&gt;故障排除&lt;/h4&gt;
&lt;p&gt;这种情况非常普遍；想象一下你最近负责开发维护的系统被他人发现有问题，在你梳理完思路之后第一件事是干什么？肯定是查看系统信息验证自己的假设是否成立，这里打印在服务器上的日志就是最好的辅助信息。而作为程序员的我们，日志是我们最熟悉不过的解决问题的利器。 &lt;/p&gt;
&lt;h4&gt;业务数据可视化&lt;/h4&gt;
&lt;p&gt;很多公司可以利用存储在自己数据库里的生产环境的日志，结合相应的工具可以对业务进行业务数据可视化。这里最典型的代表是 Grafana 和 SumoLogic。&lt;/p&gt;
&lt;h3&gt;怎么做&lt;/h3&gt;
&lt;h4&gt;模板化&lt;/h4&gt;
&lt;p&gt;为了更好支持上面的各种情况，我们需要对我们的日志格式进行梳理，按照一定的规范来写日志，而不是随便写一句废话。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/09/2-9.png&quot; alt=&quot;Log Format&quot;/&gt;&lt;br/&gt;
Log Format&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基础版本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于日志，&lt;strong&gt;时间，日志级别，和日志信息&lt;/strong&gt;最为重要，所以一个合格的日志应该至少包含这些信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高级版本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在基础版的基础上，加入线程名，主机名，方法名，类名，方法对应的行数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程名&lt;/strong&gt;：多数应用的用户都不是单一的，对于单实例的服务对同一个接口很多用户访问应用会将在不同的线程中执行，这时如果要区分对应用户的业务流程，那么通过线程名是最好的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主机名&lt;/strong&gt;：现在的应用大多部署在 Cloud 中，都是多实例的，所以在单节点的基础上，日志在多实例上就需要实例级别的区分，而主机名是最好的区分方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法名&lt;/strong&gt;：打印了日志的方法名，方便区分相同日志的出处。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类名&lt;/strong&gt;：打印了日志的类名，方便快速定位业务流程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;行数&lt;/strong&gt;：打印了日志的行数，方便快速定位日志的具体位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;格式化&lt;/h4&gt;
&lt;p&gt;为了提高日志的可读性，我们可以对日志进行修饰。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对日志级别、主机名和线程名前后加&lt;strong&gt;中括号&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;对方法名所在的类名和行号加&lt;strong&gt;括号&lt;/strong&gt;，并在类名与行号中间用&lt;strong&gt;冒号&lt;/strong&gt;隔开；&lt;/li&gt;
&lt;li&gt;在行号和日志信息中间加入一个&lt;strong&gt;横线&lt;/strong&gt;来分隔；&lt;/li&gt;
&lt;li&gt;对于日志信息也可以进行特定的格式化
&lt;ul&gt;
&lt;li&gt;对于常规的请求（Request）、响应（Response）或者其他业务日志，可以在自定义信息和参数之间用&lt;strong&gt;下划线&lt;/strong&gt;分隔；多个参数之间用逗号分隔，当然参数也是可选的；&lt;/li&gt;
&lt;li&gt;对于错误信息格式化，也可以按照 &lt;strong&gt;Key：Value&lt;/strong&gt; 的形式进行组织。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;链式追踪&lt;/h4&gt;
&lt;p&gt;记录下了日志，如果只是一行行简单的文字说明，那是没有太大意义的。在复杂系统或业务操作频繁的系统中，会产生非常多的日志，在这种情况下，我们就得花时间去过滤出相关的日志。解决上面问题的最好办法是日志的&lt;strong&gt;链式追踪&lt;/strong&gt;；简单说就是，在每条日志中加入业务系统中的一个或者多个&lt;strong&gt;唯一&lt;/strong&gt;的 ID，这样在定位业务问题的时候可以通过这些唯一的 ID 和 其他条件（e.g. 时间）快速过滤出相关的日志。&lt;/p&gt;
&lt;h4&gt;按需记录日志&lt;/h4&gt;
&lt;h5&gt;日志级别&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/09/3-7.png&quot; alt=&quot;Log Level&quot;/&gt;&lt;br/&gt;
Log Level&lt;/p&gt;
&lt;p&gt;日志的输出都是分级别的，不同的场景需要打印不同级别的日志；以下是几个比较重要的日志级别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Debug&lt;/strong&gt;: 记录技术细节，和一些帮助理解系统运行的日志；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Info&lt;/strong&gt;: 记录业务信息的日志；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Warn&lt;/strong&gt;: 非紧急且可控的可接受的错误信息；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Error&lt;/strong&gt;: 非期望的错误或者系统表现，通常是由系统bug或者环境问题导致。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时不是所有的日志都需要记录，我们要做到按需记录。下表是在不同的环境选择不同日志级别的推荐。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Environment&lt;/th&gt;
&lt;th&gt;Log Leave&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Dev&lt;/td&gt;
&lt;td&gt;Debug&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Test&lt;/td&gt;
&lt;td&gt;Debug&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UAT&lt;/td&gt;
&lt;td&gt;Info&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Prod&lt;/td&gt;
&lt;td&gt;Info&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5&gt;日志位置&lt;/h5&gt;
&lt;p&gt;有了日志级别，日志打印的位置也需要明确。一般情况下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其他系统调用自有系统时需要在收到请求和完成请求时各打印一次日志；&lt;/li&gt;
&lt;li&gt;自有系统调用第三方系统的接口前和收到返回信息后各打印一次日志；&lt;/li&gt;
&lt;li&gt;在系统中任何有异常的地方需要打印日志；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一种特殊情况是，像消息传递之类的系统，为了节省日志存储和减少查看干扰，大多时候我们不需要在收到消息后直接打印该消息，一般建议在收到消息后，如果系统处理有异常，在异常中将原始消息打印。&lt;/p&gt;
&lt;h3&gt;工具推荐&lt;/h3&gt;
&lt;p&gt;不同的编程语言有不同的日志工具；比较著名的是 Apache 的 &lt;a href=&quot;https://logging.apache.org/log4j&quot;&gt;Log4j&lt;/a&gt;, Log4j是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX系统日志等；而且 log4j 已经被移植到了其他编程语言中了，如 Python 中的 &lt;a href=&quot;https://docs.python.org/3/library/logging.html&quot;&gt;logging&lt;/a&gt;, NodeJS 中的&lt;a href=&quot;https://www.npmjs.com/package/log4js&quot;&gt;log4js&lt;/a&gt;, Rust 中的&lt;a href=&quot;https://crates.io/crates/log4rs&quot;&gt;log4rs&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;注意点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;避免打印或记录任何敏感信息，包括但不限于各种PII，PCI信息，一定要记得遵守当地的各种法律法规，如中国的《个人信息保护法》（PILI），欧洲的一般数据保护条例GDPR等&lt;/li&gt;
&lt;li&gt;按需选择合适的日志级别和日志位置&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;好的日志不仅可以为程序开发提供便利，为故障排除提供最重要的辅助信息，更可以为业务或基础设施提供优化建议或数据统计。&lt;/p&gt;
&lt;h3&gt;参考材料&lt;/h3&gt;

&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>95add56bbae3838e81000c4cdd281369</guid>
<title>干货｜十分钟读懂字节跳动的 Doris 湖仓分析实践</title>
<link>https://toutiao.io/k/ovsrlzz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34629629629629627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r1mQp3by2Sld0NkibWF5Vsz1LQe1HgegziaWJguUStKR8snibKMUNeVjHNicJqPIDDJs7osvkLGjRnoBg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;本文为字节跳动数据平台研发工程师在DataFunSummit大会演讲实录，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;关注字节跳动数据平台微信公众号，回复【0929】，领取本次分享PPT。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r0iaam0Y3z0iaV3ak0jib0hf2JTr0JNSbZIGpzpan9EAkNsKP0JBoQgRsqDpnxbFYcezyOwCDBPQQicLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;文 | 军令 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;来自字节跳动数据平台E-MapReduce团队&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;Doris简介&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Doris是一种MPP架构的分析型数据库，主要面向多维分析，数据报表，用户画像分析等场景。自带分析引擎和存储引擎，支持向量化执行引擎，不依赖其他组件，兼容MySQL协议。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Apache Doris具备以下几个特点：&lt;/span&gt;&lt;/section&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;良好的架构设计，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;支持高并发低延时的查询服务，支持高吞吐量的交互式分析。多FE均可对外提供服务，并发增加时，线性扩充FE和BE即可支持高并发的查询请求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;支持批量数据load和流式数据load，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;支持数据更新。支持Update/Delete语法，unique/aggregate数据模型，支持动态更新数据，实时更新聚合指标。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;提供了高可用，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;容错处理，高扩展的企业级特性。FE Leader错误异常，FE Follower秒级切换为新Leader继续对外提供服务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;支持聚合表和物化视图。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;多种数据模型，支持aggregate，replace等多种数据模型，支持创建rollup表，支持创建物化视图。rollup表和物化视图支持动态更新，无需用户手动处理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;MySQL协议兼容，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;支持直接使用MySQL客户端连接，非常易用的数据应用对接。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;Doris由Frontend（以下简称FE）和Backend（以下简称BE）组成，其中FE负责接受用户请求，编译，优化，分发执行计划，元数据管理，BE节点的管理等功能，BE负责执行由FE下发的执行计划，存储和管理用户数据。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5808383233532934&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r0iaam0Y3z0iaV3ak0jib0hf2JhvSwrTyGcHY7syAmmt7iaQgcTkrd1k1WSsLtdm6XicfibZoy7Ex3t5JfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1336&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;数据湖格式Hudi简介&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Hudi是下一代流式数据湖平台，为数据湖提供了表格式管理的能力，提供事务，ACID，MVCC，数据更新删除，增量数据读取等功能。支持Spark，Flink，Presto，Trino等多种计算引擎。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.48359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r0iaam0Y3z0iaV3ak0jib0hf2JobR98Po2MvEibrhS28OkPIystMuTFJn9Zib1oibrOURkgQFA7ETArlJ7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hudi根据数据更新时行为不同分为两种表类型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r0iaam0Y3z0iaV3ak0jib0hf2JicjwmCAkm98mpfhxu7fxQiaSm2dtdRQlo54QH5FapFOWQ1mmIFIs52eQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;针对Hudi的两种表格式，存在3种不同的查询类型：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r0iaam0Y3z0iaV3ak0jib0hf2JJAz7EvUibJcYcronuG4s7tXCl23g615teKkDXT6VWqYsRibqb2k9aNOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;Doris分析Hudi数据的技术背景&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在数仓业务中，随着业务对数据实时性的要求越来越高，T+1数仓业务逐渐往小时级，分钟级，甚至秒级演进。实时数仓的应用也越来越广，也经历了多个发展阶段。目前存在着多种解决方案。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;Lambda架构&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Lambda将数据处理流分为在线分析和离线分析分为两条不同的处理路径，两条路径互相独立，互不影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;离线分析处理T+1数据，使用Hive/Spark处理大数据量，不可变数据，数据一般存储在HDFS等系统上。如果遇到数据更新，需要overwrite整张表或整个分区，成本比较高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在线分析处理实时数据，使用Flink/Spark Streaming处理流式数据，分析处理秒级或分钟级流式数据，数据保存在Kafka或定期（分钟级）保存到HDFS中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该套方案存在以下缺点：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;Kappa架构&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;随着在线分析业务越来越多，Lambda架构的弊端就越来越明显，增加一个指标需要在线离线分别开发，维护困难，离线指标可能和在线指标对不齐，部署复杂，组件繁多。于是Kappa架构应运而生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kappa架构使用一套架构处理在线数据和离线数据，使用同一套引擎同时处理在线和离线数据，数据存储在消息队列上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kappa架构也有一定的局限：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;基于数据湖的实时数仓&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;针对Lambda架构和Kappa架构的缺陷，业界基于数据湖开发了Iceberg, Hudi, DeltaLake这些数据湖技术，使得数仓支持ACID, Update/Delete, 数据Time Travel, Schema Evolution等特性，使得数仓的时效性从小时级提升到分钟级，数据更新也支持部分更新，大大提高了数据更新的性能。兼具流式计算的实时性和批计算的吞吐量，支持的是近实时的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上方案中其中基于数据湖的应用最广，但数据湖模式无法支撑更高的秒级实时性，也无法直接对外提供数据服务，需要搭建其他的数据服务组件，系统较为复杂。基于此背景下，部分业务开始使用Doris来承接，业务数据分析师需要对Doris与Hudi中的数据进行联邦分析，此外在Doris对外提供数据服务时既要能查询Doris中数据，也要能加速查询离线业务中的数据湖数据，因此我们开发了Doris访问数据湖Hudi中数据的特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;Doris分析Hudi数据的设计原理&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;基于以上背景，我们设计了Apache Doris中查询数据湖格式Hudi数据，因Hudi生态为java语言，而Apache Doris的执行节点BE为C++环境，而C++ 无法直接调用Hudi java SDK，针对这一点，我们有四种解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;实现Hudi C++ client，在BE中直接调用Hudi C++ client去读写Hudi表。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;该方案需要完整实现一套Hudi C++ client，开发周期较长，后期Hudi行为变更需要同步修改Hudi C++ client，维护较为困难。&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;BE通过thrift协议发送读写请求至Broker，由Broker调用Hudi java client读取Hudi表。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;该方案需要在Broker中增加读写Hudi数据的功能，目前Broker定位仅为fs的操作接口，引入Hudi打破了Broker的定位。第二，数据需要在BE和Broker之间传输，性能较低。&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;在BE中使用JNI创建JVM，加载Hudi java client去读写Hudi表。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;该方案需要在BE进程中维护JVM，有JVM调用Hudi java client对Hudi进行读写。读写逻辑使用Hudi社区java实现，可以维护与社区同步；同时数据在同一个进程中进行处理，性能较高。但需要在BE维护一个JVM，管理较为复杂。&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用BE arrow parquet c++ api读取hudi parquet base file，hudi表中的delta file暂不处理。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;该方案可以由BE直接读取hudi表的parquet文件，性能最高。但当前不支持base file和delta file的合并读取，因此仅支持COW表Snapshot Queries和MOR表的Read Optimized Queries，不支持Incremental Queries。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上，我们选择方案四，第一期实现了COW表Snapshot Queries和MOR表的Read Optimized Queries，后面联合Hudi社区开发base file和delta file合并读取的C++接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;Doris分析Hudi数据的技术实现&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h1/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Doris中查询分析Hudi外表使用步骤非常简单。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;创建Hudi外表&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;建表时指定engine为Hudi，同时指定Hudi外表的相关信息，如hive metastore uri，在hive metastore中的database和table名字等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;建表仅仅在Doris的元数据中增加一张表，无任何数据移动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;建表时支持指定全部或部分hudi schema，也支持不指定schema创建hudi外表。指定schema时必须与hiveMetaStore中hudi表的列名，类型一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Example：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   CREATE TABLE example_db.t_hudi &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ENGINE=HUDI&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    PROPERTIES (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;hudi.database&quot; = &quot;hudi_db&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;hudi.table&quot; = &quot;hudi_table&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;hudi.hive.metastore.uris&quot;  =  &quot;thrift://127.0.0.1:9083&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CREATE TABLE example_db.t_hudi (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    column1 int,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    column2 string)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ENGINE=HUDI&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    PROPERTIES (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;hudi.database&quot; = &quot;hudi_db&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;hudi.table&quot; = &quot;hudi_table&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;hudi.hive.metastore.uris&quot;  =  &quot;thrift://127.0.0.1:9083&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    );&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;查询Hudi外表&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7404092071611253&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r0iaam0Y3z0iaV3ak0jib0hf2Jg8uZJtrnNwcHwxqibKLPPj5zKBicHohueibswv1chsf3eEiaroBAoYavtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1564&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;后期规划&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;目前Apche Doris查询Hudi表已合入社区，当前已支持COW表的Snapshot Query，支持MOR表的Read Optimized Query。对MOR表的Snapshot Query暂时还未支持，流式场景中的Incremental Query也没有支持。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后续还有几项工作需要处理，我们和社区也在积极合作进行中：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MOR表的Snapshot Query。MOR表实时读需要合并读取Data file与对应的Delta file，BE需要支持Delta file AVRO格式的读取，需要增加avro的native读取方式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;COW/MOR表的Incremental Query。支持实时业务中的增量读取。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BE读取Hudi base file和delta file的native接口。目前BE读取Hudi数据时，仅能读取data file，使用的是parquet的C++ SDK。后期我们和联合Hudi社区提供Huid base file和delta file的C++/Rust等语言的读取接口，在Doris BE中直接使用native接口来查询Hudi数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-1&quot;/&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;本文为字节跳动数据平台研发工程师在DataFunSummit大会演讲实录，&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关注字节跳动数据平台微信公众号，回复【0929】，领取本次分享PPT。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;span&gt;产品介绍&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;火山引擎 E-MapReduce&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;支持构建开源Hadoop生态的企业级大数据分析系统，完全兼容开源，提供 Hadoop、Spark、Hive、Flink集成和管理，帮助用户轻松完成企业大数据平台的构建，降低运维门槛，快速形成大数据分析能力。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;后台回复数字“3”了解产品&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;40&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/jC2t9Zib67r2rAVRBzMMF9nV9BqFPOhzHwu1XL92AFW8jK9zAQXmo5FcO2W6Ce3ld46owl9H8H1toPneEsh4mNA/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;阅读原文，&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;立即跳&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;转火山引擎&lt;span&gt;E-MapReduce&lt;/span&gt;官网了&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;解详情&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34629629629629627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r1mQp3by2Sld0NkibWF5Vsz1LQe1HgegziaWJguUStKR8snibKMUNeVjHNicJqPIDDJs7osvkLGjRnoBg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>99b29f4319184389838ac64d4d21bfd3</guid>
<title>Go 源码里的这些 //go: 指令，你知道吗？</title>
<link>https://toutiao.io/k/1wa895y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-4em6pe&quot; options=&quot;[object Object]&quot; lazyloadimageprops=&quot;[object Object]&quot; usegifprops=&quot;[object Object]&quot;&gt;&lt;blockquote data-first-child=&quot;&quot; data-pid=&quot;udIdpGQ1&quot;&gt;如果你平时有翻看源码的习惯，你肯定会发现。咦，怎么有的方法上面总是写着 &lt;code&gt;//go:&lt;/code&gt;  这类指令呢。他们到底是干嘛用的？&lt;br/&gt;今天和大家一同揭开他们的面纱，我将给你介绍一下他们的作用都是什么。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;go:linkname&lt;/b&gt;&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;//go:linkname localname importpath.name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;hCQM-R9q&quot;&gt;该指令指示编译器使用 &lt;code&gt;importpath.name&lt;/code&gt; 作为源代码中声明为 &lt;code&gt;localname&lt;/code&gt; 的变量或函数的目标文件符号名称。但是由于这个伪指令，可以破坏类型系统和包模块化，只有引用了 unsafe 包才可以使用。&lt;/p&gt;&lt;p data-pid=&quot;F7pBxZDF&quot;&gt;简单来讲，就是 &lt;code&gt;importpath.name&lt;/code&gt; 是 &lt;code&gt;localname&lt;/code&gt; 的符号别名，编译器实际上会调用 &lt;code&gt;localname&lt;/code&gt;。&lt;/p&gt;&lt;p data-pid=&quot;H8mO7ChU&quot;&gt;使用的前提是使用了 &lt;code&gt;unsafe&lt;/code&gt; 包才能使用。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;案例&lt;/b&gt;&lt;/h3&gt;&lt;h3&gt;&lt;b&gt;time/time.go&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;...
func now() (sec int64, nsec int32, mono int64)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;runtime/timestub.go&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import _ &quot;unsafe&quot; // for go:linkname

//go:linkname time_now time.now
func time_now() (sec int64, nsec int32, mono int64) {
 sec, nsec = walltime()
 return sec, nsec, nanotime() - startNano
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Se5FAxRB&quot;&gt;在这个案例中可以看到 &lt;code&gt;time.now&lt;/code&gt;，它并没有具体的实现。如果你初看可能会懵逼。这时候建议你全局搜索一下源码，你就会发现其实现在 &lt;code&gt;runtime.time_now&lt;/code&gt; 中。&lt;/p&gt;&lt;p data-pid=&quot;EIWOssYy&quot;&gt;配合先前的用法解释，可得知在 runtime 包中，我们声明了 &lt;code&gt;time_now&lt;/code&gt; 方法是 &lt;code&gt;time.now&lt;/code&gt; 的符号别名。并且在文件头引入了 &lt;code&gt;unsafe&lt;/code&gt; 达成前提条件。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;go:noescape&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;jIQB0IGB&quot;&gt;该指令指定下一个有声明但没有主体（意味着实现有可能不是 Go）的函数，不允许编译器对其做逃逸分析。&lt;/p&gt;&lt;p data-pid=&quot;jlnCf5h0&quot;&gt;一般情况下，该指令用于内存分配优化。编译器默认会进行逃逸分析，会通过规则判定一个变量是分配到堆上还是栈上。&lt;/p&gt;&lt;p data-pid=&quot;Rfi96GtE&quot;&gt;但凡事有意外，一些函数虽然逃逸分析其是存放到堆上。但是对于我们来说，它是特别的。我们就可以使用 &lt;code&gt;go:noescape&lt;/code&gt; 指令强制要求编译器将其分配到函数栈上。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;案例&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// memmove copies n bytes from &quot;from&quot; to &quot;to&quot;.
// in memmove_*.s
//go:noescape
func memmove(to, from unsafe.Pointer, n uintptr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;_kKELS6Y&quot;&gt;我们观察一下这个案例，它满足了该指令的常见特性。如下：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;lBbAQuE2&quot;&gt;memmove_*.s：只有声明，没有主体。其主体是由底层汇编实现的&lt;/li&gt;&lt;li data-pid=&quot;ED4qmbQ5&quot;&gt;memmove：函数功能，在栈上处理性能会更好&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;go:nosplit&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;-Wfq-fi_&quot;&gt;该指令指定文件中声明的下一个函数不得包含堆栈溢出检查。&lt;/p&gt;&lt;p data-pid=&quot;hFrFAXNM&quot;&gt;简单来讲，就是这个函数跳过堆栈溢出的检查。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;案例&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;//go:nosplit
func key32(p *uintptr) *uint32 {
 return (*uint32)(unsafe.Pointer(p))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;go:nowritebarrierrec&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;mfkTSn25&quot;&gt;该指令表示编译器遇到写屏障时就会产生一个错误，并且允许递归。也就是这个函数调用的其他函数如果有写屏障也会报错。&lt;/p&gt;&lt;p data-pid=&quot;vtNTEEGs&quot;&gt;简单来讲，就是针对写屏障的处理，防止其死循环。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;案例&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;//go:nowritebarrierrec
func gcFlushBgCredit(scanWork int64) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;go:yeswritebarrierrec&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;NvULiLbg&quot;&gt;该指令与 &lt;code&gt;go:nowritebarrierrec&lt;/code&gt; 相对，在标注 &lt;code&gt;go:nowritebarrierrec&lt;/code&gt; 指令的函数上，遇到写屏障会产生错误。&lt;/p&gt;&lt;p data-pid=&quot;CaK4K95y&quot;&gt;而当编译器遇到 &lt;code&gt;go:yeswritebarrierrec&lt;/code&gt; 指令时将会停止。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;案例&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;//go:yeswritebarrierrec
func gchelper() {
 ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;go:noinline&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;FFPx2r6L&quot;&gt;该指令表示该函数禁止进行内联。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;案例&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;//go:noinline
func unexportedPanicForTesting(b []byte, i int) byte {
 return b[i]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;dxLWWcbM&quot;&gt;我们观察一下这个案例，是直接通过索引取值，逻辑比较简单。如果不加上 &lt;code&gt;go:noinline&lt;/code&gt; 的话，就会出现编译器对其进行内联优化。&lt;/p&gt;&lt;p data-pid=&quot;Ia14Wd7_&quot;&gt;显然，内联有好有坏。该指令就是提供这一特殊处理。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;go:norace&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;ikVmDLa7&quot;&gt;该指令表示禁止进行竞态检测。&lt;/p&gt;&lt;p data-pid=&quot;nnRlwc6N&quot;&gt;常见的形式就是在启动时执行 &lt;code&gt;go run -race&lt;/code&gt;，能够检测应用程序中是否存在双向的数据竞争，非常有用。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;案例&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;//go:norace
func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err Errno) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;go:notinheap&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;yg7RNKhL&quot;&gt;该指令常用于类型声明，它表示这个类型不允许从 GC 堆上进行申请内存。&lt;/p&gt;&lt;p data-pid=&quot;-3mwbbWj&quot;&gt;在运行时中常用其来做较低层次的内部结构，避免调度器和内存分配中的写屏障，能够提高性能。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;案例&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// notInHeap is off-heap memory allocated by a lower-level allocator
// like sysAlloc or persistentAlloc.
//
// In general, it&#x27;s better to use real types marked as go:notinheap,
// but this serves as a generic type for situations where that isn&#x27;t
// possible (like in the allocators).
//
//go:notinheap
type notInHeap struct{}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;blockquote data-pid=&quot;c_AzwBks&quot;&gt;在本文我们简单介绍了一些常见的指令集，让大家有了整体的系统了解。这些指令平时在 Go 工程中我们是用不到的，常见的瓶颈可能更多的在自身应用上。&lt;br/&gt;不过在了解了这些机制后，对你阅读 Go 语言底层源码和了解运行机制会很有帮助 ：）&lt;/blockquote&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>