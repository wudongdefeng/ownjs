<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>37a0ed4f811b178f7d8fce5f06ff8358</guid>
<title>AI 视频编辑革新：GEN-1 / GEN-2 引领新风潮</title>
<link>https://toutiao.io/k/wr0ibbv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content &amp;#10;                       autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weuitheme=&quot;light&quot; data-id=&quot;MzIwMjE3MDIwMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/EwukgicNDWBttOY6gvx2I9WeXEsTO28t7f9z25ogyAedSsic0fovPQIDaTCCpibALUapHcjDjqEXBwf27ibdgR71iaQ/0?wx_fmt=png&quot; data-nickname=&quot;MavenTalk&quot; data-alias=&quot;mavenTalk&quot; data-signature=&quot;15+年IT人，创业者，关注人与自然的和谐成长.&quot; data-from=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在早先的一篇文章中《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwMjE3MDIwMA==&amp;amp;mid=2247487361&amp;amp;idx=1&amp;amp;sn=9830d06160097e484ba94a095e4c2b73&amp;amp;chksm=96e385b6a1940ca0f92358e91dd26d03575e94fe41e1fcccb0de8efd672389778106fcc6933b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;AI 学习心得速览（3月）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;AI 学习心得速览（3月）&lt;/a&gt;》，提到过一家AI视频公司RunWay，公司专注于 AI 视频处理，在二月份发布了第一个人工智能视频编辑模型 Gen-1，对视频素材进行转换成相应的风格。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4537037037037037&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/EwukgicNDWBt3mByIQF0Pib8xqZZOEibLGWVRgIZ0c3wT2e9hV1GbX0icP1AkibkTtx0iaqCjdv3zdrDsVLTCxYDrbbQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RunwayML&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天来聊聊Runway推出的手机App——RunwayML，已经在App Store上架，iPhone用户可以下载体验，有免费版和标准付费版、专业付费版三个版本。免费版提供初始积分，使用完之后只能升级版本才能继续使用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/EwukgicNDWBt3mByIQF0Pib8xqZZOEibLGWDhLWEPGjdDicwxLroWvhKQ70Xf0OLIfxtryCBvkyJAQWLPiaMic7Umh8Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前只有GEN-1版本可用，GEN-2视频及图片工具正在推进中，相信马上就可以面世使用；免费版对视频时长的要求是3秒钟，多余部分会被自动裁剪。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/EwukgicNDWBt3mByIQF0Pib8xqZZOEibLGWHDWNCdmoM9ibzEoxk5xps65TwPzbeicnhGfV8vxNTBbY2mDQzszac9zw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于要风格化的视频，内置了六种图像风格，同时也可以提供图片参考或文字描述，用于更加精确的图片处理（见下图）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1638888888888888&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/EwukgicNDWBt3mByIQF0Pib8xqZZOEibLGW0g91NFEQxIHE9YcI8CsgJeZz3ZP2NZkJ68hy94F0zq3xIWxycvJFAg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;处理之后的视频会存储在自己的Library里面，基于不同版本，存储的容量也不同，也可以保存在本地手机内存里面。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1638888888888888&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/EwukgicNDWBt3mByIQF0Pib8xqZZOEibLGWcqbh9WCb3OVvjsziaEygBfu7s6PDRaJsrO25QwVNia6PWvWcdxJGduSw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看一看我用一段海浪生成的四段视频效果（中间是原视频）：&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mp-common-videosnap class=&quot;channels_iframe videosnap_video_iframe&quot; data-type=&quot;video&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAfdsMUaOSiwAAAAstQy6ubaLX4KHWvLEZgBPE26MECTE3cJOAzNPgMIuOu_eeXgJgUTvBnt9lH6H1&quot; data-url=&quot;https://findermp.video.qq.com/251/20350/stodownload?encfilekey=oibeqyX228riaCwo9STVsGLPj9UYCicgttv21M9nibptUr9Vq8U6BWErrJWdKXZZ0IIL0E5n0IJOc0gIcicfCjHghiagmkNK2rsEUbLfibqc9fJVYgB7FJEKzTuhPzIVTfjTWZF2ODIicIxEY7A&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=cdc25459d90026ca0754821fd392ba83&amp;amp;token=x5Y29zUxcibDibNISWSia00LlRTrc6gbOq0cw1VJ9iaIlLhy4j2Gic4CxloILH9Q5WHyibMgzNe5vA8Mw&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM5EdAngvYufGCL6eE8CGxzD1Rbu13eU8U1kWjCuKbaAAQ/0&quot; data-nickname=&quot;MavenTalk&quot; data-username=&quot;v2_060000231003b20faec8c5eb891dc6dcca0dea37b0773da62a4f3806bc0fb18611df3f4f6b65@finder&quot; data-desc=&quot;#AI #AIGC #Runway 怎么把视频风格化展示，来看看这段海浪被AI处理后的水彩画，号称视频界的 #Midjourney&quot; data-mediatype=&quot;undefined&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot; data-nonceid=&quot;3958835662575475249&quot; data-parentwidth=&quot;330&quot; data-weui-theme=&quot;light&quot; data-isdisabled=&quot;0&quot; data-errortips=&quot;&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GEN-1与GEN-2有何区别，官方给出的答案是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;GEN-1使用扩散模型的结构和内容来引导视频合成，也就是Vedio to Vedio，依赖原始视频素材&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GEN-2使用文本驱动视频生成，即是Text to Vedio，摆脱原始视频素材依赖，直接由文字生成视频，工具性更强&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2324074074074074&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/EwukgicNDWBt3mByIQF0Pib8xqZZOEibLGWFWUIibkdQlqZYMyibKmxmGNFqMxthlDicicLXIyIZP3OajHeLxRMyib2Mhg/640?wx_fmt=png&quot;/&gt;[未来生成视频还会很复杂、繁琐吗？]&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Runway 工具箱&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6759259259259259&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/EwukgicNDWBt3mByIQF0Pib8xqZZOEibLGWIf8ZibduaRmJBj5WZwy7mPJbZxPleERINBcwfeQHaKy1jeRu0ZLmg8g/640?wx_fmt=png&quot;/&gt;Runway官方推出的27个工具集，主要功能集中于图片、视频的AI生成式处理，包括但不限于：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;图片擦除与替换&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;图片蒙版&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;视频慢动作&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;图像扩展&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;图像变体&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;黑白图色彩化&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;自动模糊视频中人脸&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;自动模糊视频背景&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;自动去除视频背景&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;自动替换视频背景音乐&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从视频中删除物体或人物&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5138888888888888&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/EwukgicNDWBt3mByIQF0Pib8xqZZOEibLGWBFYGzic53220ibSoskicwiagQR1PXEFklgdpJ8ibXZiaD5aRPeHScp2WEY3Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Runway 知名度虽然不如 Midjourney，但实力不凡，相信在 AI 视频领域，未来也是一个难以撼动的巨人。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.238888888888889&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/EwukgicNDWBt3mByIQF0Pib8xqZZOEibLGW60yMhlEnfkUjHh2PgAIPaaxcHnbbL82icnLpGErkedJN3sXKeXeVXHw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;扩展阅读：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weuitheme=&quot;light&quot; data-id=&quot;MzIwMjE3MDIwMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/EwukgicNDWBttOY6gvx2I9WeXEsTO28t7f9z25ogyAedSsic0fovPQIDaTCCpibALUapHcjDjqEXBwf27ibdgR71iaQ/0?wx_fmt=png&quot; data-nickname=&quot;MavenTalk&quot; data-alias=&quot;mavenTalk&quot; data-signature=&quot;15+年IT人，创业者，关注人与自然的和谐成长.&quot; data-from=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bf8f59e198ae244c2eb7cf6c6774b66b</guid>
<title>19个提高工作效率的JavaScript单行代码，爱不释手啊！</title>
<link>https://toutiao.io/k/e67jg9j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 生成随机字符串&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们需要一个唯一id时，通过&lt;code&gt;Math.random&lt;/code&gt;创建一个随机字符串简直不要太方便噢！！！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; randomString = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.random().toString(&lt;span&gt;36&lt;/span&gt;).slice(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;randomString() &lt;span&gt;// gi1qtdego0b&lt;/span&gt;&lt;br/&gt;randomString() &lt;span&gt;// f3qixv40mot&lt;/span&gt;&lt;br/&gt;randomString() &lt;span&gt;// eeelv1pm3ja&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.# 转义HTML特殊字符&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决XSS方法之一就是转义HTML。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;escape&lt;/span&gt; = &lt;span&gt;(&lt;span&gt;str&lt;/span&gt;) =&amp;gt;&lt;/span&gt; str.replace(&lt;span&gt;/[&amp;amp;&amp;lt;&amp;gt;&quot;&#x27;]/g&lt;/span&gt;, (m) =&amp;gt; ({ &lt;span&gt;&#x27;&amp;amp;&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;&amp;amp;amp;&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&amp;lt;&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;&amp;amp;lt;&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&amp;gt;&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;&amp;amp;gt;&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&quot;&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;&amp;amp;quot;&#x27;&lt;/span&gt;, &lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;: &lt;span&gt;&#x27;&amp;amp;#39;&#x27;&lt;/span&gt; }[m]))&lt;br/&gt;&lt;span&gt;escape&lt;/span&gt;(&lt;span&gt;&#x27;&amp;lt;div class=&quot;medium&quot;&amp;gt;Hi Medium.&amp;lt;/div&amp;gt;&#x27;&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;// &amp;amp;lt;div class=&amp;amp;quot;medium&amp;amp;quot;&amp;amp;gt;Hi Medium.&amp;amp;lt;/div&amp;amp;gt&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.# 单词首字母大写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; uppercaseWords = &lt;span&gt;(&lt;span&gt;str&lt;/span&gt;) =&amp;gt;&lt;/span&gt; str.replace(&lt;span&gt;/^(.)|\s+(.)/g&lt;/span&gt;, (c) =&amp;gt; c.toUpperCase())&lt;br/&gt;uppercaseWords(&lt;span&gt;&#x27;hello world&#x27;&lt;/span&gt;); &lt;span&gt;// &#x27;Hello World&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.# 将字符串转换为小驼峰&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; toCamelCase = &lt;span&gt;(&lt;span&gt;str&lt;/span&gt;) =&amp;gt;&lt;/span&gt; str.trim().replace(&lt;span&gt;/[-_\s]+(.)?/g&lt;/span&gt;, (_, c) =&amp;gt; (c ? c.toUpperCase() : &lt;span&gt;&#x27;&#x27;&lt;/span&gt;));&lt;br/&gt;toCamelCase(&lt;span&gt;&#x27;background-color&#x27;&lt;/span&gt;); &lt;span&gt;// backgroundColor&lt;/span&gt;&lt;br/&gt;toCamelCase(&lt;span&gt;&#x27;-webkit-scrollbar-thumb&#x27;&lt;/span&gt;); &lt;span&gt;// WebkitScrollbarThumb&lt;/span&gt;&lt;br/&gt;toCamelCase(&lt;span&gt;&#x27;_hello_world&#x27;&lt;/span&gt;); &lt;span&gt;// HelloWorld&lt;/span&gt;&lt;br/&gt;toCamelCase(&lt;span&gt;&#x27;hello_world&#x27;&lt;/span&gt;); &lt;span&gt;// helloWorld&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.# 删除数组中的重复值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得益于ES6，使用Set数据类型来对数组去重太方便了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; removeDuplicates = &lt;span&gt;(&lt;span&gt;arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; [...new &lt;span&gt;Set&lt;/span&gt;(arr)]&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(removeDuplicates([&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;])) &lt;br/&gt;&lt;span&gt;// [1, 2, 3, 4, 5, 6]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.# 铺平一个数组&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; flat = &lt;span&gt;(&lt;span&gt;arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;br/&gt;    [].concat.apply(&lt;br/&gt;        [],&lt;br/&gt;        arr.map(&lt;span&gt;(&lt;span&gt;a&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (&lt;span&gt;Array&lt;/span&gt;.isArray(a) ? flat(a) : a))&lt;br/&gt;    )&lt;br/&gt;&lt;span&gt;// Or&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; flat = &lt;span&gt;(&lt;span&gt;arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; arr.reduce(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (&lt;span&gt;Array&lt;/span&gt;.isArray(b) ? [...a, ...flat(b)] : [...a, b]), [])&lt;br/&gt;flat([&lt;span&gt;&#x27;cat&#x27;&lt;/span&gt;, [&lt;span&gt;&#x27;lion&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;tiger&#x27;&lt;/span&gt;]]) &lt;span&gt;// [&#x27;cat&#x27;, &#x27;lion&#x27;, &#x27;tiger&#x27;]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.# 移除数组中的假值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; removeFalsy = &lt;span&gt;(&lt;span&gt;arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; arr.filter(&lt;span&gt;Boolean&lt;/span&gt;)&lt;br/&gt;removeFalsy([&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&#x27;a string&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;, &lt;span&gt;NaN&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;undefined&lt;/span&gt;, &lt;span&gt;&#x27;another string&#x27;&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;])&lt;br/&gt;&lt;span&gt;// [&#x27;a string&#x27;, true, 5, &#x27;another string&#x27;]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.# 确认一个数字是奇数还是偶数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; isEven = &lt;span&gt;&lt;span&gt;num&lt;/span&gt; =&amp;gt;&lt;/span&gt; num % &lt;span&gt;2&lt;/span&gt; === &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;isEven(&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;isEven(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;// false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.# 获取两个数字之间的随机数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; random = &lt;span&gt;(&lt;span&gt;min, max&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;Math&lt;/span&gt;.random() * (max - min + &lt;span&gt;1&lt;/span&gt;) + min)&lt;br/&gt;random(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;) &lt;span&gt;// 25&lt;/span&gt;&lt;br/&gt;random(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;) &lt;span&gt;// 34&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.# 计算平均值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; average = &lt;span&gt;(&lt;span&gt;...args&lt;/span&gt;) =&amp;gt;&lt;/span&gt; args.reduce(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b) / args.length;&lt;br/&gt;average(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;);   &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.# 将数字截断到固定的小数点&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; round = &lt;span&gt;(&lt;span&gt;n, d&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt;(&lt;span&gt;Math&lt;/span&gt;.round(n + &lt;span&gt;&quot;e&quot;&lt;/span&gt; + d) + &lt;span&gt;&quot;e-&quot;&lt;/span&gt; + d)&lt;br/&gt;round(&lt;span&gt;1.005&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;//1.01&lt;/span&gt;&lt;br/&gt;round(&lt;span&gt;1.555&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;//1.56&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.# 计算两个日期之间天数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; diffDays = &lt;span&gt;(&lt;span&gt;date, otherDate&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.ceil(&lt;span&gt;Math&lt;/span&gt;.abs(date - otherDate) / (&lt;span&gt;1000&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;24&lt;/span&gt;));&lt;br/&gt;diffDays(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(&lt;span&gt;&quot;2021-11-3&quot;&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(&lt;span&gt;&quot;2022-2-1&quot;&lt;/span&gt;))  &lt;span&gt;// 90&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.# 从日期中获取是一年中的哪一天&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; dayOfYear = &lt;span&gt;(&lt;span&gt;date&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.floor((date - &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(date.getFullYear(), &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)) / (&lt;span&gt;1000&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;24&lt;/span&gt;))&lt;br/&gt;dayOfYear(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;()) &lt;span&gt;// 74&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.# 获取一个随机的颜色值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; randomColor = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;`#&lt;span&gt;${&lt;span&gt;Math&lt;/span&gt;.random().toString(&lt;span&gt;16&lt;/span&gt;).slice(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;).padEnd(&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;&lt;br/&gt;randomColor() &lt;span&gt;// #9dae4f&lt;/span&gt;&lt;br/&gt;randomColor() &lt;span&gt;// #6ef10e&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15.# 将RGB颜色转换为十六进制颜色值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; rgbToHex = &lt;span&gt;(&lt;span&gt;r, g, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;&quot;#&quot;&lt;/span&gt; + ((&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;) + (r &amp;lt;&amp;lt; &lt;span&gt;16&lt;/span&gt;) + (g &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt;) + b).toString(&lt;span&gt;16&lt;/span&gt;).slice(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;rgbToHex(&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;)  &lt;span&gt;// &#x27;#ffffff&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.# 清除所有的cookie&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; clearCookies = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;document&lt;/span&gt;.cookie.split(&lt;span&gt;&#x27;;&#x27;&lt;/span&gt;).forEach(&lt;span&gt;(&lt;span&gt;c&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (&lt;span&gt;document&lt;/span&gt;.cookie = c.replace(&lt;span&gt;/^ +/&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;).replace(&lt;span&gt;/=.*/&lt;/span&gt;, &lt;span&gt;`=;expires=&lt;span&gt;${&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;().toUTCString()}&lt;/span&gt;;path=/`&lt;/span&gt;)))&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.# 检测黑暗模式&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; isDarkMode = &lt;span&gt;window&lt;/span&gt;.matchMedia &amp;amp;&amp;amp; &lt;span&gt;window&lt;/span&gt;.matchMedia(&lt;span&gt;&#x27;(prefers-color-scheme: dark)&#x27;&lt;/span&gt;).matches&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.# 交换两个变量的值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[foo, bar] = [bar, foo]&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.# 暂停一会&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; pause = &lt;span&gt;(&lt;span&gt;millis&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;resolve&lt;/span&gt; =&amp;gt;&lt;/span&gt; setTimeout(resolve, millis))&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; fn = &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; pause(&lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;fatfish&#x27;&lt;/span&gt;) &lt;span&gt;// 1s later&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;fn()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d0fbc3b746a542adc4026353d8218db8</guid>
<title>go io 并发流</title>
<link>https://toutiao.io/k/gjjkqrp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;今天聊一个存储的实现细节，数据副本的并发写入&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储的高可靠性和高可用，必须依赖于数据的冗余机制。比如 3 副本就是把用户数据复制成 3 份。然后把 3 份数据分发到不同的地方。这个写下去的动作是&lt;strong&gt;有讲究的&lt;/strong&gt;，因为肯定不希望时延线性增加，你肯定希望的是虽然多写 2 份数据，但还只耗费 1 份时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，原则上数据虽然变多了，但是时间开销不能增加。那就只能&lt;strong&gt;并发写入&lt;/strong&gt;喽！那这个动作怎么实现呢？带大家思考几个小问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;副本冗余和并发写入的动作发生在哪里？姿势如何？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单次 IO 级别的并发和 IO 流的并发区别在哪里？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;星型写入和链式写入&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种最典型的姿势：星型写入和链式写入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-none-contnet=&quot;t&quot;&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;星型写入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;副本复制的动作发生在客户端。这种方式实现简单，异常处理好控制。&lt;strong&gt;缺点主要是节点的扇出大&lt;/strong&gt;，可能你的客户端网卡会是个瓶颈。这种方式数据分流分叉的决策点就是在客户端。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6156648451730419&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNe39T0jtYjWqicVI2e7gwHqiaHry7lNHt9Uia5mHaRMhjl4U2kUAAFI3LvU1GAYznicNZSfQE8gM9CRbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本篇就以这种方式举例&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-none-contnet=&quot;t&quot;&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;链式写入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不得不提当然还有另外一种典型的写入方式：链式写入。客户端把数据交个副本的第一个节点，然后由第一个节点交给第二个节点，再由第二个节点交给第三个节点。这种写入方式对比星型写入，每个节点的扇入扇出都是一份数据，没有明显的瓶颈点。网络的传输上&lt;strong&gt;更加均衡&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5854063018242123&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNe39T0jtYjWqicVI2e7gwHqiat7BYuia5MCOQBJpD37A9ZAP1hN6lCCVv17naibzKnhYI7WzA9DVicbVWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;IO 级别的并发&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是 IO 级别？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是看到的操作主体是一次 IO ，也就是单次 IO 。最常见的就是块存储下来的 IO ，块存储的使用姿势一般是 open 出一个句柄之后，通过这个句柄下发 IO 。我们处理的是每一次下发的 IO ，把每一次下发 IO 的数据做冗余，写入做并发。如下伪代码，比如一份数据拷贝多份，写 2 次：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 步骤一：获取到用户数据: buffer&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 步骤二：发往各个服务端节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;&lt;span&gt;2&lt;/span&gt;; i++ {&lt;br/&gt;   wn = write(&lt;span&gt;/*网络句柄*/&lt;/span&gt;, &lt;span&gt;/*buffer*/&lt;/span&gt;, &lt;span&gt;/*buffer len*/&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 等待响应，并且异常处理&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;循环调用 2 次发送即可。这种模式是 io 级别的，它处理的是这一笔 IO 。它的主要时延组成是两部分：网络 IO 的时延 + 磁盘 IO 的时延。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这个是单次 IO 级别的，buffer 可控的、较小的，网络传输的时延相比磁盘 IO （ 机械盘 ）几乎可以忽略。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3946360153256705&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNe39T0jtYjWqicVI2e7gwHqiapQ101uTJGTQib10tUFACqq7IMkWjlN2onjkjQ297c0IFzov5xcMqZibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;783&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里直接&lt;strong&gt;用循环来串行动作&lt;/strong&gt;来进行网络发送主要还是因为整体时延都在磁盘 IO，而磁盘 IO 在不同的节点是并发的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，&lt;strong&gt;存储介质现在越来越快（&lt;span&gt;比如&lt;/span&gt;&lt;span&gt; nvme 盘，傲腾盘等&lt;/span&gt;）&lt;/strong&gt;，磁盘 IO &lt;span&gt;和网&lt;/span&gt;&lt;span&gt;络 IO 的差距&lt;/span&gt;越来越小。这时候串行发送网络数据就不可取了。所以，网络传输的时延最好也是重叠的，把网络发送这部分也做成并发的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3997395833333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNe39T0jtYjWqicVI2e7gwHqiajOiaZict68qUKyEroLV7RE4BWeyfdpUEEgicSvvTfNu7x97GSDXz4GQdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络 IO 做并行化和异步化处理之后，串行的时延只有客户端循环拷贝多份内存了，内存拷贝这部分占比还是极低的，对比网络 IO 和磁盘 IO 可以忽略。当然，如果还要更极致一点，这部分时延也可以重叠起来。此处不表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;IO 流的并发&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单次 IO 的冗余和并发都是很容易理解。冗余嘛，就是把一份 buffer 拷贝出多份，并发嘛，就是把这多份数据并发的发送出去。这个都是很简单的 io 的操作调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Go 的 IO 不一样&lt;/strong&gt;！Go 的 IO 抽象了所谓的 io.Reader , io.Writer 出来。如果童鞋写过 Go 的 IO 相关的程序就很容易理解。这是一个典型的 IO 流的操作。IO 流的操作包含了成千上万次的 IO 调用。一般使用 io.Copy 这种函数来操作。io.Copy 的定义，接受一个读流、一个写流 ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;(dst Writer, src Reader)&lt;/span&gt; &lt;span&gt;(written &lt;span&gt;int64&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; copyBuffer(dst, src, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;io.Copy 的结束是要么读到 EOF 或者错误才算结束。所以这种情况如果对两个流用  io.Copy 操作，这个函数调用完，流也完成了。一次 io.Copy 并不是一次简单的 io 调用，一次 io.Copy 的函数调用里包含了成千上万次的 &lt;strong&gt;单次的 IO 操作&lt;/strong&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种就不能简单的用 for 循环来操作多次 io.Copy 了。用 for 循环那么 IO 的写入时延就无法叠加了，就是一个串行的时延。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;&lt;span&gt;2&lt;/span&gt;; i++ {&lt;br/&gt;    &lt;span&gt;// 时延纯线性增长，凉凉。。。。&lt;/span&gt;&lt;br/&gt;    io.Copy(&lt;span&gt;//)&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那该怎么办呢？把 IO 流一份为二或者一分为多？那么怎么才能把这个写入变成多份，并且写入的时间最好是重叠起来，只消耗 1 份时间呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 里，怎么做呢？奇伢先说步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;需要一个 teeReader 来分流&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要一个 Pipe 写转读&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要两个 goroutine 做并发&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-none-contnet=&quot;t&quot;&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;IO 流并发实战&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，需要一个 TeeReader ，这个组件主要是用来分流的，把一个读流分叉出一股数据流出去：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TeeReader&lt;/span&gt;&lt;span&gt;(r Reader, w Writer)&lt;/span&gt; &lt;span&gt;Reader&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;teeReader{r, w}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(t *teeReader)&lt;/span&gt; &lt;span&gt;Read&lt;/span&gt;&lt;span&gt;(p []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    n, err = t.r.Read(p)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; n &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 把读到的每一次数据都输入到 Writer 里去.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 分一股数据流出去&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; n, err := t.w.Write(p[:n]); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; n, err&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上，TeeReader 实现分流的原理也很简单，就是在每一次 Read 的调用中，都把数据写一份出去。好，现在我们流分叉有了，但是分出来的是一个写流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个好像不大对呢？能否有两个 Reader ，这两个读流里面流淌的是相同的数据。咋办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候就需要另外一个组件：Pipe 。调用 io.Pipe 会产生一个 Reader 和 Writer ，把数据写到 Writer 里，就能从 Reader 里原封不动的读出来。这可太适合写转读了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚好，就可以把 TeeReader 接着分出来的数据流用 Pipe 接着，于是乎你就有了&lt;strong&gt;两个相同的 Reader 数据流&lt;/strong&gt;，接下来只需要把它们放在不同的 goroutine 去操作，那么这个 IO 流就是并发的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Go 实战栗子 : &lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意，为了简单，省略一些异常处理：&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurrencyWrtie&lt;/span&gt;&lt;span&gt;(src io.Reader, dest [2]io.Writer)&lt;/span&gt; &lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    errCh := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; error, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 管道，主要是用来写、读流转化&lt;/span&gt;&lt;br/&gt;    pr, pw := io.Pipe()&lt;br/&gt;    &lt;span&gt;// teeReader ，主要是用来 IO 流分叉&lt;/span&gt;&lt;br/&gt;    wr := io.TeeReader(src, pw)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 并发写入&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; _err error&lt;br/&gt;        &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            pr.CloseWithError(_err)&lt;br/&gt;            errCh &amp;lt;- _err&lt;br/&gt;        }()&lt;br/&gt;        _, _err = io.Copy(dest[&lt;span&gt;1&lt;/span&gt;], pr)&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// TODO：异常处理&lt;/span&gt;&lt;br/&gt;        pw.Close()&lt;br/&gt;        _err := &amp;lt;-errCh&lt;br/&gt;        _ = _err&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 数据写入&lt;/span&gt;&lt;br/&gt;    _, err = io.Copy(dest[&lt;span&gt;0&lt;/span&gt;], wr)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，奇伢个人觉得：&lt;strong&gt;IO 流的并发其实更适合用链式的写入方式&lt;/strong&gt;。这个观点以后有机会分享。&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;总结&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;IO 级别的并发很简单，客户端用 for 循环发就行了，大部分时间是&lt;strong&gt;重叠&lt;/strong&gt;的（ 网络 IO &amp;amp; 磁盘 IO ），那么就是并发的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流式 IO 的并发也有套路，用 teeReader &lt;strong&gt;分流&lt;/strong&gt;，用 Pipe 把分出来的&lt;strong&gt;写流转成读流&lt;/strong&gt;，然后用不同的 goroutine 操作即可实现 IO 流的并发；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无论是什么样的并发，或多或少&lt;strong&gt;都会有串行的部分&lt;/strong&gt;。只要你把这部分的时间比例调整到极小，那整体就还是并发的效果；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9ff9456b550e1ad6c14c768cd714089f</guid>
<title>Java与Go到底差别在哪，谁要被时代抛弃？</title>
<link>https://toutiao.io/k/4xjp12x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content &amp;#10;                       autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-backh=&quot;239&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;239&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94cQiccAo2zibZETiaOnMVLNQAO0Zne2x8KlehRMR8AsOTW90m1pAicBEw5wBJFkQiax8ricKGbKibEKV8gQ/640?wx_fmt=png&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-backh=&quot;54&quot; data-backw=&quot;534&quot; data-ratio=&quot;0.1008174386920981&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe96srmm5CxquJGSP4BbZA8IDLUj8l7F3tzrm8VuILsgUPDciaDLtvQx78DbkrhAqOJicxze5ZUO5ZLNg/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; data-type=&quot;gif&quot; data-w=&quot;734&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template-rows=&quot;1&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👉&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;腾小云导读&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;本文针对Golang与Java的基础语法、结构体函数、异常处理、并发编程及垃圾回收、资源消耗等各方面的差异进行对比总结。欢迎阅读。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👉&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;看目&lt;/strong&gt;&lt;strong&gt;录，&lt;/strong&gt;&lt;strong&gt;点收藏&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1 基础语法&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;   1.1 变量&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   1.2 作用域规则&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   1.3 逗号 ok 模式&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;   1.4 结构体、函数以及方法&lt;/span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   1.5 值类型、引用类型以及指针&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2 面向对象&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   2.1 Java的OOP与Golang的结构体组合&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   2.2 侵入式与非侵入式接口  &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3 异常处理  &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   3.1 Java的异常处理&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   3.2 Golang的异常处理&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.并发编程&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   4.1 Java 和 Golang 的基本实现&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;   4.2 Java 和 Golang 的区别&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5 垃圾回收&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   5.1Java的垃圾回收体系&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   5.2Golang GC特征&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;6 &lt;/span&gt;&lt;span&gt;资源消耗对比&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   6.1 Java的JIT策略比Golang的AOT策略&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   6.2 内存分配和垃圾回收器&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   6.3 并发&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;   6.4 反射&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;7 生态&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;8 总结&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;基础语法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;:  编码风格及可见域规则严格且简单；&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Java:&lt;/strong&gt;  来说层次接口清晰、规范。主要表现有以下几个：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1变量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1.1 变量声明及使用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Java&lt;/strong&gt; ：变量可以声明了却不使用。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;int&lt;/span&gt; data = num; &lt;span&gt;return&lt;/span&gt; String.valueOf(num); }&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：声明的变量必须被使用，否则需要使用_来替代掉变量名，表明该变量不会比使用到。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;(num &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  data := num &lt;span&gt;// data没有使用者，无法编译&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;return&lt;/span&gt; strconv.Itoa(num)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;(num &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  _ := num &lt;span&gt;// 正常编译&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;return&lt;/span&gt; strconv.Itoa(num)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;1.1.2 变量声明及初始化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java ：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果在方法内部声明一个变量但不初始化，在使用时会出现编译错误。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;compareVariable&lt;/span&gt;() &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;int&lt;/span&gt; age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Object &lt;span&gt;object&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(age); &lt;span&gt;// 编译错误&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;object&lt;/span&gt;); &lt;span&gt;// 编译错误&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对于基本类型来讲，声明即初始化；&lt;/span&gt;&lt;span&gt;对于引用类型，声明则初始化为nil。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;compareVariable&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;var&lt;/span&gt; age &lt;span&gt;int&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;var&lt;/span&gt; hashMap *&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(num) &lt;span&gt;// num = 0&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(hashMap) &lt;span&gt;// &amp;amp;hashMap== nil&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;1.2 作用域规则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：对方法、变量及类的可见域规则是通过 private、protected、public 关键字来控制的,具体如下&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;作用域&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;当前类&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;同一package&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;子孙类 &lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;其他package&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;public&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;√    &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;√    &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;√    &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;√    &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;protected &lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;√    &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;√    &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;√    &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;×  &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;default（无修饰词）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;√    &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;√    &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;×  &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;× &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;private&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;√    &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;×  &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;×  &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;×  &lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：控制可见域的方式只有一个，当字段首字母开头是大写时说明其是对外可见的、小写时只对包内成员可见。 &lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;1.3 逗号 ok 模式&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在使用 Golang 编写代码的过程中，许多方法经常在一个表达式返回2个参数时使用这种模式：,ok，第一个参数是一个值或者 nil，第二个参数是 true/false 或者一个错误 error 。在一个需要赋值的 if 条件语句中，使用这种模式去检测第二个参数值会让代码显得优雅简洁。这种模式在 Golang 编码规范中非常重要。这是 Golang 自身的函数多返回值特性的体现。例如：&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; _, ok := conditionMap[&lt;span&gt;&quot;page&quot;&lt;/span&gt;]; ok {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;//&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;1.4 结构体、函数以及方法&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;1.4.1 结构体声明及使用&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 Golang 中区别与 Java 最显著的一点是：Golang 不存在“类”这个概念，组织数据实体的结构在 Golang 中被称为结构体。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;函数可以脱离“类”而存在，函数可以依赖于结构体来调用或者依赖于包名调用。Golang 中的结构体放弃了继承、实现等多态概念，结构体之间可使用组合来达到复用方法或者字段的效果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;声明一个结构体并使用：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// User 定义User结构体&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  Name &lt;span&gt;string&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  Age &lt;span&gt;int&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// 使用一个结构体&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  personPoint := &lt;span&gt;new&lt;/span&gt;(User) &lt;span&gt;// 通过new方法创建结构体指针&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  person1 := User{} &lt;span&gt;// 通过Person{}创建默认字段的结构体&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  person2 := User{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Name: &lt;span&gt;&quot;xiaoHong&quot;&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Age: &lt;span&gt;21&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(personPoint) &lt;span&gt;// &amp;amp;{ 0 }&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(person1) &lt;span&gt;// { 0 }&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(person2) &lt;span&gt;// {xiaoHong 21 }&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;声明实体并使用：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;User&lt;/span&gt;(&lt;span&gt;String name, &lt;span&gt;int&lt;/span&gt; age&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;(&lt;span&gt;String name&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setAge&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; age&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;() &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAge&lt;/span&gt;() &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;print&lt;/span&gt;() &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;{name = &quot;&lt;/span&gt; + name + &lt;span&gt;&quot;,age = &quot;&lt;/span&gt; + age + &lt;span&gt;&quot;}&quot;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;String[] args&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        User user = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;&quot;xiaohong&quot;&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;user信息：&quot;&lt;/span&gt; + user.print()); &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;//执行结果&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;user信息：{name = xiaohong,age = &lt;span&gt;29&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;1.4.2 函数和方法的区别&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 Java 中：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;所有的“函数”都是基于“类”这个概念构建的，也就是只有在“类”中才会包含所谓的“函数”，这里的“函数”被称为“方法”，可见上方声明实体并使用。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 Golang 中：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;“函数”和“方法”的最基本区别是：函数不基于结构体而是基于包名调用，方法基于结构体调用。如下实例：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;package&lt;/span&gt; entity&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  Name &lt;span&gt;string&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  Age &lt;span&gt;int&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// User结构体/指针可调用的&quot;方法&quot;，属于User结构体&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(user *User)&lt;/span&gt; &lt;span&gt;Solve&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(user)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// 任何地方都可调用的&quot;函数&quot;，不属于任何结构体，可通过entity.Solve调用&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Solve&lt;/span&gt;&lt;span&gt;(user *User)&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(user)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;userPoint &lt;/span&gt;:= &lt;span&gt;new&lt;/span&gt;(entity.User) // 通过new方法创建结构体指针&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  entity.&lt;span&gt;Solve&lt;/span&gt;(userPoint) // 函数调用&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  userPoint.&lt;span&gt;Solve&lt;/span&gt;() // 方法调用&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;1.5 值类型、引用类型以及指针&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在Java中不存在显式的指针操作；8种基本数据类型是值类型，数组和对象属于引用类型。&lt;br/&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;而 Golang 中存在显式的指针操作，但是 Golang 的指针不像C那么复杂，不能进行指针运算。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5633802816901409&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe96UtIwj5uyl21lveDXdiaSd0QPqBOQBvSjnj3pDGtiaOhCM0502xqRBsSsia5pGUqKghIRqqFlztstsA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;426&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所有的基本类型都属于值类型，但是有几个类型比较特殊，表现出引用类型的特征，分别是 slice、map、channel、interface 。除赋值以外它们都可以当做引用类型来使用。因此当我们这样做时，可以直接使用变量本身而不用指针。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;slice 与数组的区别为是否有固定长度，slice无固定长度，数组有固定长度。值得注意的是，在 Golang 中只有同长度、同类型的数组才可视为“同一类型”，譬如 []int 和 [3]int 则会被视为不同的类型，这在参数传递的时候会造成编译错误。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;1.5.1 数组对比&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 Java 中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;当向方法中传递数组时，可以直接通过该传入的数组修改原数组内部值（&lt;/span&gt;&lt;span&gt;浅拷贝&lt;/span&gt;&lt;span&gt;）。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 Golang 中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;则有两种情况：&lt;span&gt;在不限定数组长度(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;为 slice&lt;/span&gt;&lt;span&gt;&lt;span&gt; )时也&lt;span&gt;直接改变原数组的值，当限定数组长度时&lt;/span&gt;&lt;/span&gt;会完全复制出一份副本，来进行修改（&lt;/span&gt;&lt;span&gt;深拷贝&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java 的数组实践：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;int&lt;/span&gt;[] &lt;span&gt;array&lt;/span&gt; = {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;};&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        change(&lt;span&gt;array&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(Arrays.toString(&lt;span&gt;array&lt;/span&gt;)); &lt;span&gt;// -1,2,3&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;change&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] &lt;span&gt;array&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;array&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;-1&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang 的数组实践：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 不限定长度（即slice）:&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;var&lt;/span&gt; array = []&lt;span&gt;int&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  change(array)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(array) &lt;span&gt;// [-1 2 3]&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;change&lt;/span&gt;&lt;span&gt;(array []&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  array[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;-1&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 限定长度（即数组）：&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;var&lt;/span&gt; array = [&lt;span&gt;3&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  change(array)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(array) &lt;span&gt;//[1 2 3]&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;change&lt;/span&gt;&lt;span&gt;(array [3]&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  array[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;-1&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;1.5.2&lt;/strong&gt;&lt;strong&gt;对象对比&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 Golang 中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：传入函数参数的是原对象的一个全新的 copy （&lt;/span&gt;&lt;span&gt;有自己的内存地址&lt;/span&gt;&lt;span&gt;）; go 对象之间赋值是把对象内存的 内容（&lt;/span&gt;&lt;span&gt;字段值等&lt;/span&gt;&lt;span&gt;）copy 过去，所以才会看到 globalUser 修改前后的地址不变，但是对象的内容变了。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 Java 中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：传入函数参数的是原对象的引用的 copy（&lt;/span&gt;&lt;span&gt;指向的是同样的内存地址&lt;/span&gt;&lt;span&gt;）; Java对象之间的赋值是把对象的引用  copy 过去，因为引用指向的地址变了，所以对象的内容也变了。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang 的对象实践：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;//User 定义User结构体&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   Name &lt;span&gt;string&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   Age &lt;span&gt;int&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// 定义一个全局的User&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;var&lt;/span&gt; globalUser = User {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&quot;xiaoming&quot;&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;28&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// modifyUser 定义一个函数，参数为User结构体“对象”，将全局globalUser指向传递过来的User结构体“对象”&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;modifyUser&lt;/span&gt;&lt;span&gt;(user User)&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   fmt.Printf(&lt;span&gt;&quot;参数user的地址 = %p\n&quot;&lt;/span&gt;,&amp;amp;user) &lt;br mpa-from-tpl=&quot;t&quot;/&gt;   fmt.Printf(&lt;span&gt;&quot;globalUser修改前的地址 = %p\n&quot;&lt;/span&gt;,&amp;amp;globalUser)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   fmt.Println(&lt;span&gt;&quot;globalUser修改前 = &quot;&lt;/span&gt;,globalUser)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;// 修改指向&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   globalUser = user&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   fmt.Printf(&lt;span&gt;&quot;globalUser修改后的地址 = %p\n&quot;&lt;/span&gt;,&amp;amp;globalUser)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   fmt.Println(&lt;span&gt;&quot;globalUser修改后 = &quot;&lt;/span&gt;,globalUser)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;var&lt;/span&gt; u User = User {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&quot;xiaohong&quot;&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;29&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   fmt.Printf(&lt;span&gt;&quot;将要传递的参数u的地址 = %p\n&quot;&lt;/span&gt;,&amp;amp;u)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   modifyUser(u)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// 执行结果&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;将要传递的参数u的地址 = &lt;span&gt;0xc0000ac018&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;参数user的地址 = &lt;span&gt;0xc0000ac030&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;globalUser修改前的地址 = &lt;span&gt;0x113a270&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;globalUser修改前 = {xiaoming &lt;span&gt;28&lt;/span&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;globalUser修改后的地址 = &lt;span&gt;0x113a270&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;globalUuser修改后 = {xiaohong &lt;span&gt;29&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java 的对象实践验证：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;User&lt;/span&gt;(&lt;span&gt;String name, &lt;span&gt;int&lt;/span&gt; age&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;(&lt;span&gt;String name&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setAge&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; age&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;() &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAge&lt;/span&gt;() &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;print&lt;/span&gt;() &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;{name = &quot;&lt;/span&gt; + name + &lt;span&gt;&quot;,age = &quot;&lt;/span&gt; + age + &lt;span&gt;&quot;}&quot;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; User globalUser = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;&quot;xiaoming&quot;&lt;/span&gt;,&lt;span&gt;28&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyUser&lt;/span&gt;(&lt;span&gt;User user&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;参数globalUser的地址 = &quot;&lt;/span&gt; + user);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;globalUser修改前的地址 = &quot;&lt;/span&gt; + globalUser);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;globalUser修改前 = &quot;&lt;/span&gt; + globalUser.print());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        globalUser = user;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;globalUser修改后的地址 = &quot;&lt;/span&gt; + globalUser);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;globalUser修改后 = &quot;&lt;/span&gt; + globalUser.print());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;String[] args&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        User user = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;&quot;xiaohong&quot;&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;将要传递的参数user的地址 = &quot;&lt;/span&gt; + user);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        modifyUser(user);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;//执行结果&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;将要传递的参数user的地址 = com.example.demo.User@&lt;span&gt;5&lt;/span&gt;abca1e0&lt;br mpa-from-tpl=&quot;t&quot;/&gt;参数globalUser的地址 = com.example.demo.User@&lt;span&gt;5&lt;/span&gt;abca1e0&lt;br mpa-from-tpl=&quot;t&quot;/&gt;globalUser修改前的地址 = com.example.demo.User@&lt;span&gt;2286778&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;globalUser修改前 = {name = xiaoming,age = &lt;span&gt;28&lt;/span&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;globalUser修改后的地址 = com.example.demo.User@&lt;span&gt;5&lt;/span&gt;abca1e0&lt;br mpa-from-tpl=&quot;t&quot;/&gt;globalUser修改后 = {name = xiaohong,age = &lt;span&gt;29&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;1.5.3指针的区别&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 Java 中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：如果传递了引用类型（&lt;/span&gt;&lt;span&gt;对象、数组等&lt;/span&gt;&lt;span&gt;）会复制其指针进行传递&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 Golang 中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：必须要显式传递 Person 的指针，不然只是传递了该对象的一个副本。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang 的指针：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// User 定义User结构体&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  Name &lt;span&gt;string&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  Age &lt;span&gt;int&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  p1 := User{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Name: &lt;span&gt;&quot;xiaohong&quot;&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Age: &lt;span&gt;21&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  changePerson(p1)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(p1.Name) &lt;span&gt;// xiaohong&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  changePersonByPointer(&amp;amp;p1)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(p1.Name) &lt;span&gt;// xiaoming&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;changePersonByPointer&lt;/span&gt;&lt;span&gt;(user *User)&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  user.Name = &lt;span&gt;&quot;xiaoming&quot;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;changePerson&lt;/span&gt;&lt;span&gt;(user User)&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  user.Name = &lt;span&gt;&quot;xiaoming&quot;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Java 的指针：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;changePerson&lt;/span&gt;(&lt;span&gt;User user&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        user.setName(&lt;span&gt;&quot;xiaoming&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;String[] args&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        User user = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;&quot;xiaohong&quot;&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        changePerson(user);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;user信息：&quot;&lt;/span&gt; + user.getName()); &lt;span&gt;// xiaoming&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;User&lt;/span&gt;(&lt;span&gt;String name, &lt;span&gt;int&lt;/span&gt; age&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;(&lt;span&gt;String name&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setAge&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; age&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;() &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAge&lt;/span&gt;() &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot; draggable=&quot;true&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;面向对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;在 Golang 中&lt;/strong&gt;：没有明确的 OOP 概念，&lt;span&gt;Go语言只提供了两个关键类型：struct，interface 。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 Java 中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：面向对象语言的&lt;span&gt;&lt;span&gt;封装、继承、多态的特性以及&lt;/span&gt;“继承（ &lt;/span&gt;&lt;/span&gt;&lt;span&gt;extends &lt;/span&gt;&lt;span&gt;）、实现（ &lt;/span&gt;&lt;span&gt;implements &lt;/span&gt;&lt;span&gt;）”等关键字。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;2.1 &lt;span&gt;Java的OOP与Golang的结构体组合&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;假设有这么一个场景：动物（ &lt;/span&gt;&lt;span&gt;Animal &lt;/span&gt;&lt;span&gt;）具备名字（ &lt;/span&gt;&lt;span&gt;Name &lt;/span&gt;&lt;span&gt;）、年龄（ &lt;/span&gt;&lt;span&gt;Age &lt;/span&gt;&lt;span&gt;）的基本特性，现在需要实现一个狗( &lt;/span&gt;&lt;span&gt;Dog&lt;/span&gt;&lt;span&gt; )，且 Dog 需要具备  Animal 所需的所有特性，并且自身具备犬吠（ &lt;/span&gt;&lt;span&gt;bark ()&lt;/span&gt;&lt;span&gt;）的动作。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先来看看最熟悉的Java要如何写，很简单，使用抽象类描述 Animal 作为所有动物的超类， Dog extends Animal ：&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    String name;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;int&lt;/span&gt; age;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;bark&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(age + &lt;span&gt;&quot;岁的&quot;&lt;/span&gt; + name + &lt;span&gt;&quot;在汪汪叫&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Dog dog = &lt;span&gt;new&lt;/span&gt; Dog();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        dog.name = &lt;span&gt;&quot;小龙&quot;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        dog.age = &lt;span&gt;2&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        dog.bark(); &lt;span&gt;// 2岁的小龙在汪汪叫&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    } &lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在 Golang 中，可以这样通过结构体的组合来实现：&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;type&lt;/span&gt; Animal &lt;span&gt;struct&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  Name &lt;span&gt;string&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  Age &lt;span&gt;int&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;type&lt;/span&gt; Dog &lt;span&gt;struct&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  *Animal&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(dog *Dog)&lt;/span&gt; &lt;span&gt;Bark&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Printf(&lt;span&gt;&quot;%d岁的%s在汪汪叫&quot;&lt;/span&gt;, dog.Age, dog.Name)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  dog := &amp;amp;Dog{&amp;amp;Animal{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Name: &lt;span&gt;&quot;小龙&quot;&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Age: &lt;span&gt;2&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  dog.Bark() &lt;span&gt;// 2岁的小龙在汪汪叫...&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;2.2 侵入式与非侵入式接口  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 Java 中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：接口主要作为不同组件之间的契约存在。对契约的实现是强制的，你必须声明你的确实现了该接口。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这类接口我们称为侵入式接口。“侵入式”的主要表现在于，实现类需要明确声明自己实现了某个接口。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 Golang 中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：非侵入式接口不需要通过任何关键字声明类型与接口之间的实现关系，只要一个类型实现了接口的所有方法，那么这个类型就是这个接口的实现类型。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：管理狗的行为，可以通过以下接口实现。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Bark&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DogImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Bark&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;汪汪叫&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Demo&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Dog dog = &lt;span&gt;new&lt;/span&gt; DogImpl();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        dog.Bark(); &lt;span&gt;// 汪汪叫&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; : 假设现在有一个 Factory 接口，该接口中定义了 Produce() 方法及  Consume() 方法， CafeFactory 结构体作为其实现类型。那么可以通过以下代码实现。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;package&lt;/span&gt; entity&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;type&lt;/span&gt; Factory &lt;span&gt;interface&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  Produce() &lt;span&gt;bool&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  Consume() &lt;span&gt;bool&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;type&lt;/span&gt; CarFactory &lt;span&gt;struct&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  ProductName &lt;span&gt;string&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *CarFactory)&lt;/span&gt; &lt;span&gt;Produce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Printf(&lt;span&gt;&quot;CarFactory生产%s成功&quot;&lt;/span&gt;, c.ProductName)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *CarFactory)&lt;/span&gt; &lt;span&gt;Consume&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Printf(&lt;span&gt;&quot;CarFactory消费%s成功&quot;&lt;/span&gt;, c.ProductName)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// --------------&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  factory := &amp;amp;entity.CarFactory{&lt;span&gt;&quot;Car&quot;&lt;/span&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  doProduce(factory)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  doConsume(factory)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doProduce&lt;/span&gt;&lt;span&gt;(factory entity.Factory)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;return&lt;/span&gt; factory.Produce()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doConsume&lt;/span&gt;&lt;span&gt;(factory entity.Factory)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;return&lt;/span&gt; factory.Consume()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Golang&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 的非侵入式接口优点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;简单、高效、按需实现，具体来说如下：&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;在 Go 中，类没有继承的概念，只需要知道这个类型实现了哪些方法，每个方法是啥行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实现类型的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理。接口由使用方按需定义，而不用事前规划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;减少包的引入，因为多引用一个外部的包，就意味着更多的耦合。接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口。&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Java &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的侵入式接口优点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;层次结构清晰，对类型的动作行为有严格的管理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;03&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;异常处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 Java 中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;:  通过 try..catch..finally 的方式进行异常处理，有可能出现异常的代码会被 try 块给包裹起来，在 catch 中捕获相关的异常并进行处理，最后通过finally块来统一执行最后的结束操作（&lt;/span&gt;&lt;span&gt;释放资源&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在Golang中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：错误处&lt;/span&gt;&lt;span&gt;理方式有两种方式：, ok 模式  与 defer、panic及 recover 的组合。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;3.1 Java 的异常处理&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExceptionTest&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;String[] args&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        FileInputStream fileInputStream = &lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;try&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            fileInputStream = &lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;span&gt;catch&lt;/span&gt; (IOException e){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            System.&lt;span&gt;out&lt;/span&gt;.println(e.getMessage());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            e.printStackTrace();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;span&gt;finally&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;if&lt;/span&gt;(fileInputStream!=&lt;span&gt;null&lt;/span&gt;){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    fileInputStream.close();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    e.printStackTrace();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;回收资源&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;3.2 Golang 的异常处理&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Golang 的&lt;span&gt;, ok 模式&lt;/span&gt;。所有可能出现异常的方法或者代码直接把错误当作第二个响应值进行返回，程序中对返回值进行判断，非空则进行处理并且立即中断程序的执行。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：这种比 Java 的简单很多，是 Golang 在异常处理方式上的一大特色。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：代码冗余，所有的异常都需要通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;if err != nil {} &lt;/span&gt;&lt;/code&gt;&lt;span&gt;去做判断和处理，不能做到统一捕捉和处理，容易遗漏。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  value, err := Bark()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// 返回了异常，进行处理&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    log.error(&lt;span&gt;&quot;...异常：&quot;&lt;/span&gt;, err)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;return&lt;/span&gt; err&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;// Bark方法执行正确，继续执行后续代码&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  Process(value)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang 的 &lt;span&gt;defer 、panic 及 recover &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;defer 是 Golang 错误处理中常用的关键字， pannic 及 recover 是 Golang 中的内置函数，通常与 defer 结合进行错误处理，它们各自的用途为:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;defer的作用是延迟执行某段代码，一般用于关闭资源或者执行必须执行的收尾操作，无论是否出现错误defer代码段都会执行，类似于 Java 中的  finally 代码块的作用；defer 也可以执行函数或者是匿名函数：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;// 清理工作&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;} ()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// 这是传递参数给匿名函数时的写法&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;var&lt;/span&gt; num := &lt;span&gt;1&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(num &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;// 做你复杂的清理工作&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;} (num)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意的是， defer 使用一个栈来维护需要执行的代码，所以 defer 函数所执行的顺序是和 defer 声明的顺序相反的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;defer&lt;/span&gt; fmt.Println(a) &lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;defer&lt;/span&gt; fmt.Println(b)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;defer&lt;/span&gt; fmt.Println(c)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;执行结果：&lt;br mpa-from-tpl=&quot;t&quot;/&gt;c&lt;br mpa-from-tpl=&quot;t&quot;/&gt;b&lt;br mpa-from-tpl=&quot;t&quot;/&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;panic 的作用是抛出错误，制造系统运行时恐慌。当在一个函数执行过程中调用 panic ()函数时，正常的函数执行流程将立即终止。但函数中之前使用 defer 关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致逐层向上执行 panic 流程，直至所属的 goroutine 中所有正在执行的函数被终止， panic 和 Java 中的 throw 关键字类似：用于抛出错误，阻止程序执行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;recover 的作用是捕捉 panic 抛出的错误并进行处理，需要联合 defer 来使用，&lt;strong&gt;类似于 Java 中的 catch 代码块：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      fmt.Println(&lt;span&gt;&quot;main begin&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;// 必须要先声明defer，否则不能捕获到panic异常&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; { &lt;br mpa-from-tpl=&quot;t&quot;/&gt;        fmt.Println(&lt;span&gt;&quot;defer begin&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt; err := &lt;span&gt;recover&lt;/span&gt;(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;// 这里的err其实就是panic传入的内容&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            fmt.Println(err) &lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;         fmt.Println(&lt;span&gt;&quot;defer end&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      test()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;// test中出现错误，这里开始下面代码不会再执行&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      fmt.Println(&lt;span&gt;&quot;main end&quot;&lt;/span&gt;) &lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   fmt.Println(&lt;span&gt;&quot;test begin&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;error&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;//这里开始下面代码不会再执行&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   fmt.Println(&lt;span&gt;&quot;test end&quot;&lt;/span&gt;) &lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;//执行结果&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;main begin&lt;br mpa-from-tpl=&quot;t&quot;/&gt;test begin&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;defer&lt;/span&gt; begin&lt;br mpa-from-tpl=&quot;t&quot;/&gt;error&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;defer&lt;/span&gt; end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;注：利用 recover 处理 panic 指令，defer 必须在 panic 之前声明，否则当 panic 时， recover 无法捕获到 panic 。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;04&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;并发编程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Java 中 CPU 资源分配对象是 Thread，Go 中 CPU 资源分配对象是 goroutine。Java Thread 与系统线程为一一对应关系，goroutine 是 Go 实现的用户级线程，与系统线程是 m:n 关系。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;1 Java 和 Golang 的基本实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 Java 中，如要获得 CPU 资源并异步执行代码单元，需要将代码单元包装成 Runnable，并创建可以运行代码单元的 Thread ,执行 start 方法启动线程：&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Runnable task = &lt;span&gt;&lt;span&gt;()&lt;/span&gt;-&amp;gt;&lt;/span&gt; System.out.println(&lt;span&gt;&quot;task running&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;Thread t = &lt;span&gt;new&lt;/span&gt; Thread(task);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;t.start();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Java 应用一般使用线程池集中处理任务，以避免线程反复创建回收带来的开销：&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Runnable task = &lt;span&gt;&lt;span&gt;()&lt;/span&gt;-&amp;gt;&lt;/span&gt; System.out.println(&lt;span&gt;&quot;task running&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;Executor executor = Executors.newCachedThreadPool();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;executor.execute(task);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在 Golang 中，则需要将代码包装成函数。使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 关键字调用函数之后，便创建了一个可以运行代码单元的 goroutine 。一旦 CPU 资源就绪，对应的代码单元便会在 goroutine 中执行：&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(&lt;span&gt;&quot;test task running&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;4.2 Java 和 Golang 的区别&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;Golang 语言采用了 CSP（ &lt;/span&gt;&lt;span&gt;Communicating Sequential Processes &lt;/span&gt;&lt;span&gt;）的模型，其中以 goroutine 和 channel 作为主要实现手段。Java则采用了多线程模型，其中以 Thread 和 Synchronization 作为主要实现手段。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Golang 语言的 goroutine 是一种轻量级的线程，它们的创建和销毁速度比 Java 中的线程快得多。在 Java 中，创建和销毁线程都需要相当大的开销。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Golang 语言的 channel 是一种同步数据传递的机制，它可以方便地解决多道程序之间的通信问题。Java 中则需要使用同步工具（如 Semaphore 、 CountDownLatch 等）来解决多线程之间的通信问题。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Java 和 Go 官方库中同步方式的对应关系表&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;span&gt;&lt;strong&gt;关系&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; Golang&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;锁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;synchronized,ReentrantLock&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;sync.Mutex, one unit buffered channel&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;读写锁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;ReentrantReadWriteLock, StampedLock&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;sync.RWMutex&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;条件变量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;condition&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;sync.Cond&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;CAS/Atomic&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;Varhandle、volatile，Atomic 类&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;atomic.Value，atomic 包&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;once&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;单例模式&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;sync.Once&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;4.2.1 Java synchronized 与 Golang Mutex&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;Java synchronized ：线程 A 在 t1 时刻释放 JVM 锁后（&lt;/span&gt;&lt;span&gt;monitor exit&lt;/span&gt;&lt;span&gt;)，在随后的 t2 时刻，若任意线程 B 获取到 JVM 锁（&lt;/span&gt;&lt;span&gt;monintor enter&lt;/span&gt;&lt;span&gt;），则线程 A 在 t1 时刻之前发生的所有写入均对 B 可见。synchronized 是 JVM 内置锁实现，写入 volatile 变量相当于 monitor exit，读取 volatile 变量相当于 monintor enter。即一把锁只能同时被一个线程获取，没有获得锁的线程只能阻塞等待。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;synchronized 的使用：&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;修饰一个代码块，被修饰的代码块称为同步代码块，作用范围是大括号{}括起来的代码：&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     &lt;span&gt;// todo some thing &lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;修饰一个方法，被修饰的方法称为同步方法，其作用范围是整个方法：&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;// todo some thing&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;修改一个静态方法，作用范围是整个静态方法：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;// todo some thing&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;修改一个类，作用范围是synchronized后面括号括起来的部分：&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DemoClass&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;synchronized&lt;/span&gt;(DemoClass.class) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;         &lt;span&gt;// todo some thing&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Go Mutex&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Go 并未像 Java 一样提供 volatile 这样基础的关键字，但其 Mutex 相关内存模型和 synchronized 或 Java 官方库 Lock 实现有十分接近语义。若 goroutine A 在 t1 时刻释放 sync.Mutex 或 sync.RWMutex 后，在随后的 t2 时刻，若任意 goroutine B 获取到锁，则 goroutine A 在 t1 时刻之前发生的所有写入均对 B 可见。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Mutex的使用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;修饰&lt;/span&gt;&lt;span&gt;关键代码：每次只有一个线程对这个关键变量进行修改，避免多个线程同时这个关键代码进行操作。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;var&lt;/span&gt; mutex sync.Mutex&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  count := &lt;span&gt;0&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      mutex.Lock() &lt;span&gt;// 加锁&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      count += &lt;span&gt;1&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      mutex.Unlock() &lt;span&gt;// 解锁&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;// 休眠，等待2s&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  time.Sleep(time.Second * &lt;span&gt;2&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;// 100，没有加锁结果不正确&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Println(&lt;span&gt;&quot;count = &quot;&lt;/span&gt;, count)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;修饰结构体&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt; &lt;span&gt;带锁结构体初始化后，直接调用对应的线程安全函数就可以。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; count &lt;span&gt;struct&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  lock sync.Mutex&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  value &lt;span&gt;int&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// 结构体对应的结构方法&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(receiver *count)&lt;/span&gt; &lt;span&gt;countOne&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  receiver.lock.Lock()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;defer&lt;/span&gt; receiver.lock.Unlock()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  receiver.value++&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  c := count{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    lock: sync.Mutex{},&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    value: &lt;span&gt;0&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  group := sync.WaitGroup{}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    group.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(count2 *count)&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;defer&lt;/span&gt; group.Done()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        count2.countOne()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }(&amp;amp;c)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  group.Wait()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  fmt.Printf(&lt;span&gt;&quot;The count value is %d&quot;&lt;/span&gt;, c.value) &lt;span&gt;// The count value is 1000&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;4.2&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;.2 条件变量&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般来说，条件变量衍生于锁，不同条件变量只是同一锁空间下的不同等待队列。Java 可以使用 synchronized 代码块保护特定代码路径，兼而可以在 synchronized 代码块中使用 Object wait 和 notify、notifyall 方法实现单一条件等待。如果需要多个条件，可以使用官方库提供的 Lock 实现和 Condition 实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Java 创建条件变量的方式是调用 Lock 接口 newCondition 方法。Go sync.Cond 结构体需设置 sync.Mutex 字段才能工作，挂起方法为 Wait，唤醒方法为 Braodcast。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;Go 语言里面条件变量的通知 Signal() 和 Broadcast()，并没有在锁的保护下执行，而是在 Unlock() 之后执行。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;4.2.3 CAS/Atomic&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;原子性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为原子性（atomicity）。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;CAS是&lt;/span&gt;乐观锁&lt;span&gt;技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Java 和 Go 均支持 CAS 及原子操作。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在Java中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：  CAS 操作由 volatile 关键字和 VarHandle（9 之前是 UnSafe）支持，在此基础上有了 Atomic 类和并发包中的大量无锁实现（如 ConcurrentHashMap, AQS 队列等）。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在Golang中&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：atomic.Value 提供了 CAS 操作基础，它保证任意类型（interface {}) 的 Load 和 Store 为原子操作，在此基础上有 atomic 包。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;4.2.4 Once 与单例模式&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;sync.Once 是 Golang 标准库提供的使函数只执行一次的实现，常应用于单例模式，例如初始化配置、保持数据库连接等。它有 2 个特性：&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;section&gt;&lt;span&gt;1、保证程序运行期间某段代码只会执行一次；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、如果多个 goroutine 同时执行 Once 守护代码，只有 1 个 goroutine 会获得执行机会，其他 goroutine 会阻塞直至代码执行完毕。&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;var&lt;/span&gt; once = sync.Once{}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  f := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    time.Sleep(&lt;span&gt;10&lt;/span&gt; * time.Millisecond)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    fmt.Println(&lt;span&gt;&quot;do once&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    fmt.Println(&lt;span&gt;&quot;do once start&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    once.Do(f)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    fmt.Println(&lt;span&gt;&quot;do once finish&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  time.Sleep(&lt;span&gt;1&lt;/span&gt; * time.Millisecond)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;2&lt;/span&gt;; i++ {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      fmt.Println(&lt;span&gt;&quot;block...&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      once.Do(f)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      fmt.Println(&lt;span&gt;&quot;resume&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  time.Sleep(&lt;span&gt;10&lt;/span&gt; * time.Millisecond)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;span&gt;//~&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;do once start&lt;br mpa-from-tpl=&quot;t&quot;/&gt;block...&lt;br mpa-from-tpl=&quot;t&quot;/&gt;block...&lt;br mpa-from-tpl=&quot;t&quot;/&gt;do once&lt;br mpa-from-tpl=&quot;t&quot;/&gt;do once finish&lt;br mpa-from-tpl=&quot;t&quot;/&gt;resume&lt;br mpa-from-tpl=&quot;t&quot;/&gt;resume&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;java中单例模式的写法有好几种，主要是懒汉式单例、饿汉式单例。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;懒汉式单例&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;: 懒汉式单例的实现没有考虑线程安全问题，需要结合synchronized，保证线程安全。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;//懒汉式单例类.在第一次调用的时候实例化自己 &lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton single=&lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;//静态工厂方法 &lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; Singleton &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;         &lt;span&gt;if&lt;/span&gt; (single == &lt;span&gt;null&lt;/span&gt;) { &lt;br mpa-from-tpl=&quot;t&quot;/&gt;             single = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;         } &lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; single;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;饿汉式单例&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;//饿汉式单例类.在类初始化时，已经自行实例化 &lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Singleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Singleton single = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;//静态工厂方法 &lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; single;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;05&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;垃圾回收&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1/&gt;&lt;section&gt;&lt;span&gt;GC(Garbage Collection)垃圾回收是一种自动管理内存的方式，支持GC的语言无需手动管理内存，程序后台自动判断对象是否存活并回收其内存空间，使开发人员从内存管理上解脱出来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;因为支持更多的特性和更灵活多样的GC策略, 比如分代,对象可移动,各种参数调节等等. 而Go只做了一种GC方案,不分代,不可移动,没什么参数能调节,而且更注重暂停时间的优化,执行GC的时机更频繁, 所以Go通常更占更少的内存,但代价就是GC性能比JVM差了不少。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;5.1 Java 的垃圾回收体系&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;Java 基于 JVM 完成了垃圾收集的功能，其体系很庞大，包括了垃圾回收器（ &lt;/span&gt;&lt;span&gt;G1、CMS、Serial、ParNew 等&lt;/span&gt;&lt;span&gt;）、垃圾回收算法(&lt;/span&gt;&lt;span&gt;标记-清除、标记-整理、复制、分代收集&lt;/span&gt;&lt;span&gt;)、可达性算法(&lt;/span&gt;&lt;span&gt;可达性分析、引用计数法&lt;/span&gt;&lt;span&gt;)、引用类型、JVM内存模型等内容。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过多代发展， Java 的垃圾回收机制较为完善，Java划分新生代、老年代来存储对象。对象通常会在新生代分配内存，多次存活的对象会被移到老年代，由于新生代存活率低，产生空间碎片的可能性高，通常选用“标记-复制”作为回收算法，而老年代存活率高，通常选用“标记-清除”或“标记-整理”作为回收算法，压缩整理空间。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;5.2 Golang GC 特征&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;三色标记、并发标记和清扫、非分代、非紧缩、写屏障&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;5.2.1 三色标记&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;程序开始时有黑白灰三个集合，初始时所有对象都是白色；&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从root对象开始标记，将所有可达对象标记为灰色；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从灰色对象集合取出对象，将其引用对象标记为灰色，放入灰色集合，并将自己标记为黑色；&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重复第三步，直到灰色集合为空，即所有可达对象全部都被标记；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;标记结束后，不可达白色对象即为垃圾，对内存进行迭代清扫，回收白色对象；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重置GC状态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;5.2.2 非分代&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;Java 采用分代回收（&lt;/span&gt;&lt;span&gt;按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率&lt;/span&gt;&lt;span&gt;）， Golang 没有分代，一视同仁。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;5.2.3 非紧缩&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在垃圾回收之后不会进行内存整理以清除内存碎片。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;5.2.4 写屏障&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在并发标记的过程中，如果应用程序修改了对象图，就可能出现标记遗漏的可能，写屏障是为了处理标记遗漏的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;06&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;资源消耗对比&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在内存利用效率上， Go 语言确实比Java做得更好。&lt;/span&gt;&lt;span&gt;我们4个不同的角度来总结：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;6.1 Java 的 JIT 策略比 Golang 的 AOT 策略&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Java 在运行时相比 Golang 多占用了一些内存。&lt;strong&gt;原因在于：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Java 运行态中包含了一个完整的解释器、一个 JIT 编译期以及一个垃圾回收器，这会显著地增加内存。&lt;/span&gt;&lt;span&gt;Golang 语言直接编译到机器码，运行态只包含机器码和一个垃圾回收器。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此 Golang 的运行态相对消耗内存较少。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6685185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe97oficibBMsfVKIVnmAmjY3tf3RzxHn1dMaE199kAVs08d0icxJ3j7QEnw5YkIribzAQWQICX41Gehubw/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;6.2 内存分配和垃圾回收器&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Java 确实在起步占用上偏多，毕竟 jvm 需要更多内存做 jit ，默认的 gc 算法对内存要求偏高，但这不能代表后续占用仍然线性增长。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果目标是启动成百上千个内存需求较少的进程，那 Java 确实不擅长。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;6.3 并发&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;协程模型比线程模型更加节省内存。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;6.4 反射&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的反射更加简单，导致框架的内存消耗 Golang 程序比 Java 程序优秀。主要是因为：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的框架实现中大量使用反射，并使用 hashmap 缓存信息，这2个都是极度消耗内存的行为。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Golang 的框架中也使用 reflect、map 。但是 Golang 是面向 interface 和值类型的，这导致 Golang 的反射模型要比Java的反射模型简单非常多，反射过程要产生的对象数量也少非常多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;07&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;生态&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有人说，Java 在生态这方面简直是无敌的存在。这主要得益于 Spring 全家桶，Spring 让 Java 走上了神座。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Golang 语言知名的框架也很多，但是目前远远没有 Spring 影响那么大。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;08&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，上表为各位总结～&lt;/span&gt;&lt;/section&gt;&lt;table align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;语言&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;‍‍‍‍‍‍‍‍‍‍‍‍&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;selectTdClass&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Golang&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td class=&quot;selectTdClass&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;代码简洁性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;静态类型可编译成机器码直接运行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;天生多核并行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;垃圾收集&lt;/span&gt;&lt;br/&gt;&lt;span&gt;跨平台且不依赖运行时环境&lt;/span&gt;&lt;br/&gt;&lt;span&gt;简洁的泛型&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td class=&quot;selectTdClass&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;有限的库支持&lt;/span&gt;&lt;br/&gt;&lt;span&gt;泛型不够完善&lt;/span&gt;&lt;br/&gt;&lt;span&gt;灵活度没Java高(这个可算优点也可算缺点)&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;selectTdClass&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;java&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td class=&quot;selectTdClass&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;优秀的生态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;优秀的三方库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;多线程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;灵活性高&lt;/span&gt;&lt;br/&gt;&lt;span&gt;平台独立性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;完善的语言特性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码结构层次清晰&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td class=&quot;selectTdClass&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;大量冗余的陈旧实现导致性能不佳&lt;/span&gt;&lt;br/&gt;&lt;span&gt;生态的复杂性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复杂的继承机制&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;整体来说，二者各有优劣，各位自取所需。以上是本次分享全部内容，欢迎大家在评论区分享交流。如果觉得内容有用，欢迎转发～&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;-End-&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原创作者｜宋欣东&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术责编｜宋欣东&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39490445859872614&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96UtIwj5uyl21lveDXdiaSd0OFAs8gg2ricneDlSurpV3krrSaLvWtrYpqicCndkNIZOBkBlvVbQIqDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;JAVA 与 GO，孰是孰非？&lt;/span&gt;&lt;span&gt;欢迎评&lt;/span&gt;&lt;/span&gt;&lt;span&gt;论区留言分享你的观点。&lt;/span&gt;&lt;span&gt;我们将选取1则最有创意的分享，送出&lt;/span&gt;&lt;span&gt;腾讯云开发者-限定随行杯&lt;/span&gt;&lt;span&gt;1个（见下图）。5月12日中午12点开奖。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94AsoNbUS9q6jZC4NfBbGN1EcdicRU1ICicNg70kUXU3lBicuXUYwka0uuVkIItesmTwUUvDCPz0iaRLg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39490445859872614&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96erk7uzoeO1roLzic9vNeMH9JmIZiafkxDD6oIOU96UQVUjtTpbY0qScGFiaQibXWDJYvHZQfwYqtOmA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247611450&amp;amp;idx=1&amp;amp;sn=4128b807aa8b0a037d95615ddde81b4f&amp;amp;chksm=eaa92e6adddea77c587a2a26dbe8e4cd747867fe28500f96a260a8383280f4a24aa3ae792d3a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1638888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96UtIwj5uyl21lveDXdiaSd0nw9pGJlu82sufNuEbNXERpSufeR1ZbTzfBXvibFrMdGjNSZKH7l4arA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247607653&amp;amp;idx=1&amp;amp;sn=9c73e42de2c19ec37d52234cbfee9c5f&amp;amp;chksm=eaa93f35dddeb623206ad7f497a5be772efe6545fc3286aa95e47eb43d8e2260fc1d3b89a638&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1638888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96UtIwj5uyl21lveDXdiaSd07c6KfibDQmVwQ3j5lW8DyAC4KGhumAeTlAUQ3EWedia6m51fyM8RlsbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247607190&amp;amp;idx=1&amp;amp;sn=2e2a5419ada6b001e3030a3ca83d5631&amp;amp;chksm=eaa939c6dddeb0d0ff83aa0b17c9731d8a94d65570989a4c78f070c0ccd8c1ee6750f03cc1fb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1638888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96UtIwj5uyl21lveDXdiaSd0U4u6uoY8nViapfM1wAT9ymGaibFneOdhmWWv8BcpyBldHhR0uFBqjhQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;公众号后台回复「福利」，一键&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;领腾讯GO语言设计模式教程、GO整洁架构教程、GPT应用教程文集&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;⬇️⬇️⬇️&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI2NDU4OTExOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97ibOIthe2pvwt1H0HqX0HVJVFK9WPNQKNsibXynR5yT5S7b45uIpzN7xeZdeJIfOibPjOflZ35rKZyw/0?wx_fmt=png&quot; data-nickname=&quot;腾讯云开发者&quot; data-alias=&quot;QcloudCommunity&quot; data-signature=&quot;腾讯云官方社区公众号，汇聚技术开发者群体，分享技术干货，打造技术影响力交流社区。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3d0360e07e4c7e851885b95adf780761</guid>
<title>软件工程两大圣经之一《人件》译者序</title>
<link>https://toutiao.io/k/65rhcga</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content &amp;#10;                       autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzA4NTkwODkyMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBnic3nEAVlulnPbVU674VzeumiazficiaTHbibia7zeTTTMKkib4IHx3WX3CPHc7hL7E7Tk5K2nQSwibMZzQ/0?wx_fmt=png&quot; data-nickname=&quot;逸言&quot; data-alias=&quot;yishaosaid&quot; data-signature=&quot;开卷有逸 闭口不言&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section label=&quot;Copyright © 2014 playhudong All Rights Reserved.&quot; donone=&quot;shifuMouseDownOther(&#x27;shifu_o_028&#x27;)&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/7ibzJsmgW5wguO21SlkBAdxJgAicEOVCzDiaObyzEAEMTI527clib7gHvKfBtDu8MJZLwwEIVuVBmqfn01fmLDdTfQ/640?wx_fmt=gif&quot; data-w=&quot;22&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;◇ 类别：软件工程 | 项目管理&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;◇ 字数：3200字&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;◇ 阅读时长：9分钟&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4046296296296296&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakDb3kqQmc9ZSbDiagUda7QYg8OaDmERlwYLTLdMp3T5pXAaUJ8lhIXicTGy6KicpqkDoLFM3kKevicjEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;◇&lt;span&gt;◇&lt;span&gt;◇&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本书作者火力全开，对各种管理方法的悖论和谬论、理解与认识的偏差、囿于常识的错误、铺天盖地的方法论、自以为是的执行理论都展开了尖锐而犀利的批评。如此听来，是否觉得作者要与天下的软件项目管理者为敌呢？然而——没有！作者以让人开怀大笑的幽默笔触缓解了这种针对性，消除了剑拔弩张，变激烈对抗为和风细雨，在博得读者一笑的同时，引人深思。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一写法无疑增加了翻译的难度。如何才能将作者集幽默与儒雅的写作风格通过中文传神地呈现给读者呢？必然要求译文在保证“信”的同时，还要做到“达”，甚至对于部分译文，更需传递出“雅”的气质，何其难哉！毕竟，译者只是技术工作者，而非专业的文学翻译家。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以本书第三章《维也纳在等你》为例，为了将书中摘录的《陌生人》歌词翻译得更道地，译者参考了流传于网络的全篇歌词译文，又借鉴了本书第二版的翻译，通过反复通读这首歌的歌词，体察其歌词涵义是劝说人们放缓节奏，因为人生苦短，无论是否功成名就，最终都是黄土一抔，也就是歌中反复吟咏的“维也纳在等你”。而本书作者就是要告诫大家：案牍如山，工作永远做不完，要让工作节奏缓下来，从而佐证自己提倡不要加班的观点。终于得到现在的译文：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;但你知道老话说得在理儿，&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“要么得到你想要的，要么只是慢慢变老。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;于是你行色匆匆，人在半途却准备即刻启航。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;你要何时才会明白……维也纳在等你？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将truth翻译为“老话”，直接得自网络译文，因为它能更好体现歌者为下里巴人的口吻，要是翻译成“真理”，味道可就全变了。至于“You’re going to kick off before you even get halfway through”，则采用意译的方式，既希望准确传递人在半途的含义，又能适当透露出一丝咏叹的诗意。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.4043583535108959&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/d3Qa7X5fakDb3kqQmc9ZSbDiagUda7QYg7jokCHb8jYbgTAYkdODiaicJ3btWeWqH71cXhI2l7OiavoBKNVHKFverw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要做到翻译的“达”，则需要在翻译时从英文及时切换到中文思维，否则就会翻译出夹生饭一般的欧化中文。董桥在《文字是肉做的》一书中举了诸多英式中文的反面例子，在此遴选一例以说明翻译之难为。董桥说：“‘作为’是一个教人非常忧心的词语。罪魁祸首是英文里的‘as’。”他举例说：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们不会对一位漂亮的小姐说：“你作为一位大美人，实在不必花太多钱买化妆品了！”我们说：“你是个大美人，不用花太多钱买化妆品了！”用简洁的语言表达清楚的思路最重要。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;翻译本书时，凑巧也遇见了as。英文原文为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;As a new employee of an organization that is into Open-Space meetings, your experience of it might be something like this...&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最初译为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为一名新入职员工，你在组织里的开放空间会议上的体验大致是这样的……&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“作为”就像幽灵一般出现了。恰在此时，译者拜读到董桥老先生调侃“作为”的文章，恍然大悟，原来自己在翻译中已经深陷欧化中文的“陷阱”而不自知了。于是，暗自揣摩汉语的正确表达，居然苦思而不可得，不由叹息，身为中国人，竟然不知该如何正常地表达中文了。那就忘记英文的表述吧，尝试切换回中文的文本语境，忽然灵光一闪，获得正解：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你刚入职，公司举行了一次开放空间会议，而你的体验大致如此……&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“作为一名新入职员工”，不就是表达“你刚入职”的含义吗？显然，在翻译过程中，我们不能拘泥于英文表述中的每个字每个词，as当然是“作为”的含义，可是连贯起来，就未必要如此翻译了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之所以这般锱铢必较，大约还是想奉献更棒的译文给各位读者吧。原书如此经典，若因译文的失色而让读者体会不到本书的精彩，岂非译者的罪过？译者在阅读一些技术书籍的译本时，每每看到扭曲的中文表达时，就深以为憾，故而在本书翻译过程中力求做到更好，然而，能力有限，想必译文中仍有此类扭曲的中文，倘若读者有所发现，还请不吝赐教！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上翻译算是勉强做到了“达”，若要说雅，对我们这样的非专业翻译人士而言，未免苛求，不过，在翻译到书中对《建筑的永恒之道》引文时，苦心经营的这段译文可以说是刻意追求译文之雅的结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;历史上那些让人们宾至如归的建筑，村庄、寓所和寺庙都是由那些真正理解“道”之核心的人建造的。不遵循此道就不可能建造出宏伟的建筑、伟大的城镇或美丽的住所——让你产生归宿感，倍感活力的栖息之地。这种“道”会引导寻找它的人发现那些融合在树木山川之间，如我们面容一般熟悉的古老的建筑。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上是译者在翻译本书的一些浅薄体会，个中艰辛，不足与读者道矣。若再赘言，难免有买椟还珠之嫌，因为本书的价值，不在文笔，而在它特立独行的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;没错，就是&lt;span&gt;特立独行&lt;/span&gt;！虽说本书第一版出版于1987年，距今已有三十余年，也尝为业界称赞，将其与《人月神话》并列，誉为软件工程管理书籍的双璧；然而，不可否认，本书的影响力不如《人月神话》远也——至少在中国是如此。译者不敢妄自揣测个中缘由，单就翻译的感受来说，或许与本书内容的特立独行有关。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.4481481481481482&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/d3Qa7X5fakDb3kqQmc9ZSbDiagUda7QYgPAFwiajkQkJibVAwAQyxLkGwYOhY1OjbZhMPjicjibZELcyzibFsAryQU9w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本书虽然是软件工程管理领域的力作，却没有兜售任何一种管理方法，而是从社会学、心理学、建筑学中汲取营养，充满了柔情的人文关怀，不断地启发和突出软件项目管理中“人”的重要性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;书中蕴含了多少真知灼见啊！然而忠言逆耳，为成本计，为短期目标计，为当前的地位计，书中的种种合理建议或许都成了东风射马耳，老板们为了短期的成绩榨取更多的劳动力，如我们常常听闻的996，而员工呢，在困窘的供方弱势地位下，不得不委屈求全，哪里还敢奢求书中提及的诸多改变呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然则，本书作者并非一味站在劳方以寻求某种“政治正确”，更不是要激化普通员工与管理者之间的矛盾。作者以大量的项目实践、数据统计和顾问经验，事实胜于雄辩地证明了这些观点的合理性，呈现了这些建议能给行业带来的价值。不管是对付家具警察，抗击企业熵，挽回团队自毁，还是关注产品质量，废除帕金森定律，提高E因子，每条建议都切中肯綮，真正抓住了问题的命门，然则可惜，这些建议固然让软件从业者心有戚戚焉，然而传入管理者耳中，似又显得离经叛道，从而让他们嗤之以鼻，心里不以为然：“呔！怎么可能？让我为每个员工准备独立办公室，这得花多少租金？让我故意引入混乱来对付企业熵，允许员工展现自我，甚至可以不守公司的规范，这不瞎胡闹吗？让员工只专注于一件事，如此就可以保证工作的心流状态，那怎么行，产出不会太低吗？哦，还有快乐工作，你以为每家公司都是迪士尼？不加班，怎么能按时完成任务？别忘了，deadline可是像德摩克斯之剑悬在我头上呢。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但愿我描述的这些画面不会在现实中出现！作为译者，真的希望作者的这些建议不会被管理者粗暴的漠视。短期的销售收入与长期的战略目标，究竟谁更重要？在软件行业，因为对人才的尊重从而得到更高价值的产出，这样的例子不也比比皆是吗？或许我们真的应该反思，认真地计算投入产出比，并尝试种种变化，因为只有变化，才能激发无限的可能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注人的价值，这就是《人件》要表达的最高价值。Peopleware是作者创造的新词儿，当我们在夸夸其谈业务、技术、流程和工具时，千万别忘了，所有这些都是身为脑力工作者与知识工作者的“人”完成的！只有将软件项目管理回归到对“人”的重视与尊重，让管理者与员工成为协作者而非对抗的敌人，管理才会走向正轨，工作才会激发乐趣，从而形成一种内驱力和凝聚力，现在开始，黑衣团队真正要发挥无与伦比的威力了！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是为译者序！&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;张逸&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2023年1月6日于成都&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;特别感谢波士顿咨询Platinion董事总经理陈果（江湖人称果总）与《信用超导重塑社会经济——区块链创新理论与实践》副主编范乐文（区块链顶级专家）两位大咖拨冗为本书撰写推荐序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我在微信上认识两位老师，虽然至今缘铿一面，却为他们博学而专业的学识所折服，他们的推荐序令本书增色不少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;移&lt;/span&gt;&lt;span&gt;步至果总公众号&lt;/span&gt;，点击《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MzMzODE5MQ==&amp;amp;mid=2247493235&amp;amp;idx=1&amp;amp;sn=9144ca1be60299bf2c1f4a9a8e249039&amp;amp;chksm=ec710b53db0682450bf0b171f849c802ef45367d8226186fe8475263156fd922cfe1cc03b4f2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;人件-项目与团队的高效管理推荐序&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;人件-项目与团队的高效管理推荐序&lt;/a&gt;》，可&lt;span&gt;读到果&lt;/span&gt;&lt;span&gt;总的推荐&lt;/span&gt;&lt;span&gt;序。后续，&lt;/span&gt;我还会将范老师的推荐序发布到公众号上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本书在京东已可购买，购买链接为：https://item.jd.com/13926820.html&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5453703703703704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakDb3kqQmc9ZSbDiagUda7QYgTKhLZn8IZzpglkydC05W4mW8maUzs3JMkLxnsks0vlzANWv5ckVXEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>