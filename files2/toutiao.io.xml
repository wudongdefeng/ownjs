<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bab550ba5f7f41b2f0cad503e674d074</guid>
<title>什么是分包？怎么利用分包优化</title>
<link>https://toutiao.io/k/9gs42k0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、什么是分包&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，Webpack 会将所有代码构建成一个单独的包，这在小型项目通常不会有明显的性能问题，但伴随着项目的推进，包体积逐步增长可能会导致应用的响应耗时越来越长。归根结底这种将所有资源打包成一个文件的方式存在两个弊端：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「资源冗余」&lt;/strong&gt;：客户端必须等待整个应用的代码包都加载完毕才能启动运行，但可能用户当下访问的内容只需要使用其中一部分代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「缓存失效」&lt;/strong&gt;：将所有资源达成一个包后，所有改动 —— 即使只是修改了一个字符，客户端都需要重新下载整个代码包，缓存命中率极低&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些问题都可以通过对产物做适当的分解拆包解决，例如 &lt;code&gt;node_modules&lt;/code&gt; 中的资源通常变动较少，可以抽成一个独立的包，那么业务代码的频繁变动不会导致这部分第三方库资源被无意义地重复加载。为此，Webpack 专门提供了 &lt;code&gt;SplitChunksPlugin&lt;/code&gt; 插件，用于实现产物分包。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、使用 SplitChunksPlugin&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SplitChunksPlugin&lt;/code&gt; 是 Webpack 4 之后引入的分包方案(此前为 &lt;code&gt;CommonsChunkPlugin&lt;/code&gt;)，它能够基于一些启发式的规则将 Module 编排进不同的 Chunk 序列，并最终将应用代码分门别类打包出多份产物，从而实现分包功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用上，&lt;code&gt;SplitChunksPlugin&lt;/code&gt; 的配置规则比较抽象，算得上 Webpack 的一个难点，仔细拆解后关键逻辑在于：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SplitChunksPlugin&lt;/code&gt; 通过 module 被引用频率、chunk 大小、包请求数三个维度决定是否执行分包操作，这些决策都可以通过 &lt;code&gt;optimization.splitChunks&lt;/code&gt; 配置项调整定制，基于这些维度我们可以实现：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;单独打包某些特定路径的内容，例如 &lt;code&gt;node_modules&lt;/code&gt; 打包为 &lt;code&gt;vendors&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单独打包使用频率较高的文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SplitChunksPlugin&lt;/code&gt; 还提供配置组概念 &lt;code&gt;optimization.splitChunks.cacheGroup&lt;/code&gt;，用于为不同类型的资源设置更有针对性的配置信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SplitChunksPlugin&lt;/code&gt; 还内置了 &lt;code&gt;default&lt;/code&gt; 与 &lt;code&gt;defaultVendors&lt;/code&gt; 两个配置组，提供一些开箱即用的特性：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;node_modules&lt;/code&gt; 资源会命中 &lt;code&gt;defaultVendors&lt;/code&gt; 规则，并被单独打包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只有包体超过 20kb 的 Chunk 才会被单独打包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加载 Async Chunk 所需请求数不得超过 30&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加载 Initial Chunk 所需请求数不得超过 30&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;这里所说的请求数不能等价对标到 http 资源请求数，下文会细讲&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上，分包逻辑基本上都围绕着 Module 与 Chunk 展开，在介绍具体用法之前，有必要回顾一下 Chunk 的基础知识。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 什么是 Chunk&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;amp;mid=2247484029&amp;amp;idx=1&amp;amp;sn=7862737524e799c5eaf1605325171e32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;有点难的知识点：Webpack Chunk 分包规则详解&lt;/a&gt;》一文中，我们已经了解到 Chunk 是打包产物的基本组织单位，读者可以等价认为有多少 Chunk 就会对应生成多少产物(Bundle)。Webpack 内部包含三种类型的 Chunk：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Initial Chunk：基于 Entry 配置项生成的 Chunk&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Async Chunk：异步模块引用，如 &lt;code&gt;import(xxx)&lt;/code&gt; 语句对应的异步 Chunk&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Runtime Chunk：只包含运行时代码的 Chunk&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;关于运行时的概念，可参考《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;amp;mid=2247484088&amp;amp;idx=1&amp;amp;sn=41bf509a72f2cbcca1521747bf5e28f4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Webpack 原理系列六：彻底理解 Webpack 运行时&lt;/a&gt;》&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 &lt;code&gt;SplitChunksPlugin&lt;/code&gt; 默认只对 Async Chunk 生效，开发者也可以通过 &lt;code&gt;optimization.splitChunks.chunks&lt;/code&gt; 调整作用范围，该配置项支持如下值：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;字符串 &lt;code&gt;&#x27;all&#x27;&lt;/code&gt; ：对 Initial Chunk 与 Async Chunk 都生效，建议优先使用该值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字符串 &lt;code&gt;&#x27;initial&#x27;&lt;/code&gt; ：只对 Initial Chunk 生效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字符串 &lt;code&gt;&#x27;async&#x27;&lt;/code&gt; ：只对 Async Chunk 生效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数 &lt;code&gt;(chunk) =&amp;gt; boolean&lt;/code&gt; ：该函数返回 &lt;code&gt;true&lt;/code&gt; 时生效&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;optimization&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;splitChunks&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;chunks&lt;/span&gt;: &lt;span&gt;&#x27;all&#x27;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 分包策略详解&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;2.2.1 根据 Module 使用频率分包&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SplitChunksPlugin&lt;/code&gt; 支持按 Module 被 Chunk 引用的次数决定是否进行分包，开发者可通过 &lt;code&gt;optimization.splitChunks.minChunks&lt;/code&gt; 设定最小引用次数，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;optimization&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;splitChunks&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;// 设定引用次数超过 4 的模块才进行分包&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;minChunks&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意，这里“被 Chunk 引用次数”并不直接等价于被 &lt;code&gt;import&lt;/code&gt; 的次数，而是取决于上游调用者是否被视作 Initial Chunk 或 Async Chunk 处理，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// common.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&quot;common chunk&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// async-module.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; common &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./common&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// entry-a.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; common &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./common&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt;(&lt;span&gt;&#x27;./async-module&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// entry-b.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; common &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./common&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// webpack.config.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;entry&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;entry1&lt;/span&gt;: &lt;span&gt;&#x27;./src/entry-a.js&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;entry2&lt;/span&gt;: &lt;span&gt;&#x27;./src/entry-b.js&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;optimization&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;splitChunks&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;minChunks&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上例包含四个模块，形成如下模块关系图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6496350364963503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eicibllNWYkn0jqh4vRxWtl9tQRDFw5UDyUqL9UZyUQMTtkKsxSJvm0zHP3oWyufU7QQrvP2BE5x7HyvXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例中，&lt;code&gt;entry-a&lt;/code&gt;、&lt;code&gt;entry-b&lt;/code&gt; 分别被视作 Initial Chunk 处理；&lt;code&gt;async-module&lt;/code&gt; 被 &lt;code&gt;entry-a&lt;/code&gt; 以异步方式引入，因此被视作 Async Chunk 处理。那么对于 &lt;code&gt;common&lt;/code&gt; 模块来说，分别被三个不同的 Chunk 引入，此时引用次数为 3，命中 &lt;code&gt;optimization.splitChunks.minChunks = 2&lt;/code&gt; 规则，因此该模块&lt;strong&gt;「可能」&lt;/strong&gt;会被单独分包，最终产物：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;entry-a.js&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;entry-b.js&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;async-module.js&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;commont.js&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;2.2.2 限制分包数量&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在满足 &lt;code&gt;minChunks&lt;/code&gt; 基础上，还可以通过 &lt;code&gt;maxInitialRequest/maxAsyncRequests&lt;/code&gt; 配置项限定分包数量，配置项语义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maxInitialRequest&lt;/code&gt;：用于设置 Initial Chunk 最大并行请求数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maxAsyncRequests&lt;/code&gt;：用于设置 Async Chunk 最大并行请求数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里所说的“请求数”，是指加载一个 Chunk 时所需同步加载的分包数。例如对于一个 Chunk A，如果根据分包规则(如模块引用次数、第三方包)分离出了若干子 Chunk A¡，那么请求 A 时，浏览器需要同时请求所有的 A¡，此时并行请求数等于 ¡ 个分包加 A 主包，即 ¡+1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，对于上例所说的模块关系：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6496350364963503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eicibllNWYkn0jqh4vRxWtl9tQRDgYXl8ibiaEeO4N2CW40DbKRFFaOkmEwzNv1CCgakYPO6O6Cwm9TgbbqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若 &lt;code&gt;minChunks = 2&lt;/code&gt; ，则 &lt;code&gt;common&lt;/code&gt; 模块命中 &lt;code&gt;minChunks&lt;/code&gt; 规则被独立分包，浏览器请求 &lt;code&gt;entry-a&lt;/code&gt; 时，则需要同时请求 &lt;code&gt;common&lt;/code&gt; 包，并行请求数为 1 + 1=2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于下述模块关系：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3672627235213205&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eicibllNWYkn0jqh4vRxWtl9tQRDZPR7nkf2kzkZtkmMgkpnA5hAaJUGCHOMoCaarjDB6hTDYhkAXQmlUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1454&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若 &lt;code&gt;minChunks = 2&lt;/code&gt; ，则 &lt;code&gt;common-1&lt;/code&gt; 、&lt;code&gt;common-2&lt;/code&gt; 同时命中 &lt;code&gt;minChunks&lt;/code&gt; 规则被分别打包，浏览器请求 &lt;code&gt;entry-b&lt;/code&gt; 时需要同时请求 &lt;code&gt;common-1&lt;/code&gt; 、&lt;code&gt;common-2&lt;/code&gt; 两个分包，并行数为 2 + 1 = 3，此时若 &lt;code&gt;maxInitialRequest = 2&lt;/code&gt;，则分包数超过阈值，&lt;code&gt;SplitChunksPlugin&lt;/code&gt; 会放弃 &lt;code&gt;common-1&lt;/code&gt; 、&lt;code&gt;common-2&lt;/code&gt; 中体积较小的分包。&lt;code&gt;maxAsyncRequest&lt;/code&gt; 逻辑与此类似，不在赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并行请求数关键逻辑总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Initial Chunk 本身算一个请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Async Chunk 不算并行请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;runtimeChunk&lt;/code&gt; 拆分出的 runtime 不算并行请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果同时有两个 Chunk 满足拆分规则，但是 &lt;code&gt;maxInitialRequests&lt;/code&gt;(或 &lt;code&gt;maxAsyncRequest&lt;/code&gt;) 的值只能允许再拆分一个模块，那么体积更大的模块会被优先拆解&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;2.2.3 限制分包体积&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在满足 &lt;code&gt;minChunks&lt;/code&gt; 与 &lt;code&gt;maxInitialRequests&lt;/code&gt; 的基础上，&lt;code&gt;SplitChunksPlugin&lt;/code&gt; 还会进一步判断 Chunk 包大小决定是否分包，这一规则相关的配置项非常多：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;minSize&lt;/code&gt;：超过这个尺寸的 Chunk 才会正式被分包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maxSize&lt;/code&gt;：超过这个尺寸的 Chunk 会尝试继续做分包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maxAsyncSize&lt;/code&gt;：与 &lt;code&gt;maxSize&lt;/code&gt; 功能类似，但只对异步引入的模块生效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maxInitialSize&lt;/code&gt;：与 &lt;code&gt;maxSize&lt;/code&gt; 类似，但只对 &lt;code&gt;entry&lt;/code&gt; 配置的入口模块生效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;enforceSizeThreshold&lt;/code&gt;：超过这个尺寸的 Chunk 会被强制分包，忽略上述其它 size 限制&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，结合前面介绍的两种规则，&lt;code&gt;SplitChunksPlugin&lt;/code&gt; 的主体流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SplitChunksPlugin&lt;/code&gt; 尝试将命中 &lt;code&gt;minChunks&lt;/code&gt; 规则的 Module 统一抽到一个额外的 Chunk 对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断该 Chunk 是否满足 &lt;code&gt;maxInitialRequests&lt;/code&gt; 阈值，若满足则进行下一步&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断该 Chunk 资源的体积是否大于上述配置项 &lt;code&gt;minSize&lt;/code&gt; 声明的下限阈值；&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果体积&lt;strong&gt;「小于」&lt;/strong&gt; &lt;code&gt;minSize&lt;/code&gt; 则取消这次分包，对应的 Module 依然会被合并入原来的 Chunk&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 Chunk 体积&lt;strong&gt;「大于」&lt;/strong&gt; &lt;code&gt;minSize&lt;/code&gt; 则判断是否超过 &lt;code&gt;maxSize&lt;/code&gt;、&lt;code&gt;maxAsyncSize&lt;/code&gt;、&lt;code&gt;maxInitialSize&lt;/code&gt; 声明的上限阈值，如果超过则尝试将该 Chunk 继续分割成更小的部分&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;虽然 &lt;code&gt;maxSize&lt;/code&gt; 等上限阈值逻辑会产生更多的包体，但缓存粒度会更小，命中率相对也会更高，配合持久缓存与 HTTP 2 的多路复用能力，网络性能反而会有正向收益。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上述模块关系为例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6496350364963503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eicibllNWYkn0jqh4vRxWtl9tQRDFw5UDyUqL9UZyUQMTtkKsxSJvm0zHP3oWyufU7QQrvP2BE5x7HyvXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若此时 Webpack 配置的 &lt;code&gt;minChunks&lt;/code&gt; 大于 2，且 &lt;code&gt;maxInitialRequests&lt;/code&gt; 也同样大于 2，如果 &lt;code&gt;common&lt;/code&gt; 模块的体积大于上述说明的 &lt;code&gt;minxSize&lt;/code&gt; 配置项则分包成功，&lt;code&gt;commont&lt;/code&gt; 会被分离为单独的 Chunk，否则会被合并入原来的 3 个 Chunk。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;注意，这些属性的优先级顺序为：&lt;/p&gt;&lt;p&gt;&lt;code&gt;maxInitialRequest/maxAsyncRequests &amp;lt; maxSize &amp;lt; minSize&lt;/code&gt;&lt;/p&gt;&lt;p&gt;而命中 &lt;code&gt;enforceSizeThreshold&lt;/code&gt; 阈值的 Chunk 会直接跳过这些属性判断，强制进行分包。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 使用&lt;code&gt;cacheGroups&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;2.3.1 理解缓存组&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除上述 &lt;code&gt;minChunks&lt;/code&gt;、&lt;code&gt;maxInitialRequest&lt;/code&gt;、&lt;code&gt;minSize&lt;/code&gt; 等基础规则外，&lt;code&gt;SplitChunksPlugin&lt;/code&gt; 还提供了 &lt;code&gt;cacheGroups&lt;/code&gt; 配置项用于为不同文件组设置不同的规则，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;optimization&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;splitChunks&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;cacheGroups&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;vendors&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/[\\/]node_modules[\\/]/&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;minChunks&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;minSize&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例通过 &lt;code&gt;cacheGroups&lt;/code&gt; 属性设置 &lt;code&gt;vendors&lt;/code&gt; 缓存组，所有命中 &lt;code&gt;vendors.test&lt;/code&gt; 规则的模块都会被视作 &lt;code&gt;vendors&lt;/code&gt; 分组，优先应用该组下的 &lt;code&gt;minChunks&lt;/code&gt;、&lt;code&gt;minSize&lt;/code&gt; 等分包配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 &lt;code&gt;minChunks&lt;/code&gt; 等分包基础配置项之外，&lt;code&gt;cacheGroups&lt;/code&gt; 还支持一些与分组逻辑强相关的属性，包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;test&lt;/code&gt;：接受正则表达式、函数及字符串，所有符合 &lt;code&gt;test&lt;/code&gt; 判断的 Module 或 Chunk 都会被分到该组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;type&lt;/code&gt;：接受正则表达式、函数及字符串，与 &lt;code&gt;test&lt;/code&gt; 类似均用于筛选分组命中的模块，区别是它判断的依据是文件类型而不是文件名，例如 &lt;code&gt;type = &#x27;json&#x27;&lt;/code&gt; 会命中所有 JSON 文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;idHint&lt;/code&gt;：字符串型，用于设置 Chunk ID，它还会被追加到最终产物文件名中，例如 &lt;code&gt;idHint = &#x27;vendors&#x27;&lt;/code&gt; 时，输出产物文件名形如 &lt;code&gt;vendors-xxx-xxx.js&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;priority&lt;/code&gt;：数字型，用于设置该分组的优先级，若模块命中多个缓存组，则优先被分到 &lt;code&gt;priority&lt;/code&gt; 更大的组&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存组的作用在于能为不同类型的资源设置更具适用性的分包规则，一个典型场景是将所有 &lt;code&gt;node_modules&lt;/code&gt; 下的模块统一打包到 &lt;code&gt;vendors&lt;/code&gt; 产物，从而实现第三方库与业务代码的分离。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;2.3.2 默认分组&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Webpack 提供了两个开箱即用的 &lt;code&gt;cacheGroups&lt;/code&gt;，分别命名为 &lt;code&gt;default&lt;/code&gt; 与 &lt;code&gt;defaultVendors&lt;/code&gt;，默认配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;optimization&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;splitChunks&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;cacheGroups&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;idHint&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;reuseExistingChunk&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;minChunks&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;priority&lt;/span&gt;: &lt;span&gt;-20&lt;/span&gt;&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;defaultVendors&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;idHint&lt;/span&gt;: &lt;span&gt;&quot;vendors&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;reuseExistingChunk&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/[\\/]node_modules[\\/]/i&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;priority&lt;/span&gt;: &lt;span&gt;-10&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个配置组能帮助我们：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;将所有 &lt;code&gt;node_modules&lt;/code&gt; 中的资源单独打包到 &lt;code&gt;vendors-xxx-xx.js&lt;/code&gt; 命名的产物&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对引用次数大于等于 2 的模块，也就是被多个 Chunk 引用的模块，单独打包&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发者也可以将默认分组设置为 false，关闭分组配置，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;optimization&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;splitChunks&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;cacheGroups&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 配置项回顾&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们再回顾一下 &lt;code&gt;SplitChunksPlugin&lt;/code&gt; 支持的配置项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;minChunks&lt;/code&gt;：用于设置引用阈值，被引用次数超过该阈值的 Module 才会进行分包处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maxInitialRequest/maxAsyncRequests&lt;/code&gt;：用于限制 Initial Chunk(或 Async Chunk) 最大并行请求数，本质上是在限制最终产生的分包数量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;minSize&lt;/code&gt;：超过这个尺寸的 Chunk 才会正式被分包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maxSize&lt;/code&gt;：超过这个尺寸的 Chunk 会尝试继续做分包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maxAsyncSize&lt;/code&gt;：与 &lt;code&gt;maxSize&lt;/code&gt; 功能类似，但只对异步引入的模块生效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maxInitialSize&lt;/code&gt;：与 &lt;code&gt;maxSize&lt;/code&gt; 类似，但只对 &lt;code&gt;entry&lt;/code&gt; 配置的入口模块生效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;enforceSizeThreshold&lt;/code&gt;：超过这个尺寸的 Chunk 会被强制分包，忽略上述其它 size 限制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cacheGroups&lt;/code&gt;：用于设置缓存组规则，为不同类型的资源设置更有针对性的分包策略&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、拆分运行时包&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;amp;mid=2247484088&amp;amp;idx=1&amp;amp;sn=41bf509a72f2cbcca1521747bf5e28f4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Webpack 原理系列六：彻底理解 Webpack 运行时&lt;/a&gt;》一文中，已经比较深入介绍 Webpack 运行时的概念、组成、作用与生成机制，大致上我们可以将运行时理解为一种补齐模块化、异步加载等能力的应用骨架，用于支撑 Webpack 产物在各种环境下的正常运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行时代码的内容由业务代码所使用到的特性决定，例如当 Webpack 检测到业务代码中使用了异步加载能力，就会将异步加载相关的运行时注入到产物中，因此业务代码用到的特性越多，运行时就会越大，有时甚至可以超过 1M 之多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，可以将 &lt;code&gt;optimization.runtimeChunk&lt;/code&gt; 设置为 true，以此将运行时代码拆分到一个独立的 Chunk，实现分包。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、最佳实践&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何设置最适合项目情况的分包规则呢？这个问题并没有放诸四海皆准的通用答案，因为软件系统与现实世界的复杂性，决定了很多计算机问题并没有银弹，不过我个人还是总结了几条可供参考的最佳实践：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「尽量将第三方库拆为独立分包」&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如在一个 React + Redux 项目中，可想而知应用中的大多数页面都会依赖于这两个库，那么就应该将它们从具体页面剥离，避免重复加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但对于使用频率并不高的第三方库，就需要按实际情况灵活判断，例如项目中只有某个页面 A 接入了 Three.js，如果将这个库跟其它依赖打包在一起，那用户在访问其它页面的时候都需要加载 Three.js，最终效果可能反而得不偿失，这个时候可以尝试使用异步加载功能将 Three.js 独立分包&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「保持按路由分包，减少首屏资源负载」&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设想一个超过 10 个页面的应用，假如将这些页面代码全部打包在一起，那么用户访问其中任意一个页面都需要等待其余 9 个页面的代码全部加载完毕后才能开始运行应用，这对 TTI 等性能指标明显是不友好的，所以应该尽量保持按路由维度做异步模块加载，所幸很多知名框架如 React、Vue 对此都有很成熟的技术支持&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「尽量保持」&lt;/strong&gt; &lt;code&gt;**chunks = &#x27;all&#x27;**&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;optimization.splitChunks.chunks&lt;/code&gt; 配置项用于设置 &lt;code&gt;SplitChunksPlugin&lt;/code&gt; 的工作范围，我们应该尽量保持 &lt;code&gt;chunks = &#x27;all&#x27;&lt;/code&gt; 从而最大程度优化分包逻辑&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0b5875e88c196d4fcbbd3a5b9ed1e4e4</guid>
<title>日志中台不重不丢实现浅谈</title>
<link>https://toutiao.io/k/cnc323n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

          

          
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c1d0e95a8dab3ac0a8f44a7138bff9fd</guid>
<title>迈向可验证的 AI: 形式化方法的五大挑战</title>
<link>https://toutiao.io/k/69dbklz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;307&quot; data-backw=&quot;546&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.562962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cNFA8C0uVPvcqbcictialp8AorQz8ickOsgZZj1QdV9Z49F3GibP9XJw1akUB4ZIm3bp508eZbAxYia6Xem1KMUWMOA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;作者 | Sanjit A. Seshia, Dorsa Sadigh, S. Shankar Sastry&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编译 | 李梅、黄楠&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编辑 | 陈彩娴&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;人工智能试图模仿人类智能的计算系统，包括人类一些与智能具有直观联系的功能，例如学习、解决问题以及理性地思考和行动。在广义地解释上，AI 一词涵盖了许多密切相关的领域如机器学习。那些大量使用 AI 的系统在医疗保健、交通运输、金融、社交网络、电子商务和教育等领域都产生了重大的社会影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种日益增长的社会影响，也带来了一系列风险和担忧，包括人工智能软件中的错误、网络攻击和人工智能系统安全等方面。因此，AI 系统的验证问题以及更广泛的可信 AI 的话题已经开始引起研究界的关注。“可验证 AI”已经被确立为设计 AI 系统的目标，一个可验证的 AI 系统在特定的数学要求上具有强大的、理想情况下可证明的正确性保证。我们怎样才能实现这个目标？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近，《ACM 通讯》（The Communications of ACM）上的一篇综述文章，试图从形式验证的角度来思考可证验 AI 面临的挑战，并给出了一些原则性的解决方案。文章作者是加州伯克利分校电气工程与计算机科学系的主任 S. Shankar Sastry 和 Sanjit A. Seshia 教授，以及斯坦福大学计算机科学系助理教授 Dorsa Sadigh。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在计算机科学和工程领域，形式方法涉及系统的严格的数学规范、设计和验证。其核心在于，形式方法是关于证明的：制定形成证明义务的规范，设计系统以履行这些义务，并通过算法证明搜索来验证系统确实符合其规范。从规范驱动的测试和仿真到模型检查和定理证明，一系列的形式化方法常被用于集成电路的计算机辅助设计，并已广泛被用于发现软件中的错误，分析网络物理系统，并发现安全漏洞。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文回顾了形式化方法传统的应用方式，指明了形式化方法在 AI 系统中的五个独特挑战，包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在讨论最新进展的基础上，作者提出了解决以上挑战的原则。本文不仅仅关注特定类型的 AI 组件如深度神经网络，或特定的方法如强化学习，而是试图涵盖更广泛的 AI 系统及其设计过程。此外，形式化方法只是通往可信 AI 的其中一种途径，所以本文的观点旨在对来自其他领域的方法加以补充。这些观点很大程度上来源于对自主和半自主系统中使用 AI 所产生的问题的思考，在这些系统中，安全性和验证性问题更加突出。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-none-contnet=&quot;t&quot;&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;概述&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;图 1 显示了形式验证、形式综合和形式指导的运行时弹性的典型过程。形式验证过程从三个输入开始：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;339&quot; data-backw=&quot;546&quot; data-height=&quot;635&quot; data-ratio=&quot;0.6213307240704501&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cNFA8C0uVPtlBIickYq1Xc0dczjMjAd28kUEoibunbB8jqibnUaThG7E2nHWfPHJ2DuzclxmicYkpe4iamLtCicZVQGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1022&quot; data-width=&quot;1022&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图 1 ：用于验证、综合和运行时弹性的形式化方法&lt;/span&gt;&lt;/section&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;要验证的系统模型 S&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;环境模型 E&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;待验证的属性 Φ&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-1&quot;/&gt;&lt;p&gt;&lt;span&gt;验证者生成“是”或“否”的答案作为输出，来表明 S 是否满足环境 E 中的属性 Φ。通常，“否”输出伴随着反例，也称为错误跟踪（error trace），它是对系统的执行，表明 Φ 是如何被伪造的。一些验证工具还包括带有“是”答案的正确性证明或证书。我们对形式方法采取一种广泛的视角，包括使用形式规范、验证或综合的某些方面的任何技术。例如，我们囊括了基于仿真的硬件验证方法或基于模型的软件测试方法，因为它们也使用正式的规范或模型来指导仿真或测试的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要将形式验证应用于 AI 系统，必须能够以形式来表示至少 S、E 和 Φ 这三个输入，理想情况下，会存在有效的决策程序来回答先前所描述的“是/否”问题。然而，即使要对三个输入构建良好的表示，也并不是一件简单的事，更不用说处理底层设计和验证问题的复杂性了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们这里通过半自动驾驶领域的示例来说明本文的观点。图 2 显示了一个 AI 系统的说明性示例：一个闭环 CPS，包括一辆带有机器学习组件的半自动车辆及其环境。具体来说，假设半自动的“自我”（ego）车辆有一个自动紧急制动系统 (AEBS)，该系统试图对前方的物体进行检测和分类，并在需要避免碰撞时启动制动器。图 2 中，一个 AEBS 包括一个由控制器（自动制动）、一个受控对象（受控的车辆子系统，包括自主堆栈的其他部分）和一个传感器（摄像头），以及一个使用 DNN 的感知组件。AEBS 与车辆环境相结合，形成一个闭环 CPS。“自我”车辆的环境包括车辆外部（其他车辆、行人等）以及车辆内部（例如驾驶员）的代理和对象。这种闭环系统的安全要求可以非形式地刻画为以一种属性，即在移动的“自我”车辆与道路上的任何其他代理或物体之间保持安全距离。然而，这种系统在规范、建模和验证方面存在许多细微差别。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;227&quot; data-backw=&quot;546&quot; data-height=&quot;424&quot; data-ratio=&quot;0.41487279843444225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cNFA8C0uVPtlBIickYq1Xc0dczjMjAd284bML1ibjefiaiaCr73lFt5XKHPp8iciaCSqhEvwibrfCMCk5IeHfzWt2cRSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1022&quot; data-width=&quot;1022&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;图 2：包含机器学习组件的闭环 CPS 示例&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一，考虑对半自动车辆的环境进行建模。即使是环境中有多少和哪些代理（包括人类和非人类）这样的问题，也可能存在相当大的不确定性，更不用说它们的属性和行为了。第二，使用 AI 或 ML 的感知任务即使不是不可能，也很难形式化地加以规定。第三，诸如 DNN 之类的组件可能是在复杂、高维输入空间上运行的复杂、高维对象。因此，在生成形式验证过程的三个输入 S、E、Φ 时，即便采用一种能够使验证易于处理的形式，也十分具有挑战性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果有人解决了这个问题，那就会面临一项艰巨的任务，即验证一个如图 2 那样复杂的基于 AI 的 CPS。在这样的 CPS 中，组合（模块化）方法对于可扩展性来说至关重要，但它会由于组合规范的难度之类的因素而难以实施。最后，建构中修正的方法（correct-by-construction,CBC）有望实现可验证 AI，但它还处于起步阶段，非常依赖于规范和验证方面的进步。图 3 总结了可验证 AI 的五个挑战性领域。对于每个领域，我们将目前有前景的方法提炼成克服挑战的三个原则，用节点表示。节点之间的边缘显示了可验证 AI 的哪些原则相互依赖，共同的依赖线程由单一颜色表示。下文将详细阐述这些挑战和相应的原则。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;302&quot; data-backw=&quot;546&quot; data-height=&quot;564&quot; data-ratio=&quot;0.5523996082272282&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cNFA8C0uVPtlBIickYq1Xc0dczjMjAd28ApJoX7Xciaiax41qYfmzn76cvp0d2Osj5oRUPo9BiafV4w2N3SNiaCsibBw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1021&quot; data-width=&quot;1021&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;图 3：可验证 AI 的 5 个挑战领域总结&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-none-contnet=&quot;t&quot;&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;环境建模&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;基于 AI/ML 的系统所运行的环境通常很复杂， 比如对自动驾驶汽车运行的各种城市交通环境的建模。事实上，AI/ML 经常被引入这些系统中以应对环境的复杂性和不确定性。当前的 ML 设计流程通常使用数据来隐性地规定环境。许多 AI 系统的目标是在其运行过程中发现并理解其环境，这与为先验指定的环境设计的传统系统不同。然而，所有形式验证和综合都与一个环境模型有关。因此，必须将有关输入数据的假设和属性解释到环境模型中。我们将这种二分法提炼为 AI 系统环境建模的三个挑战，并制定相应的原则来解决这些挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 建模不确定性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在形式验证的传统用法中，一种司空见惯的做法是将环境建模为受约束的非确定性过程，或者“干扰”。这种“过度近似”的环境建模能够允许人们更为保守地捕捉环境的不确定性，而无需过于详细的模型，这种模型的推理是很不高效的。然而，对于基于 AI 的自主性，纯粹的非确定性建模可能会产生太多虚假的错误报告，从而使验证过程在实践中变得毫无用处。例如在对一辆自动驾驶汽车的周围车辆行为的建模中，周围车辆的行为多种多样，如果采用纯粹的非确定性建模，就考虑不到总是意外发生的事故。此外，许多 AI/ML 系统隐式或显式地对来自环境的数据或行为做出分布假设，从而需要进行概率建模。由于很难准确地确定潜在的分布，所以不能假定生成的概率模型是完美的，并且必须在模型本身中对建模过程中的不确定性加以表征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;概率形式建模。&lt;/strong&gt;为了应对这一挑战，我们建议使用结合概率建模和非确定性建模的形式。在能够可靠地指定或估计概率分布的情况下，可以使用概率建模。在其他情况下，非确定性建模可用于对环境行为进行过度近似。虽然诸如马尔可夫决策过程之类的形式主义已经提供了一种混合概率和非确定性的方法，但我们相信，更丰富的形式主义如概率规划范式，可以提供一种更具表达力和程序化的方式来对环境进行建模。我们预测，在许多情况下，此类概率程序需要（部分地）从数据中进行学习或合成。此时，学习参数中的任何不确定性都必须传播到系统的其余部分，并在概率模型中加以表示。例如，凸马尔可夫决策过程提供了一种方法来表示学习转变概率值的不确定性，并扩展了用于验证和控制的算法来解释这种不确定性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 未知的变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在传统的形式验证领域如验证设备驱动程序中，系统 S 与其环境 E 之间的接口定义良好，E 只能通过该接口与 S 进行交互。对于基于 AI 的自主性而言，该接口是不完善的，它由传感器和感知组件规定，这些组件只能部分且嘈杂地捕捉环境，而且无法捕捕捉 S 和 E 之间的所有交互。所有环境的变量（特征）都是已知的，更不用说被感知到的变量。即使在环境变量已知的受限场景中，也明显缺乏有关其演变的信息，尤其是在设计的时候。此外，代表环境接口的激光雷达等传感器建模也是一项重大的技术挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;内省环境建模&lt;/strong&gt;。我们建议通过开发内省的设计和验证方法来解决这个问题，也就是说，在系统 S 中进行内省，来对关于环境 E 的假设 A 进行算法上的识别，该假设足以保证满足规范 Φ。理想情况下，A 必须是此类假设中最弱的一个，并且还必须足够高效，以便在设计时生成、并在运行时监控可用传感器和有关环境的其他信息源，以及方便在假设被违反时可以采取缓解措施。此外，如果涉及人类操作员，人们可能希望 A 可以翻译成可理解的解释，也就是说 S 可以向人类“解释”为什么它可能无法满足规范 Φ。处理这些多重要求以及对良好传感器模型的需求，使得内省环境建模成为一个非常重要的问题。初步的工作表明，这种可监控假设的提取在简单的情况下是可行的，虽然需要做更多的工作才能让它具有实用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3 模拟人类行为&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于许多 AI 系统，例如半自动驾驶汽车，人类代理是环境和系统的关键部分。关于人类的人工模型无法充分捕捉人类行为的可变性和不确定性。另一方面，用于建模人类行为的数据驱动方法可能对 ML 模型使用的特征的表达能力和数据质量敏感。为了实现人类 AI 系统的高度保证，我们必须解决当前人类建模技术的局限性，并为其预测准确性和收敛性提供保障。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;主动的数据驱动建模。&lt;/strong&gt;我们相信，人类建模需要一种主动的数据驱动方法，模型结构和以数学形式表示的特征适合使用形式方法。人类建模的一个关键部分是捕捉人类意图。我们提出了一个三管齐下的方法：基于专家知识来定义模型的模板或特征，用离线学习来完成模型以供设计时使用，以及在运行时通过监控和与环境交互来学习和更新环境模型。例如，已经有研究表明，通过人类受试者实验从驾驶模拟器收集的数据，可用于生成人类驾驶员的行为模型，这些模型可用于验证和控制自动驾驶汽车。此外，计算机安全领域的对抗性训练和攻击技术可用于人类模型的主动学习，并可针对导致不安全行为的特定人类动作来进一步设计模型。这些技术可以帮助开发 human-AI 系统的验证算法。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-none-contnet=&quot;t&quot;&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;形式化规范&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;形式化验证严重依赖于形式化规范——即对系统应该做什么的精确的数学陈述。即使在形式化方法已经取得相当大成功的领域，提出高质量的形式化规范也是一项挑战，而 AI 系统尤其面临着独特的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 难以形式化的任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 2 中 AEBS 控制器中的感知模块必须检测和分类对象，从而将车辆和行人与其他实体区分开来。在经典的形式方法意义上，这个模块的准确性要求对每种类型的道路使用者和对象进行形式定义，这是极其困难的。这种问题存在于这个感知模块的所有实现中，而不仅仅出现在基于深度学习的方法中。其他涉及感知和交流的任务也会出现类似的问题，比如自然语言处理。那么，我们如何为这样的模块指定精度属性呢？规范语言应该是什么？我们可以使用哪些工具来构建规范？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;端到端/系统水平的规范（End-to-end/system-level specifications）&lt;/strong&gt;。为了应对上述挑战，我们可以对这个问题稍加变通。与其直接对难以形式化的任务进行规范，不如首先专注于精确地指定 AI 系统的端到端行为。从这种系统水平的规范中，可以获得对难以形式化的组件的输入-输出接口的约束。这些约束用作一个组件水平（component-level ）的规范，这个规范与整个 AI 系统的上下文相关。对于图 2 中的 AEBS 示例，这涉及对属性 Φ 的规定，该属性即在运动过程中与任何对象都保持最小距离，从中我们可得出对 DNN 输入空间的约束，在对抗分析中捕捉语义上有意义的输入空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 定量规范 vs. 布尔规范&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统上，形式规范往往是布尔型的，它将给定的系统行为映射为“真”或“假”。然而，在 AI 和 ML 中，规范通常作为规范成本或奖励的目标函数给出。此外，可能有多个目标，其中一些必须一起满足，而另一些则可能需要在某些环境中相互权衡。统一布尔和定量两种规范方法的最佳方式是什么？是否有能够统一捕捉 AI 组件常见属性（如鲁棒性和公平性）的形式？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;混合定量和布尔规范。&lt;/strong&gt;布尔规范和定量规范都有其优点：布尔规范更容易组合，但目标函数有助于用基于优化的技术进行验证和综合，并定义更精细的属性满足粒度。弥补这一差距的一种方法是转向定量规范语言，例如使用具有布尔和定量语义的逻辑（如度量时序逻辑），或将自动机与 RL 的奖励函数相结合。另一种方法是将布尔和定量规范组合成一个通用的规范结构，例如一本规则手册 ，手册中的规范可以按层次结构进行组织、比较和汇总。有研究已经确定了 AI 系统的几类属性，包括鲁棒性、公平性、隐私性、问责性和透明度。研究者正在提出新的形式主义，将形式方法和 ML 的思想联系起来，以对这些属性的变体（如语义鲁棒性）进行建模。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 数据 vs. 形式要求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“数据即规范”的观点在机器学习中很常见。有限输入集上标记的“真实”数据通常是关于正确行为的唯一规范。这与形式化方法非常不同，形式化方法通常以逻辑或自动机的形式给出，它定义了遍历所有可能输入的正确行为的集合。数据和规范之间的差距值得注意，尤其是当数据有限、有偏见或来自非专家时。我们需要技术来对数据的属性进行形式化，包括在设计时可用的数据和尚未遇到的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;规范挖掘(Specification mining)。&lt;/strong&gt; 为了弥合数据和形式规范之间的差距，我们建议使用算法从数据和其他观察中来推断规范——即所谓的规范挖掘技术。此类方法通常可用于 ML 组件，包括感知组件，因为在许多情况下，它不需要具有精确的规范或人类可读的规范。我们还可以使用规范挖掘方法，从演示或更复杂的多个代理（人类和人工智能）之间的交互形式来推断人类意图和其他属性。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-none-contnet=&quot;t&quot;&gt;4&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;学习系统的建模&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在形式验证的大多数传统应用中，系统 S 在设计时是固定的且已知的，比如它可以是一个程序，或者一个用编程语言或硬件描述语言来描述的电路。系统建模问题主要涉及的，是通过抽象掉不相关的细节，来将 S 减小到更易于处理的大小。AI 系统给系统建模带来了非常不同的挑战，这主要源于机器学习的使用：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;高维输入空间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用于感知的 ML 组件通常在非常高维的输入空间上运行。比如，一个输入的RGB 图像可以是 1000 x 600 像素，它包含256((1000x600x3)) 个元素，输入通常就是这样的高维向量流。尽管研究人员已经对高维输入空间（如在数字电路中）使用了形式化方法，但基于 ML 的感知输入空间的性质是不同的，它不完全是布尔值，而是混合的，包括离散变量和连续变量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;高维参数/状态空间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深度神经网络等 ML 组件具有数千到数百万个模型参数和原始组件。例如，图 2 中使用的最先进的 DNN 有多达 6000 万个参数和数十层组件。这就产生了巨大的验证搜索空间，抽象过程需要非常仔细。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在线适应和进化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一些学习系统如使用 RL 的机器人，会随着它们遇到的新数据和新情况而发生进化。对于这样的系统，设计时的验证必须考虑系统行为的未来演变，或者随着学习系统的发展逐步地在线执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在上下文中建模系统&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于许多 AI/ML 组件，它们的规范仅仅由上下文来定义。例如，要验证图 2 中基于 DNN 的系统的安全性，就需要对环境进行建模。我们需要对 ML 组件及其上下文进行建模的技术，以便可以验证在语义上有意义的属性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近年来，许多工作都专注于提高效率，来验证 DNN 的鲁棒性和输入-输出属性。然而，这还不够，我们还需要在以下三个方面取得进展：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;自动抽象和高效表示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自动生成系统的抽象一直是形式方法的关键，它在将形式方法的范围扩展到大型硬件和软件系统方面发挥着至关重要的作用。为了解决基于 ML 的系统的超高维混合状态空间和输入空间方面的挑战，我们需要开发有效的技术来将 ML 模型抽象为更易于形式分析的、更简单的模型。一些有希望的方向包括：使用抽象解释来分析 DNN，开发用于伪造有 ML 组件的网络物理系统的抽象，以及设计用于验证的新表示（比如星集）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;解释与因果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果学习者在其预测中附上关于预测是如何从数据和背景知识中产生的的解释，那我们就可以简化对学习系统进行建模的任务。这个想法并不新鲜，ML 社区已经对诸如“基于解释的泛化”等术语进行了研究，但是最近，人们正在对使用逻辑来解释学习系统的输出重新产生了兴趣。解释生成有助于在设计时调试设计和规范，并有助于合成鲁棒的 AI 系统以在运行时提供保障。包含因果推理和反事实推理的 ML  还可以帮助生成用于形式方法的解释。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;语义特征空间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当生成的对抗性输入和反例在所使用的 ML 模型的上下文中具有语义意义时，ML 模型的对抗性分析和形式验证就更有意义。例如，针对汽车颜色或一天中时间的微小变化来分析 DNN 对象检测器的技术，比向少量任意选择的像素添加噪声的技术更有用。当前，大多数的方法在这一点上都还达不到要求。我们需要语义对抗分析，即在ML 模型所属系统的上下文中对它们进行分析。其中额的一个关键步骤，是表示对 ML 系统运行的环境建模的语义特征空间，而不是为 ML 模型定义输入空间的具体特征空间。这是符合直觉的，即与完整的具体特征空间相比，具体特征空间在语义上有意义的部分（如交通场景图像）所形成的潜在空间要低得多。图 2 中的语义特征空间是代表自动驾驶汽车周围 3D 世界的低维空间，而具体的特征空间是高维像素空间。由于语义特征空间的维数较低，因此可以更容易地进行搜索。但是，我们还需要一个“渲染器”，将语义特征空间中的一个点映射到具体特征空间中的一个点。渲染器的属性如可微性（differentiability），可以更容易地应用形式化方法来执行语义特征空间的目标导向搜索。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-none-contnet=&quot;t&quot;&gt;5&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用于设计和验证的计算引擎&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;硬件和软件系统形式化方法的有效性，是由底层“计算引擎”的进步推动的——例如，布尔可满足性求解 (SAT)、可满足性模理论 (SMT) 和模型检查。鉴于 AI/ML 系统规模、环境复杂性和所涉及的新型规范，需要一类新的计算引擎来进行高效且可扩展的训练、测试、设计和验证，实现这些进步必须克服的关键挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.1 &lt;/strong&gt;&lt;strong&gt;数据集设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据是机器学习的基本起点，提高 ML 系统质量就必须提高它所学习数据的质量。形式化方法如何帮助 ML 数据系统地选择、设计和扩充？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ML 的数据生成与硬件和软件的测试生成问题有相似之处。形式化方法已被证明对系统的、基于约束的测试生成是有效的，但这与对人工智能系统的要求不同，约束类型可能要复杂得多——例如，对使用传感器从复杂环境（如交通状况）捕获的数据的“真实性”进行编码要求。我们不仅需要生成具有特定特征的数据项（如发现错误的测试），还需要生成满足分布约束的集合；数据生成必须满足数据集大小和多样性的目标，以进行有效的训练和泛化。这些要求都需要开发一套新的形式化技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;形式&lt;/strong&gt;&lt;strong&gt;方法中的受控随机化&lt;/strong&gt;。数据集设计的这个问题有很多方面，首先必须定义“合法”输入的空间，以便根据应用程序语义正确形成示例；其次，需要捕获与现实世界数据相似性度量的约束；第三，通常需要对生成的示例的分布进行约束，以获得学习算法收敛到真实概念的保证。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们相信这些方面可以通过随机形式方法来解决——用于生成受形式约束和分布要求的数据的随机算法。一类称为控制即兴创作的新技术是很有前景的，即兴创作的生成要满足三个约束的随机字符串（示例）x：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，控制即兴理论仍处于起步阶段，我们才刚刚开始了解计算复杂性并设计有效的算法。反过来，即兴创作依赖于计算问题的最新进展，例如约束随机抽样、模型计数和基于概率编程的生成方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2 &lt;/strong&gt;&lt;strong&gt;定量验证&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了通过传统指标（状态空间维度、组件数量等）衡量AI 系统规模之外，组件的类型可能要复杂得多。例如，自主和半自主车辆及其控制器必须建模为混合动力系统，结合离散和连续动力学；此外，环境中的代表（人类、其他车辆）可能需要建模为概率过程。最后，需求可能不仅涉及传统关于安全性和活性的布尔规范，还包括对系统鲁棒性和性能的定量要求，然而大多数现有的验证方法，都是针对回答布尔验证问题。为了解决这一差距，必须开发用于定量验证的新可扩展引擎。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;定量语义分析&lt;/strong&gt;。一般来说，人工智能系统的复杂性和异构性意味着，规范的形式验证（布尔或定量）是不可判定的——例如，即便是确定线性混合系统的状态是否可达，也是不可判定的。为了克服计算复杂性带来的这一障碍，人们必须在语义特征空间上使用概率和定量验证的新技术，以增强本节前面讨论的抽象和建模方法。对于同时具有布尔和定量语义的规范形式，在诸如度量时间逻辑之类的形式中，将验证表述为优化，对于统一来自形式方法的计算方法和来自优化文献的计算方法至关重要。例如在基于模拟的时间逻辑证伪中，尽管它们必须应用于语义特征空间以提高效率，这种伪造技术也可用于系统地、对抗性地生成 ML 组件的训练数据。概率验证的技术应该超越传统的形式，如马尔科夫链或MDPs，以验证语义特征空间上的概率程序。同样，关于SMT求解的工作必须扩展到更有效地处理成本约束--换句话说，将SMT求解与优化方法相结合。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;我们需要了解在设计时可以保证什么，设计过程如何有助于运行时的安全操作，以及设计时和运行时技术如何有效地互操作。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.3 &lt;/strong&gt;&lt;strong&gt;AI/ML 的组合推理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于扩展到大型系统的正式方法，组合（模块化）推理是必不可少的。在组合验证中，一个大型系统（例如，程序）被拆分为它的组件（例如，程序），每个组件都根据规范进行验证，然后组件规范一起产生系统级规范。组合验证的一个常见方法是使用假设-保证合同，例如一个过程假设一些关于它的开始状态（前置条件），反过来又保证其结束状态（后置条件），类似的假设-保证范式已被开发并应用于并发的软件和硬件系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而，这些范式并不涵盖人工智能系统，这在很大程度上是由于 &quot;形式化规范 &quot;一节中讨论的人工智能系统的规范化挑战。组合式验证需要组合式规范——也就是说，组件必须是可形式化的。然而，正如“形式化规范”中所述，可能无法正式指定一个感知组件的正确行为。因此，挑战之一就是开发不依赖于有完整组合规范的组合推理技术。此外，人工智能系统的定量和概率性质，要求将组合推理的理论扩展到定量系统和规范。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推断组件合同。&lt;/strong&gt;人工智能系统的组合式设计和分析需要在多个方面取得进展。首先，需要在一些有前景的初步工作基础上，为这些系统的语义空间开发概率保证设计和验证的理论。第二，必须设计出新的归纳综合技术，以算法方式生成假设-保证合同，减少规范负担并促进组合推理。第三，为了处理诸如感知等没有精确正式规格的组件的情况，我们提出了从系统级分析中推断组件级约束的技术，并使用这种约束将组件级分析，包括对抗性分析，集中在搜索输入空间的 &quot;相关 &quot;部分。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-none-contnet=&quot;t&quot;&gt;6&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;建构中修正智能系统&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在理想的世界中，验证将与设计过程相结合，因此系统是“在建构中修正的”。例如，验证可以与编译/合成步骤交错进行，假设在集成电路中常见的寄存器传输级（RTL）设计流程中，或许它可以被集成到合成算法中，以确保实现满足规范。我们能不能为人工智能系统设计一个合适的在建构中逐步修正的设计流程？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.1 &lt;/strong&gt;&lt;strong&gt;ML 组件的规范驱动设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给定一个正式的规范，我们能否设计一个可证明满足该规范的机器学习组件（模型）？这种全新的 ML 组件设计有很多方面：（1）设计数据集，（2） 综合模型的结构，（3）生成一组有代表性的特征，（4） 综合超参数和 ML 算法选择的其他方面，以及（5）在综合失败时自动化调试 ML 模型或规范的技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ML 组件的正式合成。&lt;/strong&gt;解决前面所列出一些问题的解决方案正在出现，可以使用语义损失函数或通过认证的鲁棒性在 ML 模型上强制执行属性，这些技术可以与神经架构搜索等方法相结合，以生成正确构建的 DNN。另一种方法是基于新兴的形式归纳综合理论，即从满足形式化规范的程序实例中进行综合。解决形式归纳综合问题的最常见方法是使用 oracle-guided 方法，其中将学习者与回答查询的 oracle 配对；如示例中图2，oracle 可以是一个伪造者，它生成反例，显示学习组件的故障如何违反系统级规范。最后，使用定理证明来确保用于训练 ML 模型的算法的正确性，也是朝着建构修正的 ML 组件迈出的重要一步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.2 &lt;/strong&gt;&lt;strong&gt;基于机器学习的系统设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个挑战，是设计一个包含学习和非学习组件的整体系统。目前已经出现的几个研究问题：我们能否计算出可以限制 ML 组件运行的安全范围？我们能否设计一种控制或规划算法来克服它接收输入的基于 ML 感知组件的限制？我们可以为人工智能系统设计组合设计理论吗？当两个 ML 模型用于感知两种不同类型的传感器数据（例如，LiDAR 和视觉图像），并且每个模型在某些假设下都满足其规范，那么二者在什么条件下可以一起使用、以提高可靠性整体系统？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这一挑战上，取得进展的一个突出例子是基于安全学习的控制的工作。这种方法预先计算了一个安全包络线，并使用学习算法在该包络线内调整控制器，需要基于例如可达性分析、来有效计算此类安全包络的技术；同样，安全 RL 领域也取得了显着进展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而，这些并没有完全解决机器学习对感知和预测带来的挑战——例如，可证明安全的端到端深度强化学习尚未实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.3 &lt;/strong&gt;&lt;strong&gt;为弹性 AI 桥接设计时间和运行时间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正如“环境建模”部分所讨论的那样，许多 AI 系统在无法先验指定的环境中运行，因此总会有无法保证正确性的环境。在运行时实现容错和错误恢复的技术，对人工智能系统具有重要作用。我们需要系统地理解在设计时可以保证什么，设计过程如何有助于人工智能系统在运行时的安全和正确运行，以及设计时和运行时技术如何有效地互操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对此，关于容错和可靠系统的文献为我们提供了开发运行时保证技术的基础——即运行时验证和缓解技术；例如 Simplex 方法，就提供了一种将复杂但容易出错的模块与安全的、正式验证的备份模块相结合的方法。最近，结合设计时和运行时保证方法的技术显示了未验证的组件、包括那些基于人工智能和 ML 的组件，可以被包裹在运行时保证框架中，以提供安全运行的保证。但目前这些仅限于特定类别的系统，或者它们需要手动设计运行时监视器和缓解策略，在诸如内省环境建模、人工智能的监测器和安全回退策略的合成等方法上，还有更多的工作需要做。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此处讨论的建构中修正智能系统的设计方法可能会引入开销，使其更难以满足性能和实时要求。但我们相信（也许是非直觉的），在以下意义上，形式化方法甚至可以帮助提高系统的性能或能源效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统的性能调优往往与上下文无关——例如，任务需要独立于它们运行的环境来满足最后期限。但如果设计时就对这些环境进行正式表征，并在运行时对其进行监控，如果其系统运行经过正式验证是安全的，那么在这种环境下，ML 模型就可以用准确性来换取更高的效率。这种权衡可能是未来研究的一个富有成果的领域。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-none-contnet=&quot;t&quot;&gt;7&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从形式化方法的角度来看，我们剖析了设计高保证人工智能系统的问题。如图3所示，我们确定了将形式化方法应用于 AI 系统的五个主要挑战，并对这五项挑战中的每一项都制定了三项设计和验证原则，这些原则有希望解决这个挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 3 中的边显示了这些原则之间的依赖关系，例如运行时保证依赖于自省和数据驱动的环境建模，以提取可监测的假设和环境模型。同样，为了进行系统级分析，我们需要进行组合推理和抽象，其中一些 AI 组件可能需要挖掘规范，而其他组件则通过形式化的归纳综合构建生成正确的结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自 2016 年以来，包括作者在内的几位研究人员一直致力于应对这些挑战，当时本文已发表的原始版本介绍了一些样本进展。我们已经开发了开源工具 VerifAI 和 Scenic，它们实现了基于本文所述原则的技术，并已应用于自动驾驶和航空航天领域的工业规模系统。这些成果只是一个开始，还有很多事情要做。在未来的几年里，可验证 AI 有望继续成为一个富有成效的研究领域。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接：https://cacm.acm.org/magazines/2022/7/262079-toward-verified-artificial-intelligence/fulltext&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt; &lt;strong&gt;&lt;span&gt;更多内容，点击下方关注：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5ODEzMjIyMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPtXjwicoibpia0GEwTzHaE7VLcdMvxiaV27Es9lt6u2zZK5AsxwENshw3fU66UL2Hpf7eLneF1X86nGTA/0?wx_fmt=png&quot; data-nickname=&quot;AI科技评论&quot; data-alias=&quot;aitechtalk&quot; data-signature=&quot;聚焦AI前沿研究，关注AI青年成长&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;扫码添加 AI 科技评论 微信号，投稿&amp;amp;进群：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;234&quot; data-backw=&quot;546&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.42857142857142855&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cNFA8C0uVPvfRWTsmyhhPlIqhibx1eNmrTncouRia4QwrSuNlnQfYBibiaLAEuTUtmZRibTENX8RgOhGH5NTj0XxgHg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f02038c64ec3fa0e3d8b39936bdf7fdf</guid>
<title>Rust P2P网络应用实战-1 P2P网络核心概念及Ping程序</title>
<link>https://toutiao.io/k/trxyaac</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;本系列文章首先研究P2P网络的核心概念，然后详细分析libp2p-rust库中的应用实例，为以后开发P2P网络应用程序打好基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;P2P网络&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;P2P(Peer-to-Peer)是一种网络技术，可以在网络中不同的计算机上共享各种计算资源，如CPU、网络带宽和存储等。P2P技术应用最广泛的是在网络中共享文件以及区块链网络，它们不依赖中央服务器或中介来连接多个客户端，用户的计算机即是客户端也是服务器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于P2P网络是一种分布式系统，不会像中央服务器一样存在单点故障，因此容错性极强。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6044905008635578&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aZSfDXbVYlP5hb8ZcXHdb4Mu2X2Cic7rRZ80aWTnp4iaFVxeicNaCxSaDBNnticIJCeZ8ib6jFpJaQuExIUt2QACTGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面让我们来看一看P2P网络的核心概念：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传输协议&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在P2P网络底层一般使用TCP/UDP传输层协议。由于P2P节点应用的多样性，在TCP/UDP传输层协议之上，会使用多种应用层协议，如：HTTP，gRPC及自定义协议等。为了有效利用资源，P2P网络会在一个连接上监听、解析多种协议，即多路复用技术：多个逻辑子流可以在同一个底层(TCP)连接上共存。可以查看yamux 库了解更多细节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;节点标识&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;P2P网络中的节点需要一个唯一的标识，以便其他节点能够找到它们。P2P网络中的节点使用公钥和私钥对(非对称公钥加密)与其他节点建立安全通信。在P2P网络中节点标识被称为PeerId，它是通过对节点公钥进行加密哈希得到的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全规则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;密钥对和节点身份标识使节点之间能够体建立安全的、经过身份验证的通信通道。但这只是安全的一个方面，节点还需要根据业务逻辑实现授权框架，该框架建立一些规则：哪些节点可以执行哪种类型的操作等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;节点路由&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;P2P网络中的一个节点首先需要找到其他节点来进行通信。这是通过维护一个节点路由表来实现的。但是在P2P网络中，有成千上万个节点在动态变化(即节点的加入和离开)，单个节点很难为网络中的所有节点维护一个完整、准确的路由表。所以节点路由表通常会由一系列路由节点维护。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;P2P网络中的节点可以向特定节点发送消息，也可以广播消息。使用发布/订阅模式，节点订阅感兴趣Topic，所有订阅该Topic的节点都能接收和发送消息。这种技术也通常用于将消息的内容传输到整个网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流多路复用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在P2P网络中，允许多个独立的“逻辑”流共享一个公共的P2P传输层。流多路复用有助于优化节点之间建立网络连接的开销。多路复用在后端服务开发中很常见，客户端可以与服务器建立底层网络连接，然后在底层网络连接上复用不同的流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;libp2p&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自己编写P2P应用程序的网络层是一项庞大的工程，我们将使用底层p2p网络库—libp2p，在其上构建p2p应用程序会更加容易。libp2p是一个模块化的系统，支持三种编程语言：Rust、Go、JS。&lt;/span&gt;&lt;span&gt;许多流行的项目中都使用libp2p做为P2P网络底层，如IPFS、Filecoin、Polkadot和Substrate。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;libp2p将P2P网络基本概念分解成了不同的模块，可以在不同的应用场景中组合使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先通过Ping这个简单的程序来熟悉一下libp2p的组件及如何使用libp2p开发点对点网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PING&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个例子非常简单，主要就是一个节点向另一个节点发送ping消息，然后等待另一个节点返回pong消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;新建一个项目名叫：libp2p-learn&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;master&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;p2p Justin$ cargo new libp2p-learn&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;Created&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;binary (application) `libp2p-learn` package&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;master&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;p2p Justin$ cd libp2p-learn/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;master&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;libp2p-learn Justin$ code .&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Cargo.toml文件中加入libp2p和tokio依赖：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;[dependencies]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;libp2p&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;0.46&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;tokio&lt;/span&gt; = { version = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1.19&quot;&lt;/span&gt;, features = [&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;full&quot;&lt;/span&gt;] }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后在src/bin/目录下创建ping.rs文件：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__title&quot;&gt;error&lt;/span&gt;::&lt;span class=&quot;code-snippet__title&quot;&gt;Error&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;libp2p&lt;/span&gt;::{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__title&quot;&gt;futures&lt;/span&gt;::&lt;span class=&quot;code-snippet__title&quot;&gt;StreamExt&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__title&quot;&gt;identity&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__title&quot;&gt;ping&lt;/span&gt;::{&lt;span class=&quot;code-snippet__title&quot;&gt;Ping&lt;/span&gt;, &lt;span class=&quot;code-snippet__title&quot;&gt;PingConfig&lt;/span&gt;},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__title&quot;&gt;swarm&lt;/span&gt;::&lt;span class=&quot;code-snippet__title&quot;&gt;SwarmEvent&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__title&quot;&gt;Multiaddr&lt;/span&gt;, &lt;span class=&quot;code-snippet__title&quot;&gt;PeerId&lt;/span&gt;, &lt;span class=&quot;code-snippet__title&quot;&gt;Swarm&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;async fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    let key_pair = identity::Keypair::generate_ed25519();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    let peer_id = PeerId::from(key_pair.&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt;());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    println!(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;节点ID: {peer_id}&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    let behaviour = Ping::new(PingConfig::new().with_keep_alive(&lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    let transport = libp2p::development_transport(key_pair).await?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    let mut swarm = Swarm::new(transport, behaviour, peer_id);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    swarm.listen_on(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/ip4/0.0.0.0/tcp/0&quot;&lt;/span&gt;.parse()?)?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; let Some(remote_peer) = std::env::args().nth(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        let remote_peer_multiaddr: Multiaddr = remote_peer.parse()?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        swarm.dial(remote_peer_multiaddr)?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        println!(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;链接远程节点: {remote_peer}&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    loop {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        match swarm.select_next_some().await {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            SwarmEvent::NewListenAddr { address, .. } =&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                println!(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;本地监听地址: {address}&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            SwarmEvent::Behaviour(event) =&amp;gt; println!(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;{:?}&quot;&lt;/span&gt;, event),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            _ =&amp;gt; {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网络行为Behaviour：&lt;/span&gt;&lt;span&gt;传输(transport)定义如何在网络中发送字节流，而网络行为定义发送什么样的字节流，在这里我们发送ping/pong消息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网络管理模块Swarm：&lt;/span&gt;&lt;span&gt;用于管理节点之间的所有活跃连接和挂起连接，并管理所有已打开的子流状态。Swarm是通过传输、网络行为和节点PeerId来创建。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;节点地址：&lt;/span&gt;&lt;span&gt;/ip4/0.0.0.0/tcp/0，表示在本机所有ip地址上，开一个随机的Tcp端口进行监听。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;打开一个终端，运行：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;cargo&lt;/span&gt; run --bin ping&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__symbol&quot;&gt;master:&lt;/span&gt;libp2p-learn Justin$ cargo run --bin ping&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   Compiling libp2p-learn v&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;1.0&lt;/span&gt; (&lt;span class=&quot;code-snippet__regexp&quot;&gt;/Users/&lt;/span&gt;Justin/workspace_rust_exercise/network-study/p2p/libp2p-learn)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Finished dev [unoptimized + debuginfo] target(s) &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;8.65&lt;/span&gt;s&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     Running &lt;span class=&quot;code-snippet__string&quot;&gt;`target/debug/ping`&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;节点&lt;span class=&quot;code-snippet__symbol&quot;&gt;ID:&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;12&lt;/span&gt;D3KooWR7H9SwB2yiFBKvzcVGFdpeKmuFG9qDTBTvuuuDarASST&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;本地监听地址: &lt;span class=&quot;code-snippet__regexp&quot;&gt;/ip4/&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;/tcp/&lt;span class=&quot;code-snippet__number&quot;&gt;58645&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到已经打印出PeerId和监听地址。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;打开另一个终端，运行：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;cargo&lt;/span&gt; run --bin ping /ip4/&lt;span class=&quot;code-snippet__number&quot;&gt;127.0.0.1&lt;/span&gt;/tcp/&lt;span class=&quot;code-snippet__number&quot;&gt;58645&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__symbol&quot;&gt;master:&lt;/span&gt;libp2p-learn Justin$ cargo run --bin ping /ip4/&lt;span class=&quot;code-snippet__number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;/tcp/&lt;span class=&quot;code-snippet__number&quot;&gt;58645&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Finished dev [unoptimized + debuginfo] target(s) &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;36&lt;/span&gt;s&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     Running &lt;span class=&quot;code-snippet__string&quot;&gt;`target/debug/ping /ip4/127.0.0.1/tcp/58645`&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;节点&lt;span class=&quot;code-snippet__symbol&quot;&gt;ID:&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;12&lt;/span&gt;D3KooWCUFTHNMJrR1p8vkFEFFYm4J8iPA1Wh6x2Dya5qmU1xdL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;链接远程节点: &lt;span class=&quot;code-snippet__regexp&quot;&gt;/ip4/&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;/tcp/&lt;span class=&quot;code-snippet__number&quot;&gt;58645&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;本地监听地址: &lt;span class=&quot;code-snippet__regexp&quot;&gt;/ip4/&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;/tcp/&lt;span class=&quot;code-snippet__number&quot;&gt;58727&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Event { &lt;span class=&quot;code-snippet__symbol&quot;&gt;peer:&lt;/span&gt; PeerId(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;12D3KooWR7H9SwB2yiFBKvzcVGFdpeKmuFG9qDTBTvuuuDarASST&quot;&lt;/span&gt;), &lt;span class=&quot;code-snippet__symbol&quot;&gt;result:&lt;/span&gt; Ok(Pong) }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Event { &lt;span class=&quot;code-snippet__symbol&quot;&gt;peer:&lt;/span&gt; PeerId(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;12D3KooWR7H9SwB2yiFBKvzcVGFdpeKmuFG9qDTBTvuuuDarASST&quot;&lt;/span&gt;), &lt;span class=&quot;code-snippet__symbol&quot;&gt;result:&lt;/span&gt; Ok(Ping { &lt;span class=&quot;code-snippet__symbol&quot;&gt;rtt:&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1.234008&lt;/span&gt;ms }) }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到链接到刚刚的节点/ip4/127.0.0.1/tcp/58645成功，也收到了发送过来的ping/pong的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下一篇文章我们将详细解析P2P聊天程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5MjA1ODYzNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/aZSfDXbVYlNFJZTrPP4XpkpGgdp7GlbufiamLErMPtGdmgRr0Sx53TdPZpp4gJPZLXwt9ax8ZTO6aBo6lmAeHGA/0?wx_fmt=png&quot; data-nickname=&quot;coding到灯火阑珊&quot; data-alias=&quot;coding-light-coding&quot; data-signature=&quot;专注于技术分享，包括Rust、Golang、分布式架构、云原生等。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ccb4f76c72abdffbc16ee6e9a8151228</guid>
<title>万字干货｜美团酒旅数据治理实践（建议收藏）</title>
<link>https://toutiao.io/k/r0q48r8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 为什么要做数据治理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 需要治理哪些问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 美团酒旅数据现状&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 治理目标&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;二、数据治理实践&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 数据治理策略&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 标准化和组织保障&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 技术系统&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 衡量指标&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5. 治理效果总结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;三、未来规划&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;四、作者简介&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 为什么要做数据治理&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;随着移动互联网的兴起，线下商业活动逐渐开始向线上化发展，数据的产生速度有了极大的提升。越来越多的公司开始认识到数据的重要性，并将其打造成为公司的核心资产，从而驱动业务的发展。在数据相关的领域中，“数据治理”这个话题近两年尤为火热，很多公司特别是大型互联网公司都在做一些数据治理的规划和动作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么要做数据治理？因为在数据产生、采集、加工、存储、应用到销毁的全过程中，每个环节都可能会引入各种质量、效率或安全相关的问题。在公司早期的发展阶段，这些数据问题对公司发展的影响并不是很大，公司对问题的容忍度相对也比较高。但是，随着业务的发展，公司在利用数据资产创造价值的同时，对数据质量和稳定性要求也有所提升。此外，当数据积累得越来越多，公司对数据精细化运营程度的要求也随之提高，会逐渐发现有很多问题需要治理。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5526315789473685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJa1G5ib6fbNPFmEr1Ujdhr26XAYvwkhBTv4C5FSbsjtOwic9cRjcCCOQYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 需要治理哪些问题&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据治理是一项需要长期被关注的复杂工程，这项工程通过建立一个满足企业需求的数据决策体系，在数据资产管理过程中行使权力、管控和决策等活动，并涉及到组织、流程、管理制度和技术体系等多个方面。一般而言，数据治理的治理内容主要包括下面几个部分：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;质量问题&lt;/strong&gt;：这是最重要的问题，很多公司的数据部门启动数据治理的大背景就是数据质量存在问题，比如数仓的及时性、准确性、规范性，以及数据应用指标的逻辑一致性问题等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;成本问题&lt;/strong&gt;：互联网行业数据膨胀速度非常快，大型互联网公司在大数据基础设施上的成本投入占比非常高，而且随着数据量的增加，成本也将继续攀升。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;效率问题&lt;/strong&gt;：在数据开发和数据管理过程中都会遇到一些影响效率的问题，很多时候是靠“盲目”地堆人力在做。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;安全问题&lt;/strong&gt;：业务部门特别关注用户数据，一旦泄露，对业务的影响非常之大，甚至能左右整个业务的生死。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;标准问题&lt;/strong&gt;：当公司业务部门比较多的时候，各业务部门、开发团队的数据标准不一致，数据打通和整合过程中都会出现很多问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5405982905982906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaawgskq8iaujiaXYhjtc8edWdXYPfldoiaOuDnqP8DKCyD1VDlgjoD5TDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 美团酒旅数据现状&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2014年，美团酒旅业务成为独立的业务部门，到2018年，酒旅平台已经成为国内酒旅业务重要的在线预订平台之一。业务发展速度较快，数据增长速度也很快。在2017到2018两年里，生产任务数以每年超过一倍的速度在增长，数据量以每年两倍多的速度在增长。如果不做治理的话，根据这种接近指数级的数据增长趋势来预测，未来数据生产任务的复杂性及成本负担都会变得非常之高。在2019年初，我们面临着下面五种问题：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据质量问题严重&lt;/strong&gt;：一是数据冗余严重，从数据任务增长的速度来看，新上线任务多，下线任务少，对数据表生命周期的控制较少；二是在数据建设过程中，很多应用层数据都属于“烟囱式”建设，很多指标口径没有统一的管理规范，数据一致性无法进行保证，同名不同义、同义不同名的现象频发。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据成本增长过快&lt;/strong&gt;：某些业务线大数据存储和计算资源的机器费用占比已经超过了35%，如果不加以控制，大数据成本费用只会变得越来越高。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据运营效率低下&lt;/strong&gt;：数据使用和咨询多，数据开发工程师需要花费大量时间一对一解答业务用户的各种问题。但是这种方式对于用户来说，并没有提升数据的易用性，无法有效地积累和沉淀数据知识，还降低了研发人员的工作效率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据安全缺乏控制&lt;/strong&gt;：各业务线之间可以共用的数据比较多，而且每个业务线没有统一的数据权限管控标准。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;开发标准规范缺失&lt;/strong&gt;：早期为快速响应业务需求，研发人员通常采用“烟囱式”的开发模式，由于缺乏相应的开发规范约束，且数据工程师的工作思路和方式差异性都非常大，导致数据仓库内的重复数据多，规范性较差。当发生数据问题时，问题的排查难度也非常大，且耗时较长。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 治理目标&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2019年，美团酒旅数据团队开始主动启动数据治理工作，对数据生命周期全链路进行体系化数据治理，期望保障数据的长期向好，解决数据各个链路的问题，并保持数据体系的长期稳定。具体的目标包含以下几个方面：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;建立数据开发全链路的标准规范，提高数据质量，通过系统化手段管理指标口径，保障数据一致性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;控制大数据成本，避免大数据机器成本膨胀对业务营收带来的影响，合理控制数据的生命周期，避免数据重复建设，减少数据冗余，及时归档和清理冷数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;管理数据的使用安全，建立完善的数据安全审批流程和使用规范，确保数据被合理地使用，避免因用户数据泄露带来的安全风险和商业损失。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;提高数据工程师的开发和运维效率，减少他们数据运营时间的投入，提高数据运营的自动化和系统化程度。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、数据治理实践&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实早在2018年以前，酒旅数据组就做过数据治理，当时只是从数仓建模、指标管理和应用上单点做了优化和流程规范。之后，基于上面提到的五个问题，我们又做了一个体系化的数据治理工作。下面将介绍一下美团酒旅数据团队在数据治理各个方向上的具体实践。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 数据治理策略&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据治理方案需要覆盖数据生命周期的全链路，我们把数据治理的内容划分为几大部分：组织、标准规范、技术、衡量指标。整体数据治理的实现路径是以标准化的规范和组织保障为前提，通过做技术体系整体保证数据治理策略的实现。同时，搭建数据治理的衡量体系，随时观测和监控数据治理的效果，保障数据治理长期向好的方向发展。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4643196955280685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaqbm3zibkbrrsriakHZCqDbEBiaENyvwV6fg8MjeMZqAve5kWvHNcLh5kQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1051&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 标准化和组织保障&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们制定了一个全链路的数据标准，从数据采集、数仓开发、指标管理到数据生命周期管理，全链路建立标准，在标准化建立过程中联合组建了业务部门的数据管理委员会。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4912109375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJarKSAVJsNXoqXAW4oamuv7hkQS024b8WV1iaSZnibniaB6DeOAO9DVVKBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;2.1 标准化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据标准化包括三个方面：一是标准制定；二是标准执行；三是在标准制定和执行过程中的组织保障，比如怎么让标准能在数据技术部门、业务部门和相关商业分析部门达成统一。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从标准制定上，我们制定了一套覆盖数据生产到使用全链路的数据标准方法，从数据采集、数仓开发、指标管理到数据生命周期管理都建立了相应环节的标准化的研发规范，数据从接入到消亡整个生命周期全部实现了标准化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2 组织保障&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;根据美团数据管理分散的现状，专门建立一个职能全面的治理组织去监督执行数据治理工作的成本有点太高，在推动和执行上，阻力也会比较大。所以，在组织保障上，我们建立了委员会机制，通过联合业务部门和技术部门中与数据最相关的团队成立了数据管理委员会，再通过委员会去推动相关各方去协同数据治理的相关工作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业务部门的数据接口团队是数据产品组，数据技术体系是由数据开发组负责建设，所以我们以这两个团队作为核心建立了业务数据管理委员会，并由这两个团队负责联合业务部门和技术部门的相关团队，一起完成数据治理各个环节工作和流程的保障。组织中各个团队的职责分工如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;数据管理委员会&lt;/strong&gt;：负责数据治理策略、目标、流程和标准的制定，并推动所有相关团队达成认知一致。&lt;strong&gt;业务数据产品组&lt;/strong&gt;：负责数据标准、需求对接流程、指标统一管理、数据安全控制以及业务方各部门的协调推动工作。&lt;strong&gt;技术数据开发组&lt;/strong&gt;：负责数据仓库、数据产品、数据质量、数据安全和数据工具的技术实现，以及技术团队各个部门的协调推动工作。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 技术系统&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据治理涉及的范围非常广，需要协作的团队也很多，除了需要通过组织和流程来保障治理行动正常开展，我们也考虑通过技术系统化和自动化的方式进一步提效，让系统代替人工。下面我们将从数据质量、数据成本、数据安全和运营效率等几个方向，来逐一介绍技术实现方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1 数据质量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据质量是影响数据价值最重要的因素，高质量的数据给带来准确的数据分析，错误的数据会把业务引导到错误的方向。数据质量涉及范围较广，在数据链路的每一个环节都有可能出现数据质量问题，酒旅业务现阶段的主要质量问题包括：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数仓规范性差，数仓架构无统一的强制规范执行约束，数仓历史冗余数据严重。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;应用层数据属于“烟囱式”建设，指标在多个任务中生产，无法保证数据的一致性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据下游应用的数据使用无法把控，数据准确较差，接口稳定性无法得到保障。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务方对多个数据产品的指标逻辑无统一的定义，各个产品中数据不能直接对标。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据组的治理数据质量方案覆盖了数据生命周期的各个环节，下面将介绍一下整体的技术架构。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;统一数仓规范建模（One Model）&lt;/strong&gt;：通过统一数仓规范建模系统化保障数仓规范执行，做到业务数仓规范标准化，并及时监控和删除重复和过期的数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;统一指标逻辑管理（One Logic）&lt;/strong&gt;：通过业务内统一的指标定义和使用，并系统化管理指标逻辑，数据应用层的数据指标逻辑都从指标管理系统中获取，保障所有产品中的指标逻辑一致。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;统一数据服务（One Service）&lt;/strong&gt;：通过建设统一的数据服务接口层，解耦数据逻辑和接口服务，当数据逻辑发生变化后不影响接口数据准确性，同时监控接口的调用，掌握数据的使用情况。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;统一用户产品入口（One Portal）&lt;/strong&gt;：分用户整合数据产品入口，使同一场景下数据逻辑和使用方式相同，用户没有数据不一致的困惑。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6632947976878613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaIicWNbq3jQszGYIQswnibZm4Qiapw4VOxID6WKPmuCcXBB3lSDtVYtW6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;692&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.1 统一数仓规范建模（One Model）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在业务发展初期，数据团队集中精力在快速建设数仓来支持业务，数仓建模规范疏于管理。随着业务的发展，数仓中的数据急剧增多，数据产品和下游应用快速增加，数据工程师和数据使用方也变得越来越多，数仓的问题日益突显。业务数据仓库从初期发展到现在主要暴露了3方面的问题：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据规范性较差，不同时间的数仓规范不同，数仓规范的执行审核需要较多的人力。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据不一致问题多，同一指标在多个ETL中生产，数据更新同步也不及时。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;历史数据冗余严重，数据存储方式较多，业务方查询不知道该用哪个数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据团队主要通过数仓规范化制定、数仓分层架构和数仓规范化系统来解决上述问题，下面是我们的具体解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;制定标准-数仓规范&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;做好数仓规范化最基本的前提是要制定一系列标准化的规范，并推动组内同学执行。标准化的适用性、全面性和可执行性直接影响到规范的执行效果。数仓规范主要从3个方面制定数据标准化：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数仓建模规范，数仓建设最基础的规范，包括分层、命名、码值、指标定义、分层依赖等维度。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;主数据管理规范，数仓各个主题的数据只有一份，团队共建复用，不能重复开发。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据使用规范，在查询数据时优先查询主题层，不再提供明细层和ODS层的查询访问入口。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;工具保障-数仓规范化开发系统-Dataman&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在执行数据规范化的过程中，我们发现团队中每个人对规范的理解不一致，很可能造成数据规范不统一，审核人在审核上线任务时需要考虑规范的全部规则，审批需要投入的人力较多。在这样的流程下，数据规范性无法从根源上进行控制，因此需要建设数据规范化的工具，通过系统保障规范的一致性。数据组使用的数据层规范化工具-Dataman，主要包括3个功能模块：标准化规范、配置化开发和规则化验证。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5255102040816326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJawbMGdoqZAMuhE47fy7QsicfcuicZqSG4MglE4miawDFShjdW8oe2FG0ZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;标准化规范&lt;/strong&gt;：制定业务数据仓库的标准规范并配置在系统中，包括架构分层、字段管理、词根管理、公共维度和码值管理等，在ETL开发时通过统一的数仓规范开发，通过配置化实现数仓的命名、分层和码值，保障数仓长期的规范性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32575757575757575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaV1U9eB8hf3GOJCZzibZicKeytBhjTbwm2AL4K94s3b6ep9oq2icdteSlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;924&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;配置化开发&lt;/strong&gt;：系统化保障工程师在开发ETL过程中遵守数仓规范，Dataman可以用配置化的方式生成XT任务模板，模板中包含数据模型的基础信息，研发同学只需要在任务模板中开发数据生产逻辑。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36804308797127466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaCovGoD8smEcxeliaHXBJVZBq3fS03uBzffwDQqXnhBibIbNgYPibtECVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1114&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;规则化验证&lt;/strong&gt;：跟进数据仓库底层元数据和标准化配置信息，定期扫描数仓的规范性情况，判断出不符合数仓规范的任务和高相似度的数据表。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.2 统一指标逻辑管理（One Logic）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业务使用数据的第一步是搭建业务指标体系，业务的目标和策略的执行情况需要通过指标来分析，指标体系的合理性和指标数据的质量直接影响到业务决策，指标的重要性不言而喻。我们通过系统化地管理数据指标，从根源上解决指标口径一致性问题，主要从以下3个方向入手：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;指标定义规范化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此处主要从指标的生成和管理上做好规范，确保业务同学和研发人员对指标体系管理的认知一致，确保指标的新建、更改和使用都按照规范执行。我们通过下面2个方向来实现指标定义的规范统一。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;业务指标体系的规范化&lt;/strong&gt;：我们在业务线内统一了指标体系规范，指标分为原子指标、计算指标和复合指标，通过使用这3类指标支持业务的数据分析需求，业务未来新增指标也要按照这个标准分类。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;指标的管理规范化&lt;/strong&gt;：我们与商业分析团队一起梳理业务指标逻辑标准和录入流程，通过制定指标的新增和变更规范SOP，解决由指标管理流程引起的质量问题，使得指标定义、系统录入、指标认证和使用各个环节都有严格的流程管控，经由业务侧数据产品经理、业务侧数据治理数据管理员和数据工程师共同审批，确保标准规范的落地执行。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;指标管理系统化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;物理数据表管理&lt;/strong&gt;：数据表管理的信息主要包括表的基础元数据信息、表类型（&lt;/span&gt;&lt;span&gt;维表或事实表&lt;/span&gt;&lt;span&gt;）、表的推荐度、描述信息和样例数据等。数据表管理主要是面向数据开发同学，通过维护数据表信息，为数据模型和指标管理提供数据基础支持。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;数据模型管理&lt;/strong&gt;：是对物理数据表的模型构建，通过一个物理模型可以查询到指标和相关的维度数据。数据模型可以是星型模型或宽表，星型模型中维护多个数据表的关联方式、关联字段、维度表包含字段和模型的ER图等信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;指标管理&lt;/strong&gt;：主要包括2部分的内容，指标的业务信息和技术信息。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;业务信息&lt;/strong&gt;：为了保障业务的指标信息准确且统一，指标的业务信息需要数据产品经理与商业分析团队讨论确定后录入，录入后需要指标所属数据主题的负责人审批后才能上线。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;技术信息&lt;/strong&gt;：技术信息主要包括指标对应的物理模型以及指标的计算逻辑，技术信息的填写需要数据工程师配置。技术信息配置后会在系统里生成技术元数据，指标管理系统通过技术元数据生成数据查询语句，提供给下游应用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7037552155771906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJanOqxoEzkuDYb9IAdXLvEhEU54M1oBXdOQb9CRUpeq6hJKLMm9vs68g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;719&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;指标查询智能化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在指标管理系统中创建指标时，我们系统化管理了指标与数仓物理模型的关联关系和取数逻辑，通过数据物理模型获得指标对应的字段和可以关联的维度，以此把指标解析为数据查询SQL语句，通过数据查询引擎执行生产的SQL，智能化获得指标数据。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6252390057361377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJayItIGUtIIjGaPZzGF7RSwfzGvJ4x3O5mSSB71L1K4gmMIQxugN8mGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2092&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在查询解析过程中，经常出现指标绑定了多个底层数据表的情况，此时需要我们手动的选一个物理模型作为指标生产的底层数据。但问题是，如果一个指标对应的模型太多，每次解析都需要手动指定，研发人员不确定选择哪个模型的性能最好。另外，随着物理模型的增多，大量旧的指标配置的关联模型不是最优解，就需要手动优化更改。为了解决这个问题，指标管理系统增加了智能解析模块，在选择智能模式查询时，系统会根据指标管理模型的数据量、存储性能和查询次数等信息自动选取最优的物理模型。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.3 统一数据服务（One Service）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据仓库对外提供数据的需求越来越多，除了管理层、分析师和产品运营同学使用数据产品和报表外，数据还需要提供到各个业务系统中使用。常用的提供数据的方式主要包括同步数据表、提供SQL和为下游服务开发定制化API接口等方式，但存在以下几个方面的问题：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据一致性无法保障，当数据指标逻辑更改时，业务系统不能及时调整，导致不同业务系统的数据不一致。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据同步到业务系统后，我们就无法管控数据的使用方式，也不能监控到数据是否被其他下游使用的情况。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据开发效率比较低，数据服务稳定性比较差，数据工程师开发一个定制化API接口需要几天时间，各个接口服务单独维护，服务稳定性也比较差。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从2018年开始，数据BP中心与分析系统中心合作建设了统一数据API服务平台（&lt;/span&gt;&lt;span&gt;Buffalo&lt;/span&gt;&lt;span&gt;），通过开发可配置的数据接口服务平台实现数据对外的灵活提供，并实现对数据服务的下游使用及性能的可监控。统一的数据服务平台解决了几个比较关键的问题：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据逻辑统一收口&lt;/strong&gt;：数据服务接口和数据逻辑解耦，当数仓更改和数据指标逻辑变更后下游无感知。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据服务的更好管控&lt;/strong&gt;：研发同学能够了解到数据被哪些下游使用、调用了多少次和数据服务是否稳定等信息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;开发效率大幅提升，服务稳定性大幅提高&lt;/strong&gt;：通过统一服务平台可以在1小时内完成一个接口的配置化开发，与此同时，接口稳定性统一运维，服务稳定性有了很好的保障。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4895155459146782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJalicKP1xhnian28d93KM9lh4ywYia3gJNVXlDbamz1pWy9F9rZ4tlwAibmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2766&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.4 统一用户产品入口（One Portal）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果不加控制，数据产品就会建设得越来越多。酒旅业务在2018年有超过10个数据相关产品的入口，用户很难快速地找到自己想要查的数据产品和报表。不同产品面对的用户不一样，数据的使用场景和展示方式也各不相同，业务方在使用数据时不知道从哪里能看到最全面的数据产品。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，也存在因为适用场景不一样，导致面向不同用户的数据逻辑不同的情况，比如某些业务同学查看的GMV不包含民宿数据，但是商业分析团队要看的GMV是包含民宿数据的。为了能够让业务方能够在一个数据产品门户中找到更全面的数据，且这个产品门户中多个产品的数据逻辑是一致的，我们将数据门户按照使用用户和应用场景划分为3类：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;决策分析使用“大圣”（&lt;/span&gt;&lt;span&gt;美团内部的数据平台&lt;/span&gt;&lt;span&gt;），面向管理者和商业分析团队，所有业务管理者和商业分析团队成员需要的数据都可以从大圣数据产品里查看。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务数据查询使用“天狼” （&lt;/span&gt;&lt;span&gt;美团内部的数据平台&lt;/span&gt;&lt;span&gt;），用户主要是销售，在天狼里能查看销售所需的各种数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据资产信息查询使用“大禹”（&lt;/span&gt;&lt;span&gt;美团内部的数据平台&lt;/span&gt;&lt;span&gt;），用户是研发人员和检索数据信息的业务方，在大禹数据门户里可以找到数据资产的信息，能更快地找到想要的数据，更全面地了解相关的元数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3431558935361217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaKQgwsvniciaicia9F7yZwG19yIwlDpzvdibAiccApOV254rqQmTghF0s7Qug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.5 整体系统架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整体的技术架构分为三层，从统一数据建模到统一指标逻辑、统一数据服务和统一产品入口，整体保障了数据的质量，同时配合数据管理的组织保障体系和流程规范，将整体数据质量相关的架构搭建起来。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5331632653061225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaA9xInHW3Wx508TglNOxnzqHh7korjibNfogMse25agdibMoyBHC0E1Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2352&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2 数据运营效率&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据工程师在日常工作中的主要工作包括两大部分：数据开发和数据运营。我们在前面介绍了通过数据开发和指标管理相关的工具系统建设，开发效率得到了大幅提升。而数据运营是另一大类工作，他们的主要时间投入在数据使用咨询和数据问题答疑，大概占数据工程师日常工作5%～10%的时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据工程师日常投入到运营的人力多的主要原因是信息不对称和信息检索能力弱，数据团队建设了很多数据模型和数据产品，但是用户不知道怎么快速地找到和使用这些数据，问题主要体现在下面3个方面：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;找数难&lt;/strong&gt;：所需要的数据有没有？在哪里能找到？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;看不懂&lt;/strong&gt;：数据仓库是以数据表和报表等方式提供，数据的逻辑和含义不够清晰易懂。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;不会用&lt;/strong&gt;：数据指标的查询逻辑是什么？多个表怎么关联使用？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.1 方案思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据团队通过数据资产信息的系统化的方式建设易用的数据检索产品，帮助用户更快捷、更方便地找到数据，并指导用户正确地使用数据，提高数据信息的易用性，以此减少数据工程师的数据答疑和运维时间。实现策略是通过用户的问题分类，通过数据信息系统化的方式分类解答80%的问题，最后少量的问题透传到研发人员再进行人工答疑。系统化方式主要分两层，数据使用智能和数据答疑机器人。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42527472527472526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJarH12tffHJaeSNDccUq1AUERV60oagrqSicAZhlt3HCRDrgKkFCdgjicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.2 数据使用指南系统&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据使用指南的定位是业务数据信息的知识白皮书，提供最新、最全、最准确的指标口径、项目指标体系、数据表用法等信息，以简洁、流畅的操作支持数据指南中的内容及时更新，降低业务方的数据答疑和数据使用成本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据使用指南通过把业务场景和数据使用场景打通，从业务场景分析到使用到的数据表、指标和数据产品打通，在系统中能够快速找到数据表、指标定义、数据查询SQL、指标所在数据产品等信息，一站式解决数据查找、使用和分析的全部场景。主要功能包括指标信息和数据表信息及使用。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;指标信息&lt;/strong&gt;：包括业务分类指标和指标的详细信息，在指标详细信息页面可以查看指标定义、指标使用场景、指标统计维度、指标对应数据表、指标所在数据产品和指标的SQL查询示例等信息，把指标信息与数据表和数据产品关联，方便用户快速根据指标信息查找到数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据表信息及使用方式&lt;/strong&gt;：包括数据表的基础信息、表的使用推荐度、SQL查询样例、数据更新时间和数据就绪时间等信息，帮助使用者快速定位需要的数据表和数据SQL的查询使用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4792079207920792&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaQHxrdKAia0rhTbo9p7sWt5XicJQtfTjJ2qNpenRk1Yg9YblIlVIkbQfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1010&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.3 数据答疑机器人&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户在使用数据时，经常咨询数据工程师一些问题，比如想找的数据在哪个表？指标怎么取？业务系统的一个字段怎么在数仓里面取到？很多问题会被重复问到，每次解答都需要研发人员花费一定的时间，而通过Wiki的方式维护效果较差，于是我们考虑用自动化答疑的方式，把数据工程师在日常答疑过程中积累问题和答案，通过一定的规则匹配，当再次被问到时系统可以自动地给出解答。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用日常答疑中积累的咨询问题和答案作为基础答疑知识库，数据答疑机器人使用美团AI平台的摩西机器人搭建，配合问题答疑的策略，实现对历史已有问题和答案通过搜索匹配后发送给用户，具体实现方式如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45569620253164556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaVqVlpiap9icLMngyuQ4xcibGFClCqnQz9Qdre4BJgCbOzdAicmTGDSg5eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;948&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3 数据成本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大数据的主要成本构成有3大部分，计算资源、存储资源和日志采集资源，其中计算资源和存储占总成本超过90%，我们的数据成本治理主要是针对大数据计算和存储这两个部分。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;254&quot; data-ratio=&quot;0.4822076978939724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaqlPWic7mticAWbPF1LFgdHhjawn4h1n53UzSvichRdibgoJKIOicaia6EZMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2754&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;大数据成本优化方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;计算资源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无效任务清理，通过任务生产出来数据的使用情况判断是否为无效任务，通过下线无效任务，减少任务执行使用的计算资源。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;超长任务优化，经过任务的计算资源使用数据可以发现，某几个大任务在执行时会占用大部分的计算资源，导致其他任务执行时间变长，或者占用配置外的弹性计算资源，导致计算成本增加。数据组会统计和监控每天任务的执行情况，发现执行时间长（&lt;/span&gt;&lt;span&gt;超过2个小时&lt;/span&gt;&lt;span&gt;）或者占用资源多的任务会及时进行优化。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分散利用计算资源，数仓的夜间批处理任务使用计算资源的实际一般都集中在早晨2点到上午10点前，这就导致在一天中只有三分之一的资源被充分利用，而且这段时间内通常资源都是不够用的，需要使用平台提供的配置外弹性资源。而其他时间段的计算资源闲置，对资源有较大的浪费。为了把全天的资源都有效地利用起来，我们会把一些对就绪时间不敏感的任务（&lt;/span&gt;&lt;span&gt;比如算法挖掘、用户标签、数据回刷等&lt;/span&gt;&lt;span&gt;）放到10点之后，把配置的计算资源充分利用起来。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;租户拆分和整合统一管理，提高资源池总量和资源总体的使用率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;存储资源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数仓架构优化和重构：通过统一数仓建模规范，把相似或相同模型进行整合和去重，确保每个主题数据只保留一份。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据存储压缩：在数据仓库建设初期，很多Hive表的存储格式是txt，通过压缩为ORC格式可以减少大量的存储空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;冷数据处理：把数据分为冷、热两大类数据，通过每天对全部数仓表扫描识别出冷数据，发给数据负责人及时处理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据生命周期控制：按照数仓分层的应用场景配置数据的生命周期，明细数仓层保留的全部历史数据，主题层保留5年数据，应用层保留1～3年数据。通过数据生命周期控制，极大地减少了数据存储成本。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;日志采集资源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;下线冷数据的上游日志数据收集任务，数据收集费用主要来自两类数据，业务系统数据库的Log同步和后台日志数据收集，通过对收集数据的使用情况监控，及时下线下游无应用的数据收集任务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3.4 数据安全&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据资产对业务来说既是价值，也是风险。数据安全作为业务部门“事关生死”的核心工作，在技术架构上会从数据产生到数据应用各个环节进行控制，保障数据应用事前有控制、事中有监控和事后有审计。数据安全控制从业务系统开始对用户高敏感数据加密，在数仓进行分级和脱敏，在应用层做密文数据权限和密钥权限的双重保障，管控用户相关的高敏感数据，按照三层系统控制加五个使用原则实现如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48810656517602286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaPnhbV5IPEboOmRrJMx0HfQSWQFwmKTPBIiavyib37It2oHEic6kicib7p3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1051&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 衡量指标&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业务部门在业务发展初级就会建立指标体系，并使用数据指标对各个业务过程做精细化的分析，衡量业务目标的达成情况和行动的执行程度。数据治理也需要一套成熟稳定的衡量指标体系，对数据体系做到长期、稳定和可量化的衡量。我们通过制定体系化的数据衡量指标体系，来及时监测数据治理过程中哪些部分做的好，哪些部分还有问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1 衡量指标建设&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了能够不重不漏地把指标都建立起来，我们从2个方面进行考虑：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;技术分类，按照数据团队关注的问题和目标，把数据治理的指标体系分成质量、成本、安全、易用性和效率这5大类。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据流环节，分别从数据的采集、生产、存储、指标管理、应用和销毁等环节监控关注的指标。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5178217821782178&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaxkut0f2ww4BhejLqf8F45xdices6xtoibt1ROU5PryFWP9h98tp6GpzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1010&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;4.2 衡量指标保障数据治理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;根据PDCA原则，将数据治理作为日常的运营项目做起来，底层依赖数据指标体系进行监控，之上从发现问题到提出优化方案，然后跟进处理，再到日常监控，构成一个完整的循环。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5309734513274337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJaibMoqur8ItxRWQ3AdL0OHPm7oEdJaqDAiaBibQkdCQ2QmicgUJyZv4yWMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 治理效果总结&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据治理覆盖了数据生命周期全链路，通过围绕数据从产生到价值消亡全部生命周期，建立数据治理组织、制定治理衡量体系和建设治理技术系统来达到数据治理目标。经过体系化的数据治理，数据系统的治理、成本、安全和运营效率都有了比较大的改善。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据质量&lt;/strong&gt;：技术架构优化后，通过标准化规范和系统保障数据的准确性，并在治理过程中清除和整合了历史冗余数据，数据质量问题有很大的改善。2019年数据生产任务的增长率比2018年减少了60%左右。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据成本&lt;/strong&gt;：经过数据成本优化后，在支持2019年酒旅业务高速增长的同时，大数据的单均成本费用降低了40%左右。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据安全&lt;/strong&gt;：通过业务系统数据加密和数据仓库数据脱敏，双重保障高敏感数据安全，避免数据泄露。通过数据安全规范和数据敏感性的宣导，加强业务同学的数据安全意识，业务没有严重数据安全问题的发生。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;运营效率&lt;/strong&gt;：运营工具化减少了研发同学超过60%的日常答疑时间，极大地减少了研发同学工作被打扰的次数，提高了开发效率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、未来规划&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据治理分为三个大阶段：被动治理、主动治理、自动治理。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4414945919370698&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUK4CicDkapoJgwhBsBgQFJa5UyM1lt2hnuFAO2VjlCxy0BjY5s5q8AdYqbIqTIQofA2Olpciccic0og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1017&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一阶段我们做的是&lt;strong&gt;被动治理&lt;/strong&gt;，也就是阶段性治理，确少统筹考虑，主要是基于单个问题的治理，而且治理之后过一段时间可能还要做重复治理。这个阶段更多是人治，一个项目成立，协调几个人按照项目制完成，没有体系规划，也没有组织保障。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二阶段是&lt;strong&gt;主动治理&lt;/strong&gt;，有长期的统筹规划，能覆盖到数据生命周期的各个链路，在治理过程中把一些手段和经验流程化、标准化、系统化，长期解决一些数据问题，让数据治理长期可控。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三阶段是&lt;strong&gt;自动治理&lt;/strong&gt;，也是智能治理，在长期规划和数据生命周期各环节链路确定好之后，把已经有的经验、流程和标准做成策略。一旦出现问题，自动监控，通过一些系统化的方式解决。自动治理的第一步还是治理方案的落地和策略化，这非常依赖于元数据，把数据治理各个过程中的一些经验技术都沉淀起来。做完策略沉淀之后做自动化，把策略用工具的方式实现，当系统发现数据有问题时，自动就去处理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前，美团酒旅业务数据治理处在第二阶段和第三阶段之间，虽然有整体治理计划、技术架构和组织保障，但仍需要投入一定的人力去做。未来，数据治理会继续朝着智能化的方向进行探索，真正把自动化治理工作做得更好。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、作者简介&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;建舒，2015年加入美团，数据科学与平台部数据工程师。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;王磊，2017年加入美团，数据科学与平台部数据工程师。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;罗茜，2017年加入美团，数据科学与平台部数据产品经理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>