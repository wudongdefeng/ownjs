<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0e89018b092e8344c4b7d4d126f2eb3b</guid>
<title>你也能成为“黑客”高手——趣谈 Linux Shell 编程语言</title>
<link>https://toutiao.io/k/yjp4mey</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：京东零售 杜兴文&lt;/p&gt;

&lt;p&gt;我们看过很多在电脑命令行敲一些命令并给观众展示很高科技的画面感的电影，比如《盗梦空间》《操作系统革命》《代码》等等，&lt;/p&gt;

&lt;p&gt;再想想电影黑客帝国中的画面，估计会令很多人都叹为观止，其实挺简单的，只要会使用Linux操作系统就可以很简单地实现电脑屏幕的字符串雨了！是不是很高大上呢！&lt;/p&gt;

&lt;p&gt;同时Linux系统的其他几个操作指令，都有十分酷炫的效果，绝对令人叹为观止，废话不多说，直接进入主题！&lt;/p&gt;

&lt;p&gt;下面不妨逐一介绍这10个Linux比较有趣的命令。&lt;/p&gt;

&lt;p&gt;1、1.cmatrix命令&lt;/p&gt;

&lt;p&gt;接下来就是见证奇迹的时刻：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/3bbc9e4b70794f62a00aad14be75aae6%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=g9cBycw3Iy3KgoMcx3TU%2BKEeEwk%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、htop命令&lt;/p&gt;

&lt;p&gt;htop是Linux操作系统的图形化性能检测工具，如果类比的话相当于windows操作系统的任务管理器&lt;/p&gt;

&lt;p&gt;运行出来的结果是绿色的界面，同时动态的检测显示，下面看看是不是很酷的样子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/d690b0dff9ff4c40ad8ce637e069d1aa%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=Rv2Mude7iZnCQPilTkKon7ePOR0%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、hollywood命令&lt;/p&gt;

&lt;p&gt;说实话这个命令可能就是抖音里很火的那个，你眼中的程序猿VS现实中的程序猿：&lt;/p&gt;

&lt;p&gt;执行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/852424cdd9d14ea6a255bb38832ed811%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=3UevhN2WcXHUHCkka4zxyTMpH6I%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、aafire&lt;/p&gt;

&lt;p&gt;aafire终端命令可以将字符串像火焰一样的燃烧的输出&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/1b07c0f5c8844723a9e7aad1caeb9b7d%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=EnJfAV0UT4Lp%2FWIx9JwhQ9x%2BioA%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5、bastet命令&lt;/p&gt;

&lt;p&gt;使用bastet命令可以在Linux系统下玩俄罗斯方块：&lt;/p&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/fa733c6213f449fc990de6605a6b8a1b%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=vjmjvCtGw76f%2By32yFKP4ndamP8%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;6、sl&lt;/p&gt;

&lt;p&gt;运行结果是一辆呼啸而过的火车：&lt;/p&gt;

&lt;p&gt;运性结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/e2082d14501b4c8094b01bc027f51e5b%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=Un53D1yPbWiBFdnAGcqmP%2Fkx3mY%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;7、cowsay命令可以打印出来一头牛，并且可以指定让这头牛说任意的话语，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/34938f49dff841e2afdd8caac1756299%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=fMBzgdoe8RMv%2FjK4kJyPD98cVcU%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;8、fortune&lt;/p&gt;

&lt;p&gt;这是一个比较有趣的功能&lt;/p&gt;

&lt;p&gt;在输入fortune之后，Terminal会输出一句名言，诗句，或一些有趣的话：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/73078f6096e2435bbd73b289d841bc6a%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=5u8i1OypKvmMqkR2hWNOBX9CkPA%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;9、echo “&quot; | boxes -d dog&lt;/p&gt;

&lt;p&gt;输出一条小狗&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/7b8862af87c045e8bfb1f0a100dcc278%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=OOvBBihuONg3Jo0FlFQJD2ylklw%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看到以上使用简单的命令输出可爱的图案，是不是觉得Linux命令功能既强大又好玩！&lt;/p&gt;

&lt;p&gt;另外，我们使用Linux系统基本操作命令来管理操作系统文件、配置环境，排查问题等等也是看着非常高大上的！&lt;/p&gt;

&lt;p&gt;下面是一些基本的操作命令，用熟了操作起来也是很酷的啊！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/56becf7b49d140da9b5ff0d23346a821%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1678668722&amp;amp;x-signature=ndtUAw7euPUY4u7FGwwfFlQm19s%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e2235b2e708d6955b6fdb537037cae34</guid>
<title>面试官：web 实时推送消息，有哪些方案？</title>
<link>https://toutiao.io/k/y66h60p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;大家好，我是君哥。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我有一个朋友～&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做了一个小破站，现在要实现一个站内信web消息推送的功能，对，就是下图这个小红点，一个很常用的功能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08426270136307311&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSibqlHGN5Qicqj3F2p4MeqIw7tYdzic8cuicibrjF20Tm1ZzZiaOkF1I79RHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;807&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过他还没想好用什么方式做，这里我帮他整理了一下几种方案，并简单做了实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6847946725860156&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSiaAu7jichUzILqRym4eQLia8et2DUSGsF4KUgcTSGOgp6Ysj7y5mCKmrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;901&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是消息推送（push）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息推送(&lt;code&gt;push&lt;/code&gt;)通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备APP进行的主动消息推送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息推送一般又分为&lt;code&gt;web端消息推送&lt;/code&gt;和&lt;code&gt;移动端消息推送&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3170940170940171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSOj5s7qmxYIQzsVhUC880L0rQ10kRnicamw1K8kM1Nk3Uvt1du6wRS5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的这种属于移动端消息推送，web端消息推送常见的诸如站内信、未读邮件数量、监控报警数量等，应用的也非常广泛。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2620320855614973&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSfvGO7yweiaM1w7hsCVqE1ncKlwRib2LCy8FC8KztefosDiap30yIQ0RMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1122&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，只要触发某个事件（主动分享了资源或者后台主动推送消息），web页面的通知小红点就会实时的&lt;code&gt;+1&lt;/code&gt;就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42444444444444446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSia0ibhpec9FQ9ibMSw4uibQBibfECW8RBWiaaykIeRGw5UeoRXPcySy8hU3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息推送无非是推（&lt;code&gt;push&lt;/code&gt;）和拉（&lt;code&gt;pull&lt;/code&gt;）两种形式，下边我们逐个了解下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;短轮询&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轮询(&lt;code&gt;polling&lt;/code&gt;)应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为&lt;code&gt;短轮询&lt;/code&gt;和&lt;code&gt;长轮询&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;短轮询很好理解，指定的时间间隔，由浏览器向服务器发出&lt;code&gt;HTTP&lt;/code&gt;请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单的JS定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;setInterval(() =&amp;gt; {&lt;br/&gt;  // 方法请求&lt;br/&gt;  messageCount().&lt;span&gt;then&lt;/span&gt;((res) =&amp;gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (res.code === 200) {&lt;br/&gt;          this.messageCount = res.data&lt;br/&gt;      }&lt;br/&gt;  })&lt;br/&gt;}, 1000);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7565011820330969&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSj5ibCJZ7QSJl1ew8wseq5FQRt1icOHiawzKmM11suvkzxOreib8tesG52w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;846&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;长轮询&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如&lt;code&gt;Nacos&lt;/code&gt;和&lt;code&gt;apollo&lt;/code&gt;配置中心，消息队列&lt;code&gt;kafka&lt;/code&gt;、&lt;code&gt;RocketMQ&lt;/code&gt;中都有用到长轮询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNTM4NzAyNg==&amp;amp;mid=2247494748&amp;amp;idx=1&amp;amp;sn=2cccdbc6269ea01e75012340af1496ef&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Nacos配置中心交互模型是push还是pull？&lt;/a&gt;一文中我详细介绍过&lt;code&gt;Nacos&lt;/code&gt;长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我使用&lt;code&gt;apollo&lt;/code&gt;配置中心实现长轮询的方式，应用了一个类&lt;code&gt;DeferredResult&lt;/code&gt;，它是在&lt;code&gt;servelet3.0&lt;/code&gt;后经过Spring封装提供的一种异步请求机制，直意就是延迟结果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5174193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLShESibst1xEBuynGicCSDCFaMIUZBJy6AQMnIMJmxH16W8pby9Ryhteag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1550&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DeferredResult&lt;/code&gt;可以允许容器线程快速释放占用的资源，不阻塞请求线程，以此接受更多的请求提升系统的吞吐量，然后启动异步工作线程处理真正的业务逻辑，处理完成调用&lt;code&gt;DeferredResult.setResult(200)&lt;/code&gt;提交响应结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下边我们用长轮询来实现消息推送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为一个ID可能会被多个长轮询请求监听，所以我采用了&lt;code&gt;guava&lt;/code&gt;包提供的&lt;code&gt;Multimap&lt;/code&gt;结构存放长轮询，一个key可以对应多个value。一旦监听到key发生变化，对应的所有长轮询都会响应。前端得到非请求超时的状态码，知晓数据变更，主动查询未读消息数接口，更新页面数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Controller&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/polling&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PollingController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 存放监听某个Id的长轮询集合&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 线程同步结构&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Multimap&amp;lt;String, DeferredResult&amp;lt;String&amp;gt;&amp;gt; watchRequests = Multimaps.synchronizedMultimap(HashMultimap.create());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 公众号：程序员小富&lt;br/&gt;     * 设置监听&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(path = &lt;span&gt;&quot;watch/{id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; DeferredResult&amp;lt;String&amp;gt; &lt;span&gt;watch&lt;/span&gt;&lt;span&gt;(@PathVariable String id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 延迟对象设置超时时间&lt;/span&gt;&lt;br/&gt;        DeferredResult&amp;lt;String&amp;gt; deferredResult = &lt;span&gt;new&lt;/span&gt; DeferredResult&amp;lt;&amp;gt;(TIME_OUT);&lt;br/&gt;        &lt;span&gt;// 异步请求完成时移除 key，防止内存溢出&lt;/span&gt;&lt;br/&gt;        deferredResult.onCompletion(() -&amp;gt; {&lt;br/&gt;            watchRequests.remove(id, deferredResult);&lt;br/&gt;        });&lt;br/&gt;        &lt;span&gt;// 注册长轮询请求&lt;/span&gt;&lt;br/&gt;        watchRequests.put(id, deferredResult);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; deferredResult;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 公众号：程序员小富&lt;br/&gt;     * 变更数据&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(path = &lt;span&gt;&quot;publish/{id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;publish&lt;/span&gt;&lt;span&gt;(@PathVariable String id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 数据变更 取出监听ID的所有长轮询请求，并一一响应处理&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (watchRequests.containsKey(id)) {&lt;br/&gt;            Collection&amp;lt;DeferredResult&amp;lt;String&amp;gt;&amp;gt; deferredResults = watchRequests.get(id);&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (DeferredResult&amp;lt;String&amp;gt; deferredResult : deferredResults) {&lt;br/&gt;                deferredResult.setResult(&lt;span&gt;&quot;我更新了&quot;&lt;/span&gt; + &lt;span&gt;new&lt;/span&gt; Date());&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当请求超过设置的超时时间，会抛出&lt;code&gt;AsyncRequestTimeoutException&lt;/code&gt;异常，这里直接用&lt;code&gt;@ControllerAdvice&lt;/code&gt;全局捕获统一返回即可，前端获取约定好的状态码后再次发起长轮询请求，如此往复调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@ControllerAdvice&lt;br/&gt;public class AsyncRequestTimeoutHandler {&lt;br/&gt;&lt;br/&gt;    @ResponseStatus(HttpStatus.NOT_MODIFIED)&lt;br/&gt;    @ResponseBody&lt;br/&gt;    @ExceptionHandler(AsyncRequestTimeoutException.class)&lt;br/&gt;    public String asyncRequestTimeoutHandler(AsyncRequestTimeoutException e) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;异步请求超时&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;304&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来测试一下，首先页面发起长轮询请求&lt;code&gt;/polling/watch/10086&lt;/code&gt;监听消息更变，请求被挂起，不变更数据直至超时，再次发起了长轮询请求；紧接着手动变更数据&lt;code&gt;/polling/publish/10086&lt;/code&gt;，长轮询得到响应，前端处理业务逻辑完成后再次发起请求，如此循环往复。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5844255975327679&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLS37z8ib4hPjQutH4jv0hzY2VibR4YYqgjT5lJTrNmI4T3KibEiaOfBZSq2A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1297&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;长轮询相比于短轮询在性能上提升了很多，但依然会产生较多的请求，这是它的一点不完美的地方。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;iframe流&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;iframe流就是在页面中插入一个隐藏的&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;标签，通过在&lt;code&gt;src&lt;/code&gt;中请求消息数量API接口，由此在服务端和客户端之间创建一条长连接，服务端持续向&lt;code&gt;iframe&lt;/code&gt;传输数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;传输的数据通常是&lt;code&gt;HTML&lt;/code&gt;、或是内嵌的&lt;code&gt;javascript&lt;/code&gt;脚本，来达到实时更新页面的效果。&lt;/p&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.531317494600432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSNmFzSyv1LDCWaTDgTvUlsHhPEXtIMxJ1hiaaGkKBZA6R3Kje2xYo6fg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式实现简单，前端只要一个&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;标签搞定了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;iframe src=&lt;span&gt;&quot;/iframe/message&quot;&lt;/span&gt; style=&lt;span&gt;&quot;display:none&quot;&lt;/span&gt;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端直接组装html、js脚本数据向&lt;code&gt;response&lt;/code&gt;写入就行了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Controller&lt;br/&gt;@RequestMapping(&lt;span&gt;&quot;/iframe&quot;&lt;/span&gt;)&lt;br/&gt;public class IframeController {&lt;br/&gt;    @GetMapping(path = &lt;span&gt;&quot;message&quot;&lt;/span&gt;)&lt;br/&gt;    public void message(HttpServletResponse response) throws IOException, InterruptedException {&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            response.setHeader(&lt;span&gt;&quot;Pragma&quot;&lt;/span&gt;, &lt;span&gt;&quot;no-cache&quot;&lt;/span&gt;);&lt;br/&gt;            response.setDateHeader(&lt;span&gt;&quot;Expires&quot;&lt;/span&gt;, 0);&lt;br/&gt;            response.setHeader(&lt;span&gt;&quot;Cache-Control&quot;&lt;/span&gt;, &lt;span&gt;&quot;no-cache,no-store&quot;&lt;/span&gt;);&lt;br/&gt;            response.setStatus(HttpServletResponse.SC_OK);&lt;br/&gt;            response.getWriter().&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot; &amp;lt;script type=\&quot;text/javascript\&quot;&amp;gt;\n&quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;parent.document.getElementById(&#x27;clock&#x27;).innerHTML = \&quot;&quot;&lt;/span&gt; + count.get() + &lt;span&gt;&quot;\&quot;;&quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;parent.document.getElementById(&#x27;count&#x27;).innerHTML = \&quot;&quot;&lt;/span&gt; + count.get() + &lt;span&gt;&quot;\&quot;;&quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;&amp;lt;/script&amp;gt;&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我个人不推荐，因为它在浏览器上会显示请求未加载完，图标会不停旋转，简直是强迫症杀手。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6464088397790055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSbFJRZklR7icKUI8tCIodXcNBibqRy41hcia42yIwtuvCsqISxDGjh1I0Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;362&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SSE (我的方式)&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人可能不知道，服务端向客户端推送消息，其实除了可以用&lt;code&gt;WebSocket&lt;/code&gt;这种耳熟能详的机制外，还有一种服务器发送事件(&lt;code&gt;Server-sent events&lt;/code&gt;)，简称&lt;code&gt;SSE&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SSE&lt;/code&gt;它是基于&lt;code&gt;HTTP&lt;/code&gt;协议的，我们知道一般意义上的HTTP协议是无法做到服务端主动向客户端推送消息的，但SSE是个例外，它变换了一种思路。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42857142857142855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSDAUZjvsvST8wO356lbp8NiaeMhoIqvoO8e6vL4uHU4RMficwBPSn1wwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SSE在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是&lt;code&gt;text/event-stream&lt;/code&gt;类型的数据流信息，在有数据变更时从服务器流式传输到客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5182795698924731&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSHpEjFU6Qmt0LOV1SHawOc3rawPDxxZjVxNibiaUQ9fb7TTb5ZGyMXHwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1395&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SSE&lt;/code&gt;与&lt;code&gt;WebSocket&lt;/code&gt;作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;SSE 是基于HTTP协议的，它们不需要特殊的协议或服务器实现即可工作；&lt;code&gt;WebSocket&lt;/code&gt;需单独服务器来处理协议。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SSE 单向通信，只能由服务端向客户端单向通信；webSocket全双工通信，即通信的双方可以同时发送和接受信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SSE 实现简单开发成本低，无需引入其他组件；WebSocket传输数据需做二次解析，开发门槛高一些。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SSE 默认支持断线重连；WebSocket则需要自己实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket默认支持传送二进制数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SSE 与 WebSocket 该如何选择？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;技术并没有好坏之分，只有哪个更合适&lt;/p&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SSE好像一直不被大家所熟知，一部分原因是出现了WebSockets，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，&lt;code&gt;SEE&lt;/code&gt;不管是从实现的难易和成本上都更加有优势。此外，SSE 具有&lt;code&gt;WebSockets&lt;/code&gt;在设计上缺乏的多种功能，例如：&lt;code&gt;自动重新连接&lt;/code&gt;、&lt;code&gt;事件ID&lt;/code&gt;和&lt;code&gt;发送任意事件&lt;/code&gt;的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端只需进行一次HTTP请求，带上唯一ID，打开事件流，监听服务端推送的事件就可以了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; source = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; userId = &lt;span&gt;7777&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;window&lt;/span&gt;.EventSource) {&lt;br/&gt;        &lt;span&gt;// 建立连接&lt;/span&gt;&lt;br/&gt;        source = &lt;span&gt;new&lt;/span&gt; EventSource(&lt;span&gt;&#x27;http://localhost:7777/sse/sub/&#x27;&lt;/span&gt;+userId);&lt;br/&gt;        setMessageInnerHTML(&lt;span&gt;&quot;连接用户=&quot;&lt;/span&gt; + userId);&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * 连接一旦建立，就会触发open事件&lt;br/&gt;         * 另一种写法：source.onopen = function (event) {}&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        source.addEventListener(&lt;span&gt;&#x27;open&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;            setMessageInnerHTML(&lt;span&gt;&quot;建立连接。。。&quot;&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * 客户端收到服务器发来的数据&lt;br/&gt;         * 另一种写法：source.onmessage = function (event) {}&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        source.addEventListener(&lt;span&gt;&#x27;message&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;            setMessageInnerHTML(e.data);&lt;br/&gt;        });&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        setMessageInnerHTML(&lt;span&gt;&quot;你的浏览器不支持SSE&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&amp;lt;&lt;span&gt;/script&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端的实现更简单，创建一个&lt;code&gt;SseEmitter&lt;/code&gt;对象放入&lt;code&gt;sseEmitterMap&lt;/code&gt;进行管理&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, SseEmitter&amp;gt; sseEmitterMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 创建连接&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt;: 2022/7/12 14:51&lt;br/&gt; * &lt;span&gt;@auther&lt;/span&gt;: 公众号：程序员小富&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SseEmitter &lt;span&gt;connect&lt;/span&gt;&lt;span&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 设置超时时间，0表示不过期。默认30秒&lt;/span&gt;&lt;br/&gt;        SseEmitter sseEmitter = &lt;span&gt;new&lt;/span&gt; SseEmitter(&lt;span&gt;0L&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 注册回调&lt;/span&gt;&lt;br/&gt;        sseEmitter.onCompletion(completionCallBack(userId));&lt;br/&gt;        sseEmitter.onError(errorCallBack(userId));&lt;br/&gt;        sseEmitter.onTimeout(timeoutCallBack(userId));&lt;br/&gt;        sseEmitterMap.put(userId, sseEmitter);&lt;br/&gt;        count.getAndIncrement();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; sseEmitter;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        log.info(&lt;span&gt;&quot;创建新的sse连接异常，当前用户：{}&quot;&lt;/span&gt;, userId);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 给指定用户发送消息&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt;: 2022/7/12 14:51&lt;br/&gt; * &lt;span&gt;@auther&lt;/span&gt;: 公众号：程序员小富&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendMessage&lt;/span&gt;&lt;span&gt;(String userId, String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (sseEmitterMap.containsKey(userId)) {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            sseEmitterMap.get(userId).send(message);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            log.error(&lt;span&gt;&quot;用户[{}]推送异常:{}&quot;&lt;/span&gt;, userId, e.getMessage());&lt;br/&gt;            removeUser(userId);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们模拟服务端推送消息，看下客户端收到了消息，和我们预期的效果一致。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5540958268933539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSDEGw1icFuuzSmKOeaqnvntXibzrbCT0y4LJ5wantI00yRPKCZ41BI1OA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1294&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt; SSE不支持&lt;code&gt;IE&lt;/code&gt;浏览器，对其他主流浏览器兼容性做的还不错。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31432748538011696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSZpKUPKh2CqeNVaG3lD7teeibAG3dWyulZrE7TPrfo2yp9J8Yzx7zLibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MQTT&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是 MQTT协议？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MQTT&lt;/code&gt; 全称(Message Queue Telemetry Transport)：一种基于发布/订阅（&lt;code&gt;publish&lt;/code&gt;/&lt;code&gt;subscribe&lt;/code&gt;）模式的&lt;code&gt;轻量级&lt;/code&gt;通讯协议，通过订阅相应的主题来获取消息，是物联网（&lt;code&gt;Internet of Thing&lt;/code&gt;）中的一个标准传输协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该协议将消息的发布者（&lt;code&gt;publisher&lt;/code&gt;）与订阅者（&lt;code&gt;subscriber&lt;/code&gt;）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的MQ有点类似。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.52734375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSokHnrFibYro6xsia2orma1qI0nkxKTK113ACcBBwfiaGhk1PKfb8VxIPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;TCP&lt;/code&gt;协议位于传输层，&lt;code&gt;MQTT&lt;/code&gt; 协议位于应用层，&lt;code&gt;MQTT&lt;/code&gt; 协议构建于&lt;code&gt;TCP/IP&lt;/code&gt;协议上，也就是说只要支持&lt;code&gt;TCP/IP&lt;/code&gt;协议栈的地方，都可以使用&lt;code&gt;MQTT&lt;/code&gt;协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要用 MQTT协议？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MQTT&lt;/code&gt;协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的 &lt;code&gt;HTTP&lt;/code&gt;协议呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先&lt;code&gt;HTTP&lt;/code&gt;协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合&lt;code&gt;IOT&lt;/code&gt;应用程序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;HTTP&lt;/code&gt;是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通常需要将一条命令或者消息，发送到网络上的所有设备上。&lt;code&gt;HTTP&lt;/code&gt;要实现这样的功能不但很困难，而且成本极高。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的MQTT协议介绍和实践，这里我就不再赘述了，大家可以参考我之前的两篇文章，里边写的也都很详细了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MQTT协议的介绍&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNTM4NzAyNg==&amp;amp;mid=2247486353&amp;amp;idx=1&amp;amp;sn=02371acc8048cb15f29285f0505c4958&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;我也没想到 springboot + rabbitmq 做智能家居，会这么简单&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MQTT实现消息推送&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNTM4NzAyNg==&amp;amp;mid=2247487818&amp;amp;idx=1&amp;amp;sn=19393de4304e1ddd3179d0e45ec16cd7&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;未读消息（小红点），前端 与 RabbitMQ 实时消息推送实践，贼简单~&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Websocket&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;websocket&lt;/code&gt;应该是大家都比较熟悉的一种实现消息推送的方式，上边我们在讲SSE的时候也和websocket进行过比较。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebSocket是一种在&lt;code&gt;TCP&lt;/code&gt;连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7215346534653465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLS88c9RL7cWXDic6oJar1SUlG4jlHibv6q6KW9LrCJWJZJl1GchHDibFDPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;808&quot;/&gt;&lt;figcaption&gt;图片源于网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;springboot整合websocket，先引入&lt;code&gt;websocket&lt;/code&gt;相关的工具包，和SSE相比额外的开发成本。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;!-- 引入websocket --&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;spring-boot-starter-websocket&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端使用&lt;code&gt;@ServerEndpoint&lt;/code&gt;注解标注当前类为一个websocket服务器，客户端可以通过&lt;code&gt;ws://localhost:7777/webSocket/10086&lt;/code&gt;来连接到WebSocket服务器端。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@ServerEndpoint&lt;/span&gt;(&lt;span&gt;&quot;/websocket/{userId}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebSocketServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//与某个客户端的连接会话，需要通过它来给客户端发送数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Session session;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; CopyOnWriteArraySet&amp;lt;WebSocketServer&amp;gt; webSockets = &lt;span&gt;new&lt;/span&gt; CopyOnWriteArraySet&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;// 用来存在线连接数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, Session&amp;gt; sessionPool = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Session&amp;gt;();&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 公众号：程序员小富&lt;br/&gt;     * 链接成功调用的方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnOpen&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onOpen&lt;/span&gt;&lt;span&gt;(Session session, @PathParam(value = &lt;span&gt;&quot;userId&quot;&lt;/span&gt;)&lt;/span&gt; String userId) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.session = session;&lt;br/&gt;            webSockets.add(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;            sessionPool.put(userId, session);&lt;br/&gt;            log.info(&lt;span&gt;&quot;websocket消息: 有新的连接，总数为:&quot;&lt;/span&gt; + webSockets.size());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 公众号：程序员小富&lt;br/&gt;     * 收到客户端消息后调用的方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnMessage&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;websocket消息: 收到客户端消息:&quot;&lt;/span&gt; + message);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 公众号：程序员小富&lt;br/&gt;     * 此为单点消息&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendOneMessage&lt;/span&gt;&lt;span&gt;(String userId, String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Session session = sessionPool.get(userId);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (session != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; session.isOpen()) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                log.info(&lt;span&gt;&quot;websocket消: 单点消息:&quot;&lt;/span&gt; + message);&lt;br/&gt;                session.getAsyncRemote().sendText(message);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端初始化打开WebSocket连接，并监听连接状态，接收服务端数据或向服务端发送数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; ws = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;&#x27;ws://localhost:7777/webSocket/10086&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 获取连接状态&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;ws连接状态：&#x27;&lt;/span&gt; + ws.readyState);&lt;br/&gt;    &lt;span&gt;//监听是否连接成功&lt;/span&gt;&lt;br/&gt;    ws.onopen = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;ws连接状态：&#x27;&lt;/span&gt; + ws.readyState);&lt;br/&gt;        &lt;span&gt;//连接成功则发送一个数据&lt;/span&gt;&lt;br/&gt;        ws.send(&lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 接听服务器发回的信息并处理展示&lt;/span&gt;&lt;br/&gt;    ws.onmessage = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;接收到来自服务器的消息：&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(data);&lt;br/&gt;        &lt;span&gt;//完成通信后关闭WebSocket连接&lt;/span&gt;&lt;br/&gt;        ws.close();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 监听连接关闭事件&lt;/span&gt;&lt;br/&gt;    ws.onclose = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 监听整个过程中websocket的状态&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;ws连接状态：&#x27;&lt;/span&gt; + ws.readyState);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 监听并处理error事件&lt;/span&gt;&lt;br/&gt;    ws.onerror = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;error&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(error);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;sendMessage&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; content = $(&lt;span&gt;&quot;#message&quot;&lt;/span&gt;).val();&lt;br/&gt;        $.ajax({&lt;br/&gt;            &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;/socket/publish?userId=10086&amp;amp;message=&#x27;&lt;/span&gt; + content,&lt;br/&gt;            &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;GET&#x27;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;data&lt;/span&gt;: { &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;&quot;7777&quot;&lt;/span&gt;, &lt;span&gt;&quot;content&quot;&lt;/span&gt;: content },&lt;br/&gt;            &lt;span&gt;success&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;console&lt;/span&gt;.log(data)&lt;br/&gt;            }&lt;br/&gt;        })&lt;br/&gt;    }&lt;br/&gt;&amp;lt;&lt;span&gt;/script&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页面初始化建立websocket连接，之后就可以进行双向通信了，效果还不错&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0943900267141585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSOuI1UOGoaNCC50kjnMjCMP39RndVOJpPfgwwibhCWms4rWHLoXLDlxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1123&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47417840375586856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSxJTIOhIibCdQpreJ7OdEBdIBcWkPnqt376OBeyMKWZmSU7qoaqun3MA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1278&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自定义推送&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边我们给我出了6种方案的原理和代码实现，但在实际业务开发过程中，不能盲目的直接拿过来用，还是要结合自身系统业务的特点和实际场景来选择合适的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推送最直接的方式就是使用第三推送平台，毕竟&lt;strong&gt;钱能解决的需求都不是问题&lt;/strong&gt;，无需复杂的开发运维，直接可以使用，省时、省力、省心，像goEasy、极光推送都是很不错的三方服务商。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般大型公司都有自研的消息推送平台，像我们本次实现的web站内信只是平台上的一个触点而已，短信、邮件、微信公众号、小程序凡是可以触达到用户的渠道都可以接入进来。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35212298682284043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMicdhGlXFlZSP7OJx9BSYLSM5ib73GpHXYicr6xfVIG729eDJWH5TI1EtA89n1iavCVImqs3DjicOGHRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1366&quot;/&gt;&lt;figcaption&gt;图片来源于网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息推送系统内部是相当复杂的，诸如消息内容的维护审核、圈定推送人群、触达过滤拦截（推送的规则频次、时段、数量、黑白名单、关键词等等）、推送失败补偿非常多的模块，技术上涉及到大数据量、高并发的场景也很多。所以我们今天的实现方式在这个庞大的系统面前只是小打小闹。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Github地址&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中所提到的案例我都一一的做了实现，整理放在了&lt;code&gt;Github&lt;/code&gt;上，觉得有用就 &lt;strong&gt;Star&lt;/strong&gt; 一下吧！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;传送门：https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-realtime-data&lt;/p&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>81ba89abf2e4a35418c6b8a12e4cfba7</guid>
<title>携程一面：什么是双亲委派模型？</title>
<link>https://toutiao.io/k/3mwl8tg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;ER15uXTl&quot;&gt;这是携程一面的一个 JVM 面试真题。参加过校招面试的同学，应该对这个问题不陌生。一般提问 JVM 知识点的时候，就会顺带问你双亲委派模型（别扭的翻译。。。）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-45413c6cbe867bc06787902091ba787b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1110&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-45413c6cbe867bc06787902091ba787b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1110&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-45413c6cbe867bc06787902091ba787b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-45413c6cbe867bc06787902091ba787b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;84Pw_WsH&quot;&gt;就算是不准备面试，学习双亲委派模型对于我们也非常有帮助。我们比较熟悉的 Tomcat 服务器为了实现 Web 应用的隔离，就自定义了类加载并打破了双亲委派模型。&lt;/p&gt;&lt;p data-pid=&quot;UXAn0hid&quot;&gt;这篇文章我会先介绍类加载器，再介绍双亲委派模型，这样有助于我们更好地理解。&lt;/p&gt;&lt;p data-pid=&quot;sM7MDxri&quot;&gt;目录概览：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5166b465ebcd6663f97b36d88f4372ba_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;734&quot; data-rawheight=&quot;836&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-5166b465ebcd6663f97b36d88f4372ba_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;734&quot; data-rawheight=&quot;836&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-5166b465ebcd6663f97b36d88f4372ba_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-5166b465ebcd6663f97b36d88f4372ba_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;回顾一下类加载过程&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;pduCa6kV&quot;&gt;开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;IhU7vQE2&quot;&gt;类加载过程：&lt;b&gt;加载-&amp;gt;连接-&amp;gt;初始化&lt;/b&gt;。&lt;/li&gt;&lt;li data-pid=&quot;l-hA88N3&quot;&gt;连接过程又可分为三步：&lt;b&gt;验证-&amp;gt;准备-&amp;gt;解析&lt;/b&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11c3d6f2183018eea985257ebd5115f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;692&quot; data-rawheight=&quot;478&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-11c3d6f2183018eea985257ebd5115f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;692&quot; data-rawheight=&quot;478&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-11c3d6f2183018eea985257ebd5115f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-11c3d6f2183018eea985257ebd5115f4_b.jpg&quot;/&gt;&lt;figcaption&gt;类加载过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;EdqEvZu_&quot;&gt;加载是类加载过程的第一步，主要完成下面 3 件事情：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;xPfV-WxL&quot;&gt;通过全类名获取定义此类的二进制字节流&lt;/li&gt;&lt;li data-pid=&quot;57YwjdoX&quot;&gt;将字节流所代表的静态存储结构转换为方法区的运行时数据结构&lt;/li&gt;&lt;li data-pid=&quot;Ro02g788&quot;&gt;在内存中生成一个代表该类的 &lt;code&gt;Class&lt;/code&gt; 对象，作为方法区这些数据的访问入口&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;类加载器&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;类加载器介绍&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;nR9JW3WI&quot;&gt;类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java Applet（已经被淘汰） 的需要。后来，慢慢成为 Java 程序中的一个重要组成部分，赋予了 Java 类可以被动态加载到 JVM 中并执行的能力。&lt;/p&gt;&lt;p data-pid=&quot;jeFOJdMz&quot;&gt;根据官方 API 文档的介绍：&lt;/p&gt;&lt;blockquote data-pid=&quot;QYUI7Qvz&quot;&gt; A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a &quot;class file&quot; of that name from a file system.&lt;br/&gt; Every Class object contains a reference to the ClassLoader that defined it.&lt;br/&gt; Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;nBKoIASj&quot;&gt;翻译过来大概的意思是：&lt;/p&gt;&lt;blockquote data-pid=&quot;gNNF-KQO&quot;&gt; 类加载器是一个负责加载类的对象。&lt;code&gt;ClassLoader&lt;/code&gt; 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。&lt;br/&gt; 每个 Java 类都有一个引用指向加载它的 &lt;code&gt;ClassLoader&lt;/code&gt;。不过，数组类不是通过 &lt;code&gt;ClassLoader&lt;/code&gt; 创建的，而是 JVM 在需要的时候自动创建的，数组类通过&lt;code&gt;getClassLoader()&lt;/code&gt;方法获取 &lt;code&gt;ClassLoader&lt;/code&gt; 的时候和该数组的元素类型的 &lt;code&gt;ClassLoader&lt;/code&gt; 是一致的。&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;WirC1FB7&quot;&gt;从上面的介绍可以看出:&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;zG7oIeMq&quot;&gt;类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。&lt;/li&gt;&lt;li data-pid=&quot;eHGx5_2a&quot;&gt;每个 Java 类都有一个引用指向加载它的 &lt;code&gt;ClassLoader&lt;/code&gt;。&lt;/li&gt;&lt;li data-pid=&quot;NDpl82wv&quot;&gt;数组类不是通过 &lt;code&gt;ClassLoader&lt;/code&gt; 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@CallerSensitive&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;3o_cALDx&quot;&gt;简单来说，&lt;b&gt;类加载器的主要作用就是加载 Java 类的字节码（ &lt;code&gt;.class&lt;/code&gt; 文件）到 JVM 中（在内存中生成一个代表该类的 &lt;code&gt;Class&lt;/code&gt; 对象）。&lt;/b&gt; 字节码可以是 Java 源程序（&lt;code&gt;.java&lt;/code&gt;文件）经过 &lt;code&gt;javac&lt;/code&gt; 编译得来，也可以是通过工具动态生成或者通过网络下载得来。&lt;/p&gt;&lt;p data-pid=&quot;A1aBH73s&quot;&gt;其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。本文只讨论其核心功能：加载类。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;类加载器加载规则&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;V1qahZQH&quot;&gt;JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。&lt;/p&gt;&lt;p data-pid=&quot;iPNYdx5g&quot;&gt;对于已经加载的类会被放在 &lt;code&gt;ClassLoader&lt;/code&gt; 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 由这个类加载器加载的类。
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 由VM调用，用此类加载器记录每个已加载类。
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;classes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;类加载器总结&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;cY2gy7yi&quot;&gt;JVM 中内置了三个重要的 &lt;code&gt;ClassLoader&lt;/code&gt;：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;CbW_wt9p&quot;&gt;&lt;b&gt;&lt;code&gt;BootstrapClassLoader&lt;/code&gt;(启动类加载器)&lt;/b&gt; ：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ &lt;code&gt;%JAVA_HOME%/lib&lt;/code&gt;目录下的 &lt;code&gt;rt.jar&lt;/code&gt; 、&lt;code&gt;resources.jar&lt;/code&gt; 、&lt;code&gt;charsets.jar&lt;/code&gt;等 jar 包和类）以及被 &lt;code&gt;-Xbootclasspath&lt;/code&gt;参数指定的路径下的所有类。&lt;/li&gt;&lt;li data-pid=&quot;DJ7MC_04&quot;&gt;&lt;b&gt;&lt;code&gt;ExtensionClassLoader&lt;/code&gt;(扩展类加载器)&lt;/b&gt; ：主要负责加载 &lt;code&gt;%JRE_HOME%/lib/ext&lt;/code&gt; 目录下的 jar 包和类以及被 &lt;code&gt;java.ext.dirs&lt;/code&gt; 系统变量所指定的路径下的所有类。&lt;/li&gt;&lt;li data-pid=&quot;rDMDXAHv&quot;&gt;&lt;b&gt;&lt;code&gt;AppClassLoader&lt;/code&gt;(应用程序类加载器)&lt;/b&gt; ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-pid=&quot;zzvDSTGv&quot;&gt;   拓展一下：&lt;br/&gt; &lt;/blockquote&gt;&lt;ul&gt;&lt;li data-pid=&quot;_buJ5mJl&quot;&gt;&lt;b&gt;&lt;code&gt;rt.jar&lt;/code&gt;&lt;/b&gt; ： rt 代表“RunTime”，&lt;code&gt;rt.jar&lt;/code&gt;是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 &lt;code&gt;java.xxx.*&lt;/code&gt;都在里面，比如&lt;code&gt;java.util.*&lt;/code&gt;、&lt;code&gt;java.io.*&lt;/code&gt;、&lt;code&gt;java.nio.*&lt;/code&gt;、&lt;code&gt;java.lang.*&lt;/code&gt;、&lt;code&gt;java.sql.*&lt;/code&gt;、&lt;code&gt;java.math.*&lt;/code&gt;。&lt;/li&gt;&lt;li data-pid=&quot;KfOmQ4Qu&quot;&gt;Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 &lt;code&gt;java.base&lt;/code&gt; 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;x3jmiQTr&quot;&gt;除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ &lt;code&gt;.class&lt;/code&gt; 文件）进行加密，加载时再利用自定义的类加载器对其解密。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;771&quot; data-rawheight=&quot;761&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;771&quot; data-rawheight=&quot;761&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_b.jpg&quot;/&gt;&lt;figcaption&gt;类加载器层次关系图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;WPoIpJbY&quot;&gt;除了 &lt;code&gt;BootstrapClassLoader&lt;/code&gt; 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 &lt;code&gt;ClassLoader&lt;/code&gt;抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。&lt;/p&gt;&lt;p data-pid=&quot;wTwnY9Bi&quot;&gt;每个 &lt;code&gt;ClassLoader&lt;/code&gt; 可以通过&lt;code&gt;getParent()&lt;/code&gt;获取其父 &lt;code&gt;ClassLoader&lt;/code&gt;，如果获取到 &lt;code&gt;ClassLoader&lt;/code&gt; 为&lt;code&gt;null&lt;/code&gt;的话，那么该类是通过 &lt;code&gt;BootstrapClassLoader&lt;/code&gt; 加载的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 父加载器
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@CallerSensitive&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;vXoNzzAq&quot;&gt;&lt;b&gt;为什么 获取到 &lt;code&gt;ClassLoader&lt;/code&gt; 为&lt;code&gt;null&lt;/code&gt;就是 &lt;code&gt;BootstrapClassLoader&lt;/code&gt; 加载的呢？&lt;/b&gt; 这是因为&lt;code&gt;BootstrapClassLoader&lt;/code&gt; 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。&lt;/p&gt;&lt;p data-pid=&quot;8Ilf_5_U&quot;&gt;下面我们来看一个获取 &lt;code&gt;ClassLoader&lt;/code&gt; 的小案例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PrintClassLoaderTree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintClassLoaderTree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;|--&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;needContinue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;needContinue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;needContinue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;classLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;\t&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;G1KG-MMn&quot;&gt;输出结果(JDK 8 )：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;|--sun.misc.Launcher$AppClassLoader@18b4aac2
    |--sun.misc.Launcher$ExtClassLoader@53bd815b
        |--null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;8iwMG9MO&quot;&gt;从输出结果可以看出：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;zVMDgdYU&quot;&gt;我们编写的 Java 类 &lt;code&gt;PrintClassLoaderTree&lt;/code&gt; 的 &lt;code&gt;ClassLoader&lt;/code&gt; 是&lt;code&gt;AppClassLoader&lt;/code&gt;；&lt;/li&gt;&lt;li data-pid=&quot;tB1UiCaW&quot;&gt;&lt;code&gt;AppClassLoader&lt;/code&gt;的父 &lt;code&gt;ClassLoader&lt;/code&gt; 是&lt;code&gt;ExtClassLoader&lt;/code&gt;；&lt;/li&gt;&lt;li data-pid=&quot;uu1Lg2-X&quot;&gt;&lt;code&gt;ExtClassLoader&lt;/code&gt;的父&lt;code&gt;ClassLoader&lt;/code&gt;是&lt;code&gt;Bootstrap ClassLoader&lt;/code&gt;，因此输出结果为 null。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;自定义类加载器&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;JuOHQLyY&quot;&gt;我们前面也说说了，除了 &lt;code&gt;BootstrapClassLoader&lt;/code&gt; 其他类加载器均由 Java 实现且全部继承自&lt;code&gt;java.lang.ClassLoader&lt;/code&gt;。如果我们要自定义自己的类加载器，很明显需要继承 &lt;code&gt;ClassLoader&lt;/code&gt;抽象类。&lt;/p&gt;&lt;p data-pid=&quot;FQXWsr8W&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt; 类有两个关键的方法：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;DBrsfRNp&quot;&gt;&lt;code&gt;protected Class loadClass(String name, boolean resolve)&lt;/code&gt;：加载指定二进制名称的类，实现了双亲委派机制 。&lt;code&gt;name&lt;/code&gt; 为类的二进制名称，&lt;code&gt;resove&lt;/code&gt; 如果为 true，在加载时调用 &lt;code&gt;resolveClass(Class&amp;lt;?&amp;gt; c)&lt;/code&gt; 方法解析该类。&lt;/li&gt;&lt;li data-pid=&quot;JPPipHLG&quot;&gt;&lt;code&gt;protected Class findClass(String name)&lt;/code&gt;：根据类的二进制名称来查找类，默认实现是空方法。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;ruM3QNoV&quot;&gt;官方 API 文档中写到：&lt;/p&gt;&lt;blockquote data-pid=&quot;Rbvb-2nM&quot;&gt; Subclasses of &lt;code&gt;ClassLoader&lt;/code&gt; are encouraged to override &lt;code&gt;findClass(String name)&lt;/code&gt;, rather than this method.&lt;br/&gt; 建议 &lt;code&gt;ClassLoader&lt;/code&gt;的子类重写 &lt;code&gt;findClass(String name)&lt;/code&gt;方法而不是&lt;code&gt;loadClass(String name, boolean resolve)&lt;/code&gt; 方法。&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;ktWytO3o&quot;&gt;如果我们不想打破双亲委派模型，就重写 &lt;code&gt;ClassLoader&lt;/code&gt; 类中的 &lt;code&gt;findClass()&lt;/code&gt; 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 &lt;code&gt;loadClass()&lt;/code&gt; 方法。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;双亲委派模型&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;双亲委派模型介绍&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;wdjBSwzs&quot;&gt;类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。&lt;/p&gt;&lt;p data-pid=&quot;mzzJ7Kja&quot;&gt;根据官网介绍：&lt;/p&gt;&lt;blockquote data-pid=&quot;iko4JBVD&quot;&gt; The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine&#x27;s built-in class loader, called the &quot;bootstrap class loader&quot;, does not itself have a parent but may serve as the parent of a ClassLoader instance.&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;y5A-pVvY&quot;&gt;翻译过来大概的意思是：&lt;/p&gt;&lt;blockquote data-pid=&quot;t0BAtGK8&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt; 类使用委托模型来搜索类和资源。每个 &lt;code&gt;ClassLoader&lt;/code&gt; 实例都有一个相关的父类加载器。需要查找类或资源时，&lt;code&gt;ClassLoader&lt;/code&gt; 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。 虚拟机中被称为 &quot;bootstrap class loader&quot;的内置类加载器本身没有父类加载器，但是可以作为 &lt;code&gt;ClassLoader&lt;/code&gt; 实例的父类加载器。&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;Q9SyrJN3&quot;&gt;从上面的介绍可以看出：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;NbqWSVqc&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt; 类使用委托模型来搜索类和资源。&lt;/li&gt;&lt;li data-pid=&quot;1E6oIVo8&quot;&gt;双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。&lt;/li&gt;&lt;li data-pid=&quot;wD3mKZk7&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt; 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;9HFhpeE0&quot;&gt;下图展示的各种类加载器之间的层次关系被称为类加载器的“**双亲委派模型(Parents Delegation Model)**”。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;771&quot; data-rawheight=&quot;761&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;771&quot; data-rawheight=&quot;761&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f44cf4aa9692500d56ddda14862b4804_b.jpg&quot;/&gt;&lt;figcaption&gt;类加载器层次关系图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;gwgFQefY&quot;&gt;注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。&lt;/p&gt;&lt;p data-pid=&quot;-qhIRfkf&quot;&gt;其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 &lt;code&gt;MotherClassLoader&lt;/code&gt; 和一个&lt;code&gt;FatherClassLoader&lt;/code&gt; 。个人觉得翻译成单亲委派模型更好一些，不过，国内既然翻译成了双亲委派模型并流传了，按照这个来也没问题，不要被误解了就好。&lt;/p&gt;&lt;p data-pid=&quot;ZqdedT9x&quot;&gt;另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 组合
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checkCreateClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;eC9LUZ4d&quot;&gt;在面向对象编程中，有一条非常经典的设计原则： &lt;b&gt;组合优于继承，多用组合少用继承。&lt;/b&gt;&lt;/p&gt;&lt;h3&gt;&lt;b&gt;双亲委派模型的执行流程&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;HNs7UyF-&quot;&gt;双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 &lt;code&gt;java.lang.ClassLoader&lt;/code&gt; 的 &lt;code&gt;loadClass()&lt;/code&gt; 中，相关代码如下所示。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loadClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassNotFoundException&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getClassLoadingLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//首先，检查该类是否已经加载过
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findLoadedClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//如果 c 为 null，则说明该类没有被加载过
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;            &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;//当父类的加载器不为空，则通过父类的loadClass来加载该类
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;                    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loadClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;//当父类的加载器为空，则调用启动类加载器来加载该类
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;                    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findBootstrapClassOrNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//非空父类的类加载器无法找到相应的类，则抛出异常
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//当父类加载器无法加载时，则调用findClass方法来加载该类
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;                &lt;span class=&quot;c1&quot;&gt;//用户可通过覆写该方法，来自定义类加载器
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;                &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

                &lt;span class=&quot;c1&quot;&gt;//用于统计类加载器相关的信息
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;                &lt;span class=&quot;n&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;misc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PerfCounter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParentDelegationTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;misc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PerfCounter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFindClassTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addElapsedTimeFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;misc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PerfCounter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFindClasses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;increment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//对类进行link操作
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;            &lt;span class=&quot;n&quot;&gt;resolveClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;SsNAhnNi&quot;&gt;每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。&lt;/p&gt;&lt;p data-pid=&quot;ydNYR2Di&quot;&gt;结合上面的源码，简单总结一下双亲委派模型的执行流程：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;DpOkRwS_&quot;&gt;在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。&lt;/li&gt;&lt;li data-pid=&quot;jPg7PnrC&quot;&gt;类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 &lt;code&gt;loadClass()&lt;/code&gt;方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 &lt;code&gt;BootstrapClassLoader&lt;/code&gt; 中。&lt;/li&gt;&lt;li data-pid=&quot;xG48Mxz0&quot;&gt;只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 &lt;code&gt;findClass()&lt;/code&gt; 方法来加载类）。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;z-z7OZFW&quot;&gt;  拓展一下：&lt;/p&gt;&lt;p data-pid=&quot;GvUW37fF&quot;&gt;&lt;b&gt;JVM 判定两个 Java 类是否相同的具体规则&lt;/b&gt; ：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 &lt;code&gt;Class&lt;/code&gt; 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;双亲委派模型的好处&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;ecw0to9n&quot;&gt;双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。&lt;/p&gt;&lt;p data-pid=&quot;M_3qcGWE&quot;&gt;如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 &lt;code&gt;java.lang.Object&lt;/code&gt; 类的话，那么程序运行的时候，系统就会出现两个不同的 &lt;code&gt;Object&lt;/code&gt; 类。双亲委派模型可以保证加载的是 JRE 里的那个 &lt;code&gt;Object&lt;/code&gt; 类，而不是你写的 &lt;code&gt;Object&lt;/code&gt; 类。这是因为 &lt;code&gt;AppClassLoader&lt;/code&gt; 在加载你的 &lt;code&gt;Object&lt;/code&gt; 类时，会委托给 &lt;code&gt;ExtClassLoader&lt;/code&gt; 去加载，而 &lt;code&gt;ExtClassLoader&lt;/code&gt; 又会委托给 &lt;code&gt;BootstrapClassLoader&lt;/code&gt;，&lt;code&gt;BootstrapClassLoader&lt;/code&gt; 发现自己已经加载过了 &lt;code&gt;Object&lt;/code&gt; 类，会直接返回，不会去加载你写的 &lt;code&gt;Object&lt;/code&gt; 类。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;打破双亲委派模型方法&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;UynNrRDZ&quot;&gt;为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 &lt;code&gt;loadClass()&lt;/code&gt; 即可。&lt;/p&gt;&lt;p data-pid=&quot;_Rale3jS&quot;&gt;&lt;b&gt;  修正（参见：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Snailclimb/JavaGuide/issues/871&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;issue871&lt;/a&gt; ）&lt;/b&gt; ：自定义加载器的话，需要继承 &lt;code&gt;ClassLoader&lt;/code&gt; 。如果我们不想打破双亲委派模型，就重写 &lt;code&gt;ClassLoader&lt;/code&gt; 类中的 &lt;code&gt;findClass()&lt;/code&gt; 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 &lt;code&gt;loadClass()&lt;/code&gt; 方法。&lt;/p&gt;&lt;p data-pid=&quot;SmNCVxDK&quot;&gt;为什么是重写 &lt;code&gt;loadClass()&lt;/code&gt; 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：&lt;/p&gt;&lt;blockquote data-pid=&quot;EH1TVBsv&quot;&gt; 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 &lt;code&gt;loadClass()&lt;/code&gt;方法来加载类）。&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;IVBr8j7H&quot;&gt;我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 &lt;code&gt;WebAppClassLoader&lt;/code&gt; 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。&lt;/p&gt;&lt;p data-pid=&quot;Y5fbhbQY&quot;&gt;Tomcat 的类加载器的层次结构如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-153968e5cf17c27b8787a2d211466f12_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;471&quot; data-rawheight=&quot;901&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-153968e5cf17c27b8787a2d211466f12_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;471&quot; data-rawheight=&quot;901&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-153968e5cf17c27b8787a2d211466f12_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-153968e5cf17c27b8787a2d211466f12_b.jpg&quot;/&gt;&lt;figcaption&gt;Tomcat 的类加载器的层次结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;xnpEk7f4&quot;&gt;感兴趣的小伙伴可以自行研究一下 Tomcat 类加载器的层次结构，这有助于我们搞懂 Tomcat 隔离 Web 应用的原理，推荐资料是&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//gk.link/a/10Egr&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入拆解 Tomcat &amp;amp; Jetty》&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;推荐阅读&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;更多面试题总结&lt;/h2&gt;&lt;p data-pid=&quot;zXLahUBD&quot;&gt;&lt;b&gt;Java&lt;/b&gt; ：&lt;/p&gt;&lt;p data-pid=&quot;z0ueBacI&quot;&gt;&lt;b&gt;计算机基础&lt;/b&gt; ：&lt;/p&gt;&lt;p data-pid=&quot;OMt3t-Gz&quot;&gt;&lt;b&gt;数据库&lt;/b&gt; ：&lt;/p&gt;&lt;p data-pid=&quot;anSVZTGT&quot;&gt;&lt;b&gt;常用框架&lt;/b&gt; ：&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>08265ad21b7ecc1a31a1472244a90fca</guid>
<title>Gateway 集成 Netty 服务</title>
<link>https://toutiao.io/k/dp0da6k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;Gateway和Netty都有盲区的感觉；&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、Netty简介&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;Netty是一个异步的，事件驱动的网络应用框架，用以快速开发高可靠、高性能的网络应用程序。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6701612903225806&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvA0qw5uGuCVxH7iaHrnpAOuMT4a0W72OwS0JK0w42RicC7ux2xeSyEor32PtVgSgjiaGG2KGYVRElkicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;传输服务&lt;/strong&gt;：提供网络传输能力的管理；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;协议支持&lt;/strong&gt;：支持常见的数据传输协议；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;核心模块&lt;/strong&gt;：包括可扩展事件模型、通用的通信API、零拷贝字节缓冲；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、Netty入门案例&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、服务端启动&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;配置Netty服务器端程序，引导相关核心组件的加载；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NettyServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// EventLoop组，处理事件和IO&lt;/span&gt;&lt;br/&gt;        EventLoopGroup parentGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;br/&gt;        EventLoopGroup childGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 服务端启动引导类&lt;/span&gt;&lt;br/&gt;            ServerBootstrap serverBootstrap = &lt;span&gt;new&lt;/span&gt; ServerBootstrap();&lt;br/&gt;            serverBootstrap.group(parentGroup, childGroup)&lt;br/&gt;                    .channel(NioServerSocketChannel&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;childHandler&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;ChannelInit&lt;/span&gt;())&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 异步IO的结果&lt;/span&gt;&lt;br/&gt;            ChannelFuture channelFuture = serverBootstrap.bind(&lt;span&gt;8082&lt;/span&gt;).sync();&lt;br/&gt;            channelFuture.channel().closeFuture().sync();&lt;br/&gt;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e){&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            parentGroup.shutdownGracefully();&lt;br/&gt;            childGroup.shutdownGracefully();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、通道初始化&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ChannelInitializer&lt;/strong&gt;特殊的通道处理器，提供一种简单的方法，对注册到EventLoop的通道进行初始化；比如此处设置的编码解码器，自定义处理器；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChannelInit&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ChannelInitializer&lt;/span&gt;&amp;lt;&lt;span&gt;SocketChannel&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initChannel&lt;/span&gt;&lt;span&gt;(SocketChannel socketChannel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 获取管道&lt;/span&gt;&lt;br/&gt;        ChannelPipeline pipeline = socketChannel.pipeline();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Http编码、解码器&lt;/span&gt;&lt;br/&gt;        pipeline.addLast(&lt;span&gt;&quot;DefHttpServerCodec&quot;&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt; HttpServerCodec());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 添加自定义的handler&lt;/span&gt;&lt;br/&gt;        pipeline.addLast(&lt;span&gt;&quot;DefHttpHandler&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; DefHandler());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3、自定义处理器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;处理对服务器端发起的访问，通常包括请求解析，具体的逻辑执行，请求响应等过程；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefHandler&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SimpleChannelInboundHandler&lt;/span&gt;&amp;lt;&lt;span&gt;HttpObject&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;channelRead0&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx, HttpObject message)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(message &lt;span&gt;instanceof&lt;/span&gt; HttpRequest) {&lt;br/&gt;            &lt;span&gt;// 请求解析&lt;/span&gt;&lt;br/&gt;            HttpRequest httpRequest = (HttpRequest) message;&lt;br/&gt;            String uri = httpRequest.uri();&lt;br/&gt;            String method = httpRequest.method().name();&lt;br/&gt;            log.info(&lt;span&gt;&quot;【HttpRequest-URI:&quot;&lt;/span&gt;+uri+&lt;span&gt;&quot;】&quot;&lt;/span&gt;);&lt;br/&gt;            log.info(&lt;span&gt;&quot;【HttpRequest-method:&quot;&lt;/span&gt;+method+&lt;span&gt;&quot;】&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;            Iterator&amp;lt;Map.Entry&amp;lt;String,String&amp;gt;&amp;gt; iterator = httpRequest.headers().iteratorAsString();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (iterator.hasNext()){&lt;br/&gt;                Map.Entry&amp;lt;String,String&amp;gt; entry = iterator.next();&lt;br/&gt;                log.info(&lt;span&gt;&quot;【Header-Key:&quot;&lt;/span&gt;+entry.getKey()+&lt;span&gt;&quot;;Header-Value:&quot;&lt;/span&gt;+entry.getValue()+&lt;span&gt;&quot;】&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 响应构建&lt;/span&gt;&lt;br/&gt;            ByteBuf content = Unpooled.copiedBuffer(&lt;span&gt;&quot;Netty服务&quot;&lt;/span&gt;, CharsetUtil.UTF_8);&lt;br/&gt;            FullHttpResponse response = &lt;span&gt;new&lt;/span&gt; DefaultFullHttpResponse&lt;br/&gt;                                        (HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);&lt;br/&gt;            response.headers().set(HttpHeaderNames.CONTENT_TYPE, &lt;span&gt;&quot;text/plain;charset=utf-8&quot;&lt;/span&gt;);&lt;br/&gt;            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());&lt;br/&gt;            ctx.writeAndFlush(response);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4、测试请求&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;上面入门案例中，简单的配置了一个Netty服务器端，启动之后在浏览器中模拟访问即可；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;http://127.0.0.1:8082/?id=1&amp;amp;name=Spring&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;三、Gateway集成&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、依赖层级&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;项目中Gateway网关依赖的版本为&lt;code&gt;2.2.5.RELEASE&lt;/code&gt;，发现Netty依赖的版本为&lt;code&gt;4.1.45.Final&lt;/code&gt;，是当下比较主流的版本；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- 1、项目工程依赖 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-gateway&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.2.5.RELEASE&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!-- 2、starter-gateway依赖 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-webflux&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.3.2.RELEASE&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!-- 3、starter-webflux依赖 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-reactor-netty&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.3.2.RELEASE&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、自动化配置&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;在Gateway网关的自动化配置配置类中，提供了Netty配置的管理；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@AutoConfigureBefore&lt;/span&gt;({ HttpHandlerAutoConfiguration&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;span&gt;WebFluxAutoConfiguration&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt; })&lt;br/&gt;@&lt;span&gt;ConditionalOnClass&lt;/span&gt;(&lt;span&gt;DispatcherHandler&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;GatewayAutoConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Configuration&lt;/span&gt;(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@ConditionalOnClass&lt;/span&gt;(HttpClient&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;NettyConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;@ConditionalOnProperty&lt;/span&gt;(name = &lt;span&gt;&quot;spring.cloud.gateway.httpserver.wiretap&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; NettyWebServerFactoryCustomizer &lt;span&gt;nettyServerWiretapCustomizer&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;                Environment environment, ServerProperties serverProperties)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NettyWebServerFactoryCustomizer(environment, serverProperties) {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;customize&lt;/span&gt;&lt;span&gt;(NettyReactiveWebServerFactory factory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    factory.addServerCustomizers(httpServer -&amp;gt; httpServer.wiretap(&lt;span&gt;true&lt;/span&gt;));&lt;br/&gt;                    &lt;span&gt;super&lt;/span&gt;.customize(factory);&lt;br/&gt;                }&lt;br/&gt;            };&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;四、配置加载&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、基础配置&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;在工程的配置文件中，简单做一些基础性的设置；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;server:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8081&lt;/span&gt;                  &lt;span&gt;# 端口号&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;netty:&lt;/span&gt;                      &lt;span&gt;# Netty组件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;connection-timeout:&lt;/span&gt; &lt;span&gt;3000&lt;/span&gt;  &lt;span&gt;# 连接超时&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、属性配置类&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;在ServerProperties类中，并没有提供很多显式的Netty配置参数，更多信息需要参考工厂类；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;server&quot;&lt;/span&gt;, ignoreUnknownFields = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServerProperties&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer port;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Netty&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; Duration connectionTimeout;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3、配置加载分析&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvA0qw5uGuCVxH7iaHrnpAOuMCuCndJTgTWu0F8R496J37NHHFTCqe319VibyGzY9qn5cSeBlW0CtkXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NettyWebServerFactoryCustomizer&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;WebServerFactoryCustomizer&lt;/span&gt;&amp;lt;&lt;span&gt;NettyReactiveWebServerFactory&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Environment environment;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ServerProperties serverProperties;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;customize&lt;/span&gt;&lt;span&gt;(NettyReactiveWebServerFactory factory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();&lt;br/&gt;        ServerProperties.Netty nettyProperties = &lt;span&gt;this&lt;/span&gt;.serverProperties.getNetty();&lt;br/&gt;        propertyMapper.from(nettyProperties::getConnectionTimeout).whenNonNull()&lt;br/&gt;                .to((connectionTimeout) -&amp;gt; customizeConnectionTimeout(factory, connectionTimeout));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;NettyReactiveWeb服务工厂，基于上述入门案例，创建WebServer时，部分参数信息出自LoopResources接口；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NettyReactiveWebServerFactory&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractReactiveWebServerFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ReactorResourceFactory resourceFactory;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; WebServer &lt;span&gt;getWebServer&lt;/span&gt;&lt;span&gt;(HttpHandler httpHandler)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        HttpServer httpServer = createHttpServer();&lt;br/&gt;        ReactorHttpHandlerAdapter handlerAdapter = &lt;span&gt;new&lt;/span&gt; ReactorHttpHandlerAdapter(httpHandler);&lt;br/&gt;        NettyWebServer webServer = &lt;span&gt;new&lt;/span&gt; NettyWebServer(httpServer, handlerAdapter, &lt;span&gt;this&lt;/span&gt;.lifecycleTimeout);&lt;br/&gt;        webServer.setRouteProviders(&lt;span&gt;this&lt;/span&gt;.routeProviders);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; webServer;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; HttpServer &lt;span&gt;createHttpServer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  HttpServer server = HttpServer.create();&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.resourceFactory != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;         LoopResources resources = &lt;span&gt;this&lt;/span&gt;.resourceFactory.getLoopResources();&lt;br/&gt;         server = server.tcpConfiguration(&lt;br/&gt;           (tcpServer) -&amp;gt; tcpServer.runOn(resources).addressSupplier(&lt;span&gt;this&lt;/span&gt;::getListenAddress));&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; applyCustomizers(server);&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;五、周期管理方法&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、控制类&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvA0qw5uGuCVxH7iaHrnpAOuMVnbfULTk9ewFnh7p0KeFPKicLxfxfY0zkenicYehXS4HZREZIYTqicvDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;Gateway项目中，Netty服务核心控制类，通过NettyReactiveWebServerFactory工厂类创建，对Netty生命周期的管理提供了一层包装；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NettyWebServer&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;WebServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HttpServer httpServer;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReactorHttpHandlerAdapter handlerAdapter;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 启动方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;start&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; WebServerException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.disposableServer == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.disposableServer = startHttpServer();&lt;br/&gt;            &lt;span&gt;// 控制台日志&lt;/span&gt;&lt;br/&gt;            logger.info(&lt;span&gt;&quot;Netty started on port(s): &quot;&lt;/span&gt; + getPort());&lt;br/&gt;            startDaemonAwaitThread(&lt;span&gt;this&lt;/span&gt;.disposableServer);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; DisposableServer &lt;span&gt;startHttpServer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        HttpServer server = &lt;span&gt;this&lt;/span&gt;.httpServer;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.routeProviders.isEmpty()) {&lt;br/&gt;            server = server.handle(&lt;span&gt;this&lt;/span&gt;.handlerAdapter);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; server.bindNow();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 停止方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;stop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; WebServerException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.disposableServer != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;// 释放资源&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.lifecycleTimeout != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.disposableServer.disposeNow(&lt;span&gt;this&lt;/span&gt;.lifecycleTimeout);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.disposableServer.disposeNow();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 对象销毁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.disposableServer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、管理类&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Netty组件中抽象管理类，以安全的方式构建Http服务；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HttpServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HttpServer &lt;span&gt;create&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; HttpServerBind.INSTANCE;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; DisposableServer &lt;span&gt;bindNow&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bindNow(Duration.ofSeconds(&lt;span&gt;45&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HttpServer &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(BiFunction&amp;lt;? &lt;span&gt;super&lt;/span&gt; HttpServerRequest, ? &lt;span&gt;super&lt;/span&gt;&lt;br/&gt;            HttpServerResponse, ? extends Publisher&amp;lt;Void&amp;gt;&amp;gt; handler)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HttpServerHandle(&lt;span&gt;this&lt;/span&gt;, handler);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;六、参考源码&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;编程文档：&lt;br/&gt;https://gitee.com/cicadasmile/butte-java-note&lt;br/&gt;&lt;br/&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;30792&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97816&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>53924308159595cf2e8e3b5d655f7c22</guid>
<title>利用 Vue 实现评论板块：发表情，@某人消息推送</title>
<link>https://toutiao.io/k/5ghozsi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在接到这个需求的时候，我就纳闷，为啥要搞这么多花样，评论就评论吧，它还要你实现艾特某人的时候，还要调用后台的IM接口，给相关人员发送通知推送；说到这里，有点经验的JY应该就想到了，数据参数如何组装和传递这是个关键点，后面再细说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;评论区主要实现的功能点有：表情包选择，艾特符识别并弹出人员选择，还有就是图片选择（篇幅有限，这个放在第二篇文章述说），还有就是支持表情包，艾特人，文本组合显示的文本区域（这个是难点）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组合显示的文本区域，除了能正常显示三种元素节点，还需要将其关联的数据包裹起来，方便在点击发送的时候，将这些数据提取出来进行组装，然后发送给后台；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始，毫无头绪，不知从何下手的时候，想到的就是去寻找一劳永逸的插件，然后发现，比较适合做这方面的插件，无非就是富文本编辑器吧，比如最常用的富文本编辑器&lt;span&gt;Vue-Quill-Editor&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; ,但是研究了一番这开源插件的文档发现，开发的API并不能满足我实际的需求，&lt;strong&gt;比如艾特人的情况下数据存储，还有改写后光标的显示和跟踪问题，&lt;/strong&gt;，😮‍💨唉，一番折腾之后又陷入了苦思当中；但问题总归是要解决的，于是我开始萌生了不再依赖插件的想法；经过我一番的努力思索，还真给我整出来了，废话不多说，先上图：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.63&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQS6rB4Lku0tQ6GMWaYJTRF3ia5m2vpibHlvKJqNDcSdwUNAenD6sO9AHIweRSpkbBQmN51D25UNiciafw/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;600&quot;/&gt; &lt;strong&gt;接下来我会从以下几个方面分享我的开发思路喝实现方案&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;原型描述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;思路分析&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;代码实现&lt;/section&gt;&lt;/li&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原型需求&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的需求是这样子的，请看下方描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A.鼠标点击输入框即可开始输入内容&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B.当在输入的过程发送了@消息时，被@的人会通过IM收到被@的消息。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;输入@后弹出人员选择框，这里的人员包括“所有人”、“创建人”、“负责人”、“子任务负责人”、“参与人”。排序顺序按照此顺序进行展示。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排列在第一个的为“所有人”这里的所有人不包括自己。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下面的其他人员中同样不会显示出自己。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;勾选人后，被勾选的人会显示到输入框中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注意：如果@了所有人，又@了单个人，此时发送出去的消息针对个人只会发送一次。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C.通过@发送出去的消息除了会在当前页面进行展示外，还会通过IM将消息发送给对方：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@了几个人就会把消息单独发给那几个人。如果有相同的需要去重，只会发送一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果@了所有人，那么就会单独发送给所有人（不包含自己）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;被@的人会在IM中收到消息。这条消息来自发起人与被@的人之间的私聊。如果聊天的内容中包含了附件，则附件不会发送到IM，只会发送本文内容和表情。做出了的效果如图：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.59&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQS6rB4Lku0tQ6GMWaYJTRF32r1fXkee4bsKSM1Dm8XGOQLicQmHTEibLDJBib9ahdDGGcbMTiapLbeN7A/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;QQ20230216-175213-HD.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;IM聊天那边就会收到相关任务的评论信息&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6496815286624203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQS6rB4Lku0tQ6GMWaYJTRF3Rk8rjlrqaZiajTOl9AI1ibd5cIhY5TDFOCOn04aQcXLJNKbBjp1YlibEg/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1884&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;思路分析&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;表情模块实现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择表情包弹层有两种方案，一种是直接图片链接展示，图片命名用中文，另一种是提交给后台的时候是要转译成【微笑】的形式进行保存，而不是图片链接&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里涉及到表情选择后，回显到文本框中。我们所知道的textarea标签只能传进文本内容，所要将div改写成可编辑的文本框，增加&lt;strong&gt;contenteditable=&quot;true&quot;&lt;/strong&gt; 属性，通过获取div的Dom,对其进行光标定位，让表情包进行插入，再操作光标移动；可能看到这里的JY有点懵，在代码实现那里会细说。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5170370370370371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQS6rB4Lku0tQ6GMWaYJTRF3DwG419eL54wuEVUejkHiahnHRgY6fpkejc3FEb7xaic0IicTbab1MbY8g/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1350&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.423963133640553&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQS6rB4Lku0tQ6GMWaYJTRF3libfCiaRCy1u02o9MJvkTRMXX9Ng5WWnyLg7icUkkQbgvHpT7vv66KZjQ/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;868&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;艾特符模块实现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当监听到用户输入@的时候我们弹出人员选择器，这时候我们需要记住现在光标所在的位置，当用户选择人员完毕之后，我们创建一个Dom在插入到我们刚刚记录光标的位置，并且把我们输入的@删除，将光标放在这个节点的最后；似乎过程描述得还蛮简单的，但不过实现起来还是有点难度；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、使用到的JavaScript对象：&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.&lt;code&gt;Range&lt;/code&gt; Range对象表示的包含节点或者文本节点一段片段&lt;br/&gt;2.&lt;code&gt;Selection&lt;/code&gt; Selection对象表示用户的光标开始位置到结束位置的选区&lt;br/&gt;（以上是我的个人理解，具体的需要到MDN上查阅）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、实现的原理&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先通过const selection = Window.getSelection(),&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;const range = selection.getrangeAt(0)获取光标的位置，我使用的是create-pos插件准确获取光标的位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后监听键盘事件,阻止输入@的默认行为，并且创建一个SPAN标签，内容为@，然后到光标处；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建两个新的span标签，把@+选中的内容让放到其中一个新建的span标签中，另外一个span标签插入空格&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建一个fragment片段，把第四步中两个span标签一次插入fragment中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后使用Range对象中的insertNode()方法插入富文本中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第6步完成之后，找到第4步创建并带有@的SPAN节点，然后移除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除时，首先找到包含@+内容的节点，然后把整个节点一起删除&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据交互模块实现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我要评论这样一条信息&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19237147595356552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQS6rB4Lku0tQ6GMWaYJTRF3mg8G8GeC9xE3B3xhDj1YmcT98A1erW1L6gY97UAJPcQPjbpRxCJylg/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1206&quot;/&gt; 那么我们需要怎样存储后端接口需要到的参数格式呢，比如IM推送，需要知道你艾特的是谁，还有表情包，到底要的是链接，还是标识符，这些需要分析如何存储和传递的， 而我这个项目的接口需要的数据格式如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25314685314685315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQS6rB4Lku0tQ6GMWaYJTRF3uESczia38g8nmJl4DJSic4PKsAxGwvAwqia5Aribw90t14jPe1fAlgl4AQ/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1430&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;其中imText是用于在IM聊天窗口中，发送消息的数据格式，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;text部分是直接用于评论任务记录的显示，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;users是用于存储艾特相关人员的用户id存储&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显而易见，我们需要做的就是将users—id存储到艾特符元素里面，imText需要我们从内容框中得到的html,再做个正则匹配将其内容转换和替换成我们需要的数据格式；至于如何实现，待会在代码实现栏上详说&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码实现&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;表情包评论代码解析&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;选中表情&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;appendEmoji(imgSrc) {&lt;br/&gt;  &lt;span&gt;// 拿到dom获取光标&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; editor = &lt;span&gt;this&lt;/span&gt;.$refs.jsEditorElement;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (editor) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.isFocus()&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(editor.focus);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.selectEmoji(imgSrc);&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onChangeJsEditor&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.onChangeJsEditor(&lt;span&gt;&#x27;emoji&#x27;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.visibleEmoj = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;将文本框的光标位置移动到添加表情后的位置&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; selectEmoji(url) {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; editor = &lt;span&gt;this&lt;/span&gt;.$refs.jsEditorElement;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (editor) {&lt;br/&gt;    editor.focus();&lt;br/&gt;    &lt;span&gt;// this.editorRange.selection.collapseToEnd();&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 删掉草稿start&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; editorRange = &lt;span&gt;this&lt;/span&gt;.editorRange.range;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;br/&gt;      &lt;span&gt;&quot;editorRange&quot;&lt;/span&gt;,&lt;br/&gt;      editorRange,&lt;br/&gt;      editorRange.startOffset,&lt;br/&gt;      editorRange.endOffset&lt;br/&gt;    );&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!editorRange) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; textNode = editorRange.endContainer; &lt;span&gt;// 拿到末尾文本节点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; endOffset = editorRange.endOffset; &lt;span&gt;// 光标位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 找出光标前的at符号位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// const textNodeValue = textNode.nodeValue&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// const expRes = (/@([^@]*)$/).exec(textNodeValue)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// if (expRes &amp;amp;&amp;amp; expRes.length &amp;gt; 1) {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// editorRange.setStart(textNode, expRes.index)&lt;/span&gt;&lt;br/&gt;    editorRange.setEnd(textNode, endOffset);&lt;br/&gt;    editorRange.deleteContents(); &lt;span&gt;// 删除草稿end&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; dom = &lt;span&gt;this&lt;/span&gt;.createInsterImgData(url);&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(dom);&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;.editorRange.selection);&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;.editorRange.range);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.insertHtmlImgAtCaret(&lt;br/&gt;      dom,&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.editorRange.selection,&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.editorRange.range&lt;br/&gt;    );&lt;br/&gt;    &lt;span&gt;// }&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;},&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;将表情包以加装后img标签的形式累加到文本显示&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;createInsterImgData(url) {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; btn = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&quot;img&quot;&lt;/span&gt;);&lt;br/&gt;  btn.setAttribute(&lt;span&gt;&quot;src&quot;&lt;/span&gt;, url);&lt;br/&gt;  btn.setAttribute(&lt;span&gt;&quot;class&quot;&lt;/span&gt;, &lt;span&gt;&quot;emo&quot;&lt;/span&gt;);&lt;br/&gt;  btn.setAttribute(&lt;span&gt;&quot;style&quot;&lt;/span&gt;, &lt;span&gt;&quot;width: 26px;height:26px;&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; btn;&lt;br/&gt;},&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;@艾特某人代码解析&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、选择@按钮事件&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以阅读源码中的&lt;code&gt;selectPerson()&lt;/code&gt;方法，这里主要说下，保存@某人信息的问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给每一个选择的人员，构造一个Dom,设置为a标签元素，然后将用户信息存放在dataset里面，并设置一个classs属性（用于提交的时候通过正则匹配出来提取用户信息）， 如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;this&lt;/span&gt;.insertCaret(&lt;br/&gt;  &lt;span&gt;`&amp;lt;a data-id=&quot;&lt;span&gt;${some.member_id}&lt;/span&gt;&quot; data-mid=&quot;&lt;span&gt;${some.im_user_id}&lt;/span&gt;&quot; class=&quot;userSetClass&quot; &lt;br/&gt;  data-name=&quot;&lt;span&gt;${some.member_name}&lt;/span&gt;&quot; contenteditable=&quot;false&quot;&amp;gt;@&lt;span&gt;${some.member_name}&lt;/span&gt;&amp;lt;/a&amp;gt;&amp;amp;nbsp;`&lt;/span&gt;&lt;br/&gt;);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;createInsterData(personArr) {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; temp = [];&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; person &lt;span&gt;of&lt;/span&gt; personArr) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; btn = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&quot;a&quot;&lt;/span&gt;);&lt;br/&gt;    btn.dataset.id = person.member_id;&lt;br/&gt;    btn.dataset.mid = person.im_user_id;&lt;br/&gt;    btn.dataset.name = person.member_name || person.name;&lt;br/&gt;    btn.contentEditable = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    btn.setAttribute(&lt;span&gt;&quot;href&quot;&lt;/span&gt;, &lt;span&gt;&quot;javascript:void(0)&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.allowSelectMembers.length === personArr.length) {&lt;br/&gt;      btn.textContent = &lt;span&gt;` &amp;amp;&lt;span&gt;${person.member_name}&lt;/span&gt; `&lt;/span&gt;;&lt;br/&gt;      btn.setAttribute(&lt;span&gt;&#x27;style&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;display:none&#x27;&lt;/span&gt;)&lt;br/&gt;      btn.setAttribute(&lt;span&gt;&quot;class&quot;&lt;/span&gt;, &lt;span&gt;&quot;userHiddenSetClass&quot;&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      btn.textContent = &lt;span&gt;` @&lt;span&gt;${person.member_name}&lt;/span&gt; `&lt;/span&gt;;&lt;br/&gt;      btn.setAttribute(&lt;span&gt;&quot;class&quot;&lt;/span&gt;, &lt;span&gt;&quot;userSetClass&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    btn.addEventListener(&lt;br/&gt;      &lt;span&gt;&quot;click&quot;&lt;/span&gt;,&lt;br/&gt;      () =&amp;gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    );&lt;br/&gt;    btn.tabindex = &lt;span&gt;&quot;-1&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; bSpaceNode = &lt;span&gt;document&lt;/span&gt;.createTextNode(&lt;span&gt;&quot;\u200B&quot;&lt;/span&gt;); &lt;span&gt;// 不可见字符，为了放光标方便&lt;/span&gt;&lt;br/&gt;    temp.push(btn);&lt;br/&gt;    temp.push(bSpaceNode);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 将所有添加进去@所有人&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.allowSelectMembers.length === personArr.length) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; btn = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&quot;a&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    btn.type = &lt;span&gt;&quot;link&quot;&lt;/span&gt;;&lt;br/&gt;    btn.textContent = &lt;span&gt;` @所有人 `&lt;/span&gt;;&lt;br/&gt;    btn.contentEditable = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    btn.setAttribute(&lt;span&gt;&quot;class&quot;&lt;/span&gt;, &lt;span&gt;&quot;userSetAllClass&quot;&lt;/span&gt;);&lt;br/&gt;    btn.setAttribute(&lt;span&gt;&quot;href&quot;&lt;/span&gt;, &lt;span&gt;&quot;javascript:void(0)&quot;&lt;/span&gt;);&lt;br/&gt;    btn.tabindex = &lt;span&gt;&quot;-1&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; bSpaceNode = &lt;span&gt;document&lt;/span&gt;.createTextNode(&lt;span&gt;&quot;\u200B&quot;&lt;/span&gt;); &lt;span&gt;// 不可见字符，为了放光标方便&lt;/span&gt;&lt;br/&gt;    temp.push(btn);&lt;br/&gt;    temp.push(bSpaceNode);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; temp;&lt;br/&gt;},&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、输入@符号监听&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要写个监听函数,当用户按 &lt;code&gt;shift + @&lt;/code&gt; 的时候会被检索到，然后执行获取光标事件，并同时更新人员弹层选择列表&lt;code&gt;getAllNewMembers()&lt;/code&gt;,&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;onInputText(e) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.onChangeJsEditor(e.target.innerHTML)&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(e.target.innerHTML)&lt;br/&gt;  &lt;span&gt;// 这是输入了@，那就直接弹选人浮层&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.doToggleDialog();&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;.editorRange);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (e.code === &lt;span&gt;&quot;Digit2&quot;&lt;/span&gt; &amp;amp;&amp;amp; e.shiftKey) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.mockInput = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;输入@&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 获取新的参与人alt列表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.getAllNewMembers()&lt;br/&gt;  }&lt;br/&gt;},&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、发布评论前的数据转换&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚才在前面两个模块做的数据组装就是为了最后一步，发表评论的数据提取和传递问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先提取用户信息，将其存放在一个数组中&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; collect = editor.getElementsByClassName(&lt;span&gt;&quot;userSetClass&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(collect, &lt;span&gt;Array&lt;/span&gt;.from(collect).length);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; child &lt;span&gt;of&lt;/span&gt; collect) {&lt;br/&gt;  atidsss.push(child.dataset.id);&lt;br/&gt;  atnames.push(child.dataset.name);&lt;br/&gt;  atmid.push(child.dataset.mid);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// @所有人&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; AltAll = editor.getElementsByClassName(&lt;span&gt;&quot;userSetAllClass&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// if(AltAll.)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(AltAll &amp;amp;&amp;amp; &lt;span&gt;Array&lt;/span&gt;.from(AltAll).length &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; userHiddenSetClass = editor.getElementsByClassName(&lt;span&gt;&quot;userHiddenSetClass&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; child &lt;span&gt;of&lt;/span&gt; userHiddenSetClass) {&lt;br/&gt;    atidsss.push(child.dataset.id);&lt;br/&gt;    atnames.push(child.dataset.name);&lt;br/&gt;    atmid.push(child.dataset.mid);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，将带有img标签的html文本，通过正则表达式将其提取出图片名称，用于IM的消息推送格式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;params.imText = params.imText.replace(&lt;br/&gt;  &lt;span&gt;/&amp;lt;img [^&amp;gt;]*src=[&#x27;&quot;]([^&#x27;&quot;]+)[^&amp;gt;]*&amp;gt;/gi&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;match, capture&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(capture);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; name = that.getLastFileName(capture)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(name) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;`[&lt;span&gt;${name}&lt;/span&gt;]`&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是整理数据，将后端定义好的数据格式传递给他们&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; params = {&lt;br/&gt;  &lt;span&gt;task_id&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;.activeTaskItemDetailID,&lt;br/&gt;  &lt;span&gt;text&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;.$refs.jsEditorElement.innerHTML,&lt;br/&gt;  &lt;span&gt;imText&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;.$refs.jsEditorElement.innerHTML,&lt;br/&gt;  &lt;span&gt;images&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;.imgList,&lt;br/&gt;  &lt;span&gt;users&lt;/span&gt;: atidsss ? atidsss.filter(&lt;span&gt;(&lt;span&gt;v&lt;/span&gt;) =&amp;gt;&lt;/span&gt; v) : [],&lt;br/&gt;  &lt;span&gt;attachment&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;.fileList,&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;完结&lt;/strong&gt; 如果您还有力气，麻烦点个小指头，支持下感谢！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;附赠源码：&lt;strong&gt;赠：赠人玫瑰，手留余香；正在参加活动，帮帮忙点赞+评论+1+收藏，感谢🙏&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;点个赞表示你也玩金铲铲呀：giegie,正在参加活动，这个赞可以给我吗？，如果觉得有价值666也好谢谢&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>