<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>383cdeea43582b8d91960907d44a6233</guid>
<title>Kafka在美团数据平台的实践</title>
<link>https://toutiao.io/k/92uh7d6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;58&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU2zk0q52HtKQjubeUEyZHBVHPgeBXgTUj0ib1Kwfosl82xO1Aw7x6gccLuuYs1dbxI7REI7OcjbGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第526&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2022年 第043篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;103&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;103&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU2zk0q52HtKQjubeUEyZHBic5ADGrKxgSd0tibyMiasOHXjb46qFBw7PTfuWAxXzWq32lDkL05icwkMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;section&gt;&lt;span&gt;Kafka在美团数据平台承担着统一的数据缓存和分发的角色，随着数据量的增长，集群规模的扩大，Kafka面临的挑战也愈发严峻。本文分享了美团Kafka面临的实际挑战，以及美团针对性的一些优化工作，希望能给从事相关开发工作的同学带来帮助或启发。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 现状和挑战&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 读写延迟优化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.1 概览&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.2 应用层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.3 系统层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.4 混合层-SSD新缓存架构&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 大规模集群管理优化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.1 隔离策略&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.2 全链路监控&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.3 服务生命周期管理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.4 TOR容灾&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4 未来展望&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 现状和挑战&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1 现状&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;Kafka是一个开源的流处理平台，我们首先了解一下Kafka在美团数据平台的现状。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;473&quot; data-ratio=&quot;0.84765625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2Ep8NK5lDVqekicpD25HBsqeDqh3hOUJicB6fzIRibdk7L2LNeeia8v2h4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图1-1 Kafka在美团数据平台的现状&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如图1-1所示，蓝色部分描述了Kafka在数据平台定位为流存储层。主要的职责是做数据的缓存和分发，它会将收集到的日志分发到不同的数据系统里，这些日志来源于系统日志、客户端日志以及业务数据库。下游的数据消费系统包括通过ODS入仓提供离线计算使用、直接供实时计算使用、通过DataLink同步到日志中心，以及做OLAP分析使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Kafka在美团的集群规模总体机器数已经超过了15000+台，单集群的最大机器数也已经到了2000+台。在数据规模上，天级消息量已经超过了30+P，天级消息量峰值也达到了4+亿/秒。不过随着集群规模的增大，数据量的增长，Kafka面临的挑战也愈发严峻，下面讲一下具体的挑战都有哪些。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2 挑战&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;213&quot; data-ratio=&quot;0.3814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2kjgz9Iktia4WEAlbpBO7ZZ5RkLWb7VJg8NHFiagQd0V5R8Co9yh0bWCQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图1-2 Kafka在美团数据平台面临的挑战&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如图1-2所示，具体的挑战可以概括为两部分：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;第一部分是慢节点影响读写&lt;/strong&gt;，这里慢节点参考了HDFS的一个概念，具体定义指的是读写延迟TP99大于300ms的Broker。造成慢节点的原因有三个：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;集群负载不均衡会导致局部热点，就是整个集群的磁盘空间很充裕或者ioutil很低，但部分磁盘即将写满或者ioutil打满。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PageCache容量，比如说，80GB的PageCache在170MB/s的写入量下仅能缓存8分钟的数据量。那么如果消费的数据是8分钟前的数据，就有可能触发慢速的磁盘访问。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Consumer客户端的线程模型缺陷会导致端到端延时指标失真。例如当Consumer消费的多个分区处于同一Broker时，TP90可能小于100ms，但是当多个分区处于不同Broker时，TP90可能会大于1000ms。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;第二部分是大规模集群管理的复杂性&lt;/strong&gt;，具体表现有4类问题：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不同Topic之间会相互影响，个别Topic的流量突增，或者个别消费者的回溯读会影响整体集群的稳定性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Kafka原生的Broker粒度指标不够健全，导致问题定位和根因分析困难。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;故障感知不及时，处理成本较高。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Rack级别的故障会造成部分分区不可用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 读写延迟优化&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;接下来我们先介绍一下针对读写延迟问题，美团数据平台做了哪些优化。首先从宏观层面，我们将受影响因素分为应用层和系统层，然后详细介绍应用层和系统层存在的问题，并给出对应的解决方案，包括流水线加速、Fetcher隔离、迁移取消和Cgroup资源隔离等，下面具体介绍各种优化方案的实现。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 概览&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;286&quot; data-ratio=&quot;0.51171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2U4VwXgjpKhlv14KQobga8wS5SspwC4akxDiczg3Oo1sR4gMaIiaveKpw/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-1 Kafka读写延迟优化概览&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图2-1是针对读写延迟碰到的问题以及对应优化方案的概览图。我们把受影响的因素分为应用层和系统层。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;应用层&lt;/strong&gt;主要包括3类问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）Broker端负载不均衡，例如磁盘使用率不均衡、ioutil不均衡等问题。个别磁盘负载升高影响整个Broker的请求受到影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）Broker的数据迁移存在效率问题和资源竞争问题。具体来讲，包括以下3个层面：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3）Consumer端单线程模型存在缺陷导致运维指标失真，并且单Consumer消费的分区数不受限制，消费能力不足就无法跟上实时最新的数据，当消费的分区数增多时可能会引起回溯读。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;系统层&lt;/strong&gt;也主要包括3类问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）PageCache污染。Kafka利用内核层提供的ZeroCopy技术提升性能，但是内核层无法区分实时读写请求和回溯读请求，导致磁盘读可能污染PageCache，影响实时读写。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）HDD在随机读写负载下性能差。HDD对于顺序读写友好，但是面对混合负载场景下的随机读写，性能显著下降。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3）CPU和内存等系统资源在混部场景下的资源竞争问题。在美团大数据平台，为了提高资源的利用率，IO密集型的服务（&lt;/span&gt;&lt;span&gt;比如Kafka&lt;/span&gt;&lt;span&gt;）会和CPU密集型的服务（&lt;/span&gt;&lt;span&gt;比如实时计算作业&lt;/span&gt;&lt;span&gt;）混布，混布存在资源竞争，影响读写延迟。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上提到的问题，我们采取了针对性的策略。比如应用层的磁盘均衡、迁移流水线加速、支持迁移取消和Consumer异步化等。系统层的Raid卡加速、Cgroup隔离优化等。此外，针对HDD随机读写性能不足的问题，我们还设计并实现了基于SSD的缓存架构。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 应用层&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;① 磁盘均衡&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;488&quot; data-ratio=&quot;0.84296875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj205CQrOf1PVflyCApAxibK4s38sq1MbR9LGLLrAAz3iab67Gj8IiaicD32A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-2 Kafka应用层磁盘均衡&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;磁盘热点导致两个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对这两个问题，我们采用了基于空闲磁盘优先的分区迁移计划，整个计划分为3步，由组件Rebalancer统筹管理：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;生成迁移计划。Rebalancer通过目标磁盘使用率和当前磁盘使用率（&lt;/span&gt;&lt;span&gt;通过Kafka Monitor上报&lt;/span&gt;&lt;span&gt;）持续生成具体的分区迁移计划。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提交迁移计划。Rebalancer向Zookeeper的Reassign节点提交刚才生成的迁移计划，Kafka的Controller收到这个Reassign事件之后会向整个Kafka Broker集群提交Reassign事件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;检查迁移计划。Kafka Broker负责具体执行数据迁移任务，Rebalancer负责检查任务进展。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;如图2-2所示，每块Disk持有3个分区是一个相对均衡的状态，如果部分Disk持有4个分区，比如Broker1-Disk1和Broker4-Disk4；部分Disk持有2个分区，比如Broker2-Disk2，Broker3-Disk3，Reblanacer就会将Broker1-Disk1和Broker4-Disk4上多余的分区分别迁移到Broker2-Disk2和Broker3-Disk3，最终尽可能地保证整体磁盘利用率均衡。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;② 迁移优化&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然基于空闲磁盘优先的分区迁移实现了磁盘均衡，但是迁移本身仍然存在效率问题和资源竞争问题。接下来，我们会详细描述我们采取的针对性策略。&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;采取流水线加速策略优化迁移缓慢引起的迁移效率问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持迁移取消解决长尾分区迁移缓慢引起的读写请求受影响问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;采取Fetcher隔离缓解数据迁移请求和实时读写请求共用Fetcher线程的问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;优化一，流水线加速&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;525&quot; data-ratio=&quot;0.90859375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2N0uJeeWaBvcdRujyNrDw2TArwCUwEsR5hGpJt5aWeGDuubFnU7icXkQ/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-3 流水线加速&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如图2-3所示，箭头以上原生Kafka版本只支持按批提交，比如说一批提交了四个分区，当TP4这个分区一直卡着无法完成的时候，后续所有分区都无法继续进行。采用流水线加速之后，即使TP4这个分区还没有完成，可以继续提交新的分区。在相同的时间内，原有的方案受阻于TP4没有完成，后续所有分区都没办法完成，在新的方案中，TP4分区已经迁移到TP11分区了。图中虚线代表了一个无序的时间窗口，主要用于控制并发，目的是为了和原有的按组提交的个数保持一致，避免过多的迁移影响读写请求服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;优化二，迁移取消&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;373&quot; data-ratio=&quot;0.6453125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2kTHuKIghUiakWJWZjzX8JfibMrj54j805zy6dUMyLb4Y1OGGbD3Z50ow/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-4-1 迁移问题&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如图2-4-1所示，箭头左侧描述了因为迁移影响的三种线上类型。第一种是因为迁移会触发最旧读，同步大量的数据，在这个过程中会首先将数据回刷到PageCache上引起PageCache污染，导致某个实时读的分区发生Cache Miss，触发磁盘度进而影响读写请求；第二种是当存在某些异常节点导致迁移Hang住时，部分运维操作无法执行，比如流量上涨触发的Topic自动扩分区。因为在Kafka迁移过程中这类运维操作被禁止执行。第三种和第二种类似，它的主要问题是当目标节点Crash，Topic扩分区也无法完成，用户可能一直忍受读写请求受影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;481&quot; data-ratio=&quot;0.83203125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2vUgult7YLNYibLgZS1weeF9IGTKwOKDGFB5OyyhZa6GYOLiaYYVqibAQw/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-4-2 迁移取消&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对上面提到的3种问题，我们支持了迁移取消功能。管理员可以调用迁移取消命令，中断正在迁移的分区，针对第一种场景，PageCache就不会被污染，实时读得以保证；在第二、三种场景中，因为迁移取消，扩分区得以完成。迁移取消会删除未完成迁移的分区，删除可能会导致磁盘IO出现瓶颈影响读写，因此我们通过支持平滑删除避免大量删除引起的性能问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;优化三，Fetcher隔离&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;719&quot; data-ratio=&quot;1.24375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2Ma5q6bUXngHJGd4d92pr3NUL8VVUpEYxWSdCibKtibNGbQQNG5IIVWKw/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-5 Fetcher隔离&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如图2-5，绿色代表实时读，红色代表延时读。当某一个Follower的实时读和延时读共享同一个Fetcher时，延时读会影响实时读。因为每一次延时读的数据量是显著大于实时读的，而且延时读容易触发磁盘读，可能数据已经不在PageCache中了，显著地拖慢了Fetcher的拉取效率。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对这种问题，我们实施的策略叫Fetcher隔离。也就是说所有ISR的Follower共享Fetcher，所有非ISR的Follower共享Fetcher，这样就能保证所有ISR中的实时读不会被非ISR的回溯读所影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;③ Consumer异步化&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;457&quot; data-ratio=&quot;0.81328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2ZU9JDCpdyvNghySib2YpzQTgBF7drSibSeZkSALPCkYIYauIibCY8eyicg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-6 Kafka-Broker分阶段延时统计模型&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在讲述Consumer异步化前，需要解释下图2-6展示的Kafka-Broker分阶段延时统计模型。Kafka-Broker端是一个典型的事件驱动架构，各组件通过队列通信。请求在不同组件流转时，会依次记录时间戳，最终就可以统计出请求在不同阶段的执行耗时。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体来说，当一个Kafka的Producer或Consumer请求进入到Kafka-Broker时，Processor组件将请求写入RequestQueue，RequestHandler从RequestQueue拉取请求进行处理，在RequestQueue中的等待时间是RequestQueueTime，RequestHandler具体的执行时间是LocalTime。当RequestHandler执行完毕后会将请求传递给DelayedPurgatory组件中，该组件是一个延时队列。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当触发某一个延时条件完成了以后会把请求写到ResponseQueue中，在DelayedPurgatory队列持续的时间为RemoteTime，Processor会不断的从ResponseQueue中将数据拉取出来发往客户端，标红的ResponseTime是可能会被客户端影响的，因为如果客户端接收能力不足，那么ResponseTime就会一直持续增加。从Kafka-Broker的视角，每一次请求总的耗时时RequestTotalTime，包含了刚才所有流程分阶段计时总和。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;597&quot; data-ratio=&quot;1.03203125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2CyqibVzfPBxSRlyMxBVjib1NasRrqHXZWxNFqIhpzxPOnVHlBdvspniaw/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-7 Consumer异步化&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ResponseTime持续增加的主要问题是因为Kafka原生Consumer基于NIO的单线程模型存在缺陷。如图2-7所示，在Phase1，User首先发起Poll请求，Kafka-Client会同时向Broker1、Broker2和Broker3发送请求，Broker1的数据先就绪时，Kafka Client将数据写入CompleteQueue，并立即返回，而不是继续拉取Broker2和Broker3的数据。后续的Poll请求会直接从CompleteQueue中读取数据，然后直接返回，直到CompleteQueue被清空。在CompleteQueue被清空之前，即使Broker2和Broker3的端的数据已经就绪，也不会得到及时拉取。如图中Phase2，因为单线程模型存在缺陷导致WaitFetch这部分时长变大，导致Kafka-Broker的RespnseTime延时指标不断升高，带来的问题是无法对服务端的处理瓶颈进行精准的监控与细分。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;415&quot; data-ratio=&quot;0.71796875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj20YJA4AibxrkPW3nrjUw6xyKZ0UGgLzib9fBEqZvWofjQ5mPo0SSibB1qg/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-8 引入异步拉取线程&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对这个问题，我们的改进是引入异步拉取线程。异步拉取线程会及时地拉取就绪的数据，避免服务端延时指标受影响，而且原生Kafka并没有限制同时拉取的分区数，我们在这里做了限速，避免GC和OOM的发生。异步线程在后台持续不断地拉取数据并放到CompleteQueue中。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3 系统层&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;① Raid卡加速&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;268&quot; data-ratio=&quot;0.4638888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj26JhuaiaaLMnxJbpRlNA16OlyL8GJib85tjkKFU1qaXmDPmRkCT5xlKrA/640?wx_fmt=jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-9 Raid卡加速&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;HDD存在随机写性能不足的问题，表现为延时升高，吞吐降低。针对这个问题我们引入了Raid卡加速。Raid卡自带缓存，与PageCache类似，在Raid这一层会把数据Merge成更大的Block写入Disk，更加充分利用顺序写HDD的带宽，借助Raid卡保证了随机写性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;② Cgroup隔离优化&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;202&quot; data-ratio=&quot;0.34921875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2rZqr6Rs4nTZnZwxvQBWUiafZsVCCMAbEhJWKXyMWmaeohZiaWdtltcaw/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-10 Cgroup隔离&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了提高资源利用率，美团数据平台将IO密集型应用和CPU密集型应用混合部署。IO密集型应用在这里指的就是Kafka，CPU密集型应用在这里指的是Flink和Storm。但是原有的隔离策略存在两个问题：首先是物理核本身会存在资源竞争，在同一个物理核下，共享的L1Cache和L2Cache都存在竞争，当实时平台CPU飙升时会导致Kafka读写延时受到影响；其次，Kafka的HT跨NUMA，增加内存访问耗时，如图2-10所示，跨NUMA节点是通过QPI去做远程访问，而这个远程访问的耗时是40ns。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对这两个问题，我们改进了隔离策略，针对物理核的资源竞争，我们新的混布策略保证Kafka独占物理核，也就是说在新的隔离策略中，不存在同一个物理核被Kafka和Flink同时使用；然后是保证Kafka的所有超线程处于同一侧的NUMA，避免Kafka跨NUMA带来的访问延时。通过新的隔离策略，Kafka的读写延时不再受Flink CPU飙升的影响。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.4 混合层-SSD新缓存架构&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;211&quot; data-ratio=&quot;0.36484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2fibwiadZs6cxoTvMGcmYibPZvgJaohozRrsMdwhksSZtqu8rm5lNDGibpg/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-11 Page污染引起的性能问题&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;背景和挑战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Kafka利用操作系统提供的ZeroCopy技术处理数据读取请求，PageCache容量充裕时数据直接从PageCache拷贝到网卡，有效降低了读取延时。但是实际上，PageCache的容量往往是不足的，因为它不会超过一个机器的内存。容量不足时，ZeroCopy就会触发磁盘读，磁盘读不仅显著变慢，还会污染PageCache影响其他读写。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如图2-11中左半部分所示，当一个延迟消费者去拉取数据时，发现PageCache中没有它想要的数据，这个时候就会触发磁盘读。磁盘读后会将数据回写到PageCache，导致PageCache污染，延迟消费者消费延迟变慢的同时也会导致另一个实时消费受影响。因为对于实时消费而言，它一直读的是最新的数据，最新的数据按正常来说时不应该触发磁盘读的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;选型和决策&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对这个问题，我们这边在做方案选型时提供了两种方案：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;方案一&lt;/strong&gt;，读磁盘时不回写PageCache，比如使用DirectIO，不过Java并不支持；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;方案二&lt;/strong&gt;，在内存和HDD之间引入中间层，比如SSD。众所周知，SSD和HDD相比具备良好的随机读写能力，非常适合我们的使用场景。针对SSD的方案我们也有两种选型：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.72265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUAT8icebFDacQnwjohib3fj21EIrzGiaqFjhjDNPejt7QDnH3DJfaLBwdkC2hUr2giafBB8iacw95jgNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;方案一&lt;/strong&gt;，可以基于操作系统的内核实现，这种方案SSD与HDD存储空间按照固定大小分块，并且SSD与HDD建立映射关系，同时会基于数据局部性原理，Cache Miss后数据会按LRU和LFU替换SSD中部分数据，业界典型方案包括OpenCAS和FlashCache。其优势是数据路由对应用层透明，对应用代码改动量小，并且社区活跃可用性好；但是问题在于局部性原理并不满足Kafka的读写特性，而且缓存空间污染问题并未得到根本解决，因为它会根据LRU和LFU去替换SSD中的部分数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;方案二&lt;/strong&gt;，基于Kafka的应用层去实现，具体就是Kafka的数据按照时间维度存储在不同设备上，对于近实时数据直接放在SSD上，针对较为久远的数据直接放在HDD上，然后Leader直接根据Offset从对应设备读取数据。这种方案的优势是它的缓存策略充分考虑了Kafka的读写特性，确保近实时的数据消费请求全部落在SSD上，保证这部分请求处理的低延迟，同时从HDD读取的数据不回刷到SSD防止缓存污染，同时由于每个日志段都有唯一明确的状态，因此每次请求目的明确，不存在因Cache Miss带来的额外性能开销。同时劣势也很明显，需要在Server端代码上进行改进，涉及的开发以及测试的工作量较大。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;272&quot; data-ratio=&quot;0.4703125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj25azWiclDZhDplnRNqbZnNoIWumiaTAnM3L5dgB6EZm5hbibfUB3etS9icg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-13 KafkaSSD新缓存架构&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;具体实现&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面来介绍一下SSD新缓存架构的具体实现。&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先新的缓存架构会将Log内的多个Segment按时间维度存储在不同的存储设备上，如图2-14中的红圈1，新缓存架构数据会有三种典型状态，一种叫Only Cache，指的是数据刚写进SSD，还未同步到HDD上；第2个是Cached，指数据既同步到了HDD也有一部分缓存在SSD上；第三种类型叫WithoutCache，指的是同步到了HDD但是SSD中已经没有缓存了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;然后后台异步线程持续地将SSD数据同步到HDD上。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;随着SSD的持续写入，当存储空间达到阈值后，会按时间顺序删除距当前时间最久的数据，因为SSD的数据空间有限。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;副本可根据可用性要求灵活开启是否写入SSD。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从HDD读取的数据是不会回刷到SSD上的，防止缓存污染。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;239&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;302&quot; data-ratio=&quot;1.2652519893899203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2vibOGzCvFoNy27lLfNf4Ehk7XpurCV0NJltQJlaicW1EDVTqJVHibViaag/640?wx_fmt=jpeg&quot; data-w=&quot;754&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2-14 SSD新缓存架构细节优化&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;细节优化&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;介绍了具体实现之后，再来看一下细节优化。&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先是关于日志段同步，就是刚才说到的Segment，只同步Inactive的日志段，Inactive指的是现在并没有在写的日志段，低成本解决数据一致性问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;其次是做同步限速优化，在SSD向HDD同步时是需要限速的，同时保护了两种设备，不会影响其他IO请求的处理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 大规模集群管理优化&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 隔离策略&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;美团大数据平台的Kafka服务于多个业务，这些业务的Topic混布在一起的话，很有可能造成不同业务的不同Topic之间相互影响。此外，如果Controller节点同时承担数据读写请求，当负载明显变高时，Controller可能无法及时控制类请求，例如元数据变更请求，最终可能会造成整个集群发生故障。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对这些相互影响的问题，我们从业务、角色和优先级三个维度来做隔离优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;615&quot; data-ratio=&quot;1.0640625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2D3nGL0s7SXSGjZWX0owfLIbHKd7fxcoJpYvWCRibDib9HIsw7lBF55wA/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;p&gt;&lt;span&gt;图3-1 隔离优化&lt;/span&gt;&lt;/p&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 全链路监控&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;随着集群规模增长，集群管理碰到了一系列问题，主要包括两方面：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Broker端延时指标无法及时反应用户问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;随着请求量的增长，Kafka当前提供的Broker端粒度的TP99甚至TP999延时指标都可能无法反应长尾延时。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Broker端的延时指标不是端到端指标，可能无法反应用户的真实问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;故障感知和处理不及时。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;502&quot; data-ratio=&quot;0.8671875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2c0pOrlkicVbJBicqaeQS8icCrHCbOAqs6GTOxiaog9xoa4DuIS1M1B2zDw/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3-2 全链路监控&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对这两个问题，我们采取的策略是全链路监控。全链路监控收集和监控Kafka核心组件的指标和日志。全链路监控架构如图3-2所示。当某一个客户端读写请求变慢时，我们通过全链路监控可以快速定位到具体慢在哪个环节，全链路指标监控如图3-3所示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;239&quot; data-ratio=&quot;0.412962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2weDFeOqdxu0LjVdTdDfricB70UWAB7TGHn4Zbs73et757Qdiaicwn5ceA/640?wx_fmt=jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3-3 全链路指标监控&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图3-4是一个根据全链路指标定位请求瓶颈的示例，可以看出服务端RemoteTime占比最高，这说明耗时主要花费在数据复制。日志和指标的解析服务可以自动实时感知故障和慢节点，大部分的故障（&lt;/span&gt;&lt;span&gt;内存、磁盘、Raid卡以及网卡等&lt;/span&gt;&lt;span&gt;）和慢节点都已经支持自动化处理，还有一类故障是计划外的故障，比如分区多个副本挂掉导致的不可用，迁移Hang住以及非预期的错误日志等，需要人工介入处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;309&quot; data-ratio=&quot;0.534375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2J3gdNqwIbSD2L9cH1kY0FZBzA2w3ur45pSSoXkWCpHLCak7UP8noKQ/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3-4 全链路监控指标示例&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 服务生命周期管理&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;384&quot; data-ratio=&quot;0.66328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2P6Q8zQLmfZ4FoehZqNz9zp5lWzoSDiaWbATUPgshXiaLtFibFEYshIDbg/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3-5 服务生命周期管理&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;美团线上Kafka的服务器规模在万级别，随着服务规模的增长，我们对服务和机器本身的管理，也在不断迭代。我们的自动化运维系统能够处理大部分的机器故障和服务慢节点，但对于机器和服务本身的管理是割裂的，导致存在两类问题：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;状态语义存在歧义，无法真实反映系统状态，往往需要借助日志和指标去找到真实系统是否健康或者异常。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;状态不全面，异常Case需人工介入处理，误操作风险极大。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;为了解决这两类问题，我们引入了生命周期管理机制，确保能够真实反映系统状态。生命周期管理指的是从服务开始运行到机器报废停止服务的全流程管理，并且做到了服务状态和机器状态联动，无需人工同步变更。而且新的生命周期管理机制的状态变更由特定的自动化运维触发，禁止人工变更。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 TOR容灾&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;205&quot; data-ratio=&quot;0.3546875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2uyDLXxwcWc24YmP05yRsd1icg9lODl8gRiaUnxKjiad2tDXM28pXvYA6g/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3-6 TOR容灾挑战&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们从工程实现的角度，归纳总结了当前主流图神经网络模型的基本范式，实现一套通用框架，以期涵盖多种GNN模型。以下按照图的类型（&lt;/span&gt;&lt;span&gt;同质图、异质图和动态图&lt;/span&gt;&lt;span&gt;）分别讨论。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;318&quot; data-ratio=&quot;0.55&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUAT8icebFDacQnwjohib3fj2rTQrSvyewmCpwzok7HKOnhcCeZI5spE4hauSUnVw5sXsvic1VXDiaibUw/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3-7 TOR容灾&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TOR容灾保证同一个分区的不同副本不在同一个Rack下，如图3-7所示，即使Rack1整个发生故障，也能保证所有分区可用。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4 未来展望&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;过去一段时间，我们围绕降低服务端的读写延迟做了大量的优化，但是在服务高可用方面，依然有一些工作需要完成。未来一段时间，我们会将重心放在提升鲁棒性和通过各种粒度的隔离机制缩小故障域。比如，让客户端主动对一些故障节点进行避让，在服务端通过多队列的方式隔离异常请求，支持服务端热下盘，网络层主动反压与限流等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，随着美团实时计算业务整体的发展，实时计算引擎（&lt;/span&gt;&lt;span&gt;典型如Flink&lt;/span&gt;&lt;span&gt;）和流存储引擎（&lt;/span&gt;&lt;span&gt;典型如Kafka&lt;/span&gt;&lt;span&gt;）混合部署的模式越来越难以满足业务的需求。因此，我们需要在保持当前成本不变的情况下对Kafka进行独立部署。这就意味着需要用更少的机器（&lt;/span&gt;&lt;span&gt;在我们的业务模式下，用原来1/4的机器&lt;/span&gt;&lt;span&gt;）来承载不变的业务流量。如何在保障服务稳定的情况下，用更少的机器扛起业务请求，也是我们面临的挑战之一。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，随着云原生趋势的来临，我们也在探索流存储服务的上云之路。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5 作者简介&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;海源、仕禄、肖恩、鸿洛、启帆、胡荣、李杰等，均来自美团数据科学与平台部。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  | &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651756933&amp;amp;idx=1&amp;amp;sn=a23c294fe1873d6b2c50730e47eda608&amp;amp;chksm=bd1240c88a65c9de720b8568bf7cf90a365c1df45732a36493eb58cc1ff8cf8461cb4829f102&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于SSD的Kafka应用层缓存架构设计与实现&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651756933&amp;amp;idx=1&amp;amp;sn=a23c294fe1873d6b2c50730e47eda608&amp;amp;chksm=bd1240c88a65c9de720b8568bf7cf90a365c1df45732a36493eb58cc1ff8cf8461cb4829f102&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于SSD的Kafka应用层缓存架构设计与实现&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基于SSD的Kafka应用层缓存架构设计与实现&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt;&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=203083582&amp;amp;idx=1&amp;amp;sn=701022c664d42b54b55d43e6bc46056b&amp;amp;chksm=2f06167318719f65e90a8154a48e875f474c56e47b66aa6607f27c9ba6779ae062195720e6f6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团技术团队博客：Kafka文件存储机制那些事&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团技术团队博客：Kafka文件存储机制那些事&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651761795&amp;amp;idx=1&amp;amp;sn=49a812ee8b9bf1cae5bd088c53772007&amp;amp;chksm=bd1275ce8a65fcd8cb960cf727125c8462022c39e50a314bc79a60737a75909b26791c37536e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团酒旅数据治理实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团酒旅数据治理实践&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765958&amp;amp;idx=1&amp;amp;sn=8201546812e5a95a2bee9dffc6d12f00&amp;amp;chksm=bd12658b8a65ec9de2f5be1e96796dfb3c8f1a374d4b7bd91266072f557caf8118d4ddb72b07&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;前端&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765981&amp;amp;idx=1&amp;amp;sn=c2dd86f15dee2cbbc89e27677d985060&amp;amp;chksm=bd1265908a65ec86d4d08f7600d1518b61c90f6453074f9b308c96861c045712280a73751c73&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;算‍法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;算法&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765982&amp;amp;idx=1&amp;amp;sn=231b41f653ac7959f3e3b8213dcec2b0&amp;amp;chksm=bd1265938a65ec85630c546169444d56377bc2f11401d251da7ca50e5d07e353aa01580c7216&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;后端&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765964&amp;amp;idx=1&amp;amp;sn=ab6d8db147234fe57f27dd46eec40fef&amp;amp;chksm=bd1265818a65ec9749246dd1a2eb3bf7798772cc4d5b4283b15eae2f80bc6db63a1471a9e61e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数‍据&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数据&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765965&amp;amp;idx=1&amp;amp;sn=37e0c56c8b080146ce5249243bfd84d8&amp;amp;chksm=bd1265808a65ec96d3a2b2c87c6e27c910d49cb6b149970fb2db8bf88045a0a85fed2e6a0b84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;安‍全&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;安全&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765972&amp;amp;idx=1&amp;amp;sn=afe02ec92762c1ce18740d03324c4ac3&amp;amp;chksm=bd1265998a65ec8f10d5f58d0f3681ddfc5325137218e568e1cda3a50e427749edb5c6a7dcf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;And‍roid&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Android&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765973&amp;amp;idx=1&amp;amp;sn=32a23bf1d278dda0398f993ab60a697e&amp;amp;chksm=bd1265988a65ec8e630ef4d24b4946ab6bd7e66702c1d712481cf3c471468a059c470a14c30d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;iO‍S&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;iOS&lt;/span&gt;&lt;/a&gt;&lt;span&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765963&amp;amp;idx=1&amp;amp;sn=a3de9ef267d07d94118c1611776a4b28&amp;amp;chksm=bd1265868a65ec906592d25ad65f2a8516338d07ec3217059e6975fc131fc0107d66a8cd2612&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运‍维&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;运维&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765974&amp;amp;idx=1&amp;amp;sn=763c1e37d04acffd0142a2852ecfb000&amp;amp;chksm=bd12659b8a65ec8dfcfeb2028ef287fae7c38f134a665375ba420556ce5d2e4cf398147bd12e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;测‍试&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ5MTI5OA==&quot; data-alias=&quot;meituantech&quot; data-from=&quot;0&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVGibnsaEib3aNlqF0tOrA2RGEmNSbia2nnohE4Tpf95UyTiaSjDVbHRfY8WNBeTuLLTaVdSckkNyEx1Q/0?wx_fmt=png&quot; data-nickname=&quot;美团技术团队&quot; data-signature=&quot;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>05755f578c83453bbea5c6cb373aef28</guid>
<title>解决方案 - 自动化单元测试</title>
<link>https://toutiao.io/k/0geaxdx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h2&gt;&lt;p&gt;收到读者的咨询，情况是这样的：&lt;/p&gt;&lt;p&gt;“亮哥，看了你最近的 8 篇关于持续交付的文章，想咨询一下对于研发人员有没有可落地的方案，我是 PHP 研发工程师，项目中使用的是 Laravel 框架，负责的是电商业务，如何将持续交付使用起来呢？”&lt;/p&gt;&lt;p&gt;今天有时间，简单整理一下，首先我们要知道持续交付涉及的事情很多，涉及的人员角色也很广，比如包括需求分析人员、技术人员、运维人员、测试人员、客户 等。关于这个问题，文章中理论的部分很到位，目前我们主要从技术人员的角度考虑，做一些 &lt;strong&gt;技术导向且支持开发过程的测试&lt;/strong&gt; ，实现一个可落地的方案，等拿到代码后就可以在此基础上编写，虽然不是很全面，但可以在此基础上进行扩展。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;约定测试 Case&lt;/h2&gt;&lt;p&gt;以电商业务为例，简单列举 2 个测试 Case：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;下单(从购物车下单) -&amp;gt; 支付(优惠券 + 余额) -&amp;gt; 发货 -&amp;gt; 收货 -&amp;gt; 评价；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;下单(直接下单) -&amp;gt; 支付(微信) -&amp;gt; 发货 -&amp;gt; 收货 -&amp;gt; 退款(售后)；&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;实际场景中有很多 Case，比如就支付这块就有很多种排列组合，退款这块也会有很多排列组合，原理都是一样的，只要上面的两个会写了，其他的也就都会写了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;项目分析&lt;/h2&gt;&lt;p&gt;Case 中的不同环节的不同操作，对于后端来说都是可供调用的 API 接口，其实我们要实现的就是如何自动化按照流程自定义流程顺序调用这些 API 接口。&lt;/p&gt;&lt;p&gt;项目的框架是 Laravel，那么我们考虑的就是在框架中如何编写单元测试代码？这个比较简单，在 &lt;code&gt;tests&lt;/code&gt; 目录就可以编写测试用例。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;用例编写&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;安装 orchestra/testbench&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;composer require --dev &lt;span&gt;&quot;orchestra/testbench&quot;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;使用这个包，可以帮助编写 Laravel 项目测试，在这里面可以使用 Laravel 中的一些特性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建 BaseTestCase.php&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;&amp;lt;?php&lt;br/&gt;&lt;br/&gt;namespace Tests;&lt;br/&gt;&lt;br/&gt;abstract class BaseTestCase extends \Orchestra\Testbench\TestCase&lt;br/&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;要注意的是 extends &lt;code&gt;\Orchestra\Testbench\TestCase&lt;/code&gt; 而不是 &lt;code&gt;PHPUnit\Framework\TestCase&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建 OrderTest.php&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;&amp;lt;?php&lt;br/&gt;&lt;br/&gt;namespace Tests\Unit;&lt;br/&gt;&lt;br/&gt;use Tests\BaseTestCase;&lt;br/&gt;&lt;br/&gt;class OrderTest extends BaseTestCase&lt;br/&gt;{&lt;br/&gt;    /**&lt;br/&gt;     * 流程：&lt;br/&gt;     * 1.下单(从购物车下单)&lt;br/&gt;     * 2.支付(优惠券 + 余额)&lt;br/&gt;     * 3.发货&lt;br/&gt;     * 4.收货&lt;br/&gt;     * 5.评价&lt;br/&gt;     */&lt;br/&gt;    public &lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;testCase1&lt;/span&gt;&lt;/span&gt;()&lt;br/&gt;    {&lt;br/&gt;        // 1.下单(从购物车下单)&lt;br/&gt;&lt;br/&gt;        // 2.支付(优惠券 + 余额)&lt;br/&gt;&lt;br/&gt;        // 3.发货&lt;br/&gt;&lt;br/&gt;        // 4.收货&lt;br/&gt;&lt;br/&gt;        // 5.评价&lt;br/&gt;&lt;br/&gt;        /**&lt;br/&gt;         * 1.在每个流程中都模拟调用 HTTP API 接口；&lt;br/&gt;         * 2.断言 HTTP 状态码为 200；&lt;br/&gt;         * 3.如果还有业务状态码，需要断言业务状态码为正确返回的状态码；&lt;br/&gt;         */&lt;br/&gt;        &lt;br/&gt;        // 仅做效果演示，断言 200 = 200，总是真 &lt;br/&gt;        &lt;span&gt;$this&lt;/span&gt;-&amp;gt;assertEquals(200, 200);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 流程：&lt;br/&gt;     * 1.下单(直接下单)&lt;br/&gt;     * 2.支付(微信)&lt;br/&gt;     * 3.发货&lt;br/&gt;     * 4.收货&lt;br/&gt;     * 5.退款(售后)&lt;br/&gt;     */&lt;br/&gt;    public &lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;testCase2&lt;/span&gt;&lt;/span&gt;()&lt;br/&gt;    {&lt;br/&gt;        // 1.下单(直接下单)&lt;br/&gt;&lt;br/&gt;        // 2.支付(微信)&lt;br/&gt;&lt;br/&gt;        // 3.发货&lt;br/&gt;&lt;br/&gt;        // 4.收货&lt;br/&gt;&lt;br/&gt;        // 5.退款(售后)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;$this&lt;/span&gt;-&amp;gt;assertEquals(200, 200);&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;输出结果美化&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;composer require --dev codedungeon/phpunit-result-printer&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;使用这个工具，可以让输出结果更加美观、清晰明了。&lt;/p&gt;&lt;p&gt;在 &lt;code&gt;phpunit.xml&lt;/code&gt; 中配置 &lt;code&gt;printerClass = &quot;Codedungeon\PHPUnitPrettyResultPrinter\Printer&quot;&lt;/code&gt;，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;&amp;lt;?xml version=&lt;span&gt;&quot;1.0&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;?&amp;gt;&lt;br/&gt;&amp;lt;phpunit&lt;br/&gt;    printerClass=&lt;span&gt;&quot;Codedungeon\PHPUnitPrettyResultPrinter\Printer&quot;&lt;/span&gt;&lt;br/&gt;    colors=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;testsuites&amp;gt;&lt;br/&gt;        &amp;lt;testsuite name=&lt;span&gt;&quot;Laravel Test Suite&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;directory suffix=&lt;span&gt;&quot;Test.php&quot;&lt;/span&gt;&amp;gt;./tests&amp;lt;/directory&amp;gt;&lt;br/&gt;        &amp;lt;/testsuite&amp;gt;&lt;br/&gt;    &amp;lt;/testsuites&amp;gt;&lt;br/&gt;&amp;lt;/phpunit&amp;gt;&lt;/p&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;效果&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;./vendor/bin/phpunit tests/Unit/OrderTest.php&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;185&quot; data-backw=&quot;535&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34579439252336447&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/go9jpG3BuhT0YeicpYv8cf8HvGy2FE9M1C0K00HzpjfuVpHIxkAZobvs8qkmFQ4Rp3CjzJ0SmQLIMD92BrWYIdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;535&quot;/&gt;&lt;/p&gt;&lt;p&gt;两个绿色对勾，表示两个 Case 执行通过。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;疑问&lt;/h2&gt;&lt;p&gt;一、有同学会说了，这不是自动化的呀，需要手动执行一个命令才行，如果你们发布系统使用的 GitLab，那么在 GitLab 中增加一个环节即可，在这个环节中执行这个命令。&lt;/p&gt;&lt;p&gt;二、如果执行项目内全部的 case 怎么办？命令这样写就可以 &lt;code&gt;./vendor/bin/phpunit tests&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;三、Case 一定 API 测试吗？不一定，也可以测试自己的方法。&lt;/p&gt;&lt;p&gt;四、持续集成/持续交付与语言有关系吗？没关系。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;/h2&gt;&lt;p&gt;以上，就是一个可落地的方案，基本上跑通了，在此基础上编写就可以，根据自己的业务场景去完善吧。&lt;/p&gt;&lt;p&gt;在这做个小调查，大家在项目中都编写测试用例吗，为什么？欢迎大家在留言区评论。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐阅读&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448836808&amp;amp;idx=1&amp;amp;sn=bd6315970e64e472d9796ac7e2888f09&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;持续交付(1) - 软件交付的问题&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448836813&amp;amp;idx=1&amp;amp;sn=540c11de05f6138fadf7d8b55d110577&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;持续交付(2) - 配置管理&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448836820&amp;amp;idx=1&amp;amp;sn=861b7ba1bf4d6e9563e564fb9403ad1b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;持续交付(3) - 持续集成&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448836826&amp;amp;idx=1&amp;amp;sn=26174bd491f88d7e64ae1df26bd233c1&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;持续交付(4) - 测试策略的实现&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448836831&amp;amp;idx=1&amp;amp;sn=269d2cd64dbd698e3fb7396c878e2968&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;持续交付(5) - 部署流水线解析&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448836837&amp;amp;idx=1&amp;amp;sn=3b9950ca54d37c445af6caf420386bb4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;持续交付(6) - 构建与部署的脚本化&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448836842&amp;amp;idx=1&amp;amp;sn=67f9f89f8b3574b146ce2263b89c7641&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;持续交付(7) - 提交阶段&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448836847&amp;amp;idx=1&amp;amp;sn=bcf03ac871807f64fc5dfd87e8aa9393&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;持续交付(8) - 自动化验收测试&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NDM4MDIwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/go9jpG3BuhQHrM0sshKxdaibyDNjXooZvnwwy0yRjdhlXrtVUkJSvQib4Ppwib1v5HucaRc8WPtgvhPBicMeiadAv9Q/0?wx_fmt=png&quot; data-nickname=&quot;新亮笔记&quot; data-alias=&quot;XinLiangTalk&quot; data-signature=&quot;日拱一卒&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;307&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/go9jpG3BuhSP7wibS4BHtlu4hduFYq8VbSAgRic8ib6hdd6qTRGxYSic7UFF9yPyGd4pGUw1XicibFRlGHBe9RJ09Smw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b2e3d52a65d5242efbe5e810148447d1</guid>
<title>Google V8引擎浅析-内存管理</title>
<link>https://toutiao.io/k/gr4z26w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;0&quot; data-index=&quot;0&quot;&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;0&quot; data-index=&quot;0&quot;&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;0&quot; data-index=&quot;0&quot;&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index-1642080622978=&quot;0&quot; data-index-1642080622978=&quot;0&quot;&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index-1646223552202=&quot;0&quot; data-index-1646223552202=&quot;0&quot;&gt;大&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index=&quot;0&quot; data-index=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index=&quot;1&quot; data-index=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index=&quot;1&quot; data-index=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index-1642080622978=&quot;1&quot; data-index-1642080622978=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index-1646223552202=&quot;1&quot; data-index-1646223552202=&quot;1&quot;&gt;厂&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index=&quot;0&quot; data-index=&quot;2&quot;&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index=&quot;2&quot; data-index=&quot;2&quot;&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index=&quot;2&quot; data-index=&quot;2&quot;&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index-1642080622978=&quot;2&quot; data-index-1642080622978=&quot;2&quot;&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index-1646223552202=&quot;2&quot; data-index-1646223552202=&quot;2&quot;&gt;技&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index=&quot;0&quot; data-index=&quot;3&quot;&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index=&quot;3&quot; data-index=&quot;3&quot;&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index=&quot;3&quot; data-index=&quot;3&quot;&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index-1642080622978=&quot;3&quot; data-index-1642080622978=&quot;3&quot;&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index-1646223552202=&quot;3&quot; data-index-1646223552202=&quot;3&quot;&gt;术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;1&quot; data-index=&quot;4&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;4&quot; data-index=&quot;4&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;4&quot; data-index=&quot;4&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1642080622978=&quot;4&quot; data-index-1642080622978=&quot;4&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1646223552202=&quot;4&quot; data-index-1646223552202=&quot;4&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;1&quot; data-index=&quot;5&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;5&quot; data-index=&quot;5&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;5&quot; data-index=&quot;5&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1642080622978=&quot;5&quot; data-index-1642080622978=&quot;5&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1646223552202=&quot;5&quot; data-index-1646223552202=&quot;5&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index=&quot;2&quot; data-index=&quot;6&quot;&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index=&quot;6&quot; data-index=&quot;6&quot;&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index=&quot;6&quot; data-index=&quot;6&quot;&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index-1642080622978=&quot;6&quot; data-index-1642080622978=&quot;6&quot;&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index-1646223552202=&quot;6&quot; data-index-1646223552202=&quot;6&quot;&gt;坚&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index=&quot;2&quot; data-index=&quot;7&quot;&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index=&quot;7&quot; data-index=&quot;7&quot;&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index=&quot;7&quot; data-index=&quot;7&quot;&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index-1642080622978=&quot;7&quot; data-index-1642080622978=&quot;7&quot;&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index-1646223552202=&quot;7&quot; data-index-1646223552202=&quot;7&quot;&gt;持&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index=&quot;2&quot; data-index=&quot;8&quot;&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index=&quot;8&quot; data-index=&quot;8&quot;&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index=&quot;8&quot; data-index=&quot;8&quot;&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index-1642080622978=&quot;8&quot; data-index-1642080622978=&quot;8&quot;&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index-1646223552202=&quot;8&quot; data-index-1646223552202=&quot;8&quot;&gt;周&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index=&quot;2&quot; data-index=&quot;9&quot;&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index=&quot;9&quot; data-index=&quot;9&quot;&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index=&quot;9&quot; data-index=&quot;9&quot;&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index-1642080622978=&quot;9&quot; data-index-1642080622978=&quot;9&quot;&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index-1646223552202=&quot;9&quot; data-index-1646223552202=&quot;9&quot;&gt;更&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;3&quot; data-index=&quot;10&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;10&quot; data-index=&quot;10&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;10&quot; data-index=&quot;10&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1642080622978=&quot;10&quot; data-index-1642080622978=&quot;10&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1646223552202=&quot;10&quot; data-index-1646223552202=&quot;10&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;3&quot; data-index=&quot;11&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;11&quot; data-index=&quot;11&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;11&quot; data-index=&quot;11&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1642080622978=&quot;11&quot; data-index-1642080622978=&quot;11&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1646223552202=&quot;11&quot; data-index-1646223552202=&quot;11&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index=&quot;4&quot; data-index=&quot;12&quot;&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index=&quot;12&quot; data-index=&quot;12&quot;&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index=&quot;12&quot; data-index=&quot;12&quot;&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index-1642080622978=&quot;12&quot; data-index-1642080622978=&quot;12&quot;&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index-1646223552202=&quot;12&quot; data-index-1646223552202=&quot;12&quot;&gt;精&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index=&quot;4&quot; data-index=&quot;13&quot;&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index=&quot;13&quot; data-index=&quot;13&quot;&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index=&quot;13&quot; data-index=&quot;13&quot;&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index-1642080622978=&quot;13&quot; data-index-1642080622978=&quot;13&quot;&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index-1646223552202=&quot;13&quot; data-index-1646223552202=&quot;13&quot;&gt;选&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index=&quot;4&quot; data-index=&quot;14&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index=&quot;14&quot; data-index=&quot;14&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index=&quot;14&quot; data-index=&quot;14&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index-1642080622978=&quot;14&quot; data-index-1642080622978=&quot;14&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index-1646223552202=&quot;14&quot; data-index-1646223552202=&quot;14&quot;&gt;好&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;4&quot; data-index=&quot;15&quot;&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;15&quot; data-index=&quot;15&quot;&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;15&quot; data-index=&quot;15&quot;&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index-1642080622978=&quot;15&quot; data-index-1642080622978=&quot;15&quot;&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index-1646223552202=&quot;15&quot; data-index-1646223552202=&quot;15&quot;&gt;文&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTIwMzU5OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIqkT4YvuDMGzasrJTZJPpibQB9reXcCvNMudWicXTzI7iaoZGNicrr903icjKsFvuUeYI6yw0FbXzzlNicw/0?wx_fmt=png&quot; data-nickname=&quot;ELab团队&quot; data-alias=&quot;&quot; data-signature=&quot;分享技术新见解&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续探索V8引擎技术的主旨，接着来我们再看下V8引擎底层，对内存管理方面还有哪些值得学习的地方。如果大家对上两次分享感兴趣的话，可以移步到：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTIwMzU5OQ==&amp;amp;mid=2247488828&amp;amp;idx=1&amp;amp;sn=eb6998cd39ac1dcdadf3c9dfb294639e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Google V8引擎浅析&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTIwMzU5OQ==&amp;amp;mid=2247490528&amp;amp;idx=1&amp;amp;sn=38301ef4c16251dc19829a3e18acefc7&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Google V8引擎浅析-面向对象&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，Javascript语言是没有能力管理内存和自动垃圾回收的，最直观的判断就是并没有这些方面的api及主动处理机制，这些能力完全依赖了底层引擎的处理，想要弄清楚V8引擎的性能为何出众，更加需要了解其重要的内存管理及垃圾回收的策略是如何运行的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内存管理&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存作为计算机的最重要部分之一，它是与CPU进行沟通的桥梁，程序运行时CPU需要调用的指令和数据只能通过内存获取。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。内存一般是半导体存储单元，包括了ROM + RAM + Cache，其中最重要的就是RAM部分。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32592592592592595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuIwPnaTxKQgHvetDDJPnKuu21ibR44bhibKHMGc1GxPE3EmKPh5WSWicVtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存的生命周期一般包括：分配内存大小 &amp;gt; 使用内存（读 or 写）&amp;gt; 不需要时进行释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行js代码时，内存空间使用包括了堆内存和栈内存。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;栈&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小而连续，数组结构，由系统自动分配相对固定大小的内存空间，并由系统自动释放，遵循LIFO后进先出的规则，主要职责是javascript中存储局部变量及管理函数调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基础数据类型的变量都是直接存储在栈中，复杂类型数据会将对象的引用（实际存储的指针地址）存储在栈中，数据本身存储在堆中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个函数的调用时，解释器都会现在栈中创建一个调用栈（call stack）来存储函数的调用流程顺序。然后把该函数添加进调用栈，解释器会为被添加进的函数再创建一个栈帧（Stack Frame）并立即执行。如果正在执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈并执行。直到这个函数执行结束，对应的栈帧也会被立即销毁。栈帧中一般会存放信息包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;函数的返回地址和参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;临时变量：函数局部变量+编译器自动生成的其他临时变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数调用的上下文&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2765957446808511&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuIsbfbMql2b7TfwbN5I2lUa5Dic6XMB8pnz68QQwPNz0hZjibRvKicSgVdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2444&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（函数的调用栈顺序）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考：为什么大部分高级语言都用栈来管理函数调用？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以从函数自身的特性来分析这个问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;函数具有可被调用的特性，代码执行控制权从最开始父函数调用子函数开始，移交给子函数，再由子函数执行完成后又移交给父函数，这个控制权的转移证明了：&lt;strong&gt;函数调用者的生命周期总是长于被调用者（后进），而且被调用者的生命周期总是先于调用者结束（先出）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数还有作用域的限制，在执行的时候，定义在函数内部的临时变量与外部环境隔离，只能在函数内访问，外部函数无权访问，当函数执行介绍后，临时变量也会随之被销毁。关于临时变量的资源占用情况证明了：&lt;strong&gt;被调用者的资源分配总是晚于调用者（后进），同时被调用者的资源释放却又总先于调用者（先出）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的函数的生命周期及资源分配情况来看，我们可以发现使用栈结构来管理函数调用，是最优解&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;堆&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考：有了栈为什么还需要堆？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈空间是连续的，在栈上分配资源和销毁资源的速度非常快，分配空间和销毁空间只需要移动下指针就可以了。但是如果想在内存中分配一块连续的大空间是非常难的，栈空间是有上限的，一旦函数循环嵌套次数过多，或者分配的数据过大，就会造成栈溢出问题，所以我们需要另外一种数据结构来存储大数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.735981308411215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuI5iavcQQJoIib38eHqYC2licwNMkAZ1B4fqyQaO39rSuvexBW4VB8wguMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;856&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3294314381270903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuIiaCNlS620WsjgnEtz2AmGeA35l7YGm2T0ewqIg25N4aRcW1OHhxBbmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1196&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对栈内存结构来说，堆内存内部结构比较复杂，V8引擎内存分配和垃圾回收机制复杂的设计也重点体现在堆内存管理上，下图中是V8引擎内存结构总览，我们来重点剖析下堆内存的结构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6179640718562874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuITzNfA69msChwVUicqkz3DtFxKMibIZqFgtiadPxCJJibtP4iczBvRicgRpFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1670&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要分为以下几个区域：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新生代主要是由两个半空间（semi space）组成，一个是from space，一个是to space，空间的大小由--min_semi_space_size(初始值) 和 --max_semi_space_size(最大值) 两个标志来控制，感兴趣可以看下&lt;span&gt;V8源码&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;对于变量的定义，在64位和32位操作系统中最大值分别为64MB和32MB，新生代空间主要是用于新对象的存储，后面配合垃圾回收再深入讲下gc的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分存储的是经过多次gc后仍在新生代中存在的对象，空间的大小由--initial_old_space_size(初始值) 和--max_old_space_size(最大值) 两个标志来控制，代码&lt;span&gt;见此处&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;这个区域包括了两个部分：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Old pointer space: 存放存活下来包含指向其他对象指针的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Old data space：存放仅保存数据的对象，不含指向其他对象指针的对象，字符串等数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Large object space (大对象区）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是大于其他空间大小限制的对象存储的地方，避免大对象的频繁拷贝导致性能变差。大对象是不会被垃圾回收的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Code space(代码区): 即时（JIT）编译器存储编译代码块的地方。唯一可执行代码的空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Cell space (单元区)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Property cell space(属性单元区)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Map space(map 区域)：用来存放对象的map信息，可以回归下之前讲过的每个对象的隐藏类，为了快速定位，单独开辟了一个区域来用来存放这部分信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Stack（栈内存）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;垃圾回收&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;什么是垃圾回收(GC)？&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GC = Garbage Collection，是指在内存空间进行垃圾回收的过程。如果不做GC，容易造成内存空间大小超过上限而导致程序的崩溃，对比C/C++等语言中，开发者需要手动处理内存的分配和释放，人工控制优势是在于可以细粒度控制，不足在于人工会导致失误率的提高，分配或释放太晚或太早会造成引用错误和内存泄漏，同时也增加了开发者的心智负担。一些语言例如js、java等，会选择在语言运行时中内置垃圾回收机制，虽然失去细颗粒度的控制，但得到了更高的开发效率，也解耦了对底层api的依赖，提高了内存的安全性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Javascript的标准ECMAScript并没有对GC做相关的要求，GC完全依赖底层引擎的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆内存中存储着动态数据，随着代码的运行，这些数据随时都可能会发生变化，而且这部分数据可能会相互引用，引擎需要不断地遍历找到这些数据相互之间的关系，从而发现哪些数据是&lt;strong&gt;非活动对象&lt;/strong&gt;并对其进行gc操作，所以gc的算法及策略的好坏，直接影响着整个引擎执行代码的性能，这部分是非常关键的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;如何判断非活跃对象？&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;判断对象是否是活跃的一般有两种方法，引用计数法和可访问性分析法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;引用计数法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;V8中并没有使用这种方法，因为每当有引用对象的地方，就加1，去掉引用的地方就减1，这种方式无法解决A与B循环引用的情况，引用计数都无法为0，导致无法完成gc&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可访问性分析法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;V8中采用了这种方法，将一个称为&lt;strong&gt;GC Roots&lt;/strong&gt;的对象（在浏览器环境中，GC Roots可以包括：全局的window对象、所有原生dom节点集合等等）作为所有初始存活的对象集合，从这个对象出发，进行遍历，遍历到的就认为是&lt;strong&gt;可访问的，为活动对象，需要保留&lt;/strong&gt;；如果没有遍历到的对象，就是&lt;strong&gt;不可访问的，这些就是非活动对象，可能就会被垃圾回收&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28826151560178304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuI1FpYx75MpQqn3EmoxTpOhwBIBZjqesz4SDBPAVza0zsQg12KEXFUAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;代际假说&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代际假说（The Generational Hypothesis）垃圾回收领域中的一个重要术语，它有两个特点&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;大部分对象在内存中存活时间很短，比如函数内部声明变量，块级作用域中的变量等，这些代码块执行完分配的内存就会被清掉&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不死的对象会活的更久，比如全局的window、Dom、全局api等对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于代际假说的理论，在V8引擎中，垃圾回收算法被分为两种，一个是Major GC，主要使用了Mark-Sweep &amp;amp; Mark-Compact算法，针对的是堆内存中的老生代进行垃圾回收；另外一个是Minor GC，主要使用了Scavenger算法，针对于堆内存中的新生代进行垃圾回收。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;Scavenger算法&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是在新生代内存中使用的算法，速度更快，空间占用更多的算法。New space区域分为了两个半区，分别为from-space和to-space。不断经过下图中的过程，在两个空间的角色互换中，完成垃圾回收的过程。每次都会有对象复制的操作，为了控制这里产生的时间成本和执行效率，往往新生代的空间并不大。同时为了避免长时间之后，某些对象会一直积压在新生代区域，V8制定了&lt;strong&gt;晋升机制&lt;/strong&gt;，满足任一条件就会被分配到老生代的内存区中。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;经历一次Scavenger算法后，仍未被标记清除的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进行复制的对象大于to space空间大小的25%&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9915014164305949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuIVer4bqRoosxv5e0qL75arQt46tsGkATBgg3g8o3BJrP6h4TPTib2J4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1412&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;Mark-Sweep &amp;amp; Mark-Compact算法&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是老生代内存中的垃圾回收算法，标记-清除 &amp;amp; 标记-整理，老生代里面的对象一般占用空间大，而且存活时间长，如果也用Scavenger算法，复制会花费大量时间，而且还需要浪费一半的空间。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;标记-清除过程：与之前讲过的可访问性分析一致，从GC Root开始遍历，标记完成后，就直接进行垃圾数据的清理工作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7642857142857142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuIMib8Zjnx1KPtdPZS95yHNTfQ47j13zlOwHuDPGwzdZmEBfmq5ib8yx1w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;420&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;标记-整理过程：清除算法后会产生大量不连续的内存碎片，碎片过多会导致后面大对象无法分配到足够的空间，所以需要进行整理，第一步的标记是一样的，但标记完成活跃对象后，并不是进行清理，而是将所有存活的对象向一端移动，然后清理掉这端之外的内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.720873786407767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuIdjuQaMP56vgRetpycKEibHogypiajNeMwibdd0yo3ZRFszbf4twliaXQLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;824&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优化策略&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为叫做全停顿（Stop-The-World）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.140485312899106&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuISWyCRdcHb3dVJicYU4iaJVrg3CmwFOOsLvgXmdnQFgw6dbPDic7WrU8Pg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1566&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;STW会造成系统周期性的卡顿，对实时性高的和与时间相关的任务执行成功率会有非常大的影响。例如：js逻辑需要执行动画，刚好碰到gc的过程，会导致整个动画卡顿，用户体验极差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了降低这种STW导致的卡顿和性能不佳，V8引擎中目前的垃圾回收器名为Orinoco，经过多年的不断精细化打磨和优化，已经具备了多种优化手段，极大地提升了GC整个过程的性能及体验。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;并行回收&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲，就是主线程执行一次完整的垃圾回收时间比较长，开启多个辅助线程来并行处理，整体的耗时会变少，所有线程执行gc的时间点是一致的，js代码也不会有影响，不同线程只需要一点同步的时间，在新生代里面执行的就是并行策略。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40389294403892945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuI6eJkQ3nNCLO6WCsdia4qCicTQUHqLpe74fa9yXaCg9I0P3UbjkgT3mAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;增量回收&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;并行策略说到底还是STW的机制，如果老生代里面存放一些大对象，处理这些依然很耗时，Orinoco又增加了增量回收的策略。将标记工作分解成小块，插在主线程不同的任务之间执行，类似于React fiber的分片机制，等待空闲时间分配。这里需要满足两个实现条件:&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;随时可以暂停和启动，暂停要保存当前的结果，等下一次空闲时机来才能启动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;暂停时间内，如果已经标记好的数据被js代码修改了，回收器要能正确地处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1836734693877551&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuIs7R66hyxGGhoGHnVZvCmZ357ad0ianCdhXAbkiaW6VMWzv5pOGst17Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1078&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面要讲到的就是Orinoco引入了3色标记法来解决随时启动或者暂停且不丢之前标记结果的问题&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三色标记法&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;三色标记法的规则如下：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最开始所有对象都是&lt;strong&gt;白色&lt;/strong&gt;状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从GC Root遍历所有可到达的对象，标记为&lt;strong&gt;灰色&lt;/strong&gt;，放入待处理队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从待处理队列中取出灰色对象，将其引用的对象标记为灰色放入待处理队列，自身标记为&lt;strong&gt;黑色&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重复3中动作，直到灰色对象队列为空，此时白色对象就是垃圾，进行回收。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2092283214001591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuIVichibAKEiaDM2spvXUHbKWdiam6WBAOvu1O6Bs8BVIEXpUZmH7aFRQQVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2514&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾回收器可以依据当前内存中有没有灰色节点，来判断整个标记是否完成，如果没有灰色节点了，就可以进行清理工作了。如果还有灰色标记，当下次恢复垃圾回收器时，便从灰色的节点开始继续执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面将要解决由于js代码导致对象引用发生变化的情况，Orinoco借鉴了写屏障的处理办法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;写屏障（write-barrier）&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一旦对象发生变化时，如何精确地更新标记的结果，我们可以分析下一般js执行过程中带来的对象的变化有哪些，其实主要有2种：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;标记过的黑色或者灰色的对象不再被其他对象所引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入新的对象，新的对象可能是白色的，面临随时被清除的危险，导致代码异常&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种问题不大，在下次执行gc的过程中会被再次标记为白色，最后会被清空掉；第二种就使用到了写屏障策略，一旦有黑色对象引用到了白色对象，系统会强制将白色对象标记成为灰色对象，从而保证了下次gc执行时状态的正确，这种模式也称为&lt;strong&gt;强三色原则。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;并发回收&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说三色标记法和写屏障保证了增量回收的机制可以实现，但依然改变不了需要占用主线程的情况，一旦主线程繁忙，垃圾回收依然会影响性能。所以增加了并发回收的机制。V8里面的并发机制相对复杂，简化来看，当主线程运行代码时，辅助线程并发进行标记，当标记完成后，主线程执行清理的过程时，辅助线程也并行执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41228070175438597&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIrtGzkBib2lViczhDcuiauMRuIMp2WHATfjBF21dLMZsCV4EoSwibmhib3y5R49UjmI198lzf6NYgDVUYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;912&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;摘自V8官网的&lt;span&gt;blog&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;: V8 中的垃圾收集器自诞生以来已经走过了漫长的道路。向现有 GC 添加并行、增量和并发技术是一项多年的努力，但已经取得了回报，将大量工作转移到后台任务。它极大地改善了暂停时间、延迟和页面加载，使动画、滚动和用户交互更加流畅。并行Scavenger算法将主线程年轻代垃圾收集的总时间减少了大约 20%–50%，具体取决于工作负载。空闲时间gc策略可以在 Gmail 空闲时将其 JavaScript 堆内存减少 45%。并发标记和清除策略已将重型 WebGL 游戏的暂停时间减少了多达 50%。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码建议&lt;/h1&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如何避免内存泄漏&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;尽量减少创建全局变量，尽量使用局部变量&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    a = 1; // 等价于window.a = 1&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定时器隐患&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const a = []; //手动不清掉定时器，a将无法被回收&lt;br/&gt;const foo = () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = 0; i &amp;lt; 1000; i++) {&lt;br/&gt;        a.push(i);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;window.setInterval(foo, 1000);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;闭包的错误使用&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; a = 123;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; a;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;const bar = foo();&lt;br/&gt;console.log(bar()); // 存在变量引用其返回的匿名函数，导致作用域无法得到释放&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;推荐弱引用&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;es6中新增了：WeakMap和WeakSet，它的键名所引用的对象均是弱引用，弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存。&lt;/p&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;DOM引用&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const elements = {&lt;br/&gt;    button: document.getElementById(&lt;span&gt;&#x27;button&#x27;&lt;/span&gt;)&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;removeButton&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    document.body.removeChild(document.getElementById(&lt;span&gt;&#x27;button&#x27;&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;// removeChild 清除了元素，但对象引用中还存在，要手动清除引用&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;V8源码: &lt;em&gt;https://source.chromium.org/chromium/chromium/src/+/main:v8/src/heap/heap.cc;l=5236?q=FLAG_min_semi_space_size&amp;amp;ss=chromium%2Fchromium%2Fsrc:v8%2F&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;见此处: &lt;em&gt;https://source.chromium.org/chromium/chromium/src/+/main:v8/src/heap/heap.cc;l=5177?q=max_old_space_size&amp;amp;ss=chromium%2Fchromium%2Fsrc:v8%2F&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;blog: &lt;em&gt;https://v8.dev/blog/trash-talk&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Trash talk: the Orinoco garbage collector: &lt;em&gt;https://v8.dev/blog/trash-talk&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Memory Management in V8, garbage collection and improvements: &lt;em&gt;https://dev.to/jennieji/memory-management-in-v8-garbage-collection-and-improvements-18e6&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;WIKI:Tracing garbage collection: &lt;em&gt;https://en.wikipedia.org/wiki/Tracing_garbage_collection&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;Google I/O 2013 - Accelerating Oz with V8: Follow the Yellow Brick Road to JavaScript Performance: &lt;em&gt;https://www.youtube.com/watch?v=VhpdsjBUS3g&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;Garbage-First Garbage Collection: &lt;em&gt;http://citeseerx.ist.psu.edu/viewdoc/download?spm=a2c6h.12873639.article-detail.15.c8451ddb05xXlv&amp;amp;doi=10.1.1.63.6386&amp;amp;rep=rep1&amp;amp;type=pdf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c807e2dafd9841f272490c6d23f47aa7</guid>
<title>以小窥大：IO 卡顿探寻苹果文件系统</title>
<link>https://toutiao.io/k/xbnkwtv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：rhythmzhang，腾讯 WXG 客户端开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从一个不寻常的 I/O 卡顿入手，发现苹果 APFS 的一个严重 bug。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近期有用户反馈频繁遇到了一个奇怪的严重卡顿问题，微信刷朋友圈和查看聊天都非常卡，主线程卡在最普通的 access, rename 等常见 I/O 系统调用，并且经常卡上百 ms，而这种场景的底层接口一般都没干什么大量的 I/O 操作。比如 access 接口也就是获取文件是否存在的轻量操作，正常耗时都只有几十 us 而已，远达不到此时的上百 ms 耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、分析问题&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;寻找关键堆栈&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆栈上看，只是很常规的视频号卡片列表滑动时，触发了下载图片和查图片本地缓存的逻辑，通过 access 接口同步查本地图片是否存在，有则直接展示，否则从网络下载图片，下载完成时再尝试删除可能已有的旧文件。这完全是一个非常简单的图片缓存和加载逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过搜寻卡顿报告，发现子线程都疑似存在大量的并发 I/O 操作，那是否卡顿的主因是和并发 I/O 有关呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尝试触发子线程并发 I/O 这个目录的图片，并打日志输出 access 接口的平均耗时，一切正常。走查功能也一切正常，毫无卡顿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有同学说可能是目录下文件过多才会有 I/O 问题，在对应目录下构造了足够多的文件，再次走查业务功能，还是一切正常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终在多次试验和猜测后，构造出了一个高概率复现的场景，在对应目录下写入10万个小图片伪造图片数据，并触发并发 I/O，此时问题终于复现了。这个时候如果触发视频号卡片滑动，朋友圈卡片滑动，就大概率必现严重的滑动掉帧和卡顿了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;构造必现代码&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概知道了必现路径后，我们构造出了一个必现代码，打开 Instruments 的 System Trace 分析，结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3883089770354906&quot; data-type=&quot;jpeg&quot; data-w=&quot;958&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasbibnicqK54k5Nia6MYIWFjBianYnT2ldkOUKUyHqia9Fcs3YFD0mVB5ggu2qAKZXtLBicK9sjX9hW51dQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现 access 等常规 I/O 接口的平均耗时依旧很低只有几十 us，但等待耗时波动很大，可以达到140 ms，也就导致了主线程每次查询图片存在状态时，单次调用耗时超过了140 ms，而滑动过程中大概存在十几次这样的行为，那最终就是每次滑动都要因为这些 I/O wait time 导致滑动耗时数秒之久，甚至个别情况下还会因此滑动卡死触发 watchdog。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续分析 Instruments 报告，发现等待的主因如下：will wait for event/lock xxx.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31023784901758017&quot; data-type=&quot;jpeg&quot; data-w=&quot;967&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasbibnicqK54k5Nia6MYIWFjBiavwEBa6uibicabDp4IicV0nCOAiaF0RX5ia3iabM5ceqL03Z89iaEOy9VaTg5A/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过前面的研究，我们已经能够构造一个必现 demo 了。大概如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;特定目录下写入大约10万个文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主线程触发频繁的 access 接口调用，统计平均耗时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子线程触发对该目录下的文件遍历并频繁的 rename 操作调用，统计平均耗时&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果2和3是同一个目录且当前目录文件数较多时，那么会高概率稳定复现平均 access 和 rename 等 I/O 接口调用 调用耗时过高的问题。而其它情况组合下，都不会复现这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试工程跑在 MacBook Pro(2019) macOS 12.3 上，会定时 benchmark 测 access 接口耗时。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  int retry = 5;&lt;br/&gt;  long long duration = benchmark(retry,^{&lt;br/&gt;    access(path.UTF8String, F_OK);&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(duration &amp;gt; 1000 * retry) {&lt;br/&gt;    //avg &amp;gt;1 ms.&lt;br/&gt;    LOG_P(&lt;span&gt;&quot;lag: avg access %.3f ms&quot;&lt;/span&gt;,duration*1.f/1000/retry);&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 APFS 分区的该目录下会频繁因大目录并发 I/O 遍历导致 access 超时问题，log输出如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  lag: avg access 2.134 ms&lt;br/&gt;  lag: avg access 11.859 ms&lt;br/&gt;  lag: avg access 5.483 ms&lt;br/&gt;  lag: avg access 5.259 ms&lt;br/&gt;  lag: avg access 4.634 ms&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时在 x86 的 ssd 设备上都能稳定复现出 access 调用平均耗时 1ms 以上，个别情况下可以达到几十ms，确实令人费解。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;dtrace 分析&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然 Instruments 告诉我们耗时的主因是 wait for lock，那接下来我们尝试分析下到底在 wait 什么 lock 最多。这就需要借助于 dtrace 来进一步分析了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DTrace 即动态追踪技术（Dynamic Tracing），是内核提供的高级动态调试能力，可以帮助开发者快速调试定位一些奇怪的疑难杂症。操作系统会在内核的一些关键调用操作里提供 trace 代码执行的入口，我们可以通过注入 trace 命令或代码来实现自定义 trace 分析。Xcode Instruments 本质就是基于内核提供的 dtrace 能力来封装并实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 iOS 平台不支持自定义 dtrace （虽然Instruments 就是基于 dtrace 的，但 iOS 即便越狱了也没办法触发自定义 dtrace 行为），
我们只有基于 macOS 打开 dtrace 分析下这个时候到底发生了什么。运行 demo ，多次跑如下 dtrace 命令分析 demo 运行状态。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sudo dtrace -n &lt;span&gt;&#x27;lockstat:::adaptive-block { @[stack()] = sum(arg1); }&#x27;&lt;/span&gt; -p 95637&lt;br/&gt;sudo dtrace -n &lt;span&gt;&#x27;profile-999 /arg0/ { @[stack()] = count(); }&#x27;&lt;/span&gt;  -p 95806&lt;br/&gt;sudo lockstat sleep 10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得到的 dtrace 相关数据如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  kernel`0xffffff8005aa6990+0x72&lt;br/&gt;  apfs`apfs_vnop_rename+0x94&lt;br/&gt;  kernel`vn_rename+0x4ae&lt;br/&gt;  kernel`0xffffff8005d42020+0xb12&lt;br/&gt;  kernel`unix_syscall64+0x1fb&lt;br/&gt;  kernel`hndl_unix_scall64+0x16&lt;br/&gt;  1367&lt;br/&gt;&lt;br/&gt;  kernel`lck_mtx_lock_spinwait_x86+0x2be&lt;br/&gt;  kernel`vn_rename+0x4ae&lt;br/&gt;  kernel`0xffffff8005d42020+0xb12&lt;br/&gt;  kernel`unix_syscall64+0x1fb&lt;br/&gt;  kernel`hndl_unix_scall64+0x16&lt;br/&gt;  2242&lt;br/&gt;&lt;br/&gt;  kernel`0xffffff8005aa67f0+0x7e&lt;br/&gt;  kernel`namei+0x9f7&lt;br/&gt;  kernel`0xffffff8005d375a0+0x79&lt;br/&gt;  kernel`0xffffff8005d42020+0x35b&lt;br/&gt;  kernel`unix_syscall64+0x1fb&lt;br/&gt;  kernel`hndl_unix_scall64+0x16&lt;br/&gt;  2262&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;R/W writer blocked by readers: 239 events &lt;span&gt;in&lt;/span&gt; 10.048 seconds (24 events/sec)&lt;br/&gt;&lt;br/&gt;Count indv cuml rcnt      abs Lock                   Caller                  &lt;br/&gt;-------------------------------------------------------------------------------&lt;br/&gt;  227  95%  95% 0.00 13385718 0xffffff8b638223e0     apfs_vnop_lookup+0x2f6  &lt;br/&gt;   11   5% 100% 0.00  8140855 0xffffff8b638223e0     apfs_vnop_getattr+0xc4  &lt;br/&gt;    1   0% 100% 0.00  2610265 0xffffff90339a97b0     omap_get+0x7c           &lt;br/&gt;-------------------------------------------------------------------------------&lt;br/&gt;&lt;br/&gt;R/W reader blocked by writer: 192 events &lt;span&gt;in&lt;/span&gt; 10.021 seconds (19 events/sec)&lt;br/&gt;&lt;br/&gt;Count indv cuml rcnt      abs Lock                   Caller                  &lt;br/&gt;-------------------------------------------------------------------------------&lt;br/&gt;  129  67%  67% 0.00  6408120 0xffffff8b638223e0     IORWLockWrite+0x90      &lt;br/&gt;   22  11%  79% 0.00    23902 0xffffff99cd1fbc00     IORWLockWrite+0x90      &lt;br/&gt;   12   6%  85% 0.00    28194 0xffffff804e970608     IORWLockWrite+0x90      &lt;br/&gt;    4   2%  87% 0.00    18808 0xffffff8048892e08     IORWLockWrite+0x90      &lt;br/&gt;    3   2%  89% 0.00    41491 0xffffff803825e608     lck_rw_lock_exclusive_check_contended+0x93&lt;br/&gt;    2   1%  90% 0.00    22725 0xffffff99cd1fbc80     IORWLockWrite+0x90      &lt;br/&gt;    2   1%  91% 0.00    78215 0xffffff8b666c2610     IORWLockWrite+0x90      &lt;br/&gt;    2   1%  92% 0.00    34049 0xffffff8b666c22c8     IORWLockWrite+0x90      &lt;br/&gt;    2   1%  93% 0.00    23949 0xffffff8b666bc4c0     IORWLockWrite+0x90      &lt;br/&gt;    2   1%  94% 0.00    28546 0xffffff8b666b94c0     IORWLockWrite+0x90      &lt;br/&gt;    2   1%  95% 0.00    38088 0xffffff804e97ab08     lck_rw_lock_exclusive_check_contended+0x93&lt;br/&gt;    2   1%  96% 0.00    17158 0xffffff803dc78d08     0xffffff8005aa77d0      &lt;br/&gt;    2   1%  97% 0.00    18658 0xffffff803dc78d08     IORWLockWrite+0x90      &lt;br/&gt;    2   1%  98% 0.00    29096 tcbinfo+0x38           IORWLockWrite+0x90      &lt;br/&gt;    1   1%  98% 0.00    52994 0xffffff8b666be7a0     IORWLockWrite+0x90      &lt;br/&gt;    1   1%  99% 0.00    20135 0xffffff8048892e08     0xffffff8005aa77d0      &lt;br/&gt;    1   1%  99% 0.00    18584 0xffffff80345de608     IORWLockWrite+0x90      &lt;br/&gt;    1   1% 100% 0.00    13805 0xffffff803825e608     IORWLockWrite+0x90      &lt;br/&gt;-------------------------------------------------------------------------------&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 dtrace 的 lockstat 数据，大概率怀疑是 kernel 层的 APFS 相关的  lock 出了问题，那为什么 APFS lock 会导致如此严重的问题呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Hopper 分析&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rename 和 access 都是系统调用，他们都是 XNU 里 VFS 注册的系统服务。APFS 的系统支持是通过系统的 apfs.kext 内核扩展载入的，我们通过 Hopper 打开 apfs.kext，分析下 APFS 对应的 rename 或 access 里到底干了什么&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;_apfs_vnop_renamex&lt;br/&gt;{&lt;br/&gt;    r12 = arg0;&lt;br/&gt;    r14 = *(int32_t *)(arg0 + 0x40);&lt;br/&gt;    r14 = r14 &amp;amp; 0xfffffff7;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (r14 &amp;lt; 0x3) goto loc_5ad56;&lt;br/&gt;&lt;br/&gt;loc_5ad47:&lt;br/&gt;    rax = 0x2d;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (r14 != 0x4) goto .l17;&lt;br/&gt;&lt;br/&gt;loc_5ad56:&lt;br/&gt;    var_C8 = 0x0;&lt;br/&gt;    var_170 = 0x0;&lt;br/&gt;    var_190 = 0x0;&lt;br/&gt;    r15 = _vfs_fsprivate(_vnode_mount(*(r12 + 0x8))); //获取目录&lt;br/&gt;    r13 = _vnode_fsnode(*(r12 + 0x8));&lt;br/&gt;    var_58 = _vnode_fsnode(*(r12 + 0x20));&lt;br/&gt;    //... ....&lt;br/&gt;&lt;br/&gt;    rax = _current_thread();&lt;br/&gt;    var_120 = rax;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (rbx != rax) {&lt;br/&gt;            _lck_rw_lock_shared(var_108); // 获取锁&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;apf.kext 的代码里 vfs_fsprivate 返回了一个结构，这个结构存了每个 vnode 相关的附加字段，比如这里会疑似返回一个目录相关的锁，每次执行 rename 接口时，会取出目录锁，尝试加锁处理，而在 apfs.kext 代码里还有很多处额外的高频加锁逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过进一步 System Trace 验证，当并发 I/O 遍历的文件目录是同一个时，Instruments 报告里的 will wait for lock xxx 会显示为同一个，大概率证明了 APFS 内部存在某种目录锁的结构，当对同一个目录的文件进行遍历 I/O 操作时，都会先请求加解锁。而在超大目录遍历时这个加锁导致的等待问题会急剧扩大，导致锁等待超时，最终可能导致了并发 I/O 速度骤降的问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对比 HFS+&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在同一台电脑上构造了两个不同的磁盘分区：APFS 和 HFS+，分别在各自分区下的同一路径下写入了相同数据的10万个文件，接着开始跑同样的测试程序，又发现了更出人意料的结论：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HFS+ 测试如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43993231810490696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasbibnicqK54k5Nia6MYIWFjBiaQ0kuw3PUuxz1GoDsgHrEXqkUB3XzibLVmut90OvUWwkBp0iarN3icoIFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;591&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;APFS 测试如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45346869712351945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasbibnicqK54k5Nia6MYIWFjBiaU6JC0QOynViaA0ibnYeicb1LvBhKpJPvn6vHQRyhdytL3KfERDTdicF0TA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;591&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过多次对比测试，发现在这种超大目录文件遍历的并发 I/O 情况下，HFS+ 的平均读写速度要比 APFS 快 8~20 倍，想不到 APFS 竟然反而比 HFS+ 要慢那么多。这个问题在 macOS 12.3 和 iOS 15.4 上都可以稳定构造出必现测试用例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、解决问题&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到开始的卡顿问题，通过构造 demo 我们稳定复现了该问题，同时继续分析用户的相关数据，确认了用户遇到问题时的情况的确和我们最终 demo 构造的基本一致，至此又一个奇怪的卡顿问题终于找到原因了：&lt;strong&gt;超大目录导致了并发 I/O 时性能急剧下降。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然我们已经明白了问题的根因超大目录结构导致的锁等待超时问题，那解决问题的办法就简单多了，将目录拆分为二级目录即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过部分统计分析发现的确有很大一批老用户也存在这个超大目录结构的问题，目前微信已经将大部分超大目录逐步拆分为二级目录了。通过每级1000 个文件/夹，二级目录可以存储100万个文件，绰绰有余了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过测试，将该目录拆分为二级目录并缓解单目录文件过多的情况后，再也没有遇到类似的并发 I/O 卡顿的情况了。另外，该问题已经反馈给苹果，苹果内部也开了 radar ，希望可以进一步提升 APFS 性能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一些坑&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合已有数据分析，发现苹果的文件操作里还存在一些坑，如下：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;苹果在 &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW2&quot; data-linktype=&quot;2&quot;&gt;File System Programming Guide&lt;/a&gt; 里建议 app 用 tmp/ 目录来存储临时文件，并且说系统会在 app 不运行时自动删除 tmp/ 目录的数据，但是实测，大概率不会，因为文档写的是 may purge。极端情况下该目录可能会存在 &amp;gt;90G 的占用。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;WebKit&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebKit 的网络缓存默认在 /Library/Caches/WebKit/NetworkCache/ ，按照 WebKit 源码 NetworkCacheStorage 里的实现，WebKit 会采取一定随机+权重的方式删除网络缓存，但是极端情况下，个别用户会因此而占用 10G 或更多的存储空间。也就是这个随机删除存在很大的随机性。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;NSURLCache&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NSURLCache 自定义磁盘缓存路径时，如果 diskCapacity 设置过大，会导致占用超大存储空间，同时也会导致网络请求因为 I/O 读写慢而变慢。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;删除文件&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实测部分情况下删文件的 I/O 量基本等于写文件的 I/O 量，而且密集删文件时会容易导致 I/O 性能下降过快。因此业务应尽量避免短时间大量密集 I/O。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、结论&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;System Trace 数据表明：当并发 I/O 遍历的文件目录是同一个时，Instruments 报告里的 will wait for lock xxx 会显示为同一个，也就进一步证明了 &lt;strong&gt;APFS 内部存在某种目录锁的结构，当对同一个目录的文件进行遍历 I/O 操作时，都会先请求加解锁。而在超大目录遍历时这个加锁导致的等待问题会急剧扩大，导致锁等待超时，最终可能导致了并发 I/O 速度骤降的问题&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免这种极端情况导致的 I/O 性能骤降问题，
移动端 app 也需要合理的设计存储结构。例如&lt;strong&gt;需要分层分级管理文件&lt;/strong&gt;，尽量&lt;strong&gt;不要将单个文件夹或单个文件搞的过大&lt;/strong&gt;，同时也&lt;strong&gt;需要定时清理临时缓存目录&lt;/strong&gt;，来进一步优化存储空间占用和优化 I/O 效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、附录&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;苹果从 iOS10.3 开始引入了 APFS，而在此之前 HFS+ 一直是作为 iOS 和 macOS 的文件系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用程序是如何从 ssd 等存储介质上读写文件的呢？如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7177835051546392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasbibnicqK54k5Nia6MYIWFjBiasoibGoIxOhbHFfy9KX97lFKGKnbw91lgKXSse8oCIfglRQyxibKTD2tg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;776&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;VFS&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VFS 统一并抽象了不同文件系统的接口，使得用户可以通过统一的系统调用接口去访问不同文件系统不同存储介质上的文件。VFS 主要可以被抽象为3层，vfstbllist 用于管理不同的文件系统，mount 管理文件系统的挂载，vnode 则抽象代表了文件和文件夹等对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XNU 中主要使用 vfstbllist 来注册管理多个文件系统，典型的 vfstlblist 如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/*&lt;br/&gt; * Set up the filesystem operations &lt;span&gt;for&lt;/span&gt; vnodes.&lt;br/&gt; */&lt;br/&gt;static struct vfstable vfstbllist[] = {&lt;br/&gt; /* HFS/HFS+ Filesystem */&lt;br/&gt;&lt;span&gt;#if HFS&lt;/span&gt;&lt;br/&gt; { &amp;amp;hfs_vfsops, &lt;span&gt;&quot;hfs&quot;&lt;/span&gt;, 17, 0, (MNT_LOCAL | MNT_DOVOLFS), hfs_mountroot, NULL, 0, 0, VFC_VFSLOCALARGS | VFC_VFSREADDIR_EXTENDED | VFS_THREAD_SAFE_FLAG | VFC_VFS64BITREADY | VFC_VFSVNOP_PAGEOUTV2 | VFC_VFSVNOP_PAGEINV2, NULL, 0},&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; /* Sun-compatible Network Filesystem */&lt;br/&gt;&lt;span&gt;#if NFSCLIENT&lt;/span&gt;&lt;br/&gt; { &amp;amp;nfs_vfsops, &lt;span&gt;&quot;nfs&quot;&lt;/span&gt;, 2, 0, 0, NULL, NULL, 0, 0, VFC_VFSGENERICARGS | VFC_VFSPREFLIGHT | VFS_THREAD_SAFE_FLAG | VFC_VFS64BITREADY | VFC_VFSREADDIR_EXTENDED, NULL, 0},&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __LP64__&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif /* __LP64__ */&lt;/span&gt;&lt;br/&gt;    ... ...&lt;br/&gt; {NULL, &lt;span&gt;&quot;&amp;lt;unassigned&amp;gt;&quot;&lt;/span&gt;, 0, 0, 0, NULL, NULL, 0, 0, 0, NULL, 0},&lt;br/&gt; {NULL, &lt;span&gt;&quot;&amp;lt;unassigned&amp;gt;&quot;&lt;/span&gt;, 0, 0, 0, NULL, NULL, 0, 0, 0, NULL, 0}&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核可以动态的通过 vfs_fsadd 等接口来加载不同的内核扩展，以启用并支持新的文件系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件系统只有被 mount 挂载后才可以被访问。对于内核支持的文件系统，macOS 会自动 从 /System/Library/FileSystems 里找到对应的内核扩展并挂载，而对于内核不支持的文件系统，则需要触发一次 kext 加载操作以支持对应的文件系统。macOS 上常见的 mount 操作如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4710467706013363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasbibnicqK54k5Nia6MYIWFjBiaENc8cvZLf5xibMy2QbhbOFG82Y2l9gktHJARwvu9c3tHrw1MM8AROlw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vnode 是 VFS 中最主要的组成。一个 vnode 可以代表一个文件或特定的一个文件系统对象。一个 vnode 一般对应实际的文件系统的对应 inode。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HFS+&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HFS+(Hierarchical File System Plus) 是 Mac OS 8.1（1998年） 开始引入的文件系统，同时也是 iOS 10.3 以前默认的文件系统。HFS+ 能更好的利用磁盘空间，使用 unicode 存储文件编码，提供了更多当时来说更现代的文件系统支持。HFS+ 使用了 Catalog File 来存储目录结构。Catalog File 的引入极大的提升了文件系统的查找速度，但也导致了所有 I/O 都会因为频繁访问 Catalog File 而被迫串行等待，导致超大并发性能会有较大下降。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;APFS&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;APFS(Apple File System) 是苹果推出的最新文件系统，它是 HFS+ 的接任者，解决了 HFS+ 在更现代的文件系统上所缺失的能力。APFS 为 ssd 而设计和优化，新增了 cloning, snapshots, space sharing, fast directory sizing, atomic safe-save, sparse files等特性，并补齐了苹果在现代文件系统能力上的缺失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;苹果的 APFS 和安卓设备的 F2FS 类似，都是专门为移动设备而优化的文件系统。二者设计上有很多异曲同工之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 rename 调用为例，开发者通过触发 rename 系统调用向 VFS 请求文件操作，VFS 触发 vn_rename 调用，如果当前目录使用的分区是 APFS，则最终会触发 apfs_vnop_renamex，而如果是 HFS+ 分区，则会触发 hfs_vnop_rename 调用，最终完成 rename 操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五、参考&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.amazon.com/Mac-OS-iOS-Internals-Apples/dp/1118057651&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Mac OS X and iOS Internals: To the Apple&#x27;s Core&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.amazon.com/MacOS-iOS-Internals-II-Kernel/dp/0991055578&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;MacOS and iOS Internals, Volume II: Kernel Mode&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://docs.oracle.com/cd/E37670_01/E37355/html/ol_dtrace.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;DTrace&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;File System Programming Guide&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/technotes/tn/tn1150.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;HFS Plus Volume Format&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://developer.apple.com/support/downloads/Apple-File-System-Reference.pdf&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Apple File System Reference&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/APFS_Guide/FAQ/FAQ.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Apple File System Guide&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://github.com/darwin-on-arm/xnu/blob/master/bsd/hfs/hfs.h&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;XNU&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;七夕彩蛋&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAASq0YgLDeYwAAAAstQy6ubaLX4KHWvLEZgBPE0KJ4OxAQBvyCzNPgMIs4UP_WvRrNg5tdEY9lQ778&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzLqhyKA03Vl1MAocId9PdpnwoIYTQusVCncn35P2jX0Hibud2Yx7v1JmmTnV0EDQea2JjX3Cr4cqp3T6tP47jS3w&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdVCLrmwcbdS5YpD3kwVxrPZSlHNep8tyCvuOBZBOeGPXuk0lZg02uNFnYfgs3y4q98&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;程序员的生活也可以很浪漫，祝大家七夕快乐！#七夕&quot; data-nonceid=&quot;11030318403157504517&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dc594339fdf77310e5588eaff95a3153</guid>
<title>NVM 快速安装教程，只此一家</title>
<link>https://toutiao.io/k/6kbp22s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;markdown小助手&quot;&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;&lt;code&gt;nvm&lt;/code&gt;&lt;span&gt;作为一款&lt;/span&gt;&lt;code&gt;node&lt;/code&gt;&lt;span&gt;的版本管理工具，在前端开发中是必不可少的，但是因为&lt;/span&gt;&lt;code&gt;GitHub&lt;/code&gt;&lt;span&gt;的特殊性，导致很多人是无法用官方教程安装成功，本文旨在整理出如德芙般丝滑的安装教程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;本文介绍的安装方法，你可以理解为通过仓库镜像的方式安装。如果你能正常稳定访问&lt;code&gt;GitHub&lt;/code&gt;，则无需通过本文方式安装。&lt;/p&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;仓库地址：&lt;/p&gt;&lt;ul data-tool=&quot;markdown小助手&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;GitHub: https://github.com/ineo6/nvm&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GitLab: https://gitlab.com/mirrorx/nvm&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;markdown小助手&quot;&gt;&lt;span/&gt;安装&lt;/h2&gt;&lt;h3 data-tool=&quot;markdown小助手&quot;&gt;&lt;span/&gt;脚本&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;安装选用下面任意一个脚本都行，注意&lt;code&gt;mac&lt;/code&gt;上没有&lt;code&gt;wget&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;markdown小助手&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; NVM_SOURCE=https://gitlab.com/mirrorx/nvm.git&lt;br/&gt;curl -o- https://gitlab.com/mirrorx/nvm/-/raw/master/install.sh | bash&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;markdown小助手&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; NVM_SOURCE=https://gitlab.com/mirrorx/nvm.git&lt;br/&gt;wget -qO- https://gitlab.com/mirrorx/nvm/-/raw/master/install.sh | bash&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;markdown小助手&quot;&gt;&lt;span/&gt;检验安装是否成功&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;markdown小助手&quot;&gt;&lt;code&gt;&lt;span&gt;command&lt;/span&gt; -v nvm&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;执行后如果显示&lt;code&gt;nvm&lt;/code&gt;则表示已经安装成功。&lt;/p&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;如果遇到&lt;code&gt;nvm&lt;/code&gt;命令找不到的问题，请查阅文末的“FAQ”。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown小助手&quot;&gt;&lt;span/&gt;更新&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;重新执行安装脚本即可。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown小助手&quot;&gt;&lt;span/&gt;配置&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;markdown小助手&quot;&gt;&lt;span/&gt;1. 设置为系统默认node&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;因为&lt;code&gt;nvm&lt;/code&gt;安装的结果都是下面这样的格式：&lt;/p&gt;&lt;pre data-tool=&quot;markdown小助手&quot;&gt;&lt;code&gt;/Users/neo/.nvm/versions/node/v14.17.4/bin/node&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;为了确保在所有的&lt;code&gt;shell&lt;/code&gt;以及&lt;code&gt;ide&lt;/code&gt;中都可以正常工作，我们需要设置把&lt;code&gt;nvm&lt;/code&gt;安装的&lt;code&gt;node&lt;/code&gt;设置为系统默认。&lt;/p&gt;&lt;pre data-tool=&quot;markdown小助手&quot;&gt;&lt;code&gt;nvm &lt;span&gt;alias&lt;/span&gt; default node&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;markdown小助手&quot;&gt;&lt;span/&gt;2. 设置node镜像&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;这里是给安装&lt;code&gt;node&lt;/code&gt;设置镜像。&lt;/p&gt;&lt;pre data-tool=&quot;markdown小助手&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node&lt;br/&gt;nvm install node&lt;br/&gt;&lt;br/&gt;// 或者&lt;br/&gt;NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node nvm install 4.2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;长期替换可以使用下面的设置：&lt;/p&gt;&lt;pre data-tool=&quot;markdown小助手&quot;&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&#x27;export NVM_NODEJS_ORG_MIRROR=&quot;https://npmmirror.com/mirrors/node&quot;&#x27;&lt;/span&gt; &amp;gt;&amp;gt; ~/.zshrc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;&lt;em&gt;注意！&lt;/em&gt; 上面脚本是把配置写入文件&lt;code&gt;.zshrc&lt;/code&gt;，你如果对此不了解，请参考&lt;code&gt;FAQ&lt;/code&gt;，确定是否更换为&lt;code&gt;.bash_profile&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown小助手&quot;&gt;&lt;span/&gt;FAQ&lt;/h2&gt;&lt;h3 data-tool=&quot;markdown小助手&quot;&gt;&lt;span/&gt;nvm命令找不到（command not found）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;需要手动配置环境变量。&lt;/p&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;执行命令&lt;code&gt;echo $SHELL&lt;/code&gt;，根据结果判断写入的文件：&lt;/p&gt;&lt;ul data-tool=&quot;markdown小助手&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;/bin/zsh =&amp;gt; zsh =&amp;gt; .zshrc&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;/bin/bash =&amp;gt; bash =&amp;gt; .bash_profile&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;markdown小助手&quot;&gt;&lt;span/&gt;.zshrc&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;markdown小助手&quot;&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&#x27;export NVM_DIR=&quot;$([ -z &quot;${XDG_CONFIG_HOME-}&quot; ] &amp;amp;&amp;amp; printf %s &quot;${HOME}/.nvm&quot; || printf %s &quot;${XDG_CONFIG_HOME}/nvm&quot;)&quot;&lt;br/&gt;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;amp;&amp;amp; \. &quot;$NVM_DIR/nvm.sh&quot;&#x27;&lt;/span&gt; &amp;gt;&amp;gt; ~/.zshrc&lt;br/&gt;&lt;span&gt;source&lt;/span&gt; ~/.zshrc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;markdown小助手&quot;&gt;&lt;span/&gt;.bash_profile&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;markdown小助手&quot;&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&#x27;export NVM_DIR=&quot;$([ -z &quot;${XDG_CONFIG_HOME-}&quot; ] &amp;amp;&amp;amp; printf %s &quot;${HOME}/.nvm&quot; || printf %s &quot;${XDG_CONFIG_HOME}/nvm&quot;)&quot;&lt;br/&gt;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;amp;&amp;amp; \. &quot;$NVM_DIR/nvm.sh&quot;&#x27;&lt;/span&gt; &amp;gt;&amp;gt; ~/.bash_profile&lt;br/&gt;&lt;span&gt;source&lt;/span&gt; ~/.bash_profile&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;markdown小助手&quot;&gt;&lt;span/&gt;更多&lt;/h2&gt;&lt;p data-tool=&quot;markdown小助手&quot;&gt;像&lt;code&gt;nvm&lt;/code&gt;这样安装困难的工具还有不少，我也一直有出一个系列合集的想法，如果你也期待更多这方面的文章，欢迎关注我，以便最快获取最新动态。&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>