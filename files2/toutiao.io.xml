<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8cc97cf5e8b16b1996503a63bf811ef9</guid>
<title>java 的泛型方法中的泛型类继承</title>
<link>https://toutiao.io/k/gyapr83</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;我们经常在集合的泛型中用到 extends、super 关键字。先看下 List 集合中获取和放入接口的定义：
&lt;img src=&quot;https://img.toutiao.io/attachment/39a784b0ed0a4bb4b82ae48ac04a3172/w600&quot; alt=&quot;file&quot;/&gt;
&lt;img src=&quot;https://img.toutiao.io/attachment/328b5bf6105a44a58576fc9a7fb32a34/w600&quot; alt=&quot;file&quot;/&gt;
&lt;img src=&quot;https://img.toutiao.io/attachment/e89bb0bfbf784a45afea9831b55343f5/w600&quot; alt=&quot;file&quot;/&gt;
通过类定义可以看到，泛型的具体类型在创建集合实例时指定，用于限定该实例的 get/set 取出和放入时的集合元素类型。&lt;/p&gt;

&lt;p&gt;List&amp;lt;? extends T&amp;gt;：声明上界，表示参数化的类型可能是所指定的 T 类型，或者是此类型的任意子类型。最终子类型：未知。
List&amp;lt;? super T&amp;gt;：声明下界，表示参数化的类型可能是所指定的 T 类型，或者是此类型的任意父类型。最终父类型：已知——Object。
Java 中泛型不变：假设有 A extends B，但 &lt;code&gt;List&amp;lt;A&amp;gt;&lt;/code&gt; 和 &lt;code&gt;List&amp;lt;B&amp;gt;&lt;/code&gt;   不存在型变关系。
————————————————&lt;/p&gt;

&lt;h1&gt;泛型的简单使用：&lt;/h1&gt;

&lt;h3&gt;泛型不变&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/1f7c032a3a67413d8130e6eaccc18267/w600&quot; alt=&quot;file&quot;/&gt;
集合可读可写，集合泛型不变。&lt;/p&gt;

&lt;h3&gt;extends 泛型协变&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/e18c10e73a434923865da6edd8bcca73/w600&quot; alt=&quot;file&quot;/&gt;
集合可读、不可写，集合泛型协变。&lt;/p&gt;

&lt;h3&gt;super 泛型逆变&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/fd3804b8c2ed431dbca130675deaad1e/w600&quot; alt=&quot;file&quot;/&gt;
集合可读 Object 、可写，集合泛型逆变。&lt;/p&gt;

&lt;h3&gt;小结&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;? extends T 针对返回值泛型使用（如，只读的消费者集合泛型），指定的 T 为集合元素的通用父类型，用于限定取出类型为 T 的子类型、打破泛型不变。&lt;/li&gt;
&lt;li&gt;? super T 针对方法参数泛型使用（如，只写的生产者集合泛型），指定的 T 为集合元素的通用父类型，用于限定放入类型为 T 的子类型、打破泛型不变。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;extends 用于方法返回值，super 用于方法参数。即，我们所说的 PECS 原则。针对方法返回值即消费，针对方法参数即生产。&lt;/p&gt;

&lt;p&gt;转载来源：&lt;a href=&quot;https://blog.csdn.net/qq_41490274/article/details/122886351&quot;&gt;https://blog.csdn.net/qq_41490274/article/details/122886351&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1014680abeb340eb049c7c90c10ab9e9</guid>
<title>面试必问：Java 是如何实现线程间通信的？</title>
<link>https://toutiao.io/k/gpjt3dm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-v-b51c2330=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文涉及到的知识点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;thread.join(),&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;object.wait(),&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;object.notify(),&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CountdownLatch,&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CyclicBarrier,&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FutureTask,&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Callable 。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文涉及代码：https://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我从几个例子作为切入点来讲解下 Java 里有哪些方法来实现线程间通信。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如何让两个线程依次执行？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;那如何让 两个线程按照指定方式有序交叉运行呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;三个运动员各自准备，等到三个人都准备好后，再一起跑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子线程完成某件任务后，把得到的结果回传给主线程&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何让两个线程依次执行？&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有两个线程，一个是线程 A，另一个是线程 B，两个线程分别依次打印 1-3 三个数字即可。我们来看下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static void &lt;span&gt;&lt;span&gt;demo1&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;    Thread A = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;        @Override  &lt;br/&gt;        public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;            printNumber(&lt;span&gt;&quot;A&quot;&lt;/span&gt;);  &lt;br/&gt;        }  &lt;br/&gt;    });  &lt;br/&gt;    Thread B = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;        @Override  &lt;br/&gt;        public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;            printNumber(&lt;span&gt;&quot;B&quot;&lt;/span&gt;);  &lt;br/&gt;        }  &lt;br/&gt;    });  &lt;br/&gt;    A.start();  &lt;br/&gt;    B.start();  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的 printNumber(String) 实现如下，用来依次打印 1, 2, 3 三个数字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static void printNumber(String threadName) {  &lt;br/&gt;    int i=0;  &lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (i++ &amp;lt; 3) {  &lt;br/&gt;        try {  &lt;br/&gt;            Thread.sleep(100);  &lt;br/&gt;        } catch (InterruptedException e) {  &lt;br/&gt;            e.printStackTrace();  &lt;br/&gt;        }  &lt;br/&gt;        System.out.println(threadName + &lt;span&gt;&quot; print: &quot;&lt;/span&gt; + i);  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我们得到的结果是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;B print: 1 A print: 1 B print: 2 A print: 2 B print: 3 A print: 3&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 A 和 B 是同时打印的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如果我们希望 B 在 A 全部打印 完后再开始打印呢？我们可以利用 thread.join() 方法，代码如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static void &lt;span&gt;&lt;span&gt;demo2&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;    Thread A = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;        @Override  &lt;br/&gt;        public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;            printNumber(&lt;span&gt;&quot;A&quot;&lt;/span&gt;);  &lt;br/&gt;        }  &lt;br/&gt;    });  &lt;br/&gt;    Thread B = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;        @Override  &lt;br/&gt;        public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;            System.out.println(&lt;span&gt;&quot;B 开始等待 A&quot;&lt;/span&gt;);  &lt;br/&gt;            try {  &lt;br/&gt;                A.join();  &lt;br/&gt;            } catch (InterruptedException e) {  &lt;br/&gt;                e.printStackTrace();  &lt;br/&gt;            }  &lt;br/&gt;            printNumber(&lt;span&gt;&quot;B&quot;&lt;/span&gt;);  &lt;br/&gt;        }  &lt;br/&gt;    });  &lt;br/&gt;    B.start();  &lt;br/&gt;    A.start();  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得到的结果如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;B 开始等待 A A print: 1 A print: 2 A print: 3&lt;/p&gt;&lt;p&gt;B print: 1 B print: 2 B print: 3&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们能看到 A.join() 方法会让 B 一直等待直到 A 运行完毕。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那如何让 两个线程按照指定方式有序交叉运行呢？&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是上面那个例子，我现在希望 A 在打印完 1 后，再让 B 打印 1, 2, 3，最后再回到 A 继续打印 2, 3。这种需求下，显然 Thread.join() 已经不能满足了。我们需要更细粒度的锁来控制执行顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，我们可以利用 object.wait() 和 object.notify() 两个方法来实现。代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**  &lt;br/&gt; * A 1, B 1, B 2, B 3, A 2, A 3  &lt;br/&gt; */  &lt;br/&gt;private static void &lt;span&gt;&lt;span&gt;demo3&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;    Object lock = new Object();  &lt;br/&gt;    Thread A = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;        @Override  &lt;br/&gt;        public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;            synchronized (lock) {  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;A 1&quot;&lt;/span&gt;);  &lt;br/&gt;                try {  &lt;br/&gt;                    lock.wait();  &lt;br/&gt;                } catch (InterruptedException e) {  &lt;br/&gt;                    e.printStackTrace();  &lt;br/&gt;                }  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;A 2&quot;&lt;/span&gt;);  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;A 3&quot;&lt;/span&gt;);  &lt;br/&gt;            }  &lt;br/&gt;        }  &lt;br/&gt;    });  &lt;br/&gt;    Thread B = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;        @Override  &lt;br/&gt;        public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;            synchronized (lock) {  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;B 1&quot;&lt;/span&gt;);  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;B 2&quot;&lt;/span&gt;);  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;B 3&quot;&lt;/span&gt;);  &lt;br/&gt;                lock.notify();  &lt;br/&gt;            }  &lt;br/&gt;        }  &lt;br/&gt;    });  &lt;br/&gt;    A.start();  &lt;br/&gt;    B.start();  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;A 1 A waiting…&lt;/p&gt;&lt;p&gt;B 1 B 2 B 3 A 2 A 3&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是我们要的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这个过程发生了什么呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先创建一个 A 和 B 共享的对象锁 lock = new Object();&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当 A 得到锁后，先打印 1，然后调用 lock.wait() 方法，交出锁的控制权，进入 wait 状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对 B 而言，由于 A 最开始得到了锁，导致 B 无法执行；直到 A 调用 lock.wait() 释放控制权后， B 才得到了锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B 在得到锁后打印 1， 2， 3；然后调用 lock.notify() 方法，唤醒正在 wait 的 A;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A 被唤醒后，继续打印剩下的 2，3。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好理解，我在上面的代码里加上 log 方便读者查看。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static void &lt;span&gt;&lt;span&gt;demo3&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;    Object lock = new Object();  &lt;br/&gt;    Thread A = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;        @Override  &lt;br/&gt;        public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;            System.out.println(&lt;span&gt;&quot;INFO: A 等待锁 &quot;&lt;/span&gt;);  &lt;br/&gt;            synchronized (lock) {  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;INFO: A 得到了锁 lock&quot;&lt;/span&gt;);  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;A 1&quot;&lt;/span&gt;);  &lt;br/&gt;                try {  &lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;INFO: A 准备进入等待状态，放弃锁 lock 的控制权 &quot;&lt;/span&gt;);  &lt;br/&gt;                    lock.wait();  &lt;br/&gt;                } catch (InterruptedException e) {  &lt;br/&gt;                    e.printStackTrace();  &lt;br/&gt;                }  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;INFO: 有人唤醒了 A, A 重新获得锁 lock&quot;&lt;/span&gt;);  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;A 2&quot;&lt;/span&gt;);  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;A 3&quot;&lt;/span&gt;);  &lt;br/&gt;            }  &lt;br/&gt;        }  &lt;br/&gt;    });  &lt;br/&gt;    Thread B = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;        @Override  &lt;br/&gt;        public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;            System.out.println(&lt;span&gt;&quot;INFO: B 等待锁 &quot;&lt;/span&gt;);  &lt;br/&gt;            synchronized (lock) {  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;INFO: B 得到了锁 lock&quot;&lt;/span&gt;);  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;B 1&quot;&lt;/span&gt;);  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;B 2&quot;&lt;/span&gt;);  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;B 3&quot;&lt;/span&gt;);  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;INFO: B 打印完毕，调用 notify 方法 &quot;&lt;/span&gt;);  &lt;br/&gt;                lock.notify();  &lt;br/&gt;            }  &lt;br/&gt;        }  &lt;br/&gt;    });  &lt;br/&gt;    A.start();  &lt;br/&gt;    B.start();  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果如下:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;INFO: A 等待锁 INFO: A 得到了锁 lock A 1 INFO: A 准备进入等待状态，调用 lock.wait() 放弃锁 lock 的控制权 INFO: B 等待锁 INFO: B 得到了锁 lock B 1 B 2 B 3 INFO: B 打印完毕，调用 lock.notify() 方法 INFO: 有人唤醒了 A, A 重新获得锁 lock A 2 A 3&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最开始我们介绍了 thread.join()，可以让一个线程等另一个线程运行完毕后再继续执行，那我们可以在 D 线程里依次 join A B C，不过这也就使得 A B C 必须依次执行，而我们要的是这三者能同步运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者说，我们希望达到的目的是：A B C 三个线程同时运行，各自独立运行完后通知 D；对 D 而言，只要 A B C 都运行完了，D 再开始运行。针对这种情况，我们可以利用 CountdownLatch 来实现这类通信方式。它的基本用法是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建一个计数器，设置初始值，CountdownLatch countDownLatch = new CountDownLatch(2);&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 等待线程 里调用 countDownLatch.await() 方法，进入等待状态，直到计数值变成 0；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 其他线程 里，调用 countDownLatch.countDown() 方法，该方法会将计数值减小 1；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当 其他线程 的 countDown() 方法把计数值变成 0 时，等待线程 里的 countDownLatch.await() 立即退出，继续执行下面的代码。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static void &lt;span&gt;&lt;span&gt;runDAfterABC&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;    int worker = 3;  &lt;br/&gt;    CountDownLatch countDownLatch = new CountDownLatch(worker);  &lt;br/&gt;    new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;        @Override  &lt;br/&gt;        public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;            System.out.println(&lt;span&gt;&quot;D is waiting for other three threads&quot;&lt;/span&gt;);  &lt;br/&gt;            try {  &lt;br/&gt;                countDownLatch.await();  &lt;br/&gt;                System.out.println(&lt;span&gt;&quot;All done, D starts working&quot;&lt;/span&gt;);  &lt;br/&gt;            } catch (InterruptedException e) {  &lt;br/&gt;                e.printStackTrace();  &lt;br/&gt;            }  &lt;br/&gt;        }  &lt;br/&gt;    }).start();  &lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (char threadName=&lt;span&gt;&#x27;A&#x27;&lt;/span&gt;; threadName &amp;lt;= &lt;span&gt;&#x27;C&#x27;&lt;/span&gt;; threadName++) {  &lt;br/&gt;        final String tN = String.valueOf(threadName);  &lt;br/&gt;        new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;            @Override  &lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;                System.out.println(tN + &lt;span&gt;&quot; is working&quot;&lt;/span&gt;);  &lt;br/&gt;                try {  &lt;br/&gt;                    Thread.sleep(100);  &lt;br/&gt;                } catch (Exception e) {  &lt;br/&gt;                    e.printStackTrace();  &lt;br/&gt;                }  &lt;br/&gt;                System.out.println(tN + &lt;span&gt;&quot; finished&quot;&lt;/span&gt;);  &lt;br/&gt;                countDownLatch.countDown();  &lt;br/&gt;            }  &lt;br/&gt;        }).start();  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是运行结果：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;D is waiting for other three threads A is working B is working C is working&lt;/p&gt;&lt;p&gt;A finished C finished B finished All done, D starts working&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实简单点来说，CountDownLatch 就是一个倒计数器，我们把初始计数值设置为3，当 D 运行时，先调用 countDownLatch.await() 检查计数器值是否为 0，若不为 0 则保持等待状态；当A B C 各自运行完后都会利用countDownLatch.countDown()，将倒计数器减 1，当三个都运行完后，计数器被减至 0；此时立即触发 D 的 await() 运行结束，继续向下执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，CountDownLatch 适用于一个线程去等待多个线程的情况。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;三个运动员各自准备，等到三个人都准备好后，再一起跑&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是一个形象的比喻，针对 线程 A B C 各自开始准备，直到三者都准备完毕，然后再同时运行 。也就是要实现一种 线程之间互相等待 的效果，那应该怎么来实现呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的 CountDownLatch 可以用来倒计数，但当计数完毕，只有一个线程的 await() 会得到响应，无法让多个线程同时触发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现线程间互相等待这种需求，我们可以利用 CyclicBarrier 数据结构，它的基本用法是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先创建一个公共 CyclicBarrier 对象，设置 同时等待 的线程数，CyclicBarrier cyclicBarrier = new CyclicBarrier(3);&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这些线程同时开始自己做准备，自身准备完毕后，需要等待别人准备完毕，这时调用 cyclicBarrier.await(); 即可开始等待别人；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当指定的 同时等待 的线程数都调用了 cyclicBarrier.await();时，意味着这些线程都准备完毕好，然后这些线程才 同时继续执行。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现代码如下，设想有三个跑步运动员，各自准备好后等待其他人，全部准备好后才开始跑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static void &lt;span&gt;&lt;span&gt;runABCWhenAllReady&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;    int runner = 3;  &lt;br/&gt;    CyclicBarrier cyclicBarrier = new CyclicBarrier(runner);  &lt;br/&gt;    final Random random = new Random();  &lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (char runnerName=&lt;span&gt;&#x27;A&#x27;&lt;/span&gt;; runnerName &amp;lt;= &lt;span&gt;&#x27;C&#x27;&lt;/span&gt;; runnerName++) {  &lt;br/&gt;        final String rN = String.valueOf(runnerName);  &lt;br/&gt;        new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;            @Override  &lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;                long prepareTime = random.nextInt(10000) + 100;  &lt;br/&gt;                System.out.println(rN + &lt;span&gt;&quot; is preparing for time: &quot;&lt;/span&gt; + prepareTime);  &lt;br/&gt;                try {  &lt;br/&gt;                    Thread.sleep(prepareTime);  &lt;br/&gt;                } catch (Exception e) {  &lt;br/&gt;                    e.printStackTrace();  &lt;br/&gt;                }  &lt;br/&gt;                try {  &lt;br/&gt;                    System.out.println(rN + &lt;span&gt;&quot; is prepared, waiting for others&quot;&lt;/span&gt;);  &lt;br/&gt;                    cyclicBarrier.await(); // 当前运动员准备完毕，等待别人准备好  &lt;br/&gt;                } catch (InterruptedException e) {  &lt;br/&gt;                    e.printStackTrace();  &lt;br/&gt;                } catch (BrokenBarrierException e) {  &lt;br/&gt;                    e.printStackTrace();  &lt;br/&gt;                }  &lt;br/&gt;                System.out.println(rN + &lt;span&gt;&quot; starts running&quot;&lt;/span&gt;); // 所有运动员都准备好了，一起开始跑  &lt;br/&gt;            }  &lt;br/&gt;        }).start();  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印的结果如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;A is preparing for time: 4131 B is preparing for time: 6349 C is preparing for time: 8206 A is prepared, waiting for others B is prepared, waiting for others C is prepared, waiting for others C starts running A starts running B starts running&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子线程完成某件任务后，把得到的结果回传给主线程&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际的开发中，我们经常要创建子线程来做一些耗时任务，然后把任务执行结果回传给主线程使用，这种情况在 Java 里要如何实现呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾线程的创建，我们一般会把 Runnable 对象传给 Thread 去执行。Runnable定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface Runnable {  &lt;br/&gt;    public abstract void run();  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 run() 在执行完后不会返回任何结果。那如果希望返回结果呢？这里可以利用另一个类似的接口类 Callable：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@FunctionalInterface  &lt;br/&gt;public interface Callable&amp;lt;V&amp;gt; {  &lt;br/&gt;    /**  &lt;br/&gt;     * Computes a result, or throws an exception &lt;span&gt;if&lt;/span&gt; unable to &lt;span&gt;do&lt;/span&gt; so.  &lt;br/&gt;     *  &lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt; computed result  &lt;br/&gt;     * @throws Exception &lt;span&gt;if&lt;/span&gt; unable to compute a result  &lt;br/&gt;     */  &lt;br/&gt;    V call() throws Exception;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出 Callable 最大区别就是返回范型 V 结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么下一个问题就是，如何把子线程的结果回传回来呢？在 Java 里，有一个类是配合 Callable 使用的：FutureTask，不过注意，它获取结果的 get 方法会阻塞主线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例，我们想让子线程去计算从 1 加到 100，并把算出的结果返回到主线程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static void &lt;span&gt;&lt;span&gt;doTaskWithResultInWorker&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;    Callable&amp;lt;Integer&amp;gt; callable = new Callable&amp;lt;Integer&amp;gt;() {  &lt;br/&gt;        @Override  &lt;br/&gt;        public Integer call() throws Exception {  &lt;br/&gt;            System.out.println(&lt;span&gt;&quot;Task starts&quot;&lt;/span&gt;);  &lt;br/&gt;            Thread.sleep(1000);  &lt;br/&gt;            int result = 0;  &lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (int i=0; i&amp;lt;=100; i++) {  &lt;br/&gt;                result += i;  &lt;br/&gt;            }  &lt;br/&gt;            System.out.println(&lt;span&gt;&quot;Task finished and return result&quot;&lt;/span&gt;);  &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;  &lt;br/&gt;        }  &lt;br/&gt;    };  &lt;br/&gt;    FutureTask&amp;lt;Integer&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(callable);  &lt;br/&gt;    new Thread(futureTask).start();  &lt;br/&gt;    try {  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Before futureTask.get()&quot;&lt;/span&gt;);  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Result: &quot;&lt;/span&gt; + futureTask.get());  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;After futureTask.get()&quot;&lt;/span&gt;);  &lt;br/&gt;    } catch (InterruptedException e) {  &lt;br/&gt;        e.printStackTrace();  &lt;br/&gt;    } catch (ExecutionException e) {  &lt;br/&gt;        e.printStackTrace();  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Before futureTask.get() Task starts Task finished and return result Result: 5050 After futureTask.get()&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，主线程调用 futureTask.get() 方法时阻塞主线程；然后 Callable 内部开始执行，并返回运算结果；此时 futureTask.get() 得到结果，主线程恢复运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们可以学到，通过 FutureTask 和 Callable 可以直接在主线程获得子线程的运算结果，只不过需要阻塞主线程。当然，如果不希望阻塞主线程，可以考虑利用 ExecutorService，把 FutureTask 放到线程池去管理执行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多线程是现代语言的共同特性，而线程间通信、线程同步、线程安全是很重要的话题。本文针对 Java 的线程间通信进行了大致的讲解，后续还会对线程同步、线程安全进行讲解。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d52f7c16c129125de002fa1d08148b5a</guid>
<title>研发在云端：淘系云研发体系实践</title>
<link>https://toutiao.io/k/x86cza8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPvaxIIiaFvq9ct2HbyO07NCyrh6aZ7ibVYqFXnPL0yWVh8icdP4b3ZiciaHw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6669793621013134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPKTEskI3r0VnsBCusuXqank6icaOqvTiaibr23iaHPYqXn6cuSTtAeOTUtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1066&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如何定义云研发？&lt;/p&gt;&lt;p&gt;云研发将面临哪些挑战？&lt;/p&gt;&lt;p&gt;云研发的未来是什么样的？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一起来看看柳千在 QCon 的精彩分享&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;带你了解阿里内部云研发落地现状&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;以及真实的云研发实践过程中踩过的坑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;26775&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1503268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPced1XLc80Sj1EE2mYXo83IBPOYFvtyibE11RlLSEhACyYM7bn6PpibGA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;306&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;议题简介&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPlAmWGd9jx1e98lkpTJZEia2JeXECmZmdFAlrTIzfJ9n1FINuRzdNdZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从微软发布 VS Code Remote Development 套件，到 VS Code 团队联合 GitHub 推出 GitHub Codespaces。云研发逐渐成为了近两年国内外技术社区最为火热的话题之一。在越来越多的开发者选择将研发环境搬到云端的背景下，云研发将面临哪些挑战？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本次分享将以淘宝内部落地云研发项目 O2 Online 为例，介绍云研发在落地过程中遇到的一些挑战与解法。同时探讨云研发的未来。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;内部云端研发体系简介&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPTJiaRxNsHqXOB9ZMCN9MFM3hksUD814DicdfMYkylmDziaEbbDYoac7ow/640?wx_fmt=png&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;阿里内部的云研发产品大体上可以分为&lt;span&gt;&lt;strong&gt;基于 OpenSumi 和基于 Theia 两大类&lt;/strong&gt;&lt;/span&gt;，两个都是时下主流的 CloudIDE 底层框架，包括我所负责的 O2 Code Online、蚂蚁 CTO 线的 Ant Codespaces ，以及阿里云云开发平台 CloudIDE 和云效团队的 DevStudio 等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而在更早几年，内部的云研发 CloudIDE 产品比现在多几个数量级，而经过几年时间时间的发展，Cloud IDE  产品也逐步统一了底层技术栈，基本都是基于 OpenSumi 来搭建。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;问题与挑战&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPnECdlWqHFhAsFkoruiaOTFTz3Mqic5kPtrpDRT7GZEUxPd0Tm6QbiaPUw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当我们聊到「把开发环境搬到云端」，脑子里似乎已经可以想象到这个非常常规的流程：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;在某云端开发产品 Dashboard 页面创建一个「工作空间」，指定我需要的基础环境，这可能包括一些基本的 Node.js 以及框架相关的 SDK 等等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;选择将某个代码仓库克隆到工作空间&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过浏览器或者本地客户端（例如 VS Code）连接到这个远程工作空间进行开发&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;开发体验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPtUpT2rUu4EEfz38UcM4H12s62RXyxA3zweRHibMphCfkSqFNicl8YOMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然而在一开始，我们真的这么做了一个非常简陋的「云端开发」平台之后，发现遇到的问题远远不止这么简单。尤其体现在「开发体验」，这里列举一下遇到的一些用户痛点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1. 内部有各种业务研发框架，覆盖了前、后端、甚至一体化的应用，不同框架所需的基础环境千差万别，不仅仅是一个「Node.js」版本这么简单；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2. 用户使用我们的产品时，往往需要在内部多个产研平台之间频繁跳转，整体需求交付链路不够顺畅，经常是编码 5 分钟，发布 2 小时；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3. 使用 OpenSumi 作为底层框架，一些功能与主流 IDE 产品有一些差异，例如一些用户更喜欢使用 WebStorm/VS Code  等 IDE；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4. 基于容器的 CloudIDE 冷启动比较慢，用户需要等待的时间较长，甚至比在本地手动克隆再打开更慢。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;理解、学习成本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPnpEaLc4F1xib6NaLkftltk2HgIerAo4y9lUv2CMgdnRJMdL4nZu2Vibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于一个相对比较「新奇」的产品来说，本身就会具有一些专属名字，例如 “工作空间”、“云端环境”等等，对于用户来说需要有一定的理解门槛，虽然这对于很多成熟的工程师看起来很简单，但实际上我们遇到一些小白用户很容易分不清这个所谓的云端环境和我的电脑差别是什么(真)，以至于一些新手遇到我们 IDE 的问题第一反应是重启自己的电脑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而另一方面，不同于本地的环境会在一些基础而常见的操作上给用户造成更高的使用门槛，例如用户运行了一个简单的 HTTP 服务器，但不知道怎样通过浏览器访问这个服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;又比如对于一些略微有点年头的项目，往往需要更老版本的 Node.js 等环境，而这又是用户的刚需，这又需要我们提供更灵活多变的环境选择。又比如用户配置的同步等等问题。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;实践经验&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在介绍内部实践之前，我们先来看一下开源社区是怎么解决这些问题的，在社区主流的两个 CloudIDE 产品 GitHub Codespaces  以及 GitPod 的实践经验是：&lt;strong&gt;&lt;span&gt;通过一份标准的配置文件来描述当前项目开发、运行所需的所有环境以及步骤。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPme5z1KQjnNReD8P5XicsqyCuqLic3pPxFYgADNjjdy19DNI3BjMoydicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中GitPod 使用&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.gitpod&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.yml&lt;/span&gt;&lt;span&gt;作为配置文件，而GitHub Codespaces 使用 &lt;/span&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;devContainer&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.json &lt;/span&gt;&lt;span&gt;作为配置文件，&lt;/span&gt;&lt;span&gt;大体上两者的结构都非常类似。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;字段用于指定当前环境使用哪个 docker 镜像&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ports &lt;/span&gt;&lt;span&gt;字段用于指定当前项目依赖的端口&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;tasks &lt;/span&gt;&lt;span&gt;是 GitPod  独有&lt;/span&gt;&lt;span&gt;的字段，用于描述当前项目的启动、调试方式 (实际上在 VS Code 中也有 Tas&lt;/span&gt;&lt;span&gt;k)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;extensions &lt;/span&gt;&lt;span&gt;字段用于指定需要预装哪些插件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;配置文件需要放在项目根目录下，这意味着任何人在 GitPod 和 GitHub Codespaces 中打开该项目后得到的就是完全一致的开发环境，同时你可以任意修改其中的一些配置，而两者都提供了更高级的一些配置方式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;面对开源社区众多研发框架来说，这是一种非常灵活的定制方式，只不过对于一些新手用户来说不太友好。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;标准化研发环境&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPVklupdEAXicjJbdh8PGx3u0Ttuz9E3w09ZK9O13baIfURN6zOjibBFag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;而对于公司内部来说，我们所面对的业务研发现状与社区最大的区别是，内部的业务框架是可枚举的，这也就意味着我们很明确的知道哪些框架是需要支持的，基于这些不同业务的特点，我们将 &lt;strong&gt;&lt;span&gt;业务镜像、内置插件、资源规格、生命周期&lt;/span&gt;&lt;/strong&gt;等等封装为一份配置，我们称其为 &lt;strong&gt;&lt;span&gt;业务模板&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPheNxbiaJibicc1hwlc0BraibogAzz2EnibC578Ggq3kpZGfqfzSwYibzQscg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;这些业务模板会与我们的前端研发平台深度绑定，例如从研发平台创建一个应用，它会自动关联到一个业务模板，用户不需要创建也不需要配置，点击 使用 &lt;span class=&quot;code-snippet__attr&quot;&gt;02&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;编码 &lt;/span&gt;会自动使用关联的业务模板创建工作空间，同时应用默认配置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPcqHicjic8qUgM0F28x5BR3PE0v4UibqzoNllhicaBz0u9oQbeQvg5Yjrgg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而在这之上，对于可枚举的这些技术栈，我们提供了统一的项目启动方式，这意味着用户不需要知道项目中的 &lt;span class=&quot;code-snippet__attribute&quot;&gt;npm&lt;/span&gt;&lt;span&gt; scripts &lt;/span&gt;是什么，只需要点击一键即可启动项目。对于常规的前端项目，我们提供了标准的编译错误监听能力，例如编译后遇到类型错误，会自动提示修复建议等等。&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPY6rddjvjibjxdXEhVMpMSeVG60DgDIWumuUtYVLVuXoN5CXd5hY0P0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于在云研发环境中运行的服务，通常的做法是监听端口是否被使用，同时提示用户打开预览地址，而在这之上我们将 IDE 内部可能触发「打开浏览器」操作的行为都进行了统一拦截与代理，例如许多前端项目运行后会自动打开 &lt;span&gt;127&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:3000&lt;/span&gt;，而在 O2 中，它依然会自动打开，只不过地址会被自动转换为 &lt;span&gt;https:&lt;/span&gt;，对于用户来说，什么都不用操作就是最简单的使用方式。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;多端支持&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPsicZ9Kp9G9MMylAzTIOOKr7YapXqesdQ2icMKSlBcibapNX5V9z78TeFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在我们接触到的用户中，有一部分是比较抵触&lt;strong&gt;&lt;span&gt;在浏览器中写代码&lt;/span&gt;&lt;/strong&gt;这件事的，除了天然的一些快捷键(例如 ctrl+w 关关闭)支持之外，在浏览器中写代码总给人一种不够安全、严肃。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而借助于 OpenSumi 天然前后端分离的架构，我们提供了桌面版客户端，用户可以&lt;strong&gt;&lt;span&gt;直接下载桌面版本连接到远程空间开发&lt;/span&gt;&lt;/strong&gt;。而对于更习惯使用 VS Code 的用户，我们也内置了 Remote Development  的支持，用户通过非常简单的配置即可&lt;strong&gt;&lt;span&gt;使用 VS Code 连接到工作空间&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;纯浏览器端探索&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在我们时间过程中会发现，一些非常轻量的场景下，例如在 CodeReview 过程中需要简单修改一点代码，即使是主打轻量便捷的 CloudIDE 也稍显过重了一些。相比基于容器技术的 CloudIDE，无论是启动时间还是资源成本考虑，纯浏览器端的 IDE 都实现了真正意义上的一键启动，方便快捷。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPMvibvlhvibua2cCaF22YoNlgdyYkLAHXyPRIavcM2Sk8mia37RicyGyYeg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;01 &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;开源社区的一些实践&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPFGTM4wvbhVyrJp0Tc03qrLqWQCNPRrqNxb9OzkSicbWhdLLICia5Hj3w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;实际上在开源社区中，这类纯浏览器端的 IDE 产品在这两年已经越来越多，例如 StackBlitz 在 2021 年 Google I/O 大会上公布的基于 WebContainer 技术的在线 IDE，在浏览器中运行了一个完整的 Node.js，对于大多数前端以及 Node.js 项目都可用，也是社区非常火热的产品之一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而与 StackBlitz 非常类似的 CodeSandbox 也同样是前端同学非常熟悉的一款在线 IDE 产品，CodeSandbox 主打轻量快捷的 demo 类产品展示，同时它实现了一个浏览器端的打包工具 Sandpack，对于一些简单的 demo 展示、测试代码等场景使用也非常方便。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而另一个更为人熟知的编辑器巨头 VS Code 也在近两年逐步开放了包括 github.dev 、vscode.dev 两款产品，其中 github.dev 深度对接了 GitHub，在 GitHub 仓库页面按下快捷键&lt;span&gt; . &lt;/span&gt;即可使用 github.dev 打开项目，并支持在其中进行 CodeReview、修改、提交等功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而 vscode.dev 与之不同的是，它基于 Chrome 的 FileSystem API，这也就意味着你可以通过 vscode.dev 打开本地电脑上的项目进行编辑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;事实上除了这两款产品之外，VS Code 也在探索基于 WebAssembly 技术的浏览器端运行时，目前已经支持运行、调试 Python 程序，预计也会在不久的未来会正式公布这款产品。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;02 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我们的一些探索&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPXHPs50P9tib7MAHMXsIbg1iaImHLuh9AJk5k4oE1W4SHwQJ68mV7ZIBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在过去的一年，我们也基于 OpenSumi 在内部开发了一款纯浏览器端的 IDE 产品 &lt;span class=&quot;code-snippet__attr&quot;&gt;02&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;Code Lite&lt;/span&gt;，它不需要连接到任何容器、虚拟机环境，简单来说只是一个静态网页，我们对接了内部的代码托管以及发布平台，同样提供了简单编码以及轻量的语言服务能力，目前已经在内部多个业务场景中落地。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622775800711743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPgrk7NS5WwWicCiaBuLZcmV15ufxDltdjiadfPwicRf9eh6Ov7d4grJHXYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除此之外，我们也自研了一款类 WebContainer 产品，与 StackBlitz 类似的支持 Node.js 、支持原生运行 WebAssembly 程序包，也内置了包括 npm、yarn、tnpm 等包管理工具。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前我们尝试在一些轻量的业务开发场景开放使用 WebContainer 进行开发，在不久的未来我们也会将提供一个对外版本，支持通过 GitHub 打开进行开发。&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;👇欢迎了解 OpenSumi，参与开源共建～&lt;/p&gt;&lt;p&gt;GitHub 地址：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;https://github.com/opensumi &lt;/em&gt;&lt;/span&gt;&lt;br/&gt;（点击文末&lt;span&gt;阅读原文&lt;/span&gt;即可跳转）&lt;/p&gt;&lt;p&gt;OpenSumi 官网：&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;https://opensumi.com/zh&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;扫二维码，加入 OpenSumi 社区交流：&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;144&quot; data-cropsely1=&quot;3&quot; data-cropsely2=&quot;197&quot; data-ratio=&quot;1.405431619786615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xab1PH8kCvJ1gpAWz99e0iaxxxaobMF0f3AOIrCGicKM3x4vZIicicNaRhsDrUMhxPGw1RbtQmuIc7Q6vIHumXHPGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1031&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;微信&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPXM0HwdWxUDGo2FEwZSibKFdmJA5wuR9UKKB6Eyibf4GMBd1riaXEzOiawQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;247&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;钉钉&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xab1PH8kCvKuwcKSHJiaQgKHDPW8IZJDPicSzdPwFQZtNlRDbg4kkiaY8KqxmBR8Z33gPyz6soVHaPPswYW8yQ4Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;410&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;QQ&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4322026982e36e3e64967934e60c3938</guid>
<title>提升内存管理效率，携程酒店查询服务轻量化探索和实践</title>
<link>https://toutiao.io/k/k0n046u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;携程技术&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;ctriptech&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;携程技术官方账号，分享交流成长。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>586990c832a68995e70e44afe9aa0a6b</guid>
<title>Effective Profiling in Google Chrome</title>
<link>https://toutiao.io/k/o1l403r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;prose md:prose-md mx-auto&quot;&gt;&lt;p&gt;This blog post will explain how to effectively profile your website so that you can deal with performance pain points.&lt;/p&gt;
&lt;p&gt;We&#x27;ll go through the two most used tools in Google Chrome for profiling:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Performance tab in Google Chrome DevTools&lt;/li&gt;
&lt;li&gt;Lighthouse—an open-source tool for improving the quality of web pages&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Imagine that you optimized your backend and everything is running smoothly. However, for some reason, the load time of your pages is still unreasonably high. Your users might be experiencing sluggish UI and long load times. This post will help you sort these issues out.&lt;/p&gt;
&lt;h2 id=&quot;importance-of-profiling-your-website&quot;&gt;Importance of Profiling Your Website&lt;/h2&gt;
&lt;p&gt;When you get a greenfield project and you start building frontend from scratch, chances are that your website won&#x27;t have poor performance. In moments like these, you don&#x27;t need to worry about measuring performance and profiling. But, as time goes on and more code and logic is added to the frontend, you might start experiencing some slowdown. This is fine since you cannot predict every possible outcome of the code you added. Also, piled up features and legacy code can prove problematic after some time if they are not taken care of along the way.&lt;/p&gt;
&lt;p&gt;The thing about legacy code and old features is that very few people in your team want to deal with them. They are the dusty parts of your application and could easily break (especially if you didn&#x27;t write automated tests). But, when your application slows down, you&#x27;ll need to start looking into those deep corners of your codebase. Luckily, Google Chrome DevTools has a couple of tools that can help you.&lt;/p&gt;
&lt;h2 id=&quot;profiling-your-pages&quot;&gt;Profiling Your Pages&lt;/h2&gt;
&lt;p&gt;Let&#x27;s say your page is slow and you want to optimize it. To understand &lt;strong&gt;why&lt;/strong&gt; it is slow, you have to measure &lt;strong&gt;what&lt;/strong&gt; is slowing it down and &lt;strong&gt;how&lt;/strong&gt; it is slowing it down. In this blog post, we will describe how to do this with the Google Chrome browser. Mozilla Firefox also has its own set of tools for measuring performance, and you can find other resources and websites online that do the same, but today, we&#x27;ll focus on Google Chrome. What Chrome offers you for profiling is Performance profiling inside the Performance tab and Lighthouse inside the Audits tab in the Google Chrome DevTools (let&#x27;s just call them DevTools from now on).&lt;/p&gt;

&lt;p&gt;The easiest way to do this is to open DevTools. There are a couple of ways to open them:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Use the Inspect option by right-clicking somewhere on your page and selecting Inspect
&lt;figure class=&quot;mx-auto&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Or press Command+Option+C (Mac) or Control+Shift+C (Windows, Linux, Chrome OS).&lt;/li&gt;
&lt;li&gt;Press Command+Option+J (Mac) or Control+Shift+J (Windows, Linux, Chrome OS) to jump straight into the Console panel.&lt;/li&gt;
&lt;li&gt;Press Command+Option+I (Mac) or Control+Shift+I.&lt;/li&gt;
&lt;li&gt;Click Customize and control Google Chrome Customize and control Google Chrome and then select More Tools &amp;gt; Developer Tools.
&lt;figure class=&quot;mx-auto&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;recording-performance&quot;&gt;Recording Performance&lt;/h3&gt;
&lt;p&gt;Now that we&#x27;re in the DevTools, go into the Performance tab, and press the Record button to interact with your website. For example, if you have some part of your application that&#x27;s slow, like a list of items being scrolled, try to scroll that list when the profiler is running. Once you&#x27;re done with the interaction, press Stop or the Record button again.&lt;/p&gt;
&lt;h3 id=&quot;recording-websites-load-performance&quot;&gt;Recording Website&#x27;s Load Performance&lt;/h3&gt;
&lt;p&gt;If you want to measure how your website loads, you can click the &lt;strong&gt;Start profiling and reload the page&lt;/strong&gt; button next to the Record button. This will record what is going on and below the page while it&#x27;s being loaded. After the application has loaded and you&#x27;re finished interacting with it, click the Stop button to get a recording.&lt;/p&gt;
&lt;h3 id=&quot;reading-performance-recordings&quot;&gt;Reading Performance Recordings&lt;/h3&gt;
&lt;p&gt;After you&#x27;ve simulated the behavior that affects your website&#x27;s performance and gathered the recordings, it&#x27;s time to analyze that data. You should see something like this in your browser:&lt;/p&gt;
&lt;figure class=&quot;mx-auto&quot;/&gt;
&lt;p&gt;This can be overwhelming at first and a bit scary, but don&#x27;t back down now! As you can see, the Performance tab offers a ton of features for you to look into, but we will only glance over a few common ones. The first thing you should get acquainted with is moving around the &lt;strong&gt;Timeline&lt;/strong&gt;. The easiest way for me was to select a specific portion of the Timeline using my mouse. You can do it like this:&lt;/p&gt;
&lt;figure class=&quot;mx-auto&quot;/&gt;
&lt;p&gt;As you can see in the GIF above, I&#x27;m trying to zoom in on the place in the Timeline where the most activity occurred. The Timeline shows what is going on with your website in each frame. To be able to visually identify what was going on when you profiled your website, Timeline is painted in different colors. JavaScript execution time is marked in yellow and it&#x27;s called &lt;strong&gt;Scripting&lt;/strong&gt;. The purple area shows the &lt;strong&gt;Rendering&lt;/strong&gt; and the green parts of the Timeline show the &lt;strong&gt;Painting&lt;/strong&gt; process. To better understand what these mean, let&#x27;s dive into how the browser ships pixels to your screen.&lt;/p&gt;
&lt;figure class=&quot;mx-auto&quot;/&gt;
&lt;p&gt;Everything begins with evaluating the JavaScript code on your page, which is what the &lt;strong&gt;Scripting&lt;/strong&gt; part of Timeline refers to. This is the JS part of your code that will result in some visual changes on your website. Then, the &lt;strong&gt;Rendering&lt;/strong&gt; part comes in with &lt;strong&gt;Style&lt;/strong&gt; and &lt;strong&gt;Layout&lt;/strong&gt; coming into place. &lt;strong&gt;Style calculations&lt;/strong&gt; is a process where the browser is figuring out which CSS rule applies to which HTML element. The &lt;strong&gt;Layout&lt;/strong&gt; process tries to come up with the sizing of your elements and where to put them on the screen. Finally, we have the &lt;strong&gt;Painting&lt;/strong&gt; part that has 2 parts—&lt;strong&gt;Paint&lt;/strong&gt; and &lt;strong&gt;Composite&lt;/strong&gt;. &lt;strong&gt;Paint&lt;/strong&gt; is a process where colors, images, text, and shadows are drawn. &lt;strong&gt;Compositing&lt;/strong&gt; is a process that ensures that layers of your website are drawn in the correct order, for example, if you have elements that overlap each other. Each of these processes can slow down, and thus slow down the whole process of showing a frame to the end-user.&lt;/p&gt;
&lt;p&gt;You must be thinking, &quot;OK, now what?&quot; Hang on, we&#x27;re getting there. Chrome will mark the sections of the timeline where the UI was choppy with red in the FPS row of the timeline like below. Luckily, we just got familiar with what color represents which process, and with that knowledge, we can identify what might be wrong with the code behind it.&lt;/p&gt;
&lt;figure class=&quot;mx-auto&quot;/&gt;
&lt;p&gt;This is a clear indicator that something in there is causing poor performance. In that case, you should select the part of the Timeline that is marked as red in the FPS row and investigate the Main thread activity flame chart. If you&#x27;ve never read flame charts before, don&#x27;t worry, they are pretty intuitive. A flame chart is a data visualization of your call stack while you were profiling your app. Take a look at the call stack that is causing the most trouble by following the execution trace to the bottom. This is how you usually find the culprit.&lt;/p&gt;
&lt;figure class=&quot;mx-auto&quot;/&gt;
&lt;p&gt;In this case, JavaScript code was triggering expensive Style recalculation that caused UI to lag. In the Timeline, it will be marked as &lt;strong&gt;Scripting&lt;/strong&gt;. This is one of the major causes of poor performance. This happened to me when I was using React and was triggering unnecessary renders that caused a lot of Style changes. In React, you can achieve this by checking when a component should be rerendered using &lt;a href=&quot;https://reactjs.org/docs/react-component.html#shouldcomponentupdate&quot;&gt;shouldComponentUpdate&lt;/a&gt;. One of the solutions, in that case, is to stop triggering renders when they are
not needed.&lt;/p&gt;
&lt;p&gt;One of the guidelines for avoiding situations like these are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Let the browser do the work it can. Do not handle touch and scrolls on your own, for example.&lt;/li&gt;
&lt;li&gt;Consider using &lt;a href=&quot;https://css-tricks.com/using-requestanimationframe/&quot;&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;&lt;/a&gt; for those tricky DOM updates.&lt;/li&gt;
&lt;li&gt;Delegate some of the work to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers&quot;&gt;Web Workers&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If this is not enough, there is a great article about how to &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution&quot;&gt;optimize JavaScript execution&lt;/a&gt; to improve your website performance.&lt;/p&gt;
&lt;p&gt;Another thing that might slow down your website directly is complex CSS which will show up in the Timeline as a lot of purple sections—&lt;strong&gt;Rendering&lt;/strong&gt;. One scenario where this can happen is if you have complex CSS selectors like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.box:nth-child(n+1) a.button.submit {
  /* styles */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you have a lot of these at a bad time, the browser will have to calculate to which elements this rule applies to and will slow things down.&lt;/p&gt;
&lt;p&gt;If you&#x27;re not careful, you can also stress the browser when constantly reading and writing to the DOM. This will cause the browser to repeatedly calculate the layout over and over again. One good solution for this would be to avoid that practice somehow or resort to the &lt;a href=&quot;https://github.com/wilsonpage/fastdom&quot;&gt;fastdom library&lt;/a&gt; which batches read/write operations to the DOM so that the browser isn&#x27;t stressed too much.&lt;/p&gt;
&lt;p&gt;Some tips on reducing &lt;strong&gt;Rendering&lt;/strong&gt; as a bottleneck:&lt;/p&gt;

&lt;p&gt;You can find more great tips on solving performance problems in an article from Google Developers about &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/rendering-tools&quot;&gt;analyzing runtime performance&lt;/a&gt;. Also, check out this detailed guide on &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference&quot;&gt;performance analysis&lt;/a&gt; that explains everything that happens inside the Performance tab.&lt;/p&gt;

&lt;p&gt;Sometimes, performance drops are not affected by your code. Or, maybe the SEO score of your website is not that good and it&#x27;s being ranked poorly in searches. What do you do in that case? Well, there is a tool called Lighthouse that measures some crucial points of your app so that you can get a well-rounded website.&lt;/p&gt;
&lt;p&gt;Lighthouse is an &lt;a href=&quot;https://github.com/GoogleChrome/lighthouse&quot;&gt;open source tool&lt;/a&gt; that can also be used outside the browser. It is actively maintained by Google and it&#x27;s an important tool to have under your belt.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lighthouse analyzes web apps and web pages, collecting modern performance metrics and insights on developer best practices.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You can use Lighthouse in other contexts, but we&#x27;ll go through the process of using it inside DevTools in Google Chrome.&lt;/p&gt;
&lt;p&gt;The first thing you need to do is to open DevTools (we covered this part above) and go to the Audits tab inside it. You should see something like this:&lt;/p&gt;
&lt;figure class=&quot;mx-auto&quot;/&gt;
&lt;p&gt;To conduct an audit, click &lt;strong&gt;Perform and audit&lt;/strong&gt; and wait for the Lighthouse to finish profiling. It assesses your website using 5 categories, where you can score between 0 and 100 points for each category. Lighthouse measures:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Performance — how fast is your website?&lt;/li&gt;
&lt;li&gt;Accessibility — how accessible is your website to others?&lt;/li&gt;
&lt;li&gt;Best Practices — are you following the web&#x27;s best practices?&lt;/li&gt;
&lt;li&gt;SEO — is your website SEO friendly?&lt;/li&gt;
&lt;li&gt;Progressive Web App — is your website a PWA?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These metrics are important to have a versatile website that will stand out when a user visits it. This can increase your standing in the searches performed by users interested in your website&#x27;s topics. You can&#x27;t go wrong with trying to score as much as you can on the Lighthouse audit.&lt;/p&gt;
&lt;p&gt;After you run an audit, you will get something like this:&lt;/p&gt;
&lt;figure class=&quot;mx-auto&quot;/&gt;
&lt;p&gt;As you can see, our Performance score is not perfect, it&#x27;s in the orange range. Lighthouse then suggests which metrics attributed to this result. To learn more about the Lighthouse scoring, you can consult its &lt;a href=&quot;https://developers.google.com/web/tools/lighthouse/v3/scoring&quot;&gt;scoring guide&lt;/a&gt;. If you expand them, you can get a more detailed explanation of each metric shown.&lt;/p&gt;
&lt;figure class=&quot;mx-auto&quot;/&gt;
&lt;p&gt;When you click on the &lt;strong&gt;Learn more&lt;/strong&gt; links, you&#x27;ll be taken to a page that deals with potential solutions that address those problems. Most common solutions that make Lighthouse and users happy are to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Optimize the size of images on your website. Use tools such as &lt;a href=&quot;https://imageoptim.com/&quot;&gt;ImageOptim&lt;/a&gt; or &lt;a href=&quot;https://www.jpegmini.com/&quot;&gt;JPEGmini&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Remove unused CSS. You can identify unused CSS rules by using &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/css/reference#coverage&quot;&gt;Coverage tab in DevTools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Minify and compress your files&lt;/li&gt;
&lt;li&gt;Use a &lt;a href=&quot;https://css-tricks.com/adding-a-cdn-to-your-website/&quot;&gt;Content Delivery Network (CDN)&lt;/a&gt; to manage your assets&lt;/li&gt;
&lt;li&gt;Only run the code needed to render that page. Maybe you don&#x27;t need &lt;code&gt;lodash.js&lt;/code&gt; on your homepage after all.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can also configure Lighthouse to simulate being on a mobile device or having a slow CPU. This can be useful if you are interested in users who are visiting your website from slow mobile devices, for example. You can also change &lt;strong&gt;Throttling&lt;/strong&gt; where you can simulate slow internet speeds that can occur most often on mobile devices.&lt;/p&gt;
&lt;p&gt;Once you&#x27;re done with measuring and profiling from your browser locally, it
would be a good thing to know what is happening with your website online.
AppSignal has great &lt;a href=&quot;https://docs.appsignal.com/front-end/&quot;&gt;support for catching errors from your front-end&lt;/a&gt; that allows you to catch errors before your users do. Make sure to check it out if you run Node, Ruby or Elixir on your back-end.&lt;/p&gt;
&lt;h2 id=&quot;automating-performance-checks&quot;&gt;Automating Performance Checks&lt;/h2&gt;
&lt;p&gt;After figuring out what was slowing your app down and dealing with it, the app is now similar to the time when it was brand new and lightning-fast. I&#x27;m pretty sure you will want to keep it that way. The only way to make sure it stays fast is to measure it through time. One way you can do that is by setting up automated checks that will keep your website performance at bay.&lt;/p&gt;
&lt;p&gt;You can set up Lighthouse to run in your continuous integration (CI) by following the instructions on its
&lt;a href=&quot;https://github.com/GoogleChrome/lighthouse-ci/blob/master/docs/getting-started.md&quot;&gt;GitHub repo&lt;/a&gt;. Then, you can set it up to show up in GitHub&#x27;s pull request as a status check and block any future changes that might jeopardize the performance of your website.&lt;/p&gt;
&lt;h2 id=&quot;always-measure-the-performance&quot;&gt;Always Measure the Performance&lt;/h2&gt;
&lt;p&gt;No matter how cool and beautiful your website is, nobody will get over the fact that is slow, inaccessible or dangerous. To keep these adjectives out of the proximity of your application, I strongly suggest that you always measure the performance, whether it&#x27;s through an automated CI job, or a recurring Lighthouse run.&lt;/p&gt;
&lt;p&gt;In the end, to have a website that&#x27;s optimized and fast for all users is a journey, and profiling and reading data is just the first step in that journey. Make sure to always think of the end-user while walking on that path.&lt;/p&gt;
&lt;p&gt;I hope this blog post helped you to better grasp how you can measure your website in Chrome.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you liked this post, &lt;a href=&quot;/javascript-sorcery&quot;&gt;subscribe to our new JavaScript Sorcery list&lt;/a&gt; for a monthly deep dive into more magical JavaScript tips and tricks.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.P.S. When we wrote this, it wasn&#x27;t out yet, but AppSignal &lt;a href=&quot;https://www.appsignal.com/nodejs&quot;&gt;monitoring for Node.js apps&lt;/a&gt; is here! If you&#x27;d love an all-in-one APM for Node, go and check it out.&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>