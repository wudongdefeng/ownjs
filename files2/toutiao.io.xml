<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>15f6d06d0496d497ba91de39223fa6e4</guid>
<title>Jupyter Notebook 入门指南</title>
<link>https://toutiao.io/k/3qcyw39</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h6&gt;作者：京东科技隐私计算产品部 孙晓军&lt;/h6&gt;

&lt;h1&gt;&lt;strong&gt;1. Jupyter Notebook介绍&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0fd0cb99ada45f5ac32b7a1aa7881b5%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图1 Jupter项目整体架构&lt;/p&gt;

&lt;p&gt;[&lt;a href=&quot;https://docs.jupyter.org/en/latest/projects/architecture/content-architecture.html&quot;&gt;https://docs.jupyter.org/en/latest/projects/architecture/content-architecture.html&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Jupyter Notebook是一套基于web的交互式开发环境。用户可以在线开发和分享包含代码和输出的交互式文档，支持实时代码，数学方程，可视化和 markdown等。用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等。&lt;/p&gt;

&lt;p&gt;Jupyter Notebook内部通过内核维护状态并运行代码片段，浏览器显示代码片段和其执行的结果。Jupyter Notebook提供了一个用户交互式的开发环境，用户可以通过执行一部分代码片段，并观察执行结果。这种交互式设计，使得Jupyter Notebook非常适合数据科学和机器学习的开发工作。&lt;/p&gt;

&lt;p&gt;注意本文的代码和脚本，均基于Jupyter Notebook v6.5.2稳定版本。&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;2. Jupyter的工作方式&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e5ff3f79ea24257a2c626f0a2ebda36%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图2 Jupter Notebook工作方式&lt;/p&gt;

&lt;p&gt;[&lt;a href=&quot;https://docs.jupyter.org/en/latest/projects/architecture/content-architecture.html&quot;&gt;https://docs.jupyter.org/en/latest/projects/architecture/content-architecture.html&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Jupyter的主要工作单元是Jupyter Server和Kernel。其中Jupyter Server用来提供基于Web的界面和API服务，Kernel用来执行代码片段。浏览器通过Http和Websockets的方式和Jupyter Server进行交互，Jupyter Server和kernel之间，通过ZeroMQ进行数据通信。&lt;/p&gt;

&lt;p&gt;Jupyter Server采用经典的MVC模式，使用了tornado作为web服务器，用来提供地址映射和控制器逻辑，使用jinja2来提供模板视图功能。&lt;/p&gt;

&lt;p&gt;Jupyter Notebook（v6.5.2）项目的主要模块结构如下：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模块&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;notebook&lt;/td&gt;
&lt;td&gt;Notebook功能模块。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;terminal&lt;/td&gt;
&lt;td&gt;终端模块。为Jupyter提供控制台交互能力。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;view&lt;/td&gt;
&lt;td&gt;文件可视化模块。比如pdf文件的显示。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tree&lt;/td&gt;
&lt;td&gt;工作区目录树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nbconvert&lt;/td&gt;
&lt;td&gt;格式转换模块，可以把Jupyter Notebook转换成html，pdf等格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kernel&lt;/td&gt;
&lt;td&gt;Jupyter Notebook 内核&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;services&lt;/td&gt;
&lt;td&gt;Jupyter Notebook REST API模块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i18n&lt;/td&gt;
&lt;td&gt;Jupyter Notebook多语言资源&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h1&gt;&lt;strong&gt;3. 安装Jupyter Notebook&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;前置条件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python和pip&lt;/p&gt;

&lt;p&gt;不同的Jupyter Notebook对Python有不同的版本要求。我们安装的最新的稳定版本v6.5.2的Jupyter Notebook，要求Python的最低版本为3.6。注意这个Python的版本，不同于内核的Python版本。对于Jupyter内核来说，支持的Python版本和Jupyter Notebook依赖的Python版本没有关系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在Linux系统下安装Jupyter Notebook&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用pip安装Jupyter notebook非常简单。如果服务器同时拥有Python2和Python3的pip，注意需要使用pip3来替换命令中的pip。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 更新pip
pip install --upgrade pip
# 安装jupyter
pip install jupyter
# 检查安装的jupyter
jupyter --version
//输出 notebook  : 6.5.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;&lt;strong&gt;4. 配置和启动Jupyter&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Jupyter提供了大量的启动参数，用来配置Jupyter Server。我们可以在启动Jupyter服务时，通过命令行参数的方式配置当前启动的服务，但更普遍的方式是使用Jupyter的配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 生成配置文件
jupyter notebook --generate-config
// 默认生成的配置文件位置：
/root/.jupyter/jupyter_notebook_config.py

# 修改Jupyter配置文件...

# 启动jupyter
jupyter notebook
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jupyter直接使用一个Python文件来配置Jupyter服务，所有的配置项均通过Python代码来完成。常用的配置项及其说明如下：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.allow_root&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;为了安全，Jupyter默认不允许使用root用户启动。如果需要以root用户的身份启动Jupyter，需要开启此设定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.allow_origin&lt;/td&gt;
&lt;td&gt;&#x27;&#x27;&lt;/td&gt;
&lt;td&gt;当需要Jupyter内嵌到iframe时，可以设置为“*“来避免跨origin的限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.ip&lt;/td&gt;
&lt;td&gt;localhost&lt;/td&gt;
&lt;td&gt;当需要通过外网地址来访问Jupyter服务时，需要设置一个有效的服务器IP地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.port&lt;/td&gt;
&lt;td&gt;8888&lt;/td&gt;
&lt;td&gt;Jupyter server对外服务端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.notebook_dir&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;Jupyter的工作空间，默认可以访问服务器上当前用户的所有文件系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.open_browser&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;启动服务后是否立即通过浏览器打开服务地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.default_url&lt;/td&gt;
&lt;td&gt;/tree&lt;/td&gt;
&lt;td&gt;Jupyter服务的默认地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.extra_static_paths&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;扩展静态文件目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.extra_template_paths&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;扩展模板文件目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.KernelSpecManager.allowed_kernelspecs&lt;/td&gt;
&lt;td&gt;set()&lt;/td&gt;
&lt;td&gt;默认允许使用所有的kernel&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.NotebookApp.nbserver_extensions&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;td&gt;允许加载的Jupyter Server扩展&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h1&gt;5. 使用Jupyter&lt;/h1&gt;

&lt;h2&gt;5.1. 创建Notebook&lt;/h2&gt;

&lt;p&gt;启动Jupyter 后，在浏览器内输入 http://服务器地址:端口/，Jupyter会默认重定向到.default_url指定的工作区目录树地址，默认是工作区目录树的界面。&lt;/p&gt;

&lt;p&gt;如果在访问的过程中，使用了默认的token作为其认证方式，那么在首次打开时，需要输入Jupyter Notebook的token值，这个值可以在启动Jupyter时的控制台输出中找到，或者使用Jupyter命令来查询&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 查询运行的jupyter notebook
jupyter notebook list
//返回结果中包含了http://x.x.x.x:8899?token=ABC 的信息，其中的ABC就是我们需要的token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bd1619d943a459a80efde5b961aca66%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;图3 Jupter Notebook的默认工作区目录树页面&lt;/p&gt;

&lt;p&gt;Jupyter Notebook通过Jupyter Server提供基于Web的平台无关的工作方式，这使得跨平台开发和协作，代码分享等能力变得比传统IDE更加容易。&lt;/p&gt;

&lt;p&gt;在Jupyter 工作区管理界面，用户可以灵活地以类似文件系统的方式管理工作区的数据。可以创建文件和文件夹，编辑文件和文件夹，可以上传和下载文件。通过选择一个Jupyter内核，可以创建一个Notebook文件。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/782dd77ebc1e4fd78da31d82053620b4%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图4 通过Jupyter内核创建一个Notebook&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;5.2. 使用Notebook&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;使用Python3内核创建一个Notebook后，我们得到一个xxx.ipynb（IPython Notebook）文件。这个文件是一个json格式的文本文件，其中包含了我们在Notebook中编写的代码和文本内容，也包含了界面上没有显示的元数据信息。通过在工作区目录界面选择一个notebook文件，点击编辑，我们可以查看到ipynb文件的原始内容。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b66a3240cac142df9c4a8bf7f7879ff6%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图5 ipynb文件的原始内容&lt;/p&gt;

&lt;p&gt;我们可以像使用其它IDE类似的方式来使用Notebook，在使用Notebook上，我们主要关注下Jupyter内核和单元格。&lt;/p&gt;

&lt;p&gt;内核是执行单元格代码的核心进程，不同的内核，决定了我们在单元格中能够编写哪些语言的代码，以及对应了指定的编程语言的哪个版本等信息。&lt;/p&gt;

&lt;p&gt;单元格是整个Notebook的核心组成部分，我们编写的代码和文本，通过一些列Notebook单元格来组成。Notebook提供了Code，Markdown, Raw NBConvert, Heading四种类型的单元格。&lt;/p&gt;

&lt;p&gt;•Code单元格。用来编写内核指定语言的程序代码&lt;/p&gt;

&lt;p&gt;•Markdown单元格。使用Markdown编辑器的语法来编辑富文本&lt;/p&gt;

&lt;p&gt;•Raw NBConvert单元格。原始的文本，不会被当作代码或markdown被解释执行&lt;/p&gt;

&lt;p&gt;•Heading单元格。Heading是Mardown的一个子集，对应了Markdown中的标题编写语法&lt;/p&gt;

&lt;p&gt;Jupyter Notebook使用了机器学习中检查点的概念，在我们修改Notebook的过程中，Jupyter会自动保存我们的修改，我们也可以通过【文件】-&amp;gt;【保存】来手动保存检查点。检查点文件包含了我们编写的Notebook内容，以及执行代码单元格之后的输出。我们可以在工作空间的“.ipynb_checkpoints”文件夹下，找到这些检查点文件。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a9c22e7990b45889298ae10edbc60c9%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图6 使用Jupyter单元格来编写交互式代码&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;5.3. 分享Notebook&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;相较于使用传统的IDE编写的代码，基于Web服务的Jupyter Notebook在代码分享上拥有着天然的优势。&lt;/p&gt;

&lt;p&gt;在Jupyter Notebook中，我们可以通过两种不同的方式分享我们创作的nootbook。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;交互式Notebook文档&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;传统的技术文档或者说明书，通过静态的文本，配合图片和视频，来描述和讲解特定的技术或功能。有了Jupyter Notebook后，我们仍然可以使用Notebook来编写类似传统的技术文档。在此基础上，我们可以加入更生动的代码交互单元格，用户通过查看文档说明，并与文档中提供的代码进行互动，可以更生动地介绍产品中的功能和技术。每个Jupyter Notebook的ipynb文件，都对应了一个独立的访问地址： &lt;a href=&quot;http://x.x.x.x:8899/notebooks/my_notebook.ipynb&quot;&gt;http://x.x.x.x:8899/notebooks/my_notebook.ipynb&lt;/a&gt; ,通过分享此文件的地址，其他用户可以方便地使用包含了富文本和可执行的代码的交互式Notebook文档。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;离线Notebook文档&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们通过逐步执行文档中的所有单元格，得到一个包含了我们编写的说明和代码，以及代码执行的输出结果的完整文档。之后点击【文件】-&amp;gt; 【另存为】，选择一种合适的文件格式。我们可以把文档导出为一份静态文件，通过共享此静态文件，我们实现了Notebook文档的离线分享。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;5.4. 魔法函数&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Jupyter Notebook提供了一些列魔法函数来增强Jupyter Code单元格的功能，通过魔法函数，我们能够执行javascript脚本，html代码，运行另一个可执行程序等许多额外的功能。&lt;/p&gt;

&lt;p&gt;我们可以在Jupyter代码单元格中使用 %lsmagic命令来查看所有的魔法函数，如果要阅读详细的魔法函数的使用说明，可以参考： &lt;a href=&quot;https://ipython.readthedocs.io/en/stable/interactive/magics.html&quot;&gt;https://ipython.readthedocs.io/en/stable/interactive/magics.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;魔法函数分为行魔法函数，单元格魔法函数和会话魔法函数。顾名思义，行魔法函数只对当前行起作用，而单元格魔法函数则作用于整个单元格，会话魔法函数则作用于整个会话期间。&lt;/p&gt;

&lt;p&gt;一些常用的魔法函数：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;%matplotlib&lt;/td&gt;
&lt;td&gt;设置matplot绘图的显示模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%%javascript&lt;/td&gt;
&lt;td&gt;单元格内的代码被识别为javascript代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%%html&lt;/td&gt;
&lt;td&gt;单元格内的代码被识别为html代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%run&lt;/td&gt;
&lt;td&gt;执行外部脚本文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%pwd&lt;/td&gt;
&lt;td&gt;获取当前工作的目录位置（非工作空间目录位置）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%writefile&lt;/td&gt;
&lt;td&gt;以文件形式保存当前单元格代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%timeit&lt;/td&gt;
&lt;td&gt;获取本行代码的执行时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%debug&lt;/td&gt;
&lt;td&gt;激活调试模式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h1&gt;&lt;strong&gt;6. 管理Jupyter&lt;/strong&gt;&lt;/h1&gt;

&lt;h2&gt;&lt;strong&gt;6.1. 多语言&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Jupyter Notebook使用i18n目录下的资源来进行多语言翻译。在Jupyter Notebook启动时，会加载i18n目录下的多语言资源。之后根据http请求指定的语言，为响应数据提供对应的多语言翻译。如果没有对应的翻译，则保留原始的多语言标签值（英文）。如果调整了多语言翻译，需要重新启动Jupyter Notebook才能使用新的语言包。&lt;/p&gt;

&lt;p&gt;Jupyter Notebook的翻译资源主要分布在三个po文件中：&lt;/p&gt;

&lt;p&gt;•nbjs.po - js文件中的多语言数据&lt;/p&gt;

&lt;p&gt;•nbui.po - UI界面中的多语言数据&lt;/p&gt;

&lt;p&gt;•notebook.po - notebook中的多语言数据&lt;/p&gt;

&lt;p&gt;原始的po文件，需要通过pybabel工具，把po文件编译成mo文件，之后部署在$notebook/i18n/${LANG}/LC_MESSAGES/目录下（$notebook是notebook的安装目录），才能在Jupyter Notebook中作为多语言的资源包来使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 使用pybabel编译多语言po文件
pybabel compile -D notebook -f -l ${LANG} -i ${LANG}/LC_MESSAGES/notebook.po -o ${LANG}/LC_MESSAGES/notebook.mo
pybabel compile -D nbui -f -l ${LANG} -i ${LANG}/LC_MESSAGES/nbui.po -o ${LANG}/LC_MESSAGES/nbui.mo
pybabel compile -D nbjs -f -l ${LANG} -i ${LANG}/LC_MESSAGES/nbjs.po -o ${LANG}/LC_MESSAGES/nbjs.mo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbbc1e9e4dba45079c45f89ed18a6856%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图7 使用了中文语言包后的中文Notebook界面&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;6.2. 内核管理&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;内核（kernel）是独立于jupyter服务和界面之外的用来运行Jupyter代码单元格的进程，Jupyter默认提供了ipykernel内核来支持Python开发语言。Jupyter社区提供了jupyterC, IJava，xeus-cling, xeus-sql等众多其它编程语言的内核，用来支持C/C++, Java, SQL等编程语言。&lt;/p&gt;

&lt;p&gt;ipykernel默认使用系统环境下的Python来提供服务。我们可以使用ipykernel安装多个Python kernel来提供Python2.x, Python3.x等多个Python内核环境。&lt;/p&gt;

&lt;p&gt;安装kernel后，kernel的信息被保存在kernel.json文件中，我们可以在 /usr/local/share/jupyter/kernels 目录，找到Jupyter安装的所有kernel以及对应的kernel.json文件。&lt;/p&gt;

&lt;p&gt;kernel可以直接继承自安装kernel的Python指令，也可以使用Python虚拟环境。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 1.直接继承自Python指令的kernel安装
# 安装ipykernel
pip install ipykernel
# 安装kernel
python -m ipykernel install --name tensorflow2 --display-name &quot;tensorflow2&quot;

# 2. 在Python虚拟环境下的kernel安装
# 激活虚拟环境
source activate myenv
# 安装ipykernel
pip install ipykernel
# 安装kernel
python -m ipykernel install --name myenv --display-name &quot;Python3 (myenv)&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要查看当前的kernel列表，以及删除已经安装的kernel，可以使用如下的Jupyter命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 查看已经安装的kernel列表
jupyter kernelspec list
# 删除列表中指定的kernel
jupyter kernelspec remove kernelname
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;6.3. REST API&lt;/h2&gt;

&lt;p&gt;Jupyter提供了REST API接口来和Jupyter server进行交互。借助REST API的能力，我们可以以编程的方式和Jupyter Server进行交互，灵活地管理Jupyter Server。另外REST API为现代化的软件开发提供了一个优秀的能力：自动化。&lt;/p&gt;

&lt;p&gt;借助Jupyter Notebook REST API，可以实现文件的上传和下载，检查点管理，会话管理，内核管理，终端管理等一些列管理能力。完整的Jupyter REST API接口列表可以参考： &lt;a href=&quot;https://jupyter-server.readthedocs.io/en/latest/developers/rest-api.html&quot;&gt;https://jupyter-server.readthedocs.io/en/latest/developers/rest-api.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;要使用REST API，需要在请求中携带认证信息。Jupyter支持直接把token作为query string的方式来认证，也可以使用标准的Http Authorization头信息来完成认证。使用Authorization头来认证的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Authrozation: token 527a9f1430ccfed995ebcf15517583a2547c2469bc3c47a6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a788d8d789bb4816b29296607036c44d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图8 使用Postman来调用Jupyter REST API接口&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;6.4. 安全管理与多人协作&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Jupyter提供了灵活强大的能力，用以支持在线的交互式文档和代码的编写。但Jupyter项目自身没有提供精细化的安全管理体系，用以支持多用户下灵活地使用Jupyter Notebook的功能。对于文件安全，Jupyter依赖于启动服务的linux用户，合理地配置启动Jupyter的用户的权限，才能保证使用Jupyter的用户，不会对系统或项目造成破坏。Jupyter工作空间的设定，仅起到了方便Jupyter使用者管理必要文件的易用性，不能阻挡用户访问和管理工作空间外的文件系统。另外，配合使用Python虚拟环境，可以防止Jupyter Notebook提供的 pip install ,pip uninstall功能，对现有项目环境造成破坏。&lt;/p&gt;

&lt;p&gt;在多人协作方面，JupyterHub项目提供了多人协作Jupyter Notebook和Jupyter lab开发的能力。使用JupyterHub,不同职能的用户可以在自己独立的空间内进行Notebook的编写工作，不同用户间也可以方便地分享各自的Notebook。&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;7. 扩展Jupyter&lt;/strong&gt;&lt;/h1&gt;

&lt;h2&gt;&lt;strong&gt;7.1. 前端扩展&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Jupyter Notebook前端扩展(front end extension)是使用Javascript语言编写的异步模块，可以用来绘制Jupyter界面的仪表盘，Notebook，工具栏等，。定义一个前端扩展必须要实现一个load_ipython_extension方法，当前端控件被加载时，Jupyter client会调用load_ipython_extension方法。&lt;/p&gt;

&lt;p&gt;Jupyter Notebook前端扩展能力目前还不是一个稳定的版本，不保证代码能够向后兼容。Jupyter的JS API目前也没有官方的文档，需要通过源代码或者实际加载的JS来查看Jupyter前端脚本的成员和方法。&lt;/p&gt;

&lt;p&gt;我们实现一个简单的前端扩展脚本，在jupyter前端的工具条中，添加一个自定义工具，当点击自定义工具时，弹出提示信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([
    &#x27;base/js/namespace&#x27;
], function(
    Jupyter
) {
    function load_ipython_extension() {

        var handler = function () {
            alert(&#x27;欢迎使用前端扩展!&#x27;);
        };

        var action = {
            icon: &#x27;fa-comment-o&#x27;,
            help    : &#x27;前端扩展&#x27;,
            help_index : &#x27;zz&#x27;,
            handler : handler
        };
        var prefix = &#x27;my_extension&#x27;;
        var action_name = &#x27;show-alert&#x27;;

        var full_action_name = Jupyter.actions.register(action, action_name, prefix); // returns &#x27;my_extension:show-alert&#x27;
        Jupyter.toolbar.add_buttons_group([full_action_name]);
    }

    return {
        load_ipython_extension: load_ipython_extension
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完前端扩展代码后，我们把脚本保存到main.js文件，放置在/opt/my_extension目录下。接下来我们使用jupyter nbextension工具来安装和启用前端扩展&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 安装前端扩展
jupyter nbextension install /opt/my_extension
# 启用前端扩展
jupyter nbextension enable my_extension/main
# 禁用前端扩展
jupyter nbextension disable my_extension/main
# 查看前端扩展列表
jupyter nbextension list
# 卸载前端扩展
jupyter nbextension uninstall my_extension
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e21b3ef928244ba2850af8ca0e211a00%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图9 在Notebook工具条中加入的前端扩展&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;7.2. 服务端扩展&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Jupyter服务端扩展（server extension）是使用Python语言编写的模块，可以用来处理发送到Jupyter Server的Http请求。使用Jupyter服务端扩展，可以更改现有Jupyter请求的数据和行为，也可以为jupyter Server定义新的服务处理程序。&lt;/p&gt;

&lt;p&gt;定义一个服务端扩展模块要实现一个load_jupyter_server_extension方法，其中包含一个类型为notebook.notebookapp.NotebookApp的参数serverapp，serverapp的详细属性和方法可以通过Jupyter Notebook源代码中的notebookapp.py文件来查看。当服务端扩展被加载时，Jupyter Server会调用load_jupyter_server_extension方法。在load_jupyter_server_extension方法中，我们可以通过调用serverapp的web_app属性的add_handlers方法来注册处理程序，用来处理特定的服务端请求。处理程序类需要继承自Jupyter的IPythonHandler类。在处理程序的方法中，可以使用Jupyter提供的@web.authenticated装饰器来为方法增加身份认证保护。&lt;/p&gt;

&lt;p&gt;通过服务端扩展，还可以与前端扩展联动，实现一个功能丰富的Jupyter Notebook前端控件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 定义一个处理程序
from tornado import (
    gen, web,
)
from notebook.base.handlers import IPythonHandler

class HelloWorldHandler(IPythonHandler):
    @web.authenticated
    @gen.coroutine
    def get(self):
        self.finish(f&#x27;Hello, world!&#x27;)


# 实现load_jupyter_server_extension方法并注册处理程序
def load_jupyter_server_extension(serverapp):
    handlers = [
        (&#x27;/myextension/hello&#x27;, HelloWorldHandler)
    ]
    serverapp.web_app.add_handlers(&#x27;.*$&#x27;, handlers)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成服务端扩展代码后，我们把代码保存为&lt;strong&gt;init&lt;/strong&gt;.py文件，要在Jupyter Notebook中使用处理程序，我们还需要进行服务端扩展的安装和启用。不同于前端扩展，服务端扩展不能直接使用指令来安装，需要我们手动编写安装程序。此外，Jupyter提供了自动启用服务端扩展和前端扩展的方法，需要我们在脚本的根目录提供启用扩展的配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jupyter-config/
├── jupyter_notebook_config.d/
│   └── my_server_extension.json
└── nbconfig/
    └── notebook.d/
        └── my_front_extension.json
 setup.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入了自动启用扩展的配置，我们的服务端扩展目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hello-extension/
├── __init__.py
jupyter-config/
├── jupyter_notebook_config.d/
    └── hello_extension.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hello_extension.json文件的内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;ServerApp&quot;: {
        &quot;jpserver_extensions&quot;: {
            &quot;hello_extension&quot;: true
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们通过安装程序，安装服务端扩展的信息保存在/root/.jupyter/jupyter_notebook_config.json文件中。在安装完成后，我们可以通过jupyter serverextesion工具来股那里服务端扩展&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 启用服务端扩展
jupyter serverextension enable hello_extension
# 禁用服务端扩展
jupyter serverextension disable hello_extension

# 服务端扩展直接卸载的方法，需要我们通过pip uninstall 卸载安装程序，
# 再通过手工修改/root/.jupyter/jupyter_notebook_config.json文件删除扩展信息来完成卸载
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7b8f85d24fe41429b6993f5ab81e8fb%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图10 在浏览器中测试安装的服务端扩展程序&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;7.3. 界面定制&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Jupyter没有提供标准的界面定制的能力，但我们可以手工调整jupyter生成的模板视图文件和样式文件，达到整条调整jupyter notebook的界面的能力。&lt;/p&gt;

&lt;p&gt;Jupyter Notebook模板文件的位置为：$notebook/templates，样式和脚本定制推荐的方案是使用~/.jupyter/custom/custom.css和~/.jupyter/custom/custom.js文件。我们可以直接在此基础上对文件进行修改，还可以通过extra_template_paths和extra_static_paths来引入其它位置的模板和其它静态文件。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/377c4bbb3ac5442c8130ac671dbfca89%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图11 通过直接调整模板文件加入的界面定制按钮&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;7.4. 小部件&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;小部件（Widgets）是Jupyter交互式可视化数据呈现部件。Jupyter Widgets同时包含了访问后端数据和前端呈现的能力，可以用于在Jupyter Notebook上生动地展示服务端的数据和数据变化。&lt;/p&gt;

&lt;p&gt;在v6.5.2稳定版本上，我们目前只能使用系统提供的小部件，还不能开发自定义小部件。在Jupyter notebook7.x版本中，开始提供了小部件的自定义开发能力。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 确保安装了ipywidgets和traitlets
pip install --upgrade traitlets
pip install --upgrade ipywidgets

# 安装和启用小部件
jupyter nbextension install --py widgetsnbextension
jupyter nbextension enable --py widgetsnbextension
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在安装和启用了小部件后，我们可以在notebook中直接使用系统提供的小部件。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63ca91d9bc4d477598c5b294e1cd15f2%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;图12 在Notebook中使用小部件&lt;/p&gt;

&lt;p&gt;完整的小部件列表和使用方式可以参考： &lt;a href=&quot;https://ipywidgets.readthedocs.io/en/7.x/examples/Widget%20List.html&quot;&gt;https://ipywidgets.readthedocs.io/en/7.x/examples/Widget%20List.html&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;8. 总结&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Jupyter Notebook以其丰富的功能，简单易用，强大的交互能力和扩展能力，成为数据科学和机器学习开发中的神器。目前，Jupyter Notebook支持超过40种编程语言，被应用于Google Colab, Kubeflow, 华为云，kaggle等多个知名项目中，大量机器学习和数据科学的论文中使用到了Jupyter。Jupyter在数据可视化，提升工作效率，改善用户体验和丰富文档功能方面显现了巨大的威力。除此之外，Jupyter还提供的灵活强大的扩展能力，更是为Jupyter的深层次使用提供了更广阔的想象空间。如果你还没有开始接触Jupyter，那么就从现在开始吧。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8a8896830c54b4bc69267c7fbe0cb288</guid>
<title>6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理</title>
<link>https://toutiao.io/k/f6e4akr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇给大家带来的是微服务框架中非常重要的一个组件：API 网关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文已收录至&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAwMjI0ODk0NA==&amp;amp;action=getalbum&amp;amp;album_id=2083392961806925826#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《深入剖析 Spring Cloud 底层架构原理》&lt;/a&gt;，已更新 16 讲。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6450549450549451&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEwQibSZVERpJAjGve11zyhoQ5sgV16pmhJMc3H5ibWHiaTVT1qSaQTmBkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1820&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 PassJava 项目中，我用到了 Spring Cloud Gateway 作为 API 网关，客户端的所有的请求都是先经过网关，然后再转发到会员微服务、题目微服务等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 API 网关和会员微服务对应的访问地址如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;API 网关地址：http://localhost:8060&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会员微服务地址：http://localhost:14000&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端请求都是访问的 API 网关，然后网关转发到会员微服务，客户端无需知道会员微服务的地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇将会以 PassJava 作为案例进行讲解。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PassJava 开源地址：https://github.com/Jackson0714/PassJava-Platform&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么需要 API 网关&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 SpringBoot 单体架构中，一般只有一个后端服务，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6771653543307087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFE4Tb61OSkuVWzRXEzVavqxl3psibMoRnwicmIacZ68I9uNSTfIr3iacZ0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;figcaption&gt;单体架构访问示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在 SpringCloud 微服务架构中，往往有多个微服务，这些微服务可能部署在不同的机器上，而且一个微服务可能会扩容成多个相同的微服务，组成微服务集群。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8391472868217055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFE8HON8fPcfoPjzLQQomPqqwMgh8S8PTpJlyBkViarHUmiaH7YJ5GkibSXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1032&quot;/&gt;&lt;figcaption&gt;微服务架构访问示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况下，会存在如下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果需要添加鉴权功能，则需要对每个微服务进行改造。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果需要对流量进行控制，则需要对每个微服务进行改造。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;跨域问题，需要对每个微服务进行改造。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存在安全问题，每个微服务需要暴露自己的 Endpoint 给客户端。Endpoint 就是服务的访问地址 + 端口。比如下面的地址：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;http://order.passjava.cn:8000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;灰度发布、动态路由需要对每个微服务进行改造。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题的痛点是各个微服务都是一个入口，有没有办法统一入口呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决这个问题的方式就是在客户端和服务器之间加个中间商就好了呀，只有中间商一个入口，这个中间商就是网关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;还有一个细节问题&lt;/strong&gt;：多个微服务之间是如何通信的？这就要用到远程调用组件了，比如 OpenFeign。但是服务之间的调用是需要知道对方的 Endpoint 的，如果一个服务有多个微服务，就需要通过负载均衡组件进行流量分发。那微服务之间不就暴露 Endpoint 了吗？这个没有问题，毕竟只是后端服务知道，外界是不知道的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9978260869565218&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFE31faEsZ3Ool3l6tjI2fXTo2fM308qOvHyLDghNXew5ibn3zFvpjVdxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了帮助大家更容易理解网关的作用，这里有个网关、客户端、微服务的三方通话。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关对话&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网关&lt;/strong&gt;：客户端你好，你现在可以只跟我通信了，我可以将你本来想发给微服务的流量进行转发，微服务处理完之后，将结果返回给我，我再给你。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端&lt;/strong&gt;：你没有赚差价吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API 网关&lt;/strong&gt;：我可能会加些请求头、做下认证、鉴权、限流等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端&lt;/strong&gt;：微服务不是自己可以做吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API 网关&lt;/strong&gt;：但是每个微服务都得自己加，这就很麻烦了，都交给我就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;微服务&lt;/strong&gt;：网关你好，你会为我保密我的地址对吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API 网关&lt;/strong&gt;：当然，我给客户端看的是我自己的地址，客户端不需要知道你的地址，只需要知道你的 API 是哪个就行，剩下的交给我来转发给你。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;API 网关选型对比&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界比较出名的网关：Spring Cloud Gateway、Netflix Zuul、Nginx、Kong、Alibaba Tengine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为 Spring Cloud 全家桶中的一款组件，当然选择 Spring Cloud Gateway 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最开始 Spring Cloud 推荐的网关是 Netflix Zuul 1.x，但是停止维护了，后来又有 Zuul 2.0，但是因为开发延期比较严重，Spring Cloud 官方自己开发了 Spring Cloud Gateway 网关组件，用于代替 Zuul 网关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以本篇我们只会讲解 Spring Cloud Gateway 网关组件。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Cloud Gateway 的工作流程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Gateway 的工作流程如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.6977777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEPsQuxIDpVy9JvicAQU0QrAia23nVlS1P4GHyDfjAMAtcLILibpicj9vvPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;① &lt;strong&gt;路由判断&lt;/strong&gt;；客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;② &lt;strong&gt;请求过滤&lt;/strong&gt;：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在...之前”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;③ &lt;strong&gt;服务处理&lt;/strong&gt;：后端服务会对请求进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;④ &lt;strong&gt;响应过滤&lt;/strong&gt;：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在...之后”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⑤ &lt;strong&gt;响应返回&lt;/strong&gt;：响应经过过滤处理后，返回给客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小结：客户端的请求先通过匹配规则找到合适的路由，就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次经过过滤器处理，最后返回给客户端。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Cloud Gateway 的断言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言（Predicate）这个词听起来极其深奥，它是一种编程术语，我们生活中根本就不会用它。说白了它就是对一个表达式进行 if 判断，结果为真或假，如果为真则做这件事，否则做那件事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Gateway 中，如果客户端发送的请求满足了断言的条件，则映射到指定的路由器，就能转发到指定的服务上进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言配置的示例如下，配置了两个路由规则，有一个 predicates 断言配置，当请求 url 中包含 api/thirdparty，就匹配到了第一个路由 route_thirdparty。（代码示例来自我的开源项目 PassJava）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5961070559610706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEic5vckEJFXibibcEWpdJatZjFeNT1z7hEhibNv9PSIfbJiaTI32rdGV730Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1644&quot;/&gt;&lt;figcaption&gt;断言配置&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们看下 Route 路由和 Predicate 断言的对应关系：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1076923076923078&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFE5ibAUpeUvSzmt3b1EspgaaVMXUjzoQVGiaeLzKVLiaibjDSW2ibnhDibgSFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1690&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;断言和路由的对应关系原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;一对多&lt;/strong&gt;：一个路由规则可以包含多个断言。如上图中路由 Route1 配置了三个断言 Predicate。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;同时满足&lt;/strong&gt;：如果一个路由规则中有多个断言，则需要同时满足才能匹配。如上图中路由 Route2 配置了两个断言，客户端发送的请求必须同时满足这两个断言，才能匹配路由 Route2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;第一个匹配成功&lt;/strong&gt;：如果一个请求可以匹配多个路由，则映射第一个匹配成功的路由。如上图所示，客户端发送的请求满足 Route3 和 Route4 的断言，但是 Route3 的配置在配置文件中靠前，所以只会匹配 Route3。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的 Predicate 断言配置如下所示，假设匹配路由成功后，转发到 http://localhost:9001&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44811858608893956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEibXBYVziaGNjrm6RXLqQh6UyJRQ2gJJJpor8bbfEpB0ZVMWPd5GA4aTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1754&quot;/&gt;&lt;figcaption&gt;常见的 Predicate 断言配置&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面演示 Gateway 中通过断言来匹配路由的例子。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新建一个 Maven 工程，引入 Gateway 依赖。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-gateway&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新建 application.yml 文件，添加 Gateway 的路由规则。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cloud:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;gateway:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;routes:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;route_qq&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;uri:&lt;/span&gt; &lt;span&gt;http://www.qq.com&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;predicates:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;Query=url,qq&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;route_baidu&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;uri:&lt;/span&gt; &lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;predicates:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;Query=url,baidu&lt;/span&gt;&lt;br/&gt;&lt;span&gt;server:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8060&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一条路由规则：断言为 Query=url,qq，表示当请求路径中包含 url=qq，则跳转到http://www.qq.com&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二条路由规则：当请求路径中包含 url=baidu，则跳转到http://www.baidu.com&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Cloud Gateway 动态路由&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务架构中，我们不会直接通过 IP + 端口的方式访问微服务，而是通过服务名的方式来访问。如下图所示，微服务中加入了注册中心，多个微服务将自己注册到了注册中心，这样注册中心就保存了服务名和 IP+端口的映射关系。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.549492385786802&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEalWia3m8AooW7me9qibFibyzBeHKAianFTSSvoxBIribibYVq3QDwvlHK4Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;figcaption&gt;微服务注册到注册中心&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来看下加入 Gateway 后，请求是如何进行转发的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端先将请求发送给 Nginx，然后转发到网关，网关经过断言匹配到一个路由后，将请求转发给指定 uri，这个 uri 可以配置成 微服务的名字，比如 passjava-member。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个服务名具体要转发到哪个 IP 地址和端口上呢？这个就依赖注册中心的注册表了，Gateway 从注册中心拉取注册表，就能知道服务名对应具体的 IP + 端口，如果一个服务部署了多台机器，则还可以通过负载均衡进行请求的转发。原理如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3469985358711567&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEKxBHgZySMxA6oggOXc7dbzJSIibo6kEJuYMWbb2pf9yrRDm7HIrV8Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1366&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;网关+注册中心&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的配置为 uri 字段如下所示&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3412887828162291&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFECMPnoViaj4kgicfvLHNHbjj8SsXkXoJBBl6CJiaU5GbuEiad5L8ODbbIQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1676&quot;/&gt;&lt;strong&gt;uri: lb://passjava-question&lt;/strong&gt;，表示将请求转发给 passjava-question 微服务，且支持负载均衡。lb 是 loadbalance（负载均衡) 单词的缩写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那什么叫动态路由呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 passjava-question 服务添加一个微服务，或者 IP 地址更换了，Gateway 都是可以感知到的，但是配置是不需要更新的。这里的动态指的是微服务的集群个数、IP 和端口是动态可变的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码示例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例：调用 OSS 第三方服务，上传文件到 OSS。（基于 PassJava 项目）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前提：前端页面配置的统一访问路径是网关的地址：http://localhost:8060/api/，OSS 服务对应的地址是http://localhost:14000。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;期望结果：将前端请求&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http:&lt;span&gt;//localhost:8060/api/thirdparty/v1/admin/oss/getPolicy&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;转发到 OSS 服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http:&lt;span&gt;//localhost:14000/thirdparty/v1/admin/oss/getPolicy&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置网关：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cloud:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;gateway:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;routes:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;route_thirdparty&lt;/span&gt; &lt;span&gt;# 第三方微服务路由规则&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;uri:&lt;/span&gt; &lt;span&gt;lb://passjava-thirdparty&lt;/span&gt; &lt;span&gt;# 负载均衡，将请求转发到注册中心注册的 passjava-thirdparty 服务&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;predicates:&lt;/span&gt; &lt;span&gt;# 断言&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;Path=/api/thirdparty/**&lt;/span&gt; &lt;span&gt;# 如果前端请求路径包含 api/thirdparty，则应用这条路由规则&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;filters:&lt;/span&gt; &lt;span&gt;#过滤器&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;RewritePath=/api/(?&amp;lt;segment&amp;gt;.*),/$\{segment}&lt;/span&gt; &lt;span&gt;# 将跳转路径中包含的api替换成空&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试上传文件成功。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48898216159496327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEDEBAA6iaefeuvWF7T45hMkLMleB9icMcGL5x1InOy2goEaXia5agglDew/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;953&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们看下 Gateway 非常重要且核心的功能：过滤器。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Cloud Gateway 的过滤器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关，顾名思义，就是网络中的一道关卡，可以统一对请求和响应进行一些操作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;过滤器 Filter 的分类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过滤器 Filter 按照请求和响应可以分为两种：&lt;code&gt;Pre&lt;/code&gt; 类型和 &lt;code&gt;Post&lt;/code&gt; 类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Pre 类型&lt;/strong&gt;：在请求被转发到微服务之前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Post 类型&lt;/strong&gt;：微服务处理完请求后，返回响应给网关，网关可以再次进行处理，例如修改响应内容或响应头、日志输出、流量监控等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一种分类是按照过滤器 Filter 作用的范围进行划分：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GlobalFilter&lt;/strong&gt;：全局过滤器，应用在所有路由上的过滤器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;局部过滤器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GatewayFilter&lt;/strong&gt;：局部过滤器，应用在单个路由或一组路由上的过滤器。标红色表示比较常用的过滤器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整理了一份 27 种自带的 GatwayFilter 过滤器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5580389329488104&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEiaIqIPUzn4dnib0eNsGwVk7icczYjtDicuspL5m95tS0N7Dleo6MKfgyrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2774&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体怎么用呢，这里有个示例，如果 URL 匹配成功，则去掉 URL 中的 “api”。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;filters:&lt;/span&gt; &lt;span&gt;#过滤器&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;-&lt;/span&gt; &lt;span&gt;RewritePath=/api/(?&amp;lt;segment&amp;gt;.*),/$\{segment}&lt;/span&gt; &lt;span&gt;# 将跳转路径中包含的 “api” 替换成空&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然我们也可以自定义过滤器，本篇不做展开。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;全局过滤器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整理了一份全局过滤器的表格，具体用法可以参照官方文档。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;官方文档：https://cloud.spring.io/spring-cloud-static/Greenwich.SR2/single/spring-cloud.html&lt;span&gt;#_global_filters&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5067178502879078&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFELTuzAEYOFib71ytc2He3RIcwfHSTFEbY2bV4IULIqvmKoYv59nAfzOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1042&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局过滤器最常见的用法是进行负载均衡。配置如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;spring:&lt;br/&gt;  cloud:&lt;br/&gt;    gateway:&lt;br/&gt;      routes:&lt;br/&gt;        - id: route_member # 第三方微服务路由规则&lt;br/&gt;          &lt;span&gt;uri&lt;/span&gt;: lb:&lt;span&gt;//passjava-member # 负载均衡，将请求转发到注册中心注册的 passjava-member 服务&lt;/span&gt;&lt;br/&gt;          predicates: # 断言&lt;br/&gt;            - Path=&lt;span&gt;/api/m&lt;/span&gt;ember&lt;span&gt;/** # 如果前端请求路径包含 api/member，则应用这条路由规则&lt;br/&gt;          filters: #过滤器&lt;br/&gt;            - RewritePath=/api/(?&amp;lt;segment&amp;gt;.*),/$\{segment} # 将跳转路径中包含的api替换成空&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个关键字 &lt;code&gt;lb&lt;/code&gt;，用到了全局过滤器 &lt;code&gt;LoadBalancerClientFilter&lt;/code&gt;，当匹配到这个路由后，会将请求转发到 passjava-member 服务，且支持负载均衡转发，也就是先将 passjava-member 解析成实际的微服务的 host 和 port，然后再转发给实际的微服务。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现简单的 token 认证&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用 Gateway 做登录认证的时候，通常需要我们自定义一个过滤器做登录认证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如客户端登录时，将用户名和密码发送给网关，网关转发给认证服务器后，如果账号密码正确，则拿到一个 JWT token，然后客户端再访问应用服务时，先将请求发送给网关，网关统一做 JWT 认证，如果 JWT 符合条件，再将请求转发给应用服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理如下图所示，红色框框的部分就是待会我要演示的部分。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2046296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEIricWzXQWoQ9P2WIcgsKicf6jjbTsZz0UPOtsEl7bZWF2gQW28iaasFvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;案例演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面做一个简单的认证实例。客户端携带 token 访问 member 服务，网关会先校验 token 的合法性，验证规则如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当请求的 header 中包含 token，且 token = admin，则认证通过。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当验证通过后，就会将请求转发给 member 服务。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码示例&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先定义一个全局过滤器，验证 token 的合法性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalLoginFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;GlobalFilter&lt;/span&gt;, &lt;span&gt;Ordered&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;Void&amp;gt; &lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(ServerWebExchange exchange, GatewayFilterChain chain)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ServerHttpRequest request= exchange.getRequest();&lt;br/&gt;        String token = request.getHeaders().getFirst(&lt;span&gt;&quot;token&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(!StringUtils.isEmpty(token)){&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;&quot;admin&quot;&lt;/span&gt;.equals(token)){&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; chain.filter(exchange);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; exchange.getResponse().setComplete();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getOrder&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先测试在 header 中添加 token=123，响应结果为 401  Unauthorized，没有权限。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFEWXJD5G4Rd9PnpHMYicCvPnaeSvqNYEHEXZyA3RWMHuzmtBTiabEFpPhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.44537037037037036&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后测试在 header 中添加 token=admin，正常返回响应数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7326607818411097&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15iasHBP1CxbYejlrAHIYFESRoDJ5wdGKt4Tmgic4LoJApibVAuoEvgib9y2ic2kScHibWu979fL4WUOqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1586&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下一篇：如何用 Gateway 做登录鉴权：SpringCloud Gateway + JWT Token&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>94dde32613d0402d1c8395688014a04e</guid>
<title>数据与广告系列三十五：召回，没有什么是一个双塔解决不了的，如果有，那就多来几个</title>
<link>https://toutiao.io/k/570tp2q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作者·黄崇远&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;『数据虫巢』&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全文&lt;strong&gt;19476&lt;/strong&gt;字&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;题图ssyer.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;374&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;468&quot; data-ratio=&quot;1.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqsfk6bM7QwwqsV0svU56oFLHff0buVJddcKmPYg6kQyInQjpKlpvRWFQKGgxxdb9kM6tvMCicTjpfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;“&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 广告推荐的召回，没有什么是一个双塔解决不了的，如果有，那就多来几个。当然，这是戏说，但对于召回技术来说，确实是崛起于双塔，或者说双塔技术为推荐广告的召回提供了更广阔的想象空间，但实际上召回发展的路上，却不止于双塔。&lt;strong&gt;&lt;span&gt;”&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如题引，我们今天的主题包含了两层，业务视角是召回，技术视角是双塔技术的演化，而逻辑的推进是两者的有机结合，最终我们会沿着召回发展的足迹，深入去剖析基于双塔向量召回的演化，我们最终再跳出双塔召回的束缚，看召回的本质。&lt;br/&gt;PS：万字长文，慎入坑。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;召回今生前世&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;世界上本没有召回，然而当需要待推荐的资源多了，也就有了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时确实如此，召回的概念来源于推荐（包含了广告的推荐）的推送资源的筛选分层，然而分层的前提是候选资源太多，一个排序筛选的模型（通常是point-wise）实际上在用户等待的耐心范围内（耗时），不允许模型对太多资源进行转化概率的计算（或者广告中eCPM的计算）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42099898063200814&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqse57xyjoNS4Y1RJEav6E911vv3HID54tnP4X1dvNojEcgzQnyiczkNk0F9aB3vjHcJj1tArxoBuNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;981&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，就有了上图类似的层级划分，江湖人称“推荐三段式”--召回，粗排，精排。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，在“远古”时代，推荐系统远没有这么复杂，候选资源少意味着不需要太多的筛选，用户心思单纯，太容易转化了（相对于人肉编辑资源展示的逻辑来说），所以没有人去干这种吃力不讨好的事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一切的一切发生在互联网信息爆炸时代，这个爆炸来自于一方面是数据的爆炸，这意味着候选资源指数级的上涨（得益于互联网/移动互联网的普及，以及分布式技术的发展），那么必然需要一种新的信息筛选模式去支持这种数量级的扩张；其次是用户体验的爆炸，或者说被轰炸，导致了用户皮糙肉厚，即内容的高度同质化，导致了用户麻木了，所以在最终推荐的候选上，或者严格说效果上，需要做的更加的深入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，过去那种简单粗暴直接一个模型推荐的思路玩不转了，比如推荐领域的经典协同推荐思路，必然面临着如何高效筛选信息的演进。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，资源的筛选的逻辑分层是一个必然的趋势。只是说不是一下子进化成当前流行的三段式。饭是一口一口吃的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直接的模型推荐演变成了先进行粗筛，然后再进行模型精准的预估，这就意味着粗筛层是足够高效的（整体时间有限，需要留时间给更重要的精准筛选层），且大体上是能体现效果的--不一定完全精准，但要做到大差不差。于是，天马行空的思路就出来了，比如基于历史表现来筛选，比如基于把一些新进来的作为粗筛候选，又比如给资源和人打标，通过标签来做粗筛选。其中，具有时代代表意义的就是协同模型（又见协同），不那么靠谱但又足够高效可离线化协同模型退化成了召回支持模型（协同老矣，尚能饭）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;五花八门，召回成了一个大杂烩，成了探索什么推荐新颖、候选多样的阵地，也成了产品经理显神通的法宝（各种花式召回策略嘛）。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个群星闪耀的时代，也是一个群魔乱舞的时代，各种标签匹配召回、热度召回、随机召回、新候选召回、协同召回、不知名的规则召回等等--多路召回的闪耀时代。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所谓英雄起于乱世，而终结乱世，请站好，我们的主角要登场了，更准确的说是要清场了--双塔，严格来说是双塔技术支撑的向量召回的模式，终结了多路召回的混乱时代。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;双塔，出道即巅峰&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;聊双塔，聊向量召回之前，我们回忆下三段式的职责，特别是召回的--需要足够的高效，且效果上要大差不差，最起码不能给人家粗筛出明显是badcase的东西出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;带着这两个问题，我们来看什么是双塔。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于起源论文，这里就不贴了，最早由微软提出，后续到国内大厂中又陆续衍生出很多变种变种模型，这里贴一个之前贴过的结构图，简单阐述下，为什么双塔可以解决，或者说很好的解决召回的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9704641350210971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqtLXmOpQks9QDxcAKZf2XwNwEAyRHg4r2sI1lsSN2YsgTEcrgKzdvYbZ0sq0DRh5PpxmJYpaTRibqQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;948&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个挂了广告与用户召回场景的简易结构图，一端是User，一端是Item，在这里就是广告Ad，User与Item有各自独立的网络结构，当然，这里只是贴了最简单的逻辑，特征embedding化，然后过全连接层，就直接到了各自网络的顶部，顶部各自表征的embedding进行叉乘，然后过sigmod转化为01区间。如果按梯度求解的思路观测就反过来，通过顶部的正负样本，不断地反向传播，进行梯度求解，最终拟合网络参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看结构就是标准的两个塔形结构，所以俗称双塔模型。这里需要注意，我们需要的东西其实并不是一个模型，而是模型稳定之后输出的两塔塔尖的表征，即最后一层全链接层分别对于User与Item的表征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是涉及到了召回阶段的第一要素--高效。由于双塔的结构特点，导致了双塔各自的塔尖实际上是分别对于User与Item的表征，所以，当模型稳定之后，实际上对于单个用户的广告播放请求来说（通常，一个用户需要给他呈现广告时，我们称之为为用户播放一个广告），User是固定的，Item是一个集合，那么理论上是不是可以提前让所有的User和所有的Item的embedding都提前计算好，这样，召回的时候，实际上一个在线查表的过程，查询到对应User的embedding和Item的embedding，然后叉乘计算得分排序，然后召回TopK的资源，这样整个过程可以控制在10ms级，完全满足粗筛的性能要求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，模型结构决定了双塔模型可以让推理发生在离线端，不用像预估模型那样，有多少个候选资源，就需要做多少次user*item的得分推导，导致了其可以理论计算的范围大很多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，在实际操作中，并不是完全的做离线查找，因为User端显然只需要推导一次，这就意味着User端实际上可以是放到线上去的，且可以带来不少的好处。比如，新用户同样可以获得embedding的表征，以及模型可以及时的更新，这里所说的更新，比如小时级，甚至是10分钟级，让模型增量update一次，保持模型对最新数据的感知，从而不断地调优embedding。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而这种频次的更新，对于item侧来说，只需要批量更新item的离线embedding即可，大部分互联网的场景中，虽然item也可能几十万，上百万，但是对于动辄上亿、六七亿的User量级来说，这个更新成本是完全可接受的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哪怕对于部分电商场景来说，Item资源池巨大，比如需要从几百万的Item资源库中快速检索与当前User相关的资源，目前也有不少解决方案，比如一些开源的向量检索引擎Faciss等，都能解决在线检索问题的性能，只要把在线推导问题转换为在线检索问题，效率是可以得到保证的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至此，双塔完美地解决了召回所需要的性能问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到双塔对于塔尖User和Item的表征问题，这种表征由于是通过User与Item的交互样本反向梯度求解出来的，所以表征中自然夹带了User与Item的关系。即，当User-embedding与Item-embedding叉乘的时候，自然而然的与样本的分布所趋近了，这就是所谓的对CTR有一定的拟合作用（假设正样本是点击样本的话）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PS：关于双塔embedding表征的问题，可以看下之前的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjM2MTY0OQ==&amp;amp;mid=2650474763&amp;amp;idx=1&amp;amp;sn=aa0834e1ceae6f79db62fbb51c7a7ff5&amp;amp;chksm=83bca3d5b4cb2ac33649b470622b01f993a39698333fc32b90cbf176d36e13a4ce8a0eb6f242&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《数据与广告系列二十五：Embedding的起源与演化，以及序列构建与目标拟合派的流派之争》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《数据与广告系列二十五：Embedding的起源与演化，以及序列构建与目标拟合派的流派之争》&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看着还是很粗糙，User与Item直到最后才发生交集，虽然用的是CTR的样本，但是这种程度的学习，能让模型很好的识别这种点击预估关系吗？理论上是不能的，特别是跟直接做点击与否预估的深度模型比，但是如果跟过去的召回逻辑相比呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如标签匹配的召回。标签匹配，标准的做法是User测打标，Item测打标，然后通过标签匹配命中来进行召回。就算画像标签做的再准，还是有几个致命的问题，比如标签是对于群体的描述，颗粒度是一类，而双塔向量的召回颗粒度是User*item级别。其次是标签更新的问题，通常是比较滞后的。所以，整体而言，这是一种粗颗粒度的，且对于个性化不敏感的召回逻辑。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，标签召回在常规召回中无法做到的更多，但在某些特殊的场景中，比如即时兴趣召回上，结合实时的数据回流，近乎实时的给用户打标，然后在下个Action中通过标签匹配的方式，召回即时兴趣的候选，是一种较为常用的手法。这就是我们所谓，刚看到刚点击完某个东西，结果推荐系统就给你推荐XX的大体逻辑，通过即时兴趣打标的方式，然后结合实时工作流进行召回。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但这种剑走偏锋的方式毕竟无法替代核心主路逻辑，只是在某些特殊的场景中，或者作为一种补充召回方案使用，毕竟对于近实时的行为捕捉与描述不一定能够准确的描述用户的偏好，以及由于时效性的原因，这种预测方式必然无法做的更加的精细，这也就是为何大多偏向于即时打标的方式来做，而不是用复杂的深度模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再例如，双塔向量与协同推荐的召回相比，协同的大体逻辑见图（截自亚马逊的论文&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文《Item-Based Collaborative Filtering Recommendation Algorithms》）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.33256880733944955&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqv9icsz2ImSmMjr6KRbMq1n9MfZKHm1xvRTYXTlWAfzHRia0BErb1KAicicOOK5ebvOxiax1gjCB2iaR0Pg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1744&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图所示，协同模型输入是User与Item的行为数据，依赖行为构建User*Item的关系矩阵，通过矩阵的方式计算User与User的关系，或者计算Item与Item的关系，如果需要计算User与Item的关系，则依赖于当前User找到近邻的User，然后通过近邻的User的Item偏好指向，最终来给当前User推荐近邻整体偏好的Item。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说白了，这是一种相似关系计算，而相似计算的输入是User*Item的行为，并没有额外的信息输入了。哪怕是协同中相对复杂点的分解逻辑，也不过是把显式的行为矩阵计算转换为了一种中间态的数学计算，比如矩阵分解的方式中，把中间关联关系通过隐式矩阵的方式进行关系表征了，与常规User2CF，Item2CF并没有质的不同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，协同的最大限制在于输入的固定，只依赖交互行为的计算存在太多的问题，比如行为关系的多寡会影响User与User，Item与Item的计算，然后行为的频繁程度会影响关系计算的是否置信，无法引入User与Item本身的特征会导致很多预测是失真的，以及无法解决新用户新Item的问题，每次引入新的批次需要整体重新计算等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总之，协同的模型，从推荐的远古时代一直服务到现在，从推荐模型退化到一路召回逻辑，发光发热已经尽责了，我们不能要求的更多，放过他吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上来看，基于双塔模型结构的召回，完美的解决了召回阶段所要求的高性能，哪怕是从几十万上百万的候选中快速进行召回；也解决的了效果问题，先不说效果到底有多好，但与我们传统的标签匹配，协同，以及基于逻辑规则的一些召回相比，向量召回的建模逻辑决定了他的起点远高于过去的那些召回方式，意味着哪怕是按着流程简单建模，其效果也会得到明显的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;双塔模型的准入门槛也低，两个基本的深度网络结构，过几道全链接层，搁一个刚毕业的计算机学生都会。所以，其准入门槛是非常低的，当然不是说个大厂实际用的就是这么简单，而是说这事的基本门槛不高，在低投入下能带来高回报，ROI比较高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，基于双塔的向量召回从此一统江湖，成为召回领域的绝对扛把子--不是说其他召回自此消失不见了，而是说作为召回的主要逻辑，或者说主路召回方式，基于双塔的向量召回成为了一个必选项。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是随着向量召回的一统江湖，其迭代增长的曲线是平缓的，远不如精排预估的模型演化来的轰轰烈烈，整体而言不温不火。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给人一种出道即巅峰的感觉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于双塔的向量召回，之所以能成为当前潮流的主路召回，核心在于其双塔的网络结构，使得其可以进行User在线部署与Item端离线部署，从而获得在万军之中取上将首级的能力（海量候选中召回候选资源）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但因为要保证User与Item各自表征的纯粹性，导致了双塔必然无法进行交叉，从而让两端只能输入各自的行为与特征，这对于预估的精准来说是致命的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你不能绕开双塔的塔形结构，一旦绕开了就不是双塔了，最核心的是无法做高效推理了；如果不绕开，那么就很难解决进一步的效果问题。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这似乎是一个死结，我们来看前行者们如何解决这些问题。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;不止于双塔&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于双塔模型结构的向量召回，得益于其双塔分离的顶部embedding表征方式，使得其能够进行高效计算User和Item的关系，但也由于双塔的分离式的塔形结构，使得模型的最终拟合能力不够（或者说表达能力不足）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到模型结构，我们将整个过程自底向上拆分，为了实现增强模型表达能力这件事上，在原始特征层我们可以做什么，在塔身结构中我们可以做什么，在塔顶各自embedding表征上我们可以做什么，在塔尖交汇的地方我们可以做什么。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是原始特征层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如章节2中的基本User2Ad的双塔基本结构图，特征层输入的都是非常纯粹的User特征信息，例如用户的ID、性别、年龄，使用APP的偏好，搜索偏好等等。Ad广告特征信息，例如ID、投放的标的物，广告类型，投放位置，广告出价等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么不能加入交互特征呢？虽然无法加入需要实时交互的行为特征，但是可以加历史的表现数据呀，从而实现User与Ad的伪交叉，让两个塔提前学习到历史上对应的User分别喜欢什么Item，Item更受什么User所偏爱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最直接的当然是直接把交互ID都放上去，例如对于User来说，就把过去一段时间内跟他有正/负交互的Item ID都放上去，形成一个多值特征，但这种做法非常容易导致维度爆炸，特别是对于Item侧来说，比如一个广告，可能被数百万的User所点击，总不能都放进去吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然无法做到这么细颗粒度，那么就上溯，上溯到例如User2Item-feature，或者Item2User-feature。用户偏爱什么类型的广告，偏爱到什么程度，广告适用于什么类型的用户，比如性别、年龄上的偏好特征等等。对于User来说，Item实际上是相对有限的，可以做成序列的embedding特征作为输入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们把User2Item-feature做成特征，而Item本身就有自己feature，通过这种间接的映射关系，可以让User提前学到Item的相关偏好，即在特征层实现伪交叉的目的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次是塔身。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于双塔模型来说，单个塔身的结构实际上是不受限的，那么深度网络结构怎么玩，这里就可以怎么玩，花样贼多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如特征的Embedding层，为何要用简单的concat呢，不同特征理论上是有不同权重的，加个Attention不香么，或者说单塔特征之间做交叉，这不是Deep Crossing的套路吗？对于塔身结构的改造，就绕不开SENet双塔模型，如下图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7416452442159382&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqtzuHQq7YWmNAuBPgmWlj2Xia1JaJ9HYTBoFTxaFqBCaYicqAcbPMyC75eYR8dNq6EPziccWQCjBEowA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从这个结构来看，SENet双塔模型对于整体双塔的结构改动并不大，没有实质上变动双塔的塔形结构，核心还是在各自塔内做模型的优化，甚至可以说是在特征的Embedding层进行叠加网络结构层，从而起到优化特征的作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SENet一种基于CNN结构的网络模型，核心思路是针对CNN中间层的卷积核特征做Attention操作，见SENet的网络结构图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44607046070460704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqtzuHQq7YWmNAuBPgmWlj2Xdc6a6ZMqAiaYcGA2E390smicl5iagITZY6UVoLC4ljibKDwfYrW6qjhcaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1845&quot;/&gt;&lt;span&gt;SENet最早是在图像领域被提出来的，从上图我们可以看到，其核心还是CNN的结构，只是将过程拆分成了三个部分，第一部分Squeeze拿到特征的通道Maps信息，然后做了Excitation，最重要的操作时Gating mechanism to produce channel-wide weights，即对特征通道进行加权，所以在最后一步拿到的就是已经Reweighting的特征Maps。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从这个过程看，其本质还是Attention，只不过是叠加在CNN卷积核基础上的特征通道加权。&lt;/span&gt;&lt;span&gt;所以，可以看到这种叠加改造本质上还是对于特征层的增强，或者更准确的说是筛选，核心思路还是Attention逻辑，对于特征的强弱进行加降权，最终通过加加降权的方式让重要特征的信息得以保存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，在实操层面，延续这种思路的话，Deep Crossing的特征之间的交叉是不是也可以试试，虽然是单一User或者Item内部的特征，但是内部特征也可以做交叉关系的计算，以及历史统计的交互信息与其他Feature的进一步交叉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.929845422116528&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqtzuHQq7YWmNAuBPgmWlj2XZRicLZLR1fPUMkm2J4KggvbZmZ9EOS2dhFQrEuBnibA22iajUx2pC1sLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;841&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至于Attention，如果不想引入复杂的SENet做特征加权，可以直接引入Transformer的Self-Attention模块，做特征的加权也是一种低门槛的尝试方式，方法可能不同，但是方向是一致的。至于更多的一些炼丹细节，只能通过实际的场景，以及真正的细节调节的时候逐渐的摸索和总结了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总之，对于塔身的改造，拆开单个网络结构来看，完全可以看做是一个普通深度网络模型，那么对于一个普通的深度网络模型如何去改造和迭代，稍微翻看一下CTR或者精排预估模型的演进，有太多可借鉴的地方了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;聊完塔身，我们来看塔尖的对于User和Item的Embedding表征这里，有没有可以进一步优化的空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjM2MTY0OQ==&amp;amp;mid=2650474763&amp;amp;idx=1&amp;amp;sn=aa0834e1ceae6f79db62fbb51c7a7ff5&amp;amp;chksm=83bca3d5b4cb2ac33649b470622b01f993a39698333fc32b90cbf176d36e13a4ce8a0eb6f242&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《数据与广告系列二十五：Embedding的起源与演化，以及序列构建与目标拟合派的流派之争》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《数据与广告系列二十五：Embedding的起源与演化，以及序列构建与目标拟合派的流派之争》&lt;/a&gt;一文中，我们曾重点研究了“万物皆可Embedding”的逻辑，本质上双塔的塔尖的User以及Item的Embedding表征也绕不开这个范畴，更多是基于一个显式目标反向拟合的Embedding向量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，问题是，抛开我们念念不忘的特征交叉的问题，以及就算我们在比如特征层做了一些特征注意力机制的加降权，按当前这种双塔模型拟合出来的向量会有什么缺陷呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还是之前的问题，经过了多层深度的网络层转换之后，底层信息的缺失，模型塔顶的表达能力不足，如何提升这种表达能力？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先看下从上篇&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjM2MTY0OQ==&amp;amp;mid=2650475393&amp;amp;idx=1&amp;amp;sn=affa322c82aa642205a4108e54f342f3&amp;amp;chksm=83bca15fb4cb28495b98415fd70ffb012217e35a2c1491730a5cef932908e346238e7df5ec11&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《数据与广告系列三十四：定向智能化，是好东西，但终究是英雄迟暮》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《数据与广告系列三十四：定向智能化，是好东西，但终究是英雄迟暮》&lt;/a&gt;中提到的Tag推荐的网络模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3768518518518518&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqsWjlTs4Nqx08S5ibKsOUaxvLEGIpcTerhzvAyCENeyspicD1ib5R5gGpsOcZib26j1MMjscGxGic36YPw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个结构图跟微信原始的UTPM（《Learning to Build User-tag Profile in Recommendation System》），以及大相径庭了，之前我们也提到过，本质上UTMP的网络结构也是一个双塔模型，是一种为了特殊目的而变种的双塔。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6292372881355932&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqtzuHQq7YWmNAuBPgmWlj2XfbMbib1mY3kibnXEUOOrpz6rrmicfu5q73AjpnUUUNkERicvgCA7ibCLKkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从我们改造的结构图来看，先看左侧塔身部分的改造对于塔尖的影响。这里我们本质上是将特征拆分了Wide和Deep两部分，目的当然就很明显了，所有的Wide&amp;amp;Deep模型的目的是一样的--通过Deep来解决模型的泛化的问题，通过Wide来解决历史经验记忆的问题。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，回到这里的结构改造上，最终Ad的embedding表征实际上是通过两种逻辑生成的（这里是通过加权相加），一种是特征不做复杂操作，只做简单的特征化之后过一个全连接层，然后到塔顶，另一种则就是标准的深度网络结构了。所以，塔顶的Ad的Embedding表征通过两个不同倾向的逻辑生成，那么必然包含了两个逻辑所要表达的目的，即对于历史经验的反馈和泛化性的表征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而这只是这种思路的一个开端，远不是结束，给我们的启发就是一个简单的线性层可以带来样本经验的学习，那么理论上单塔内部是不是可以拆分为N个塔，不同塔通过不同的网络逻辑去学习不同倾向的embedding表征，最终这些不同目的表征再合并成塔顶的User或者Item的表征即可，这样塔顶的Embedding表征的格局一下子就打开了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同理，DeepFM的网络结构逻辑是一样的思路，FM部分核心通过FM的二阶交叉逻辑获取稀疏特征的二阶交叉信息，并且相对于Deep部分，FM部分网络浅很多，很多历史信息得以记忆，从这点来说，跟Wide&amp;amp;Deep模型的wide部分的目的也有异曲同工之妙。&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.525030525030525&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqtzuHQq7YWmNAuBPgmWlj2XvlzXBObgaFM78ameEBcF68RcshaNa3pbHecYTJ4icW0URF5mjAicSsjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;819&quot;/&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同理，还有基于DeepFM系列的xDeepFM，AFM等等，本质上都是网络结构拆分的思路，通过不同网络结构获取不同的信息，然后再在网络的顶部通过某种方式进行信息融合，从而让整体的网络模型学习到多种不同的信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但真正的将这种思路融入到双塔结构中的，我们可以先来看FaceBook的Que2Search模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;《Que2Search: Fast and Accurate Query and Document Understanding for Search at Facebook》。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是语义领域的双塔模型，简单的语义双塔模型，一端Query一端是Document，本质上两端都是文本，常规做法是文本输入一个语义编码器，简单如做词表，稍微复杂点做N-gram切分，然后做Embedding Bag，再复杂点的，叠加个Bert的编码器（但要慎重，特别是Query端的实时Embedding推导，性能不一定扛得住），如果性能不行就上简化般的Bert，给文本做Embedding编码，然后塔尖叉乘或者取Cosine，完成双塔的标准流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Que2Search的思路跟上面Wide&amp;amp;Deep其实并没有质的不同，这里有两个假设点，一个是不同位置的特征带来的顶部信息是不一致的，其次是不同编码的方式带来的向量信息也是不同的。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5587863463969659&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqv9icsz2ImSmMjr6KRbMq1n9lVNctrudVM4LcK7sfbribjqBIZicAMNTb4YksHlOmWXQ2A55vDgqjfAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;791&quot;/&gt;从网络结构图中可以看到，对于Query端来说，部分特征直接Embedding化，比如Country；然后针对Query本身的处理，一是直接按3-gram进行词袋的向量表征（至于为什么是3-gram，这应该是炼丹经验以及query的场景相关了），这是一种非常直接的multi-hot的逻辑；此外，还让Query过XLM Encoder编码器，获取Embedding表征，这是Facebook自己魔改过的Transfor编码器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，本质上他还是想通过不同的模型逻辑，让Query或者Doc获得不同的表征能力，从而丰富Item的表达，其中相同的Query分别按gram切分和深度编码器处理，更是有点Wide&amp;amp;Deep的味道了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但至此基于单个塔身做实际多塔拆分的方向还没有一个正式的名字，直到腾讯QQ的下伙伴们给他命名的“并联多塔”（源自于QQ浏览器小说推荐场景）。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46039035591274396&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqtzuHQq7YWmNAuBPgmWlj2XWRl0J4rKSd8NmlqjZDNbQuSicf3uGic1dgFcRNyC6eNRb8p74kwYH0kQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;871&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上，从他的网络结构图中可以看到，并联多塔将不同网络模型带来不同表征的作用发挥到了极致，在表示层，分别通过了常规的MLP、深度交叉特征DCN（Deep Crossing Net）、稀疏特征二维交叉的FM、来源于CNN卷积的三阶特征交叉CIN模型，在匹配层获取到了User以及Item的表征。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中MLP负责常规的表征表达，DCN侧重于整体特征的交叉信息获取，FM负责稀疏特征的二阶交叉以及历史信息的记忆，CIN负责做更深度的三阶特征交叉。整个并联双塔如果从动机或者本质的角度观测，与我们上面说的Wide&amp;amp;Deep应用于双塔，以及FaceBook的Que2Search双塔并没有太多的不同，都是通过不同网络模型来表示不同向量表征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只不过，我们需要注意的是，通过多塔来丰富User或者Item的表征的目的是一致的，只不过采用的表示层（这里沿用并联双塔的术语）是不同的，并且，对于多塔带来的表征如何融合的方式也是值得推敲推敲的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我们O厂的定向智能推荐场景中，最终Wide和Deep部分是直接通过相同维度的加权求和的方式拿到了Ad的向量表征，至于两塔相交就是正常的Cosine或者内积过Sigmod；在Que2Search中，在Embedding Bag或者XLM Encoder的表示层之后，是叠加了一个Attention Fusion，顶部是常规的两个向量Cosine；而在腾讯QQ的并联双塔中，有点不一样，是因为不管User还是Item，内部表示层是一一对应的，所以他采用的是相同表示网络的Embedding进行Hardamard求积之后，再将不表示层的求积进行concat，再过sigmod得到一个Score。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于多塔的融合，熟悉排序预估领域相关模型的同学估计得来劲了，ESMM多目标建模的思路本质上不也是“并联”思路吗？这里是表达方式的并联，那里是多种目标的融合。加一层门控，通过样本来反向拟合门控的超参。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7373333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqsIjiau5j12XeblXkaia6XQWhtUdgsTmniaaVCaFoSZjmB9ON81FtHOp1s05cSM8tTKJ7LaTd78VQ6XQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了基于网络模型本身的特点获取不同模型带来的表征，还有其他的方式来丰富单个塔最终的向量表征吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来看下天猫的MIND（《Multi-Interest Network with Dynamic Routing forRecommendation at Tmall》）模型，虽然MIND也用于召回，并且最终Serving端也是通过向量进行召回的，但是向量的生成并不是通过双塔结构获取的，我们在这里引入他并不是要讲的模型结构，而是借鉴其Multi-interest的思路引出双塔改造中的多兴趣双塔的表征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4872611464968153&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqs2aXL86iaQ8Iz8rjQe0mu5WQt7pJ33DR2UhsUxReyTrhOEH6DKNDplJAPibdsHTxdRKWPr3sicSVqqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1256&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MIND的思路其实比较清晰，最左侧是用户的输入，右侧是Item的输入，User向上走没有什么好说的，Item向上走的时候，通过了胶囊网络（《Dynamic Routing Between Capsules》，这里笔者没有过多的研究，只是将他看成了一种深度网络的聚类网络来看待，不影响我们研究其大逻辑）进行了Item的聚类，这里的聚类表征了是不同兴趣簇，而不同的兴趣簇与User则在Multi-Interest Extractor Layer进行交互，本质上这里是一个兴趣注意力，或者兴趣加权的逻辑，最终通过用户与Item的交互label在感兴趣的Items簇上获得更多的信息，在过了两个ReLU之后，得到的就是User-vec，是一个带有多兴趣表征的User向量。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而在实际上线的时候，他的过程就跟双塔逻辑就差的有点远了，反倒是跟YoutubeDNN的上线过程有点类似。&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8268590455049944&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqsEeuicPrTmb6wVouPmhgywibAmLeuiae46ZkJNzuwX2mPibcehd3kPvU1PgawEiagjbqTWIC2iclHvL5yg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;901&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终的上线部分，想要变得更高效，就不能脱离向量检索或者向量内积计算的路子了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MIND提供的一个思路就是User embedding的表征是可以多兴趣表征的，即走的跟并联双塔以及Que2Search不一样的逻辑，单纯从User*Item交互的差异中，学习User对于不同Item的兴趣程度（Attention）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;铺垫完MIND，终于又可以回到我们的双塔主题了，我们来看腾讯的MVKE（《Mixture of Virtual-Kernel Experts for Multi-Objective User Profile Modeling》。这也是一个围绕兴趣点（Topics）构建用户embedding表征的模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5151515151515151&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqtpicia4J7hOO2TYct34Sjnf46sloFvrstGdPaZwoL5ocFDx4459MHiboxEhgTuBjiauPjElO0nHgOOKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;363&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一篇腾讯给用户打标的应用场景论文，这里就不得不提点题外话了，腾讯真的对用户打标非常之热衷，上面提到的UTPM（Learning to Build User-tag Profile in Recommendation System），系列二十五篇中提到的GraphRT（《Graph Neural Network for Tag Ranking in Tag-enhanced Video Recommendation》）也是基于标签向量推荐的场景，并且热衷于向量跟标签结合，标签跟推荐结合，不服都不行。&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5176946410515673&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqs2aXL86iaQ8Iz8rjQe0mu5Wvg1q54mdMe79sdRRALnAsL3KdjD8xeicibQb2YDqEicbDDv3TtjhdY4xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;989&quot;/&gt;&lt;span&gt;如上图，结合论文的背景，腾讯这里的应用阶段是广告的Targeting阶段，即广告的Tag阶段，通过定向粗筛人群，而这里的MVKE是用于给User打Tag（按双塔的打分，取TopN的Tag给User附上）。但是，既然可以精准的多兴趣双塔建模User2Tag，为什么不直接建模User2Ad呢？这里也可以构建User对于不同广告的多Topic嘛，略微不懂（很多厂子这里，直接跳过了Tag的定向过滤，直接做到User2Ad的资源召回，包括我厂，或者这只是当前鹅厂广告的一路逻辑，也或者是出论文的团队率属于定向团队，不懂）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从MVKE的名字中，Multi-Objective User Profile，跟Multi-Interest实际上的目标是一致的，甚至笔者感觉这里直接用Multi-Interest会更合适点。&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.755223880597015&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqs2aXL86iaQ8Iz8rjQe0mu5WUN21gDBt2I4ibvufia3n5qSDvaPnhPVdtZI7dW9P1Ap5tE5kFzOmlP9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;span&gt;MVKE的本质依然是一个双塔，一侧是User塔，一侧是Item塔，即Tag塔，最终计算的是User与Tag的关系，即给用户打标签（再次感叹，腾讯在给用户打标签这件事上是认真的）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MVKE核心动的是User部分，即看他如何将User-embedding的表征拆分为多塔表征，甚至可以说，MVKE至少从理论上走的更远。他跟并联双塔，或者我们所印象中的一些并联模型那样，而是试图构建一个动态的User-embedding，或者说个性化的embedding。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的User-embedding设计思路，岂不是比单纯的思考如何通过单一embedding来进一步丰富表达更有意思，以及更具有突破性的代表意义，MVKE想要做的事是构建一个动态的千人千面的embedding。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，当我们传入不同的item，获取到的User embedding是不同的，那么最终叉乘或者Cosine出来的结果岂不是更加的合理，更能表征两者之间的关系。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我们在聊MVKE之前，特地聊了MIND，本质上MVKE也是一种多兴趣表达的逻辑，MVKE所要实现的千人千面，也是基于User多兴趣表达的基础进行的，通过不同的User*item样本关系，来获取User-embedding在不同兴趣上的表征，而不同兴趣，最终得到的是不同的User embedding。我们在实际上线的时候，当然不能提前生成N个User embedding，然后按item的特征来动态选择，我们来看看MVKE如何实现User动态多兴趣的embedding表征的。&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5533625730994152&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqs2aXL86iaQ8Iz8rjQe0mu5WSgknhX0jPCGLgqlPAngyNJxO5GU38Wp9yHicpwreBbicTMhH1cic8DEOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot;/&gt;&lt;span&gt;整个网络结构见上，假如我们忽略掉中间层的变化，对比跟常规双塔有什么不一样的地方？大部分是相同的，底层双塔User-input，Item-input，标准的各自特征输入，底层生成User embedding和Item embedding，然后叉乘计算Loss，顶层也是标准的双塔输出结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;核心差异点在于中间逻辑的构建，以及最重要的是Item embedding除了作为顶层与User计算Loss的输入，在中间还作为输入变量，输入到了User网络中，起到了双塔交叉的目的，这是打破传统的做法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来看模型最核心的部分，有两个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个是VK Expert，论文中简称为VKE。即Virtual Kernel Expert网络，核心描述的是一个用户在一个兴趣点上的表征。当然这里的兴趣点，是一个虚拟的兴趣点，或者原文谓之为“Topic”，笔者更愿意称之为虚拟的兴趣簇，所以这是一个Virtual Topics Expert（这样会更容易理解些）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体如何获取用户的某个兴趣簇的表征，作者这里用了QKV的注意力逻辑，其中Value和Key都是用户的特征，但是这里用了field，即这里的特征输入按原文的说法是不同VKE输入的用户特征组合是不同的（various combinations of user feature inputs），但具体如何选择没有细说，而作为Query的核心加权触发是Virtual Kernel，即Virtual Topics，这里构建了一个虚拟的可学习的VK，初始化没有细说，大概率是按注意力机制中的随机初始化之类的。然后KQ经过矩阵相乘之后过softmax，得到权重，对Value进行加权，获得用户在单一虚拟兴趣簇上的vector表征。总结下来就是，用户的不同特征组合，理论上会体现用户的不同兴趣点，通过一个虚拟构建的原始兴趣embedding（KV）来给用户的行为特征加权，从而获取用户在某虚拟兴趣上的表征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里我们定义多少个虚拟兴趣（VK），则有多少个VKE。而在构建起了N个VKE之后，即假设用户已经有了N个虚拟的兴趣簇表征，那剩下的问题就是，最终如何融合这些兴趣，从而获取一个用户的最终embedding表征，且这个表征是实际反馈用户不同兴趣的（所以不能是单纯的sum pooling 或者avg pooling）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到了第二个核心重点，VK Gate。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5815899581589958&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqtpicia4J7hOO2TYct34Sjnf4gu4tTNFex2TK3c32J2u2FDoB0AkhOOeKNupiaiaGYsOQFYuOagtuVTRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;478&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Gate，这玩意儿我们熟，门控。一说到门控，那肯定是一个门控加权逻辑，那么作为门控的输入调控变量，到底需要如何进行控制，这个动作跟MVKE的个性化User embedding有着直接关系。这里同样是一个QKV的注意力加权逻辑，我们需要通过QK对Value进行加权，Value即我们在上个环节中输出的KVEs（标准称呼为KV Experts Outputs，即用户不同兴趣表征），K是VK（Virtual Kernel），最为关键的Query动作是右塔的Tag embedding，即塔交叉的地方，剩下的就是跟VKE逻辑一样。最终获取到通过右塔干预的User embedding，而干预的地方在于通过Tag embedding的输入来干预VKE的权重分布，最终顺起自然的实现Item层面对于User embedding表征的个性化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于上面的内容，还有最重要的一步，那就是如何实现标准双塔的快速计算的性能问题。我们看，其实整体结构还是一个双塔，无非是中间右塔“窜”到了左塔中，并对左塔的输出形成了干预。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先抽离离线可计算的部分，Items塔的部分可以离线过裁剪网络然后得到Item embedding。左侧部分，左右交互部分先不管，把离线部分抽离出来，即VKG加权下面的一层，即QK计算部分，可以离线计算，这里只跟Item embedding和KV有关，有N个KV即有N个Softmax的输出，所以这里一个Item会有N个Softmax输出，也可以离线存储起来。最后就是在广告或者推荐的在线召回部分，User实时拿到VKE outputs，然后从内存中拿到Item embedding和item对应的N个KN加权表征，接着把Weigthed Sum部分再执行一遍即拿到User的表征，剩下就是User embedding 和Item embedding的Cosine或者叉乘计算了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，大性能消耗的VKE outputs在线推导的网络是只需要过一次的，剩下的Weigthed Sum以及Cosine计算都是低消耗的类矩阵的运算，性能是可以支撑的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上，实现了User embedding表征的多兴趣表征，且这个多兴趣表征是Item颗粒度个性化的，完美的实现了User*Item交叉，又不会影响双塔本身的性能问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，针对MVKE再吐槽几句。整个网络结构的设计是非常巧妙的，通过两层的QKV注意力机制设计，完美的挖掘了用户的多兴趣表征，以及利用Item的Query输入作用实现局部解耦的高性能多兴趣交叉双塔。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是应用点是值得吐槽的，整个结构是做User2Tag的计算，然后用于Targeting定向，直接用于User2Ad的召回不香么，从原论文也可以看到，实际上为了构建User2Tag的关系，作者拿的是User*Ad的Click以及Convert数据，然后通过Ad-Tags的映射，最终构建起User Tags的正负样本关系，实际上是信息有损的。这点我们在做定向推荐的时候就发现了，做法也类似，拿User*Ad的关系数据（海量），然后通过User-Tags映射，来计算Ad2Tags的关系（给广告推荐定向标签）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上是有异曲同工之处的，但缺点也很明显，信息有损，中间多了一层转换（我们这里是User-tags，MVKE这里是Ad-tags），且这个中间转换，理论上也是有权重之分的，比如我们这里用户对用tags的映射，理论上不是平铺的，是有兴趣强弱之分的，而MVKE理论上也有这个问题，Ad-tags的映射，虽然User点击了这个Ad，但是由于Ad身上哪个Tags吸引了用户是不得而知的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后一点，应用场景很局限，但是目标很远大，在整个MVKE基础结构上，前套了类似MMoE的多任务建模，同时构建CTR和CVR表征，按论文的意思是构建了Interest关系和Intention关系，但具体两类表征在线上怎么用户，没有过多关注了，不是笔者的重点。&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9599383667180277&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqs2aXL86iaQ8Iz8rjQe0mu5Wc4EiaMvjAJAE7gXbw6nQ1IBDuBic3FhSITpHMO8ic9mY8xZ5kJvzLNurg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;span&gt;至此，MKVE拆解完毕，对于双塔召回的方向领域来说，MVKE还是非常有代表性意义的。从召回本身所需要的性能角度，以及向量召回的部署逻辑的角度看，并没有发生质的变化，看的出来虽然“千变万化”，但骨子里还是一个正宗的双塔。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但这个模型的设计，实打实的丰富了User的向量表达能力（Item如果要做也是可以的，但如果都走VKE的方式估计不行，没法交叉了，但可以上并联多模型来丰富表达能力），并且这种表达能力是基于业务本身的（多兴趣、多Topic），而非不同网络模型结构带来的，最重要的在于巧妙的结构设计在User表征中引入了Item Embedding的变量，从而构建了User embedding生成的Item交互个性化，VKE与VKG的两层设计又最终不影响向量高效匹配方式的部署（当然，跟原生比，还是多了N个Item的VKG次级的softmax结果计算，这个计算虽然比较简单，但量级上去之后，还是会稍微影响点点性能的）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;聊完塔身的表征改造，继续向上，交叉层的改进。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一层的改动就相对有限了，常规向量召回的部署逻辑决定了，双塔的输出是两侧embedding向量，然后通过向量Cosine的计算，或者内积叉乘过Sigmod的方式，拿到计算关系得分。这里怎么改造都玩不出花来了，再无非是把叉乘关系再加几层简单的线性层，不然在部署的时候，推导性能就支撑不了了，在出来embedding之后再过简单的MLP网络，勉强还行，多了就支撑不了了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但从实际意义的角度来说，多了几个简单的线性网络核心是想让两侧embedding再做信息交叉，但此时再做信息的交叉已经有点晚了，因为从底层的特征输入层到塔顶，已经经过了复杂的网络变化，失去了行为交叉的本质意义了。所以，从交叉顶层的变化就局限了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至此，我们将常规双塔，从特征层一路到单塔网络结构，再到塔顶embedding的丰富表征，甚至引入user与item的信息交叉实现user embedding的交互个性化，再到交叉层的改造。再回过头来看，不变的向量召回的高性能部署方式，以及基本的双塔输出范式，而其他都是可以变的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进一步衍生，万物即可embedding，而embedding的方式是可灵活多变的，只要embedding表征之后，则万物皆可计算。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;04&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;万物即可embedding&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;延续上一个章节的内容，我们将标准双塔从特征输入到塔顶交叉摸了透，但始终没有去动最根本性的东西，即向量部署的模式，扣紧向量召回的模式，进一步抽象出来实际上做的都是如何表征user如何表征item的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在围绕这个目标的实现过程中，所谓“神挡杀神，魔阻灭魔”（拟合的不够就把网络变复杂，尝试u跟i的交叉，就让特征层输入交叉历史特征，尝试embedding多种表征就拆分网络抽象兴趣，进一步想提前学习交叉表征，就让另一端作为输入影响表征的输出等等）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再抽象出来，即embedding的表征问题，user2item则构建user和item的表征，item2item则构建item关系内的表征，user2user则构建人与人的关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;万物即可embedding，万物皆可计算关系，万物皆可相互召回。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjM2MTY0OQ==&amp;amp;mid=2650474763&amp;amp;idx=1&amp;amp;sn=aa0834e1ceae6f79db62fbb51c7a7ff5&amp;amp;chksm=83bca3d5b4cb2ac33649b470622b01f993a39698333fc32b90cbf176d36e13a4ce8a0eb6f242&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《数据与广告系列二十五：Embedding的起源与演化，以及序列构建与目标拟合派的流派之争》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《数据与广告系列二十五：Embedding的起源与演化，以及序列构建与目标拟合派的流派之争》&lt;/a&gt;一文中我们也有提到过，Word2Vec如同打开同质序列关系计算的“潘多拉魔盒”，后面衍生的一系列的序列计算，游走类的关系计算、甚至是同质、异构图的关系计算，本质上都属于这一类。而YoutubeDNN这种目前看似古老的东西，则为异构强关系计算（User2item）打开了一扇大门，而双塔DSSM则为他放大光彩，而后包含一系列的衍生，本质上都是利用强关系样本（User2item的关系样本，又或者是回溯或者关联穿透的关系，比如&lt;span&gt;MVKE跟UTPM就算这种&lt;/span&gt;）构建特殊的深度网络，然后最终取中间副产品去应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而这里所有的一切，核心在于我们先找到我们需要表征的关系，比如是item与item还是user与item，以及希望这种表征带来什么样的结果，比如item之间的某种关联，还是user与item的交互关系（本质上还是转化的关系），这就是应用出口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;剩下的事，真的是天马行空，只要你敢想，你就会获得什么样的embedding。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;我们再来看几个天马行空的例子，基于我们还是更多研究user跟item的关系，举的还是偏向于user2item的例子。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;微信2020年在CIKM发表的《Graph Neural Network for Tag Ranking in Tag-enhanced Video Recommendation》。背景：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;微信看一看场景，每个视频下面放若干个video自带的tag，但展示位有限不能全放，但如何根据用户的信息来个性化的给用户展示呢？如果用户喜欢某个Tag，点击进去之后是对应Tag的视频集合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5138888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqsEeuicPrTmb6wVouPmhgywibewdwuxljBEuMRGr3QjN3162ss2tibjiaE6b9rKG3ckKR2yjZHIGNySvQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，微信目的来说就是寻找user与tag的最佳匹配关系（你看，腾讯果然是研究Tag的专家）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果直接对user和tag的关系建模，有点难搞，数据太少，而且tag的量也不多（这点我们在看UTPM模型和MVKE上其实都有体现）。&lt;/span&gt;&lt;span/&gt;&lt;span&gt;其主逻辑做法就是，寻找一种tag的embedding表示方法，然后用user过去一段时间有过正交互（比如点击过的tag）tag，从而生成user embedding，最终在线计算的时候，直接计算user embedding与候选tag embedding的内积，根据内积来排序，选取若干个tag进行给user展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是这种逻辑大部分会表征tag与tag之间的关系，不是那么的个性化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GraphRT的思考逻辑是&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）Tag embedding需要包含与user的交互关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）谁拥有与user的交互，当然是video。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）而video天然又跟tag&lt;/span&gt;&lt;span&gt;有&lt;span&gt;关系。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（4）将他们放到一个大的异构图中，通过异构关系图寻找获取tag embedding的表征方法，并且将三种item之间的逻辑关系也一起学习到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你看，就算从Tag2Tag中，也是可以通过间接的关系去找User和Tag的关系，GraphRT穿透了2层，User2Video2Tag，而实际上有监督的直接样本是模仿Word2vec构建的，即Video2Video的&lt;span&gt;同session序列（做类似与相似损失计算，构建起的有监督关系），而其他的User和Tag只是附着在Video上的异构图。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体过程就是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）将user, video, tag（还加上video的来源media）都放入一个大的异构图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）通过图卷积，学习到video embedding，再建模video与video之间的相关性（比如在同一个session中播放过，这个就跟其他embedding寻找的优化目标是一致的了）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）因为video embedding融合了tag embedding，因此在优化目标达成之后，一个优质的副产品就是得到tag embedding。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7411095305832148&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqsEeuicPrTmb6wVouPmhgywibvFVMdpJZHpwm3oBfwdxuhGt2IZQRfVKgvQzySc87K4Rh4wib2iarSVQQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;703&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;鬼才的设计思路，绕了多少道湾湾终于找到他们所需要的各自关系（更多拆解细节可以看&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjM2MTY0OQ==&amp;amp;mid=2650474763&amp;amp;idx=1&amp;amp;sn=aa0834e1ceae6f79db62fbb51c7a7ff5&amp;amp;chksm=83bca3d5b4cb2ac33649b470622b01f993a39698333fc32b90cbf176d36e13a4ce8a0eb6f242&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;系列二十五&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;系列二十五&lt;/a&gt;中的相关部分）。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;只要存在关系，即可计算embedding，只要关系和设计思路合理，即可利用这种embedding表征交叉计算，来获得异构或者同质实体之间的关系。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;再来看百度的Mobius（KDD 2019 《MOBIUS: Towards the Next Generation of Query-Ad Matching in Baidu’s Sponsored Search》）也是一个鬼才设计。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;一句话背景，百度是检索逻辑，所以在召回场景里是既要又要的”流氓“思维，即既要钱又要体验，更通俗的讲就是既要转化又要与检索query相关的资源（笔者做搜索广告也有一段时间，这里需要说下的就是，相关跟钱并没有绝对的关系，很多时候甚至是负相关的关系）。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6612554112554112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBquoibZ10KUTRHQiapml7gZBFo4pxs6kKynHNyd1esVpSYFnDYqBJkkic7MOzFYgcLlpgQBpxiaSNEDKfQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;924&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1951219512195122&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBquoibZ10KUTRHQiapml7gZBFogkS3nl9bgcPFbGMPEIic4CE0VteUNaPcTsk4KobPxANClcC2hyYlCuQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;984&quot;/&gt;&lt;br/&gt;&lt;/span&gt;（5）将augData输入Relevance_Judger中（Teacher），核心是获取augData数据的相关性，即query*ad的相关性。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;       =》笔者疑问：这个Relevance模型怎么构建的，以及如何在整个模型结构中生效的，是网络嵌入的方式还是单纯的将Relevance模型解耦部署，然后在一个epoch流程中生效，作为一个Judger存在？&lt;span&gt;&lt;br/&gt;&lt;/span&gt;（6）过相关性阈值，将低相关性的augData筛选出来，作为lowRelAugData。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;（7）送入Neural_Click_Model（Students），这个Click_Model是一个original CTR Model（初始的二分类的预估模型），输出数据（lowRelAugData，pCTR）。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;（7）进一步通过pCTR过滤，这里将高pCTR的过滤出来，即低相关性，高pCTR的数据，最终作为badCase。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;（8）将badCase和常规的排序二分类的样本data数据合并，作为trainBuffers数据，作为最后一层预测模型的训练数据（即每个epoch的数据实际上是由原始data和生产的badcase来构造的，前面的流程都是为了构造badcase）。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;（9）中间过user网络和ad网络，顶层的CTR prediction，由传统的二分类变为三分类，新增的一类即为badcase类。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;（10）双塔塔顶过Softmax，然后最终变成click unclick  bad。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总之，抓住几个关键点：&lt;br/&gt;（1）最核心的思路是将之前粗排CTR拟合的二分类，变为三分类，通过多构建一个badcase分类，从而让整个模型引入相关性的识别能力，严格来说是识别高CTR低相关性的识别能力。&lt;br/&gt;（2）其次，为了追求性能，部署依然是双塔离线embedding的模式，而由于加入了badcase的三分类，从而让塔尖的vector获得相关性的表征能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）第三，对于着墨不少的query*ad扩展逻辑，笔者认为是加分项，理论上如果样本已经很多了，跳过这步直接从log里拿query*ad的实际关系作为badcase挑选的候选集也没有太大的毛病，无非就是泛化能力的稍稍不足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你看，Mobius从部署的角度看，还是向量召回，从模型类型来看，本质上还是双塔，更多的设计逻辑核心做的是让embedding具备同时表征高转化和高相关性的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还是之前那句话，只要有诉求，只要敢想，你就可以收获什么embedding，万物皆可embedding。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，我们在聊这些论文中的模型设计的时候，并没有考虑说这种结构设计是否一定有效，任何说是否有效的前提在于你的场景是否Match论文的场景，人家能够提供给你的是一个思路，论文的论证数据也只是人家的数据，出论文是给你提供场景思路的，并保证你的场景一定有效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，很多时候笔者在聊这些论文，拆解这些论文的时候，更多聊的是场景迁移和论文的结构设计思路，并没有说一定什么什么有效，依样画葫芦可以，但是尽量要有自己的思考，对自己所处于的场景要有足够的理解，对于需要解决的问题需要有足够的抽象能力，最终从这些天马行空的模型结构设计思路中摘取自己所需要的东西。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我们只看思路，只看他们通过什么方式解决问题，场景有没有可借鉴和迁移的可能性，以及这种思路给我们自己带来什么提示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，回到万物皆可embedding这个话题，万物只要存在关系，确实皆可embedding，至于说怎么构建关系，以及这种关系怎么转化为embedding向量，有太多方式方法可借鉴了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;05&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;收尾：召回的本质&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们收归召回的话题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实整个召回众多的解决方案中，基于双塔的向量召回并不是唯一的一条路，比如阿里TDM（2018 KDD《Learning Tree-based Deep Model for Recommender Systems》）还是比较有名的。基于深度树的方式解决掉召回性能的问题，从而丢弃掉了传统双塔向量检索逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但很多时候，这种召回逻辑限制还是挺多的，首先按兴趣树分层的方式本身就决定了这种场景更倾向于类似电商这种有清晰的类目结构树，从而导致用户无论从需求出发还是从兴趣出发，可以按兴趣分层的方式去做候选资源的筛选，这是业务属性决定的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5912653975363942&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqu5E2s76KeIgv9Dj2CCT97ShZ7l1tY7ZrgAibdJkONmeO5NSJNA3VRkyuQ95XIZhdy5WcGRFej1Uhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;893&quot;/&gt;&lt;span&gt;其次是&lt;/span&gt;&lt;span&gt;TDM这种整体模型非常复杂，&lt;/span&gt;&lt;span&gt;不管&lt;/span&gt;&lt;span&gt;是训练还是部署，&lt;/span&gt;&lt;span&gt;尤其是线上&lt;/span&gt;&lt;span&gt;非常重，一般的厂子还真的不一定玩的转，尤其是看阿里2022年发的一致性建模的相关文章，提的更多是PDM（Point based Deep Match Model)召回，其实更倾向的还是类似于双塔向量召回的主逻辑，还是熟悉的配方。&lt;/span&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.496098104793757&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqu5E2s76KeIgv9Dj2CCT97S2hWRLolFpibhIz2uHm92EQlnooffSpKKcfEoUtAq7Gp24bbibAzNAkWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;897&quot;/&gt;&lt;span&gt;所以，聊召回，&lt;/span&gt;&lt;span&gt;我们把&lt;/span&gt;&lt;span&gt;大篇的篇幅用&lt;/span&gt;&lt;span&gt;于聊&lt;/span&gt;&lt;span&gt;基于双塔向量的召回，没毛病，&lt;/span&gt;&lt;span&gt;这才是&lt;/span&gt;&lt;span&gt;“平民版&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;的召回解决方案，所谓“熟读论文三百篇，不会写来&lt;/span&gt;&lt;span&gt;也会抄”&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;搞清楚&lt;/span&gt;&lt;span&gt;整个双塔向量的玩法，以及别人家的天马行空的思路，结合自己的业务场景，组合出来一个看着没那么基础版的召回模型还是可以的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我们读这篇文章的时候，不要被上面这些天马行空的思路给蒙蔽了，核心在于你需要解决什么问题，有什么数据。上面这些思路，只是给你提供解决的手段而已，要不要用，怎么用取决于你。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，在这篇长文的最后一个章节里，笔者想要探讨的是更深层的一个话题，那就是召回到底要解决什么问题？特别是我们在经历了不同思路的轰炸之后。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;或者说，我们回归一个更为本质的问题，在embedding只要做的好，即可表征万物，即可表征多维多目标的情况下，万能的embedding呀，是不是一个召回模型即可吃遍天下，所谓的传统多路召回已经消亡？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如Mobius一个embedding把相关性和转化问题都解决了，MVKE不但把User的不同兴趣给表征了还item输入个性化了，阿里提的PDM不但把ctr预估问题解决了，还解决了广告的eCPM中融入bid的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你看，他们都多才多艺，万法通吃，只要模型设计的足够复杂和合理，就跟熔炉似的，把所有目标和可能性都熔炼到一个embedding上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上不是的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不管是从笔者自身的经历来看，以及跟一些人聊的情况来看，哪怕是我们所认知的大厂，也没有说一路召回解决掉所有问题的，绝大部分还是多路召回融合的思路，既然可以做多路，那为什么不在模型内部做多目标路呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;理论上也是可以的，但在实际中操作成本太高了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;召回的本质是什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个是趋同于后链路，这也就是阿里这两年常说的链路一致性，即召回粗排精排的目标一致，比如广告中要eCPM高的，那么我就给你召回eCPM高的，这就导致了召回的目标向后一致，这也是近些年来基于LTR（Learning to Ranking）的召回思路“甚嚣尘上”，以及召回都奔着深度转化去建模等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前后一心，理论上我们的末端效果是会越来越好的。但本身召回就是排序的前链路，前链路学习后链路，这又是一个鸡生蛋蛋生鸡的循环问题，岂不是绕回死胡同去了。所以很多做LTR的，要么在样本上做一些拓展，要么干脆再开一路来打破鸡生蛋蛋生鸡魔咒，让那一路来突破链路循环。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但还不够，召回本身就是整个链路的最前端，理论上他应该把所有可能最好的东西都拿过来--所谓召回是也。所以吃老本的召回方式是不够的，他还有更重要的使命，那就是探索。传统双塔向量的探索逻辑是更多依赖于样本，让模型见更多没有见过的样本，这就是搞召回搞久了的选手都会念叨几句的“召回是样本的艺术”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但实际上，目前不同厂子存在多路召回逻辑，虽然LTR的模式越来越受到欢迎，但始终不敢完全放开，依赖于其他召回逻辑（可能也是双塔向量）来弥补探索的不足，特别是近些年来基于图召回的一些探索。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;包括笔者自身，过去的不短时间里，都在实际探索搜索广告的一些召回解决方案，对于偏向于语义的召回，基于双塔向量的召回，以及基于图网络技术的一些游走空间类探索类的召回都有所涉及。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然当前大家对于深度网络的理解与过去相比已经不可同日而语，按我们上面三四章节的逻辑，理论上我们确实可以在一个网络中甚至一个embedding表征中融入我们想要表达的各种东西，比如用户多兴趣的个性化，比如用户对于新item的探索，用户与检索query的语义关系等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但实际上，并没有这么神奇，或者在实操中的难度会大很多。我们以搜索广告的召回为例，搜索广告与常规广告不同，在满足赚钱的同时，需要受体验的约束，而体验很多时候转化的是可量化的语义相关性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这看似百度Mobius就可以同时解决转化与相关的问题，但在实际中，通常产品经理对于体验的要求是有具体可量化指标的，但实际上Mobius内部需要调节两者平衡就没有那么直观了。而将他退化为一路偏向于效果的召回，一路偏向于语义的召回，在两路做可控的融合，则比较简单直白的达到策略可控的量化目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;又比如召回探索性质的问题，同样很难将不同目标的召回进行单一网络的融合，远不如一路做LTR的效果控制召回，一路做常规的全局随机负采样的探索向量召回来的方便。更不用说偏向于多维空间关系探索的图逻辑召回，更难以融入常规的双塔向量中，但在实际的召回探索中又往往有意想不到的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个复杂深度网络通吃的解决方案看着是更高大尚的，也是更具有可吹水性质的，但在实操中实际上往往很难落地，最多做到尽可能地缩减召回路数，尽量同一维的进行多目标建模，但不同维度的还是较难以混合融合，特别是在很多具有显式策略控制需求的场景下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，关于推荐广告的召回的走势到底是一个融合了多维目标的复杂深度模型通吃的模式，还是往多路各司其职的模式上退化，这是一个值得持续思考的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而关于鸡生蛋蛋生鸡的问题，笔者的一个小小观测或者实际经历或许可以分享或者探讨一下。在笔者曾经的经历中，A召回对于B召回来说是一个推翻全盘的升级迭代，开始阶段A是一个小流量状态，在效果正向之后，按照流量反转的原则，则直接进行模型配置反转，大小流量直接反转。然而观察到的现象是A在反转之后，带来的持续正向效果远高于之前其小流量时期的效果，且持久而稳定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么会出现大小流量反转之后，增幅大幅变化的情况？我们也曾试图寻找答案。并且，可以确认的是，在主如同模型小版本迭代的这种变化中找不到这种规律，这意味着是A和B的模式变化，并且叠加大小流量反转的变量呈现出这种走势规律。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而流量绝对大小对于A和B的影响在哪？在于模型对于全局范围的影响，这就是鸡生蛋蛋生鸡的问题。以正样本为例，当A呈现小流量时，最终受A影响而产生的正样本（不考虑召回排序负样本的差异，当然，例如LTR模式中负样本的差异也没有想象中的大），实际上在整条链路上是非常有限的，这意味着整个样本选择的模式除了各自模型本身的样本策略的影响之外，大范围上是受B模型的召回结果（影响大的范围）和之后的排序模型的打分结果（影响大范围内的局部资源的序）所影响的。而当A瞬间反转之后，成为了绝对占比的大流量，这意味着整个大范围的样本圈选逻辑是受A所影响的，打破了之前排序对于B召回结果的“适应”，而对于A来说，则意味着“左右全局”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终，回到鸡生蛋蛋生鸡的问题，A模型在小流量状态彷佛就是一枚额外插进来的鸡蛋，整个鸡窝鸡的类型不受其影响，当这枚鸡蛋复制占据了大部分鸡窝空间的时候，哪怕后面排序阶段还有自主选择的权力，但是依然受限于这类鸡蛋的范围内了，即A召回反过来对排序进行了影响，使得了排序阶段反过来去适应召回模型的变动，最终是的召回A和排序在新的一轮调整中得到了最优解，而B成为了鸡窝里独特的那枚鸡蛋，从而使得A和B的差距进一步持续拉大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，如上，笔者这种推导不一定正确，但从目前的角度看并没有看到更合理的解释。总之，从这里来看，持续走LTR的路子并不一定完全正确，或者说我们在召回阶段持续模仿（学习）排序阶段的序的时候，或者这并不是一条得以持续的路，或者说不是一条可以打破”传统“的路，无法让你的召回突破原有的固定模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;召回召回，不管是古老的协同也好，一些规则热点召回也好，主流的不同目的的双塔向量召回也好，或者抛开了向量召回的深度树TDM也好，又或者说叠加了一些学习排序目标的蒸馏逻辑召回也好，这些都是手段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我们的目标，召回，是整个链路的起点，记住，起点其实也决定了终点。&lt;/span&gt;&lt;/p&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;夏虫评说&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;上一篇&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjM2MTY0OQ==&amp;amp;mid=2650475393&amp;amp;idx=1&amp;amp;sn=affa322c82aa642205a4108e54f342f3&amp;amp;chksm=83bca15fb4cb28495b98415fd70ffb012217e35a2c1491730a5cef932908e346238e7df5ec11&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《数据与广告系列三十四：定向智能化，是好东西，但终究是英雄迟暮》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《数据与广告系列三十四：定向智能化，是好东西，但终究是英雄迟暮》&lt;/a&gt;是2022年9月14号发布的，如今已经是2023年了，中间间隔了一篇在【夏虫悟冰】上2022年11月份发表的一篇非技术文&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4NDE2Mzc5Mg==&amp;amp;mid=2247484023&amp;amp;idx=1&amp;amp;sn=737d7a781311389e85fc8ba1029fccc8&amp;amp;chksm=fd9f4ac8cae8c3ded98896fe7e3cc81759d3ccdd5c76b8fe76170071c9b989df09c0522b2953&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《互联网的落日余晖》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《互联网的落日余晖》&lt;/a&gt;。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;倒不是偷懒，而是整个2022年度都忙的晕头转向，特别是下旬，忙着带着团队与其他团队打攻防战，严格来说是抢夺别人家的地盘--算法团队的意义不在于此嘛。只有不断地PK对比，给业务带来持续地增长指标，才有存在的意义和价值。不卷别人就死自己，现实真的是残酷啊。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;所幸，在年底到来之前，团队完成了绝大部分的即定目标，甚至是超额完成目标，卷的别人”痛不欲生“，这也就有了一点点时间来思考和整理。&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;其实夏虫早就想写召回了，长篇里之前写了oCPX调价（&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjM2MTY0OQ==&amp;amp;mid=2650475140&amp;amp;idx=1&amp;amp;sn=e22cf42a49a5826258f59740cc07f68a&amp;amp;chksm=83bca05ab4cb294cee76f52416057711dee17af81e421c0173c34d2c9b46004585a60aec71af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《数据与广告系列三十一：智能调价oCPX，你以为赚的是保价，其实你丢的是流量》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《数据与广告系列三十一：智能调价oCPX，你以为赚的是保价，其实你丢的是流量》&lt;/a&gt;），写了重排（&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjM2MTY0OQ==&amp;amp;mid=2650475209&amp;amp;idx=1&amp;amp;sn=a4dace7992a15cb87f9a11af0bb3f8b2&amp;amp;chksm=83bca017b4cb29019ab9e9a1eecad22bc59753e4401f6c1e1cae1bc371df86f247a893de5e13&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《数据与广告系列三十二：重排ReRank，广告推荐算法链路上的背叛者，格局的重塑者》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《数据与广告系列三十二：重排ReRank，广告推荐算法链路上的背叛者，格局的重塑者》&lt;/a&gt;），专门写了搜索广告（&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjM2MTY0OQ==&amp;amp;mid=2650475320&amp;amp;idx=1&amp;amp;sn=3d330534f54d23b3e692d266d3cc8ed2&amp;amp;chksm=83bca1e6b4cb28f055b99ca27323abf9d34fa82e42893b45b8c891e768ffb908ea2d7a6d280d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《数据与广告系列三十三：搜索广告，如何在用户搜索过程中优雅的夹带“私货”》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《数据与广告系列三十三：搜索广告，如何在用户搜索过程中优雅的夹带“私货”》&lt;/a&gt;），最近一篇还写了智能化定向（&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjM2MTY0OQ==&amp;amp;mid=2650475393&amp;amp;idx=1&amp;amp;sn=affa322c82aa642205a4108e54f342f3&amp;amp;chksm=83bca15fb4cb28495b98415fd70ffb012217e35a2c1491730a5cef932908e346238e7df5ec11&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《数据与广告系列三十四：定向智能化，是好东西，但终究是英雄迟暮》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《数据与广告系列三十四：定向智能化，是好东西，但终究是英雄迟暮》&lt;/a&gt;），基本上每一篇都是万字长文，试图将一个领域内的业务逻辑、技术逻辑，以及结合的逻辑讲透，这篇同样如此。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;虽然一直没有动笔，但是持续的思考从未停下来过，包括之前写&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjM2MTY0OQ==&amp;amp;mid=2650474763&amp;amp;idx=1&amp;amp;sn=aa0834e1ceae6f79db62fbb51c7a7ff5&amp;amp;chksm=83bca3d5b4cb2ac33649b470622b01f993a39698333fc32b90cbf176d36e13a4ce8a0eb6f242&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《数据与广告系列二十五：Embedding的起源与演化，以及序列构建与目标拟合派的流派之争》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《数据与广告系列二十五：Embedding的起源与演化，以及序列构建与目标拟合派的流派之争》&lt;/a&gt;还有&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjM2MTY0OQ==&amp;amp;mid=2650474368&amp;amp;idx=1&amp;amp;sn=89eab1cc8a23e6414bd6e5d9b4902bf6&amp;amp;chksm=83bcad5eb4cb2448b0c208fc0faa0b29c2791ddcba014525ce09df45e3190208ca30afdae140&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《数据与广告系列十九：推荐召回与广告LookAlike，万物皆可Embedding》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《数据与广告系列十九：推荐召回与广告LookAlike，万物皆可Embedding》&lt;/a&gt;等篇章的时候，实际上都是这篇的基石。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;反复的思考和沉淀之后，方敢动之以笔，落之以文。在后面的规划里，应该至少还有一篇关于排序的文章，这是笔者最难以下笔的领域。一方面是这个领域技术维度已经非常丰富而繁杂，从技术的维度来说已经被人反复咀嚼过了；另一方面，而从业务的角度，这玩意儿又非常的抽象化，导致了目标非常之单纯（这也是其技术能进一步高度繁华发展的原因）。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;越是纯粹的东西，越容易被各路神仙花式研究，不留下阴影。不过，他终究是这个系列的最后几个关键的领域节点，一定会覆盖进去的。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9465648854961832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOkgZGq1Nam2wx8KHreT6gcGaEAOHDaREvvGbFfYficNNNkpHKMxiaYRIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;131&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文章都看完了，还不点个赞来个赏~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-id=&quot;2255&quot;&gt;&lt;section&gt;&lt;p data-original=&quot;http://bj.91join.com/sucai/57.png&quot;&gt;&lt;span&gt;OTHER&lt;/span&gt;&lt;span&gt;相关系列文章（看“推荐广告系列”）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;217&quot; data-backw=&quot;554&quot; data-before-oversubscription-url=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/icr5FVCSvBqvKestzBFLnfCjCM3dqHibqiaNpeU4tUjKw5ehb6Pdumns43uNwbr8VWHE2qJMh1WlSZtibU81nHUdXg/0?wx_fmt=jpeg&quot; data-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqvKestzBFLnfCjCM3dqHibqiadMpRoNxpDgggQFw15AdfibagOvQNbiakdzy3icmLsyTl5G1icl3O1rB3SQ/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqvKestzBFLnfCjCM3dqHibqiaNpeU4tUjKw5ehb6Pdumns43uNwbr8VWHE2qJMh1WlSZtibU81nHUdXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzAxMjM2MTY0OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvAbqiatjxIbKnCHHZyKSOULJcPGHiaxvW0hNbicYl8BzAED552KcYM0dEgHKVLcwB77xZWVAet89Tzg/0?wx_fmt=png&quot; data-nickname=&quot;数据虫巢&quot; data-alias=&quot;blogchong&quot; data-signature=&quot;这个号专注于“数据与广告”的数据挖掘系列，深耕于数据与算法的专业领域。也欢迎关注夏虫另一个号【夏虫悟冰】，抬头望天空，低头省自我，将重点更新“我有故事你有酒吗”与“历史尘埃”两个系列。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;也欢迎关注笔者另一个非技术公众号【夏虫悟冰】&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzU4NDE2Mzc5Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/L1DZlNuj2MVtThPyeNicwY65TGF50j7R2FbP6sT0utKIiak73ooPBVuARS0RkULCGjhpzicGHOSIuzmvC5tEkQBVg/0?wx_fmt=png&quot; data-nickname=&quot;夏虫悟冰&quot; data-alias=&quot;chong_talk&quot; data-signature=&quot;在写作中思考，在思考中成长，眯眼看世界，回首望自己。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;“我有故事你有酒吗”系列：&lt;/p&gt;&lt;p&gt;“历史的尘埃”系列：&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20d96adf1cb7b3d3062a87d1dfaf47a1</guid>
<title>工作流引擎架构设计</title>
<link>https://toutiao.io/k/9c3wejl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近开发的安全管理平台新增了很多工单申请流程需求，比如加白申请，开通申请等等。最开始的两个需求，为了方便，也没多想，就直接开发了对应的业务代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但随着同类需求不断增多，感觉再这样写可要累死人，于是开始了工作流引擎的开发之路。查找了一些资料之后，开发了现阶段的工作流引擎，文章后面会有介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然现在基本上能满足日常的需求，但感觉还不够智能，还有很多的优化空间，所以正好借此机会，详细了解了一些完善的工作流引擎框架，以及在架构设计上需要注意的点，形成了这篇文章，分享给大家。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是工作流&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看一下维基百科对于工作流的定义：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;工作流（Workflow），是对工作流程及其各操作步骤之间业务规则的抽象、概括描述。工作流建模，即将工作流程中的工作如何前后组织在一起的逻辑和规则，在计算机中以恰当的模型表达并对其实施计算。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流要解决的主要问题是：为实现某个业务目标，利用计算机在多个参与者之间按某种预定规则自动传递文档、信息或者任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，工作流就是对业务的流程化抽象。WFMC（工作流程管理联盟） 给出了工作流参考模型如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5433070866141733&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;635&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEokSpu8KwKQPJwWBPwhuTyZFVT34SWGu2RQolwXpwZV4G2DeIeROUNg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个例子，比如公司办公的 OA 系统，就存在大量的申请审批流程。而在处理这些流程时，如果每一个流程都对应一套代码，显然是不现实的，这样会造成很大程度上的代码冗余，而且开发工作量也会骤增。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候就需要一个业务无关的，高度抽象和封装的引擎来统一处理。通过这个引擎，可以灵活配置工作流程，并且可以自动化的根据配置进行状态变更和流程流转，这就是工作流引擎。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简单的工作流&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，一个工作流引擎需要支持哪些功能呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题并没有一个标准答案，需要根据实际的业务场景和需求来分析。在这里，我通过一个工单流程的演进，从简单到复杂，循序渐进地介绍一下都需要包含哪些基础功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;最简单流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.09712722298221614&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;731&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoECpiaicvSibehzpdJ1seOwBcN8kPt6ZTib8C3U4RN5dETL9j5iaIFXBbRY9g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最简单的一个流程工单，申请人发起流程，每个节点审批人逐个审批，最终流程结束。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;会签&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45010183299389&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEmUXyTRmY77t4Iibian48pFibkcAwJhDoEg2mVUziay5916wuUt4kt1LRPQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个过程中，节点分成了两大类：简单节点和复杂节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单节点处理逻辑不变，依然是处理完之后自动到下一个节点。复杂节点比如说会签节点，则不同，需要其下的所有子节点都处理完成，才能到下一个节点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;并行&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45010183299389&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEFtuMh4mZTEkvodA5aicfGr5B8ibOkibUuc4ZmoVnDiaqvfIhiaMqubVysbA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样属于复杂节点，其任何一个子节点处理完成后，都可以进入到下一个节点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;条件判断&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45010183299389&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEsMU8VtVneq8EHgOaSHSCUmMpzRC3PzbGuvkf0mtDjBPiabHZaVZbB6A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要根据不同的表单内容进入不同的分支流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个例子，比如在进行休假申请时，请假一天需要直属领导审批，如果大于三天则需要部门领导审批。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;动态审批人&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23392612859097128&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;731&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEeVVM21bkiaOBnFMwqcJibDB4afAicThzeoiaUyQ8pyzOtekmknVInaC6kw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审批节点的审批人需要动态获取，并且可配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审批人的获取方式可以分以下几种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;固定审批人&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从申请表单中获取&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据组织架构，动态获取&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从配置的角色组或者权限组中获取&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;撤销和驳回&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2913816689466484&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;731&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoE2nic6tSSxvCKh5absaFWhz5MfL0pibOsoMoaGias0T0FTn3AVDZ3IusRA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节点状态变更可以有申请人撤回，审批人同意，审批人驳回。那么在驳回时，可以直接驳回到开始节点，流程结束，也可以到上一个节点。更复杂一些，甚至可以到前面流程的任意一个节点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自动化节点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22024623803009577&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;731&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEtYG6zS97Ab7k4R50BxdAibNfgoTibZ8qSLfdMXkBREBSiawtibGRuO00LA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一些节点是不需要人工参与的，比如说联动其他系统自动处理，或者审批节点有时间限制，超时自动失效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;个性化通知&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节点审批之后，可以配置不同的通知方式来通知相关人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是我列举的一些比较常见的需求点，还有像加签，代理，脚本执行等功能，如果都实现的话，应该会是一个庞大的工作量。当然了，如果目标是做一个商业化产品的话，功能还是需要更丰富一些的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但把这些常见需求点都实现的话，应该基本可以满足大部分的需求了，至少对于我们系统的工单流程来说，目前是可以满足的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;工作流引擎对比&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然这是一个常见的需求，那么需要我们自己来开发吗？市面上有开源项目可以使用吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是肯定的，目前，市场上比较有名的开源流程引擎有 Osworkflow、Jbpm、Activiti、Flowable、Camunda 等等。其中：Jbpm、Activiti、Flowable、Camunda 四个框架同宗同源，祖先都是 Jbpm4，开发者只要用过其中一个框架，基本上就会用其它三个了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Osworkflow&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Osworkflow 是一个轻量化的流程引擎，基于状态机机制，数据库表很少。Osworkflow 提供的工作流构成元素有：步骤（step）、条件（conditions）、循环（loops）、分支（spilts）、合并（joins）等，但不支持会签、跳转、退回、加签等这些操作，需要自己扩展开发，有一定难度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果流程比较简单，Osworkflow 是一个很不错的选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;JBPM&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JBPM 由 JBoss 公司开发，目前最高版本是 JPBM7，不过从 JBPM5 开始已经跟之前不是同一个产品了，JBPM5 的代码基础不是 JBPM4，而是从 Drools Flow 重新开始的。基于 Drools Flow 技术在国内市场上用的很少，所有不建议选择 JBPM5 以后版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JBPM4 诞生的比较早，后来 JBPM4 创建者 Tom Baeyens 离开 JBoss，加入 Alfresco 后很快推出了新的基于 JBPM4 的开源工作流系统 Activiti，另外 JBPM 以 hibernate 作为数据持久化 ORM 也已不是主流技术。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Activiti&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Activiti 由 Alfresco 软件开发，目前最高版本 Activiti7。Activiti 的版本比较复杂，有 Activiti5、Activiti6、Activiti7 几个主流版本，选型时让人晕头转向，有必要先了解一下 Activiti 这几个版本的发展历史。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Activiti5 和 Activiti6 的核心 leader 是 Tijs Rademakers，由于团队内部分歧，在 2017 年 Tijs Rademakers 离开团队，创建了后来的 Flowable。Activiti6 以及 Activiti5 代码已经交接给了 Salaboy 团队，Activiti6 以及 Activiti5 的代码官方已经暂停维护了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Salaboy 团队目前在开发 Activiti7 框架，Activiti7 内核使用的还是 Activiti6，并没有为引擎注入更多的新特性，只是在 Activiti 之外的上层封装了一些应用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Flowable&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flowable 是一个使用 Java 编写的轻量级业务流程引擎，使用 Apache V2 license 协议开源。2016 年 10 月，Activiti 工作流引擎的主要开发者离开 Alfresco 公司并在 Activiti 分支基础上开启了 Flowable 开源项目。基于 Activiti v6 beta4 发布的第一个 Flowable release 版本为 6.0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flowable 项目中包括 BPMN（Business Process Model and Notation）引擎、CMMN（Case Management Model and Notation）引擎、DMN（Decision Model and Notation）引擎、表单引擎（Form Engine）等模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对开源版，其商业版的功能会更强大。以 Flowable6.4.1 版本为分水岭，大力发展其商业版产品，开源版本维护不及时，部分功能已经不再开源版发布，比如表单生成器（表单引擎）、历史数据同步至其他数据源、ES 等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Camunda&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Camunda 基于 Activiti5，所以其保留了 PVM，最新版本 Camunda7.15，保持每年发布两个小版本的节奏，开发团队也是从 Activiti 中分裂出来的，发展轨迹与 Flowable 相似，同时也提供了商业版，不过对于一般企业应用，开源版本也足够了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是每个项目的一个大概介绍，接下来主要对比一下 Jbpm、Activiti、Flowable 和 Camunda。只看文字的话可能对它们之间的关系还不是很清楚，所以我画了一张图，可以更清晰地体现每个项目的发展轨迹。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4676165803108808&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;772&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEafXvEvIxELIgIVslEqWIOliaZvMD8ly0XnzXwj7FSia0nlkAiavIzicBtA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如果想要选择其中一个项目来使用的话，应该如何选择呢？我罗列了几项我比较关注的点，做了一张对比表格，如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Activiti 7&lt;/th&gt;&lt;th&gt;Flowable 6&lt;/th&gt;&lt;th&gt;Camunda&lt;/th&gt;&lt;th&gt;JBPM 7&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;流程协议&lt;/td&gt;&lt;td&gt;BPMN2.0、XPDL、PDL&lt;/td&gt;&lt;td&gt;BPMN2.0、XPDL、XPDL&lt;/td&gt;&lt;td&gt;BPMN2.0、XPDL、XPDL&lt;/td&gt;&lt;td&gt;BPMN2.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;开源情况&lt;/td&gt;&lt;td&gt;开源&lt;/td&gt;&lt;td&gt;商业和开源版&lt;/td&gt;&lt;td&gt;商业和开源版&lt;/td&gt;&lt;td&gt;开源&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;开发基础&lt;/td&gt;&lt;td&gt;JBPM4&lt;/td&gt;&lt;td&gt;Activiti 5 &amp;amp; 6&lt;/td&gt;&lt;td&gt;Activiti 5&lt;/td&gt;&lt;td&gt;版本 5 之后 Drools Flow&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据库&lt;/td&gt;&lt;td&gt;Oracle、SQL Server、MySQL&lt;/td&gt;&lt;td&gt;Oracle、SQL Server、MySQL、postgre&lt;/td&gt;&lt;td&gt;Oracle、SQL Server、MySQL、postgre&lt;/td&gt;&lt;td&gt;MySQL，postgre&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;架构&lt;/td&gt;&lt;td&gt;spring boot 2&lt;/td&gt;&lt;td&gt;spring boot 1.5&lt;/td&gt;&lt;td&gt;spring boot 2&lt;/td&gt;&lt;td&gt;Kie&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;运行模式&lt;/td&gt;&lt;td&gt;独立运行和内嵌&lt;/td&gt;&lt;td&gt;独立运行和内嵌&lt;/td&gt;&lt;td&gt;独立运行和内嵌&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;流程设计器&lt;/td&gt;&lt;td&gt;AngularJS&lt;/td&gt;&lt;td&gt;AngularJS&lt;/td&gt;&lt;td&gt;bpmn.js&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;活跃度&lt;/td&gt;&lt;td&gt;活跃&lt;/td&gt;&lt;td&gt;相对活跃&lt;/td&gt;&lt;td&gt;相对活跃&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;表数量&lt;/td&gt;&lt;td&gt;引入 25 张表&lt;/td&gt;&lt;td&gt;引入 47 张表&lt;/td&gt;&lt;td&gt;引入 19 张表&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jar 包数量&lt;/td&gt;&lt;td&gt;引入 10 个 jar&lt;/td&gt;&lt;td&gt;引入 37 个 jar&lt;/td&gt;&lt;td&gt;引入 15 个 jar&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Flowable 应用举例&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果选择使用开源项目来开发自己的引擎，或者嵌入到现有的项目中，应该如何使用呢？这里通过 Flowable 来举例说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Flowable 可以有两种方式，分别是内嵌和独立部署方式，现在来分别说明：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;内嵌模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建 maven 工程&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先建一个普通的 maven 工程，加入 Flowable 引擎的依赖以及 h2 内嵌数据库的依赖，也可以使用 MySQL 数据库来做持久化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.flowable/flowable-engine --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.flowable&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;flowable-engine&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;6.7.2&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.h2database&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;h2&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.4.192&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建流程引擎实例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; org.flowable.engine.ProcessEngine;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.flowable.engine.ProcessEngineConfiguration;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HolidayRequest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ProcessEngineConfiguration cfg = &lt;span&gt;new&lt;/span&gt; StandaloneProcessEngineConfiguration()&lt;br/&gt;      .setJdbcUrl(&lt;span&gt;&quot;jdbc:h2:mem:flowable;DB_CLOSE_DELAY=-1&quot;&lt;/span&gt;)&lt;br/&gt;      .setJdbcUsername(&lt;span&gt;&quot;sa&quot;&lt;/span&gt;)&lt;br/&gt;      .setJdbcPassword(&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt;      .setJdbcDriver(&lt;span&gt;&quot;org.h2.Driver&quot;&lt;/span&gt;)&lt;br/&gt;      .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);&lt;br/&gt;&lt;br/&gt;    ProcessEngine processEngine = cfg.buildProcessEngine();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们就可以往这个引擎实例上部署一个流程 xml。比如，我们想建立一个员工请假流程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;definitions&lt;/span&gt; &lt;span&gt;xmlns&lt;/span&gt;=&lt;span&gt;&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;xmlns:activiti&lt;/span&gt;=&lt;span&gt;&quot;http://activiti.org/bpmn&quot;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;typeLanguage&lt;/span&gt;=&lt;span&gt;&quot;http://www.w3.org/2001/XMLSchema&quot;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;expressionLanguage&lt;/span&gt;=&lt;span&gt;&quot;http://www.w3.org/1999/XPath&quot;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;targetNamespace&lt;/span&gt;=&lt;span&gt;&quot;http://www.flowable.org/processdef&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;process&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;holidayRequest&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Holiday Request&quot;&lt;/span&gt; &lt;span&gt;isExecutable&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;startEvent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;startEvent&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;startEvent&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;approveTask&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!--        &amp;lt;userTask id=&quot;approveTask&quot; name=&quot;Approve or reject request&quot;/&amp;gt;--&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;userTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;approveTask&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Approve or reject request&quot;&lt;/span&gt; &lt;span&gt;activiti:candidateGroups&lt;/span&gt;=&lt;span&gt;&quot;managers&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;approveTask&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;decision&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;exclusiveGateway&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;decision&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;decision&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;externalSystemCall&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;conditionExpression&lt;/span&gt; &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;tFormalExpression&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &amp;lt;![CDATA[&lt;br/&gt;          ${approved}&lt;br/&gt;        ]]&amp;gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;conditionExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;sequenceFlow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;decision&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;sendRejectionMail&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;conditionExpression&lt;/span&gt; &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;tFormalExpression&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &amp;lt;![CDATA[&lt;br/&gt;          ${!approved}&lt;br/&gt;        ]]&amp;gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;conditionExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;sequenceFlow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;serviceTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;externalSystemCall&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Enter holidays in external system&quot;&lt;/span&gt;&lt;br/&gt;                     &lt;span&gt;activiti:class&lt;/span&gt;=&lt;span&gt;&quot;org.example.CallExternalSystemDelegate&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;externalSystemCall&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;holidayApprovedTask&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!--        &amp;lt;userTask id=&quot;holidayApprovedTask&quot; name=&quot;Holiday approved&quot;/&amp;gt;--&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;userTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;holidayApprovedTask&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Holiday approved&quot;&lt;/span&gt; &lt;span&gt;activiti:assignee&lt;/span&gt;=&lt;span&gt;&quot;${employee}&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;holidayApprovedTask&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;approveEnd&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;serviceTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;sendRejectionMail&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Send out rejection email&quot;&lt;/span&gt;&lt;br/&gt;                     &lt;span&gt;activiti:class&lt;/span&gt;=&lt;span&gt;&quot;org.flowable.SendRejectionMail&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;sendRejectionMail&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;rejectEnd&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;endEvent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;approveEnd&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;endEvent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;rejectEnd&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;process&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;definitions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此 xml 是符合 bpmn2.0 规范的一种标准格式，其对应的流程图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37898936170212766&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoE8x1ibHZJY4Jdey0TlmvDibanictLnozVGibDjQxekdgSibll16DLkoAGsXg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们就把这个文件传给流程引擎，让它基于该文件，创建一个工作流。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;RepositoryService repositoryService = processEngine.getRepositoryService();&lt;br/&gt;Deployment deployment = repositoryService.createDeployment()&lt;br/&gt;  .addClasspathResource(&lt;span&gt;&quot;holiday-request.bpmn20.xml&quot;&lt;/span&gt;)&lt;br/&gt;  .deploy();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建后，实际就写到内存数据库 h2 了，我们还可以把它查出来：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()&lt;br/&gt;  .deploymentId(deployment.getId())&lt;br/&gt;  .singleResult();&lt;br/&gt;System.out.println(&lt;span&gt;&quot;Found process definition : &quot;&lt;/span&gt; + processDefinition.getName());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建工作流实例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建工作流实例，需要提供一些输入参数，比如我们创建的员工请假流程，参数就需要：员工姓名、请假天数、事由等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Scanner scanner= &lt;span&gt;new&lt;/span&gt; Scanner(System.in);&lt;br/&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;Who are you?&quot;&lt;/span&gt;);&lt;br/&gt;String employee = scanner.nextLine();&lt;br/&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;How many holidays do you want to request?&quot;&lt;/span&gt;);&lt;br/&gt;Integer nrOfHolidays = Integer.valueOf(scanner.nextLine());&lt;br/&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;Why do you need them?&quot;&lt;/span&gt;);&lt;br/&gt;String description = scanner.nextLine();&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;RuntimeService runtimeService = processEngine.getRuntimeService();&lt;br/&gt;&lt;br/&gt;Map&amp;lt;String, Object&amp;gt; variables = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;();&lt;br/&gt;variables.put(&lt;span&gt;&quot;employee&quot;&lt;/span&gt;, employee);&lt;br/&gt;variables.put(&lt;span&gt;&quot;nrOfHolidays&quot;&lt;/span&gt;, nrOfHolidays);&lt;br/&gt;variables.put(&lt;span&gt;&quot;description&quot;&lt;/span&gt;, description);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数准备好后，就可以传给工作流了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ProcessInstance processInstance =&lt;br/&gt;    runtimeService.startProcessInstanceByKey(&lt;span&gt;&quot;holidayRequest&quot;&lt;/span&gt;, variables);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，就会根据流程定义里的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;userTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;approveTask&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Approve or reject request&quot;&lt;/span&gt; &lt;span&gt;activiti:candidateGroups&lt;/span&gt;=&lt;span&gt;&quot;managers&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个任务，任务有个标签，就是 &lt;code&gt;candidateGroups&lt;/code&gt;，这里的 &lt;code&gt;managers&lt;/code&gt;，可以猜得出，是给 &lt;code&gt;managers&lt;/code&gt; 建了个审批任务。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;查询并审批任务&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 manager 查询任务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;TaskService taskService = processEngine.getTaskService();&lt;br/&gt;List&amp;lt;Task&amp;gt; tasks = taskService.createTaskQuery().taskCandidateGroup(&lt;span&gt;&quot;managers&quot;&lt;/span&gt;).list();&lt;br/&gt;System.out.println(&lt;span&gt;&quot;You have &quot;&lt;/span&gt; + tasks.size() + &lt;span&gt;&quot; tasks:&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;tasks.size(); i++) {&lt;br/&gt;  System.out.println((i+&lt;span&gt;1&lt;/span&gt;) + &lt;span&gt;&quot;) &quot;&lt;/span&gt; + tasks.get(i).getName());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审批任务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;boolean&lt;/span&gt; approved = scanner.nextLine().toLowerCase().equals(&lt;span&gt;&quot;y&quot;&lt;/span&gt;);&lt;br/&gt;variables = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;();&lt;br/&gt;variables.put(&lt;span&gt;&quot;approved&quot;&lt;/span&gt;, approved);&lt;br/&gt;taskService.complete(task.getId(), variables);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就是把全局变量 &lt;code&gt;approved&lt;/code&gt;，设为了 &lt;code&gt;true&lt;/code&gt;，然后提交给引擎。引擎就会根据这里的变量是 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt;，选择走不同分支。如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;decision&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;externalSystemCall&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;conditionExpression&lt;/span&gt; &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;tFormalExpression&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &amp;lt;![CDATA[&lt;br/&gt;  ${approved}&lt;br/&gt;]]&amp;gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;conditionExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;sequenceFlow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;decision&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;sendRejectionMail&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;conditionExpression&lt;/span&gt; &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;tFormalExpression&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &amp;lt;![CDATA[&lt;br/&gt;  ${!approved}&lt;br/&gt;]]&amp;gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;conditionExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;sequenceFlow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回调用户代码&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审批后，就会进入下一个节点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;serviceTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;externalSystemCall&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Enter holidays in external system&quot;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;activiti:class&lt;/span&gt;=&lt;span&gt;&quot;org.example.CallExternalSystemDelegate&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个 &lt;code&gt;class&lt;/code&gt;，就是需要我们自己实现的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.27611664820967147&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2709&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEuWhdjibY85LibMwia2HzYsm5ePHvWRfDbXZYgL9EvxhykfpgaUX6JicBxw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，流程就走完结束了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;REST API 模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍的方式是其作为一个 jar，内嵌到我们的程序里。创建引擎实例后，由我们业务程序去驱动引擎的运行。引擎和业务代码在同一个进程里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种方式，Flowable 也可以作为一个独立服务运行，提供 REST API 接口，这样的话，非 Java 语言开发的系统就也可以使用该引擎了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个只需要我们下载官方的 zip 包，里面有个 rest 的 war 包，可以直接放到 tomcat 里运行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;部署工作流&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种方式下，如果要实现上面举例的员工请假流程，可以通过调接口来实现：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25798438608942514&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoE1F1s7fcbAEuLlfRUSEYjsS34TSXgoHcQsmvhso0ficKY2VDK78Smynw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动工作流：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4304581097812629&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2423&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEkQIsQCHMrak55e4NzI1TNlQZrfzCX071PHxViaJ8IibukIj26CY7E4Lw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他接口就不一一展示了，可以参考官方文档。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;通过页面进行流程建模&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截止到目前，创建工作流程都是通过建立 xml 来实现的，这样还是非常不方便的。因此，系统也提供了通过页面可视化的方式来创建流程，使用鼠标拖拽相应组件即可完成。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46255506607929514&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEBKdoOoc7ZxEQ5zjK0NoxYzuTXPP0LSyOSdBTpXIic6pfzjicC9GODL6A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是体验下来还是比较辛苦的，功能很多，名词更多，有很多都不知道是什么意思，只能不断尝试来理解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开源 VS 自研&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然已经有成熟的开源产品了，还需要自研吗？这算是一个老生常谈的问题了。那到底应该如何选择呢？其实并不困难，归根结底就是要符合自身的业务特点，以及实际的需求。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3442622950819672&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;671&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoE2JM9obqkfh6nC9GKRZNne0nk5x3tJ1ibgA6UmicoTaib7CicvoDFBcaEMQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;开源优势：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入门门槛低，有很多可以复用的成果。通常而言，功能比较丰富，周边生态也比较完善，投入产出比比较高。&lt;strong&gt;一句话总结，投入少，见效快。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;开源劣势：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核不容易掌控，门槛较高，通常开源的功能和实际业务并不会完全匹配，很多开源产品开箱即用做的不够好，需要大量调优。&lt;strong&gt;一句话总结，入门容易掌控难。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;自研优势：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品核心技术掌控程度高，可以更好的贴着业务需求做，可以定制的更好，基于上述两点，通常更容易做到良好的性能表现。&lt;strong&gt;一句话总结，量身定制。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;自研劣势：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;投入产出比略低，且对团队成员的能力曲线要求较高。此外封闭的生态会导致周边支持缺乏，当需要一些新需求时，往往都需要定制开发。&lt;strong&gt;一句话总结，啥事都要靠自己。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上的分析，再结合我们自身业务，我总结了以下几点可供参考：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;开源项目均为 Java 技术栈，而我们使用 Python 和 Go 比较多，技术栈不匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开源项目功能丰富，而我们业务相对简单，使用起来比较重&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开源项目并非开箱即用，需要结合业务特点做定制开发，学习成本和维护成本比较高&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上所述，我觉得自研更适合我们现阶段的产品特点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;工作流引擎架构设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果选择自研，架构应该如何设计呢？有哪些比较重要的模块和需要注意的点呢？下面来详细说说。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;BPMN&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BPMN 全称是 Business Process Model And Notation，即业务流程模型和符号。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4838507369081217&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;3189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoE0JDoYulZz74Dao4mlib8KtsRiaXRF7RpTib60iakNeMRZGcaGpVmUCgtJw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以理解成一种规范，在这个规范里，哪些地方用空心圆，哪些地方用矩形，哪些地方用菱形，都是有明确定义的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，只要是基于这个规范开发的系统，其所创建的流程就都是可以通用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，如果只是开发一个内部系统，不遵守这个规范也没有问题。但要是做一个产品的话，为了通用性更强，最好还是遵守这个规范。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;流程设计器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于工作流引擎来说，流程设计器的选型至关重要，它提供了可视化的流程编排能力，决定了用户体验的好坏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前主流的流程设计器有 Activiti-Modeler，mxGraph，bpmn-js 等，下面来做一个简单介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Activiti-Modeler&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Activiti 开源版本中带了 Web 版流程设计器，在 Activiti-explorer 项目中有 Activiti-Modeler，优点是集成简单，开发工作量小，缺点是界面不美观，用户体验差。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6623711340206185&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEFUJl7beaEw7ay6yyBZqhbxceibJg8DqIFLicqRdxa4j89ia4RYGiassQjA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;mxGraph&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mxGraph 是一个强大的 JavaScript 流程图前端库，可以快速创建交互式图表和图表应用程序，国内外著名的 ProcessOne 和 draw.io 都是使用该库创建的强大的在线流程图绘制网站。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 mxGraph 是一个开放的 js 绘图开发框架，我们可以开发出很炫的样式，或者完全按照项目需求定制。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6822742474916388&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEOuWjeb6XQZKoax07RD7BH21LNxRjyeibht5U92lYBQBbNagKliaRDZQw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方网站：http://jgraph.github.io/mxgrap&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;bpmn-js&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bpmn-js 是 BPMN2.0 渲染工具包和 Web 模型。bpmn-js 正在努力成为 Camunda BPM 的一部分。bpmn-js 使用 Web 建模工具可以很方便的构建 BPMN 图表，可以把 BPMN 图表嵌入到你的项目中，容易扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bpmn-js 是基于原生 js 开发，支持集成到 vue、react 等开源框架中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38113207547169814&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoETJL5oibK862N9KwEdO6rBcKFA9GtXVjCplMLvE6M6icHf26yXPn0MTMA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方网站：https://bpmn.io/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上介绍的都属于是功能强大且完善的框架，除此之外，还有其他基于 Vue 或者 React 开发的可视化编辑工具，大家也可以根据自己的实际需求进行选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;流程引擎&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后来说说流程引擎，整个系统的核心。引擎设计的好坏决定了整个系统的稳定性，可用性，扩展性等等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6747967479674797&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;861&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt8m5ktghgPamMaYF2RSzoEV2UlNNSic16BlkJttOVUhadkPZ8HdGIK0MHc5hSyehxItTR6TYKk5Qg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体架构如图所示，主要包括一下几个部分：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一、&lt;strong&gt;流程设计器&lt;/strong&gt;主要通过一系列工具创建一个计算机可以处理的工作流程描述，流程建模通常由许多离散的节点步骤组成，需要包含所有关于流程的必要信息，这些信息包括流程的起始和结束条件，节点之间的流转，要承担的用户任务，被调用的应用程序等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二、&lt;strong&gt;流程引擎&lt;/strong&gt;主要负责流程实例化、流程控制、节点实例化、节点调度等。在执行过程中，工作流引擎提供流程的相关信息，管理流程的运行，监控流程的运行状态，并记录流程运行的历史数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三、&lt;strong&gt;存储服务&lt;/strong&gt;提供具体模型及流程流转产生的信息的存储空间，工作流系统通常需要支持各种常见的数据库存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;四、&lt;strong&gt;组织模型&lt;/strong&gt;不属于工作流系统的建设范围，但流程设计器在建模的过程中会引用组织模型，如定义任务节点的参与者。还有就是在流程流转的过程中同样也需要引用组织模型，如在进行任务指派时，需要从组织模型中确定任务的执行者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流引擎内部可以使用平台自身的统一用户组织架构，也可以适配第三方提供的用户组织架构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;五、工作流引擎作为一项基础支撑服务提供给各业务系统使用，对第三方系统开放标准的 &lt;strong&gt;RESTful 服务&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后记&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来说说我现在开发的系统支持到了什么程度，以及未来可能的发展方向。由于毕竟不是一个专门的工单系统，工单申请也只是其中的一个模块，所以在整体的功能上肯定和完整的工作流引擎有很大差距。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;第一版&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一版并没有流程引擎，开发方式简单粗暴，每增加一个流程，就需要重新开发对应的表和业务代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的缺点是非常明显的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每个流程需要单独开发，工作量大，开发效率低&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流程功能相近，代码重复量大，冗余，不利于维护&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定制化开发，缺少扩展性#&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;第二版&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二版，也就是目前的版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着工单流程逐渐增多，工作量逐渐增大，于是开始对流程进行优化，开发了现阶段的工作流引擎。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.578125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dlt6wu6Lcialicmn80jiaoLvIQ3cT8jd1rLjuibXwwVJ2DNMJTgriaZuCQJCjPKYRNjZbTtd8886E3lEFNQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在新增一个工单流程时，需要先进行工作流配置，配置其基础信息，自定义字段，状态和流转这些信息。还支持配置自动化节点，可以根据条件由程序自动完成相关操作并审批。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置好之后，后端无需开发，由统一的引擎代码进行处理，包括节点审批流转，状态变更等。只需要开发前端的创建和查询页面即可，相比于第一版，已经在很大程度上提高了开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前版本需要优化的点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;缺少可视化流程设计器，无法做到拖拽式设计流程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点之间状态流转不够灵活&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺少分布式事物支持，以及异常处理机制&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;下一个版本&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对以上不足，下一个版本准备主要优化三点，如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;需要支持可视化流程设计器，使流程设计更加简单，灵活&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据流程配置自动生成前端页面，做到新增一种类型的工单，无需开发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加节点自动化能力，异常处理机制，提高系统的稳定性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是本文的全部内容，如果觉得还不错的话欢迎&lt;strong&gt;点赞&lt;/strong&gt;，&lt;strong&gt;转发&lt;/strong&gt;和&lt;strong&gt;关注&lt;/strong&gt;，感谢支持。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考文章：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://www.cnblogs.com/grey-wolf/p/15963839.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.cnblogs.com/duck-and-duck/p/14436373.html#!comments&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://zhuanlan.zhihu.com/p/369761832&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://zhuanlan.zhihu.com/p/143739835&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://bbs.qolome.com/?p=365&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://workflowengine.io/blog/java-workflow-engines-comparison/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1cf7296baf50908af9059b42426439af</guid>
<title>什么是 Istio ？Istio 是用来做什么的？可以代替 Spring Cloud 吗？</title>
<link>https://toutiao.io/k/won00pk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-4em6pe&quot; options=&quot;[object Object]&quot;&gt;&lt;blockquote data-first-child=&quot;&quot; data-pid=&quot;_Da6VmTL&quot;&gt;北京时间2月23日，在全球首届社区峰会IstioCon 2021中，华为云应用服务网格首席架构师张超盟发表了《Best practice:from Spring Cloud to Istio》主题演讲，分享了Istio在生产中使用的实际案例。&lt;br/&gt;官网链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//events.istio.io/istiocon-2021/sessions/best-practice%25EF%25BC%259Afrom-spring-cloud-to-istio/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;events.istio.io/istioco&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;n-2021/sessions/best-practice%EF%BC%9Afrom-spring-cloud-to-istio/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;以下为演讲全文&lt;/blockquote&gt;&lt;p data-pid=&quot;QGx8pc28&quot;&gt;大家好，我是来自华为云的工程师。很荣幸有机会和大家分享Istio在生产中使用的实际案例。&lt;/p&gt;&lt;p data-pid=&quot;a8l3rG6k&quot;&gt;华为云应用服务网格从2018年在公有云上线， 作为全球最早的几个网格服务之一，经历和见证了从早期对网格的了解、尝试到当前大规模使用的过程。服务的客户越来越多，场景也越来越复杂。这其中的通用功能作为feature大都贡献到Istio社区，解决方案层面的实践也希望通过这样的机会和大家交流。&lt;/p&gt;&lt;p data-pid=&quot;EDqNk4qM&quot;&gt;本次我选取的主题是Spring Cloud to Istio。来自我们客户的Spring cloud的项目和Istio的结合与迁移案例。&lt;/p&gt;&lt;p data-pid=&quot;jm2hAto0&quot;&gt;&lt;b&gt;演讲主要包含四部分的内容：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;uvS12tH4&quot;&gt;1）背景介绍&lt;/p&gt;&lt;p data-pid=&quot;JbbOq0b9&quot;&gt;2）使用Spring cloud微服务框架遇到的问题&lt;/p&gt;&lt;p data-pid=&quot;67Hwkk-E&quot;&gt;3）解决方案&lt;/p&gt;&lt;p data-pid=&quot;PLhrPMiH&quot;&gt;4）通过示例来描述方案的实践细节&lt;/p&gt;&lt;p data-pid=&quot;TvEMVuM9&quot;&gt;相关文章推荐：&lt;/p&gt;&lt;h2&gt;背景介绍&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3b0d5f37df01a526eeefb37905f576ff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-3b0d5f37df01a526eeefb37905f576ff_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-3b0d5f37df01a526eeefb37905f576ff_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3b0d5f37df01a526eeefb37905f576ff_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;yyNqkmkN&quot;&gt;还是以微服务为切入点，微服务的诸多优势非常明显，但相应给整个系统带来的复杂度也非常显著。单体的系统变成了分布式后，网络问题，服务如何找到并访问到对端的服务发现问题，网络访问的容错保护问题等。连当年最简单的通过日志中的调用栈就能实现的问题定位，微服务化后必须要通过分布式调用链才能支持。怎样解决微服务带来的这些挑战？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9b0aea69666b26afda11689d634493c9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;610&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-9b0aea69666b26afda11689d634493c9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;610&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-9b0aea69666b26afda11689d634493c9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9b0aea69666b26afda11689d634493c9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Zakr2OcJ&quot;&gt;微服务SDK曾经是一个常用的解决方案。将微服务化后通用的能力封装在一个开发框架中，开发者使用这个框架开发写自己的业务代码，生成的微服务自然就内置了这些能力。在很长的一段时间内，这种形态是微服务治理的标配，以至于初学者以为只有这些SDK才是微服务。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9a19501df58110a0890eaabf82cdcf0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;603&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-9a19501df58110a0890eaabf82cdcf0a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;603&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-9a19501df58110a0890eaabf82cdcf0a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9a19501df58110a0890eaabf82cdcf0a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;7imVlHRn&quot;&gt;服务网格则通过另一种形态提供治理能力。不同于SDK方式，服务治理的能力在一个独立的代理进程中提供，完全和开发解耦。虽然从图上看两者差异非常小，后面我们将会从架构和实际案例来分析两者在设计理念上的差异，来体会前者是一个开发框架，而后者是一个基础设施。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f3887b9d075b8ce169f7e01652818b67_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-f3887b9d075b8ce169f7e01652818b67_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-f3887b9d075b8ce169f7e01652818b67_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-f3887b9d075b8ce169f7e01652818b67_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;nqGk5or6&quot;&gt;SDK形态中Spring cloud是最有影响力的代表项目。Spring cloud提供了构建分布式应用的开发工具集，如列表所示。其中被大部分开发者熟知的是微服务相关项目，如：服务注册发现eureka、配置管理 config、负载均衡ribbon、熔断容错Hystrix、调用链埋点sleuth、网关zuul或Spring cloud gateway等项目。在本次分享中提到的Spring cloud也特指Spring cloud的微服务开发套件。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c1748daf404cd785afcc16fb0b440c69_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;602&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c1748daf404cd785afcc16fb0b440c69_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;602&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c1748daf404cd785afcc16fb0b440c69_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c1748daf404cd785afcc16fb0b440c69_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;F1bQwTZd&quot;&gt;而网格形态中，最有影响力的项目当属Istio。Istio的这张架构图在这次演讲中会高频出现。作为本次分享的背景，我们只要知道架构上由控制面和数据面组成，控制面管理网格里面的服务和对服务配置的各种规则。数据面上每个服务间的出流量和入流量都会被和服务同POD的数据面代理拦截和执行流量管理的动作。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d81a93b744db85015a5b16472c12021b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-d81a93b744db85015a5b16472c12021b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-d81a93b744db85015a5b16472c12021b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d81a93b744db85015a5b16472c12021b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;dFVt6Y-W&quot;&gt;除了架构外，作为背景的另外一个部分，我们挑两个基础功能稍微打开看下两者的设计和实现上的相同和不同。首先是服务发现和负载均衡。&lt;/p&gt;&lt;p data-pid=&quot;R5KTFbad&quot;&gt;左边是Spring cloud，所有的微服务都会先注册中心，一般是Eureka进行服务注册，然后在服务访问时，consumer去注册中心进行服务发现得到待访问的目标服务的实例列表，使用客户端负载均衡ribbon选择一个服务实例发起访问。&lt;/p&gt;&lt;p data-pid=&quot;AaAp7iEH&quot;&gt;右边Istio不需要服务注册的过程，只需要从运行平台k8s中获取服务和实例的关系，在服务访问时，数据面代理Envoy拦截到流量，选择一个目标实例发送请求。可以看到都是基于服务发现数据进行客户端负载均衡，差别是服务发现数据来源不同，负载均衡的执行体不同。&lt;/p&gt;&lt;p data-pid=&quot;4htdg_1s&quot;&gt;&lt;b&gt;下面比较下熔断：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-00ac848e45d051e9ed0104526397c35b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-00ac848e45d051e9ed0104526397c35b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-00ac848e45d051e9ed0104526397c35b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-00ac848e45d051e9ed0104526397c35b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;rWngFs5m&quot;&gt;左边为经典的Hystrix的状态迁移图。一段时间内实例连续的错误次数超过阈值则进入熔断开启状态，不接受请求；隔离一段时间后，会从熔断状态迁移到半熔断状态，如果正常则进入熔断关闭状态，可以接收请求；如果不正常则还是进入熔断开启状态。&lt;/p&gt;&lt;p data-pid=&quot;svaxKLb_&quot;&gt;Istio中虽然没有显示的提供这样一个状态图，但是大家熟悉Istio规则和行为应该会发现，Istio中OutlierDection的阈值规则也都是这样设计的。两者的不同是Spring cloud的熔断是在SDK中Hystrix执行，Istio中是数据面proxy执行。Hystrix因为在业务代码中，允许用户通过编程做一些控制。&lt;/p&gt;&lt;p data-pid=&quot;ILIzCBiR&quot;&gt;以上分析可以看到服务发现、负载均衡和熔断，能力和机制都是类似的。如果忽略图上的某些细节，粗的看框图模型都是完全一样的，对比表格中也一般只有一项就是执行位置不同，这一点不同在实际应用中带来非常大的差异。&lt;/p&gt;&lt;h2&gt;使用Spring cloud微服务框架遇到的问题&lt;/h2&gt;&lt;p data-pid=&quot;pa1-0p55&quot;&gt;本次演讲的重点是实践。以下是我们客户找到我们TOP的几个的问题，剖析下用户使用传统微服务框架碰到了哪些问题，这些大部分也是他们选择网格的最大动力。&lt;/p&gt;&lt;p data-pid=&quot;XOTb2FxB&quot;&gt;&lt;b&gt;1）多语言问题&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-97aa11b8f8e62831883ecb818fa2c458_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-97aa11b8f8e62831883ecb818fa2c458_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-97aa11b8f8e62831883ecb818fa2c458_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-97aa11b8f8e62831883ecb818fa2c458_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;54IRKIUz&quot;&gt;在企业应用开发下，一个业务使用统一的开发框架是非常合理常见的，很多开发团队为了提升效率，经常还会维护有自己公司或者团队的通用开发框架。当然因为大部分业务系统都是基于Java开发，所以Spring cloud开发框架，或者衍生于Spring cloud的各种开发框架使用的尤其广泛。&lt;/p&gt;&lt;p data-pid=&quot;K0nE4Gd9&quot;&gt;但是在云原生场景下，业务一般更加复杂多样，特别是涉及到很多即存的老系统。我们不能要求为了微服务化将在用的一组成熟服务用Spring cloud重写下。用户非常希望有一种方式不重写原来的系统也能对其进行应用层服务访问管理。&lt;/p&gt;&lt;p data-pid=&quot;p9I7CtXL&quot;&gt;&lt;b&gt;2）将Spring cloud的微服务运行在K8s上会有很大的概率出现服务发现不及时&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-951426814487a341585dc708e00e0048_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-951426814487a341585dc708e00e0048_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-951426814487a341585dc708e00e0048_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-951426814487a341585dc708e00e0048_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;gen-uIWp&quot;&gt;前面介绍过Spring cloud服务发现是基于各个微服务先向注册中心进行服务注册的数据来实现的，在传统Spring cloud场景下，当微服务部署在VM上，服务动态变化要求没有那么高，顶多个别实例运行不正常，通过服务发现的健康检查就足够了。但是在k8s场景下，服务实例动态迁移是非常正常场景。如图示，producer的某个Pod已经从一个节点迁移到另外一个节点了，这时需要新的pod2的producer实例向eureka注册，老实例Pod1要去注册。&lt;/p&gt;&lt;p data-pid=&quot;G2w3ZN4m&quot;&gt;如果该情况频繁发生，会出现注册中心数据维护不及时，导致服务发现和负载均衡到旧的实例pod1上，从而引起访问失败的情况。&lt;/p&gt;&lt;p data-pid=&quot;Akfhya99&quot;&gt;&lt;b&gt;3）升级所有应用以应对服务管理需求变化&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c04a3fda1687eb470ad0e128b35b5040_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-c04a3fda1687eb470ad0e128b35b5040_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-c04a3fda1687eb470ad0e128b35b5040_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c04a3fda1687eb470ad0e128b35b5040_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Q5cZ6ebP&quot;&gt;第三个问题是一个比较典型的问题。客户有一个公共团队专门维护了一套基于Spring cloud的自有开发框架，在每次升级开发框架时，不得不求着业务团队来升级自己的服务。经常会SDK自身修改测试工作量不大，但却要制定很长周期的升级计划，来对上千个基于这个SDK开发的服务分组重新编译，打包，升级，而且经常要陪着业务团队在夜间变更。业务团队因为自身没有什么改动，考虑到这个升级带来的工作量和线上风险，一般也没有什么动力。&lt;/p&gt;&lt;p data-pid=&quot;aOeCxLhg&quot;&gt;&lt;b&gt;4）从单体式架构向微服务架构迁移&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c73c99145c6f4e907b562c037e759d5d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;600&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c73c99145c6f4e907b562c037e759d5d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;600&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c73c99145c6f4e907b562c037e759d5d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c73c99145c6f4e907b562c037e759d5d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;eGvfhJZL&quot;&gt;这是一个比较普遍的问题，就是渐进的微服务化。马丁福勒在著名的文章单体到微服务的拆分中（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//martinfowler.com/articles/break-monolith-into-microservices.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;martinfowler.com/articl&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;es/break-monolith-into-microservices.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; ）也提到了对渐进微服务化的倡议，如何能从业务上将一个大的业务分割，解耦，然后逐步微服务化。马丁福勒强调 “解耦的是业务能力不是代码” ，大神将代码的解耦留给了开发者。&lt;/p&gt;&lt;p data-pid=&quot;y1hQhXBU&quot;&gt;但是站在开发者的角度讲渐进的微服务不是一个容易的事情。以基于Spring cloud框架进行微服务开发为例，为了所有的微服务间进行统一的服务发现、负载均衡，消费和执行同样的治理策略，必须要求所有的微服务基于同样的，甚至是统一版本的SDK来开发。&lt;/p&gt;&lt;p data-pid=&quot;qZl_8C9B&quot;&gt;当然我们客户在这种情况下也有基于API层面做适配，将原有的未微服务化的和已微服务化的并存，使用这种类似于灰度方式，实际操作非常麻烦。&lt;/p&gt;&lt;p data-pid=&quot;olmWD_JA&quot;&gt;曾经有客户问过有没有不用费劲搞两套，是否可以直接有些大的单体微服务化，另外一些单体很长时间内完全不动，直到有时间或者认为安全想动它的时候去动。&lt;/p&gt;&lt;h2&gt;解决方案&lt;/h2&gt;&lt;p data-pid=&quot;CNY3Lph0&quot;&gt;对于客户实际碰到的4个典型的微服务框架的问题，我们推荐的解决方案都是服务网格。下面我们分别看下Istio如何解决上面的几个问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4f019812c7a389677676dceb60c9aab1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;603&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-4f019812c7a389677676dceb60c9aab1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;603&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-4f019812c7a389677676dceb60c9aab1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4f019812c7a389677676dceb60c9aab1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;cndRpxzl&quot;&gt;首先，多语言问题。基于服务网格，业务和治理的数据面无需运行在同一个进程里，也无需一起编译，因此也没有语言和框架上的绑定。无论什么语言开发的服务，只要有一个对外可以被访问和管理的一定应用协议上的端口，都可以被网格进行管理。通过统一的网格控制面，下发统一的治理规则给统一的网格数据面执行，进行统一的治理动作，包括前面介绍到的灰度、流量、安全、可观察性等等。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ebd98685ce7efeb0e259961c9d4f79cd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-ebd98685ce7efeb0e259961c9d4f79cd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-ebd98685ce7efeb0e259961c9d4f79cd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ebd98685ce7efeb0e259961c9d4f79cd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;yE32rQWr&quot;&gt;关于Spring cloud服务在Kubernetes运行时，关于原有的服务注册和发现不及时的问题。根本原因是两套服务发现导致的不一致问题，那么解决办法也比较简单，统一服务发现即可。既然K8s已经在Pod调度的同时维护有服务和实例间的数据，那么就没有必要再单独搞一套名字服务的机制，还要费劲的进行服务注册，然后再发现。&lt;/p&gt;&lt;p data-pid=&quot;Uc4i1XCk&quot;&gt;比较之前Spring cloud注册发现那张图，注册中心没了，服务基于注册中心的服务注册和服务发现的动作也不需要了，Istio直接使用k8s的服务发现数据，但从架构上看也简洁很多。&lt;/p&gt;&lt;p data-pid=&quot;35THFZL1&quot;&gt;我们也总结过，大部分碰到这个问题的场景，都是将微服务框架从VM迁移到k8s时候碰到的，有点把容器当作之前的VM使用，只使用了k8s作为容器部署运行的平台，并没有用到k8s的service。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fc070e261413734c69f855c3b317083c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;608&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fc070e261413734c69f855c3b317083c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;608&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fc070e261413734c69f855c3b317083c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fc070e261413734c69f855c3b317083c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;RC2wRo6V&quot;&gt;对于SDK自身升级导致业务全部重新升级的问题，解决办法就是把服务治理的公共能力和业务解耦。在网格中，将治理能力下沉到基础设施后，业务的开发、部署、升级都和服务治理的基础设施解耦了。业务开发者专注自己的业务部分。只要没有修改业务代码，就无需重新编译和上线变更。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;LXVYLGBL&quot;&gt;当治理能力升级只需基础设施升级即可，基础设施的升级对用户业务完全没有影响。像华为云ASM这样大部分网格服务的服务提供商都能做到一键升级，用户完全感知不到这个过程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1dcdf756e8cb760f3d08820a2672e8e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;605&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-1dcdf756e8cb760f3d08820a2672e8e0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;605&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-1dcdf756e8cb760f3d08820a2672e8e0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-1dcdf756e8cb760f3d08820a2672e8e0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;lZLuoUf1&quot;&gt;关于渐进微服务化的问题，使用Isito服务网格可以非常完美的解决。Istio治理的是服务间的访问，只要一个服务被其他服务访问，就可以通过Istio来进行管理，不管是微服务还是单体。Istio接管了服务的流量后，单体和微服务都可以接收统一的规则进行统一的管理。&lt;/p&gt;&lt;p data-pid=&quot;oIkPNum4&quot;&gt;如图中，在微服务化的过程中，可以对某个单体应用svc1根据业务拆分优先进行微服务化，拆分成三个微服务svc11、svc12和svc13，svc1服务依赖的另外一个单体应用svc2不用做任何变更，在网格中运行起来就可以和另外三个微服务一样的被管理。同样在运行一段时间后，svc2服务可以根据自身的业务需要再进行微服务化。从而尽量避免一次大的重构带来的工作量和业务迁移的风险，真正做到马丁富勒倡导的渐进微服务化的实践。&lt;/p&gt;&lt;h2&gt;实践&lt;/h2&gt;&lt;p data-pid=&quot;aoUkgXO-&quot;&gt;以上是对实际工作中客户的几个典型问题的解决方案。在实践中，怎么把这些解决方案落地呢？下面基于实际客户案例总结，分享具体的实践。&lt;/p&gt;&lt;p data-pid=&quot;3V01oVyS&quot;&gt;我们的主要是思路是解耦和卸载。卸载原有SDK中非开发的功能，SDK只提供代码框架、应用协议等开发功能。涉及到微服务治理的内容都卸载到基础设施去做。&lt;/p&gt;&lt;p data-pid=&quot;ZpfcHF8t&quot;&gt;从图上可以看到开发人员接触到开发框架变薄了，开发人员的学习、使用和维护成本也相应的降低了。而基础设施变得厚重了，除了完成之前需要做的服务运行的基础能力外，还包括非侵入的服务治理能力。即将越来越多的之前认为是业务的能力提炼成通用能力，交给基础设施去做，交给云厂商去做，客户摆脱这些繁琐的非业务的事务，更多的时间和精力投入到业务的创新和开发上。在这种分工下，SDK才真的回归到开发框架的根本职能。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-712d8d29b693ac53146a070158a2cabc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-712d8d29b693ac53146a070158a2cabc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-712d8d29b693ac53146a070158a2cabc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-712d8d29b693ac53146a070158a2cabc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;sujmLmVK&quot;&gt;要使用网格的能力，前提是微服务出来的流量能走到网格的数据面来。主要的迁移工作在微服务的服务调用方。我们推荐3个步骤：&lt;/p&gt;&lt;p data-pid=&quot;Hj0dXTKg&quot;&gt;第一步：废弃原有的微服务注册中心，使用K8S的Service。&lt;/p&gt;&lt;p data-pid=&quot;BdXAmYxl&quot;&gt;第二步：短路SDK中服务发现和负载均衡等逻辑，直接使用k8s的服务名和端口访问目标服务；&lt;/p&gt;&lt;p data-pid=&quot;IJt7BGF7&quot;&gt;第三步：结合自身项目需要，逐步使用网格中的治理能力替换原有SDK中提供的对应功能，当然这步是可选的，如调用链埋点等原有功能使用满足要求，也可以作为应用自身功能保留。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c5494751a3ed3caab036a27120dd9f59_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c5494751a3ed3caab036a27120dd9f59_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c5494751a3ed3caab036a27120dd9f59_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c5494751a3ed3caab036a27120dd9f59_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;p6O1FyKu&quot;&gt;为了达成以上迁移，我们有两种方式，供不同的用户场景采用。&lt;/p&gt;&lt;p data-pid=&quot;nEb2nIj0&quot;&gt;一种是只修改配置的方式：Spring cloud本身除了支持基于Eureka的服务端的服务发现外，还可以给Ribbon配置静态服务实例地址。利用这种机制给对应微服务的后端实例地址中配置服务的Kubernetes服务名和端口。&lt;/p&gt;&lt;p data-pid=&quot;hyCWbp8e&quot;&gt;当Spring cloud框架中还是访问原有的服务端微服务名时，会将请求转发到k8s的服务和端口上。这样访问会被网格数据面拦截，从而走到网格数据面上来。服务发现负载均衡和各种流量规则都可以应用网格的能力。&lt;/p&gt;&lt;p data-pid=&quot;l7d4jItf&quot;&gt;这种方式其实是用最小的修改将SDK的访问链路和网格数据面的访问链路串接起来。在平台中使用时，可以借助流水线工具辅助，减少直接修改配置文件的工作量和操作错误。可以看到我这个实际项目中，只是修改了项目的application.yaml配置文件，其他代码都是0修改。当然对于基于annotation的方式的配置也是同样的语义修改即可。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-422e9d035f000daafcf2e2ff66a133fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-422e9d035f000daafcf2e2ff66a133fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-422e9d035f000daafcf2e2ff66a133fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-422e9d035f000daafcf2e2ff66a133fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;0O89ywD-&quot;&gt;前面一种方式对原有项目的修改比较少，但是Spring cloud的项目依赖都还在。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;21FI_sBV&quot;&gt;我们有些客户选择了另外一种更简单直接的方式，既然原有SDK中服务发现负载均衡包括各种服务治理能力都不需要了，干脆这些依赖也全部干掉。从最终的镜像大小看，整个项目的体量也得到了极大的瘦身。这种方式客户根据自己的实际使用方式，进行各种裁剪，最终大部分是把Spring cloud退化成Spring boot。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6694ec5f96ccca66c51aba0cc383adbe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;605&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-6694ec5f96ccca66c51aba0cc383adbe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;605&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-6694ec5f96ccca66c51aba0cc383adbe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-6694ec5f96ccca66c51aba0cc383adbe_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;iuoU9oxg&quot;&gt;迁移中还有另外一部分比较特殊，就是微服务外部访问的Gateway。&lt;/p&gt;&lt;p data-pid=&quot;c_SrxeJt&quot;&gt;Spring cloud 有两种功能类似的Gateway，Zuul和Spring cloud Gateway。基于Eureka的服务发现，将内部微服务映射成外部服务，并且在入口处提供安全、分流等能力。在切换到k8s和Istio上来时，和内部服务一样，将入口各个服务的服务发现迁移到k8s上来。&lt;/p&gt;&lt;p data-pid=&quot;fseVma2Q&quot;&gt;差别在于对于用户如果在Gateway上开发了很多私有的业务强相关的filter时，这时候Gateway其实是微服务的门面服务，为了业务延续性，方案上可以直接将其当成普通的微服务部署在网格中进行管理。&lt;/p&gt;&lt;p data-pid=&quot;sTW0_RfR&quot;&gt;但是大多数情况下我们推荐使用Istio的Ingress Gateway直接替换这个微服务网关，以非侵入的方式提供外部TLS终止、限流、流量切分等能力。&lt;/p&gt;&lt;p data-pid=&quot;rVRuAJKk&quot;&gt;经过以上的简单改造，各种不同语言、各种不同开发框架开发的服务，只要业务协议相通，彼此可以互相访问，访问协议可以被网格管理，就都可以通过Istio进行统一的管理。&lt;/p&gt;&lt;p data-pid=&quot;of-rpWQO&quot;&gt;控制面上可以配置统一的服务管理规则。数据面上，统一使用Envoy进行服务发现、负载均衡和其他流量、安全、可观察性等相关能力。数据面上的服务即可以运行在容器里，也可以运行在虚机上。并且可以运行在多个k8s集群中。&lt;/p&gt;&lt;p data-pid=&quot;bfAau_OP&quot;&gt;当然在迁移过程中间，我们也支持阶段性的保留原有微服务框架的注册中心，使Istio和其他的服务发现结合使用的中间状态，让网格中的服务可以访问到微服务注册中心的服务。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4ea3467be07de85e52f53f41da1d9e85_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;605&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-4ea3467be07de85e52f53f41da1d9e85_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;605&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-4ea3467be07de85e52f53f41da1d9e85_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4ea3467be07de85e52f53f41da1d9e85_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;9_VX9lPa&quot;&gt;这里是一个Spring cloud开发的服务运行在Istio服务网格上进行灰度发布的示例。上面的日志是服务调用方Sidecar的日志，可以看到网格将流量分发到不同的服务后端上。下面的截图是使用了华为云ASM服务的灰度功能，可以看到这个Spring cloud服务通过网格配置的分流策略，将30%的流量分发到灰度版本上。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3b4adfa35d9a914d6a13315cd4b1c575_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-3b4adfa35d9a914d6a13315cd4b1c575_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-3b4adfa35d9a914d6a13315cd4b1c575_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3b4adfa35d9a914d6a13315cd4b1c575_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;tnrHEC3H&quot;&gt;下面这个示例是Spring cloud开发的服务使用Istio的熔断功能。这个过程就是就是前面原理一节Hystrix的状态迁移图的实践，不同在于这个实现是基于Istio来实现的。基于服务网格不管这里的服务是什么语言或者框架开发的，都可以对访问进行熔断保护。&lt;/p&gt;&lt;p data-pid=&quot;lqqowbNm&quot;&gt;这里的效果截图是来自华为云应用服务网格ASM的应用拓扑，可以非常清新的看到服务级别、服务实例级别流量变化情况，服务和服务实例的健康状态，从而展示故障的Spring cloud实例被隔离的全过程。从拓扑图上可以看到有个实例异常满足熔断阈值，触发了熔断，网格数据面向这个故障实例上分发的流量逐渐减少，直到完全没有流量，即故障实例被隔离。通过这种熔断保护保障服务整体访问的成功率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-422d6fb7e9790702d02915c79a5c80fe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-422d6fb7e9790702d02915c79a5c80fe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-422d6fb7e9790702d02915c79a5c80fe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-422d6fb7e9790702d02915c79a5c80fe_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;wUnCw6Z5&quot;&gt;下面三个流量拓扑演示了故障恢复的过程。&lt;/p&gt;&lt;p data-pid=&quot;Jc73vx2H&quot;&gt;可以看到：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;Uq1P31QP&quot;&gt;初始状态这个故障实例被隔离中，没有流量；&lt;/li&gt;&lt;li data-pid=&quot;nxqqyYiv&quot;&gt;当实例自身正常后，网格数据面在将其隔离配置的间隔后，重新尝试给其分配流量，当满足阈值要求则该实例会被认为是正常实例，可以和其他两个实例一样接收请求。&lt;/li&gt;&lt;li data-pid=&quot;BtRKNZBH&quot;&gt;最终可以看到三个实例上均衡的处理请求。&lt;br/&gt;即实现了故障恢复。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;xRr4Njp_&quot;&gt;&lt;b&gt;最后，通过微服务、容器、k8s和Istio的关系图来总结今天的内容：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f521a1178b34d50f14ed17af2ab44d2c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f521a1178b34d50f14ed17af2ab44d2c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f521a1178b34d50f14ed17af2ab44d2c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f521a1178b34d50f14ed17af2ab44d2c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;RVSkoZJS&quot;&gt;1）微服务和容器都有轻量和敏捷的共同特点，容器是微服务非常适合的一个运行环境；&lt;/p&gt;&lt;p data-pid=&quot;Q7ypUGAJ&quot;&gt;2）在云原生场景下，在微服务场景下，容器从来都不是独立存在的，使用k8s来编排容器已经是一个事实标准；&lt;/p&gt;&lt;p data-pid=&quot;mTeXNwg4&quot;&gt;3）Istio和k8s在架构和应用场景上的紧密结合，一起提供了一个端到端的微服务运行和治理的平台。&lt;/p&gt;&lt;p data-pid=&quot;BKLXJar5&quot;&gt;4）也是我们推荐的方案，使用Istio进行微服务治理正在成为越来越多用户的技术选择。&lt;/p&gt;&lt;p data-pid=&quot;WSK3ru3r&quot;&gt;以上四个关系顺时针结合在一起为我们的解决方案构造一个完整的闭环。&lt;/p&gt;&lt;h2&gt;后记&lt;/h2&gt;&lt;p data-pid=&quot;DCZRDsnx&quot;&gt;自荐一个非常不错的 Java 教程类开源项目：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide&lt;/a&gt; ，目前这个项目在 Github 上收到了 125k+ 的 star。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-728fb636e52fe98ee24dd825f2149932_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1298&quot; data-rawheight=&quot;1206&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-728fb636e52fe98ee24dd825f2149932_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1298&quot; data-rawheight=&quot;1206&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-728fb636e52fe98ee24dd825f2149932_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-728fb636e52fe98ee24dd825f2149932_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;x3TMP6mg&quot;&gt;并且，这个项目还推出了一个 PDF 版本：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247486324%26idx%3D1%26sn%3De8b690ddaedabc486bd399310105aad3%26chksm%3Dcea244bff9d5cda9a627fa65235be09e7b089e92cf49c0eb0ceb35b39bbed86c1fab0125f5af%26token%3D1351080357%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;完结撒花！JavaGuide面试突击版来啦！&lt;/a&gt;。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0b7cfd4801ace2a4034102d62509ae46_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;679&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0b7cfd4801ace2a4034102d62509ae46_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;679&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0b7cfd4801ace2a4034102d62509ae46_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0b7cfd4801ace2a4034102d62509ae46_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>