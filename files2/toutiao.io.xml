<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>87ae6108a9b3dc95fc2ed6240a18d92c</guid>
<title>IoT 运维：如何部署一套高可用 K8S 集群</title>
<link>https://toutiao.io/k/pzgvequ</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h1&gt;环境&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://p9.toutiaoimg.com/img/tos-cn-i-qvj2lq49k0/1257baca960b490c907637752e93ab8d%7Etplv-tt-shrink:640:0.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;准备工作&lt;/h1&gt;

&lt;p&gt;配置ansible(deploy 主机执行)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ssh-keygen
# for i in 192.168.3.{21..28}; do  ssh-copy-id  -i ~/.ssh/id_rsa.pub $i; done

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[root@deploy ~]# cat /etc/ansible/hosts 
[etcd]
192.168.3.21
192.168.3.22
192.168.3.23
[k8s-master]
192.168.3.24
192.168.3.25
192.168.3.26
[k8s-worker]
192.168.3.27
192.168.3.28

[k8s:children]
k8s-master
k8s-worker

&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;优化主机配置&lt;/h1&gt;

&lt;p&gt;关闭防火墙和selinux&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ansible all -m shell -a &quot;systemctl stop firewalld &amp;amp;&amp;amp; systemctl disable firewalld&quot;
# ansible all -m shell -a &quot;sed -i &#x27;s/^SELINUX=.*/SELINUX=disabled/g&#x27; /etc/selinux/config&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改limit&lt;/p&gt;

&lt;p&gt;关闭交换分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# swapoff -a
# ansible  k8s  -m shell -a &quot;yes | cp /etc/fstab /etc/fstab_bak&quot;
# ansible  k8s  -m shell -a &quot;cat /etc/fstab_bak | grep -v swap &amp;gt; /etc/fstab&quot;
# ansible  k8s  -m shell -a &quot;echo vm.swappiness = 0 &amp;gt;&amp;gt; /etc/sysctl.d/k8s.conf&quot;
# ansible  k8s  -m shell -a &quot;sysctl -p /etc/sysctl.d/k8s.conf&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;配置ipvs&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# cat /root/ipvs.sh 
#!/bin/bash
yum -y install ipvsadm ipset
####创建ipvs脚本

cat &amp;gt; /etc/sysconfig/modules/ipvs.modules &amp;lt;&amp;lt; EOF
#!/bin/bash
modprobe -- ip_vs
modprobe -- ip_vs_rr
modprobe -- ip_vs_wrr
modprobe -- ip_vs_sh
modprobe -- nf_conntrack_ipv4
EOF

####执行脚本，验证配置

chmod 755 /etc/sysconfig/modules/ipvs.modules
bash /etc/sysconfig/modules/ipvs.modules
lsmod | grep -e ip_vs -e nf_conntrack_ipv4

#########################

# ansible k8s  -m script -a &quot;/root/ipvs.sh&quot;



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置网桥转发规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat sysctl.sh 
#!/bin/bash
cat &amp;gt; /etc/sysctl.d/k8s.conf &amp;lt;&amp;lt; EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
EOF

cat &amp;lt;&amp;lt;EOF | tee /etc/modules-load.d/crio.conf
overlay
br_netfilter
EOF
modprobe overlay
modprobe br_netfilter
sysctl --system

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# ansible k8s  -m script -a &quot;/root/sysctl.sh&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;配置etcd集群&lt;/h1&gt;

&lt;p&gt;生成证书(ansible 主机操作)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# curl -o /usr/bin/cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64
# curl -o /usr/bin/cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64
# curl -o /usr/bin/cfssl-certinfo https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64
# chmod +x /usr/bin/cfssl*

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 CA 配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# mkdir p ssl
# cd /root/ssl
# cat &amp;gt;ca-config.json &amp;lt;&amp;lt;EOF
{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;876000h&quot;
    },
    &quot;profiles&quot;: {
      &quot;etcd&quot;: {
        &quot;usages&quot;: [
            &quot;signing&quot;,
            &quot;key encipherment&quot;,
            &quot;server auth&quot;,
            &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;876000h&quot;
      }
    }
  }
}
EOF

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 CA 证书签名请求&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat &amp;gt;ca-csr.json &amp;lt;&amp;lt;EOF
{
  &quot;CN&quot;: &quot;etcd&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [
    {
      &quot;C&quot;: &quot;CN&quot;,
      &quot;ST&quot;: &quot;beijing&quot;,
      &quot;L&quot;: &quot;beijing&quot;,
      &quot;O&quot;: &quot;jdt&quot;,
      &quot;OU&quot;: &quot;iot&quot;
    }
  ]
}
EOF

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成 CA 证书和私钥&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cfssl gencert -initca ca-csr.json | cfssljson -bare ca

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建etcd的TLS认证证书&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat &amp;gt; etcd-csr.json &amp;lt;&amp;lt;EOF
{
  &quot;CN&quot;: &quot;etcd&quot;,
  &quot;hosts&quot;: [
    &quot;192.168.3.21&quot;, 
    &quot;192.168.3.22&quot;, 
    &quot;192.168.3.23&quot;,
    &quot;192.168.3.24&quot;,
    &quot;192.168.3.23&quot;,
    &quot;192.168.3.26&quot;,
    &quot;etcd1&quot;,
    &quot;etcd2&quot;,
    &quot;etcd3&quot;,
    &quot;master1&quot;,
    &quot;master2&quot;,
    &quot;master3&quot;
  ],
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [
    {
      &quot;C&quot;: &quot;CN&quot;,
      &quot;ST&quot;: &quot;beijing&quot;,
      &quot;L&quot;: &quot;beijing&quot;,
      &quot;O&quot;: &quot;jdt&quot;,
      &quot;OU&quot;: &quot;iot&quot;
    }
  ]
EOF

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成 etcd证书和私钥并分发&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=etcd etcd-csr.json | cfssljson -bare etcd
# ansible  etcd -m copy -a &quot;src=/root/ssl/ dest=/export/Data/certs/&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ETCD安装以及配置&lt;/p&gt;

&lt;p&gt;创建数据目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ansible etcd -m shell -a &quot;mkdir -p /export/Data/etcd_data&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载etcd并分发&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# wget https://github.com/etcd-io/etcd/releases/download/v3.5.1/etcd-v3.5.1-linux-amd64.tar.gz
# tar xf etcd-v3.5.1-linux-amd64.tar.gz  &amp;amp;&amp;amp; cd etcd-v3.5.1-linux-amd64
# ansible etcd -m copy -a &quot;src=etcd  dest=/usr/bin/&quot;
# ansible etcd -m copy -a &quot;src=etcdutl  dest=/usr/bin/&quot;
# ansible etcd -m copy -a &quot;src=etcdctl  dest=/usr/bin/&quot;
# ansible etcd -m shell -a &quot;chmod +x /usr/bin/etcd*&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置etcd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat etcd_config.sh 
#!/bin/bash

#PEER_NAME指定本节点的主机名称/域名，
#PRIVATE_IP指定本节点的IP(用于后面配置文件的生成)
#ETCD_CLUSTER群集列表，是所有节点信息（内容格式: 各节点名称=https://ip:端口  名称任意但要有标识性）
#ETCD_INITIAL_CLUSTER_TOKEN为该etcd集群Token,同一集群token一致
interface_name=`cat /proc/net/dev | sed -n &#x27;3,$p&#x27; | awk -F &#x27;:&#x27; {&#x27;print $1&#x27;} | grep  -E &quot;^ &quot; | grep -v lo | head -n1`
ipaddr=`ip a | grep $interface_name  | awk &#x27;{print $2}&#x27; | awk -F&quot;/&quot;  &#x27;{print $1}&#x27; | awk -F&#x27;:&#x27; &#x27;{print $NF}&#x27;`
export PEER_NAME=`hostname`
export PRIVATE_IP=`echo $ipaddr | tr -d &#x27;\r&#x27;`
export ETCD_CLUSTER=&quot;etcd1=https://192.168.3.21:2380,etcd2=https://192.168.3.22:2380,etcd3=https://192.168.3.23:2380&quot;
export ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster-1&quot;


cat &amp;gt; /etc/systemd/system/etcd.service  &amp;lt;&amp;lt;EOF
[Unit]
Description=etcd
Documentation=https://github.com/coreos/etcd
Conflicts=etcd.service

[Service]
Type=notify
Restart=always
RestartSec=5s
LimitNOFILE=65536
TimeoutStartSec=0

ExecStart=/usr/bin/etcd --name ${PEER_NAME} \
    --data-dir /export/Data/etcd_data\
    --listen-client-urls https://${PRIVATE_IP}:2379 \
    --advertise-client-urls https://${PRIVATE_IP}:2379 \
    --listen-peer-urls https://${PRIVATE_IP}:2380 \
    --initial-advertise-peer-urls https://${PRIVATE_IP}:2380 \
    --cert-file=/export/Data/certs/etcd.pem \
    --key-file=/export/Data/certs/etcd-key.pem \
    --client-cert-auth \
    --trusted-ca-file=/export/Data/certs/ca.pem \
    --peer-cert-file=/export/Data/certs/etcd.pem \
    --peer-key-file=/export/Data/certs/etcd-key.pem \
    --peer-client-cert-auth \
    --peer-trusted-ca-file=/export/Data/certs/ca.pem \
    --initial-cluster ${ETCD_CLUSTER} \
    --initial-cluster-token etcd-cluster-1 \
    --initial-cluster-state new

[Install]
WantedBy=multi-user.target

EOF

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# ansible etcd   -m script -a &quot;/root/etcd_config.sh&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动ETCD&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ansible etcd -m shell -a &quot;systemctl daemon-reload&quot;
# ansible etcd -m service -a &#x27;name=etcd  state=started&#x27;
# ansible etcd -m shell -a &quot;systemctl enable  etcd&quot; 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;校验ETCD&lt;/p&gt;

&lt;p&gt;注： ansible节点执行，需安装 etcdctl&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat check_etcd.sh 
#!/bin/bash

HOST1=192.168.3.21
HOST2=192.168.3.22
HOST3=192.168.3.23
ENDPOINTS=$HOST1:2379,$HOST2:2379,$HOST3:2379
#因为开启了证书验证，因此执行命令需加上证书
KEY=&quot;--cacert=/root/ssl/ca.pem \
--cert=/root/ssl/etcd.pem \
--key=/root/ssl/etcd-key.pem&quot;


#etcd集群健康信息
etcdctl --endpoints=$ENDPOINTS $KEY endpoint health

#etcd集群状态信息
etcdctl --endpoints=$ENDPOINTS $KEY --write-out=table endpoint status

#etcd集群成员信息
etcdctl --endpoints=$ENDPOINTS $KEY member list -w table

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# sh check_etcd.sh 
192.168.3.22:2379 is healthy: successfully committed proposal: took = 6.670434ms
192.168.3.23:2379 is healthy: successfully committed proposal: took = 7.021894ms
192.168.3.21:2379 is healthy: successfully committed proposal: took = 6.938656ms
+-------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
|     ENDPOINT      |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |
+-------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
| 192.168.3.21:2379 | a30c90f91c6bc0bf |   3.5.1 |   20 kB |     false |      false |         2 |         23 |                 23 |        |
| 192.168.3.22:2379 | 877407b6419f0fed |   3.5.1 |   20 kB |      true |      false |         2 |         23 |                 23 |        |
| 192.168.3.23:2379 | 75b3a36457698e9a |   3.5.1 |   37 kB |     false |      false |         2 |         23 |                 23 |        |
+-------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
+------------------+---------+-------+---------------------------+---------------------------+------------+
|        ID        | STATUS  | NAME  |        PEER ADDRS         |       CLIENT ADDRS        | IS LEARNER |
+------------------+---------+-------+---------------------------+---------------------------+------------+
| 75b3a36457698e9a | started | etcd3 | https://192.168.3.23:2380 | https://192.168.3.23:2379 |      false |
| 877407b6419f0fed | started | etcd2 | https://192.168.3.22:2380 | https://192.168.3.22:2379 |      false |
| a30c90f91c6bc0bf | started | etcd1 | https://192.168.3.21:2380 | https://192.168.3.21:2379 |      false |
+------------------+---------+-------+---------------------------+---------------------------+------------+


&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;安装配置 CRI-O&lt;/h1&gt;

&lt;p&gt;安装CRI-O&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat get_cri-o.sh 
#!/bin/bash
VERSION=1.22
sudo curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable.repo https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/CentOS_7/devel:kubic:libcontainers:stable.repo
sudo curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable:cri-o:${VERSION}.repo https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:${VERSION}/CentOS_7/devel:kubic:libcontainers:stable:cri-o:${VERSION}.repo

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# ansible k8s -m  yum -a &quot;name=cri-o,cri-tools state=latest&quot;
# ansible k8s -m  shell  -a &quot;sudo systemctl enable --now crio&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改cri-o 存储路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ansible k8s -m shell -a &quot;sed -i -e  &#x27;s?^graphroot =.*?graphroot = &quot;/export/Data/containers/storage&quot;?g&#x27; /etc/containers/storage.conf&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置cgroup&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat 02-cgroup-manager.conf 
[crio.runtime]
conmon_cgroup = &quot;pod&quot;
cgroup_manager = &quot;systemd&quot;

# ansible k8s -m copy -a &quot;src=02-cgroup-manager.conf   dest=/etc/crio/crio.conf.d/&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置镜像加速&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat images_mirr.sh 
#!/bin/bash
cat &amp;gt;&amp;gt; /etc/containers/registries.conf &amp;lt;&amp;lt; EOF
[[registry]]
prefix = &quot;docker.io&quot;
location = &quot;hub-mirror.c.163.com&quot;

[[registry.mirror]]
prefix = &quot;docker.io&quot;
location = &quot;hub-mirror.c.163.com&quot;
EOF

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# ansible k8s  -m script -a &quot;/root/images_mirr.sh&quot;
# ansible k8s  -m service -a &#x27;name=crio  state=restarted&#x27;

&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;配置LB&lt;/h1&gt;

&lt;p&gt;公有云使用负载均衡代替&lt;/p&gt;

&lt;p&gt;高可用LB后续更新，暂用nginx代替&lt;/p&gt;

&lt;p&gt;以下操作LB节点执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@lb ~]# yum -y install epel-release.noarch
[root@lb ~]# yum -y install nginx nginx-mod-stream

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nginx 配置文件中加入以下配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stream {
  log_format  main  &#x27;$remote_addr [$time_local]&#x27;
                    &#x27;$protocol $status $bytes_sent $bytes_received&#x27;
                    &#x27;$session_time&#x27;;
  server {
    listen 16443;
    proxy_pass kubeapi;
    access_log  /var/log/nginx/access.log  main;
  }
  upstream kubeapi {
    server 192.168.3.24:6443;
    server 192.168.3.25:6443;
    server 192.168.3.26:6443;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;部署k8s&lt;/h1&gt;

&lt;p&gt;安装kubeadm、kubelet&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat kube.sh 
#!/bin/bash
cat &amp;lt;&amp;lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
exclude=kubelet kubeadm kubectl
EOF
yum install   -y kubelet-1.22.3-0  kubeadm-1.22.3-0  kubectl-1.22.3-0 --disableexcludes=kubernetes

sudo systemctl enable --now kubelet


# ansible k8s  -m script -a &quot;/root/kube.sh&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分发etcd证书&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ansible k8s -m shell -a &quot;mkdir -p /export/Data/certs/&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置kubelet&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat  kubelet_conf.sh
#!/bin/bash

cat &amp;gt; /etc/sysconfig/kubelet &amp;lt;&amp;lt;EOF
KUBELET_EXTRA_ARGS=--container-runtime=remote --cgroup-driver=systemd --container-runtime-endpoint=&#x27;unix:///var/run/crio/crio.sock&#x27; --runtime-request-timeout=5m
EOF

# ansible k8s  -m script -a &quot;/root/kubelet_conf.sh&quot;
# ansible k8s  -m service -a &#x27;name=kubelet  state=restarted&#x27;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始第一个master节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat kubeadm_config.yaml 
apiVersion: kubeadm.k8s.io/v1beta2
kind: ClusterConfiguration
kubernetesVersion: v1.22.3
imageRepository: registry.aliyuncs.com/google_containers
controlPlaneEndpoint: &quot;192.168.3.29:16443&quot;
networking:
  serviceSubnet: &quot;10.96.0.0/16&quot;
  podSubnet: &quot;172.16.0.0/16&quot;
  dnsDomain: &quot;cluster.local&quot;
dns:
  type: &quot;CoreDNS&quot;
etcd:
  external:
     endpoints:
     - https://192.168.3.21:2379
     - https://192.168.3.22:2379
     - https://192.168.3.23:2379
     caFile: /export/Data/certs/ca.pem
     certFile: /export/Data/certs/etcd.pem
     keyFile: /export/Data/certs/etcd-key.pem
---
apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
cgroupDriver: systemd

---
apiVersion: kubeproxy.config.k8s.io/v1alpha1
kind: KubeProxyConfiguration
mode: ipvs

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# ansible 192.168.3.24 -m copy -a &quot;src=kubeadm_config.yaml dest=/root&quot;
# ansible  k8s  -m copy -a &quot;src=/root/ssl/ dest=/export/Data/certs/&quot;
#  ansible 192.168.3.24 -m shell  -a &quot;kubeadm init    --config=/root/kubeadm_config.yaml   --upload-certs&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化第二个master节点&lt;/p&gt;

&lt;p&gt;注: 密钥上步获得&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ansible 192.168.3.25 -m shell  -a &quot;kubeadm join 192.168.3.29:16443 --token de4x51.d923b7l0tbi0692t --discovery-token-ca-cert-hash sha256:b1a8f00caed912ac083d10d8ecd1e92ddf6870c768f91d4e43c91c2614e24e1a --control-plane --certificate-key 0b34ca2ebd85f99ff66b2f57b80708e2ac0368880da52a802e3feb01852f2d81&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化第三个master节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ansible 192.168.3.26 -m shell  -a &quot;kubeadm join 192.168.3.29:16443 --token de4x51.d923b7l0tbi0692t --discovery-token-ca-cert-hash sha256:b1a8f00caed912ac083d10d8ecd1e92ddf6870c768f91d4e43c91c2614e24e1a --control-plane --certificate-key 0b34ca2ebd85f99ff66b2f57b80708e2ac0368880da52a802e3feb01852f2d81&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化worker节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ansible  k8s-worker  -m shell -a &quot; kubeadm join 192.168.3.29:16443 --token de4x51.d923b7l0tbi0692t --discovery-token-ca-cert-hash sha256:b1a8f00caed912ac083d10d8ecd1e92ddf6870c768f91d4e43c91c2614e24e1a&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化kubectl&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# mkdir -p $HOME/.kube
# scp root@192.168.3.24:/etc/kubernetes/admin.conf $HOME/.kube/config
# scp root@192.168.3.24:/usr/bin/kubectl  /usr/bin/kubectl

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证kubelet&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@deploy ~]# kubectl  get node
NAME      STATUS   ROLES                  AGE     VERSION
master1   Ready    control-plane,master   41m     v1.22.3
master2   Ready    control-plane,master   13m     v1.22.3
master3   Ready    control-plane,master   12m     v1.22.3
worker1   Ready    &amp;lt;none&amp;gt;                 9m18s   v1.22.3
worker2   Ready    &amp;lt;none&amp;gt;                 9m19s   v1.22.3

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;部署网络模型&lt;/p&gt;

&lt;p&gt;修改配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
# Source: calico/templates/calico-etcd-secrets.yaml
# The following contains k8s Secrets for use with a TLS enabled etcd cluster.
# For information on populating Secrets, see http://kubernetes.io/docs/user-guide/secrets/
apiVersion: v1
kind: Secret
type: Opaque
metadata:
  name: calico-etcd-secrets
  namespace: kube-system
data:
  # Populate the following with etcd TLS configuration if desired, but leave blank if
  # not using TLS for etcd.
  # The keys below should be uncommented and the values populated with the base64
  # encoded contents of each file that would be associated with the TLS data.
  # Example command for encoding a file contents: cat &amp;lt;file&amp;gt; | base64 -w 0
  etcd-key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcEFJQkFBS0NBUUVBNkZJNE91OUl4WU01L2IxUVBHa2RWQUF0UHc1QzA1b0MwN1Z0WGhWaWZDUzYwWitsCjV3aFRBRGRITVpvajhzdXB3dGU2a3IyUnpOYjluM2xGb2lqb0MxMjV4LzUvd2xZcWYyOWt1WTJrQzd4RlBwUFgKdHhwUmlUMEVFV09vTGVyQ202Y3RmMVhjR1RxTHBsZXorVTBCSGNRY0FoUnc3NFFHK1ByU3pDbzV5UDhGWTFHSQo0UWhHWkxyWnZXT0JJZGcyWjFGOHpvSVdVVE1QdWxrQ0Z6WHNDeENFVXY1TXFybjZsN0RZcWJ5K2drZG5qb2U3CklhQXp0UW5CZFVOMmEvdHdXSVE4S3YvSU15TTduT0plL29POG5rdDY4d2h6V1Ftc3p2VkdpSDI1SWhwUUxub3UKcmp1TEhBRERCaS9RM1JuWXdVZWZYTGVOZ1FoTmJYZXE0eGVuT1FJREFRQUJBb0lCQVFETVNjaHlZb211VFFlSQpqWmxwbGRFWlZaSnorVGxnVXZTYmI5VTlQemE4RFp4TnlzSWJGMkhOTmM2ZjJuZ3ovMDFITFdZOXRQN3BqaisxCnBQRkxlQWNjUDQyblJLN1psK1dFNjlJNXJFaU5uVCtTbUhTKzZTQzd1bkRDVGN6TW03d0hIWW5QaUJPa0I2eFgKV0pYRTZpYktJdkd5RG9HRXpLZEk5MTYzODRXZXJKejJneEhDMEZzUGcxOEJPV0NjMmM3SkN5UmdhOXl6Sk90UQpISWw5N0svNStNRXZpSFI0emhqV3hiTXNyVW55MllMQ1hPeW9reTBzVzN0U2RLbmZBUUs2RkJueWxFN3VVQnNXCm1XK2o3Kzl6ZUJGUVdRMlBGS1J4Q1o4amtYSSt1a1NhVzBoTER6b0d6OHBweno5UWNHMWVCOURqTFE5UHFCZDYKbTFkcnovU0JBb0dCQVBqY2x3TlEvOVFFUWhMc1Q3Nkw1OFpZQnBkQ2RUZTFMbG1vVWVIeDQveStJYlYwSkQ2eQpvRmpFbGEzZm1UOHA3THJGMXFQZjlNWmsrUmtRa3VjOGcyQUlyUXp0cmtrUnQxWmVSWHBhMHIzMU53emlEdTU3ClpLNnVWamM4S0NKYlV6S3NNcGZUajdRemFLelZNSFI3aWgxdzZOUWYxS0JNdG94Q3Rtc2MrdjBwQW9HQkFPNzgKSytxd3BJbWpCd2dXZm01NitSKzFzWXkrclZOMk1kZU9QdmRFTzRyQzlHSGlWT1VaaEM0WXlNRnJNOEh4TFd5RQo0eVpsMVpvNXZYVG5ha0JFUWxHU2E4L1NnMkZkY0tJdnNyTG9RUnBMTEhWMHo4b1E0Q2JWTW1GZkgwMDBMK1dICnBYYXNYaWlBdkcrdmxxOGk2Z1U2OGRnOFc2akFUeTZTTUNQTDBZdVJBb0dBU2h4L1NIaU54MWtCU0Z0aG9EQlAKOU14d0lnbWptTlIzR2pJN09GdHQ5dTIwWWpKVlBPcTdQOVJEY3dWY3dPZStYUnpmdit2SkhIQWprcWhSNTFVcApGcWRleWJQYXJGMy9TRlJJd3BoYm5FQnpoWDJvenJLbW1ETEk4Q2dWRjY0MHg2bHFZN2FZWENUWExtbEt4ZFdvCm12M3VDSVgyTDBySkxsb0xzemh0TW9rQ2dZQjJOdUw2YW5wWll2MDljUE1GYjJyLzFuNkhJbUxXWUNiemUzZUcKRklobmNWdzFkeUdMV2YzYVY0UW11UUtYTXRmSFVFeVVWOWM3UE1pTXBWUVhpaXhMOFdQSEgxakJ0dGphUVVIaAo0YVVpZm9EMWNOekFGV3pyaUpZdE9FSmhqQ2tOSHZZb0o4ZER2YnA0ZktESzdUaFpjZmpqZjZmUFo2RkRaaWpOCjdDb3hJUUtCZ1FDWTRWTDM5cG5KZVFQMFhYc1dHVnhVN2Z5Szh0YVFJVnk4Y0tXeVBGdXNaYklXSVM0eU5ENW8KWFI5cHZGYjdkbmQzMnJXaFNKeWZJVm9ZQWhMTXpyd2dBdnF5Q1J4MXdEU2NqdnRFbCs5ZUF1SWIrUFNYZEQ2NgpRMnFyWEttMjNlem0yVkpUL2MxWHlOb2FDYVExb1BPK1BBTDMxZkxiUklLdUZrUEMzVTRZSFE9PQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=
  etcd-cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVLRENDQXhDZ0F3SUJBZ0lVWkRmczR0UGR0dVJGZEZGRHM0MHBRcWp0VUNjd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1hERUxNQWtHQTFVRUJoTUNRMDR4RURBT0JnTlZCQWdUQjJKbGFXcHBibWN4RURBT0JnTlZCQWNUQjJKbAphV3BwYm1jeEREQUtCZ05WQkFvVEEycGtkREVNTUFvR0ExVUVDeE1EYVc5ME1RMHdDd1lEVlFRREV3UmxkR05rCk1DQVhEVEl4TVRFeE56RXhOVGd3TUZvWUR6SXhNakV4TURJME1URTFPREF3V2pCY01Rc3dDUVlEVlFRR0V3SkQKVGpFUU1BNEdBMVVFQ0JNSFltVnBhbWx1WnpFUU1BNEdBMVVFQnhNSFltVnBhbWx1WnpFTU1Bb0dBMVVFQ2hNRAphbVIwTVF3d0NnWURWUVFMRXdOcGIzUXhEVEFMQmdOVkJBTVRCR1YwWTJRd2dnRWlNQTBHQ1NxR1NJYjNEUUVCCkFRVUFBNElCRHdBd2dnRUtBb0lCQVFEb1VqZzY3MGpGZ3puOXZWQThhUjFVQUMwL0RrTFRtZ0xUdFcxZUZXSjgKSkxyUm42WG5DRk1BTjBjeG1pUHl5Nm5DMTdxU3ZaSE0xdjJmZVVXaUtPZ0xYYm5IL24vQ1ZpcC9iMlM1amFRTAp2RVUrazllM0dsR0pQUVFSWTZndDZzS2JweTEvVmR3Wk9vdW1WN1A1VFFFZHhCd0NGSER2aEFiNCt0TE1Lam5JCi93VmpVWWpoQ0Vaa3V0bTlZNEVoMkRablVYek9naFpSTXcrNldRSVhOZXdMRUlSUy9reXF1ZnFYc05pcHZMNkMKUjJlT2g3c2hvRE8xQ2NGMVEzWnIrM0JZaER3cS84Z3pJenVjNGw3K2c3eWVTM3J6Q0hOWkNhek85VWFJZmJraQpHbEF1ZWk2dU80c2NBTU1HTDlEZEdkakJSNTljdDQyQkNFMXRkNnJqRjZjNUFnTUJBQUdqZ2Q4d2dkd3dEZ1lEClZSMFBBUUgvQkFRREFnV2dNQjBHQTFVZEpRUVdNQlFHQ0NzR0FRVUZCd01CQmdnckJnRUZCUWNEQWpBTUJnTlYKSFJNQkFmOEVBakFBTUIwR0ExVWREZ1FXQkJUSGNlT1BOZm50WnUxR3hZMEtzcmttQmsyQVpUQWZCZ05WSFNNRQpHREFXZ0JUS0JxL29EV3p0TE5HSDNzcnVvY0IrckI1akp6QmRCZ05WSFJFRVZqQlVnZ1ZsZEdOa01ZSUZaWFJqClpES0NCV1YwWTJRemdnZHRZWE4wWlhJeGdnZHRZWE4wWlhJeWdnZHRZWE4wWlhJemh3VEFxQU1WaHdUQXFBTVcKaHdUQXFBTVhod1RBcUFNWWh3VEFxQU1YaHdUQXFBTWFNQTBHQ1NxR1NJYjNEUUVCQ3dVQUE0SUJBUUEvSU9NbgpIMkZYWmVqYU1DNHhlTjdVRmVoaTNGQndjbGNXcUtLU3J2VHhYT1RsMjZOVzhRd2h1SGc3RHNrQkN3UEhXL0s3ClJqdllRNHlEbVB0Q0JHbDE0K3hnMmxYcnhuY0Zzd1N0dFoxcDV1UjNWVFFlNlFDS3ZsNGMyWXNHQzZEU3d2dE4KK041SVFkVVhvalhJTVhkWXVzZS90Qk42b2xjMkdvVFJQV0lCU2FHODhBejd4em5VNThiZXZzN28vU1ZtS2pxZgpTVVA2U3FZeHlPaUtDNWs5cC9qOU42MnN0ZmJURmRxN1JYQ2p0OVl6Q3QwNWg4QW1wLzNmdStYZkhCQTRjYjN1ClJUNTdjZVlXdkIzSEtMMFFFNWNOUjRLNWlXa01LUi94YnNzZlNxSWFPTVF6Q29sWjF3dFZPendaNGZsZUkrVUUKYTFpQUF4K1IxNkNCeG4xZgotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg== 
  etcd-ca: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURyRENDQXBTZ0F3SUJBZ0lVTGpLRjE2cDVteXhiWkZFRWNUMi9sSDhGTVdrd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1hERUxNQWtHQTFVRUJoTUNRMDR4RURBT0JnTlZCQWdUQjJKbGFXcHBibWN4RURBT0JnTlZCQWNUQjJKbAphV3BwYm1jeEREQUtCZ05WQkFvVEEycGtkREVNTUFvR0ExVUVDeE1EYVc5ME1RMHdDd1lEVlFRREV3UmxkR05rCk1CNFhEVEl4TVRFeE56RXhOVEl3TUZvWERUSTJNVEV4TmpFeE5USXdNRm93WERFTE1Ba0dBMVVFQmhNQ1EwNHgKRURBT0JnTlZCQWdUQjJKbGFXcHBibWN4RURBT0JnTlZCQWNUQjJKbGFXcHBibWN4RERBS0JnTlZCQW9UQTJwawpkREVNTUFvR0ExVUVDeE1EYVc5ME1RMHdDd1lEVlFRREV3UmxkR05rTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGCkFBT0NBUThBTUlJQkNnS0NBUUVBeXE2Zm4ycWtlVzJOS3RqREJiMmg5Q1lzZWpBWnIwTmlOWGRPZy8rL3FRNk8KbUNMR1pLU3picUlVY05NRUQvSk5tbWF4UGlPUVNLYmFBUlZscWFKS1ZMVXUxMmo2S1NPUi9KR1hOcnF5ZjM4RQpvREE0R29jdHdtWkI3Rzdrdk1PdXFRWXRMKzQxR0hJYmZsaHFXci9zQ2hEM1E3VlJyaWVMYW9CVFpFMFpEUWVDCis5KzNLcDNqYmEyeWZUNU85K3F4WlFya0xBeE5GR21KUVBzT2ZhTnJjU1p6YTVBc0sybE9MNXAveExGRm0yQU8KanVVSE8yMnBKL0NjMDBPanNveUFnVE5jdVJmaDNuNjdXbllyYVV1RXVhU0RheEZBWlk4bGlhdXFHbndlV296VAp0Q3pVcEUrbW9RTzVqL0o0UksrNm94OTJlZWpLQm1hY3VTM1JNeTFPQVFJREFRQUJvMll3WkRBT0JnTlZIUThCCkFmOEVCQU1DQVFZd0VnWURWUjBUQVFIL0JBZ3dCZ0VCL3dJQkFqQWRCZ05WSFE0RUZnUVV5Z2F2NkExczdTelIKaDk3SzdxSEFmcXdlWXljd0h3WURWUjBqQkJnd0ZvQVV5Z2F2NkExczdTelJoOTdLN3FIQWZxd2VZeWN3RFFZSgpLb1pJaHZjTkFRRUxCUUFEZ2dFQkFEQ1huN3h0VnFjT2ptTUcvUFpHYWp5UEdVTlFsKzNwaFhnYm1vZmtQMFNoCkJlVTZXbTNkOHB4WThrR0xTT2gxSzl1MlA3RnUyTzY3M21pMkdSOEJPT3NLWS9UK0p0RmlmenlmY3VGMjQ4L3QKcFFjRkNUOGw1Wjc1bXcySTRORXZJU1pnU3piWVN0SXdPU01FcFBJZWRRNzY2QUxtVGVwZXNuVll3K2U2dGlBUgpmS0lqakJEeGcrd1B4b2tseWNxWXRCQVA5dDRKMVk4Vkt6VENNelorcllweWRNNWlIaElFK3VYTlhqSXJTMURMCmxNN3JSS2crblRnRk9ma2dPQ3FaTmlZMTFzdzNWQnJUOW4rM1BhTzB2ekZqbXcrUVNxTVpTclJUS1d1V2xaSkcKT2JiUXUvcGhKdk9hZ2NBbUVXRGorNUdaZTVwS29neXlIdUVSVW0wSzYwST0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo= 
---
# Source: calico/templates/calico-config.yaml
# This ConfigMap is used to configure a self-hosted Calico installation.
kind: ConfigMap
apiVersion: v1
metadata:
  name: calico-config
  namespace: kube-system
data:
  # Configure this with the location of your etcd cluster.
  etcd_endpoints: &quot;https://192.168.3.21:2379,https://192.168.3.22:2379,https://192.168.3.23:2379&quot;
  # If you&#x27;re using TLS enabled etcd uncomment the following.
  # You must also populate the Secret below with these files.
  etcd_ca: &quot;/calico-secrets/etcd-ca&quot;   # &quot;/calico-secrets/etcd-ca&quot;
  etcd_cert: &quot;/calico-secrets/etcd-cert&quot; # &quot;/calico-secrets/etcd-cert&quot;
  etcd_key: &quot;/calico-secrets/etcd-key&quot;  # &quot;/calico-secrets/etcd-key&quot;
  # Typha is disabled.
  typha_service_name: &quot;none&quot;
  # Configure the backend to use.
  calico_backend: &quot;vxlan&quot;

  # Configure the MTU to use for workload interfaces and tunnels.
  # By default, MTU is auto-detected, and explicitly setting this field should not be required.
  # You can override auto-detection by providing a non-zero value.
  veth_mtu: &quot;0&quot;

  # The CNI network configuration to install on each node. The special
  # values in this config will be automatically populated.
  cni_network_config: |-
    {
      &quot;name&quot;: &quot;k8s-pod-network&quot;,
      &quot;cniVersion&quot;: &quot;0.3.1&quot;,
      &quot;plugins&quot;: [
        {
          &quot;type&quot;: &quot;calico&quot;,
          &quot;log_level&quot;: &quot;info&quot;,
          &quot;log_file_path&quot;: &quot;/var/log/calico/cni/cni.log&quot;,
          &quot;etcd_endpoints&quot;: &quot;__ETCD_ENDPOINTS__&quot;,
          &quot;etcd_key_file&quot;: &quot;__ETCD_KEY_FILE__&quot;,
          &quot;etcd_cert_file&quot;: &quot;__ETCD_CERT_FILE__&quot;,
          &quot;etcd_ca_cert_file&quot;: &quot;__ETCD_CA_CERT_FILE__&quot;,
          &quot;mtu&quot;: __CNI_MTU__,
          &quot;ipam&quot;: {
              &quot;type&quot;: &quot;calico-ipam&quot;
          },
          &quot;policy&quot;: {
              &quot;type&quot;: &quot;k8s&quot;
          },
          &quot;kubernetes&quot;: {
              &quot;kubeconfig&quot;: &quot;__KUBECONFIG_FILEPATH__&quot;
          }
        },
        {
          &quot;type&quot;: &quot;portmap&quot;,
          &quot;snat&quot;: true,
          &quot;capabilities&quot;: {&quot;portMappings&quot;: true}
        },
        {
          &quot;type&quot;: &quot;bandwidth&quot;,
          &quot;capabilities&quot;: {&quot;bandwidth&quot;: true}
        }
      ]
    }

---
# Source: calico/templates/calico-kube-controllers-rbac.yaml

# Include a clusterrole for the kube-controllers component,
# and bind it to the calico-kube-controllers serviceaccount.
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: calico-kube-controllers
rules:
  # Pods are monitored for changing labels.
  # The node controller monitors Kubernetes nodes.
  # Namespace and serviceaccount labels are used for policy.
  - apiGroups: [&quot;&quot;]
    resources:
      - pods
      - nodes
      - namespaces
      - serviceaccounts
    verbs:
      - watch
      - list
      - get
  # Watch for changes to Kubernetes NetworkPolicies.
  - apiGroups: [&quot;networking.k8s.io&quot;]
    resources:
      - networkpolicies
    verbs:
      - watch
      - list
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: calico-kube-controllers
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: calico-kube-controllers
subjects:
- kind: ServiceAccount
  name: calico-kube-controllers
  namespace: kube-system
---

---
# Source: calico/templates/calico-node-rbac.yaml
# Include a clusterrole for the calico-node DaemonSet,
# and bind it to the calico-node serviceaccount.
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: calico-node
rules:
  # The CNI plugin needs to get pods, nodes, and namespaces.
  - apiGroups: [&quot;&quot;]
    resources:
      - pods
      - nodes
      - namespaces
    verbs:
      - get
  # EndpointSlices are used for Service-based network policy rule
  # enforcement.
  - apiGroups: [&quot;discovery.k8s.io&quot;]
    resources:
      - endpointslices
    verbs:
      - watch 
      - list
  - apiGroups: [&quot;&quot;]
    resources:
      - endpoints
      - services
    verbs:
      # Used to discover service IPs for advertisement.
      - watch
      - list
  # Pod CIDR auto-detection on kubeadm needs access to config maps.
  - apiGroups: [&quot;&quot;]
    resources:
      - configmaps
    verbs:
      - get
  - apiGroups: [&quot;&quot;]
    resources:
      - nodes/status
    verbs:
      # Needed for clearing NodeNetworkUnavailable flag.
      - patch

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: calico-node
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: calico-node
subjects:
- kind: ServiceAccount
  name: calico-node
  namespace: kube-system

---
# Source: calico/templates/calico-node.yaml
# This manifest installs the calico-node container, as well
# as the CNI plugins and network config on
# each master and worker node in a Kubernetes cluster.
kind: DaemonSet
apiVersion: apps/v1
metadata:
  name: calico-node
  namespace: kube-system
  labels:
    k8s-app: calico-node
spec:
  selector:
    matchLabels:
      k8s-app: calico-node
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
  template:
    metadata:
      labels:
        k8s-app: calico-node
    spec:
      nodeSelector:
        kubernetes.io/os: linux
      hostNetwork: true
      tolerations:
        # Make sure calico-node gets scheduled on all nodes.
        - effect: NoSchedule
          operator: Exists
        # Mark the pod as a critical add-on for rescheduling.
        - key: CriticalAddonsOnly
          operator: Exists
        - effect: NoExecute
          operator: Exists
      serviceAccountName: calico-node
      # Minimize downtime during a rolling upgrade or deletion; tell Kubernetes to do a &quot;force
      # deletion&quot;: https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods.
      terminationGracePeriodSeconds: 0
      priorityClassName: system-node-critical
      initContainers:
        # This container installs the CNI binaries
        # and CNI network config file on each node.
        - name: install-cni
          image: docker.mirrors.ustc.edu.cn/calico/cni:v3.21.0
          command: [&quot;/opt/cni/bin/install&quot;]
          envFrom:
          - configMapRef:
              # Allow KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT to be overridden for eBPF mode.
              name: kubernetes-services-endpoint
              optional: true
          env:
            # Name of the CNI config file to create.
            - name: CNI_CONF_NAME
              value: &quot;10-calico.conflist&quot;
            # The CNI network config to install on each node.
            - name: CNI_NETWORK_CONFIG
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: cni_network_config
            # The location of the etcd cluster.
            - name: ETCD_ENDPOINTS
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: etcd_endpoints
            # CNI MTU Config variable
            - name: CNI_MTU
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: veth_mtu
            # Prevents the container from sleeping forever.
            - name: SLEEP
              value: &quot;false&quot;
          volumeMounts:
            - mountPath: /host/opt/cni/bin
              name: cni-bin-dir
            - mountPath: /host/etc/cni/net.d
              name: cni-net-dir
            - mountPath: /calico-secrets
              name: etcd-certs
          securityContext:
            privileged: true
        # Adds a Flex Volume Driver that creates a per-pod Unix Domain Socket to allow Dikastes
        # to communicate with Felix over the Policy Sync API.
        - name: flexvol-driver
          image: docker.mirrors.ustc.edu.cn/calico/pod2daemon-flexvol:v3.21.0
          volumeMounts:
          - name: flexvol-driver-host
            mountPath: /host/driver
          securityContext:
            privileged: true
      containers:
        # Runs calico-node container on each Kubernetes node. This
        # container programs network policy and routes on each
        # host.
        - name: calico-node
          image: docker.mirrors.ustc.edu.cn/calico/node:v3.21.0
          envFrom:
          - configMapRef:
              # Allow KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT to be overridden for eBPF mode.
              name: kubernetes-services-endpoint
              optional: true
          env:
            # The location of the etcd cluster.
            - name: ETCD_ENDPOINTS
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: etcd_endpoints
            # Location of the CA certificate for etcd.
            - name: ETCD_CA_CERT_FILE
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: etcd_ca
            # Location of the client key for etcd.
            - name: ETCD_KEY_FILE
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: etcd_key
            # Location of the client certificate for etcd.
            - name: ETCD_CERT_FILE
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: etcd_cert
            # Set noderef for node controller.
            - name: CALICO_K8S_NODE_REF
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
            # Choose the backend to use.
            - name: CALICO_NETWORKING_BACKEND
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: calico_backend
            # Cluster type to identify the deployment type
            - name: CLUSTER_TYPE
              value: &quot;k8s,bgp&quot;
            # Auto-detect the BGP IP address.
            - name: IP
              value: &quot;autodetect&quot;
            # Enable IPIP
            - name: CALICO_IPV4POOL_IPIP
              value: &quot;Never&quot;
            # Enable or Disable VXLAN on the default IP pool.
            - name: CALICO_IPV4POOL_VXLAN
              value: &quot;Always&quot;
            # Set MTU for tunnel device used if ipip is enabled
            - name: FELIX_IPINIPMTU
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: veth_mtu
            # Set MTU for the VXLAN tunnel device.
            - name: FELIX_VXLANMTU
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: veth_mtu
            # Set MTU for the Wireguard tunnel device.
            - name: FELIX_WIREGUARDMTU
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: veth_mtu
            # The default IPv4 pool to create on startup if none exists. Pod IPs will be
            # chosen from this range. Changing this value after installation will have
            # no effect. This should fall within `--cluster-cidr`.
            - name: CALICO_IPV4POOL_CIDR
              value: &quot;172.16.0.0/16&quot;
            # Disable file logging so `kubectl logs` works.
            - name: CALICO_DISABLE_FILE_LOGGING
              value: &quot;true&quot;
            # Set Felix endpoint to host default action to ACCEPT.
            - name: FELIX_DEFAULTENDPOINTTOHOSTACTION
              value: &quot;ACCEPT&quot;
            # Disable IPv6 on Kubernetes.
            - name: FELIX_IPV6SUPPORT
              value: &quot;false&quot;
            - name: FELIX_HEALTHENABLED
              value: &quot;true&quot;
          securityContext:
            privileged: true
          resources:
            requests:
              cpu: 250m
          lifecycle:
            preStop:
              exec:
                command:
                - /bin/calico-node
                - -shutdown
          livenessProbe:
            exec:
              command:
              - /bin/calico-node
              - -felix-live
              #- -bird-live
            periodSeconds: 10
            initialDelaySeconds: 10
            failureThreshold: 6
            timeoutSeconds: 10
          readinessProbe:
            exec:
              command:
              - /bin/calico-node
              - -felix-ready
              #- -bird-ready
            periodSeconds: 10
            timeoutSeconds: 10
          volumeMounts:
            # For maintaining CNI plugin API credentials.
            - mountPath: /host/etc/cni/net.d
              name: cni-net-dir
              readOnly: false
            - mountPath: /lib/modules
              name: lib-modules
              readOnly: true
            - mountPath: /run/xtables.lock
              name: xtables-lock
              readOnly: false
            - mountPath: /var/run/calico
              name: var-run-calico
              readOnly: false
            - mountPath: /var/lib/calico
              name: var-lib-calico
              readOnly: false
            - mountPath: /calico-secrets
              name: etcd-certs
            - name: policysync
              mountPath: /var/run/nodeagent
            # For eBPF mode, we need to be able to mount the BPF filesystem at /sys/fs/bpf so we mount in the
            # parent directory.
            - name: sysfs
              mountPath: /sys/fs/
              # Bidirectional means that, if we mount the BPF filesystem at /sys/fs/bpf it will propagate to the host.
              # If the host is known to mount that filesystem already then Bidirectional can be omitted.
              mountPropagation: Bidirectional
            - name: cni-log-dir
              mountPath: /var/log/calico/cni
              readOnly: true
      volumes:
        # Used by calico-node.
        - name: lib-modules
          hostPath:
            path: /lib/modules
        - name: var-run-calico
          hostPath:
            path: /var/run/calico
        - name: var-lib-calico
          hostPath:
            path: /var/lib/calico
        - name: xtables-lock
          hostPath:
            path: /run/xtables.lock
            type: FileOrCreate
        - name: sysfs
          hostPath:
            path: /sys/fs/
            type: DirectoryOrCreate
        # Used to install CNI.
        - name: cni-bin-dir
          hostPath:
            path: /opt/cni/bin
        - name: cni-net-dir
          hostPath:
            path: /etc/cni/net.d
        # Used to access CNI logs.
        - name: cni-log-dir
          hostPath:
            path: /var/log/calico/cni
        # Mount in the etcd TLS secrets with mode 400.
        # See https://kubernetes.io/docs/concepts/configuration/secret/
        - name: etcd-certs
          secret:
            secretName: calico-etcd-secrets
            defaultMode: 0400
        # Used to create per-pod Unix Domain Sockets
        - name: policysync
          hostPath:
            type: DirectoryOrCreate
            path: /var/run/nodeagent
        # Used to install Flex Volume Driver
        - name: flexvol-driver-host
          hostPath:
            type: DirectoryOrCreate
            path: /usr/libexec/kubernetes/kubelet-plugins/volume/exec/nodeagent~uds
---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: calico-node
  namespace: kube-system

---
# Source: calico/templates/calico-kube-controllers.yaml
# See https://github.com/projectcalico/kube-controllers
apiVersion: apps/v1
kind: Deployment
metadata:
  name: calico-kube-controllers
  namespace: kube-system
  labels:
    k8s-app: calico-kube-controllers
spec:
  # The controllers can only have a single active instance.
  replicas: 1
  selector:
    matchLabels:
      k8s-app: calico-kube-controllers
  strategy:
    type: Recreate
  template:
    metadata:
      name: calico-kube-controllers
      namespace: kube-system
      labels:
        k8s-app: calico-kube-controllers
    spec:
      nodeSelector:
        kubernetes.io/os: linux
      tolerations:
        # Mark the pod as a critical add-on for rescheduling.
        - key: CriticalAddonsOnly
          operator: Exists
        - key: node-role.kubernetes.io/master
          effect: NoSchedule
      serviceAccountName: calico-kube-controllers
      priorityClassName: system-cluster-critical
      # The controllers must run in the host network namespace so that
      # it isn&#x27;t governed by policy that would prevent it from working.
      hostNetwork: true
      containers:
        - name: calico-kube-controllers
          image: docker.mirrors.ustc.edu.cn/calico/kube-controllers:v3.21.0
          env:
            # The location of the etcd cluster.
            - name: ETCD_ENDPOINTS
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: etcd_endpoints
            # Location of the CA certificate for etcd.
            - name: ETCD_CA_CERT_FILE
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: etcd_ca
            # Location of the client key for etcd.
            - name: ETCD_KEY_FILE
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: etcd_key
            # Location of the client certificate for etcd.
            - name: ETCD_CERT_FILE
              valueFrom:
                configMapKeyRef:
                  name: calico-config
                  key: etcd_cert
            # Choose which controllers to run.
            - name: ENABLED_CONTROLLERS
              value: policy,namespace,serviceaccount,workloadendpoint,node
          volumeMounts:
            # Mount in the etcd TLS secrets.
            - mountPath: /calico-secrets
              name: etcd-certs
          livenessProbe:
            exec:
              command:
              - /usr/bin/check-status
              - -l
            periodSeconds: 10
            initialDelaySeconds: 10
            failureThreshold: 6
            timeoutSeconds: 10
          readinessProbe:
            exec:
              command:
              - /usr/bin/check-status
              - -r
            periodSeconds: 10
      volumes:
        # Mount in the etcd TLS secrets with mode 400.
        # See https://kubernetes.io/docs/concepts/configuration/secret/
        - name: etcd-certs
          secret:
            secretName: calico-etcd-secrets
            defaultMode: 0440

---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: calico-kube-controllers
  namespace: kube-system

---

# This manifest creates a Pod Disruption Budget for Controller to allow K8s Cluster Autoscaler to evict

apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: calico-kube-controllers
  namespace: kube-system
  labels:
    k8s-app: calico-kube-controllers
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      k8s-app: calico-kube-controllers

---
# Source: calico/templates/calico-typha.yaml

---
# Source: calico/templates/configure-canal.yaml

---
# Source: calico/templates/kdd-crds.yaml

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装calico&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# kubectl  apply -f calico-etcd.yaml

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证集群&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@deploy ~]# kubectl  get  pod -n kube-system
NAME                                      READY   STATUS    RESTARTS   AGE
calico-kube-controllers-9767fc4b9-tk9fb   1/1     Running   0          6m56s
calico-node-5mc9h                         1/1     Running   0          6m56s
calico-node-dswmp                         1/1     Running   0          6m56s
calico-node-qht2s                         1/1     Running   0          6m56s
calico-node-sdrcg                         1/1     Running   0          6m56s
calico-node-x58lj                         1/1     Running   0          6m56s
coredns-7f6cbbb7b8-fc8rd                  1/1     Running   0          61m
coredns-7f6cbbb7b8-qvw2m                  1/1     Running   0          61m
kube-apiserver-master1                    1/1     Running   2          94m
kube-apiserver-master2                    1/1     Running   0          66m
kube-apiserver-master3                    1/1     Running   0          64m
kube-controller-manager-master1           1/1     Running   2          94m
kube-controller-manager-master2           1/1     Running   0          66m
kube-controller-manager-master3           1/1     Running   0          64m
kube-proxy-bscfn                          1/1     Running   0          62m
kube-proxy-f2fpb                          1/1     Running   0          64m
kube-proxy-kt7nl                          1/1     Running   0          66m
kube-proxy-lzww8                          1/1     Running   0          62m
kube-proxy-zn6gj                          1/1     Running   2          94m
kube-scheduler-master1                    1/1     Running   2          94m
kube-scheduler-master2                    1/1     Running   0          66m
kube-scheduler-master3                    1/1     Running   0          64m


&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;问题与解决&lt;/h1&gt;

&lt;p&gt;1 、 kubelet日报错 failed to get cgroup stats for &quot;&lt;br/&gt;
/system.slice/kubelet.service&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;11月 18 09:00:42 master1 kubelet[2424]: E1118 09:00:42.948672    2424 summary_sys_containers.go:47] &quot;Failed to get system container stats&quot; err=&quot;failed to get cgroup stats for \&quot;/system.slice/kubelet.service\&quot;: failed to get container info for \&quot;/system.slice/kubelet.service\&quot;: unknown container \&quot;/system.slice/kubelet.service\&quot;&quot; containerName=&quot;/system.slice/kubelet.service&quot;
11月 18 09:00:52 master1 kubelet[2424]: E1118 09:00:52.956142    2424 summary_sys_containers.go:47] &quot;Failed to get system container stats&quot; err=&quot;failed to get cgroup stats for \&quot;/system.slice/kubelet.service\&quot;: failed to get container info for \&quot;/system.slice/kubelet.service\&quot;: unknown container \&quot;/system.slice/kubelet.service\&quot;&quot; containerName=&quot;/system.slice/kubelet.service&quot;
11月 18 09:01:02 master1 kubelet[2424]: E1118 09:01:02.961022    2424 summary_sys_containers.go:47] &quot;Failed to get system container stats&quot; err=&quot;failed to get cgroup stats for \&quot;/system.slice/kubelet.service\&quot;: failed to get container info for \&quot;/system.slice/kubelet.service\&quot;: unknown container \&quot;/system.slice/kubelet.service\&quot;&quot; containerName=&quot;/system.slice/kubelet.service&quot;
11月 18 09:01:12 master1 kubelet[2424]: E1118 09:01:12.966033    2424 summary_sys_containers.go:47] &quot;Failed to get system container stats&quot; err=&quot;failed to get cgroup stats for \&quot;/system.slice/kubelet.service\&quot;: failed to get container info for \&quot;/system.slice/kubelet.service\&quot;: unknown container \&quot;/system.slice/kubelet.service\&quot;&quot; containerName=&quot;/system.slice/kubelet.service&quot;
11月 18 09:01:22 master1 kubelet[2424]: E1118 09:01:22.970644    2424 summary_sys_containers.go:47] &quot;Failed to get system container stats&quot; err=&quot;failed to get cgroup stats for \&quot;/system.slice/kubelet.service\&quot;: failed to get container info for \&quot;/system.slice/kubelet.service\&quot;: unknown container \&quot;/system.slice/kubelet.service\&quot;&quot; containerName=&quot;/system.slice/kubelet.service&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方案&lt;/p&gt;

&lt;p&gt;配置文件中写入 CPUAccounting=true 与 MemoryAccounting=true&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@master2 ~]# cat /lib/systemd/system/kubelet.service.d/10-kubeadm.conf 
# Note: This dropin only works with kubeadm and kubelet v1.11+
[Service]
CPUAccounting=true
MemoryAccounting=true
Environment=&quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf&quot;
Environment=&quot;KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml&quot;
# This is a file that &quot;kubeadm init&quot; and &quot;kubeadm join&quot; generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically
EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env
# This is a file that the user can use for overrides of the kubelet args as a last resort. Preferably, the user should use
# the .NodeRegistration.KubeletExtraArgs object in the configuration files instead. KUBELET_EXTRA_ARGS should be sourced from this file.
EnvironmentFile=-/etc/sysconfig/kubelet
ExecStart=
ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、kubectl get cs 提示 dial tcp 127.0.0.1:10251: connect: connection refused&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@deploy ~]# kubectl  get cs
Warning: v1 ComponentStatus is deprecated in v1.19+
NAME                 STATUS      MESSAGE                                                                                       ERROR
scheduler            Unhealthy   Get &quot;http://127.0.0.1:10251/healthz&quot;: dial tcp 127.0.0.1:10251: connect: connection refused   
etcd-1               Healthy     {&quot;health&quot;:&quot;true&quot;,&quot;reason&quot;:&quot;&quot;}                                                                 
controller-manager   Healthy     ok                                                                                            
etcd-0               Healthy     {&quot;health&quot;:&quot;true&quot;,&quot;reason&quot;:&quot;&quot;}                                                                 
etcd-2               Healthy     {&quot;health&quot;:&quot;true&quot;,&quot;reason&quot;:&quot;&quot;} 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方案&lt;/p&gt;

&lt;p&gt;注释 port=0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@master1 ~]# cat /etc/kubernetes/manifests/kube-scheduler.yaml 
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    component: kube-scheduler
    tier: control-plane
  name: kube-scheduler
  namespace: kube-system
spec:
  containers:
  - command:
    - kube-scheduler
    - --authentication-kubeconfig=/etc/kubernetes/scheduler.conf
    - --authorization-kubeconfig=/etc/kubernetes/scheduler.conf
    - --bind-address=127.0.0.1
    - --kubeconfig=/etc/kubernetes/scheduler.conf
    - --leader-elect=true
#    - --port=0
    image: registry.aliyuncs.com/google_containers/kube-scheduler:v1.22.3
    imagePullPolicy: IfNotPresent

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[root@deploy ~]# kubectl  get cs
Warning: v1 ComponentStatus is deprecated in v1.19+
NAME                 STATUS    MESSAGE                         ERROR
scheduler            Healthy   ok                              
controller-manager   Healthy   ok                              
etcd-1               Healthy   {&quot;health&quot;:&quot;true&quot;,&quot;reason&quot;:&quot;&quot;}   
etcd-2               Healthy   {&quot;health&quot;:&quot;true&quot;,&quot;reason&quot;:&quot;&quot;}   
etcd-0               Healthy   {&quot;health&quot;:&quot;true&quot;,&quot;reason&quot;:&quot;&quot;}   

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作者：宗庄凯&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b325cbb447990cb49ee2c2854c65b95a</guid>
<title>每个 C++ 工程师都要了解的十个性能陷阱</title>
<link>https://toutiao.io/k/s1p9biy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：jinshang，腾讯 WXG 后台开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果你让每个 C++工程师列出他们喜欢 C++的原因，那“掌控力”绝对是排在前几的特性。与 go、java 等垃圾回收语言的大道至简、python 等解释语言的小快灵不同，C++最大的魅力就是给予工程师对代码完全的掌控，每个 C++程序员仿佛都是人形编译器，不止要看懂代码表面的逻辑，甚至要知道每行代码对应的汇编指令。优化代码也成了 C++工程师日常必备活动，正所谓“一杯茶，一包烟，一段代码，优化一天”。在经历过无数个性能优化的日日夜夜后，笔者也总结了几个中过招的性能陷阱，与诸位分享。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍的性能陷阱主要分为两大类：“&lt;strong&gt;有成本抽象&lt;/strong&gt;”和“&lt;strong&gt;与编译器作对&lt;/strong&gt;”。前者是指在使用 C++的功能/库时需要注意的隐形成本，后者则是一些 C++新手可能会写出不利于编译器优化的代码。另外本文的顺序是由基础到进阶，读者可以根据目录直接跳到自己想看的部分。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;有成本抽象&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++“信徒”们常常鼓吹 C++的“零成本抽象（Zero Cost Abstraction）”。然而对于“零成本抽象”这个概念存在很多误解。比如有的新手会认为：“使用 C++的任何特性都没有成本”。那显然是大错特错的，比如使用模版就会导致编译时间变慢的编译期成本，而且我花了 21 天时间精通 C++的时间成本也是成本啊（狗头）。有些经验的 C++程序员会解释为”使用 C++的任何特性都没有&lt;strong&gt;运行时&lt;/strong&gt;成本“，这也是对 C++最常见的误解。C++的创始人 Bjarne Stroustrup 是这样解释“零成本抽象“的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;你不会为任何你没有使用的特性付出任何成本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于你使用的特性，你只会付出最小运行时成本。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，就是 C++不会背着你偷偷干坏事（比如垃圾回收），而你指定 C++干的活，C++会尽量在编译期做，保证在运行期只会做“最少”的工作。连小学生都应该知道，“最少”并不等于“零”，所以“零成本抽象”其实是一种谎言，Google 的 C++负责人 Chandler Carruth 就曾经在 CppCon 2019 说过：C++根本不存在”零成本抽象“。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，C++的很多特性是有性能成本的，而且，这些成本往往出现在你“没有写”的代码里，即 C++帮你添加的隐形代码。作为 C++工程师，我们就必须了解每个特性会带来的性能损耗，在做代码设计时尽量选择损耗小的特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而下文介绍的很多坑点，C++语言服务器 clangd 可以帮你实时检测出来并自动修复。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;（一）虚函数&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老生常谈的性能损耗，这里只介绍一下虚函数调用带来的成本：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;会多一次寻址操作，去虚函数表查询函数的地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可能会破坏 cpu 流水线，因为虚函数调用是一次间接调用，需要进行分支预测。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻碍了编译器内联，大部分情况下，虚函数是无法被内联的（与前两条相比，无法内联才是虚函数性能损耗的主要来源）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而在实际生产环境中，可能很多的运行时多态是无法避免的，毕竟这是 OOP 的基础特性，因此对于虚函数我们也只能了解背后的成本而已。某些情况下我们可以使用编译期多态来替代虚函数，比如 CRTP(Curiously Recurring Template Pattern)、Tempated Visitor Pattern、Policy Based Design 等等，我的下一篇文章《C++独有的设计模式》中会介绍这些技巧，敬请期待。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;（二）隐形的拷贝&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也是一个老生常谈的性能损耗，这里主要介绍几个容易被疏忽的场景：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Member Initialization 构造函数&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;C&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  C(A a, B b): a_(a), b_(b){}&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  A a_;&lt;br/&gt;  B b_;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  A a;&lt;br/&gt;  B b;&lt;br/&gt;  &lt;span&gt;C &lt;span&gt;c&lt;/span&gt;&lt;span&gt;(a, b)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 A、B 是非平凡的类，会各被复制两次，在传入构造函数时一次，在构造时一次。C 的构造函数应当改为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  C(A a, B b): a_(&lt;span&gt;std&lt;/span&gt;::move(a)), b_(&lt;span&gt;std&lt;/span&gt;::move(b)){}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种写法是 clang-tidy 推荐的https://clang.llvm.org/extra/clang-tidy/checks/modernize/pass-by-value.html#pass-by-value-in-constructors ，相比传 const 引用进来，如果外面也是传右值，则完全没有拷贝。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;For 循环&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;gt; vec;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; s: vec){&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里每个 string 会被复制一次，改为&lt;code&gt;for(const std::string&amp;amp; s: vec)&lt;/code&gt;即可.&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Lambda 捕获&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;A a;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; f = [a]{};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lambda 函数在值捕获时会将被捕获的对象拷贝一次，可以根据需求考虑使用引用捕获&lt;code&gt;auto f = [&amp;amp;a]{};&lt;/code&gt;或者用 std::move 捕获初始化&lt;code&gt;auto f = [a = std::move(a)]{};&lt;/code&gt;（仅限 C++14 以后）。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;隐式类型转换&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;unordered_map&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;gt; &lt;span&gt;map&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::pair&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;amp; p: &lt;span&gt;map&lt;/span&gt;){&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个很容易被忽视的坑点，这段代码用了 const 引用，但是因为类型错了，所以还是会发生拷贝，因为 unordered_map element 的类型是&lt;code&gt;std::pair&amp;lt;const int, std::string&amp;gt;&lt;/code&gt;，所以在遍历时，推荐使用 const auto&amp;amp;，对于 map 类型，也可以使用结构化绑定。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;（三）隐形的析构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 C++代码中，我们几乎不会主动去调用类的析构函数，都是靠实例离开作用域后自动析构。而“隐形”的析构调用，也会导致我们的程序运行变慢：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;复杂类型的析构&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的业务代码中有这样一种接口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;Process&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Req&amp;amp; req, Resp* resp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Context ctx = BuildContext(req); &lt;span&gt;// 非常复杂的类型&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; ret = Compute(ctx, req, resp); &lt;span&gt;// 主要的业务逻辑&lt;/span&gt;&lt;br/&gt;  PrintTime();&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ret;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;Api&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Req&amp;amp; req, Resp* resp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; ret = Process(req, resp);&lt;br/&gt;  PrintTime();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日志中，Process 函数内打印的时间和 PrintTime 打印的时间竟然差了 20 毫秒，而我们当时接口的总耗时也不过几十毫秒，我当时百思不得其解，还是靠我老板 tomtang 一语道破先机，原来是析构 Context 足足花了 20ms。后面我们实现了 Context 的&lt;strong&gt;池化&lt;/strong&gt;，直接将接口耗时降了 20%。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;平凡析构类型&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何定义类的析构函数也大有讲究，看下下面这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; j;&lt;br/&gt;  ~A() {};&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;A &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; A{&lt;span&gt;41&lt;/span&gt;, &lt;span&gt;42&lt;/span&gt;};&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;get&lt;/code&gt;函数对应的汇编代码是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;get():                                # @get()&lt;br/&gt;        movq    %rdi, %rax&lt;br/&gt;        movabsq $&lt;span&gt;180388626473&lt;/span&gt;, %rcx             &lt;span&gt;# imm = 0x2A00000029&lt;/span&gt;&lt;br/&gt;        movq    %rcx, (%rdi)&lt;br/&gt;        retq&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而如果我能把析构函数改一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; j;&lt;br/&gt;  ~A() = &lt;span&gt;default&lt;/span&gt;; &lt;span&gt;// 注意这里&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;A &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; A{&lt;span&gt;41&lt;/span&gt;, &lt;span&gt;42&lt;/span&gt;};&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的汇编代码则变成了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;get():                                # @get()&lt;br/&gt;        movabsq $&lt;span&gt;180388626473&lt;/span&gt;, %rax             &lt;span&gt;# imm = 0x2A00000029&lt;/span&gt;&lt;br/&gt;        retq&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前者多了两次赋值，也多用了两个寄存器，原因是前者给类定义了一个自定义的析构函数（虽然啥也不干），会导致类为不可平凡析构类型(&lt;code&gt;std::is_trivially_destructible&lt;/code&gt;)和不可平凡复制类型（&lt;code&gt;std::is_trivially_copyable&lt;/code&gt;），根据 C++的函数调用 ABI 规范，不能被直接放在返回的寄存器中（%rax），只能间接赋值。除此之外，不可平凡复制类型也不能作为编译器常量进行编译器运算。所以，如果你的类是平凡的（只有数值和数字，不涉及堆内存分配），千万不要随手加上析构函数！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于非平凡析构类型造成的性能损耗，后文还会多次提到。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;（四）滥用 std::shared_ptr&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++核心指南是这样推荐智能指针的用法的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用 &lt;code&gt;std::unique_ptr&lt;/code&gt;或 &lt;code&gt;std::shared_ptr&lt;/code&gt;表达资源的所有权。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不涉及所有权时，用裸指针。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽量使用&lt;code&gt;std::unique_ptr&lt;/code&gt;，只有当资源需要被共享所有权时，再用&lt;code&gt;std::shared_ptr&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在实际代码中，用&lt;code&gt;std::shared_ptr&lt;/code&gt;的场景大概就是以下几种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;小部分是因为代码作者是写 python 或者 java 来的，不会写没有 gc 的代码（比如 apache arrow 项目，所有数据全用&lt;code&gt;std::shared_ptr&lt;/code&gt;，像是被 apache 的 Java 环境给荼毒了）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;绝大部分是因为代码作者是会写 C++的，但是太懒了，不想梳理内存资源模型。不得不说，&lt;code&gt;std::shared_ptr&lt;/code&gt;确实是懒人的福音，既保证了资源的安全，又不用梳理资源的所有权模型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;很小一部分是因为确实需要使用&lt;code&gt;std::shared_ptr&lt;/code&gt;的场景（不到 10%）。我能想到的必须用 std::shared_ptr 的场景有：异步析构，缓存。除此之外想不出任何必须的场景，欢迎小伙伴们在评论区补充。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，&lt;code&gt;std::shared_ptr&lt;/code&gt;的构造、复制和析构都是非常重的操作，因为涉及到原子操作，&lt;code&gt;std::shared_ptr&lt;/code&gt;是要比裸指针和&lt;code&gt;std::unique_ptr&lt;/code&gt;慢 10%～ 20%的。即使用了&lt;code&gt;std::shared_ptr&lt;/code&gt;也要使用 std::move 和引用等等，尽量避免拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;还有个陷阱是一定要使用&lt;code&gt;std::make_shared&amp;lt;T&amp;gt;()&lt;/code&gt;而不是&lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;(new T)&lt;/code&gt;来构造，因为后者会分配两次内存，且原子计数和数据本身的内存是不挨着的，不利于 cpu 缓存。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;（五）类型擦除：std::function 和 std::any&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;std::function，顾名思义，可以封装任何可被调用的对象，包括常规函数、类的成员函数、有 operator()定义的类、lambda 函数等等，当我们需要存储函数时 std::function 非常好用，但是 std::function 是有成本的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;std::function 要占用 32 个字节，而函数指针只需要 8 个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;std::function 本质上是一个虚函数调用，因此虚函数的问题 std::function 都有，比如无法内联&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;std::function 可能涉及堆内存分配，比如 lambda 捕获了大量值时，用 std::function 封装会需要在堆上分配内存&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们只应在必须时才使用 std::function，比如需要存储一个不确定类型的函数。而在只需要多态调用的，完全可以用模版静态派发：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; Func&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Run&lt;/span&gt;&lt;span&gt;(Func&amp;amp;&amp;amp; f)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  f();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;std::any 同理，用类型擦除的机制可以存储任何类型，但是也不推荐使用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;（六）std::variant 和 std::optional&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在我的另一篇文章《C++17 在业务代码中最好用的十个特性 》大肆吹捧了一波 std::variant 和 std::optional，但是说实话，C++的实现还是有些性能开销的，这里以 std::optional 为例介绍：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;必须的多余内存开销：简单来说，std::optional&lt;t&gt;有两个成员变量，类型分别为 bool 和 T，由于内存对齐的原因，sizeof(std::optional&lt;t&gt;)会是 sizeof(T)+alignof(T)，对于简单的类型，sizeof(std::optional&lt;t&gt;)甚至会是 sizeof(T)的两倍。相比之下，rust 语言的 option 实现则有 null pointer optimization，即如果一个类的合法内存表示一定不会全部字节为零，比如 std::reference_wrapper，那就可以零开销地表示 std::optional&lt;t&gt;，而 C++由于需要兼容 C 的内存对齐，不可能实现这项优化&lt;/t&gt;&lt;/t&gt;&lt;/t&gt;&lt;/t&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;c++标准要求如果 T 是可平凡析构的（见上文析构的部分），std::optional&lt;t&gt;也必须是平凡析构的，但是 gcc 在 8.0.0 之前的实现是有 bug 的，所有 std::optional&lt;t&gt;都被设置为了非平凡类型，所以用 std::optional 作为工厂函数的返回值是由额外性能开销的。&lt;/t&gt;&lt;/t&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对 NRVO（返回值优化）不友好，见下文 NRVO 的部分。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;（七）std::async&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;std::async 是一个很好用的异步执行抽象，但是在使用的时候可能一不小心，你的代码就变成了同步调用：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不指定 policy&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;std::async 的接口是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt; class Function, class... Args &amp;gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;future&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;invoke_result_t&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;decay_t&lt;/span&gt;&amp;lt;Function&amp;gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;decay_t&lt;/span&gt;&amp;lt;Args&amp;gt;...&amp;gt;&amp;gt;&lt;br/&gt;    &lt;span&gt;async&lt;/span&gt;&lt;span&gt;( Function&amp;amp;&amp;amp; f, Args&amp;amp;&amp;amp;... args )&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt; class Function, class... Args &amp;gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;future&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;invoke_result_t&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;decay_t&lt;/span&gt;&amp;lt;Function&amp;gt;, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;decay_t&lt;/span&gt;&amp;lt;Args&amp;gt;...&amp;gt;&amp;gt;&lt;br/&gt;    &lt;span&gt;async&lt;/span&gt;&lt;span&gt;( &lt;span&gt;std&lt;/span&gt;::launch policy, Function&amp;amp;&amp;amp; f, Args&amp;amp;&amp;amp;... args )&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 std::launch 类型包括两种：&lt;a href=&quot;https://en.cppreference.com/w/cpp/thread/launch&quot; data-linktype=&quot;2&quot;&gt;std::launch::async&lt;/a&gt;异步执行和&lt;a href=&quot;https://en.cppreference.com/w/cpp/thread/launch&quot; data-linktype=&quot;2&quot;&gt;std::launch::deferred&lt;/a&gt;懒惰执行，如果你使用第一种接口不指定 policy，那么编译器可能会自己帮你选择懒惰执行，也就是在调用 future.get()的时候才同步执行。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不保存返回值&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 c++的 std::async 的一个大坑点，非常容易踩坑，比如这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;func1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;func2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::async(&lt;span&gt;std&lt;/span&gt;::launch::async, func1);&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::async(&lt;span&gt;std&lt;/span&gt;::launch::async, func2);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段代码里，func1 和 func2 其实是串行的！因为 std::async 会返回一个 std::future，而这个 std::future 在析构时，会同步等待函数返回结果才析构结束。这也是上文“隐形的析构”的另外一种表现。正确的代码应当长这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;auto&lt;/span&gt; future1 = &lt;span&gt;std&lt;/span&gt;::async(&lt;span&gt;std&lt;/span&gt;::launch::async, func1);&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; future2 = &lt;span&gt;std&lt;/span&gt;::async(&lt;span&gt;std&lt;/span&gt;::launch::async, func2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更奇葩的是，只有 std::async 返回的 std::future 在析构时会同步等待，std::packaged_task，std::promise 构造的 std::future 都不会同步等待，实在是让人无力吐槽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 std::async 等等 C++多线程工具，在我之后的文章《现代 C++并发编程指南》会介绍，敬请期待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;与编译器作对&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，现代编译器是非常强大的。毛主席曾经说过：要团结一切可以团结的力量。面对如此强大的编译器，我们应该争取做编译器的朋友，而不是与编译器为敌。做编译器的朋友，就是要充分利用编译器的优化。而很多优化是有条件的，因此我们要争取写出优化友好的代码，把剩下的工作交给编译器，而不是自己胡搞蛮搞。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;（八）返回值优化 NRVO（Named Return Value Optimization)&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个函数的返回值是当前函数内的一个局部变量，且该局部变量的类型和返回值一致时，编译器会将该变量直接在函数的返回值接收处构造，不会发生拷贝和移动，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Noisy&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  Noisy() { &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;constructed at &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;this&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;; }&lt;br/&gt;  Noisy(&lt;span&gt;const&lt;/span&gt; Noisy&amp;amp;) { &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;copy-constructed\n&quot;&lt;/span&gt;; }&lt;br/&gt;  Noisy(Noisy&amp;amp;&amp;amp;) { &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;move-constructed\n&quot;&lt;/span&gt;; }&lt;br/&gt;  ~Noisy() { &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;destructed at &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;this&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;; }&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;Noisy &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Noisy v = Noisy();&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; v;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;g&lt;/span&gt;&lt;span&gt;(Noisy arg)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&amp;amp;arg = &quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;arg &amp;lt;&amp;lt; &lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Noisy v = f();&lt;br/&gt;  g(f());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码中，函数 f()满足 NRVO 的条件，所以 Noisy 既不会拷贝，也不会 move，只会被构造和析构两次，程序的输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;constructed at &lt;span&gt;0x7fff880300ae&lt;/span&gt;&lt;br/&gt;constructed at &lt;span&gt;0x7fff880300af&lt;/span&gt;&lt;br/&gt;&amp;amp;arg = &lt;span&gt;0x7fff880300af&lt;/span&gt;&lt;br/&gt;destructed at &lt;span&gt;0x7fff880300af&lt;/span&gt;&lt;br/&gt;destructed at &lt;span&gt;0x7fff880300ae&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;滥用 std::move&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自从 C++11 加入 std::move 语义之后，有些“自以为是”的程序员会到处添加 move。在这些情况下，std::move 是根本没用的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;被 move 的对象是平凡类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;被 move 的对象是一个常量引用。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在某些情况下，move 反而会导致负优化，比如阻碍了 NRVO：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Noisy &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Noisy v = Noisy();&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::move(v);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是上面的代码，只不过返回值被改成 move 走，结果就多了两次 move 构造和两次析构，反而得不偿失：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;constructed at &lt;span&gt;0x7ffc54006cdf&lt;/span&gt;&lt;br/&gt;move-constructed&lt;br/&gt;destructed at &lt;span&gt;0x7ffc54006cdf&lt;/span&gt;&lt;br/&gt;constructed at &lt;span&gt;0x7ffc54006cdf&lt;/span&gt;&lt;br/&gt;move-constructed&lt;br/&gt;destructed at &lt;span&gt;0x7ffc54006cdf&lt;/span&gt;&lt;br/&gt;&amp;amp;arg = &lt;span&gt;0x7ffc54006d0f&lt;/span&gt;&lt;br/&gt;destructed at &lt;span&gt;0x7ffc54006d0f&lt;/span&gt;&lt;br/&gt;destructed at &lt;span&gt;0x7ffc54006d0e&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;工厂返回 std::optional&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的，使用 std::optional 也可能会阻碍 NRVO 优化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::optional&amp;lt;Noisy&amp;gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Noisy v = Noisy();&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; v;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为返回值类型不对应，因此应当改为&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::optional&amp;lt;Noisy&amp;gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::optional&amp;lt;Noisy&amp;gt; v;&lt;br/&gt;  v = Noisy();&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; v;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了性能牺牲了部分可读性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;（九）尾递归优化&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尾递归优化是函数式语言常用的一种优化，如果某个函数的最后一步操作是调用自身，那么编译器完全可以不用调用的指令(call)，而是用跳转(jmp)回当前函数的开头，省略了新开调用栈的开销。然而由于 C++的各种隐形操作，尾递归优化不是那么好实现。我曾经在知乎上看到这样一个问题：&lt;a href=&quot;https://www.zhihu.com/question/552352098&quot; data-linktype=&quot;2&quot;&gt;https://www.zhihu.com/question/552352098&lt;/a&gt;。题主的函数长这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;btd_tail&lt;/span&gt;&lt;span&gt;(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; input, &lt;span&gt;int&lt;/span&gt; v)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (input.empty()) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; v;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        v = v * &lt;span&gt;2&lt;/span&gt; + (input.front() - &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; btd_tail(input.substr(&lt;span&gt;1&lt;/span&gt;), v);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接 return 自身的调用，如果在函数式语言就是一个标准的尾递归，然而，实际执行的代码是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;btd_tail&lt;/span&gt;&lt;span&gt;(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; input, &lt;span&gt;int&lt;/span&gt; v)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (input.empty()) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; v;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        v = v * &lt;span&gt;2&lt;/span&gt; + (input.front() - &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;auto&lt;/span&gt; temp = btd_tail(input.substr(&lt;span&gt;1&lt;/span&gt;), v);&lt;br/&gt;        input.~&lt;span&gt;string&lt;/span&gt;(); &lt;span&gt;// 注意这里&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; temp;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于在 return 前 C++有隐形的析构操作，所以这段代码并不是尾递归。而需要析构的本质原因是 std::string 不是可平凡析构的对象，解决办法也很简单，换成 std::string_view 就好了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;btd_tail&lt;/span&gt;&lt;span&gt;(&lt;span&gt;std&lt;/span&gt;::string_view input, &lt;span&gt;int&lt;/span&gt; v)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (input.empty()) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; v;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        v = v * &lt;span&gt;2&lt;/span&gt; + (input.front() - &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; btd_tail(input.substr(&lt;span&gt;1&lt;/span&gt;), v);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;std::string_view 是可平凡析构的，所以编译器根本不需要调用析构函数，这也是上文推荐尽量选用可平凡析构对象的另一个理由。我的下一篇文章《C++函数式编程指南》会介绍 C++函数式编程，敬请期待。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;（十）自动向量化优化&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现代 CPU 大部分都支持一些向量化指令集如 SSE、AVX 等，向量化指的是 SIMD 操作，即一个指令，多条数据。在某些条件下，编译器会自动将循环优化为向量化操作：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;循环内部访问的是连续内存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环内部没有函数调用，没有 if 分支&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环之间没有依赖&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，下方的代码非常的向量化不友好：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Type { kAdd, kMul };&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; a + b; }&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;mul&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; a * b; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; a, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; b, Type t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;(a.size())&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; a.size(); ++i) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (t == kAdd) {&lt;br/&gt;      c[i] = add(a[i], b[i]);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      c[i] = mul(a[i], b[i]);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既有 if，又有函数调用，而如果我们通过模版 if 和内联函数，这两条都可以规避：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Type { kAdd, kMul };&lt;br/&gt;&lt;span&gt;inline&lt;/span&gt; __attribute__((always_inline)) &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; a + b; }&lt;br/&gt;&lt;span&gt;inline&lt;/span&gt; __attribute__((always_inline)) &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;mul&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; a * b; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;Type t&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; a, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;(a.size())&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; a.size(); ++i) {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;(t == kAdd)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      c[i] = add(a[i], b[i]);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      c[i] = mul(a[i], b[i]);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就变成了向量化友好的代码。我们团队正在基于 apache arrow 做一些向量化计算的工作，后续也会有文章分享关于向量化优化的详细介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAHqwz4MEkrgAAAAstQy6ubaLX4KHWvLEZgBPEqaMEGHVLK-SBzNPgMIt9NKcFvgpSUDpGaEL5K-ou&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiaDdmS6DcMDJq9Oarq0ibU3jGUnKMiaACdEJyv3zcBibzYYe1uL5LdQ5k4rwSkqdwSuJs15vqbjlzFBjBvpfLmyOqew&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdW21bibhOrQZBItu9VZ8iasj0kpS1FicdZ0C5miccrqjlN36AEvyJYQ4JXPp2OiboibHyMpk&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;程序员不止会写代码，还会这些&amp;#10;#1024程序员节&amp;#10;&quot; data-nonceid=&quot;10318897206917704755&quot; data-type=&quot;video&quot; data-authiconurl=&quot;https://dldir1v6.qq.com/weixin/checkresupdate/icons_filled_channels_authentication_enterprise_a2658032368245639e666fb11533a600.png&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;红包福利&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;点击回复：1024 即可抽奖红包封面&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasvpPfMrktl2xvC9A325p8Qa9dFeEzxZmZ2O1XuFGsVXyQhG9Dia8J8nTXVtzNcHozr0umH3R4iboXg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>04843ebbeac360adc8874bce943e7e98</guid>
<title>一步一图带你深入理解 Linux 虚拟内存管理</title>
<link>https://toutiao.io/k/d6580o6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写在本文开始之前....&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从本文开始我们就正式开启了 Linux 内核内存管理子系统源码解析系列，笔者还是会秉承之前系列文章的风格，采用一步一图的方式先是详细介绍相关原理，在保证大家清晰理解原理的基础上，我们再来一步一步的解析相关内核源码的实现。有了源码的辅证，这样大家看得也安心，理解起来也放心，最起码可以证明笔者没有胡编乱造骗大家，哈哈~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存管理子系统可谓是 Linux 内核众多子系统中最为复杂最为庞大的一个，其中包含了众多繁杂的概念和原理，通过内存管理这条主线我们把可以把操作系统的众多核心系统给拎出来，比如：进程管理子系统，网络子系统，文件子系统等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于内存管理子系统过于复杂庞大，其中涉及到的众多繁杂的概念又是一环套一环，层层递进。如何把这些繁杂的概念具有层次感地，并且清晰地，给大家梳理呈现出来真是一件比较有难度的事情，因此关于这个问题，笔者在动笔写这个内存管理源码解析系列之前也是思考了很久。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;万事开头难，那么到底什么内容适合作为这个系列的开篇呢 ？笔者还是觉得从大家日常开发工作中接触最多最为熟悉的部分开始比较好，比如：在我们日常开发中创建的类，调用的函数，在函数中定义的局部变量以及 new 出来的数据容器（Map，List，Set .....等）都需要存储在物理内存中的某个角落。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们在程序中编写业务逻辑代码的时候，往往需要引用这些创建出来的数据结构，并通过这些引用对相关数据结构进行业务处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当程序运行起来之后就变成了进程，而这些业务数据结构的引用在进程的视角里全都都是虚拟内存地址，因为进程无论是在用户态还是在内核态能够看到的都是虚拟内存空间，物理内存空间被操作系统所屏蔽进程是看不到的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程通过虚拟内存地址访问这些数据结构的时候，虚拟内存地址会在内存管理子系统中被转换成物理内存地址，通过物理内存地址就可以访问到真正存储这些数据结构的物理内存了。随后就可以对这块物理内存进行各种业务操作，从而完成业务逻辑。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;那么到底什么是虚拟内存地址 ？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Linux 内核为啥要引入虚拟内存而不直接使用物理内存 ？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;虚拟内存空间到底长啥样？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核如何管理虚拟内存？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;什么又是物理内存地址 ？如何访问物理内存？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者就来为大家详细一一解答上述几个问题，让我们马上开始吧~~~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9846774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTNfQ6WSkpeNANq9RovbFiafnYm86718mQUReXSA2AAlt3icZYCoW6fhEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;本文概要.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 到底什么是虚拟内存地址&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先人们提出地址这个概念的目的就是用来方便定位现实世界中某一个具体事物的真实地理位置，它是一种用于定位的概念模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个生活中的例子，比如大家在日常生活中给亲朋好友邮寄一些本地特产时，都会填写收件人地址以及寄件人地址。以及在日常网上购物时，都会在相应电商 APP 中填写自己的收获地址。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36363636363636365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTKUG9rxboRf74OXdcDQEpXQJMPf7Xj9zbDhatWY6Exd5jaD0tjN8OUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1166&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后快递小哥就会根据我们填写的收货地址找到我们的真实住所，将我们网购的商品送达到我们的手里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收货地址是用来定位我们在现实世界中真实住所地理位置的，而现实世界中我们所在的城市，街道，小区，房屋都是一砖一瓦，一草一木真实存在的。但收货地址这个概念模型在现实世界中并不真实存在，它只是人们提出的一个虚拟概念，通过收货地址这个虚拟概念将它和现实世界真实存在的城市，小区，街道的地理位置一一映射起来，这样我们就可以通过这个虚拟概念来找到现实世界中的具体地理位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上所述，收货地址是一个虚拟地址，它是人为定义的，而我们的城市，小区，街道是真实存在的，他们的地理位置就是物理地址。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8266666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTleL73x2AXcOKcIc4wbxpC8UfZyKmJt0L2GMdmsP5DgoEGQy1HIJyDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如现在的广东省深圳市在过去叫宝安县，河北省的石家庄过去叫常山，安徽省的合肥过去叫泸州。不管是常山也好，石家庄也好，又或是合肥也好，泸州也罢，这些都是人为定义的名字而已，但是地方还是那个地方，它所在的地理位置是不变的。也就说虚拟地址可以人为的变来变去，但是物理地址永远是不变的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在让我们把视角在切换到计算机的世界，在计算机的世界里内存地址用来定义数据在内存中的存储位置的，内存地址也分为虚拟地址和物理地址。而虚拟地址也是人为设计的一个概念，类比我们现实世界中的收货地址，而物理地址则是数据在物理内存中的真实存储位置，类比现实世界中的城市，街道，小区的真实地理位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多，那么到底虚拟内存地址长什么样子呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以日常生活中的收货地址为例做出类比，我们都很熟悉收货地址的格式：xx省xx市xx区xx街道xx小区xx室，它是按照地区层次递进的。同样，在计算机世界中的虚拟内存地址也有这样的递进关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们以 Intel Core i7 处理器为例，64 位虚拟地址的格式为：全局页目录项（9位）+ 上层页目录项（9位）+ 中间页目录项（9位）+ 页表项（9位）+ 页内偏移（12位）。共 48 位组成的虚拟内存地址。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2806451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTrRwwRoicDmo0xr1zkn2tbghDgDPXNKFJ8PiaxIGNhwibTicibWZj1m5nmdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟内存地址中的全局页目录项就类比我们日常生活中收获地址里的省，上层页目录项就类比市，中间层页目录项类比区县，页表项类比街道小区，页内偏移类比我们所在的楼栋和几层几号。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里大家只需要大体明白虚拟内存地址到底长什么样子，它的格式是什么，能够和日常生活中的收货地址对比理解起来就可以了，至于页目录项，页表项以及页内偏移这些计算机世界中的概念，大家暂时先不用管，后续文章中笔者会慢慢给大家解释清楚。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;32 位虚拟地址的格式为：页目录项（10位）+ 页表项（10位） + 页内偏移（12位）。共 32 位组成的虚拟内存地址。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTl58jTcPaz0Ux8W4GN4IElq59hGWPLl6qTw1ia5NVxvghiciaJibibAc9UFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;进程虚拟内存空间中的每一个字节都有与其对应的虚拟内存地址，一个虚拟内存地址表示进程虚拟内存空间中的一个特定的字节。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 为什么要使用虚拟地址访问内存&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过第一小节的介绍，我们现在明白了计算机世界中的虚拟内存地址的含义及其展现形式。那么大家可能会问了，既然物理内存地址可以直接定位到数据在内存中的存储位置，那为什么我们不直接使用物理内存地址去访问内存而是选择用虚拟内存地址去访问内存呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在回答大家的这个疑问之前，让我们先来看下，如果在程序中直接使用物理内存地址会发生什么情况？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在没有虚拟内存地址，我们在程序中对内存的操作全都都是使用物理内存地址，在这种情况下，程序员就需要精确的知道每一个变量在内存中的具体位置，我们需要手动对物理内存进行布局，明确哪些数据存储在内存的哪些位置，除此之外我们还需要考虑为每个进程究竟要分配多少内存？内存紧张的时候该怎么办？如何避免进程与进程之间的地址冲突？等等一系列复杂且琐碎的细节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们在单进程系统中比如嵌入式设备上开发应用程序，系统中只有一个进程，这单个进程独享所有的物理资源包括内存资源。在这种情况下，上述提到的这些直接使用物理内存的问题可能还好处理一些，但是仍然具有很高的开发门槛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而在现代操作系统中往往支持多个进程，需要处理多进程之间的协同问题，在多进程系统中直接使用物理内存地址操作内存所带来的上述问题就变得非常复杂了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里笔者为大家举一个简单的例子来说明在多进程系统中直接使用物理内存地址的复杂性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们现在有这样一个简单的 Java 程序。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;br/&gt;        string i = args[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;        ..........&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在程序代码相同的情况下，我们用这份代码同时启动三个 JVM 进程，我们暂时将进程依次命名为 a , b , c 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三个进程用到的代码是一样的，都是我们提前写好的，可以被多次运行。由于我们是直接操作物理内存地址，假设变量 i 保存在 0x354 这个物理地址上。这三个进程运行起来之后，同时操作这个 0x354 物理地址，这样这个变量 i 的值不就混乱了吗？ 三个进程就会出现变量的地址冲突。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTdkYRNwjZKSpQhK3Zj76ia1xamewMP0KhHNNrTVJwpEeibUYoI7BJEJzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在直接操作物理内存的情况下，我们需要知道每一个变量的位置都被安排在了哪里，而且还要注意和多个进程同时运行的时候，不能共用同一个地址，否则就会造成地址冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现实中一个程序会有很多的变量和函数，这样一来我们给它们都需要计算一个合理的位置，还不能与其他进程冲突，这就很复杂了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们该如何解决这个问题呢？程序的局部性原理再一次救了我们~~&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;程序局部性原理表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某块数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从程序局部性原理的描述中我们可以得出这样一个结论：进程在运行之后，对于内存的访问不会一下子就要访问全部的内存，相反进程对于内存的访问会表现出明显的倾向性，更加倾向于访问最近访问过的数据以及热点数据附近的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据这个结论我们就清楚了，无论一个进程实际可以占用的内存资源有多大，根据程序局部性原理，在某一段时间内，进程真正需要的物理内存其实是很少的一部分，我们只需要为每个进程分配很少的物理内存就可以保证进程的正常执行运转。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而虚拟内存的引入正是要解决上述的问题，虚拟内存引入之后，进程的视角就会变得非常开阔，每个进程都拥有自己独立的虚拟地址空间，进程与进程之间的虚拟内存地址空间是相互隔离，互不干扰的。每个进程都认为自己独占所有内存空间，自己想干什么就干什么。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6387096774193548&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTJARMZJCXHv9mjibj0gVPdicJTiaKmej7Es23ib8Rc0AUAkYZsk8SIfD8XQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统上还运行了哪些进程和我没有任何关系。这样一来我们就可以将多进程之间协同的相关复杂细节统统交给内核中的内存管理模块来处理，极大地解放了程序员的心智负担。这一切都是因为虚拟内存能够提供内存地址空间的隔离，极大地扩展了可用空间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7258064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTLINE1jjQPxBJrZqwwSMJgMP6WHR0rLxsICVroYUN5HQv7Kk5a8aS3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样进程就以为自己独占了整个内存空间资源，给进程产生了所有内存资源都属于它自己的幻觉，这其实是 CPU 和操作系统使用的一个障眼法罢了，任何一个虚拟内存里所存储的数据，本质上还是保存在真实的物理内存里的。只不过内核帮我们做了虚拟内存到物理内存的这一层映射，将不同进程的虚拟地址和不同内存的物理地址映射起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 CPU 访问进程的虚拟地址时，经过地址翻译硬件将虚拟地址转换成不同的物理地址，这样不同的进程运行的时候，虽然操作的是同一虚拟地址，但其实背后写入的是不同的物理地址，这样就不会冲突了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 进程虚拟内存空间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上小节中，我们介绍了为了防止多进程运行时造成的内存地址冲突，内核引入了虚拟内存地址，为每个进程提供了一个独立的虚拟内存空间，使得进程以为自己独占全部内存资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个进程独占的虚拟内存空间到底是什么样子呢？在本小节中，笔者就为大家揭开这层神秘的面纱~~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本小节内容开始之前，我们先想象一下，如果我们是内核的设计人员，我们该从哪些方面来规划进程的虚拟内存空间呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本小节我们只讨论进程用户态虚拟内存空间的布局，我们先把内核态的虚拟内存空间当做一个黑盒来看待，在后面的小节中笔者再来详细介绍内核态相关内容。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们会想到的是一个进程运行起来是为了执行我们交代给进程的工作，执行这些工作的步骤我们通过程序代码事先编写好，然后编译成二进制文件存放在磁盘中，CPU 会执行二进制文件中的机器码来驱动进程的运行。所以在进程运行之前，这些存放在二进制文件中的机器码需要被加载进内存中，而用于存放这些机器码的虚拟内存空间叫做代码段。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2210200927357033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTvoFvPLedMwWZ12oz9vlBJgaAPryNZRbXh1FWIQKj3Y0UTzGRfgC1RA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;647&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在程序运行起来之后，总要操作变量吧，在程序代码中我们通常会定义大量的全局变量和静态变量，这些全局变量在程序编译之后也会存储在二进制文件中，在程序运行之前，这些全局变量也需要被加载进内存中供程序访问。所以在虚拟内存空间中也需要一段区域来存储这些全局变量。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;那些在代码中被我们指定了初始值的全局变量和静态变量在虚拟内存空间中的存储区域我们叫做数据段。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;那些没有指定初始值的全局变量和静态变量在虚拟内存空间中的存储区域我们叫做 BSS 段。这些未初始化的全局变量被加载进内存之后会被初始化为 0 值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2210200927357033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTnJA0UxdicicudWnJAx39pAB6WoW74icPY0nhzRicWwfxVrputCHNJibUzMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;647&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍的这些全局变量和静态变量都是在编译期间就确定的，但是我们程序在运行期间往往需要动态的申请内存，所以在虚拟内存空间中也需要一块区域来存放这些动态申请的内存，这块区域就叫做堆。注意这里的堆指的是 OS 堆并不是 JVM 中的堆。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2210200927357033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTNPgtIIf5ZFrNQPIcDAz6Lqd4zCib3OLTPSVh7jRfbBsaMyvxz86Ew6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;647&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，我们的程序在运行过程中还需要依赖动态链接库，这些动态链接库以 .so 文件的形式存放在磁盘中，比如 C 程序中的 glibc，里边对系统调用进行了封装。glibc 库里提供的用于动态申请堆内存的 malloc 函数就是对系统调用 sbrk 和 mmap 的封装。这些动态链接库也有自己的对应的代码段，数据段，BSS 段，也需要一起被加载进内存中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有用于内存文件映射的系统调用 mmap，会将文件与内存进行映射，那么映射的这块内存（虚拟内存）也需要在虚拟地址空间中有一块区域存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些动态链接库中的代码段，数据段，BSS 段，以及通过 mmap 系统调用映射的共享内存区，在虚拟内存空间的存储区域叫做文件映射与匿名映射区。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2210200927357033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT8U1Q0hXl5iaMReI67lEzNibZtcqKUicLicia6tpSxObJ7ics7LDxeywFoUBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;647&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们在程序运行的时候总该要调用各种函数吧，那么调用函数过程中使用到的局部变量和函数参数也需要一块内存区域来保存。这一块区域在虚拟内存空间中叫做栈。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTicphhcl2Aw1uezGWibPt5uDiaslIFnv6k4B3WRF4wO43cpEiaurLFDlyDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;625&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在进程的虚拟内存空间所包含的主要区域，笔者就为大家介绍完了，我们看到内核根据进程运行的过程中所需要不同种类的数据而为其开辟了对应的地址空间。分别为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用于存放进程程序二进制文件中的机器指令的代码段&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用于存放程序二进制文件中定义的全局变量和静态变量的数据段和 BSS 段。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用于在程序运行过程中动态申请内存的堆。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用于存放动态链接库以及内存映射区域的文件映射与匿名映射区。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用于存放函数调用过程中的局部变量和函数参数的栈。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是我们通过一个程序在运行过程中所需要的数据所规划出的虚拟内存空间的分布，这些只是一个大概的规划，那么在真实的 Linux 系统中，进程的虚拟内存空间的具体规划又是如何的呢？我们接着往下看~~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Linux 进程虚拟内存空间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上小节中我们介绍了进程虚拟内存空间中各个内存区域的一个大概分布，在此基础之上，本小节笔者就带大家分别从 32 位 和 64 位机器上看下在 Linux 系统中进程虚拟内存空间的真实分布情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 32 位机器上进程虚拟内存空间分布&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 32 位机器上，指针的寻址范围为 2^32，所能表达的虚拟内存空间为 4 GB。所以在 32 位机器上进程的虚拟内存地址范围为：0x0000 0000 - 0xFFFF FFFF。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000  。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9048387096774193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT4tbtfaNT1ztoudqt3UE8ia6RtNNbtUe1siaGb7b1Dre087AnhxlnWMSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是用户态虚拟内存空间中的代码段并不是从 0x0000 0000 地址开始的，而是从 0x0804 8000 地址开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;0x0000 0000 到 0x0804 8000 这段虚拟内存地址是一段不可访问的保留区，因为在大多数操作系统中，数值比较小的地址通常被认为不是一个合法的地址，这块小地址是不允许访问的。比如在 C 语言中我们通常会将一些无效的指针设置为 NULL，指向这块不允许访问的地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保留区的上边就是代码段和数据段，它们是从程序的二进制文件中直接加载进内存中的，BSS 段中的数据也存在于二进制文件中，因为内核知道这些数据是没有初值的，所以在二进制文件中只会记录 BSS 段的大小，在加载进内存时会生成一段 0 填充的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧挨着 BSS 段的上边就是我们经常使用到的堆空间，从图中的红色箭头我们可以知道在堆空间中地址的增长方向是从低地址到高地址增长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核中使用 start_brk 标识堆的起始位置，brk 标识堆当前的结束位置。当堆申请新的内存空间时，只需要将 brk 指针增加对应的大小，回收地址时减少对应的大小即可。比如当我们通过 malloc 向内核申请很小的一块内存时（128K 之内），就是通过改变 brk 位置实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆空间的上边是一段待分配区域，用于扩展堆空间的使用。接下来就来到了文件映射与匿名映射区域。进程运行时所依赖的动态链接库中的代码段，数据段，BSS 段就加载在这里。还有我们调用 mmap 映射出来的一段虚拟内存空间也保存在这个区域。&lt;strong&gt;注意：在文件映射与匿名映射区的地址增长方向是从高地址向低地址增长&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来用户态虚拟内存空间的最后一块区域就是栈空间了，在这里会保存函数运行过程所需要的局部变量以及函数参数等函数调用信息。&lt;strong&gt;栈空间中的地址增长方向是从高地址向低地址增长&lt;/strong&gt;。每次进程申请新的栈地址时，其地址值是在减少的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在内核中使用 start_stack 标识栈的起始位置，RSP 寄存器中保存栈顶指针 stack pointer，RBP 寄存器中保存的是栈基地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在栈空间的下边也有一段待分配区域用于扩展栈空间，在栈空间的上边就是内核空间了，进程虽然可以看到这段内核空间地址，但是就是不能访问。这就好比我们在饭店里虽然可以看到厨房在哪里，但是厨房门上写着 “厨房重地，闲人免进” ，我们就是进不去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.365625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTsiceVVZuF68UrbjUJYtoLWTEHbTXYmeZj34OhZttVia9YR73dNDxysXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 64 位机器上进程虚拟内存空间分布&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上小节中介绍的 32 位虚拟内存空间布局和本小节即将要介绍的 64 位虚拟内存空间布局都可以通过 &lt;code&gt;cat /proc/pid/maps&lt;/code&gt; 或者 &lt;code&gt;pmap pid&lt;/code&gt; 来查看某个进程的实际虚拟内存布局。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道在 32 位机器上，指针的寻址范围为 2^32，所能表达的虚拟内存空间为 4 GB。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们理所应当的会认为在 64 位机器上，指针的寻址范围为 2^64，所能表达的虚拟内存空间为 16 EB 。虚拟内存地址范围为：0x0000 0000 0000 0000 0000 - 0xFFFF FFFF FFFF FFFF 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好家伙 !!! 16 EB 的内存空间，笔者都没见过这么大的磁盘，在现实情况中根本不会用到这么大范围的内存空间，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上在目前的 64 位系统下只使用了 48 位来描述虚拟内存空间，寻址范围为  2^48 ，所能表达的虚拟内存空间为 256TB。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中低 128 T 表示用户态虚拟内存空间，虚拟内存地址范围为：0x0000 0000 0000 0000  - 0x0000 7FFF FFFF F000 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高 128 T 表示内核态虚拟内存空间，虚拟内存地址范围为：0xFFFF 8000 0000 0000  - 0xFFFF FFFF FFFF FFFF 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来就在用户态虚拟内存空间与内核态虚拟内存空间之间形成了一段 0x0000 7FFF FFFF F000  -  0xFFFF 8000 0000 0000  的地址空洞，我们把这个空洞叫做 canonical address 空洞。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49032258064516127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTLPmAARV9MdjF6Ts8damEDNEVbTBnfibG8ZUDhkyNAE5FiaxAOepGupSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个 canonical address 空洞是如何形成的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道在 64 位机器上的指针寻址范围为 2^64，但是在实际使用中我们只使用了其中的低 48 位来表示虚拟内存地址，那么这多出的高 16 位就形成了这个地址空洞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家注意到在低 128T 的用户态地址空间：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000 范围中，所以虚拟内存地址的高 16 位全部为 0 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个虚拟内存地址的高 16 位全部为 0 ，那么我们就可以直接判断出这是一个用户空间的虚拟内存地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的道理，在高 128T 的内核态虚拟内存空间：0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 范围中，所以虚拟内存地址的高 16 位全部为 1 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说内核态的虚拟内存地址的高 16 位全部为 1 ，如果一个试图访问内核的虚拟地址的高 16 位不全为 1 ，则可以快速判断这个访问是非法的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个高 16 位的空闲地址被称为 canonical 。如果虚拟内存地址中的高 16 位全部为 0 （表示用户空间虚拟内存地址）或者全部为 1 （表示内核空间虚拟内存地址），这种地址的形式我们叫做 canonical form，对应的地址我们称作 canonical address 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么处于 canonical address 空洞 ：0x0000 7FFF FFFF F000 - 0xFFFF 8000 0000 0000 范围内的地址的高 16 位 不全为 0 也不全为 1 。如果某个虚拟地址落在这段 canonical address 空洞区域中，那就是既不在用户空间，也不在内核空间，肯定是非法访问了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;未来我们也可以利用这块 canonical address 空洞，来扩展虚拟内存地址的范围，比如扩展到 56 位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们理解了 canonical address 这个概念之后，我们再来看下 64 位 Linux 系统下的真实虚拟内存空间布局情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9919354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTO7TLSnvKsLicbW38ZEcgMibdJBHl0icAjRG0P8J1pzOM4KofkFTlbFjeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图中我们可以看出 64 位系统中的虚拟内存布局和 32 位系统中的虚拟内存布局大体上是差不多的。主要不同的地方有三点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;就是前边提到的由高 16 位空闲地址造成的  canonical address 空洞。在这段范围内的虚拟内存地址是不合法的，因为它的高 16 位既不全为 0 也不全为 1，不是一个 canonical address，所以称之为 canonical address 空洞。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在代码段跟数据段的中间还有一段不可以读写的保护段，它的作用是防止程序在读写数据段的时候越界访问到代码段，这个保护段可以让越界访问行为直接崩溃，防止它继续往下运行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户态虚拟内存空间与内核态虚拟内存空间分别占用 128T，其中低128T 分配给用户态虚拟内存空间，高 128T 分配给内核态虚拟内存空间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 进程虚拟内存空间的管理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一小节中，笔者为大家介绍了 Linux 操作系统在 32 位机器上和 64 位机器上进程虚拟内存空间的布局分布，我们发现无论是在 32 位机器上还是在 64 位机器上，进程虚拟内存空间的核心区域分布的相对位置是不变的，它们都包含下图所示的这几个核心内存区域。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTicphhcl2Aw1uezGWibPt5uDiaslIFnv6k4B3WRF4wO43cpEiaurLFDlyDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;625&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唯一不同的是这些核心内存区域在 32 位机器和 64 位机器上的绝对位置分布会有所不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在此基础之上，内核如何为进程管理这些虚拟内存区域呢？这将是本小节重点为大家介绍的内容~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然我们要介绍进程的虚拟内存空间管理，那就离不开进程在内核中的描述符 task_struct 结构。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 进程id&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;pid_t&lt;/span&gt;    pid;&lt;br/&gt;        &lt;span&gt;// 用于标识线程所属的进程 pid&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;pid_t&lt;/span&gt;    tgid;&lt;br/&gt;        &lt;span&gt;// 进程打开的文件信息&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;files_struct&lt;/span&gt;  *&lt;span&gt;files&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 内存描述符表示进程虚拟地址空间&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;mm_struct&lt;/span&gt;  *&lt;span&gt;mm&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        .......... 省略 .......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进程描述符 task_struct 结构中，有一个专门描述进程虚拟地址空间的内存描述符 mm_struct 结构，这个结构体中包含了前边几个小节中介绍的进程虚拟内存空间的全部信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个进程都有唯一的 mm_struct 结构体，也就是前边提到的每个进程的虚拟地址空间都是独立，互不干扰的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们调用 fork() 函数创建进程的时候，表示进程地址空间的 mm_struct 结构会随着进程描述符 task_struct 的创建而创建。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;long&lt;/span&gt; _do_fork(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; clone_flags,&lt;br/&gt;       &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; stack_start,&lt;br/&gt;       &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; stack_size,&lt;br/&gt;       &lt;span&gt;int&lt;/span&gt; __user *parent_tidptr,&lt;br/&gt;       &lt;span&gt;int&lt;/span&gt; __user *child_tidptr,&lt;br/&gt;       &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; tls)&lt;br/&gt;{&lt;br/&gt;        ......... 省略 ..........&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; *&lt;span&gt;pid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; *&lt;span&gt;p&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        ......... 省略 ..........&lt;br/&gt;    &lt;span&gt;// 为进程创建 task_struct 结构，用父进程的资源填充 task_struct 信息&lt;/span&gt;&lt;br/&gt; p = copy_process(clone_flags, stack_start, stack_size,&lt;br/&gt;    child_tidptr, &lt;span&gt;NULL&lt;/span&gt;, trace, tls, NUMA_NO_NODE);&lt;br/&gt;&lt;br/&gt;         ......... 省略 ..........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会在 copy_process 函数中创建 task_struct 结构，并拷贝父进程的相关资源到新进程的 task_struct 结构里，其中就包括拷贝父进程的虚拟内存空间 mm_struct 结构。&lt;strong&gt;这里可以看出子进程在新创建出来之后它的虚拟内存空间是和父进程的虚拟内存空间一模一样的，直接拷贝过来&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; __latent_entropy struct task_struct *&lt;span&gt;copy_process&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;     &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; clone_flags,&lt;br/&gt;     &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; stack_start,&lt;br/&gt;     &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; stack_size,&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; __user *child_tidptr,&lt;br/&gt;     struct pid *pid,&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; trace,&lt;br/&gt;     &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; tls,&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; node)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; *&lt;span&gt;p&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 创建 task_struct 结构&lt;/span&gt;&lt;br/&gt;    p = dup_task_struct(current, node);&lt;br/&gt;&lt;br/&gt;        ....... 初始化子进程 ...........&lt;br/&gt;&lt;br/&gt;        ....... 开始继承拷贝父进程资源  .......      &lt;br/&gt;    &lt;span&gt;// 继承父进程打开的文件描述符&lt;/span&gt;&lt;br/&gt; retval = copy_files(clone_flags, p);&lt;br/&gt;    &lt;span&gt;// 继承父进程所属的文件系统&lt;/span&gt;&lt;br/&gt; retval = copy_fs(clone_flags, p);&lt;br/&gt;    &lt;span&gt;// 继承父进程注册的信号以及信号处理函数&lt;/span&gt;&lt;br/&gt; retval = copy_sighand(clone_flags, p);&lt;br/&gt; retval = copy_signal(clone_flags, p);&lt;br/&gt;    &lt;span&gt;// 继承父进程的虚拟内存空间&lt;/span&gt;&lt;br/&gt; retval = copy_mm(clone_flags, p);&lt;br/&gt;    &lt;span&gt;// 继承父进程的 namespaces&lt;/span&gt;&lt;br/&gt; retval = copy_namespaces(clone_flags, p);&lt;br/&gt;    &lt;span&gt;// 继承父进程的 IO 信息&lt;/span&gt;&lt;br/&gt; retval = copy_io(clone_flags, p);&lt;br/&gt;&lt;br/&gt;      ...........省略.........&lt;br/&gt;    &lt;span&gt;// 分配 CPU&lt;/span&gt;&lt;br/&gt;    retval = sched_fork(clone_flags, p);&lt;br/&gt;    &lt;span&gt;// 分配 pid&lt;/span&gt;&lt;br/&gt;    pid = alloc_pid(p-&amp;gt;nsproxy-&amp;gt;pid_ns_for_children);&lt;br/&gt;&lt;br/&gt;.     ..........省略.........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们重点关注 copy_mm 函数，正是在这里完成了子进程虚拟内存空间 mm_struct 结构的的创建以及初始化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;copy_mm&lt;/span&gt;&lt;span&gt;(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; clone_flags, struct task_struct *tsk)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 子进程虚拟内存空间，父进程虚拟内存空间&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;mm_struct&lt;/span&gt; *&lt;span&gt;mm&lt;/span&gt;, *&lt;span&gt;oldmm&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; retval;&lt;br/&gt;&lt;br/&gt;        ...... 省略 ......&lt;br/&gt;&lt;br/&gt; tsk-&amp;gt;mm = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt; tsk-&amp;gt;active_mm = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 获取父进程虚拟内存空间&lt;/span&gt;&lt;br/&gt; oldmm = current-&amp;gt;mm;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!oldmm)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        ...... 省略 ......&lt;br/&gt; &lt;span&gt;// 通过 vfork 或者 clone 系统调用创建出的子进程（线程）和父进程共享虚拟内存空间&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (clone_flags &amp;amp; CLONE_VM) {&lt;br/&gt;        &lt;span&gt;// 增加父进程虚拟地址空间的引用计数&lt;/span&gt;&lt;br/&gt;        mmget(oldmm);&lt;br/&gt;        &lt;span&gt;// 直接将父进程的虚拟内存空间赋值给子进程（线程）&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 线程共享其所属进程的虚拟内存空间&lt;/span&gt;&lt;br/&gt;        mm = oldmm;&lt;br/&gt;        &lt;span&gt;goto&lt;/span&gt; good_mm;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; retval = -ENOMEM;&lt;br/&gt; &lt;span&gt;// 如果是 fork 系统调用创建出的子进程，则将父进程的虚拟内存空间以及相关页表拷贝到子进程中的 mm_struct 结构中。&lt;/span&gt;&lt;br/&gt; mm = dup_mm(tsk);&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!mm)&lt;br/&gt;  &lt;span&gt;goto&lt;/span&gt; fail_nomem;&lt;br/&gt;&lt;br/&gt;good_mm:&lt;br/&gt; &lt;span&gt;// 将拷贝出来的父进程虚拟内存空间 mm_struct 赋值给子进程&lt;/span&gt;&lt;br/&gt; tsk-&amp;gt;mm = mm;&lt;br/&gt; tsk-&amp;gt;active_mm = mm;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        ...... 省略 ......&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于本小节中我们举的示例是通过  fork() 函数创建子进程的情形，所以这里大家先占时忽略 &lt;code&gt;if (clone_flags &amp;amp; CLONE_VM)&lt;/code&gt; 这个条件判断逻辑，我们先跳过往后看~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;copy_mm  函数首先会将父进程的虚拟内存空间 current-&amp;gt;mm 赋值给指针 oldmm。然后通过 dup_mm 函数将父进程的虚拟内存空间以及&lt;strong&gt;相关页表&lt;/strong&gt;拷贝到子进程的 mm_struct 结构中。最后将拷贝出来的 mm_struct 赋值给子进程的 task_struct 结构。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;通过 fork() 函数创建出的子进程，它的虚拟内存空间以及相关页表相当于父进程虚拟内存空间的一份拷贝，直接从父进程中拷贝到子进程中。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而当我们通过 vfork 或者 clone 系统调用创建出的子进程，首先会设置 CLONE_VM 标识，这样来到 copy_mm 函数中就会进入  &lt;code&gt;if (clone_flags &amp;amp; CLONE_VM)&lt;/code&gt;  条件中，在这个分支中会将父进程的虚拟内存空间以及相关页表直接赋值给子进程。这样一来父进程和子进程的虚拟内存空间就变成共享的了。也就是说父子进程之间使用的虚拟内存空间是一样的，并不是一份拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子进程共享了父进程的虚拟内存空间，这样子进程就变成了我们熟悉的线程，&lt;strong&gt;是否共享地址空间几乎是进程和线程之间的本质区别。Linux 内核并不区别对待它们，线程对于内核来说仅仅是一个共享特定资源的进程而已&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核线程和用户态线程的区别就是内核线程没有相关的内存描述符 mm_struct ，内核线程对应的 task_struct 结构中的 mm 域指向 Null，所以内核线程之间调度是不涉及地址空间切换的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个内核线程被调度时，它会发现自己的虚拟地址空间为 Null，虽然它不会访问用户态的内存，但是它会访问内核内存，聪明的内核会将调度之前的上一个用户态进程的虚拟内存空间 mm_struct 直接赋值给内核线程，因为内核线程不会访问用户空间的内存，它仅仅只会访问内核空间的内存，所以直接复用上一个用户态进程的虚拟地址空间就可以避免为内核线程分配 mm_struct 和相关页表的开销，以及避免内核线程之间调度时地址空间的切换开销。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;父进程与子进程的区别，进程与线程的区别，以及内核线程与用户态线程的区别其实都是围绕着这个 mm_struct 展开的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们知道了表示进程虚拟内存空间的 mm_struct 结构是如何被创建出来的相关背景，那么接下来笔者就带大家深入 mm_struct 结构内部，来看一下内核如何通过这么一个 mm_struct 结构体来管理进程的虚拟内存空间的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 内核如何划分用户态和内核态虚拟内存空间&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 《3. 进程虚拟内存空间》小节的介绍我们知道，进程的虚拟内存空间分为两个部分：一部分是用户态虚拟内存空间，另一部分是内核态虚拟内存空间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTicphhcl2Aw1uezGWibPt5uDiaslIFnv6k4B3WRF4wO43cpEiaurLFDlyDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;625&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么用户态的地址空间和内核态的地址空间在内核中是如何被划分的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就用到了进程的内存描述符 mm_struct 结构体中的 task_size 变量，task_size 定义了用户态地址空间与内核态地址空间之间的分界线。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;mm_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; task_size; &lt;span&gt;/* size of task vm space */&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前边小节的内容介绍，我们知道在  32 位系统中用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9048387096774193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT4tbtfaNT1ztoudqt3UE8ia6RtNNbtUe1siaGb7b1Dre087AnhxlnWMSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;32位地址空间.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;32 位系统中用户地址空间和内核地址空间的分界线在 0xC000 000 地址处，那么自然进程的 mm_struct 结构中的 task_size 为 0xC000 000。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下内核在 &lt;code&gt;/arch/x86/include/asm/page_32_types.h&lt;/code&gt; 文件中关于 TASK_SIZE 的定义。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/*&lt;br/&gt; * User space process size: 3GB (default).&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; TASK_SIZE  __PAGE_OFFSET&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：__PAGE_OFFSET 的值在 32 位系统下为  0xC000 000。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6217741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTwn4kedvjD143dXc3MMSuQHNQUu9padcq5PI9QQmKRcIee0gImtguRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;/arch/arm/Kconfig.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 64 位系统中，只使用了其中的低 48 位来表示虚拟内存地址。其中用户态虚拟内存空间为低 128 T，虚拟内存地址范围为：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核态虚拟内存空间为高 128 T，虚拟内存地址范围为：0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9919354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTO7TLSnvKsLicbW38ZEcgMibdJBHl0icAjRG0P8J1pzOM4KofkFTlbFjeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;64位地址空间.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;64 位系统中用户地址空间和内核地址空间的分界线在  0x0000 7FFF FFFF F000 地址处，那么自然进程的 mm_struct 结构中的 task_size 为 0x0000 7FFF FFFF F000 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下内核在 &lt;code&gt;/arch/x86/include/asm/page_64_types.h&lt;/code&gt; 文件中关于 TASK_SIZE 的定义。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; TASK_SIZE  (test_thread_flag(TIF_ADDR32) ? \&lt;br/&gt;     IA32_PAGE_OFFSET : TASK_SIZE_MAX)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; TASK_SIZE_MAX  task_size_max()&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; task_size_max()  ((_AC(1,UL) &amp;lt;&amp;lt; __VIRTUAL_MASK_SHIFT) - PAGE_SIZE)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; __VIRTUAL_MASK_SHIFT 47&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下在 64 位系统中内核如何来计算 TASK_SIZE，在  task_size_max() 的计算逻辑中 1 左移 47 位得到的地址是 0x0000800000000000，然后减去一个 PAGE_SIZE （默认为 4K），就是 0x00007FFFFFFFF000，共 128T。所以在 64 位系统中的 TASK_SIZE 为 0x00007FFFFFFFF000 。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里我们可以看出，64 位虚拟内存空间的布局是和物理内存页 page 的大小有关的，物理内存页 page 默认大小 PAGE_SIZE 为 4K。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PAGE_SIZE 定义在 &lt;code&gt;/arch/x86/include/asm/page_types.h&lt;/code&gt;文件中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/* PAGE_SHIFT determines the page size */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; PAGE_SHIFT  12&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; PAGE_SIZE  (_AC(1,UL) &amp;lt;&amp;lt; PAGE_SHIFT)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而内核空间的起始地址是 0xFFFF 8000 0000 0000 。在 0x00007FFFFFFFF000 - 0xFFFF 8000 0000 0000 之间的内存区域就是我们在 《4.2 64 位机器上进程虚拟内存空间分布》小节中介绍的 canonical address 空洞。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 内核如何布局进程虚拟内存空间&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们理解了内核是如何划分进程虚拟内存空间和内核虚拟内存空间之后，那么在 《3. 进程虚拟内存空间》小节中介绍的那些虚拟内存区域在内核中又是如何划分的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来笔者就为大家介绍下内核是如何划分进程虚拟内存空间中的这些内存区域的，本小节的示例图中，笔者只保留了进程虚拟内存空间中的核心区域，方便大家理解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5362903225806451&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTRV8O9NcRglfjls8RoaE2pOElX2BkmGhX4VRuoG257kTwfR2tBRuzUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们提到，内核中采用了一个叫做内存描述符的 mm_struct 结构体来表示进程虚拟内存空间的全部信息。在本小节中笔者就带大家到 mm_struct 结构体内部去寻找下相关的线索。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;mm_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; task_size;    &lt;span&gt;/* size of task vm space */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; start_code, end_code, start_data, end_data;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; start_brk, brk, start_stack;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; arg_start, arg_end, env_start, env_end;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mmap_base;  &lt;span&gt;/* base of mmap area */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; total_vm;    &lt;span&gt;/* Total pages mapped */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; locked_vm;  &lt;span&gt;/* Pages that have PG_mlocked set */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pinned_vm;  &lt;span&gt;/* Refcount permanently increased */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; data_vm;    &lt;span&gt;/* VM_WRITE &amp;amp; ~VM_SHARED &amp;amp; ~VM_STACK */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; exec_vm;    &lt;span&gt;/* VM_EXEC &amp;amp; ~VM_WRITE &amp;amp; ~VM_STACK */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; stack_vm;    &lt;span&gt;/* VM_STACK */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;       ...... 省略 ........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核中用 mm_struct 结构体中的上述属性来定义上图中虚拟内存空间里的不同内存区域。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;start_code 和 end_code 定义代码段的起始和结束位置，程序编译后的二进制文件中的机器码被加载进内存之后就存放在这里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;start_data 和 end_data 定义数据段的起始和结束位置，二进制文件中存放的全局变量和静态变量被加载进内存中就存放在这里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面紧挨着的是 BSS 段，用于存放未被初始化的全局变量和静态变量，这些变量在加载进内存时会生成一段 0 填充的内存区域 （BSS 段）， BSS 段的大小是固定的，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就是 OS 堆了，在堆中内存地址的增长方向是由低地址向高地址增长， start_brk 定义堆的起始位置，brk 定义堆当前的结束位置。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们使用 malloc 申请小块内存时（低于 128K），就是通过改变 brk 位置调整堆大小实现的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来就是内存映射区，在内存映射区内存地址的增长方向是由高地址向低地址增长，mmap_base 定义内存映射区的起始地址。进程运行时所依赖的动态链接库中的代码段，数据段，BSS 段以及我们调用 mmap 映射出来的一段虚拟内存空间就保存在这个区域。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;start_stack 是栈的起始位置在 RBP 寄存器中存储，栈的结束位置也就是栈顶指针 stack pointer 在 RSP 寄存器中存储。在栈中内存地址的增长方向也是由高地址向低地址增长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;arg_start 和 arg_end 是参数列表的位置， env_start 和 env_end 是环境变量的位置。它们都位于栈中的最高地址处。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42338709677419356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTcWU7wiaNM09r9pblewZhVPCvyicMIv9WhP1UXq4OxrKRf5f3ptIXwDLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 mm_struct 结构体中除了上述用于划分虚拟内存区域的变量之外，还定义了一些虚拟内存与物理内存映射内容相关的统计变量，操作系统会把物理内存划分成一页一页的区域来进行管理，所以物理内存到虚拟内存之间的映射也是按照页为单位进行的。这部分内容笔者会在后续的文章中详细介绍，大家这里只需要有个概念就行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mm_struct 结构体中的 total_vm 表示在进程虚拟内存空间中总共与物理内存映射的页的总数。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意映射这个概念，它表示只是将虚拟内存与物理内存建立关联关系，并不代表真正的分配物理内存。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当内存吃紧的时候，有些页可以换出到硬盘上，而有些页因为比较重要，不能换出。locked_vm 就是被锁定不能换出的内存页总数，pinned_vm  表示既不能换出，也不能移动的内存页总数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;data_vm 表示数据段中映射的内存页数目，exec_vm 是代码段中存放可执行文件的内存页数目，stack_vm 是栈中所映射的内存页数目，这些变量均是表示进程虚拟内存空间中的虚拟内存使用情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在关于内核如何对进程虚拟内存空间进行布局的内容我们已经清楚了，那么布局之后划分出的这些虚拟内存区域在内核中又是如何被管理的呢？我们接着往下看~~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 内核如何管理虚拟内存区域&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上小节的介绍中，我们知道内核是通过一个 mm_struct 结构的内存描述符来表示进程的虚拟内存空间的，并通过 task_size 域来划分用户态虚拟内存空间和内核态虚拟内存空间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTicphhcl2Aw1uezGWibPt5uDiaslIFnv6k4B3WRF4wO43cpEiaurLFDlyDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;625&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在划分出的这些虚拟内存空间中如上图所示，里边又包含了许多特定的虚拟内存区域，比如：代码段，数据段，堆，内存映射区，栈。那么这些虚拟内存区域在内核中又是如何表示的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节中，笔者将为大家介绍一个新的结构体 vm_area_struct，正是这个结构体描述了这些虚拟内存区域 VMA（virtual memory area）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;vm_area_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; vm_start;  &lt;span&gt;/* Our start address within vm_mm. */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; vm_end;  &lt;span&gt;/* The first byte after our end address&lt;br/&gt;        within vm_mm. */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;/*&lt;br/&gt;  * Access permissions of this VMA.&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;pgprot_t&lt;/span&gt; vm_page_prot;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; vm_flags; &lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;anon_vma&lt;/span&gt; *&lt;span&gt;anon_vma&lt;/span&gt;;&lt;/span&gt; &lt;span&gt;/* Serialized by page_table_lock */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; * &lt;span&gt;vm_file&lt;/span&gt;;&lt;/span&gt;  &lt;span&gt;/* File we map to (can be NULL). */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; vm_pgoff;  &lt;span&gt;/* Offset (within vm_file) in PAGE_SIZE&lt;br/&gt;        units */&lt;/span&gt; &lt;br/&gt; &lt;span&gt;void&lt;/span&gt; * vm_private_data;  &lt;span&gt;/* was vm_pte (shared mem) */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;/* Function pointers to deal with this struct. */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;vm_operations_struct&lt;/span&gt; *&lt;span&gt;vm_ops&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 vm_area_struct 结构对应于虚拟内存空间中的唯一虚拟内存区域 VMA，vm_start 指向了这块虚拟内存区域的起始地址（最低地址），vm_start 本身包含在这块虚拟内存区域内。vm_end 指向了这块虚拟内存区域的结束地址（最高地址），而 vm_end 本身包含在这块虚拟内存区域之外，所以 vm_area_struct 结构描述的是 [vm_start，vm_end) 这样一段左闭右开的虚拟内存区域。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4604779411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTCwh0csrop8H9RPKibNQSiaqM11pOcaAnCBXBAIOibm8hgFICKQibObAcOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1088&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.4 定义虚拟内存区域的访问权限和行为规范&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vm_page_prot 和 vm_flags 都是用来标记 vm_area_struct 结构表示的这块虚拟内存区域的访问权限和行为规范。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边小节中我们也提到，内核会将整块物理内存划分为一页一页大小的区域，以页为单位来管理这些物理内存，每页大小默认 4K 。而虚拟内存最终也是要和物理内存一一映射起来的，所以在虚拟内存空间中也有虚拟页的概念与之对应，虚拟内存中的虚拟页映射到物理内存中的物理页。无论是在虚拟内存空间中还是在物理内存中，内核管理内存的最小单位都是页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vm_page_prot 偏向于定义底层内存管理架构中页这一级别的访问控制权限，它可以直接应用在底层页表中，它是一个具体的概念。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;页表用于管理虚拟内存到物理内存之间的映射关系，这部分内容笔者后续会详细讲解，这里大家有个初步的概念就行。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟内存区域 VMA 由许多的虚拟页 (page) 组成，每个虚拟页需要经过页表的转换才能找到对应的物理页面。页表中关于内存页的访问权限就是由 vm_page_prot 决定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vm_flags 则偏向于定于整个虚拟内存区域的访问权限以及行为规范。描述的是虚拟内存区域中的整体信息，而不是虚拟内存区域中具体的某个独立页面。它是一个抽象的概念。可以通过 &lt;code&gt;vma-&amp;gt;vm_page_prot = vm_get_page_prot(vma-&amp;gt;vm_flags)&lt;/code&gt; 实现到具体页面访问权限 vm_page_prot 的转换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面笔者列举一些常用到的 vm_flags 方便大家有一个直观的感受：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;vm_flags&lt;/th&gt;&lt;th&gt;访问权限&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;VM_READ&lt;/td&gt;&lt;td&gt;可读&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VM_WRITE&lt;/td&gt;&lt;td&gt;可写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VM_EXEC&lt;/td&gt;&lt;td&gt;可执行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VM_SHARD&lt;/td&gt;&lt;td&gt;可多进程之间共享&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VM_IO&lt;/td&gt;&lt;td&gt;可映射至设备 IO 空间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VM_RESERVED&lt;/td&gt;&lt;td&gt;内存区域不可被换出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VM_SEQ_READ&lt;/td&gt;&lt;td&gt;内存区域可能被顺序访问&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VM_RAND_READ&lt;/td&gt;&lt;td&gt;内存区域可能被随机访问&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VM_READ，VM_WRITE，VM_EXEC 定义了虚拟内存区域是否可以被读取，写入，执行等权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如代码段这块内存区域的权限是可读，可执行，但是不可写。数据段具有可读可写的权限但是不可执行。堆则具有可读可写，可执行的权限（Java 中的字节码存储在堆中，所以需要可执行权限），栈一般是可读可写的权限，一般很少有可执行权限。而文件映射与匿名映射区存放了共享链接库，所以也需要可执行的权限。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4604779411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTpl6pHWb18OgpCQSFx88HvCalkeMjcyv7ckibCU6ZPy5FEfeWnY0j4Mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1088&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VM_SHARD 用于指定这块虚拟内存区域映射的物理内存是否可以在多进程之间共享，以便完成进程间通讯。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;设置这个值即为 mmap 的共享映射，不设置的话则为私有映射。这个等后面我们讲到 mmap 的相关实现时还会再次提起。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VM_IO 的设置表示这块虚拟内存区域可以映射至设备 IO 空间中。通常在设备驱动程序执行 mmap 进行 IO 空间映射时才会被设置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VM_RESERVED 的设置表示在内存紧张的时候，这块虚拟内存区域非常重要，不能被换出到磁盘中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VM_SEQ_READ 的设置用来暗示内核，应用程序对这块虚拟内存区域的读取是会采用顺序读的方式进行，内核会根据实际情况决定预读后续的内存页数，以便加快下次顺序访问速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VM_RAND_READ 的设置会暗示内核，应用程序会对这块虚拟内存区域进行随机读取，内核则会根据实际情况减少预读的内存页数甚至停止预读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过 posix_fadvise，madvise 系统调用来暗示内核是否对相关内存区域进行顺序读取或者随机读取。相关的详细内容，大家可以看下笔者上篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247486623&amp;amp;idx=1&amp;amp;sn=0cafed9e89b60d678d8c88dc7689abda&amp;amp;chksm=ce77cad8f90043ceaaca732aaaa7cb692c1d23eeb6c07de84f0ad690ab92d758945807239cee&amp;amp;token=1276722624&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《从 Linux 内核角度探秘 JDK NIO 文件读写本质》&lt;/a&gt;中的第 9 小节文件页预读部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这一系列的介绍，我们可以看到 vm_flags 就是定义整个虚拟内存区域的访问权限以及行为规范，而内存区域中内存的最小单位为页（4K），虚拟内存区域中包含了很多这样的虚拟页，对于虚拟内存区域 VMA 设置的访问权限也会全部复制到区域中包含的内存页中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.5 关联内存映射中的映射关系&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的三个属性 anon_vma，vm_file，vm_pgoff 分别和虚拟内存映射相关，虚拟内存区域可以映射到物理内存上，也可以映射到文件中，映射到物理内存上我们称之为匿名映射，映射到文件中我们称之为文件映射。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个映射关系在内核中该如何表示呢？这就用到了 vm_area_struct 结构体中的上述三个属性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42338709677419356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTcWU7wiaNM09r9pblewZhVPCvyicMIv9WhP1UXq4OxrKRf5f3ptIXwDLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们调用 malloc 申请内存时，如果申请的是小块内存（低于 128K）则会使用 do_brk() 系统调用通过调整堆中的 brk 指针大小来增加或者回收堆内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果申请的是比较大块的内存（超过 128K）时，则会调用 mmap 在上图虚拟内存空间中的文件映射与匿名映射区创建出一块 VMA 内存区域（这里是匿名映射）。这块匿名映射区域就用 struct anon_vma 结构表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当调用 mmap 进行文件映射时，vm_file 属性就用来关联被映射的文件。这样一来虚拟内存区域就与映射文件关联了起来。vm_pgoff 则表示映射进虚拟内存中的文件内容，在文件中的偏移。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当然在匿名映射中，vm_area_struct 结构中的 vm_file 就为 null，vm_pgoff 也就没有了意义。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vm_private_data 则用于存储 VMA 中的私有数据。具体的存储内容和内存映射的类型有关，我们暂不展开论述。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.6 针对虚拟内存区域的相关操作&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;struct vm_area_struct 结构中还有一个 vm_ops 用来指向针对虚拟内存区域 VMA 的相关操作的函数指针。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;vm_operations_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;void&lt;/span&gt; (*open)(struct vm_area_struct * area);&lt;br/&gt; &lt;span&gt;void&lt;/span&gt; (*close)(struct vm_area_struct * area);&lt;br/&gt;    &lt;span&gt;vm_fault_t&lt;/span&gt; (*fault)(struct vm_fault *vmf);&lt;br/&gt;    &lt;span&gt;vm_fault_t&lt;/span&gt; (*page_mkwrite)(struct vm_fault *vmf);&lt;br/&gt;&lt;br/&gt;    ..... 省略 .......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当指定的虚拟内存区域被加入到进程虚拟内存空间中时，open 函数会被调用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当虚拟内存区域 VMA 从进程虚拟内存空间中被删除时，close 函数会被调用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当进程访问虚拟内存时，访问的页面不在物理内存中，可能是未分配物理内存也可能是被置换到磁盘中，这时就会产生缺页异常，fault 函数就会被调用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个只读的页面将要变为可写时，page_mkwrite 函数会被调用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;struct vm_operations_struct 结构中定义的都是对虚拟内存区域 VMA 的相关操作函数指针。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核中这种类似的用法其实有很多，在内核中每个特定领域的描述符都会定义相关的操作。比如在前边的文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247486623&amp;amp;idx=1&amp;amp;sn=0cafed9e89b60d678d8c88dc7689abda&amp;amp;chksm=ce77cad8f90043ceaaca732aaaa7cb692c1d23eeb6c07de84f0ad690ab92d758945807239cee&amp;amp;token=1276722624&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《从 Linux 内核角度探秘 JDK NIO 文件读写本质》&lt;/a&gt; 中我们介绍到内核中的文件描述符 struct file 中定义的 struct file_operations  *f_op。里面定义了内核针对文件操作的函数指针，具体的实现根据不同的文件类型有所不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对 Socket 文件类型，这里的 file_operations 指向的是 socket_file_ops。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48629032258064514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTpJKpGlocuxEfConFicRSdhlicskcHsr6ETUJqAAcpnUqDbkLicHaR8lcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;进程中管理文件列表结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ext4 文件系统中管理的文件对应的 file_operations 指向 ext4_file_operations，专门用于操作 ext4 文件系统中的文件。还有针对 page cache 页高速缓存相关操作定义的 address_space_operations 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6056451612903225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT6QNuOEO3cjwD6D14LstYQMSTGM6WOeDicV3EXIasbsic4YwK6RbTmuaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有我们在 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《从 Linux 内核角度看 IO 模型的演变》&lt;/a&gt;一文中介绍到，socket 相关的操作接口定义在 inet_stream_ops 函数集合中，负责对上给用户提供接口。而 socket 与内核协议栈之间的操作接口定义在 struct sock 中的 sk_prot 指针上，这里指向 tcp_prot 协议操作函数集合。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5620967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT5TjyB66fyZCRKuOwKxG5HJ5ebERelmfGZc5PosSu4XibrwSQHD63iaoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;系统IO调用结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 socket 发起的系统 IO 调用时，在内核中首先会调用 socket 的文件结构 struct file 中的 file_operations 文件操作集合，然后调用 struct socket 中的 ops 指向的 inet_stream_opssocket 操作函数，最终调用到 struct sock 中 sk_prot 指针指向的 tcp_prot 内核协议栈操作函数接口集合。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.7 虚拟内存区域在内核中是如何被组织的&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一小节中，我们介绍了内核中用来表示虚拟内存区域 VMA 的结构体 struct vm_area_struct ，并详细为大家剖析了 struct vm_area_struct 中的一些重要的关键属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经熟悉了这些虚拟内存区域，那么接下来的问题就是在内核中这些虚拟内存区域是如何被组织的呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTicphhcl2Aw1uezGWibPt5uDiaslIFnv6k4B3WRF4wO43cpEiaurLFDlyDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;625&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们继续来到 struct vm_area_struct 结构中，来看一下与组织结构相关的一些属性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;vm_area_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;vm_area_struct&lt;/span&gt; *&lt;span&gt;vm_next&lt;/span&gt;, *&lt;span&gt;vm_prev&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;rb_node&lt;/span&gt; &lt;span&gt;vm_rb&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;list_head&lt;/span&gt; &lt;span&gt;anon_vma_chain&lt;/span&gt;;&lt;/span&gt; &lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;mm_struct&lt;/span&gt; *&lt;span&gt;vm_mm&lt;/span&gt;;&lt;/span&gt; &lt;span&gt;/* The address space we belong to. */&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; vm_start;     &lt;span&gt;/* Our start address within vm_mm. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; vm_end;       &lt;span&gt;/* The first byte after our end address&lt;br/&gt;                       within vm_mm. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;     * Access permissions of this VMA.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;pgprot_t&lt;/span&gt; vm_page_prot;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; vm_flags; &lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;anon_vma&lt;/span&gt; *&lt;span&gt;anon_vma&lt;/span&gt;;&lt;/span&gt;  &lt;span&gt;/* Serialized by page_table_lock */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; * &lt;span&gt;vm_file&lt;/span&gt;;&lt;/span&gt;      &lt;span&gt;/* File we map to (can be NULL). */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; vm_pgoff;     &lt;span&gt;/* Offset (within vm_file) in PAGE_SIZE&lt;br/&gt;                       units */&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; * vm_private_data;     &lt;span&gt;/* was vm_pte (shared mem) */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/* Function pointers to deal with this struct. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;vm_operations_struct&lt;/span&gt; *&lt;span&gt;vm_ops&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在内核中其实是通过一个 struct vm_area_struct 结构的双向链表将虚拟内存空间中的这些虚拟内存区域 VMA 串联起来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vm_area_struct 结构中的 vm_next ，vm_prev 指针分别指向 VMA 节点所在双向链表中的后继节点和前驱节点，内核中的这个 VMA 双向链表是有顺序的，所有 VMA 节点按照低地址到高地址的增长方向排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双向链表中的最后一个 VMA 节点的 vm_next 指针指向 NULL，双向链表的头指针存储在内存描述符 struct mm_struct 结构中的 mmap 中，正是这个 mmap 串联起了整个虚拟内存空间中的虚拟内存区域。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;mm_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;vm_area_struct&lt;/span&gt; *&lt;span&gt;mmap&lt;/span&gt;;&lt;/span&gt;  &lt;span&gt;/* list of VMAs */&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在每个虚拟内存区域 VMA 中又通过 struct vm_area_struct 中的 vm_mm 指针指向了所属的虚拟内存空间 mm_struct。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT9micXwnnJLk1icdR1KJeSMqiarDJX8venibtYAMAl0LG4lMlSpNDlRUFCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过 &lt;code&gt;cat /proc/pid/maps&lt;/code&gt; 或者 &lt;code&gt;pmap pid&lt;/code&gt; 查看进程的虚拟内存空间布局以及其中包含的所有内存区域。这两个命令背后的实现原理就是通过遍历内核中的这个 vm_area_struct 双向链表获取的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核中关于这些虚拟内存区域的操作除了遍历之外还有许多需要根据特定虚拟内存地址在虚拟内存空间中查找特定的虚拟内存区域。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其在进程虚拟内存空间中包含的内存区域 VMA 比较多的情况下，使用红黑树查找特定虚拟内存区域的时间复杂度是 O( logN ) ，可以显著减少查找所需的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在内核中，同样的内存区域 vm_area_struct 会有两种组织形式，一种是双向链表用于高效的遍历，另一种就是红黑树用于高效的查找。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 VMA 区域都是红黑树中的一个节点，通过 struct vm_area_struct 结构中的 vm_rb 将自己连接到红黑树中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而红黑树中的根节点存储在内存描述符 struct mm_struct 中的 mm_rb 中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;mm_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;rb_root&lt;/span&gt; &lt;span&gt;mm_rb&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7741935483870968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTkDjSrw0Zfl8RI3ibrp7ST6kibrgBvybgFxSGodZnGiarqNCUY2l5f6dBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 程序编译后的二进制文件如何映射到虚拟内存空间中&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过前边这么多小节的内容介绍，现在我们已经熟悉了进程虚拟内存空间的布局，以及内核如何管理这些虚拟内存区域，并对进程的虚拟内存空间有了一个完整全面的认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们再来回到最初的起点，进程的虚拟内存空间 mm_struct 以及这些虚拟内存区域 vm_area_struct 是如何被创建并初始化的呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42338709677419356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTcWU7wiaNM09r9pblewZhVPCvyicMIv9WhP1UXq4OxrKRf5f3ptIXwDLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 《3. 进程虚拟内存空间》小节中，我们介绍进程的虚拟内存空间时提到，我们写的程序代码编译之后会生成一个 ELF 格式的二进制文件，这个二进制文件中包含了程序运行时所需要的元信息，比如程序的机器码，程序中的全局变量以及静态变量等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 ELF 格式的二进制文件中的布局和我们前边讲的虚拟内存空间中的布局类似，也是一段一段的，每一段包含了不同的元数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;磁盘文件中的段我们叫做 Section，内存中的段我们叫做 Segment，也就是内存区域。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;磁盘文件中的这些 Section 会在进程运行之前加载到内存中并映射到内存中的 Segment。通常是多个 Section 映射到一个 Segment。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如磁盘文件中的 .text，.rodata 等一些只读的 Section，会被映射到内存的一个只读可执行的 Segment 里（代码段）。而 .data，.bss 等一些可读写的 Section，则会被映射到内存的一个具有读写权限的 Segment 里（数据段，BSS 段）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这些 ELF 格式的二进制文件中的 Section 是如何加载并映射进虚拟内存空间的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核中完成这个映射过程的函数是 load_elf_binary ，这个函数的作用很大，加载内核的是它，启动第一个用户态进程 init 的是它，fork 完了以后，调用 exec 运行一个二进制程序的也是它。当 exec 运行一个二进制程序的时候，除了解析 ELF 的格式之外，另外一个重要的事情就是建立上述提到的内存映射。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;load_elf_binary&lt;/span&gt;&lt;span&gt;(struct linux_binprm *bprm)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;      ...... 省略 ........&lt;br/&gt;  &lt;span&gt;// 设置虚拟内存空间中的内存映射区域起始地址 mmap_base&lt;/span&gt;&lt;br/&gt;  setup_new_exec(bprm);&lt;br/&gt;&lt;br/&gt;     ...... 省略 ........&lt;br/&gt;  &lt;span&gt;// 创建并初始化栈对应的 vm_area_struct 结构。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 设置 mm-&amp;gt;start_stack 就是栈的起始地址也就是栈底，并将 mm-&amp;gt;arg_start 是指向栈底的。&lt;/span&gt;&lt;br/&gt;  retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),&lt;br/&gt;         executable_stack);&lt;br/&gt;&lt;br/&gt;     ...... 省略 ........&lt;br/&gt;  &lt;span&gt;// 将二进制文件中的代码部分映射到虚拟内存空间中&lt;/span&gt;&lt;br/&gt;  error = elf_map(bprm-&amp;gt;file, load_bias + vaddr, elf_ppnt,&lt;br/&gt;        elf_prot, elf_flags, total_size);&lt;br/&gt;&lt;br/&gt;     ...... 省略 ........&lt;br/&gt; &lt;span&gt;// 创建并初始化堆对应的的 vm_area_struct 结构&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 设置 current-&amp;gt;mm-&amp;gt;start_brk = current-&amp;gt;mm-&amp;gt;brk，设置堆的起始地址 start_brk，结束地址 brk。 起初两者相等表示堆是空的&lt;/span&gt;&lt;br/&gt;  retval = set_brk(elf_bss, elf_brk, bss_prot);&lt;br/&gt;&lt;br/&gt;     ...... 省略 ........&lt;br/&gt;  &lt;span&gt;// 将进程依赖的动态链接库 .so 文件映射到虚拟内存空间中的内存映射区域&lt;/span&gt;&lt;br/&gt;  elf_entry = load_elf_interp(&amp;amp;loc-&amp;gt;interp_elf_ex,&lt;br/&gt;              interpreter,&lt;br/&gt;              &amp;amp;interp_map_addr,&lt;br/&gt;              load_bias, interp_elf_phdata);&lt;br/&gt;&lt;br/&gt;     ...... 省略 ........&lt;br/&gt;  &lt;span&gt;// 初始化内存描述符 mm_struct&lt;/span&gt;&lt;br/&gt;  current-&amp;gt;mm-&amp;gt;end_code = end_code;&lt;br/&gt;  current-&amp;gt;mm-&amp;gt;start_code = start_code;&lt;br/&gt;  current-&amp;gt;mm-&amp;gt;start_data = start_data;&lt;br/&gt;  current-&amp;gt;mm-&amp;gt;end_data = end_data;&lt;br/&gt;  current-&amp;gt;mm-&amp;gt;start_stack = bprm-&amp;gt;p;&lt;br/&gt;&lt;br/&gt;     ...... 省略 ........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;setup_new_exec 设置虚拟内存空间中的内存映射区域起始地址 mmap_base&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;setup_arg_pages 创建并初始化栈对应的 vm_area_struct 结构。置 mm-&amp;gt;start_stack 就是栈的起始地址也就是栈底，并将 mm-&amp;gt;arg_start 是指向栈底的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;elf_map 将 ELF 格式的二进制文件中.text ，.data，.bss 部分映射到虚拟内存空间中的代码段，数据段，BSS 段中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;set_brk 创建并初始化堆对应的的 vm_area_struct 结构，设置 &lt;code&gt;current-&amp;gt;mm-&amp;gt;start_brk = current-&amp;gt;mm-&amp;gt;brk&lt;/code&gt;，设置堆的起始地址 start_brk，结束地址 brk。 起初两者相等表示堆是空的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;load_elf_interp 将进程依赖的动态链接库 .so 文件映射到虚拟内存空间中的内存映射区域&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;初始化内存描述符 mm_struct&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 内核虚拟内存空间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经知道了进程虚拟内存空间在内核中的布局以及管理，那么内核态的虚拟内存空间又是什么样子的呢？本小节笔者就带大家来一层一层地拆开这个黑盒子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前在介绍进程虚拟内存空间的时候，笔者提到不同进程之间的虚拟内存空间是相互隔离的，彼此之间相互独立，相互感知不到其他进程的存在。使得进程以为自己拥有所有的内存资源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7258064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTLINE1jjQPxBJrZqwwSMJgMP6WHR0rLxsICVroYUN5HQv7Kk5a8aS3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而内核态虚拟内存空间是所有进程共享的，不同进程进入内核态之后看到的虚拟内存空间全部是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么意思呢？比如上图中的进程 a，进程 b，进程 c 分别在各自的用户态虚拟内存空间中访问虚拟地址 x 。由于进程之间的用户态虚拟内存空间是相互隔离相互独立的，虽然在进程a，进程b，进程c 访问的都是虚拟地址 x 但是看到的内容却是不一样的（背后可能映射到不同的物理内存中）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是当进程 a，进程 b，进程 c 进入到内核态之后情况就不一样了，由于内核虚拟内存空间是各个进程共享的，所以它们在内核空间中看到的内容全部是一样的，比如进程 a，进程 b，进程 c 在内核态都去访问虚拟地址 y。这时它们看到的内容就是一样的了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里笔者和大家澄清一个经常被误解的概念：由于内核会涉及到物理内存的管理，所以很多人会想当然地认为只要进入了内核态就开始使用物理地址了，这就大错特错了，千万不要这样理解，进程进入内核态之后使用的仍然是虚拟内存地址，只不过在内核中使用的虚拟内存地址被限制在了内核态虚拟内存空间范围中，这也是本小节笔者要为大家介绍的主题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在清楚了这个基本概念之后，下面笔者分别从 32 位体系 和 64 位体系下为大家介绍内核态虚拟内存空间的布局。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 32 位体系内核虚拟内存空间布局&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边《5.1 内核如何划分用户态和内核态虚拟内存空间》小节中我们提到，内核在 &lt;code&gt;/arch/x86/include/asm/page_32_types.h&lt;/code&gt; 文件中通过 TASK_SIZE 将进程虚拟内存空间和内核虚拟内存空间分割开来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/*&lt;br/&gt; * User space process size: 3GB (default).&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; TASK_SIZE       __PAGE_OFFSET&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;__PAGE_OFFSET 的值在 32 位系统下为 0xC000 000&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9048387096774193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT4tbtfaNT1ztoudqt3UE8ia6RtNNbtUe1siaGb7b1Dre087AnhxlnWMSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 32 位体系结构下进程用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000 。内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节我们主要关注 0xC000 000 - 0xFFFF FFFF 这段虚拟内存地址区域也就是内核虚拟内存空间的布局情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1.1 直接映射区&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在总共大小 1G 的内核虚拟内存空间中，位于最前边有一块 896M 大小的区域，我们称之为直接映射区或者线性映射区，地址范围为 3G -- 3G + 896m 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以这块 896M 大小的区域称为直接映射区或者线性映射区，是因为这块连续的虚拟内存地址会映射到 0 - 896M 这块连续的物理内存上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说 3G -- 3G + 896m 这块 896M 大小的虚拟内存会直接映射到 0 - 896M 这块 896M 大小的物理内存上，&lt;strong&gt;这块区域中的虚拟内存地址直接减去 0xC000 0000 (3G) 就得到了物理内存地址&lt;/strong&gt;。所以我们称这块区域为直接映射区。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为了方便为大家解释，我们假设现在机器上的物理内存为 4G 大小&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5233870967741936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTFnmSNJxcOXI7TxpbhdNzgJnvDt81tMEyFGsnNic5DZx9L2mkn77RLmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;虽然这块区域中的虚拟地址是直接映射到物理地址上，但是内核在访问这段区域的时候还是走的虚拟内存地址，内核也会为这块空间建立映射页表。关于页表的概念笔者后续会为大家详细讲解，这里大家只需要简单理解为页表保存了虚拟地址到物理地址的映射关系即可。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;大家这里只需要记得内核态虚拟内存空间的前 896M 区域是直接映射到物理内存中的前 896M 区域中的，直接映射区中的映射关系是一比一映射。映射关系是固定的不会改变&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明白了这个关系之后，我们接下来就看一下这块直接映射区域在物理内存中究竟存的是什么内容~~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段 896M 大小的物理内存中，前 1M 已经在系统启动的时候被系统占用，1M 之后的物理内存存放的是内核代码段，数据段，BSS 段（这些信息起初存放在 ELF格式的二进制文件中，在系统启动的时候被加载进内存）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们可以通过 &lt;code&gt;cat /proc/iomem&lt;/code&gt; 命令查看具体物理内存布局情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们使用 fork 系统调用创建进程的时候，内核会创建一系列进程相关的描述符，比如之前提到的进程的核心数据结构 task_struct，进程的内存空间描述符 mm_struct，以及虚拟内存区域描述符 vm_area_struct 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些进程相关的数据结构也会存放在物理内存前 896M 的这段区域中，当然也会被直接映射至内核态虚拟内存空间中的 3G -- 3G + 896m 这段直接映射区域中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7741935483870968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTkDjSrw0Zfl8RI3ibrp7ST6kibrgBvybgFxSGodZnGiarqNCUY2l5f6dBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当进程被创建完毕之后，在内核运行的过程中，会涉及内核栈的分配，内核会为每个进程分配一个固定大小的内核栈（一般是两个页大小，依赖具体的体系结构），每个进程的整个调用链必须放在自己的内核栈中，内核栈也是分配在直接映射区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与进程用户空间中的栈不同的是，内核栈容量小而且是固定的，用户空间中的栈容量大而且可以动态扩展。内核栈的溢出危害非常巨大，它会直接悄无声息的覆盖相邻内存区域中的数据，破坏数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上内容的介绍我们了解到内核虚拟内存空间最前边的这段 896M 大小的直接映射区如何与物理内存进行映射关联，并且清楚了直接映射区主要用来存放哪些内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写到这里，笔者觉得还是有必要再次从功能划分的角度为大家介绍下这块直接映射区域。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道内核对物理内存的管理都是以页为最小单位来管理的，每页默认 4K 大小，理想状况下任何种类的数据页都可以存放在任何页框中，没有什么限制。比如：存放内核数据，用户数据，缓冲磁盘数据等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是实际的计算机体系结构受到硬件方面的限制制约，间接导致限制了页框的使用方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在 X86 体系结构下，ISA 总线的 DMA （直接内存存取）控制器，只能对内存的前16M 进行寻址，这就导致了 ISA 设备不能在整个 32 位地址空间中执行 DMA，只能使用物理内存的前 16M 进行 DMA 操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此直接映射区的前 16M 专门让内核用来为 DMA 分配内存，这块 16M 大小的内存区域我们称之为 ZONE_DMA。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用于 DMA 的内存必须从 ZONE_DMA 区域中分配。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而直接映射区中剩下的部分也就是从 16M 到 896M（不包含 896M）这段区域，我们称之为 ZONE_NORMAL。从字面意义上我们可以了解到，这块区域包含的就是正常的页框（使用没有任何限制）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZONE_NORMAL 由于也是属于直接映射区的一部分，对应的物理内存 16M 到 896M 这段区域也是被直接映射至内核态虚拟内存空间中的 3G + 16M 到 3G + 896M 这段虚拟内存上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.510483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT8zuLLYT3jE5gI1XxxuhpM1Qlg82wzlwGPNy9Bl8xCo5dYdKxY2Oqzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意这里的 ZONE_DMA 和 ZONE_NORMAL 是内核针对物理内存区域的划分。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在物理内存中的前 896M 的区域也就是前边介绍的 ZONE_DMA 和 ZONE_NORMAL 区域到内核虚拟内存空间的映射笔者就为大家介绍完了，它们都是采用直接映射的方式，一比一就行映射。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1.2  ZONE_HIGHMEM 高端内存&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而物理内存 896M 以上的区域被内核划分为 ZONE_HIGHMEM 区域，我们称之为高端内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本例中我们的物理内存假设为 4G，高端内存区域为 4G - 896M = 3200M，那么这块 3200M 大小的 ZONE_HIGHMEM 区域该如何映射到内核虚拟内存空间中呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于内核虚拟内存空间中的前 896M 虚拟内存已经被直接映射区所占用，而在 32 体系结构下内核虚拟内存空间总共也就 1G 的大小，这样一来内核剩余可用的虚拟内存空间就变为了 1G - 896M = 128M。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然物理内存中 3200M 大小的 ZONE_HIGHMEM 区域无法继续通过直接映射的方式映射到这 128M 大小的虚拟内存空间中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来物理内存中的 ZONE_HIGHMEM 区域就只能采用动态映射的方式映射到 128M 大小的内核虚拟内存空间中，也就是说只能动态的一部分一部分的分批映射，先映射正在使用的这部分，使用完毕解除映射，接着映射其他部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了 ZONE_HIGHMEM 区域的映射原理，我们接着往下看这 128M 大小的内核虚拟内存空间究竟是如何布局的？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.510483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTPbibvHGL4nm4dwdjUSHEAAGN8RBUweEasfbqZRfXmJ4ogqz6zZWoGPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核虚拟内存空间中的 3G + 896M 这块地址在内核中定义为 high_memory，high_memory 往上有一段 8M 大小的内存空洞。空洞范围为：high_memory 到  VMALLOC_START 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VMALLOC_START 定义在内核源码 &lt;code&gt;/arch/x86/include/asm/pgtable_32_areas.h&lt;/code&gt; 文件中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; VMALLOC_OFFSET (8 * 1024 * 1024)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; VMALLOC_START ((unsigned long)high_memory + VMALLOC_OFFSET)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1.3 vmalloc 动态映射区&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来 VMALLOC_START 到 VMALLOC_END 之间的这块区域成为动态映射区。采用动态映射的方式映射物理内存中的高端内存。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;ifdef&lt;/span&gt; CONFIG_HIGHMEM&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# &lt;span&gt;define&lt;/span&gt; VMALLOC_END (PKMAP_BASE - 2 * PAGE_SIZE)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# &lt;span&gt;define&lt;/span&gt; VMALLOC_END (LDT_BASE_ADDR - 2 * PAGE_SIZE)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4241935483870968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTZHjzia2OcPveiaAD6Sjj44WzTVu7xMB3dqHlZqzX6IDdWh8Ouwf5XvmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和用户态进程使用 malloc 申请内存一样，在这块动态映射区内核是使用 vmalloc 进行内存分配。由于之前介绍的动态映射的原因，vmalloc 分配的内存在虚拟内存上是连续的，但是物理内存是不连续的。通过页表来建立物理内存与虚拟内存之间的映射关系，从而可以将不连续的物理内存映射到连续的虚拟内存上。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由于 vmalloc 获得的物理内存页是不连续的，因此它只能将这些物理内存页一个一个地进行映射，在性能开销上会比直接映射大得多。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 vmalloc 分配内存的相关实现原理，笔者会在后面的文章中为大家讲解，这里大家只需要明白它在哪块虚拟内存区域中活动即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1.4 永久映射区&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4241935483870968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTfdtjLnvoyuauI7AeWzkv3MnrW4vmX8sAp7dyP7OGEZxFFuM1icNjqWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 PKMAP_BASE 到 FIXADDR_START 之间的这段空间称为永久映射区。在内核的这段虚拟地址空间中允许建立与物理高端内存的长期映射关系。比如内核通过 alloc_pages() 函数在物理内存的高端内存中申请获取到的物理内存页，这些物理内存页可以通过调用 kmap 映射到永久映射区中。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;LAST_PKMAP 表示永久映射区可以映射的页数限制。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; PKMAP_BASE  \&lt;br/&gt; ((LDT_BASE_ADDR - PAGE_SIZE) &amp;amp; PMD_MASK)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; LAST_PKMAP 1024&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1.5 固定映射区&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4508064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTr7KEhCehnXzscf3hkJudYmFbLFialcUax2icKHKzmcfia7jZrOPRt6yqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核虚拟内存空间中的下一个区域为固定映射区，区域范围为：FIXADDR_START 到 FIXADDR_TOP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FIXADDR_START 和 FIXADDR_TOP 定义在内核源码 &lt;code&gt;/arch/x86/include/asm/fixmap.h&lt;/code&gt; 文件中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; FIXADDR_START  (FIXADDR_TOP - FIXADDR_SIZE)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; __FIXADDR_TOP; &lt;span&gt;// 0xFFFF F000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; FIXADDR_TOP ((unsigned long)__FIXADDR_TOP)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在内核虚拟内存空间的直接映射区中，直接映射区中的虚拟内存地址与物理内存前 896M 的空间的映射关系都是预设好的，一比一映射。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在固定映射区中的虚拟内存地址可以自由映射到物理内存的高端地址上，但是与动态映射区以及永久映射区不同的是，在固定映射区中虚拟地址是固定的，而被映射的物理地址是可以改变的。也就是说，有些虚拟地址在编译的时候就固定下来了，是在内核启动过程中被确定的，而这些虚拟地址对应的物理地址不是固定的。采用固定虚拟地址的好处是它相当于一个指针常量（常量的值在编译时确定），指向物理地址，如果虚拟地址不固定，则相当于一个指针变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么会有固定映射这个概念呢 ?  比如：在内核的启动过程中，有些模块需要使用虚拟内存并映射到指定的物理地址上，而且这些模块也没有办法等待完整的内存管理模块初始化之后再进行地址映射。因此，内核固定分配了一些虚拟地址，这些地址有固定的用途，使用该地址的模块在初始化的时候，将这些固定分配的虚拟地址映射到指定的物理地址上去。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1.6  临时映射区&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在内核虚拟内存空间中的最后一块区域为临时映射区，那么这块临时映射区是用来干什么的呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4508064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT4aicM8rSpYHlFgD5OLCRuMvUhOKyLdTXJlibOEQfpU36mJibR6iadWjb0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者在之前文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247486623&amp;amp;idx=1&amp;amp;sn=0cafed9e89b60d678d8c88dc7689abda&amp;amp;chksm=ce77cad8f90043ceaaca732aaaa7cb692c1d23eeb6c07de84f0ad690ab92d758945807239cee&amp;amp;token=1276722624&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《从 Linux 内核角度探秘 JDK NIO 文件读写本质》&lt;/a&gt; 的 “ 12.3 iov_iter_copy_from_user_atomic ” 小节中介绍在 Buffered IO 模式下进行文件写入的时候，在下图中的第四步，内核会调用 iov_iter_copy_from_user_atomic 函数将用户空间缓冲区 DirectByteBuffer 中的待写入数据拷贝到 page cache 中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2209677419354839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTicjf8r1WkxeUKn3NeibYpn7KNyI4ub2oGAcEpIP33a5OIfqdaicDkl5mA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是内核又不能直接进行拷贝，因为此时从 page cache 中取出的缓存页 page 是物理地址，而在内核中是不能够直接操作物理地址的，只能操作虚拟地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那怎么办呢？所以就需要使用 kmap_atomic 将缓存页临时映射到内核空间的一段虚拟地址上，这段虚拟地址就位于内核虚拟内存空间中的临时映射区上，然后将用户空间缓存区 DirectByteBuffer 中的待写入数据通过这段映射的虚拟地址拷贝到 page cache 中的相应缓存页中。这时文件的写入操作就已经完成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于是临时映射，所以在拷贝完成之后，调用 kunmap_atomic 将这段映射再解除掉。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;size_t&lt;/span&gt; &lt;span&gt;iov_iter_copy_from_user_atomic&lt;/span&gt;&lt;span&gt;(struct page *page,&lt;br/&gt;    struct iov_iter *i, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;size_t&lt;/span&gt; bytes)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 将缓存页临时映射到内核虚拟地址空间的临时映射区中&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; *kaddr = kmap_atomic(page), &lt;br/&gt;  *p = kaddr + offset;&lt;br/&gt;  &lt;span&gt;// 将用户缓存区 DirectByteBuffer 中的待写入数据拷贝到文件缓存页中&lt;/span&gt;&lt;br/&gt;  iterate_all_kinds(i, bytes, v,&lt;br/&gt;    copyin((p += v.iov_len) - v.iov_len, v.iov_base, v.iov_len),&lt;br/&gt;    memcpy_from_page((p += v.bv_len) - v.bv_len, v.bv_page,&lt;br/&gt;         v.bv_offset, v.bv_len),&lt;br/&gt;    &lt;span&gt;memcpy&lt;/span&gt;((p += v.iov_len) - v.iov_len, v.iov_base, v.iov_len)&lt;br/&gt;  )&lt;br/&gt;  &lt;span&gt;// 解除内核虚拟地址空间与缓存页之间的临时映射，这里映射只是为了临时拷贝数据用&lt;/span&gt;&lt;br/&gt;  kunmap_atomic(kaddr);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; bytes;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1.7 32位体系结构下 Linux 虚拟内存空间整体布局&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到现在为止，整个内核虚拟内存空间在 32 位体系下的布局，笔者就为大家详细介绍完毕了，我们再次结合前边《4.1 32 位机器上进程虚拟内存空间分布》小节中介绍的进程虚拟内存空间和本小节介绍的内核虚拟内存空间来整体回顾下 32 位体系结构 Linux 的整个虚拟内存空间的布局：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1096774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTQxKjhIG7yiaBooWo0d4VPwd7lvblpzKYx192ibwVB1kY5CDBUhNWa1gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 64 位体系内核虚拟内存空间布局&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核虚拟内存空间在 32 位体系下只有 1G 大小，实在太小了，因此需要精细化的管理，于是按照功能分类划分除了很多内核虚拟内存区域，这样就显得非常复杂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到了 64 位体系下，内核虚拟内存空间的布局和管理就变得容易多了，因为进程虚拟内存空间和内核虚拟内存空间各自占用 128T 的虚拟内存，实在是太大了，我们可以在这里边随意翱翔，随意挥霍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此在 64 位体系下的内核虚拟内存空间与物理内存的映射就变得非常简单，由于虚拟内存空间足够的大，即便是内核要访问全部的物理内存，直接映射就可以了，不在需要用到《7.1.2 ZONE_HIGHMEM 高端内存》小节中介绍的高端内存那种动态映射方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边《5.1 内核如何划分用户态和内核态虚拟内存空间》小节中我们提到，内核在 &lt;code&gt;/arch/x86/include/asm/page_64_types.h&lt;/code&gt; 文件中通过 TASK_SIZE 将进程虚拟内存空间和内核虚拟内存空间分割开来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; TASK_SIZE  (test_thread_flag(TIF_ADDR32) ? \&lt;br/&gt;     IA32_PAGE_OFFSET : TASK_SIZE_MAX)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; TASK_SIZE_MAX  task_size_max()&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; task_size_max()  ((_AC(1,UL) &amp;lt;&amp;lt; __VIRTUAL_MASK_SHIFT) - PAGE_SIZE)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; __VIRTUAL_MASK_SHIFT 47&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;64 位系统中的 TASK_SIZE 为 0x00007FFFFFFFF000&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9919354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTO7TLSnvKsLicbW38ZEcgMibdJBHl0icAjRG0P8J1pzOM4KofkFTlbFjeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;64位地址空间.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 64 位系统中，只使用了其中的低 48 位来表示虚拟内存地址。其中用户态虚拟内存空间为低 128 T，虚拟内存地址范围为：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核态虚拟内存空间为高 128 T，虚拟内存地址范围为：0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节我们主要关注 0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 这段内核虚拟内存空间的布局情况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.082258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTu02UOSu8wdLWmrpjbyJQ30xXvGRsqkW32icicawDI8kSrwicx7WhyEf1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;64 位内核虚拟内存空间从 0xFFFF 8000 0000 0000 开始到 0xFFFF 8800 0000 0000 这段地址空间是一个 8T 大小的内存空洞区域。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧着着 8T 大小的内存空洞下一个区域就是 64T 大小的直接映射区。这个区域中的虚拟内存地址减去 PAGE_OFFSET 就直接得到了物理内存地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PAGE_OFFSET 变量定义在 &lt;code&gt;/arch/x86/include/asm/page_64_types.h&lt;/code&gt; 文件中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; __PAGE_OFFSET_BASE      _AC(0xffff880000000000, UL)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; __PAGE_OFFSET           __PAGE_OFFSET_BASE&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中 VMALLOC_START 到 VMALLOC_END 的这段区域是 32T 大小的 vmalloc 映射区，这里类似用户空间中的堆，内核在这里使用 vmalloc 系统调用申请内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VMALLOC_START 和  VMALLOC_END 变量定义在 &lt;code&gt;/arch/x86/include/asm/pgtable_64_types.h&lt;/code&gt; 文件中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; __VMALLOC_BASE_L4 0xffffc90000000000UL&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; VMEMMAP_START  __VMEMMAP_BASE_L4&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; VMALLOC_END  (VMALLOC_START + (VMALLOC_SIZE_TB &amp;lt;&amp;lt; 40) - 1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 VMEMMAP_START 开始是 1T 大小的虚拟内存映射区，用于存放物理页面的描述符 struct page 结构用来表示物理内存页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VMEMMAP_START 变量定义在 &lt;code&gt;/arch/x86/include/asm/pgtable_64_types.h&lt;/code&gt; 文件中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; __VMEMMAP_BASE_L4 0xffffea0000000000UL&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# &lt;span&gt;define&lt;/span&gt; VMEMMAP_START  __VMEMMAP_BASE_L4&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 __START_KERNEL_map 开始是大小为 512M 的区域用于存放内核代码段、全局变量、BSS 等。这里对应到物理内存开始的位置，减去 __START_KERNEL_map 就能得到物理内存的地址。这里和直接映射区有点像，但是不矛盾，因为直接映射区之前有 8T 的空洞区域，早就过了内核代码在物理内存中加载的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;__START_KERNEL_map 变量定义在 &lt;code&gt;/arch/x86/include/asm/page_64_types.h&lt;/code&gt; 文件中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; __START_KERNEL_map  _AC(0xffffffff80000000, UL)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2.1 64位体系结构下 Linux 虚拟内存空间整体布局&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到现在为止，整个内核虚拟内存空间在 64 位体系下的布局笔者就为大家详细介绍完毕了，我们再次结合前边《4.2 64 位机器上进程虚拟内存空间分布》小节介绍的进程虚拟内存空间和本小节介绍的内核虚拟内存空间来整体回顾下 64 位体系结构 Linux 的整个虚拟内存空间的布局：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1024193548387098&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTXmRqaPO5z5RrOjseNbic1LiaUN1o1C8THRicxZicictv5xm46KkUy5gmLMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 到底什么是物理内存地址&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聊完了虚拟内存，我们接着聊一下物理内存，我们平时所称的内存也叫随机访问存储器（ random-access memory ）也叫 RAM 。而 RAM 分为两类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一类是静态 RAM（ &lt;code&gt;SRAM&lt;/code&gt; ），这类 SRAM 用于 CPU 高速缓存 L1Cache，L2Cache，L3Cache。其特点是访问速度快，访问速度为 1 - 30 个时钟周期，但是容量小，造价高。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTJ5alHgqgibtia7vjXBkR000djmOfzEsYTWoA46W7elZV9iaSNwWV90IXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU缓存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;另一类则是动态 RAM ( &lt;code&gt;DRAM&lt;/code&gt; )，这类 DRAM 用于我们常说的主存上，其特点的是访问速度慢（相对高速缓存），访问速度为 50 - 200 个时钟周期，但是容量大，造价便宜些（相对高速缓存）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存由一个一个的存储器模块（memory module）组成，它们插在主板的扩展槽上。常见的存储器模块通常以 64 位为单位（ 8 个字节）传输数据到存储控制器上或者从存储控制器传出数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTiajJYbncwV0Oia7M1QABIbJ97ne8vGujGCsaUTuPEA3tS0JupaN2tcCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;450&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示内存条上黑色的元器件就是存储器模块（memory module）。多个存储器模块连接到存储控制器上，就聚合成了主存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTeFKnMiaONgEVaoQJmovBnGLO9ksqEUbued8YhQoavJ9VnxLXa6K9y2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 DRAM 芯片就包装在存储器模块中，每个存储器模块中包含 8 个 DRAM 芯片，依次编号为 0 - 7 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5225806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTlrGGlRuia5pOWnVCYfTlag58YNb6KtouDTRk3a3aibVIrE0g96nja57w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;存储器模块.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而每一个 DRAM 芯片的存储结构是一个二维矩阵，二维矩阵中存储的元素我们称为超单元（supercell），每个 supercell 大小为一个字节（8 bit）。每个 supercell 都由一个坐标地址（i，j）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;i 表示二维矩阵中的行地址，在计算机中行地址称为 RAS (row access strobe，行访问选通脉冲)。
j 表示二维矩阵中的列地址，在计算机中列地址称为 CAS (column access strobe,列访问选通脉冲)。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图中的 supercell 的 RAS = 2，CAS = 2。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4161290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTia6GWhFXBFDnxVpNDS6dXIYshGib6JUibddicqmuNjo04XC65rY2yTrGhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DRAM 芯片中的信息通过引脚流入流出 DRAM 芯片。每个引脚携带 1 bit的信号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中 DRAM 芯片包含了两个地址引脚( &lt;code&gt;addr&lt;/code&gt; )，因为我们要通过 RAS，CAS 来定位要获取的 supercell 。还有 8 个数据引脚（&lt;code&gt;data&lt;/code&gt;），因为 DRAM 芯片的 IO 单位为一个字节（8 bit），所以需要 8 个 data 引脚从 DRAM 芯片传入传出数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意这里只是为了解释地址引脚和数据引脚的概念，实际硬件中的引脚数量是不一定的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 DRAM 芯片的访问&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在就以读取上图中坐标地址为（2，2）的 supercell 为例，来说明访问 DRAM 芯片的过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6290322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTZezPX4v7jrWqCtPQU5PVS8knFfGavYFtdBwVjZfUGs3RzoV1nn8jYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM芯片访问.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先存储控制器将行地址 RAS = 2 通过地址引脚发送给 DRAM 芯片。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DRAM 芯片根据 RAS = 2 将二维矩阵中的第二行的全部内容拷贝到内部行缓冲区中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接下来存储控制器会通过地址引脚发送 CAS = 2 到 DRAM 芯片中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DRAM芯片从内部行缓冲区中根据 CAS = 2 拷贝出第二列的 supercell 并通过数据引脚发送给存储控制器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;DRAM 芯片的 IO 单位为一个 supercell ，也就是一个字节(8 bit)。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 CPU 如何读写主存&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了内存的物理结构，以及如何访问内存中的 DRAM 芯片获取 supercell 中存储的数据（一个字节）。本小节我们来介绍下 CPU 是如何访问内存的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4443548387096774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTfY776YyT3I63PTt9uVeCufTuU54A5ovp7N7vqt5XuwwcbmmyBsvicDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU与内存之间的总线结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 与内存之间的数据交互是通过总线（bus）完成的，而数据在总线上的传送是通过一系列的步骤完成的，这些步骤称为总线事务（bus transaction）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中数据从内存传送到 CPU 称之为读事务（read transaction），数据从 CPU 传送到内存称之为写事务（write transaction）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总线上传输的信号包括：地址信号，数据信号，控制信号。其中控制总线上传输的控制信号可以同步事务，并能够标识出当前正在被执行的事务信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当前这个事务是到内存的？还是到磁盘的？或者是到其他 IO 设备的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个事务是读还是写？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总线上传输的地址信号（物理内存地址），还是数据信号（数据）？。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;这里大家需要注意总线上传输的地址均为物理内存地址&lt;/strong&gt;。比如：在 MESI 缓存一致性协议中当 CPU core0 修改字段 a 的值时，其他 CPU 核心会在总线上嗅探字段 a 的&lt;strong&gt;物理内存地址&lt;/strong&gt;，如果嗅探到总线上出现字段 a 的&lt;strong&gt;物理内存地址&lt;/strong&gt;，说明有人在修改字段 a，这样其他 CPU 核心就会失效字段 a 所在的 cache line 。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，其中系统总线是连接 CPU 与 IO bridge 的，存储总线是来连接 IO bridge 和主存的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IO bridge 负责将系统总线上的电子信号转换成存储总线上的电子信号。IO bridge 也会将系统总线和存储总线连接到IO总线（磁盘等IO设备）上。这里我们看到 IO bridge 其实起的作用就是转换不同总线上的电子信号。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.3 CPU 从内存读取数据过程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 CPU 现在需要将物理内存地址为 A 的内容加载到寄存器中进行运算。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大家需要注意的是 CPU 只会访问虚拟内存，在操作总线之前，需要把虚拟内存地址转换为物理内存地址，总线上传输的都是物理内存地址，这里省略了虚拟内存地址到物理内存地址的转换过程，这部分内容笔者会在后续文章的相关章节详细为大家讲解，这里我们聚焦如果通过物理内存地址读取内存数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4596774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT72O3UQ0t2nJB8YD8u44h1Cbr3DdCSxZ2yY7nfee5qOUeoQ1gC6IiaRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU读取内存.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先 CPU 芯片中的总线接口会在总线上发起读事务（read transaction）。 该读事务分为以下步骤进行：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU 将物理内存地址 A 放到系统总线上。随后 IO bridge 将信号传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主存感受到存储总线上的地址信号并通过存储控制器将存储总线上的物理内存地址 A 读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器通过物理内存地址 A 定位到具体的存储器模块，从 DRAM 芯片中取出物理内存地址 A 对应的数据 X。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器将读取到的数据 X 放到存储总线上，随后 IO bridge 将存储总线上的数据信号转换为系统总线上的数据信号，然后继续沿着系统总线传递。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU 芯片感受到系统总线上的数据信号，将数据从系统总线上读取出来并拷贝到寄存器中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是 CPU 读取内存数据到寄存器中的完整过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是其中还涉及到一个重要的过程，这里我们还是需要摊开来介绍一下，那就是存储控制器如何通过物理内存地址 A 从主存中读取出对应的数据 X 的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们结合前边介绍的内存结构以及从 DRAM 芯片读取数据的过程，来总体介绍下如何从主存中读取数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.4 如何根据物理内存地址从主存中读取数据&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边介绍到，当主存中的存储控制器感受到了存储总线上的地址信号时，会将内存地址从存储总线上读取出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会通过内存地址定位到具体的存储器模块。还记得内存结构中的存储器模块吗 ？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTeFKnMiaONgEVaoQJmovBnGLO9ksqEUbued8YhQoavJ9VnxLXa6K9y2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而每个存储器模块中包含了 8 个 DRAM 芯片，编号从 0 - 7 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5225806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTlrGGlRuia5pOWnVCYfTlag58YNb6KtouDTRk3a3aibVIrE0g96nja57w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;存储器模块.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储控制器会将&lt;strong&gt;物理内存地址&lt;/strong&gt;转换为 DRAM 芯片中 supercell 在二维矩阵中的坐标地址(RAS，CAS)。并将这个坐标地址发送给对应的存储器模块。随后存储器模块会将 RAS 和 CAS 广播到存储器模块中的所有 DRAM 芯片。依次通过 (RAS，CAS) 从 DRAM0 到 DRAM7 读取到相应的 supercell 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6290322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTZezPX4v7jrWqCtPQU5PVS8knFfGavYFtdBwVjZfUGs3RzoV1nn8jYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM芯片访问.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道一个 supercell 存储了一个字节（ 8 bit ） 数据，这里我们从 DRAM0 到 DRAM7 依次读取到了 8 个 supercell 也就是 8 个字节，然后将这 8 个字节返回给存储控制器，由存储控制器将数据放到存储总线上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CPU 总是以 word size 为单位从内存中读取数据，在 64 位处理器中的 word size 为 8 个字节。64 位的内存每次只能吞吐 8 个字节。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU 每次会向内存读写一个 cache line 大小的数据（ 64 个字节），但是内存一次只能吞吐 8 个字节。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在物理内存地址对应的存储器模块中，DRAM0 芯片存储第一个低位字节（ supercell ），DRAM1 芯片存储第二个字节，......依次类推 DRAM7 芯片存储最后一个高位字节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6540322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTfdypa7oUmDksZq4YldUaRkVEYggYibu4wtlf0GCdBxT6VKMlCKU1obQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;读取存储器模块数据.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于存储器模块中这种由 8 个 DRAM 芯片组成的物理存储结构的限制，内存读取数据只能是按照物理内存地址，8 个字节 8 个字节地顺序读取数据。所以说内存一次读取和写入的单位是 8 个字节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4685483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImToQMMG7NSnwNQdV7oicnkcibdAyfFNPrt6beM4CicSGexMicMsUaMGdRvPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存IO单位.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且在程序员眼里连续的物理内存地址实际上在物理上是不连续的。因为这连续的 8 个字节其实是存储于不同的 DRAM 芯片上的。每个 DRAM 芯片存储一个字节（supercell）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.5 CPU 向内存写入数据过程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在假设 CPU 要将寄存器中的数据 X 写到物理内存地址 A 中。同样的道理，CPU 芯片中的总线接口会向总线发起写事务（write transaction）。写事务步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU 将要写入的物理内存地址 A 放入系统总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过 IO bridge 的信号转换，将物理内存地址 A 传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器感受到存储总线上的地址信号，将物理内存地址 A 从存储总线上读取出来，并等待数据的到达。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU 将寄存器中的数据拷贝到系统总线上，通过 IO bridge 的信号转换，将数据传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器感受到存储总线上的数据信号，将数据从存储总线上读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器通过内存地址 A 定位到具体的存储器模块，最后将数据写入存储器模块中的 8 个 DRAM 芯片中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们从虚拟内存地址开始聊起，一直到物理内存地址结束，包含的信息量还是比较大的。首先笔者通过一个进程的运行实例为大家引出了内核引入虚拟内存空间的目的及其需要解决的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们有了虚拟内存空间的概念之后，笔者又近一步为大家介绍了内核如何划分用户态虚拟内存空间和内核态虚拟内存空间，并在次基础之上分别从 32 位体系结构和 64 位体系结构的角度详细阐述了 Linux 虚拟内存空间的整体布局分布。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们可以通过 &lt;code&gt;cat /proc/pid/maps&lt;/code&gt; 或者 &lt;code&gt;pmap pid&lt;/code&gt; 命令来查看进程用户态虚拟内存空间的实际分布。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;还可以通过 &lt;code&gt;cat /proc/iomem&lt;/code&gt; 命令来查看进程内核态虚拟内存空间的的实际分布。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们清楚了  Linux 虚拟内存空间的整体布局分布之后，笔者又介绍了 Linux 内核如何对分布在虚拟内存空间中的各个虚拟内存区域进行管理，以及每个虚拟内存区域的作用。在这个过程中还介绍了相关的内核数据结构，近一步从内核源码实现角度加深大家对虚拟内存空间的理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后笔者介绍了物理内存的结构，以及 CPU 如何通过物理内存地址来读写内存中的数据。这里笔者需要特地再次强调的是 CPU 只会访问虚拟内存地址，只不过在操作总线之前，通过一个地址转换硬件将虚拟内存地址转换为物理内存地址，然后将物理内存地址作为地址信号放在总线上传输，由于地址转换的内容和本文主旨无关，考虑到文章的篇幅以及复杂性，笔者就没有过多的介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，本文的全部内容到这里就结束了，感谢大家的收看，我们下篇文章见~~~&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2MzU3Mjc3Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZ9qpdibKBrYASLXXicypdMcnlrAGcicnHQyWYNZvic3C5OpgEicMDGsAcibZTKiaNECcNXDKJiaIBr2XGTow/0?wx_fmt=png&quot; data-nickname=&quot;bin的技术小屋&quot; data-alias=&quot;&quot; data-signature=&quot;专注源码解析系列原创技术文章，分享自己的技术感悟。谈笑有鸿儒，往来无白丁。无丝竹之乱耳，无案牍之劳形。斯是陋室，惟吾德馨。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>afc319970bb3c8395a78255962dede0e</guid>
<title>Redis 大 key 多 key 拆分方案</title>
<link>https://toutiao.io/k/4yfxfj2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;pre&gt;&lt;h4/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;大家好，我是不才陈某~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务场景中经常会有各种大key多key的情况， 比如：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1：单个简单的key存储的value很大&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2：hash， set，zset，list 中存储过多的元素（以万为单位）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3：一个集群存储了上亿的key，Key 本身过多也带来了更多的空间占用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（如无意外，文章中所提及的hash，set等数据结构均指redis中的数据结构   ）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于redis是单线程运行的，如果一次操作的value很大会对整个redis的响应时间造成负面影响，所以，业务上能拆则拆，下面举几个典型的分拆方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1：单个简单的key存储的value很大&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; i：该对象需要每次都整存整取&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以尝试将对象分拆成几个key-value， 使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响；    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ii：该对象每次只需要存取部分数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以像第一种做法一样，分拆成几个key-value，  也可以将这个存储在一个hash中，每个field代表一个具体的属性，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用hget,hmget来获取部分的value，使用hset，hmset来更新部分属性    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2：value中存储过多的元素&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类似于场景一种的第一个做法，可以将这些元素分拆。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以hash为例，原先的正常存取流程是  hget(hashKey, field) ; hset(hashKey, field, value)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在，固定一个桶的数量，比如 10000， 每次存取的时候，先在本地计算field的hash值，模除 10000， 确定了该field落在哪个key上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;newHashKey  =  hashKey + ( set, zset, list 也可以类似上述做法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但有些不适合的场景，比如，要保证 lpop 的数据的确是最早push到list中去的，这个就需要一些附加的属性，或者是在 key的拼接上做一些工作（比如list按照时间来分拆）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3：一个集群存储了上亿的key&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果key的个数过多会带来更多的内存空间占用，&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      i：key本身的占用（每个key 都会有一个Category前缀）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      ii：集群模式中，服务端需要建立一些slot2key的映射关系，这其中的指针占用在key多的情况下也是浪费巨大空间&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      这两个方面在key个数上亿的时候消耗内存十分明显（Redis 3.2及以下版本均存在这个问题，4.0有优化）；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以减少key的个数可以减少内存消耗，可以参考的方案是转Hash结构存储，即原先是直接使用Redis String 的结构存储，现在将多个key存储在一个Hash结构中，具体场景参考如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       一：key 本身就有很强的相关性，比如多个key 代表一个对象，每个key是对象的一个属性，这种可直接按照特定对象的特征来设置一个新Key——Hash结构， 原先的key则作为这个新Hash 的field。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;举例说明： &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原先存储的三个key &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;user.zhangsan-id = 123;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;user.zhangsan-age = 18; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;user.zhangsan-country = china;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这三个key本身就具有很强的相关特性，转成Hash存储就像这样 key =  user.zhangsan&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;field:id = 123; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;field:age = 18; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;field:country = china;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即redis中存储的是一个key ：user.zhangsan， 他有三个 field， 每个field + key 就对应原先的一个key。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      二：key 本身没有相关性，预估一下总量，采取和上述第二种场景类似的方案，预分一个固定的桶数量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      比如现在预估key 的总数为 2亿，按照一个hash存储 100个field来算，需要 2亿 /  100  = 200W 个桶 (200W 个key占用的空间很少，2亿可能有将近 20G )&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原先比如有三个key   ：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;user.123456789  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;user.987654321&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;user.678912345&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在按照200W 固定桶分就是先计算出桶的序号 hash(123456789)   % 200W ， 这里最好保证这个 hash算法的值是个正数，否则需要调整下模除的规则；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样算出三个key 的桶分别是     1 ， 2， 2。   所以存储的时候调用API    hset(key,  field, value)，读取的时候使用  hget （key， field）   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18853974121996303&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j65LNUfAhtpuRflkjfqZeVYOg4yCTGpxJEnsKb1MGqRc47QJXHbwByQnJO63GKeQrmK6OmswcgLKTQ2Yia7nKqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意两个地方：1，hash 取模对负数的处理；  2，预分桶的时候， 一个hash 中存储的值最好不要超过 512 ，100 左右较为合适&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4：大Bitmap或布隆过滤器（Bloom ）拆分&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用bitmap或布隆过滤器的场景，往往是数据量极大的情况，在这种情况下，Bitmap和布隆过滤器使用空间也比较大，比如用于公司userid匹配的布隆过滤器，就需要512MB的大小，这对redis来说是绝对的大value了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种场景下，我们就需要对其进行拆分，拆分为足够小的Bitmap，比如将512MB的大Bitmap拆分为1024个512KB的Bitmap。不过拆分的时候需要注意，要将每个key落在一个Bitmap上。有些业务只是把Bitmap 拆开， 但还是当做一个整体的bitmap看， 所以一个 key 还是落在多个 Bitmap 上，这样就有可能导致一个key请求需要查询多个节点、多个Bitmap。如下图，被请求的值被hash到多个Bitmap上，也就是redis的多个key上，这些key还有可能在不同节点上，这样拆分显然大大降低了查询的效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8553054662379421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j65LNUfAhtpuRflkjfqZeVYOg4yCTGpxpBOrsg9a3QZoIjErSVn1ZMzbVsqsDeYCbbYnmrAqCY7CqD4qRIwYEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;311&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此我们所要做的是把所有拆分后的Bitmap当作独立的bitmap，然后通过hash将不同的key分配给不同的bitmap上，而不是把所有的小Bitmap当作一个整体。这样做后每次请求都只要取redis中一个key即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2991913746630728&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j65LNUfAhtpuRflkjfqZeVYOg4yCTGpxynvMwe4N4icMn5ic399WyTkiaNRl9XDKDgXqtM0ObMpR8ibITD2UgTtIOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;371&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有同学可能会问，通过这样拆分后，相当于Bitmap变小了，会不会增加布隆过滤器的误判率？实际上是不会的，布隆过滤器的误判率是哈希函数个数k，集合元素个数n，以及Bitmap大小m所决定的，其约等于&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32786885245901637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j65LNUfAhtpuRflkjfqZeVYOg4yCTGpxRsVjiarmfRd1ibOPOwQcLlKISbnSe7KBxkUXmKhciaYJInibodiaAZuOJZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;244&quot;/&gt;&lt;span&gt;&lt;span&gt;。因此如果我们在第一步，也就是在分配key给不同Bitmap时，能够尽可能均匀的拆分，那么n／m的值几乎是一样的，误判率也就不会改变。具体的误判率推导可以参考&lt;/span&gt;wiki：Bloom_filter&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时，客户端也提供便利的api （&amp;gt;=2.3.4版本）， setBits/ getBits 用于一次操作同一个key的多个bit值 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;建议 ：k 取 13 个， 单个bloomfilter控制在 512KB 以下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上方案仅供参考，欢迎大家提供其他的优秀方案。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后说一句（别白嫖，求关注）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;陈某每一篇文章都是精心输出，已经写了&lt;span&gt;3个专栏&lt;/span&gt;，整理成&lt;span&gt;PDF&lt;/span&gt;，获取方式如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;amp;action=getalbum&amp;amp;album_id=2042874937312346114#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Spring Cloud 进阶》&lt;/a&gt;PDF：关注公众号：【&lt;span&gt;码猿技术专栏&lt;/span&gt;】回复关键词 &lt;span&gt;Spring Cloud 进阶&lt;/span&gt; 获取！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;amp;action=getalbum&amp;amp;album_id=1532834475389288449#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Spring Boot 进阶》&lt;/a&gt;PDF：关注公众号：【&lt;span&gt;码猿技术专栏&lt;/span&gt;】回复关键词 &lt;span&gt;Spring Boot进阶&lt;/span&gt; 获取！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;amp;action=getalbum&amp;amp;album_id=1500819225232343046#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Mybatis 进阶》&lt;/a&gt;PDF：关注公众号：【&lt;span&gt;码猿技术专栏&lt;/span&gt;】回复关键词 &lt;span&gt;Mybatis 进阶&lt;/span&gt; 获取！&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对你有所帮助，或者有所启发的话，帮忙&lt;span&gt;点赞&lt;/span&gt;、&lt;span&gt;在看&lt;/span&gt;、&lt;span&gt;转发&lt;/span&gt;、&lt;span&gt;收藏&lt;/span&gt;，你的支持就是我坚持下去的最大动力！&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU3MDAzNDg1MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rA07Je2pY1o0ic2KcPRn44icO8GVcKRdwiaYvrE6bNeTbWPicyV7c7jWmSyzsiaWASjjckzBcsJMJw06pA/0?wx_fmt=png&quot; data-nickname=&quot;码猿技术专栏&quot; data-alias=&quot;oneswholife&quot; data-signature=&quot;前蚂蚁P8，纯粹的技术人，以专栏的形式分享java全栈技术：SSM、Spring全家桶、微服务、MySQL、分布式、中间件、Linux、偶尔讲点运维Jenkins、Nexus、Docker、ELK..&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dcfa7730e0b473809e609519a07b23d3</guid>
<title>安全漏洞：SpringBoot 该如何预防 XSS 攻击？</title>
<link>https://toutiao.io/k/o3wesfc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2ibq0p8cfjxRlTHl0reqRwBcTwYuTvbW8SL1VImm163MGgkBZiaojCCiazEnQz49QOTicbqXAdtvoywg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span&gt;👆&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;长按 &lt;/span&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;关注&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt; 此公众号，&lt;span&gt;技术干货，及时送达&lt;/span&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;👆&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写此文章的目的是为了记录一下在工作中解决的 XSS漏洞 问题。XSS漏洞是生产上比较常见的问题。虽然是比较常见并且是基本的安全问题，但是我们没有做🙄️ ，也怪我没有安全意识。于是终于有一天被制裁了。所以这次就补上了，记录一下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看看问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XSS 漏洞到底是什么，说实话我讲不太清楚。但是可以通过遇到的现象了解一下。在前端Form表单的输入框中，用户没有正常输入，而是输入了一段代码：&lt;code&gt;&amp;lt;/input&amp;gt;&amp;lt;img src=1 onerror=alert1&amp;gt;&lt;/code&gt;这个正常保存没有问题。问题出在了列表查询的时候，上面的代码就生效了，由于图片的地址乱写的，所以这个alert就起作用了来看图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;102&quot; data-ratio=&quot;0.1819672131147541&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iccLKyfqr2YLepblQGNjKsGy58emVwGzDks7fLErPvtjicaSgiacELujmCKvJf6Zm6pKB64q7KoMBPa4wjCa8jOZQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;610&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那根据这个原理，实际上如果没有做任何的限制，有心人就可以为所欲为了。可以在里面嵌入一些关键代码，把你的信息拿走。确实是个很严重的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解决思路&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然是因为输入框中输入了不该输入的东西，那自然就萌生一些想法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;校验输入内容&lt;/strong&gt;，不允许用户输入特殊字符，特殊标签&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;允许用户输入&lt;/strong&gt;，但是保存的时候将特殊的字符直接替换为空串&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;允许用户输入&lt;/strong&gt;，将特殊字符转义保存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种方法，特殊字符过滤。既然要过滤特殊字符，那就得自己把所有的特殊字符列出来进行匹配，比较麻烦，而且要定义好什么才是特殊字符？况且用户本身不知道什么是特殊字符。突如其来的报错，会让用户有点摸不着头脑，不是很友好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种方法，特殊字符替换为空串。未免有点太暴力。万一真的需要输入一点特殊的字符，保存完查出来发现少了好多东西，人家以为我们的BUG呢。也不是很好的办法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三种办法，特殊字符转译。这个办法不但用户数据不丢失，而且浏览器也不会执行代码。比较符合预期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那办法确定了，怎么做呢？前端来做还是后端来做？想了想还是要后端来做。毕竟使用切面或者Filter可以一劳永逸。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;心路历程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过抄袭，我发现了一些问题，也渐渐地有了一些理解。下面再说几句废话：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查到的预防XSS攻击的，大多数的流程是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;拦截请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重新包装请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重写&lt;code&gt;HttpServletRequest&lt;/code&gt;中的获取参数的方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将获得的参数进行XSS处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拦截器放行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是我就逮住一个抄了一下。抄袭完毕例行测试，发现我用&lt;code&gt;@RequestBody&lt;/code&gt;接受的参数，并不能过滤掉特殊字符。怎么肥四？大家明明都这么写。为什么我的不好使？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候突然一个想法萌生。SpringMVC在处理&lt;code&gt;@RequestBody&lt;/code&gt;类型的参数的时候，是不是使用的我重写的这些方法呢？（&lt;code&gt;getQueryString()&lt;/code&gt;、&lt;code&gt;getParameter(String name)&lt;/code&gt;、&lt;code&gt;getParameterValues(String name)&lt;/code&gt;、&lt;code&gt;getParameterMap()&lt;/code&gt;）。打了个日志，发现还真不是这些方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是搜索了一下Springboot拦截器获取&lt;code&gt;@RequestBody&lt;/code&gt;参数，看到了这篇文章。首先的新发现是Spring MVC 在获取&lt;code&gt;@RequestBody&lt;/code&gt;参数的时候使用的是&lt;code&gt;getInputStream()&lt;/code&gt;方法。嗯？（斜眼笑）那我是不是可以重写这个方法获取到输入流的字符串，然后直接处理一下？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说干就干，一顿操作。进行测试。发现直接JSON 转换的报错了。脑裂。估计是获得的字符串在转换的时候把不该转的东西转译了，导致不能序列化了。眼看就要成功了，一测回到解放前。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该怎么办呢？其实思路是没错的，就是在获取到流之后进行处理。但是错就错在处理的位置。果然处理的时间点很重要。（就像伴侣一样，某人出现的时间点很重要）。那既然不能在现在处理，那就等他序列化完毕之后再处理就好了。那怎么办呢？难道要写一个AOP 拦截到所有的请求？用JAVA反射处理？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;正在迷茫的时候，看到了一篇文章，知识增加了。原来可以在序列化和反序列化的时候进行处理。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最终实现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下最终的代码实现（有些导入的包被我删了）&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;重新包装Request的代码&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; org.apache.commons.text.StringEscapeUtils;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.slf4j.Logger;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.slf4j.LoggerFactory;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.ReadListener;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.ServletInputStream;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.http.HttpServletRequest;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.http.HttpServletRequestWrapper;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.BufferedReader;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.ByteArrayInputStream;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.IOException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.InputStreamReader;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.charset.StandardCharsets;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Map;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 重新包装一下Request。重写一些获取参数的方法，将每个参数都进行过滤&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XSSHttpServletRequestWrapper&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;HttpServletRequestWrapper&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(XSSHttpServletRequestWrapper&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; HttpServletRequest request;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 请求体 RequestBody&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String reqBody;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Constructs a request object wrapping the given request.&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; request The request to wrap&lt;br/&gt;     * &lt;span&gt;@throws&lt;/span&gt; IllegalArgumentException if the request is null&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;XSSHttpServletRequestWrapper&lt;/span&gt;&lt;span&gt;(HttpServletRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(request);&lt;br/&gt;        logger.info(&lt;span&gt;&quot;---xss XSSHttpServletRequestWrapper created-----&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.request = request;&lt;br/&gt;        reqBody = getBodyString();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getQueryString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; StringEscapeUtils.escapeHtml4(&lt;span&gt;super&lt;/span&gt;.getQueryString());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * The default behavior of this method is to return getParameter(String&lt;br/&gt;     * name) on the wrapped request object.&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; name&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getParameter&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        logger.info(&lt;span&gt;&quot;---xss XSSHttpServletRequestWrapper work  getParameter-----&quot;&lt;/span&gt;);&lt;br/&gt;        String parameter = request.getParameter(name);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (StringUtil.isNotBlank(parameter)) {&lt;br/&gt;            logger.info(&lt;span&gt;&quot;----filter before--name:{}--value:{}----&quot;&lt;/span&gt;, name, parameter);&lt;br/&gt;            parameter = StringEscapeUtils.escapeHtml4(parameter);&lt;br/&gt;            logger.info(&lt;span&gt;&quot;----filter after--name:{}--value:{}----&quot;&lt;/span&gt;, name, parameter);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; parameter;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * The default behavior of this method is to return&lt;br/&gt;     * getParameterValues(String name) on the wrapped request object.&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; name&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; String[] getParameterValues(String name) {&lt;br/&gt;        logger.info(&lt;span&gt;&quot;---xss XSSHttpServletRequestWrapper work  getParameterValues-----&quot;&lt;/span&gt;);&lt;br/&gt;        String[] parameterValues = request.getParameterValues(name);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!CollectionUtil.isEmpty(parameterValues)) {&lt;br/&gt;         &lt;span&gt;// 经 “@Belief_7” 指正 这种方式不能更改parameterValues里面的值，要换成下面👇的写法&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//for (String value : parameterValues) {&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//    logger.info(&quot;----filter before--name:{}--value:{}----&quot;, name, value);&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//    value = StringEscapeUtils.escapeHtml4(value);&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//    logger.info(&quot;----filter after--name:{}--value:{}----&quot;, name, value);&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// }&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; parameterValues.length; i++) &lt;br/&gt;         { &lt;br/&gt;             parameterValues[i] = StringEscapeUtils.escapeHtml4(parameterValues[i]); &lt;br/&gt;         } &lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; parameterValues;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * The default behavior of this method is to return getParameterMap() on the&lt;br/&gt;     * wrapped request object.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String[]&amp;gt; getParameterMap() {&lt;br/&gt;        logger.info(&lt;span&gt;&quot;---xss XSSHttpServletRequestWrapper work  getParameterMap-----&quot;&lt;/span&gt;);&lt;br/&gt;        Map&amp;lt;String, String[]&amp;gt; map = request.getParameterMap();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !map.isEmpty()) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (String[] value : map.values()) {&lt;br/&gt;                &lt;span&gt;/*循环所有的value*/&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (String str : value) {&lt;br/&gt;                    logger.info(&lt;span&gt;&quot;----filter before--value:{}----&quot;&lt;/span&gt;, str, str);&lt;br/&gt;                    str = StringEscapeUtils.escapeHtml4(str);&lt;br/&gt;                    logger.info(&lt;span&gt;&quot;----filter after--value:{}----&quot;&lt;/span&gt;, str, str);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; map;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/*重写输入流的方法，因为使用RequestBody的情况下是不会走上面的方法的*/&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * The default behavior of this method is to return getReader() on the&lt;br/&gt;     * wrapped request object.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; BufferedReader &lt;span&gt;getReader&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        logger.info(&lt;span&gt;&quot;---xss XSSHttpServletRequestWrapper work  getReader-----&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(getInputStream()));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * The default behavior of this method is to return getInputStream() on the&lt;br/&gt;     * wrapped request object.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ServletInputStream &lt;span&gt;getInputStream&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        logger.info(&lt;span&gt;&quot;---xss XSSHttpServletRequestWrapper work  getInputStream-----&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;/*创建字节数组输入流*/&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; ByteArrayInputStream bais = &lt;span&gt;new&lt;/span&gt; ByteArrayInputStream(reqBody.getBytes(StandardCharsets.UTF_8));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletInputStream() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isFinished&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isReady&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setReadListener&lt;/span&gt;&lt;span&gt;(ReadListener listener)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; bais.read();&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取请求体&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; 请求体&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;getBodyString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        StringBuilder builder = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;        InputStream inputStream = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        BufferedReader reader = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            inputStream = request.getInputStream();&lt;br/&gt;&lt;br/&gt;            reader = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(inputStream));&lt;br/&gt;&lt;br/&gt;            String line;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; ((line = reader.readLine()) != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                builder.append(line);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            logger.error(&lt;span&gt;&quot;-----get Body String Error:{}----&quot;&lt;/span&gt;, e.getMessage(), e);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (inputStream != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    inputStream.close();&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                    logger.error(&lt;span&gt;&quot;-----get Body String Error:{}----&quot;&lt;/span&gt;, e.getMessage(), e);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (reader != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    reader.close();&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                    logger.error(&lt;span&gt;&quot;-----get Body String Error:{}----&quot;&lt;/span&gt;, e.getMessage(), e);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; builder.toString();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;定义过滤器&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; org.slf4j.Logger;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.slf4j.LoggerFactory;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.*;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.http.HttpServletRequest;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.IOException;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * Filter 过滤器，拦截请求转换为新的请求&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XssFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Filter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(XssFilter&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 初始化方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(FilterConfig filterConfig)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ServletException &lt;/span&gt;{&lt;br/&gt;        logger.info(&lt;span&gt;&quot;----xss filter start-----&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 过滤方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilter&lt;/span&gt;&lt;span&gt;(ServletRequest request, ServletResponse response, FilterChain chain)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;{&lt;br/&gt;        ServletRequest wrapper = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (request &lt;span&gt;instanceof&lt;/span&gt; HttpServletRequest) {&lt;br/&gt;            HttpServletRequest servletRequest = (HttpServletRequest) request;&lt;br/&gt;            wrapper = &lt;span&gt;new&lt;/span&gt; XSSHttpServletRequestWrapper(servletRequest);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == wrapper) {&lt;br/&gt;            chain.doFilter(request, response);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            chain.doFilter(wrapper, response);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;注册过滤器&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注册过滤器我了解到的有两种方式。我用的下面的这种&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种通过&lt;code&gt;@WebFilter&lt;/code&gt;注解的方式来配置，但这种启动类上要加&lt;code&gt;@ServletComponentScan&lt;/code&gt;注解来指定扫描路径&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一种就是以Bean 的方式来注入（不知道放哪里，就把Bean放到启动类里面）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * XSS 的Filter注入&lt;br/&gt; * 用来处理getParameter的参数&lt;br/&gt; * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; FilterRegistrationBean &lt;span&gt;xssFilterRegistrationBean&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    FilterRegistrationBean filterRegistrationBean = &lt;span&gt;new&lt;/span&gt; FilterRegistrationBean();&lt;br/&gt;    filterRegistrationBean.setFilter(&lt;span&gt;new&lt;/span&gt; XssFilter());&lt;br/&gt;    filterRegistrationBean.setOrder(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    filterRegistrationBean.setDispatcherTypes(DispatcherType.REQUEST);&lt;br/&gt;    filterRegistrationBean.setEnabled(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    filterRegistrationBean.addUrlPatterns(&lt;span&gt;&quot;/*&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; filterRegistrationBean;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面配的是使用&lt;code&gt;request.getParameter()&lt;/code&gt;的时候生效的,但是当我使用&lt;code&gt;@RequestBody&lt;/code&gt;来接收参数的时候是不行的，所以还得有下面的代码：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;处理请求中的JSON数据&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; com.fasterxml.jackson.core.JsonParser;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.fasterxml.jackson.core.JsonProcessingException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.fasterxml.jackson.databind.DeserializationContext;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.fasterxml.jackson.databind.JsonDeserializer;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.apache.commons.text.StringEscapeUtils;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.IOException;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 反序列化，用来处理请求中的JSON数据&lt;br/&gt; * 处理RequestBody方式接收的参数&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XssJacksonDeserializer&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;JsonDeserializer&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;deserialize&lt;/span&gt;&lt;span&gt;(JsonParser jp, DeserializationContext ctxt)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, JsonProcessingException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; StringEscapeUtils.escapeHtml4(jp.getText());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;处理返回值的JSON数据&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; com.fasterxml.jackson.core.JsonGenerator;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.fasterxml.jackson.databind.JsonSerializer;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.fasterxml.jackson.databind.SerializerProvider;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.apache.commons.text.StringEscapeUtils;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.IOException;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 处理向前端发送的JSON数据，将数据进行转译后发送&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XssJacksonSerializer&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;JsonSerializer&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;serialize&lt;/span&gt;&lt;span&gt;(String value, JsonGenerator jgen, SerializerProvider provider)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        jgen.writeString(StringEscapeUtils.escapeHtml4(value));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;注册、配置自定义的序列化方法&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;extendMessageConverters&lt;/span&gt;&lt;span&gt;(List&amp;lt;HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converters)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; Jackson2ObjectMapperBuilder builder = &lt;span&gt;new&lt;/span&gt; Jackson2ObjectMapperBuilder();&lt;br/&gt; ObjectMapper mapper = builder.build();&lt;br/&gt; &lt;span&gt;/*注入自定义的序列化工具，将RequestBody的参数进行转译后传输*/&lt;/span&gt;&lt;br/&gt;    SimpleModule simpleModule = &lt;span&gt;new&lt;/span&gt; SimpleModule();&lt;br/&gt;    &lt;span&gt;// XSS序列化&lt;/span&gt;&lt;br/&gt;    simpleModule.addSerializer(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;XssJacksonSerializer&lt;/span&gt;())&lt;/span&gt;;&lt;br/&gt;    simpleModule.addDeserializer(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;XssJacksonDeserializer&lt;/span&gt;())&lt;/span&gt;;&lt;br/&gt;    mapper.registerModule(simpleModule);&lt;br/&gt;    converters.add(&lt;span&gt;new&lt;/span&gt; MappingJackson2HttpMessageConverter(mapper));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;测试&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有东西都配置完了，接下来进行愉快的测试阶段了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我依然在输入框中输入这段代码&lt;code&gt;&amp;lt;/input&amp;gt;&amp;lt;img src=1 onerror=alert1&amp;gt;&lt;/code&gt;并进行保存。来看一下数据库中的保存结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;549&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;38&quot; data-ratio=&quot;0.0692167577413479&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iccLKyfqr2YLepblQGNjKsGy58emVwGzDxav8y9vbLIElfPicHDTOaNGJqDYJfsfxKpue9mOwbN8gr3eAx0bwAsA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到数据库中保存的数据，已经经过转译了。那查询一下列表是什么样的呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;301&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;149&quot; data-ratio=&quot;0.4950166112956811&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iccLKyfqr2YLepblQGNjKsGy58emVwGzDd9ZDdXolibPs2Jgosw0zhZyVUCg7iaiao6oME5lCzlOInFfJsZGE71q7Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;301&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到两条数据，上面的是我们经过转译的，正常的展示出来了。而下面的是没经过转译的，直接空白，并且给我弹了个窗。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;就是注意要分情况处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拦截器处理一部分，并注意拦截器的注册方式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Jackson的方式处理另一部分，也是注意配置方式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;补充&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码经过验证后，发现了一个问题。今天来补充一下。问题是这样的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用&lt;code&gt;@RequestBody&lt;/code&gt;的形式接受参数，也就是需要使用自定义的序列化方式。然而有时候，我们的业务需要传递一些JSON串到后端，如&lt;code&gt;{\&quot;username\&quot;:\&quot;zx\&quot;,\&quot;pwd\&quot;:\&quot;123\&quot;}&lt;/code&gt;（注意这是个字符串）。但是因为我不管三七二十一直接暴力转译，导致里面的双引号以及其他符号都被转译了。那么当我们拿到这个字符串之后，再自己反序列化的时候就会出错了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，我在自定义的序列化方法中判断了一下这个字段的值是否是JSON形式，如果是JSON形式，那就不做处理，直接返回，以保证能够顺利反序列化。判断是否是JSON的方式，我选择最简单的，判断首尾是否是&lt;code&gt;{ } [ ]&lt;/code&gt;的组合。代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XssJacksonDeserializer&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;JsonDeserializer&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;deserialize&lt;/span&gt;&lt;span&gt;(JsonParser jp, DeserializationContext ctxt)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, JsonProcessingException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 判断一下 值是不是JSON的格式，如果是JSON的话，那就不处理了。&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;/*判断JSON，可以用JSON.parse但是所有字段都Parse一下，未免有点太费性能，所以粗浅的认为，不是以{ 或者[ 开头的文本都不是JSON*/&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (isJson(jp.getText())) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; jp.getText();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; StringEscapeUtils.escapeHtml4(jp.getText());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 判断字符串是不是JSON&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; str&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isJson&lt;/span&gt;&lt;span&gt;(String str)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (StringUtil.isNotBlank(str)) {&lt;br/&gt;            str = str.trim();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (str.startsWith(&lt;span&gt;&quot;{&quot;&lt;/span&gt;) &amp;amp;&amp;amp; str.endsWith(&lt;span&gt;&quot;}&quot;&lt;/span&gt;)) {&lt;br/&gt;                result = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (str.startsWith(&lt;span&gt;&quot;[&quot;&lt;/span&gt;) &amp;amp;&amp;amp; str.endsWith(&lt;span&gt;&quot;]&quot;&lt;/span&gt;)) {&lt;br/&gt;                result = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是经过这样的改动之后，可能又没那么安全了。所以还是要看自己的取舍了。&lt;/p&gt;&lt;blockquote mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;来源：&lt;/span&gt;&lt;span&gt;blog.csdn.net/sinat_31420295/article/details/121519010&lt;/span&gt;&lt;/blockquote&gt;&lt;blockquote mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span&gt;版权声明：此内容来源网络，版权归原作者所有。我们转载的内容，都会注明来源，除非无法确认。若有侵权，烦请告知，我们会立即删除并表示歉意。谢谢！&lt;/span&gt;&lt;/blockquote&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;PS：文章若对您有用，请帮助 &lt;strong&gt;点赞、在看、转发&lt;/strong&gt; 吧！&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;公众号：Java精选&quot; data-id=&quot;91842&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;点击卡片关注我们，更多技术干货，及时为您送达！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzU0ODk2MzE3MA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib178LnVu9br0VUuI4OKYwvXKpZnaGseFG3vyFJShp2VFcwVodS88CkUsNYcLDrglYLHPFoic6MJD4A/0?wx_fmt=png&quot; data-nickname=&quot;逻魔代码&quot; data-alias=&quot;lomagicode&quot; data-signature=&quot;逻魔代码，分享架构技术干货，打造有价值的经验分享社群，帮助后继者以前人的肩膀为基，建造更精妙的技术殿堂！&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;20&quot;&gt;&lt;p mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;20&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485409&amp;amp;idx=1&amp;amp;sn=472dcdd83bd3154dc8dba024e8c5bb0c&amp;amp;chksm=fbb651ecccc1d8fa1747b5fcce10fb6e44a530d63a9ccd4914b7bc6ef53b983fe91d09c04fbf&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于CANVAS实现的多功能画板【建议收藏学习】&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基于CANVAS实现的多功能画板【建议收藏学习】&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485409&amp;amp;idx=2&amp;amp;sn=e82e7cd34d9faeee40d2022bc49f3464&amp;amp;chksm=fbb651ecccc1d8fab6f078bd79f8f7d53445f4ad7ac26055b5635670fe30927ef574e5a6a750&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;优雅地处理重复请求/并发请求&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;优雅地处理重复请求/并发请求&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485370&amp;amp;idx=1&amp;amp;sn=a5dc9c8df141cf83655c2ea0f235b09a&amp;amp;chksm=fbb651b7ccc1d8a121e32d113045a4cdfcfc550c314e4956386d899dd9c7ba649b83a31d9c7c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;ULID规范解读与实现原理&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;ULID规范解读与实现原理&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485347&amp;amp;idx=2&amp;amp;sn=84c4a6ed5cc4a8a4870a65422498f4b1&amp;amp;chksm=fbb651aeccc1d8b8bb47adc23497ecc7a3c026e221292bd084098eabe86fd7442a7f47d73711&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;谈谈MySQL字符集带来的一点存储影响&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;谈谈MySQL字符集带来的一点存储影响&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>