<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9ae64c6a9363e32b922d1ada3e5c28fb</guid>
<title>四个步骤，教你落地稳定性保障工作</title>
<link>https://toutiao.io/k/30q3q6w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2EWv8cAzu93UQTQJtkWjymmK6gUETiaxRHF193Ijxpmul0Z2c4l3G2Xw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;序-好记性不如烂笔头&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;稳定性是个啥？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一次接触稳定性这个词是在加入阿里第一年的双十一KO会上。接触到限流、扩容、压测等词汇，只觉得稳定性工作是琐碎的、繁杂的、无流程性的、无明确衡量指标的、无从下手的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;今年，我和两个小伙伴一起在稳定性保障工作中投入了大量的精力，我也从他们那里学到了不少关于稳定性保障相关知识，开始对稳定性工作有了一定的理解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;稳定性工作也是有条理有步骤的，按照步骤一步步来，就能够轻松将稳定性保障工作做全、做对、做好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所谓好记性不如烂笔头。趁机梳理记录下来，以便后续使用时能够信手拈来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;什么是稳定性保障&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;那么到底什么是稳定性保障呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据前人总结，稳定性保障就是保障系统的稳定，在各种不可预知的情况发生时仍然能够持续稳定的运行和提供服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;个人感觉稳定性保障很像一个水利工程。在应用系统中，水可以是用户流量，也可以是资金流。而稳定性工作就是保障这些水能够按照预定的渠道路径流淌，保障没有渗水、漏水、渠道垮塌的现象，或者出现这类现象也能够及时修复将损失降到最低。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35509904622157007&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2biaWTYVEnVDfdgL6s9yZL8azsnpeUzqqRMSGiaWQVn34tIu1UYhiaUrwQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;稳定性保障工作做什么&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;稳定性保障工作到底做什么？自然是实现稳定性保障目标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据前文稳定性保障的定义可知“&lt;strong&gt;在各种不可预知的情况发生时仍然能够持续稳定的运行和提供服务&lt;/strong&gt;”就是稳定性保障工作的目标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个目标怎么实现？还是一头雾水，无从下手。那是因为这个目标太大太虚了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;遇到一个大而虚的目标，可以使用目标细化分而治之的方式。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;需要如下图的红色虚线箭头所示的几个步骤。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8867579908675799&quot; data-type=&quot;png&quot; data-w=&quot;2190&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2IicoMurZZzsoWYSChjBsKQteAIicOC7oicBo0DhPakSW8IPhDMHGYdUMA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，将目标细分为子目标，可以通过&lt;strong&gt;抽取目标中的关键字定义子目标&lt;/strong&gt;。从“在各种不可预知的情况发生时仍然能够持续稳定的运行和提供服务”中可提取出 &lt;strong&gt;不可预知的情况、发生时、持续稳定、运行、提供服务&lt;/strong&gt;。这五个关键字就是稳定性保障工作的子目标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后，针对每个子目标进行提问，凡是自己有疑问的都罗列出来。包括但不限于对目标的理解类疑问、对目标实现的方法类疑问、对目标实现的标准类疑问。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;之后，对自己所有的疑问找出答案或解决方案。就像上学期间导师给出课题，自己去理解去解决的过程。这可能需要查阅资料、现状分析、方案选择、最终决策、实际落地。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如此，所有的子目标都将逐一实现，最终，子目标的实现进而完成终极目标的整体实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;综上，上图中最外层的淡蓝色圈中的内容就是我们为了实现稳定性保障目标所需要做的工作了。初看起来很多，细看下来隐有规律，再看之下发现本质就是这几点：什么现象？如何发现？什么影响？如何处理？现象、影响、处理方式都与具体异常耦合，发现靠监控告警。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总结起来就是：&lt;strong&gt;梳理异常情况-&amp;gt;配置监控告警-&amp;gt;评估影响面-&amp;gt;预定解决方案&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来，将从这四个步骤入手阐述稳定性保障工作具体如何落地。大框架先展示如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6402378592666006&quot; data-type=&quot;png&quot; data-w=&quot;2018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2cnAr4dxuQoBhyuzkzd3NglMV68GsaWKr4rdbnuMuUPpAHTsSiaZsOyA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;梳理异常情况&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;那么什么是异常情况？异常情况很多很琐碎啊，像RT飙高、消息队列阻塞、FullGC、NPE、数据异常、数据不一致、资金金额计算出错、数据库连接超时、网络异常、代码出现bug造成异常等等，这么多梳理起来如何保证覆盖率？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;继续使用前文的目标细化分而治之的方式，但此时目标细化无法通过拆分关键字实现了，此时可以&lt;strong&gt;通过类目细化的方式定义子目标&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对异常情况进行类目细化。从上面列出的这些异常情况可进行归类梳理，可见消息队列、数据库连接、FullGC等都是中间件导致的异常，而代码bug、数据不一致、资金金额算错这类异常属于开发写出的bug或者产品设计缺陷。综上，可将中间件这类异常定义为基础设施异常，bug和产品缺陷类的异常定义为业务功能异常。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;再反向梳理一下，基础设施异常包括网络、容量、连接、磁盘、缓存、JVM等等中间件或者底层硬件设施产生的异常；这类异常日常一般不会发生，只可能发生在大而突然的流量变化时，基础设施扛不住过大的流量导致异常。因此多发生在大促期间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务功能异常包括代码逻辑异常和资金异常。与业务功能息息相关，因此这类异常一般出现在每次业务逻辑的变更后，与日常需求相对应。可在每次业务需求开发的同时进行梳理，也可根据异常梳理结果在代码中预置开关和订正工具，万一上线后异常情况出现，就可使用预置开关和订正工具进行止血和修复。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;顺便提一下，根据异常的分类，平日里大家习惯性将稳定性保障工作分为日常稳定性保障和大促稳定性保障。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;配置监控告警&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;监控告警分为三类，基础设施监控告警、业务功能监控告警、资金安全监控告警。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基础设施监控告警一般都是在应用创建之初进行配置的，涵盖应用和所有的中间件、网络等。集团对基础监控告警的覆盖范围有明确规定。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务功能监控告警都是在日常业务功能开发时由开发人员配置的，用于监控特定的业务场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;资金安全监控告警主要面向与资金相关的应用，例如下单支付。如果没有就需要从0到1的创建，之后就随着每次业务功能开发进行增量式设置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大促前夕一般会对所有的监控告警进行梳理并查漏补缺。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;数据流向图&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;监控告警配置其实是个省略句，其完整的表达应该是：监控告警数据源的准备、监控告警配置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6875912408759124&quot; data-type=&quot;png&quot; data-w=&quot;1370&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2Zz6oA1hssvEd71dQ0nepePEYl7acDtPClZaPXdcjibCgNdicyKkfyS5g/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;监控告警的整体数据流向如上图所示。主要通过日志、消息、持久化数据作为数据源，将数据收集起来后用于监控告警的配置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中日志主要用于监控大盘展示，实时反应线上真是情况；消息主要用于实时核对的触发媒介，触发资金安全核对，资金安全核对通过采用旁路核对、资金一致性核对、两两核对等方式核对线上逻辑；持久化数据主要用于离线核对，通过两两核对的方式校验数据正确性。具体核对逻辑后文详述。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最终，监控核对都将告警信息汇总到告警系统，触发告警。同步到告警响应人进行处理。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;配置步骤&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;综上对监控告警的数据源及其流向有了了解，就可以按照以下步骤配置监控告警了：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6222760290556901&quot; data-type=&quot;png&quot; data-w=&quot;1652&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2UeE43lbu4nPtKrfiaiapBLkDZp4LuwFickyoxhSicAzIseLMyrEcyicVicUQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;值得一提的是，虽然先要有数据，才能配置监控。但是其实&lt;strong&gt;数据准备和监控配置这两者应该是并行的&lt;/strong&gt;。根据监控项的大概规划准备监控数据，然后进行监控告警配置，有任何数据不满足配置的情况都要返回进行数据准备步骤。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;个人认为一个监控的好坏评判标准主要通过三个指标：正确性、覆盖率、直观性。正确性保证监控的基本功能，能够正确的反应真实情况。没有正确性的监控毫无存在意义。覆盖率是衡量一个监控系统成功与否的关键指标，覆盖率越高，监控系统就越能够完美的体现系统的实际运行情况。直观的展示监控指标有助于快速发现异常、快速定位问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于告警，个人认为告警的配置最重要的是：及时性、有效性、责任制。告警出现一般都是有异常情况，可能涉及到资损或者故障，发现越及时，止血越及时，损失就越小。告警最终都是人工处理，无效的告警会浪费人力成本，因此告警配置要注意过滤噪音，保障告警的有效性，保证报出的确实是问题。至于责任制则是强调告警必须要有人响应，每条告警最好分配到人。有响应的告警才是最终有效的。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;资金安全核对&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;资金安全核对的本质是检查是否有资损事件的发生，做到及时报警快速止血，最终达到资损防控的目的。资金逻辑相比一般的业务逻辑存在一些共性，因此我们能够针对这些共性思考出一些通用的资金安全核对方法和资损防控措施。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于资金安全核对的方法论，根据前辈们的总结概括，资金安全问题主要是对资金关键要素的处理过程中出现异常导致的。资金关键要素的生命周期主要包含三个重要节点：生产、传递和消费。三个节点分别可能出现的错误为生产错误、漏传错传、消费错误。针对这些错误，前辈们提出三大核对方法，所谓核对，都是寻找有一个正确数据作为预期，将实际情况与预期数据进行对比核对。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7189384800965019&quot; data-type=&quot;png&quot; data-w=&quot;1658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2Bnicu7Vfhyr50qaodoticBmYsjFIxCG6EdvFHRdOGqia73LiaP6Zs29Z1g/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基线核对是将历史数据作为预期进行对比核对，这种方式依赖历史数据的正确性，投入少，实效低，可发现大的资金问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;两两核对将上游作为预期，进行对比核对，精准度高，时效性高，成本比较高，难以覆盖全面。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务逻辑核对将业务专家的经验作为预期进行核对，需要大量人力投入，对经验的依赖度高，但是精准度高，时效性高。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;面对资损防控，我们可以采用哪些具体的落地措施呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我的专攻资损防控的小伙伴做了很全面的总结归纳，如下图所示，资损防控的策略包括保存量、盘增量、控高危、盯特有。资损防控是一个长期的过程，需要时常维护，对存量布控不断优化保鲜；对新增变更进行资损评估，发布前卡点确认，保证有对应的核对规则；对于易资损场景和数据进行专项重保；对大促特有逻辑或者场景进行特别关注。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8437047756874095&quot; data-type=&quot;png&quot; data-w=&quot;1382&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU23bsPUfHaIXsclhArI3Yzj452Rm0s8GPkK51ReV7clXYzuyGxANic9rA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;资损防控，需要对全链路资金安全风险场景进行梳理，从失血类型、规则表达、规则类型、依赖因子等多方面分析资损场景，建立相应的失血模型。为保证快速、精确，可监听异步消息来进行实时核对，同时结合特定的错误日志告警，再加上小时级离线持久化数据核对兜底来保障资金安全。对于核对脚本，可通过组织review和攻防验证保障其正确性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;建立资损大盘，在大促高峰期值班期间安排专人盯盘，及时响应问题处理，同时对于高资损风险项预置必要的应急预案，在紧急情况发生时可以及时熔断止血以保障资金安全。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;预估影响面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;影响面自然也是和异常相关的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基础设施的异常分多种，例如程度较轻的仅仅是短期内的负载高，严重的某个中间件（例如MetaQ）不可用、机房断电，光缆被挖断。其异常的严重程度直接决定了影响面，可能错误率飙高、RT飙高、消息阻塞、FullGC频繁，影响到系统的持续稳定性，也可能系统瘫痪不可用、网络不可用、流量跌零。不过对于这种严重的异常一般不会发生。机房都是多机房部署，硬件容灾考虑有专门的团队去保障。中间件也要专门的团队运维保障。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;稳定性保障工作对于基础设施异常一般只考虑大促流量激增引起的容量不足、系统压力大等问题。这类问题的原因明确，就是流量过大。直接现象就是错误率飙高、RT飙高、消息阻塞、FullGC频繁等，较严重的情况下会引起客诉和舆情。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务功能异常就是错误，无论是逻辑异常还是资金计算错误，资金流转错误，本质上就是产品设计有缺、开发留下的bug或者某处配置有误。这类异常与具体的业务场景有关，小则仅影响某一个局部小功能，大则影响核心功能。可能引起客诉和舆情，资金异常可能导致资损。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;预定解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;前文大框架中，我们已经知道了预定的解决方案大概有限流、压测、扩容、预案等措施，那么这些解决方案具体如何落地呢？他们之间是否存在一定的顺序？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解决方案与异常类型强相关。不同的类型有不同的解决方案。因此解决方案也分为业务功能异常的解决方案和基础设施异常的解决方案。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;业务异常的解决方案&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;稳定性保障对于业务异常主要是从“万一发生了怎么办”这个角度出发去思考解决方案的。因此需要提前准备锦囊，以备不时之需。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务类异常的解决方案一般分为三类，止血解决方案、临时解决方案和长期解决方案。需要消耗的时间逐渐增多，对问题的解决程度逐渐增加。都是问题发生后的应对方案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;止血解决方案一般不需要走代码变更发布，通过预案、设置、开关等实现，通常也是需要提前有所计划，有所准备的。临时解决方案和长期解决方案一般需要走代码变更发布，耗时较长。因此遇到问题一般都先执行效率最高的止血解决方案，如果止血解决方案依旧承受较大的损失，就需要快速拿出临时方案来解决问题，临时方案虽然一定程度上解决了问题，但是可能存在一些小功能问题、性能问题或者优雅性方面的瑕疵。因此需要在问题得以缓解之后思考出一个稳定优雅的长期解决方案。当然，那已经是后话了，不属于稳定性保障的工作范畴。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于业务功能异常，在日常开发时就需要提前打算，准备好能够多维度多程度降级的开关或者设置，留作异常发生时紧急止血使用。也就是预案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;预案需要预演进行验证，保证预案配置和执行的正确性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3316008316008316&quot; data-type=&quot;png&quot; data-w=&quot;1924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU24lsbNsWXaKxQWhMvkTnaZb8XSCzTLamicuuIx32XTxdPvbnoT6qqSzQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;预案&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;预案的本质是一个或者多个能够快速改变代码逻辑的设置。例如开关、diamond配置或者其他工具，将这些配置跳过繁琐的审批流程、实现快速执行就是预案，&lt;strong&gt;是用于大促前期关闭非核心功能、大促期间紧急问题及时止血保障主要功能而选择断尾某些功能的操作配置。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;预案按照执行时间分为提前预案和应急预案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;提前预案是大促前期自动执行用于关闭非核心功能以保障核心功能的预案，例如日志降级等；这类预案一般不会造成损失，风险可控，影响面是业务和消费者都可接受的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;应急预案是大促期间发现线上问题，经过大促负责人审批同意后由相关测试或者开发人员手动执行，用于及时止血以保障主要功能的预案。这类预案类似于壁虎断尾的行为，舍弃小的损失，保留大的功能，因此一般都存在一定的损失。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;预案项需要提前梳理清楚，对功能无影响但是对性能无影响的锦上添花的部分在大促期间是是可以作为提前预案降级；对于可能出现异常情况的代码逻辑，或者评估风险较高的逻辑都要不吝增加开关设置，实现多维度降级（业务身份维度、商品类目维度、商家维度等等），在大促前夕配置好紧急预案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;预案设置越多越好，但是预案执行须谨慎。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;预案越多，能够快速应对的异常场景就越多，就越能够快速止血，当然也要考虑维护成本。但是配置预案的时候就要全面细致的评估清楚其执行影响，这样到了执行的时候才能正确选择合适大小的创可贴应对止血伤口。执行预案时须谨慎，按照大促要求走相应的流程，保证有double check。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;预演&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;预演就是预先演练一遍。包括功能预演、活动预演、预案预演等。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;基础设施异常的解决方案&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;稳定性保障对于基础设施异常主要是从“如何才能不发生”这个角度出发去思考解决方案的。因此需要提前修炼内功，增强自身实力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于基础设施异常，一旦发生，难以快速止血和修复。因此一般都是在大促前夕就要做足稳定性保障工作保证大促时不发生或者少发生这类异常，可通过压测、预演提前发现异常，提前提出解决方案进行修复处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如前文所述，对于基础设施异常，稳定性保障工作仅考虑流量过大导致的异常。因此这类异常的原因明确就是流量过大。其解决方案也就明确是解决流量问题，分为对外解决方案和对内解决方案。对外限流拒绝过多流量对自身进行保护，但限流需要基于容量预估，有考量有依据的设置。对内扩容增强自身实力，并提前预热做好应对准备。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;内外解决方案通过压测相互协调配合，最终达到一种权衡利弊后的和谐。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4368231046931408&quot; data-type=&quot;png&quot; data-w=&quot;1662&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2pN4NUTYCplGj8FD0YHRuibS7tyHMCRiaEFB7xLFib0PtxCwUibZFJG31bg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;综上，先要进行容量预估，预估外部流量峰值，再根据预估容量进行限流设置，然后进行压测，评估内部容量是否能够支撑预估容量，如果无法支撑，就要考虑扩容，扩容后根据机器数量进行限流调整，然后再次压测，压测后能够支撑预估容量甚至游刃有余时可以考虑再次调整限流，承载更多的流量。最后可以考虑在大促前进行缓存预热防止流量峰值击穿缓存。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;容量预估&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;容量评估要做的事情总结起来就是三件：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1、&lt;strong&gt;对上游：&lt;/strong&gt;询问预估流量，即他们要求我们的保障值。上游需要调用我们的服务，因此我们提供的服务量级需要满足他们的诉求。简言之，我们的水渠需要能够容纳得住从他们那里流下来的水流量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2、&lt;strong&gt;对自身：&lt;/strong&gt;梳理自身上下游链路，基于自身预估，根据上游诉求，预估对下游的诉求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3、&lt;strong&gt;对下游：&lt;/strong&gt;提供自己的预估容量，要求下游提供足够的容量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;自身容量如何预估呢？一般是通过以下几个方法进行：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1、&lt;strong&gt;梳理业务变化对流量影响：&lt;/strong&gt;业务逻辑每年都在变化，进而对流量有所影响。因此要梳理去年同一大促结束到今年大促之前这段时间内的业务变化，预估其对流量的影响量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2、&lt;strong&gt;参考往年同一大促容量值：&lt;/strong&gt;梳理往年同一大促的流量、峰值发生时间、整体流量走势；参考预估，没有影响流量的业务变化的情况下（理想情况），基本可以直接用来作为预估值。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3、&lt;strong&gt;参考同年之前的大促容量值：&lt;/strong&gt;梳理同年前一次大促的流量参考预估。对比往年两次大促的流量比例来预估，例如，如果去年618与双11的的流量比是1:2，那么可以将今年618的容量乘以2的值来作为今年双11的容量预估值。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4、结合上游诉求：收集到所有上游的诉求保障值，总结归纳。再对比自身预估容量。一般是两者取大。但是如果差异很大，就需要再认真核对，可能有预估错误或者遗漏。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.501&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU27cxsmicib4l21IvAn0RP3SnicGEmCTEKT6g9BwmpPSdAtUn6RByoZwu3g/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;对下游的诉求保障值如何预估呢？&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;限流&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;限流类似于水渠源头的闸门，这个闸门开的大小直接决定了水渠中的水流量。将闸门开启到一定程度，而非完全打开，保障水渠不至于被冲垮的行为就是限流。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;无论有没有扩容，&lt;strong&gt;无论系统是游刃有余还是苦苦支撑，都需要对系统进行限流。&lt;/strong&gt;限流是系统的门卫，超出的容量可以被拦截在外。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们一般都使用单机限流，即设置单台机器最大可接受的QPS，超过则触发限流，限流可以直接拒绝，即快速失败，也可以排队等待。单机限流可以进行调用来源应用维度的限流，可以对所有上游应用一概而论（流控应用设置为default），也可以因人而异保障主要业务（针对核心的应用限流设置较大，非核心的应用限流设置较小）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;也可以考虑集群限流，对整个集群进行限流。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;压测&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;所谓压测，就是构造数据流量通过几台压力机模拟用户持续并发请求系统接口，测试系统的性能和承受能力的过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;集团的压测分为单链路压测和全链路压测。所谓单链路压测，即自己的应用服务入口作为压测入口进行触发压测，主要面对的仅限于单个应用，涉及应用少，涉及人员少。全链路压测则从用户实际操作入口作为压测入口，这个操作涉及到的所有应用服务全部参与压测，是一个跨部门跨应用的过程，每次全链路压测，涉及到链路上所有团队的协调参与共同努力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;全链路压测更能反应线上真是情况。条件允许的情况下都选择全链路压测。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;集团的压测都会提前构造影子链路，即真实链路的影子，和真实链路一模一样，却又不会对真实链路产生影响。库表也是使用影子表，将压测的持久化数据与真实持久化数据分开。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;压测是一个复杂的过程，需要专业的压测团队的同学支撑。对于一个从未参加过压测的应用而言，要做的工作简要概括如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4264018691588785&quot; data-type=&quot;png&quot; data-w=&quot;1712&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2Jx3ApdvVNJ654UrXXb5vMlympVdRaITzny9n9YI26XBVpDY8RSNP8Q/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1、&lt;strong&gt;应用适配改造：&lt;/strong&gt;要走通压测链路，涉及改动较多，包括应用系统改造、nginx升级、中间件改造、缓存端升级、DB端升级等等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2、&lt;strong&gt;构造压测数据：&lt;/strong&gt;压测数据构造需要根据具体的业务。例如价保的压测，需要构造的压测数据是处于价保有效期内的订单。如果要压到申请链路，还要构造优惠制造差价。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3、&lt;strong&gt;创建压测模型：&lt;/strong&gt;所谓压测模型是指压测数据的分布情况，压测模型要能够反应线上真实流量占比。要覆盖到所有链路，不同业务的流量占比等同线上真实情况，中心机房和单元机房的流量比例也要按照线上比例分配。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4、&lt;strong&gt;进行压测：&lt;/strong&gt;压测分为单链路压测和全链路压测，单链路压测是指仅仅对自己关注的系统进行压测；全链路压测是从用户发起请求开始到整个业务逻辑结束的全部链路压测。压测入口也分为http接口压测和端上接口压测，具体根据系统情况而定。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5、&lt;strong&gt;观测与总结：&lt;/strong&gt;在压测的过程中，要时刻盯盘，观测系统水位。压测后总结梳理出压测报告。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;压测一般不是一次就能够完成的，可能因为各种原因导致压测结果不理想，因此要多次压测，每次根据压测问题进行修复后再次压测，直到压测结果符合预期为止。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图中只绘制了压测适配原因导致的重新压测，如前文所示扩容和限流后也要进行压测。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;扩容&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;扩容，就是暴力增加机器。所以也要考虑成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果压测的结果，系统无法达到上游诉求，为了保证业务的顺利进行。就需要扩容，并再次压测，直到系统能够保障目标容量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果压测的结果皆大欢喜，满足了上游诉求，那么就不需要扩容了。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;预热&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;预热可简单的理解为参赛前的热身。让容器、缓存、数据库等都准备好迎接大促的流量峰值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6673228346456693&quot; data-type=&quot;png&quot; data-w=&quot;2032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2RAxGD5raPxba1hBD1yiciaBm8HZX0oK7NMH8MjY66VMFhDthYAkG78nA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;预热分为缓存预热和启动预热。缓存预热属于大促稳定性保障工作，但是启动预热属于一种日常的性能优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;集团每年大促的商品预热是被人所熟知的。就是将热点商品提前加载进缓存中，避免大促期间缓存击穿，流量直接打挂db的情况。这就是缓存预热。多用于大量依赖缓存的应用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;启动预热一般是处理服务刚启动时服务RT较大甚至超时的问题，处理方式是在启动时通过构造参数，模拟真实请求的方式把代码跑热后再对外提供服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;稳定性保障工作从时间上来说，包括日常业务需求开发时的监控告警配置和开关预留，大促前夕的容量预估、压测、限流、扩容和预热，其实还有一部分，上文未及提及，那便是大促值班。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;建议在值班前写一个值班手册，将可能出现的问题，解决方案，需要使用到的工具链接全部罗列清楚，避免值班时手忙脚乱找资料找工具。还有必要的权限申请在值班前申请好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在大促期间，严阵以待，这个时候需要做到两动，主动关注监控大盘，注意流量变化，监控基础设施指标；被动关注告警，一旦被告警提醒就是有异常情况了，要立刻投入定位解决。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，稳定性保障工作是没有尽头的，其重要性不言而喻，但是也要在业务功能与稳定性之间做好权衡，如果稳定性核对的调用流量都超过了业务流量，那么稳定性工作就有点过了，从机器成本、人力成本上都没有这个必要。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文整理了自己对稳定性保障的认识和理解，可能存在理解有误或者认识不足的情况欢迎指正，也期待更多的学习逐渐修正和完善自己的稳定性相关知识。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;语雀产品评测，免费体验！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;🚀🚀🚀参与语雀产品评测，赢取语雀专业会员1年、语雀周边礼盒、阿里云定制冲锋衣等多重好礼🎁&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;点击阅读原文查看详情。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>83f6f87bb91caf1562eb5ee980759659</guid>
<title>万字总结 Redis 常见面试题！（上）</title>
<link>https://toutiao.io/k/ysgqxgz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;theme-hope-content&quot;&gt;&lt;h2 id=&quot;redis-基础&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-基础&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 基础&lt;/h2&gt;&lt;h3 id=&quot;什么是-redis&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#什么是-redis&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 什么是 Redis？&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://redis.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Redis&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。&lt;/p&gt;&lt;p&gt;为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap）。并且，Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。&lt;/p&gt;&lt;p&gt;Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。&lt;/p&gt;&lt;p&gt;个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的&lt;a href=&quot;https://try.redis.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;在线 Redis 环境&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;来实际体验 Redis。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/try.redis.io.png&quot; alt=&quot;try-redis&quot;/&gt;&lt;/p&gt;&lt;p&gt;全世界有非常多的网站使用到了 Redis ，&lt;a href=&quot;https://techstacks.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;techstacks.io&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 专门维护了一个&lt;a href=&quot;https://techstacks.io/tech/redis&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;使用 Redis 的热门站点列表&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; ，感兴趣的话可以看看。&lt;/p&gt;&lt;h3 id=&quot;redis-为什么这么快&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-为什么这么快&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 为什么这么快？&lt;/h3&gt;&lt;p&gt;Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Redis 基于内存，内存的访问速度是磁盘的上千倍；&lt;/li&gt;&lt;li&gt;Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；&lt;/li&gt;&lt;li&gt;Redis 内置了多种优化过后的数据结构实现，性能非常高。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面这张图片总结的挺不错的，分享一下，出自 &lt;a href=&quot;https://twitter.com/alexxubyte/status/1498703822528544770&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Why is Redis so fast?&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/assets/why-redis-so-fast.d3507ae8.png&quot; alt=&quot;why-redis-so-fast&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;分布式缓存常见的技术选型方案有哪些&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#分布式缓存常见的技术选型方案有哪些&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 分布式缓存常见的技术选型方案有哪些？&lt;/h3&gt;&lt;p&gt;分布式缓存的话，比较老牌同时也是使用的比较多的还是 &lt;strong&gt;Memcached&lt;/strong&gt; 和 &lt;strong&gt;Redis&lt;/strong&gt;。不过，现在基本没有看过还有项目使用 &lt;strong&gt;Memcached&lt;/strong&gt; 来做缓存，都是直接用 &lt;strong&gt;Redis&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。&lt;/p&gt;&lt;p&gt;另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV 存储数据库，基于知名的开源项目 &lt;a href=&quot;https://github.com/facebook/rocksdb&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;RocksDB&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型，名为 &lt;a href=&quot;https://github.com/Tencent/Tendis&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Tendis&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Redis vs Tendis：冷热混合存储版架构揭秘&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; ，可以简单参考一下。&lt;/p&gt;&lt;p&gt;从这个项目的 Github 提交记录可以看出，Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用 Tendis 来实现分布式缓存。&lt;/p&gt;&lt;h3 id=&quot;说一下-redis-和-memcached-的区别和共同点&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#说一下-redis-和-memcached-的区别和共同点&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 说一下 Redis 和 Memcached 的区别和共同点&lt;/h3&gt;&lt;p&gt;现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！&lt;/p&gt;&lt;p&gt;&lt;strong&gt;共同点&lt;/strong&gt; ：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;都是基于内存的数据库，一般都用来当做缓存使用。&lt;/li&gt;&lt;li&gt;都有过期策略。&lt;/li&gt;&lt;li&gt;两者的性能都非常高。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt; ：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Redis 支持更丰富的数据类型（支持更复杂的应用场景）&lt;/strong&gt;。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Redis 有灾难恢复机制。&lt;/strong&gt; 因为可以把缓存中的数据持久化到磁盘上。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。&lt;/strong&gt; （Redis 6.0 引入了多线程 IO ）&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。&lt;/p&gt;&lt;h3 id=&quot;为什么要用-redis-为什么要用缓存&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#为什么要用-redis-为什么要用缓存&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 为什么要用 Redis/为什么要用缓存？&lt;/h3&gt;&lt;p&gt;下面我们主要从“高性能”和“高并发”这两点来回答这个问题。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;高性能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这样有什么好处呢？&lt;/strong&gt; 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;高并发&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;QPS（Query Per Second）：服务器每秒可以执行的查询次数；&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。&lt;/p&gt;&lt;h3 id=&quot;redis-除了做缓存-还能做什么&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-除了做缓存-还能做什么&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 除了做缓存，还能做什么？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;分布式锁&lt;/strong&gt; ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：&lt;a href=&quot;https://javaguide.cn/distributed-system/distributed-lock.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;分布式锁详解&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;限流&lt;/strong&gt; ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：&lt;a href=&quot;https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt; ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;复杂业务场景&lt;/strong&gt; ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。&lt;/li&gt;&lt;li&gt;......&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;redis-可以做消息队列么&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-可以做消息队列么&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 可以做消息队列么？&lt;/h3&gt;&lt;p&gt;Redis 5.0 新增加的一个数据结构 &lt;code&gt;Stream&lt;/code&gt; 可以用来做消息队列，&lt;code&gt;Stream&lt;/code&gt; 支持：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;发布 / 订阅模式&lt;/li&gt;&lt;li&gt;按照消费者组进行消费&lt;/li&gt;&lt;li&gt;消息持久化（ RDB 和 AOF）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议是不使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。&lt;/p&gt;&lt;p&gt;相关文章推荐：&lt;a href=&quot;https://javakeeper.starfish.ink/data-management/Redis/Redis-MQ.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Redis 消息队列的三种方案（List、Streams、Pub/Sub）&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;&lt;h3 id=&quot;如何基于-redis-实现分布式锁&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#如何基于-redis-实现分布式锁&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 如何基于 Redis 实现分布式锁？&lt;/h3&gt;&lt;p&gt;关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：&lt;a href=&quot;https://javaguide.cn/distributed-system/distributed-lock.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;分布式锁详解&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 。&lt;/p&gt;&lt;h2 id=&quot;redis-数据结构&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-数据结构&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 数据结构&lt;/h2&gt;&lt;h3 id=&quot;redis-常用的数据结构有哪些&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-常用的数据结构有哪些&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 常用的数据结构有哪些？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;5 种基础数据结构&lt;/strong&gt; ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;3 种特殊数据结构&lt;/strong&gt; ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;关于 5 种基础数据结构的详细介绍请看这篇文章：&lt;a href=&quot;/database/redis/redis-data-structures-01.html&quot; class=&quot;&quot;&gt;Redis 5 种基本数据结构详解&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;关于 3 种特殊数据结构的详细介绍请看这篇文章：&lt;a href=&quot;/database/redis/redis-data-structures-02.html&quot; class=&quot;&quot;&gt;Redis 3 种特殊数据结构详解&lt;/a&gt;。&lt;/p&gt;&lt;h3 id=&quot;string-的应用场景有哪些&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#string-的应用场景有哪些&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; String 的应用场景有哪些？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;常规数据（比如 session、token、、序列化后的对象）的缓存；&lt;/li&gt;&lt;li&gt;计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；&lt;/li&gt;&lt;li&gt;分布式锁(利用 &lt;code&gt;SETNX key value&lt;/code&gt; 命令可以实现一个最简易的分布式锁)；&lt;/li&gt;&lt;li&gt;......&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;关于 String 的详细介绍请看这篇文章：&lt;a href=&quot;/database/redis/redis-data-structures-01.html&quot; class=&quot;&quot;&gt;Redis 5 种基本数据结构详解&lt;/a&gt;。&lt;/p&gt;&lt;h3 id=&quot;string-还是-hash-存储对象数据更好呢&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#string-还是-hash-存储对象数据更好呢&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; String 还是 Hash 存储对象数据更好呢？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。&lt;/li&gt;&lt;li&gt;String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在绝大部分情况，我们建议使用 String 来存储对象数据即可！&lt;/p&gt;&lt;h3 id=&quot;string-的底层实现是什么&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#string-的底层实现是什么&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; String 的底层实现是什么？&lt;/h3&gt;&lt;p&gt;Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 &lt;code&gt;\0&lt;/code&gt; 结尾的字符数组），而是自己编写了 &lt;a href=&quot;https://github.com/antirez/sds&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;SDS&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;（Simple Dynamic String，简单动态字符串） 来作为底层实现。&lt;/p&gt;&lt;p&gt;SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。&lt;/p&gt;&lt;p&gt;Redis7.0 的 SDS 的部分源码如下（https://github.com/redis/redis/blob/7.0/src/sds.h）：&lt;/p&gt;&lt;div class=&quot;language-c line-numbers-mode&quot; data-ext=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code&gt;&lt;span class=&quot;token comment&quot;&gt;/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__packed__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sdshdr5&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 3 lsb of type, and 5 msb of string length */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; buf&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__packed__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sdshdr8&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint8_t&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* used */&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint8_t&lt;/span&gt; alloc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; buf&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__packed__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sdshdr16&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint16_t&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* used */&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint16_t&lt;/span&gt; alloc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; buf&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__packed__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sdshdr32&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint32_t&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* used */&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint32_t&lt;/span&gt; alloc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; buf&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__packed__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sdshdr64&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint64_t&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* used */&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint64_t&lt;/span&gt; alloc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; buf&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;字节&lt;/th&gt;&lt;th&gt;位&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;sdshdr5&lt;/td&gt;&lt;td&gt;&amp;lt; 1&lt;/td&gt;&lt;td&gt;&amp;lt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sdshdr8&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sdshdr16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sdshdr32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sdshdr64&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;64&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;对于后四种实现都包含了下面这 4 个属性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;len&lt;/code&gt; ：字符串的长度也就是已经使用的字节数&lt;/li&gt;&lt;li&gt;&lt;code&gt;alloc&lt;/code&gt;：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小&lt;/li&gt;&lt;li&gt;&lt;code&gt;buf[]&lt;/code&gt; ：实际存储字符串的数组&lt;/li&gt;&lt;li&gt;&lt;code&gt;flags&lt;/code&gt; ：低三位保存类型标志&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;SDS 相比于 C 语言中的字符串有如下提升：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;可以避免缓冲区溢出&lt;/strong&gt; ：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;获取字符串长度的复杂度较低&lt;/strong&gt; ： C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;减少内存分配次数&lt;/strong&gt; ： 为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;二进制安全&lt;/strong&gt; ：C 语言中的字符串以空字符 &lt;code&gt;\0&lt;/code&gt; 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;多提一嘴，很多文章里 SDS 的定义是下面这样的：&lt;/p&gt;&lt;div class=&quot;language-c line-numbers-mode&quot; data-ext=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sdshdr&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; free&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; buf&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，&lt;code&gt;len&lt;/code&gt; 和 &lt;code&gt;free&lt;/code&gt; 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。&lt;/p&gt;&lt;h3 id=&quot;购物车信息用-string-还是-hash-存储更好呢&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#购物车信息用-string-还是-hash-存储更好呢&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 购物车信息用 String 还是 Hash 存储更好呢?&lt;/h3&gt;&lt;p&gt;由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;用户 id 为 key&lt;/li&gt;&lt;li&gt;商品 id 为 field，商品数量为 value&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;/assets/hash-shopping-cart.b8c84954.png&quot; alt=&quot;Hash维护简单的购物车信息&quot;/&gt;&lt;/p&gt;&lt;p&gt;那用户购物车信息的维护具体应该怎么操作呢？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;用户添加商品就是往 Hash 里面增加新的 field 与 value；&lt;/li&gt;&lt;li&gt;查询购物车信息就是遍历对应的 Hash；&lt;/li&gt;&lt;li&gt;更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；&lt;/li&gt;&lt;li&gt;删除商品就是删除 Hash 中对应的 field；&lt;/li&gt;&lt;li&gt;清空购物车直接删除对应的 key 即可。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。&lt;/p&gt;&lt;h3 id=&quot;使用-redis-实现一个排行榜怎么做&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#使用-redis-实现一个排行榜怎么做&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 使用 Redis 实现一个排行榜怎么做？&lt;/h3&gt;&lt;p&gt;Redis 中有一个叫做 &lt;code&gt;sorted set&lt;/code&gt; 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。&lt;/p&gt;&lt;p&gt;相关的一些 Redis 命令: &lt;code&gt;ZRANGE&lt;/code&gt; (从小到大排序) 、 &lt;code&gt;ZREVRANGE&lt;/code&gt; （从大到小排序）、&lt;code&gt;ZREVRANK&lt;/code&gt; (指定元素排名)。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021060714195385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;《Java 面试指北》&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719071115140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;使用-set-实现抽奖系统需要用到什么命令&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#使用-set-实现抽奖系统需要用到什么命令&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 使用 Set 实现抽奖系统需要用到什么命令？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;SPOP key count&lt;/code&gt; ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。&lt;/li&gt;&lt;li&gt;&lt;code&gt;SRANDMEMBER key count&lt;/code&gt; : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;使用-bitmap-统计活跃用户怎么做&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#使用-bitmap-统计活跃用户怎么做&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 使用 Bitmap 统计活跃用户怎么做？&lt;/h3&gt;&lt;p&gt;使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。&lt;/p&gt;&lt;p&gt;初始化数据：&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; SETBIT &lt;span class=&quot;token number&quot;&gt;20210308&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; SETBIT &lt;span class=&quot;token number&quot;&gt;20210308&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; SETBIT &lt;span class=&quot;token number&quot;&gt;20210309&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;统计 20210308~20210309 总活跃用户数:&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; BITOP and desk1 &lt;span class=&quot;token number&quot;&gt;20210308&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20210309&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; BITCOUNT desk1
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;统计 20210308~20210309 在线活跃用户数:&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; BITOP or desk2 &lt;span class=&quot;token number&quot;&gt;20210308&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20210309&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; BITCOUNT desk2
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;使用-hyperloglog-统计页面-uv-怎么做&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#使用-hyperloglog-统计页面-uv-怎么做&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 使用 HyperLogLog 统计页面 UV 怎么做？&lt;/h3&gt;&lt;p&gt;1、将访问指定页面的每个用户 ID 添加到 &lt;code&gt;HyperLogLog&lt;/code&gt; 中。&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;PFADD PAGE_1:UV USER1 USER2 &lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt; USERn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2、统计指定页面的 UV。&lt;/p&gt;&lt;h2 id=&quot;redis-线程模型&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-线程模型&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 线程模型&lt;/h2&gt;&lt;p&gt;对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。&lt;/p&gt;&lt;h3 id=&quot;redis-单线程模型了解吗&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-单线程模型了解吗&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 单线程模型了解吗？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型&lt;/strong&gt; （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。&lt;/p&gt;&lt;p&gt;《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。&lt;/li&gt;&lt;li&gt;当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字&lt;/strong&gt;，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;既然是单线程，那怎么监听大量的客户端连接呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Redis 通过 &lt;strong&gt;IO 多路复用程序&lt;/strong&gt; 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。&lt;/p&gt;&lt;p&gt;这样的好处非常明显： &lt;strong&gt;I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗&lt;/strong&gt;（和 NIO 中的 &lt;code&gt;Selector&lt;/code&gt; 组件很像）。&lt;/p&gt;&lt;p&gt;文件事件处理器（file event handler）主要是包含 4 个部分：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;多个 socket（客户端连接）&lt;/li&gt;&lt;li&gt;IO 多路复用程序（支持多个客户端连接的关键）&lt;/li&gt;&lt;li&gt;文件事件分派器（将 socket 关联到相应的事件处理器）&lt;/li&gt;&lt;li&gt;事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-event-handler.png&quot; alt=&quot;文件事件处理器&quot;/&gt;&lt;/p&gt;&lt;p&gt;相关阅读：&lt;a href=&quot;http://remcarpediem.net/article/1aa2da89/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Redis 事件机制详解&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 。&lt;/p&gt;&lt;h3 id=&quot;redis6-0-之前为什么不使用多线程&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis6-0-之前为什么不使用多线程&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis6.0 之前为什么不使用多线程？&lt;/h3&gt;&lt;p&gt;虽然说 Redis 是单线程模型，但是，实际上，&lt;strong&gt;Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。&lt;/p&gt;&lt;p&gt;为此，Redis 4.0 之后新增了&lt;code&gt;UNLINK&lt;/code&gt;（可以看作是 &lt;code&gt;DEL&lt;/code&gt; 的异步版本）、&lt;code&gt;FLUSHALL ASYNC&lt;/code&gt;（清空所有数据库的所有 key，不仅仅是当前 &lt;code&gt;SELECT&lt;/code&gt; 的数据库）、&lt;code&gt;FLUSHDB ASYNC&lt;/code&gt;（清空当前 &lt;code&gt;SELECT&lt;/code&gt; 数据库中的所有 key）等异步命令。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis4.0-more-thread.png&quot; alt=&quot;redis4.0 more thread&quot;/&gt;&lt;/p&gt;&lt;p&gt;大体上来说，Redis 6.0 之前主要还是单线程处理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;那 Redis6.0 之前为什么不使用多线程？&lt;/strong&gt; 我觉得主要原因有 3 点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;单线程编程容易并且更容易维护；&lt;/li&gt;&lt;li&gt;Redis 的性能瓶颈不在 CPU ，主要在内存和网络；&lt;/li&gt;&lt;li&gt;多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;相关阅读：&lt;a href=&quot;https://draveness.me/whys-the-design-redis-single-thread/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;为什么 Redis 选择单线程模型&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 。&lt;/p&gt;&lt;h3 id=&quot;redis6-0-之后为何引入了多线程&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis6-0-之后为何引入了多线程&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis6.0 之后为何引入了多线程？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Redis6.0 引入多线程主要是为了提高网络 IO 读写性能&lt;/strong&gt;，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。&lt;/p&gt;&lt;p&gt;虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。&lt;/p&gt;&lt;p&gt;Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置IO线程数 &amp;gt; 1，需要修改 redis 配置文件 &lt;code&gt;redis.conf&lt;/code&gt; ：&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;io-threads &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;#设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;io-threads的个数一旦设置，不能通过config动态设置&lt;/li&gt;&lt;li&gt;当设置ssl后，io-threads将不工作&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;开启多线程后，默认只会使用多线程进行IO写入writes，即发送数据给客户端，如果需要开启多线程IO读取reads，同样需要修改 redis 配置文件 &lt;code&gt;redis.conf&lt;/code&gt; :&lt;/p&gt;&lt;p&gt;但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启&lt;/p&gt;&lt;p&gt;相关阅读：&lt;/p&gt;&lt;h2 id=&quot;redis-内存管理&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-内存管理&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 内存管理&lt;/h2&gt;&lt;h3 id=&quot;redis-给缓存数据设置过期时间有啥用&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-给缓存数据设置过期时间有啥用&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 给缓存数据设置过期时间有啥用？&lt;/h3&gt;&lt;p&gt;一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？&lt;/p&gt;&lt;p&gt;因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。&lt;/p&gt;&lt;p&gt;Redis 自带了给缓存数据设置过期时间的功能，比如：&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&amp;gt;&lt;/span&gt; expire key &lt;span class=&quot;token number&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# 数据在 60s 后过期&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&amp;gt;&lt;/span&gt; setex key &lt;span class=&quot;token number&quot;&gt;60&lt;/span&gt; value &lt;span class=&quot;token comment&quot;&gt;# 数据在 60s 后过期 (setex:[set] + [ex]pire)&lt;/span&gt;
OK
&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&amp;gt;&lt;/span&gt; ttl key &lt;span class=&quot;token comment&quot;&gt;# 查看数据还有多久过期&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;56&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意：&lt;strong&gt;Redis 中除了字符串类型有自己独有设置过期时间的命令 &lt;code&gt;setex&lt;/code&gt; 外，其他方法都需要依靠 &lt;code&gt;expire&lt;/code&gt; 命令来设置过期时间 。另外， &lt;code&gt;persist&lt;/code&gt; 命令可以移除一个键的过期时间。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;过期时间除了有助于缓解内存的消耗，还有什么其他用么？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。&lt;/p&gt;&lt;p&gt;如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。&lt;/p&gt;&lt;h3 id=&quot;redis-是如何判断数据是否过期的呢&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-是如何判断数据是否过期的呢&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 是如何判断数据是否过期的呢？&lt;/h3&gt;&lt;p&gt;Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-expired-dictionary.png&quot; alt=&quot;redis过期字典&quot;/&gt;&lt;/p&gt;&lt;p&gt;过期字典是存储在 redisDb 这个结构里的：&lt;/p&gt;&lt;div class=&quot;language-c line-numbers-mode&quot; data-ext=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;redisDb&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;

    dict &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;dict&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;token comment&quot;&gt;//数据库键空间,保存着数据库中所有键值对&lt;/span&gt;
    dict &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;expires   &lt;span class=&quot;token comment&quot;&gt;// 过期字典,保存着键的过期时间&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; redisDb&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;过期的数据的删除策略了解么&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#过期的数据的删除策略了解么&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 过期的数据的删除策略了解么？&lt;/h3&gt;&lt;p&gt;如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？&lt;/p&gt;&lt;p&gt;常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;惰性删除&lt;/strong&gt; ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;定期删除&lt;/strong&gt; ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 &lt;strong&gt;定期删除+惰性/懒汉式删除&lt;/strong&gt; 。&lt;/p&gt;&lt;p&gt;但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。&lt;/p&gt;&lt;p&gt;怎么解决这个问题呢？答案就是：&lt;strong&gt;Redis 内存淘汰机制。&lt;/strong&gt;&lt;/p&gt;&lt;h3 id=&quot;redis-内存淘汰机制了解么&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-内存淘汰机制了解么&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 内存淘汰机制了解么？&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Redis 提供 6 种数据淘汰策略：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;volatile-lru（least recently used）&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰&lt;/li&gt;&lt;li&gt;&lt;strong&gt;volatile-ttl&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰&lt;/li&gt;&lt;li&gt;&lt;strong&gt;volatile-random&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰&lt;/li&gt;&lt;li&gt;&lt;strong&gt;allkeys-lru（least recently used）&lt;/strong&gt;：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）&lt;/li&gt;&lt;li&gt;&lt;strong&gt;allkeys-random&lt;/strong&gt;：从数据集（server.db[i].dict）中任意选择数据淘汰&lt;/li&gt;&lt;li&gt;&lt;strong&gt;no-eviction&lt;/strong&gt;：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;4.0 版本后增加以下两种：&lt;/p&gt;&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;&lt;strong&gt;volatile-lfu（least frequently used）&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰&lt;/li&gt;&lt;li&gt;&lt;strong&gt;allkeys-lfu（least frequently used）&lt;/strong&gt;：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;redis-持久化机制&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-持久化机制&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 持久化机制&lt;/h2&gt;&lt;h3 id=&quot;怎么保证-redis-挂掉之后再重启数据可以进行恢复&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#怎么保证-redis-挂掉之后再重启数据可以进行恢复&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 怎么保证 Redis 挂掉之后再重启数据可以进行恢复？&lt;/h3&gt;&lt;p&gt;很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。&lt;/p&gt;&lt;p&gt;Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。&lt;strong&gt;Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）&lt;/strong&gt;。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。&lt;/p&gt;&lt;h3 id=&quot;什么是-rdb-持久化&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#什么是-rdb-持久化&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 什么是 RDB 持久化？&lt;/h3&gt;&lt;p&gt;Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。&lt;/p&gt;&lt;p&gt;快照持久化是 Redis 默认采用的持久化方式，在 &lt;code&gt;redis.conf&lt;/code&gt; 配置文件中默认有此下配置：&lt;/p&gt;&lt;div class=&quot;language-clojure line-numbers-mode&quot; data-ext=&quot;clojure&quot;&gt;&lt;pre class=&quot;language-clojure&quot;&gt;&lt;code&gt;save &lt;span class=&quot;token number&quot;&gt;900&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;           &lt;span class=&quot;token operator&quot;&gt;#&lt;/span&gt;在&lt;span class=&quot;token number&quot;&gt;900&lt;/span&gt;秒&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;15&lt;/span&gt;分钟&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;之后，如果至少有&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;个key发生变化，Redis就会自动触发bgsave命令创建快照。

save &lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;          &lt;span class=&quot;token operator&quot;&gt;#&lt;/span&gt;在&lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;秒&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;分钟&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;之后，如果至少有&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;个key发生变化，Redis就会自动触发bgsave命令创建快照。

save &lt;span class=&quot;token number&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10000&lt;/span&gt;        &lt;span class=&quot;token operator&quot;&gt;#&lt;/span&gt;在&lt;span class=&quot;token number&quot;&gt;60&lt;/span&gt;秒&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;分钟&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;之后，如果至少有&lt;span class=&quot;token number&quot;&gt;10000&lt;/span&gt;个key发生变化，Redis就会自动触发bgsave命令创建快照。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;rdb-创建快照时会阻塞主线程吗&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#rdb-创建快照时会阻塞主线程吗&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; RDB 创建快照时会阻塞主线程吗？&lt;/h3&gt;&lt;p&gt;Redis 提供了两个命令来生成 RDB 快照文件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;save&lt;/code&gt; : 主线程执行，会阻塞主线程；&lt;/li&gt;&lt;li&gt;&lt;code&gt;bgsave&lt;/code&gt; : 子线程执行，不会阻塞主线程，默认选项。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;什么是-aof-持久化&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#什么是-aof-持久化&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 什么是 AOF 持久化？&lt;/h3&gt;&lt;p&gt;与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：&lt;/p&gt;&lt;p&gt;开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 &lt;code&gt;server.aof_buf&lt;/code&gt; 中，然后再根据 &lt;code&gt;appendfsync&lt;/code&gt; 配置来决定何时将其同步到硬盘中的 AOF 文件。&lt;/p&gt;&lt;p&gt;AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 &lt;code&gt;appendonly.aof&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;appendfsync always    &lt;span class=&quot;token comment&quot;&gt;#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度&lt;/span&gt;
appendfsync everysec  &lt;span class=&quot;token comment&quot;&gt;#每秒钟同步一次，显式地将多个写命令同步到硬盘&lt;/span&gt;
appendfsync no        &lt;span class=&quot;token comment&quot;&gt;#让操作系统决定何时进行同步&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了兼顾数据和写入性能，用户可以考虑 &lt;code&gt;appendfsync everysec&lt;/code&gt; 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;相关 issue&lt;/strong&gt; ：&lt;/p&gt;&lt;h3 id=&quot;aof-日志是如何实现的&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#aof-日志是如何实现的&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; AOF 日志是如何实现的？&lt;/h3&gt;&lt;p&gt;关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/assets/redis-aof-write-log-disc.ca22bd65.png&quot; alt=&quot;AOF 记录日志过程&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为什么是在执行完命令之后记录日志呢？&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；&lt;/li&gt;&lt;li&gt;在命令执行完之后再记录，不会阻塞当前的命令执行。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；&lt;/li&gt;&lt;li&gt;可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;aof-重写了解吗&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#aof-重写了解吗&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; AOF 重写了解吗？&lt;/h3&gt;&lt;p&gt;当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。&lt;/p&gt;&lt;p&gt;AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。&lt;/p&gt;&lt;p&gt;在执行 &lt;code&gt;BGREWRITEAOF&lt;/code&gt; 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。&lt;/p&gt;&lt;p&gt;Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。&lt;/p&gt;&lt;h3 id=&quot;如何选择-rdb-和-aof&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#如何选择-rdb-和-aof&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 如何选择 RDB 和 AOF？&lt;/h3&gt;&lt;p&gt;关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明&lt;a href=&quot;https://redis.io/docs/manual/persistence/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Redis persistence&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;，这里结合自己的理解简单总结一下。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;RDB 比 AOF 优秀的地方&lt;/strong&gt; ：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。&lt;/li&gt;&lt;li&gt;使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;AOF 比 RDB 优秀的地方&lt;/strong&gt; ：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。&lt;/li&gt;&lt;li&gt;RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。&lt;/li&gt;&lt;li&gt;AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行&lt;code&gt;FLUSHALL&lt;/code&gt;命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;redis-4-0-对于持久化机制做了什么优化&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-4-0-对于持久化机制做了什么优化&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 4.0 对于持久化机制做了什么优化？&lt;/h3&gt;&lt;p&gt;由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 &lt;code&gt;aof-use-rdb-preamble&lt;/code&gt; 开启）。&lt;/p&gt;&lt;p&gt;如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。&lt;/p&gt;&lt;p&gt;官方文档地址：https://redis.io/topics/persistence&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis4.0-persitence.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;参考&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#参考&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 参考&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31bf3e5aa568f5a534e0a93569969e1c</guid>
<title>Vue3.2 + Element-Plus 二次封装 el-table（Pro版）</title>
<link>https://toutiao.io/k/an0szva</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;ProTable 组件目前已是 &lt;code&gt;2.0版本&lt;/code&gt;🌈，在 &lt;span&gt;1.0版本&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 中大家提出的问题与功能优化，目前已经得到优化和解决。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;😀 欢迎大家在使用过程中发现任何问题或更好的想法，都可以在下方评论区留言，或者我的开源项目 issues 中提出。如果你觉得还不错，请帮我点个小小的 &lt;strong&gt;Star&lt;/strong&gt; 🧡&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、在线预览 👀&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Link：&lt;span&gt;admin.spicyboy.cn&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、Git 仓库地址 (欢迎 Star⭐⭐⭐)&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Gitee：&lt;span&gt;gitee.com/laramie/Gee…&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;GitHub：&lt;span&gt;github.com/HalseySpicy…&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、ProTable 功能 🚀🚀🚀&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;ProTable&lt;/strong&gt; 组件目前使用属性透传进行重构，支持 &lt;strong&gt;el-table &amp;amp;&amp;amp; el-table-column&lt;/strong&gt; 所有属性、事件、方法的调用，不会有任何心智负担。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;表格内容自适应屏幕宽高，溢出内容表格内部滚动（flex 布局）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表格搜索、重置、分页查询 Hooks 封装 （页面使用不会存在任何搜索、重置、分页查询逻辑）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表格数据操作 Hooks 封装 （单条数据删除、批量删除、重置密码、状态切换等操作）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表格数据多选 Hooks 封装 （支持现跨页勾选数据）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表格数据导入组件、导出 Hooks 封装&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表格搜索区域使用 Grid 布局重构，支持自定义响应式配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表格分页组件封装（Pagination）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表格数据刷新、列显隐、列排序、搜索区域显隐设置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表格数据打印功能（可勾选行数据、隐藏列打印）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表格配置支持多级 prop（示例 ==&amp;gt; prop: user.detail.name）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单元格内容格式化、tag 标签显示（有字典 enum 会根据字典 enum 自动格式化）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持多级表头、表头内容自定义渲染（支持作用域插槽、tsx 语法、h 函数）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持单元格内容自定义渲染（支持作用域插槽、tsx 语法、h 函数）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配合 TreeFilter、SelectFilter 组件使用更佳（项目中有使用示例）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、ProTable 功能需求分析 📑&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先我们来看效果图（总共可以分为五个模块）：&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48802083333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQQ1GDkNwynJ1iaHnb9U9E2sk8noxVe5mibWUj6qSPxoAW6qPqJib3DwxOUX5G5JiamP0qzBicgkPWe3aww/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1、表格搜索区域&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2、表格数据操作按钮区域&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3、表格功能按钮区域&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4、表格主体内容展示区域&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;5、表格分页区域&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、表格搜索区域需求分析：&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;可以看到搜索区域的字段都是存在于表格当中的，并且每个页面的搜索、重置方法都是一样的逻辑，只是不同的查询参数而已。我们完全可以在传表格配置项 &lt;strong&gt;columns&lt;/strong&gt; 时，直接指定某个 &lt;strong&gt;column&lt;/strong&gt; 的 &lt;strong&gt;search&lt;/strong&gt; 配置，就能把该项变为搜索项，然后使用 &lt;strong&gt;el&lt;/strong&gt; 字段可以指定搜索框的类型，最后把表格的搜索方法都封装成 &lt;strong&gt;Hooks&lt;/strong&gt; 钩子函数。页面上完全就不会存在任何搜索、重置逻辑了。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在 &lt;strong&gt;1.0&lt;/strong&gt; 版本中使用 &lt;strong&gt;v-if&lt;/strong&gt; 判断太麻烦，为了更方便用户传递参数，搜索组件在 &lt;strong&gt;2.0&lt;/strong&gt; 版本中通过 &lt;strong&gt;component :is&lt;/strong&gt; 动态组件 &amp;amp;&amp;amp; &lt;strong&gt;v-bind&lt;/strong&gt; 属性透传实现，将用户传递的参数全部透传到组件上，所以大家可以直接根据 &lt;strong&gt;element&lt;/strong&gt; 官方文档在 &lt;strong&gt;props&lt;/strong&gt; 中传递参数了。以下代码还结合了自己逻辑上的一些处理：&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;component&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;column.search?.el&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:is&lt;/span&gt;=&lt;span&gt;&quot;`el-${column.search.el}`&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;v-bind&lt;/span&gt;=&lt;span&gt;&quot;column.search.props&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;v-model&lt;/span&gt;=&lt;span&gt;&quot;searchParam[column.search.key ?? handleProp(column.prop!)]&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:data&lt;/span&gt;=&lt;span&gt;&quot;column.search?.el === &#x27;tree-select&#x27; ? columnEnum : []&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:placeholder&lt;/span&gt;=&lt;span&gt;&quot;placeholder(column)&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:clearable&lt;/span&gt;=&lt;span&gt;&quot;clearable(column)&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;range-separator&lt;/span&gt;=&lt;span&gt;&quot;至&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;start-placeholder&lt;/span&gt;=&lt;span&gt;&quot;开始时间&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;end-placeholder&lt;/span&gt;=&lt;span&gt;&quot;结束时间&quot;&lt;/span&gt;&lt;br/&gt;  &amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt; &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;column.search.el === &#x27;select&#x27;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;component&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;:is&lt;/span&gt;=&lt;span&gt;&quot;`el-option`&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;v-for&lt;/span&gt;=&lt;span&gt;&quot;(col, index) in columnEnum&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;:key&lt;/span&gt;=&lt;span&gt;&quot;index&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;:label&lt;/span&gt;=&lt;span&gt;&quot;col[fieldNames().label]&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;:value&lt;/span&gt;=&lt;span&gt;&quot;col[fieldNames().value]&quot;&lt;/span&gt;&lt;br/&gt;      &amp;gt;&amp;lt;/&lt;span&gt;component&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;slot&lt;/span&gt; &lt;span&gt;v-else&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;slot&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;component&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;=&lt;span&gt;&quot;ts&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;searchFormItem&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { computed, inject, ref } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { handleProp } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/utils/util&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ColumnProps } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/components/ProTable/interface&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;interface SearchFormItem {&lt;br/&gt;  &lt;span&gt;column&lt;/span&gt;: ColumnProps; &lt;span&gt;// 具体每一个搜索项的配置&lt;/span&gt;&lt;br/&gt;  searchParam: { [key: string]: any }; &lt;span&gt;// 搜索参数&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; props = defineProps&amp;lt;SearchFormItem&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 接受 enumMap&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; enumMap = inject(&lt;span&gt;&quot;enumMap&quot;&lt;/span&gt;, ref(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;()));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; columnEnum = computed(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!enumMap.value.get(props.column.prop)) &lt;span&gt;return&lt;/span&gt; [];&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; enumMap.value.get(props.column.prop);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 判断 fieldNames 设置 label &amp;amp;&amp;amp; value 的 key 值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; fieldNames = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;label&lt;/span&gt;: props.column.fieldNames?.label ?? &lt;span&gt;&quot;label&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;value&lt;/span&gt;: props.column.fieldNames?.value ?? &lt;span&gt;&quot;value&quot;&lt;/span&gt;&lt;br/&gt;  };&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 判断 placeholder&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; placeholder = &lt;span&gt;(&lt;span&gt;column: ColumnProps&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; column.search?.props?.placeholder ?? (column.search?.el === &lt;span&gt;&quot;input&quot;&lt;/span&gt; ? &lt;span&gt;&quot;请输入&quot;&lt;/span&gt; : &lt;span&gt;&quot;请选择&quot;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 是否有清除按钮 (当搜索项有默认值时，清除按钮不显示)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; clearable = &lt;span&gt;(&lt;span&gt;column: ColumnProps&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; column.search?.props?.clearable ?? (column.search?.defaultValue == &lt;span&gt;null&lt;/span&gt; || column.search?.defaultValue == &lt;span&gt;undefined&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;表格搜索组件在 &lt;strong&gt;2.0&lt;/strong&gt; 版本中还支持了响应式配置，使用 &lt;strong&gt;Grid&lt;/strong&gt; 方法进行整体重构 😋。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;动画.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、表格数据操作按钮区域需求分析：&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;表格数据操作按钮基本上每个页面都会不一样，所以我们直接使用 &lt;strong&gt;作用域插槽&lt;/strong&gt; 来完成每个页面的数据操作按钮区域，&lt;strong&gt;作用域插槽&lt;/strong&gt; 可以将表格多选数据信息从 &lt;strong&gt;ProTable&lt;/strong&gt; 的 &lt;strong&gt;Hooks&lt;/strong&gt; 多选钩子函数中传到页面上使用。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;scope&lt;/strong&gt; 数据中包含：&lt;strong&gt;selectedList（当前选择的数据）、selectedListIds（当前选择的数据id）、isSelected（当前是否选中的数据）&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- ProTable 中 tableHeader 插槽 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;slot&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;tableHeader&quot;&lt;/span&gt; &lt;span&gt;:selectList&lt;/span&gt;=&lt;span&gt;&quot;selectedList&quot;&lt;/span&gt; &lt;span&gt;:selectedListIds&lt;/span&gt;=&lt;span&gt;&quot;selectedListIds&quot;&lt;/span&gt; &lt;span&gt;:isSelected&lt;/span&gt;=&lt;span&gt;&quot;isSelected&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;slot&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!-- 页面使用 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt; #&lt;span&gt;tableHeader&lt;/span&gt;=&lt;span&gt;&quot;scope&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;CirclePlus&quot;&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;openDrawer(&#x27;新增&#x27;)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;新增用户&lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;Upload&quot;&lt;/span&gt; &lt;span&gt;plain&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;batchAdd&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;批量添加用户&lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;Download&quot;&lt;/span&gt; &lt;span&gt;plain&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;downloadFile&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;导出用户数据&lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;danger&quot;&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;Delete&quot;&lt;/span&gt; &lt;span&gt;plain&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;batchDelete(scope.selectedListIds)&quot;&lt;/span&gt; &lt;span&gt;:disabled&lt;/span&gt;=&lt;span&gt;&quot;!scope.isSelected&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;批量删除用户&lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、表格功能按钮区域分析：&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这块区域没什么特殊功能，只有四个按钮，其功能分别为：&lt;strong&gt;表格数据刷新（一直会携带当前查询和分页条件）、表格数据打印、表格列设置（列显隐、列排序）、表格搜索区域显隐（方便展示更多的数据信息）&lt;/strong&gt;。可通过 &lt;strong&gt;toolButton&lt;/strong&gt; 属性控制这块区域的显隐。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;表格打印功能基于 &lt;strong&gt;PrintJs&lt;/strong&gt; 实现，因 &lt;strong&gt;PrintJs&lt;/strong&gt; 不支持多级表头打印，所以当页面存在多级表头时，只会打印最后一级表头。表格打印功能可根据显示的列和勾选的数据动态打印，默认打印当前显示的所有数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5019098548510313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQQ1GDkNwynJ1iaHnb9U9E2skuo31530un4qw1RqSQcIGzLgTqic8nOA1iaMz9pBwBzQRDhYhMcoyK4qQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1309&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、表格主体内容展示区域分析：&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;🍉 该区域是最重要的数据展示区域，对于使用最多的功能就是表头和单元格内容可以自定义渲染，在第 &lt;strong&gt;1.0&lt;/strong&gt; 版本中，自定义表头只支持传入&lt;code&gt;renderHeader&lt;/code&gt;方法，自定义单元格内容只支持&lt;code&gt;slot&lt;/code&gt;插槽。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;💥 目前 &lt;strong&gt;2.0&lt;/strong&gt; 版本中，表头支持&lt;code&gt;headerRender&lt;/code&gt;方法（避免与 &lt;strong&gt;el-table-column&lt;/strong&gt; 上的属性重名导致报错）、作用域插槽（&lt;code&gt;column.prop + &#x27;Header&#x27;&lt;/code&gt;）两种方式自定义，单元格内容支持&lt;code&gt;render&lt;/code&gt;方法和作用域插槽（&lt;code&gt;column 上的 prop 属性&lt;/code&gt;）两种方式自定义。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- 使用作用域插槽自定义单元格内容 username --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt; #&lt;span&gt;username&lt;/span&gt;=&lt;span&gt;&quot;scope&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    {{ scope.row.username }}&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!-- 使用作用域插槽自定义表头内容 username --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt; #&lt;span&gt;usernameHeader&lt;/span&gt;=&lt;span&gt;&quot;scope&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;ElMessage.success(&#x27;我是通过作用域插槽渲染的表头&#x27;)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        {{ scope.row.label }}&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;=&lt;span&gt;&quot;tsx&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; columns: ColumnProps[] = [&lt;br/&gt; {&lt;br/&gt;    &lt;span&gt;prop&lt;/span&gt;: &lt;span&gt;&quot;username&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;用户姓名&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 使用 headerRender 自定义表头&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;headerRender&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;row&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            ElMessage.success(&quot;我是通过 tsx 语法渲染的表头&quot;);&lt;br/&gt;          }}&lt;br/&gt;        &amp;gt;&lt;br/&gt;          {row.label}&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;      );&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;prop&lt;/span&gt;: &lt;span&gt;&quot;status&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;用户状态&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 使用 render 自定义表格内容&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;render&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;scope: { row }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;          &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;el-switch&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;model-value&lt;/span&gt;=&lt;span&gt;{scope.row.status}&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;active-text&lt;/span&gt;=&lt;span&gt;{scope.row.status&lt;/span&gt; ? &quot;启用&quot; &lt;span&gt;:&lt;/span&gt; &quot;禁用&quot;}&lt;br/&gt;            &lt;span&gt;active-value&lt;/span&gt;=&lt;span&gt;{1}&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;inactive-value&lt;/span&gt;=&lt;span&gt;{0}&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt; =&amp;gt;&lt;/span&gt; changeStatus(scope.row)}&lt;br/&gt;          /&amp;gt;&lt;/span&gt;&lt;br/&gt;        ) &lt;br/&gt;      );&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;];&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;💢💢💢 &lt;strong&gt;最强大的功能：如果你想使用 &lt;code&gt;el-table&lt;/code&gt; 的任何属性、事件，目前通过属性透传都能支持。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;如果你还不了解属性透传，请阅读 vue 官方文档：&lt;span&gt;cn.vuejs.org/guide/compo…&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ProTable 组件上的绑定的所有属性和事件都会通过 &lt;code&gt;v-bind=&quot;$attrs&quot;&lt;/code&gt; 透传到 el-table 上。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ProTable 组件内部暴露了 el-table DOM，可通过 &lt;code&gt;proTable.value.element.方法名&lt;/code&gt; 调用其方法。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;el-table&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;tableRef&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;v-bind&lt;/span&gt;=&lt;span&gt;&quot;$attrs&quot;&lt;/span&gt; &lt;br/&gt;    &amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;el-table&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;=&lt;span&gt;&quot;ts&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;ProTable&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ref } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ElTable } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;element-plus&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; tableRef = ref&amp;lt;InstanceType&amp;lt;&lt;span&gt;typeof&lt;/span&gt; ElTable&amp;gt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;defineExpose({ &lt;span&gt;element&lt;/span&gt;: tableRef });&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、表格分页区域分析：&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;分页区域也没有什么特殊的功能，该支持的都支持了🤣（页面上使用 ProTable 组件完全不存在分页逻辑）&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;!-- 分页组件 --&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;el-pagination&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:current-page&lt;/span&gt;=&lt;span&gt;&quot;pageable.pageNum&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:page-size&lt;/span&gt;=&lt;span&gt;&quot;pageable.pageSize&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:page-sizes&lt;/span&gt;=&lt;span&gt;&quot;[10, 25, 50, 100]&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:background&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;layout&lt;/span&gt;=&lt;span&gt;&quot;total, sizes, prev, pager, next, jumper&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:total&lt;/span&gt;=&lt;span&gt;&quot;pageable.total&quot;&lt;/span&gt;&lt;br/&gt;    @&lt;span&gt;size-change&lt;/span&gt;=&lt;span&gt;&quot;handleSizeChange&quot;&lt;/span&gt;&lt;br/&gt;    @&lt;span&gt;current-change&lt;/span&gt;=&lt;span&gt;&quot;handleCurrentChange&quot;&lt;/span&gt;&lt;br/&gt;  &amp;gt;&amp;lt;/&lt;span&gt;el-pagination&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;=&lt;span&gt;&quot;ts&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;pagination&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;interface Pageable {&lt;br/&gt;  &lt;span&gt;pageNum&lt;/span&gt;: number;&lt;br/&gt;  pageSize: number;&lt;br/&gt;  total: number;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;interface PaginationProps {&lt;br/&gt;  &lt;span&gt;pageable&lt;/span&gt;: Pageable;&lt;br/&gt;  handleSizeChange: &lt;span&gt;(&lt;span&gt;size: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;  handleCurrentChange: &lt;span&gt;(&lt;span&gt;currentPage: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;defineProps&amp;lt;PaginationProps&amp;gt;();&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五、ProTable 文档 📚&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、ProTable 属性（ProTableProps）：&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用 &lt;code&gt;v-bind=&quot;$atts&quot;&lt;/code&gt; 通过属性透传将 &lt;strong&gt;ProTable&lt;/strong&gt; 组件属性全部透传到 &lt;strong&gt;el-table&lt;/strong&gt; 上，所以我们支持 &lt;strong&gt;el-table&lt;/strong&gt; 的所有 &lt;strong&gt;Props&lt;/strong&gt; 属性。在此基础上，还扩展了以下 &lt;strong&gt;Props：&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性名&lt;/th&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;是否必传&lt;/th&gt;&lt;th&gt;默认值&lt;/th&gt;&lt;th&gt;属性描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;columns&lt;/td&gt;&lt;td&gt;ColumnProps&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;ProTable 组件会根据此字段渲染搜索表单与表格列，详情见 ColumnProps&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;requestApi&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;获取表格数据的请求 API&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dataCallback&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;后台返回数据的回调函数，可对后台返回数据进行处理&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;title&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;表格标题，目前只在打印的时候用到&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pagination&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;true&lt;/td&gt;&lt;td&gt;是否显示分页组件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;initParam&lt;/td&gt;&lt;td&gt;Object&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;{}&lt;/td&gt;&lt;td&gt;表格请求的初始化参数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;toolButton&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;true&lt;/td&gt;&lt;td&gt;是否显示表格功能按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;selectId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;&#x27;id&#x27;&lt;/td&gt;&lt;td&gt;当表格数据多选时，所指定的 id&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;searchCol&lt;/td&gt;&lt;td&gt;Object&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;{ xs: 1, sm: 2, md: 2, lg: 3, xl: 4 }&lt;/td&gt;&lt;td&gt;表格搜索项每列占比配置&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、Column 配置（ColumnProps）：&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用 &lt;code&gt;v-bind=&quot;column&quot;&lt;/code&gt; 通过属性透传将每一项 &lt;strong&gt;column&lt;/strong&gt; 属性全部透传到 &lt;strong&gt;el-table-column&lt;/strong&gt; 上，所以我们支持 &lt;strong&gt;el-table-column&lt;/strong&gt; 的所有 &lt;strong&gt;Props&lt;/strong&gt; 属性。在此基础上，还扩展了以下 &lt;strong&gt;Props：&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性名&lt;/th&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;是否必传&lt;/th&gt;&lt;th&gt;默认值&lt;/th&gt;&lt;th&gt;属性描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;tag&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;td&gt;当前单元格值是否为标签展示&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;isShow&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;true&lt;/td&gt;&lt;td&gt;当前列是否显示在表格内&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;search&lt;/td&gt;&lt;td&gt;SearchProps&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;搜索项配置，详情见 SearchProps&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;enum&lt;/td&gt;&lt;td&gt;Object | Function&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;字典，可格式化单元格内容，还可以作为搜索框的下拉选项（字典可以为API请求函数，内部会自动执行）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;isFilterEnum&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;true&lt;/td&gt;&lt;td&gt;当前单元格值是否根据 enum 格式化（例如 enum 只作为搜索项数据，不参与内容格式化）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;fieldNames&lt;/td&gt;&lt;td&gt;Object&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;指定字典 label &amp;amp;&amp;amp; value 的 key 值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;headerRender&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;自定义表头内容渲染（tsx 语法、h 语法）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;render&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;自定义单元格内容渲染（tsx 语法、h 语法）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;_children&lt;/td&gt;&lt;td&gt;ColumnProps&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;多级表头&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、搜索项 配置（SearchProps）：&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用 &lt;code&gt;v-bind=&quot;column.search.props“&lt;/code&gt; 通过属性透传将 &lt;strong&gt;search.props&lt;/strong&gt; 属性全部透传到每一项搜索组件上，所以我们支持 &lt;strong&gt;input、select、tree-select、date-packer、time-picker、time-select、swicth&lt;/strong&gt; 大部分属性，并在其基础上还扩展了以下 &lt;strong&gt;Props：&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性名&lt;/th&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;是否必传&lt;/th&gt;&lt;th&gt;默认值&lt;/th&gt;&lt;th&gt;属性描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;el&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;当前项搜索框的类型，支持：input、select、tree-select、cascader、date-packer、time-picker、time-select、swicth&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;props&lt;/td&gt;&lt;td&gt;Object&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;根据 element plus 官方文档来传递，该属性所有值会透传到组件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;defaultValue&lt;/td&gt;&lt;td&gt;Any&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;搜索项默认值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;key&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;当搜索项 key 不为 prop 属性时，可通过 key 指定&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;order&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;搜索项排序（从大到小）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;span&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;搜索项所占用的列数，默认为 1 列&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;offset&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;搜索字段左侧偏移列数&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、ProTable 事件：&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;根据 &lt;strong&gt;ElementPlus Table&lt;/strong&gt; 文档在 &lt;strong&gt;ProTable&lt;/strong&gt; 组件上绑定事件即可，组件会通过 &lt;strong&gt;$attrs&lt;/strong&gt; 透传给 &lt;strong&gt;el-table&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;span&gt;el-table 事件文档链接&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、ProTable 方法：&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;ProTable&lt;/strong&gt; 组件暴露了 &lt;strong&gt;el-table&lt;/strong&gt; 实例和一些组件内部的参数和方法：&lt;/p&gt;&lt;p&gt;&lt;span&gt;el-table 方法文档链接&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法名&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;element&lt;/td&gt;&lt;td&gt;&lt;code&gt;el-table&lt;/code&gt; 实例，可以通过&lt;code&gt;element.方法名&lt;/code&gt;来调用 &lt;code&gt;el-table&lt;/code&gt; 的所有方法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;tableData&lt;/td&gt;&lt;td&gt;当前页面所展示的数据&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;searchParam&lt;/td&gt;&lt;td&gt;所有的搜索参数，不包含分页&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pageable&lt;/td&gt;&lt;td&gt;当前表格的分页数据&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;getTableList&lt;/td&gt;&lt;td&gt;获取、刷新表格数据的方法（携带所有参数）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;clearSelection&lt;/td&gt;&lt;td&gt;清空表格所选择的数据，除此方法之外还可使用 &lt;code&gt;element.clearSelection()&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;enumMap&lt;/td&gt;&lt;td&gt;当前表格使用的所有字典数据（Map 数据结构）&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6、ProTable 插槽：&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;插槽名&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;—&lt;/td&gt;&lt;td&gt;默认插槽，支持直接写 el-table-column&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;tableHeader&lt;/td&gt;&lt;td&gt;自定义表格头部左侧区域的插槽，一般情况该区域放操作按钮&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;append&lt;/td&gt;&lt;td&gt;插入至表格最后一行之后的内容， 如果需要对表格的内容进行无限滚动操作，可能需要用到这个 slot。若表格有合计行，该 slot 会位于合计行之上。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;empty&lt;/td&gt;&lt;td&gt;当表格数据为空时自定义的内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;column.prop&lt;/code&gt;&lt;/td&gt;&lt;td&gt;单元格的作用域插槽&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;column.prop&lt;/code&gt; + &quot;Header&quot;&lt;/td&gt;&lt;td&gt;表头的作用域插槽&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;六、代码实现 &amp;amp; 基础使用 💪（代码较多，详情请去项目里查看）&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用一段话总结下我的想法：📚📚&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;🤔 &lt;strong&gt;前提：首先我们在封装 ProTable 组件的时候，在不影响 el-table 原有的属性、事件、方法的前提下，然后在其基础上做二次封装，否则做得再好，也不太完美。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;🧐 &lt;strong&gt;思路：把一个表格页面所有重复的功能 （表格多选、查询、重置、刷新、分页、数据操作二次确认、文件下载、文件上传） 都封装成 Hooks 函数钩子或组件，然后在 ProTable 组件中使用这些函数钩子或组件。在页面中使用的时，只需传给 ProTable 当前表格数据的请求 API、表格配置项 columns 就行了，数据传输都使用 作用域插槽 或 tsx 语法从 ProTable 传递给父组件就能在页面上获取到了。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、常用 Hooks 函数&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { Table } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./interface&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { reactive, computed, onMounted, toRefs } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * @description table 页面操作方法封装&lt;br/&gt; * @param {Function} api 获取表格数据 api 方法(必传)&lt;br/&gt; * @param {Object} initParam 获取数据初始化参数(非必传，默认为{})&lt;br/&gt; * @param {Boolean} isPageable 是否有分页(非必传，默认为true)&lt;br/&gt; * @param {Function} dataCallBack 对后台返回的数据进行处理的方法(非必传)&lt;br/&gt; * */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; useTable = (&lt;br/&gt;  api: &lt;span&gt;(&lt;span&gt;params: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt;,&lt;br/&gt;  initParam: object = {},&lt;br/&gt;  isPageable: &lt;span&gt;boolean&lt;/span&gt; = &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  dataCallBack?: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; state = reactive&amp;lt;Table.TableStateProps&amp;gt;({&lt;br/&gt;    &lt;span&gt;// 表格数据&lt;/span&gt;&lt;br/&gt;    tableData: [],&lt;br/&gt;    &lt;span&gt;// 分页数据&lt;/span&gt;&lt;br/&gt;    pageable: {&lt;br/&gt;      &lt;span&gt;// 当前页数&lt;/span&gt;&lt;br/&gt;      pageNum: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;// 每页显示条数&lt;/span&gt;&lt;br/&gt;      pageSize: &lt;span&gt;10&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;// 总条数&lt;/span&gt;&lt;br/&gt;      total: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// 查询参数(只包括查询)&lt;/span&gt;&lt;br/&gt;    searchParam: {},&lt;br/&gt;    &lt;span&gt;// 初始化默认的查询参数&lt;/span&gt;&lt;br/&gt;    searchInitParam: {},&lt;br/&gt;    &lt;span&gt;// 总参数(包含分页和查询参数)&lt;/span&gt;&lt;br/&gt;    totalParam: {},&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * @description 分页查询参数(只包括分页和表格字段排序,其他排序方式可自行配置)&lt;br/&gt;   * */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; pageParam = computed({&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;        pageNum: state.pageable.pageNum,&lt;br/&gt;        pageSize: state.pageable.pageSize,&lt;br/&gt;      };&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;newVal: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;我是分页更新之后的值&quot;&lt;/span&gt;, newVal);&lt;br/&gt;    },&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 初始化的时候需要做的事情就是 设置表单查询默认值 &amp;amp;&amp;amp; 获取表格数据(reset函数的作用刚好是这两个功能)&lt;/span&gt;&lt;br/&gt;  onMounted(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    reset();&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * @description 获取表格数据&lt;br/&gt;   * @return void&lt;br/&gt;   * */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; getTableList = &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 先把初始化参数和分页参数放到总参数里面&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;Object&lt;/span&gt;.assign(&lt;br/&gt;        state.totalParam,&lt;br/&gt;        initParam,&lt;br/&gt;        isPageable ? pageParam.value : {}&lt;br/&gt;      );&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; { data } = &lt;span&gt;await&lt;/span&gt; api(state.totalParam);&lt;br/&gt;      dataCallBack &amp;amp;&amp;amp; (data = dataCallBack(data));&lt;br/&gt;      state.tableData = isPageable ? data.datalist : data;&lt;br/&gt;      &lt;span&gt;// 解构后台返回的分页数据 (如果有分页更新分页信息)&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; { pageNum, pageSize, total } = data;&lt;br/&gt;      isPageable &amp;amp;&amp;amp; updatePageable({ pageNum, pageSize, total });&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(error);&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * @description 更新查询参数&lt;br/&gt;   * @return void&lt;br/&gt;   * */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; updatedTotalParam = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    state.totalParam = {};&lt;br/&gt;    &lt;span&gt;// 处理查询参数，可以给查询参数加自定义前缀操作&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; nowSearchParam: { [key: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;any&lt;/span&gt; } = {};&lt;br/&gt;    &lt;span&gt;// 防止手动清空输入框携带参数（这里可以自定义查询参数前缀）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt; state.searchParam) {&lt;br/&gt;      &lt;span&gt;// * 某些情况下参数为 false/0 也应该携带参数&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;        state.searchParam[key] ||&lt;br/&gt;        state.searchParam[key] === &lt;span&gt;false&lt;/span&gt; ||&lt;br/&gt;        state.searchParam[key] === &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;      ) {&lt;br/&gt;        nowSearchParam[key] = state.searchParam[key];&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;Object&lt;/span&gt;.assign(&lt;br/&gt;      state.totalParam,&lt;br/&gt;      nowSearchParam,&lt;br/&gt;      isPageable ? pageParam.value : {}&lt;br/&gt;    );&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * @description 更新分页信息&lt;br/&gt;   * @param {Object} resPageable 后台返回的分页数据&lt;br/&gt;   * @return void&lt;br/&gt;   * */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; updatePageable = &lt;span&gt;(&lt;span&gt;resPageable: Table.Pageable&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;Object&lt;/span&gt;.assign(state.pageable, resPageable);&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * @description 表格数据查询&lt;br/&gt;   * @return void&lt;br/&gt;   * */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; search = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    state.pageable.pageNum = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    updatedTotalParam();&lt;br/&gt;    getTableList();&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * @description 表格数据重置&lt;br/&gt;   * @return void&lt;br/&gt;   * */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; reset = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    state.pageable.pageNum = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    state.searchParam = {};&lt;br/&gt;    &lt;span&gt;// 重置搜索表单的时，如果有默认搜索参数，则重置默认的搜索参数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Object&lt;/span&gt;.keys(state.searchInitParam).forEach(&lt;span&gt;(&lt;span&gt;key&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      state.searchParam[key] = state.searchInitParam[key];&lt;br/&gt;    });&lt;br/&gt;    updatedTotalParam();&lt;br/&gt;    getTableList();&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * @description 每页条数改变&lt;br/&gt;   * @param {Number} val 当前条数&lt;br/&gt;   * @return void&lt;br/&gt;   * */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; handleSizeChange = &lt;span&gt;(&lt;span&gt;val: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    state.pageable.pageNum = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    state.pageable.pageSize = val;&lt;br/&gt;    getTableList();&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * @description 当前页改变&lt;br/&gt;   * @param {Number} val 当前页&lt;br/&gt;   * @return void&lt;br/&gt;   * */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; handleCurrentChange = &lt;span&gt;(&lt;span&gt;val: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    state.pageable.pageNum = val;&lt;br/&gt;    getTableList();&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    ...toRefs(state),&lt;br/&gt;    getTableList,&lt;br/&gt;    search,&lt;br/&gt;    reset,&lt;br/&gt;    handleSizeChange,&lt;br/&gt;    handleCurrentChange,&lt;br/&gt;  };&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { ref, computed } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * @description 表格多选数据操作&lt;br/&gt; * @param {String} selectId 当表格可以多选时，所指定的 id&lt;br/&gt; * @param {Any} tableRef 当表格 ref&lt;br/&gt; * */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; useSelection = &lt;span&gt;(&lt;span&gt;selectId: &lt;span&gt;string&lt;/span&gt; = &quot;id&quot;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 是否选中数据&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; isSelected = ref&amp;lt;&lt;span&gt;boolean&lt;/span&gt;&amp;gt;(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;// 选中的数据列表&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; selectedList = ref([]);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 当前选中的所有ids(数组)，可根据项目自行配置id字段&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; selectedListIds = computed((): &lt;span&gt;string&lt;/span&gt;[] =&amp;gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; ids: &lt;span&gt;string&lt;/span&gt;[] = [];&lt;br/&gt;    selectedList.value.forEach(&lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      ids.push(item[selectId]);&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ids;&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 获取行数据的 Key,用来优化 Table 的渲染;在使用跨页多选时,该属性是必填的&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; getRowKeys = &lt;span&gt;(&lt;span&gt;row: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; row[selectId];&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * @description 多选操作&lt;br/&gt;   * @param {Array} rowArr 当前选择的所有数据&lt;br/&gt;   * @return void&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; selectionChange = &lt;span&gt;(&lt;span&gt;rowArr: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    rowArr.length === &lt;span&gt;0&lt;/span&gt; ? (isSelected.value = &lt;span&gt;false&lt;/span&gt;) : (isSelected.value = &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    selectedList.value = rowArr;&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    isSelected,&lt;br/&gt;    selectedList,&lt;br/&gt;    selectedListIds,&lt;br/&gt;    selectionChange,&lt;br/&gt;    getRowKeys&lt;br/&gt;  };&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { ElNotification } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;element-plus&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * @description 接收数据流生成blob，创建链接，下载文件&lt;br/&gt; * @param {Function} api 导出表格的api方法(必传)&lt;br/&gt; * @param {String} tempName 导出的文件名(必传)&lt;br/&gt; * @param {Object} params 导出的参数(默认为空对象)&lt;br/&gt; * @param {Boolean} isNotify 是否有导出消息提示(默认为 true)&lt;br/&gt; * @param {String} fileType 导出的文件格式(默认为.xlsx)&lt;br/&gt; * @return void&lt;br/&gt; * */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; useDownload = &lt;span&gt;async&lt;/span&gt; (&lt;br/&gt;  api: &lt;span&gt;(&lt;span&gt;param: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt;,&lt;br/&gt;  tempName: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  params: &lt;span&gt;any&lt;/span&gt; = {},&lt;br/&gt;  isNotify: &lt;span&gt;boolean&lt;/span&gt; = &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  fileType: &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;.xlsx&quot;&lt;/span&gt;&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (isNotify) {&lt;br/&gt;    ElNotification({&lt;br/&gt;      title: &lt;span&gt;&quot;温馨提示&quot;&lt;/span&gt;,&lt;br/&gt;      message: &lt;span&gt;&quot;如果数据庞大会导致下载缓慢哦，请您耐心等待！&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;info&quot;&lt;/span&gt;,&lt;br/&gt;      duration: &lt;span&gt;3000&lt;/span&gt;&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; res = &lt;span&gt;await&lt;/span&gt; api(params);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; blob = &lt;span&gt;new&lt;/span&gt; Blob([res]);&lt;br/&gt;    &lt;span&gt;// 兼容 edge 不支持 createObjectURL 方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;msSaveOrOpenBlob&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; navigator) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;window&lt;/span&gt;.navigator.msSaveOrOpenBlob(blob, tempName + fileType);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; blobUrl = &lt;span&gt;window&lt;/span&gt;.URL.createObjectURL(blob);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; exportFile = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&quot;a&quot;&lt;/span&gt;);&lt;br/&gt;    exportFile.style.display = &lt;span&gt;&quot;none&quot;&lt;/span&gt;;&lt;br/&gt;    exportFile.download = &lt;span&gt;`&lt;span&gt;${tempName}${fileType}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;    exportFile.href = blobUrl;&lt;br/&gt;    &lt;span&gt;document&lt;/span&gt;.body.appendChild(exportFile);&lt;br/&gt;    exportFile.click();&lt;br/&gt;    &lt;span&gt;// 去除下载对 url 的影响&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;document&lt;/span&gt;.body.removeChild(exportFile);&lt;br/&gt;    &lt;span&gt;window&lt;/span&gt;.URL.revokeObjectURL(blobUrl);&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(error);&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { ElMessageBox, ElMessage } from &lt;span&gt;&quot;element-plus&quot;&lt;/span&gt;;&lt;br/&gt;import { HandleData } from &lt;span&gt;&quot;./interface&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 操作单条数据信息(二次确认【删除、禁用、启用、重置密码】)&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; {Function} api 操作数据接口的api方法(必传)&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; {Object} params 携带的操作数据参数 {id,params}(必传)&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; {String} message 提示信息(必传)&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; {String} confirmType icon类型(不必传,默认为 warning)&lt;br/&gt; * &lt;span&gt;@return&lt;/span&gt; Promise&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;export &lt;span&gt;const&lt;/span&gt; useHandleData = &amp;lt;P = any, R = any&amp;gt;(&lt;br/&gt;  api: (params: P) =&amp;gt; Promise&amp;lt;R&amp;gt;,&lt;br/&gt;  params: Parameters&amp;lt;typeof api&amp;gt;[&lt;span&gt;0&lt;/span&gt;],&lt;br/&gt;  message: string,&lt;br/&gt;  confirmType: HandleData.MessageType = &lt;span&gt;&quot;warning&quot;&lt;/span&gt;&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt; {&lt;br/&gt;    ElMessageBox.confirm(`是否${message}?`, &lt;span&gt;&quot;温馨提示&quot;&lt;/span&gt;, {&lt;br/&gt;      confirmButtonText: &lt;span&gt;&quot;确定&quot;&lt;/span&gt;,&lt;br/&gt;      cancelButtonText: &lt;span&gt;&quot;取消&quot;&lt;/span&gt;,&lt;br/&gt;      type: confirmType,&lt;br/&gt;      draggable: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    }).then(async () =&amp;gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; res = await api(params);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!res) &lt;span&gt;return&lt;/span&gt; reject(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;      ElMessage({&lt;br/&gt;        type: &lt;span&gt;&quot;success&quot;&lt;/span&gt;,&lt;br/&gt;        message: `${message}成功!`&lt;br/&gt;      });&lt;br/&gt;      resolve(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、Protable 组件：&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;!-- 查询表单 card --&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;SearchForm&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:search&lt;/span&gt;=&lt;span&gt;&quot;search&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:reset&lt;/span&gt;=&lt;span&gt;&quot;reset&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:searchParam&lt;/span&gt;=&lt;span&gt;&quot;searchParam&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:columns&lt;/span&gt;=&lt;span&gt;&quot;searchColumns&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;:searchCol&lt;/span&gt;=&lt;span&gt;&quot;searchCol&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;v-show&lt;/span&gt;=&lt;span&gt;&quot;isShowSearch&quot;&lt;/span&gt;&lt;br/&gt;  /&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;!-- 表格内容 card --&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;card table&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;!-- 表格头部 操作按钮 --&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;table-header&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;header-button-lf&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;slot&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;tableHeader&quot;&lt;/span&gt; &lt;span&gt;:selectedListIds&lt;/span&gt;=&lt;span&gt;&quot;selectedListIds&quot;&lt;/span&gt; &lt;span&gt;:selectList&lt;/span&gt;=&lt;span&gt;&quot;selectedList&quot;&lt;/span&gt; &lt;span&gt;:isSelected&lt;/span&gt;=&lt;span&gt;&quot;isSelected&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;slot&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;header-button-ri&quot;&lt;/span&gt; &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;toolButton&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;Refresh&quot;&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;getTableList&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;Printer&quot;&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;columns.length&quot;&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;handlePrint&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;Operation&quot;&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;columns.length&quot;&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;openColSetting&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;Search&quot;&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;searchColumns.length&quot;&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;isShowSearch = !isShowSearch&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;!-- 表格主体 --&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;el-table&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;tableRef&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;v-bind&lt;/span&gt;=&lt;span&gt;&quot;$attrs&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:data&lt;/span&gt;=&lt;span&gt;&quot;tableData&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:border&lt;/span&gt;=&lt;span&gt;&quot;border&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:row-key&lt;/span&gt;=&lt;span&gt;&quot;getRowKeys&quot;&lt;/span&gt;&lt;br/&gt;      @&lt;span&gt;selection-change&lt;/span&gt;=&lt;span&gt;&quot;selectionChange&quot;&lt;/span&gt;&lt;br/&gt;    &amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;!-- 默认插槽 --&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;slot&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;slot&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt; &lt;span&gt;v-for&lt;/span&gt;=&lt;span&gt;&quot;item in tableColumns&quot;&lt;/span&gt; &lt;span&gt;:key&lt;/span&gt;=&lt;span&gt;&quot;item&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;!-- selection || index --&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-table-column&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;v-bind&lt;/span&gt;=&lt;span&gt;&quot;item&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;:align&lt;/span&gt;=&lt;span&gt;&quot;item.align ?? &#x27;center&#x27;&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;:reserve-selection&lt;/span&gt;=&lt;span&gt;&quot;item.type == &#x27;selection&#x27;&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;item.type == &#x27;selection&#x27; || item.type == &#x27;index&#x27;&quot;&lt;/span&gt;&lt;br/&gt;        &amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;el-table-column&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;!-- expand 支持 tsx 语法 &amp;amp;&amp;amp; 作用域插槽 (tsx &amp;gt; slot) --&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-table-column&lt;/span&gt; &lt;span&gt;v-bind&lt;/span&gt;=&lt;span&gt;&quot;item&quot;&lt;/span&gt; &lt;span&gt;:align&lt;/span&gt;=&lt;span&gt;&quot;item.align ?? &#x27;center&#x27;&quot;&lt;/span&gt; &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;item.type == &#x27;expand&#x27;&quot;&lt;/span&gt; &lt;span&gt;v-slot&lt;/span&gt;=&lt;span&gt;&quot;scope&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;&lt;span&gt;component&lt;/span&gt; &lt;span&gt;:is&lt;/span&gt;=&lt;span&gt;&quot;item.render&quot;&lt;/span&gt; &lt;span&gt;:row&lt;/span&gt;=&lt;span&gt;&quot;scope.row&quot;&lt;/span&gt; &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;item.render&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;component&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;&lt;span&gt;slot&lt;/span&gt; &lt;span&gt;:name&lt;/span&gt;=&lt;span&gt;&quot;item.type&quot;&lt;/span&gt; &lt;span&gt;:row&lt;/span&gt;=&lt;span&gt;&quot;scope.row&quot;&lt;/span&gt; &lt;span&gt;v-else&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;slot&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;el-table-column&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;!-- other 循环递归 --&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;TableColumn&lt;/span&gt; &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;!item.type &amp;amp;&amp;amp; item.prop &amp;amp;&amp;amp; item.isShow&quot;&lt;/span&gt; &lt;span&gt;:column&lt;/span&gt;=&lt;span&gt;&quot;item&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt; &lt;span&gt;v-for&lt;/span&gt;=&lt;span&gt;&quot;slot in Object.keys($slots)&quot;&lt;/span&gt; #[&lt;span&gt;slot&lt;/span&gt;]=&lt;span&gt;&quot;scope&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;slot&lt;/span&gt; &lt;span&gt;:name&lt;/span&gt;=&lt;span&gt;&quot;slot&quot;&lt;/span&gt; &lt;span&gt;:row&lt;/span&gt;=&lt;span&gt;&quot;scope.row&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;slot&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;TableColumn&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;!-- 无数据 --&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt; #&lt;span&gt;empty&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;table-empty&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;&lt;span&gt;img&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;@/assets/images/notData.png&quot;&lt;/span&gt; &lt;span&gt;alt&lt;/span&gt;=&lt;span&gt;&quot;notData&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;暂无数据&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;el-table&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;!-- 分页组件 --&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;Pagination&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;pagination&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:pageable&lt;/span&gt;=&lt;span&gt;&quot;pageable&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:handleSizeChange&lt;/span&gt;=&lt;span&gt;&quot;handleSizeChange&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:handleCurrentChange&lt;/span&gt;=&lt;span&gt;&quot;handleCurrentChange&quot;&lt;/span&gt;&lt;br/&gt;    /&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;!-- 列设置 --&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;ColSetting&lt;/span&gt; &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;toolButton&quot;&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;colRef&quot;&lt;/span&gt; &lt;span&gt;v-model:colSetting&lt;/span&gt;=&lt;span&gt;&quot;colSetting&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;=&lt;span&gt;&quot;ts&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;ProTable&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ref, watch, computed, provide } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { useTable } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/hooks/useTable&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { useSelection } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/hooks/useSelection&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { BreakPoint } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/components/Grid/interface&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ColumnProps } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/components/ProTable/interface&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ElTable, TableProps } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;element-plus&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { Refresh, Printer, Operation, Search } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@element-plus/icons-vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { filterEnum, formatValue, handleProp, handleRowAccordingToProp } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/utils/util&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; SearchForm &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/components/SearchForm/index.vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Pagination &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./components/Pagination.vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; ColSetting &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./components/ColSetting.vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; TableColumn &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./components/TableColumn.vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; printJS &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;print-js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 表格 DOM 元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; tableRef = ref&amp;lt;InstanceType&amp;lt;&lt;span&gt;typeof&lt;/span&gt; ElTable&amp;gt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 是否显示搜索模块&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; isShowSearch = ref&amp;lt;boolean&amp;gt;(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;interface ProTableProps extends Partial&amp;lt;Omit&amp;lt;TableProps&amp;lt;any&amp;gt;, &lt;span&gt;&quot;data&quot;&lt;/span&gt;&amp;gt;&amp;gt; {&lt;br/&gt;  &lt;span&gt;columns&lt;/span&gt;: ColumnProps[]; &lt;span&gt;// 列配置项&lt;/span&gt;&lt;br/&gt;  requestApi: &lt;span&gt;(&lt;span&gt;params: any&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;&amp;lt;any&amp;gt;; &lt;span&gt;// 请求表格数据的api ==&amp;gt; 必传&lt;/span&gt;&lt;br/&gt;  dataCallback?: &lt;span&gt;(&lt;span&gt;data: any&lt;/span&gt;) =&amp;gt;&lt;/span&gt; any; &lt;span&gt;// 返回数据的回调函数，可以对数据进行处理 ==&amp;gt; 非必传&lt;/span&gt;&lt;br/&gt;  title?: string; &lt;span&gt;// 表格标题，目前只在打印的时候用到 ==&amp;gt; 非必传&lt;/span&gt;&lt;br/&gt;  pagination?: boolean; &lt;span&gt;// 是否需要分页组件 ==&amp;gt; 非必传（默认为true）&lt;/span&gt;&lt;br/&gt;  initParam?: any; &lt;span&gt;// 初始化请求参数 ==&amp;gt; 非必传（默认为{}）&lt;/span&gt;&lt;br/&gt;  border?: boolean; &lt;span&gt;// 是否带有纵向边框 ==&amp;gt; 非必传（默认为true）&lt;/span&gt;&lt;br/&gt;  toolButton?: boolean; &lt;span&gt;// 是否显示表格功能按钮 ==&amp;gt; 非必传（默认为true）&lt;/span&gt;&lt;br/&gt;  selectId?: string; &lt;span&gt;// 当表格数据多选时，所指定的 id ==&amp;gt; 非必传（默认为 id）&lt;/span&gt;&lt;br/&gt;  searchCol?: number | Record&amp;lt;BreakPoint, number&amp;gt;; &lt;span&gt;// 表格搜索项 每列占比配置 ==&amp;gt; 非必传 { xs: 1, sm: 2, md: 2, lg: 3, xl: 4 }&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 接受父组件参数，配置默认值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; props = withDefaults(defineProps&amp;lt;ProTableProps&amp;gt;(), {&lt;br/&gt;  &lt;span&gt;columns&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; [],&lt;br/&gt;  &lt;span&gt;pagination&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;initParam&lt;/span&gt;: {},&lt;br/&gt;  &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;toolButton&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;selectId&lt;/span&gt;: &lt;span&gt;&quot;id&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;searchCol&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; ({ &lt;span&gt;xs&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;sm&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;md&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;lg&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;xl&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt; })&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 表格多选 Hooks&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { selectionChange, getRowKeys, selectedList, selectedListIds, isSelected } = useSelection(props.selectId);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 表格操作 Hooks&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { tableData, pageable, searchParam, searchInitParam, getTableList, search, reset, handleSizeChange, handleCurrentChange } =&lt;br/&gt;  useTable(props.requestApi, props.initParam, props.pagination, props.dataCallback);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 清空选中数据列表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; clearSelection = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; tableRef.value!.clearSelection();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 监听页面 initParam 改化，重新获取表格数据&lt;/span&gt;&lt;br/&gt;watch(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; props.initParam,&lt;br/&gt;  () =&amp;gt; {&lt;br/&gt;    getTableList();&lt;br/&gt;  },&lt;br/&gt;  { &lt;span&gt;deep&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; }&lt;br/&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 接收 columns 并设置为响应式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; tableColumns = ref&amp;lt;ColumnProps[]&amp;gt;(props.columns);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 定义 enumMap 存储 enum 值（避免异步请求无法格式化单元格内容 || 无法填充搜索下拉选择）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; enumMap = ref(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;&amp;lt;string, { [key: string]: any }[]&amp;gt;());&lt;br/&gt;provide(&lt;span&gt;&quot;enumMap&quot;&lt;/span&gt;, enumMap);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 扁平化 columns &amp;amp;&amp;amp; 处理 tableColumns 数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; flatColumnsFunc = &lt;span&gt;(&lt;span&gt;columns: ColumnProps[], flatArr: ColumnProps[] = []&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  columns.forEach(&lt;span&gt;async&lt;/span&gt; col =&amp;gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (col._children?.length) flatArr.push(...flatColumnsFunc(col._children));&lt;br/&gt;    flatArr.push(col);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 给每一项 column 添加 isShow &amp;amp;&amp;amp; isFilterEnum 属性&lt;/span&gt;&lt;br/&gt;    col.isShow = col.isShow ?? &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    col.isFilterEnum = col.isFilterEnum ?? &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!col.enum) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 如果当前 enum 为后台数据需要请求数据，则调用该请求接口，并存储到 enumMap&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; col.enum !== &lt;span&gt;&quot;function&quot;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; enumMap.value.set(col.prop!, col.enum);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { data } = &lt;span&gt;await&lt;/span&gt; col.enum();&lt;br/&gt;    enumMap.value.set(col.prop!, data);&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; flatArr.filter(&lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; !item._children?.length);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 扁平 columns&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; flatColumns = ref&amp;lt;ColumnProps[]&amp;gt;();&lt;br/&gt;flatColumns.value = flatColumnsFunc(tableColumns.value &lt;span&gt;as&lt;/span&gt; any);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 过滤需要搜索的配置项 &amp;amp;&amp;amp; 处理搜索排序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; searchColumns = flatColumns.value&lt;br/&gt;  .filter(&lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; item.search?.el)&lt;br/&gt;  .sort(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (b.search?.order ?? &lt;span&gt;0&lt;/span&gt;) - (a.search?.order ?? &lt;span&gt;0&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 设置搜索表单的默认值&lt;/span&gt;&lt;br/&gt;searchColumns.forEach(&lt;span&gt;&lt;span&gt;column&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (column.search?.defaultValue !== &lt;span&gt;undefined&lt;/span&gt; &amp;amp;&amp;amp; column.search?.defaultValue !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    searchInitParam.value[column.search.key ?? handleProp(column.prop!)] = column.search?.defaultValue;&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 列设置 ==&amp;gt; 过滤掉不需要设置显隐的列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; colRef = ref();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; colSetting = tableColumns.value!.filter(&lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; item.isShow &amp;amp;&amp;amp; item.type !== &lt;span&gt;&quot;selection&quot;&lt;/span&gt; &amp;amp;&amp;amp; item.type !== &lt;span&gt;&quot;index&quot;&lt;/span&gt; &amp;amp;&amp;amp; item.type !== &lt;span&gt;&quot;expand&quot;&lt;/span&gt; &amp;amp;&amp;amp; item.prop !== &lt;span&gt;&quot;operation&quot;&lt;/span&gt;;&lt;br/&gt;});&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; openColSetting = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  colRef.value.openColSetting();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 处理打印数据（把后台返回的值根据 enum 做转换）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; printData = computed(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; printDataList = &lt;span&gt;JSON&lt;/span&gt;.parse(&lt;span&gt;JSON&lt;/span&gt;.stringify(selectedList.value.length ? selectedList.value : tableData.value));&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; colEnumList = flatColumns.value!.filter(&lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; item.enum || (item.prop &amp;amp;&amp;amp; item.prop.split(&lt;span&gt;&quot;.&quot;&lt;/span&gt;).length &amp;gt; &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;  colEnumList.forEach(&lt;span&gt;&lt;span&gt;colItem&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    printDataList.forEach(&lt;span&gt;(&lt;span&gt;tableItem: { [key: string]: any }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      tableItem[handleProp(colItem.prop!)] =&lt;br/&gt;        colItem.prop!.split(&lt;span&gt;&quot;.&quot;&lt;/span&gt;).length &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; !colItem.enum&lt;br/&gt;          ? formatValue(handleRowAccordingToProp(tableItem, colItem.prop!))&lt;br/&gt;          : filterEnum(handleRowAccordingToProp(tableItem, colItem.prop!), enumMap.value.get(colItem.prop!), colItem.fieldNames);&lt;br/&gt;    });&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; printDataList;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 打印表格数据（💥 多级表头数据打印时，只能扁平化成一维数组，printJs 不支持多级表头打印）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; handlePrint = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  printJS({&lt;br/&gt;    &lt;span&gt;printable&lt;/span&gt;: printData.value,&lt;br/&gt;    &lt;span&gt;header&lt;/span&gt;: props.title &amp;amp;&amp;amp; &lt;span&gt;`&amp;lt;div style=&quot;display: flex;flex-direction: column;text-align: center&quot;&amp;gt;&amp;lt;h2&amp;gt;&lt;span&gt;${props.title}&lt;/span&gt;&amp;lt;/h2&amp;gt;&amp;lt;/div&amp;gt;`&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;properties&lt;/span&gt;: flatColumns&lt;br/&gt;      .value!.filter(&lt;br/&gt;        &lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;br/&gt;          item.isShow &amp;amp;&amp;amp; item.type !== &lt;span&gt;&quot;selection&quot;&lt;/span&gt; &amp;amp;&amp;amp; item.type !== &lt;span&gt;&quot;index&quot;&lt;/span&gt; &amp;amp;&amp;amp; item.type !== &lt;span&gt;&quot;expand&quot;&lt;/span&gt; &amp;amp;&amp;amp; item.prop !== &lt;span&gt;&quot;operation&quot;&lt;/span&gt;&lt;br/&gt;      )&lt;br/&gt;      .map(&lt;span&gt;(&lt;span&gt;item: ColumnProps&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;field&lt;/span&gt;: handleProp(item.prop!),&lt;br/&gt;          &lt;span&gt;displayName&lt;/span&gt;: item.label&lt;br/&gt;        };&lt;br/&gt;      }),&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;json&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;gridHeaderStyle&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;&quot;border: 1px solid #ebeef5;height: 45px;font-size: 14px;color: #232425;text-align: center;background-color: #fafafa;&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;gridStyle&lt;/span&gt;: &lt;span&gt;&quot;border: 1px solid #ebeef5;height: 40px;font-size: 14px;color: #494b4e;text-align: center&quot;&lt;/span&gt;&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 暴露给父组件的参数和方法(外部需要什么，都可以从这里暴露出去)&lt;/span&gt;&lt;br/&gt;defineExpose({ &lt;span&gt;element&lt;/span&gt;: tableRef, tableData, searchParam, pageable, getTableList, clearSelection });&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;component&lt;/span&gt; &lt;span&gt;:is&lt;/span&gt;=&lt;span&gt;&quot;renderLoop(column)&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;component&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;=&lt;span&gt;&quot;tsx&quot;&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { inject, ref, useSlots } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ElTableColumn, ElTag } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;element-plus&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { filterEnum, formatValue, handleRowAccordingToProp } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/utils/util&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ColumnProps } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/components/ProTable/interface&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; slots = useSlots();&lt;br/&gt;&lt;br/&gt;defineProps&amp;lt;{ &lt;span&gt;column&lt;/span&gt;: ColumnProps }&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; enumMap = inject(&lt;span&gt;&quot;enumMap&quot;&lt;/span&gt;, ref(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;()));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 渲染表格数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; renderCellData = &lt;span&gt;(&lt;span&gt;item: ColumnProps, scope: { [key: string]: any }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; enumMap.value.get(item.prop) &amp;amp;&amp;amp; item.isFilterEnum&lt;br/&gt;    ? filterEnum(handleRowAccordingToProp(scope.row, item.prop!), enumMap.value.get(item.prop)!, item.fieldNames)&lt;br/&gt;    : formatValue(handleRowAccordingToProp(scope.row, item.prop!));&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 获取 tag 类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; getTagType = &lt;span&gt;(&lt;span&gt;item: ColumnProps, scope: { [key: string]: any }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; filterEnum(handleRowAccordingToProp(scope.row, item.prop!), enumMap.value.get(item.prop), item.fieldNames, &lt;span&gt;&quot;tag&quot;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; any;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; renderLoop = &lt;span&gt;(&lt;span&gt;item: ColumnProps&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      {item.isShow &amp;amp;&amp;amp; (&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;ElTableColumn&lt;/span&gt;&lt;br/&gt;          {&lt;span&gt;...item&lt;/span&gt;}&lt;br/&gt;          &lt;span&gt;align&lt;/span&gt;=&lt;span&gt;{item.align&lt;/span&gt; ?? &quot;&lt;span&gt;center&lt;/span&gt;&quot;}&lt;br/&gt;          &lt;span&gt;showOverflowTooltip&lt;/span&gt;=&lt;span&gt;{item.showOverflowTooltip&lt;/span&gt; ?? &lt;span&gt;item.prop&lt;/span&gt; !== &lt;span&gt;&quot;operation&quot;&lt;/span&gt;}&lt;br/&gt;        &amp;gt;&lt;/span&gt;&lt;br/&gt;          {{&lt;br/&gt;            default: (scope: any) =&amp;gt; {&lt;br/&gt;              if (item._children) return item._children.map(child =&amp;gt; renderLoop(child));&lt;br/&gt;              if (item.render) return item.render(scope);&lt;br/&gt;              if (slots[item.prop!]) return slots[item.prop!]!(scope);&lt;br/&gt;              if (item.tag) return &lt;span&gt;&amp;lt;ElTag &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;{getTagType(item,&lt;/span&gt; &lt;span&gt;scope&lt;/span&gt;)}&amp;gt;&lt;/span&gt;{renderCellData(item, scope)}&lt;span&gt;&amp;lt;/ElTag&amp;gt;&lt;/span&gt;;&lt;br/&gt;              return renderCellData(item, scope);&lt;br/&gt;            },&lt;br/&gt;            header: () =&amp;gt; {&lt;br/&gt;              if (item.headerRender) return item.headerRender(item);&lt;br/&gt;              if (slots[`${item.prop}Header`]) return slots[`${item.prop}Header`]!({ row: item });&lt;br/&gt;              return item.label;&lt;br/&gt;            }&lt;br/&gt;          }}&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;ElTableColumn&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      )}&lt;br/&gt;    &lt;span&gt;&amp;lt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、页面使用 ProTable 组件：&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;table-box&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;ProTable&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;proTable&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;title&lt;/span&gt;=&lt;span&gt;&quot;用户列表&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:columns&lt;/span&gt;=&lt;span&gt;&quot;columns&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:requestApi&lt;/span&gt;=&lt;span&gt;&quot;getTableList&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:initParam&lt;/span&gt;=&lt;span&gt;&quot;initParam&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:dataCallback&lt;/span&gt;=&lt;span&gt;&quot;dataCallback&quot;&lt;/span&gt;&lt;br/&gt;    &amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;!-- 表格 header 按钮 --&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt; #&lt;span&gt;tableHeader&lt;/span&gt;=&lt;span&gt;&quot;scope&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;CirclePlus&quot;&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;openDrawer(&#x27;新增&#x27;)&quot;&lt;/span&gt; &lt;span&gt;v-auth&lt;/span&gt;=&lt;span&gt;&quot;[&#x27;add&#x27;]&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;新增用户&lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;Upload&quot;&lt;/span&gt; &lt;span&gt;plain&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;batchAdd&quot;&lt;/span&gt; &lt;span&gt;v-auth&lt;/span&gt;=&lt;span&gt;&quot;[&#x27;batchAdd&#x27;]&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;批量添加用户&lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;Download&quot;&lt;/span&gt; &lt;span&gt;plain&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;downloadFile&quot;&lt;/span&gt; &lt;span&gt;v-auth&lt;/span&gt;=&lt;span&gt;&quot;[&#x27;export&#x27;]&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;导出用户数据&lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;danger&quot;&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;Delete&quot;&lt;/span&gt; &lt;span&gt;plain&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;batchDelete(scope.selectedListIds)&quot;&lt;/span&gt; &lt;span&gt;:disabled&lt;/span&gt;=&lt;span&gt;&quot;!scope.isSelected&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          批量删除用户&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;!-- Expand --&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt; #&lt;span&gt;expand&lt;/span&gt;=&lt;span&gt;&quot;scope&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        {{ scope.row }}&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;!-- usernameHeader --&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt; #&lt;span&gt;usernameHeader&lt;/span&gt;=&lt;span&gt;&quot;scope&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;ElMessage.success(&#x27;我是通过作用域插槽渲染的表头&#x27;)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          {{ scope.row.label }}&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;!-- createTime --&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt; #&lt;span&gt;createTime&lt;/span&gt;=&lt;span&gt;&quot;scope&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;ElMessage.success(&#x27;我是通过作用域插槽渲染的内容&#x27;)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          {{ scope.row.createTime }}&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;!-- 表格操作 --&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt; #&lt;span&gt;operation&lt;/span&gt;=&lt;span&gt;&quot;scope&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;View&quot;&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;openDrawer(&#x27;查看&#x27;, scope.row)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;查看&lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;EditPen&quot;&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;openDrawer(&#x27;编辑&#x27;, scope.row)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;编辑&lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;Refresh&quot;&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;resetPass(scope.row)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;重置密码&lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; &lt;span&gt;:icon&lt;/span&gt;=&lt;span&gt;&quot;Delete&quot;&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;deleteAccount(scope.row)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;删除&lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;ProTable&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;UserDrawer&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;drawerRef&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;ImportExcel&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;dialogRef&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;=&lt;span&gt;&quot;tsx&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;useComponent&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ref, reactive } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ElMessage } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;element-plus&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { User } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/api/interface&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ColumnProps } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/components/ProTable/interface&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { useHandleData } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/hooks/useHandleData&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { useDownload } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/hooks/useDownload&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { useAuthButtons } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/hooks/useAuthButtons&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; ProTable &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/components/ProTable/index.vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; ImportExcel &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/components/ImportExcel/index.vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; UserDrawer &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/views/proTable/components/UserDrawer.vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { CirclePlus, Delete, EditPen, Download, Upload, View, Refresh } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@element-plus/icons-vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {&lt;br/&gt;  getUserList,&lt;br/&gt;  deleteUser,&lt;br/&gt;  editUser,&lt;br/&gt;  addUser,&lt;br/&gt;  changeUserStatus,&lt;br/&gt;  resetUserPassWord,&lt;br/&gt;  exportUserInfo,&lt;br/&gt;  BatchAddUser,&lt;br/&gt;  getUserStatus,&lt;br/&gt;  getUserGender&lt;br/&gt;} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@/api/modules/user&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 获取 ProTable 元素，调用其获取刷新数据方法（还能获取到当前查询参数，方便导出携带参数）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; proTable = ref();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如果表格需要初始化请求参数，直接定义传给 ProTable(之后每次请求都会自动带上该参数，此参数更改之后也会一直带上，改变此参数会自动刷新表格数据)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; initParam = reactive({&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// dataCallback 是对于返回的表格数据做处理，如果你后台返回的数据不是 datalist &amp;amp;&amp;amp; total &amp;amp;&amp;amp; pageNum &amp;amp;&amp;amp; pageSize 这些字段，那么你可以在这里进行处理成这些字段&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; dataCallback = &lt;span&gt;(&lt;span&gt;data: any&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;datalist&lt;/span&gt;: data.datalist,&lt;br/&gt;    &lt;span&gt;total&lt;/span&gt;: data.total,&lt;br/&gt;    &lt;span&gt;pageNum&lt;/span&gt;: data.pageNum,&lt;br/&gt;    &lt;span&gt;pageSize&lt;/span&gt;: data.pageSize&lt;br/&gt;  };&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如果你想在请求之前对当前请求参数做一些操作，可以自定义如下函数：params 为当前所有的请求参数（包括分页），最后返回请求列表接口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 默认不做操作就直接在 ProTable 组件上绑定 :requestApi=&quot;getUserList&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; getTableList = &lt;span&gt;(&lt;span&gt;params: any&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; newParams = { ...params };&lt;br/&gt;  newParams.username &amp;amp;&amp;amp; (newParams.username = &lt;span&gt;&quot;custom-&quot;&lt;/span&gt; + newParams.username);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; getUserList(newParams);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 页面按钮权限（按钮权限既可以使用 hooks，也可以直接使用 v-auth 指令，指令适合直接绑定在按钮上，hooks 适合根据按钮权限显示不同的内容）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { BUTTONS } = useAuthButtons();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 自定义渲染表头（使用tsx语法）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; headerRender = &lt;span&gt;(&lt;span&gt;row: ColumnProps&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        ElMessage.success(&quot;我是通过 tsx 语法渲染的表头&quot;);&lt;br/&gt;      }}&lt;br/&gt;    &amp;gt;&lt;br/&gt;      {row.label}&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 表格配置项&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; columns: ColumnProps[] = [&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;selection&quot;&lt;/span&gt;, &lt;span&gt;fixed&lt;/span&gt;: &lt;span&gt;&quot;left&quot;&lt;/span&gt;, &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;80&lt;/span&gt; },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;index&quot;&lt;/span&gt;, &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;#&quot;&lt;/span&gt;, &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;80&lt;/span&gt; },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;expand&quot;&lt;/span&gt;, &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;Expand&quot;&lt;/span&gt;, &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;100&lt;/span&gt; },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;prop&lt;/span&gt;: &lt;span&gt;&quot;username&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;用户姓名&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;search&lt;/span&gt;: { &lt;span&gt;el&lt;/span&gt;: &lt;span&gt;&quot;input&quot;&lt;/span&gt; },&lt;br/&gt;    &lt;span&gt;render&lt;/span&gt;: &lt;span&gt;&lt;span&gt;scope&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;el-button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt; =&amp;gt;&lt;/span&gt; ElMessage.success(&quot;我是通过 tsx 语法渲染的内容&quot;)}&amp;gt;&lt;br/&gt;          {scope.row.username}&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;el-button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;      );&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;prop&lt;/span&gt;: &lt;span&gt;&quot;gender&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;性别&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;enum&lt;/span&gt;: getUserGender,&lt;br/&gt;    &lt;span&gt;fieldNames&lt;/span&gt;: { &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;genderLabel&quot;&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&quot;genderValue&quot;&lt;/span&gt; },&lt;br/&gt;    &lt;span&gt;search&lt;/span&gt;: { &lt;span&gt;el&lt;/span&gt;: &lt;span&gt;&quot;select&quot;&lt;/span&gt; }&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;// 多级 prop&lt;/span&gt;&lt;br/&gt;  { &lt;span&gt;prop&lt;/span&gt;: &lt;span&gt;&quot;user.detail.age&quot;&lt;/span&gt;, &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;年龄&quot;&lt;/span&gt;, &lt;span&gt;search&lt;/span&gt;: { &lt;span&gt;el&lt;/span&gt;: &lt;span&gt;&quot;input&quot;&lt;/span&gt; } },&lt;br/&gt;  { &lt;span&gt;prop&lt;/span&gt;: &lt;span&gt;&quot;idCard&quot;&lt;/span&gt;, &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;身份证号&quot;&lt;/span&gt;, &lt;span&gt;search&lt;/span&gt;: { &lt;span&gt;el&lt;/span&gt;: &lt;span&gt;&quot;input&quot;&lt;/span&gt; } },&lt;br/&gt;  { &lt;span&gt;prop&lt;/span&gt;: &lt;span&gt;&quot;email&quot;&lt;/span&gt;, &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;邮箱&quot;&lt;/span&gt;, &lt;span&gt;search&lt;/span&gt;: { &lt;span&gt;el&lt;/span&gt;: &lt;span&gt;&quot;input&quot;&lt;/span&gt; } },&lt;br/&gt;  { &lt;span&gt;prop&lt;/span&gt;: &lt;span&gt;&quot;address&quot;&lt;/span&gt;, &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;居住地址&quot;&lt;/span&gt; },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;prop&lt;/span&gt;: &lt;span&gt;&quot;status&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;用户状态&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;enum&lt;/span&gt;: getUserStatus,&lt;br/&gt;    &lt;span&gt;fieldNames&lt;/span&gt;: { &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;userLabel&quot;&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&quot;userStatus&quot;&lt;/span&gt; },&lt;br/&gt;    &lt;span&gt;search&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;el&lt;/span&gt;: &lt;span&gt;&quot;tree-select&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;props&lt;/span&gt;: { &lt;span&gt;props&lt;/span&gt;: { &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;userLabel&quot;&lt;/span&gt; }, &lt;span&gt;nodeKey&lt;/span&gt;: &lt;span&gt;&quot;userStatus&quot;&lt;/span&gt; }&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;render&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;scope: { row: User.ResUserList }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          {BUTTONS.value.status ? (&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;el-switch&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;model-value&lt;/span&gt;=&lt;span&gt;{scope.row.status}&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;active-text&lt;/span&gt;=&lt;span&gt;{scope.row.status&lt;/span&gt; ? &quot;启用&quot; &lt;span&gt;:&lt;/span&gt; &quot;禁用&quot;}&lt;br/&gt;              &lt;span&gt;active-value&lt;/span&gt;=&lt;span&gt;{1}&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;inactive-value&lt;/span&gt;=&lt;span&gt;{0}&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt; =&amp;gt;&lt;/span&gt; changeStatus(scope.row)}&lt;br/&gt;            /&amp;gt;&lt;br/&gt;          ) : (&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;el-tag&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;{scope.row.status&lt;/span&gt; ? &quot;&lt;span&gt;success&lt;/span&gt;&quot; &lt;span&gt;:&lt;/span&gt; &quot;&lt;span&gt;danger&lt;/span&gt;&quot;}&amp;gt;&lt;/span&gt;{scope.row.status ? &quot;启用&quot; : &quot;禁用&quot;}&lt;span&gt;&amp;lt;/&lt;span&gt;el-tag&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          )}&lt;br/&gt;        &lt;span&gt;&amp;lt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;      );&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;prop&lt;/span&gt;: &lt;span&gt;&quot;createTime&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;创建时间&quot;&lt;/span&gt;,&lt;br/&gt;    headerRender,&lt;br/&gt;    &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;200&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;search&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;el&lt;/span&gt;: &lt;span&gt;&quot;date-picker&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;span&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;defaultValue&lt;/span&gt;: [&lt;span&gt;&quot;2022-11-12 11:35:00&quot;&lt;/span&gt;, &lt;span&gt;&quot;2022-12-12 11:35:00&quot;&lt;/span&gt;],&lt;br/&gt;      &lt;span&gt;props&lt;/span&gt;: { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;datetimerange&quot;&lt;/span&gt; }&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  { &lt;span&gt;prop&lt;/span&gt;: &lt;span&gt;&quot;operation&quot;&lt;/span&gt;, &lt;span&gt;label&lt;/span&gt;: &lt;span&gt;&quot;操作&quot;&lt;/span&gt;, &lt;span&gt;fixed&lt;/span&gt;: &lt;span&gt;&quot;right&quot;&lt;/span&gt;, &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;330&lt;/span&gt; }&lt;br/&gt;];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 删除用户信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; deleteAccount = &lt;span&gt;async&lt;/span&gt; (params: User.ResUserList) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; useHandleData(deleteUser, { &lt;span&gt;id&lt;/span&gt;: [params.id] }, &lt;span&gt;`删除【&lt;span&gt;${params.username}&lt;/span&gt;】用户`&lt;/span&gt;);&lt;br/&gt;  proTable.value.getTableList();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 批量删除用户信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; batchDelete = &lt;span&gt;async&lt;/span&gt; (id: string[]) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; useHandleData(deleteUser, { id }, &lt;span&gt;&quot;删除所选用户信息&quot;&lt;/span&gt;);&lt;br/&gt;  proTable.value.clearSelection();&lt;br/&gt;  proTable.value.getTableList();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 重置用户密码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; resetPass = &lt;span&gt;async&lt;/span&gt; (params: User.ResUserList) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; useHandleData(resetUserPassWord, { &lt;span&gt;id&lt;/span&gt;: params.id }, &lt;span&gt;`重置【&lt;span&gt;${params.username}&lt;/span&gt;】用户密码`&lt;/span&gt;);&lt;br/&gt;  proTable.value.getTableList();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 切换用户状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; changeStatus = &lt;span&gt;async&lt;/span&gt; (row: User.ResUserList) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; useHandleData(changeUserStatus, { &lt;span&gt;id&lt;/span&gt;: row.id, &lt;span&gt;status&lt;/span&gt;: row.status == &lt;span&gt;1&lt;/span&gt; ? &lt;span&gt;0&lt;/span&gt; : &lt;span&gt;1&lt;/span&gt; }, &lt;span&gt;`切换【&lt;span&gt;${row.username}&lt;/span&gt;】用户状态`&lt;/span&gt;);&lt;br/&gt;  proTable.value.getTableList();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 导出用户列表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; downloadFile = &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;  useDownload(exportUserInfo, &lt;span&gt;&quot;用户列表&quot;&lt;/span&gt;, proTable.value.searchParam);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 批量添加用户&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; dialogRef = ref();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; batchAdd = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; params = {&lt;br/&gt;    &lt;span&gt;title&lt;/span&gt;: &lt;span&gt;&quot;用户&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;tempApi&lt;/span&gt;: exportUserInfo,&lt;br/&gt;    &lt;span&gt;importApi&lt;/span&gt;: BatchAddUser,&lt;br/&gt;    &lt;span&gt;getTableList&lt;/span&gt;: proTable.value.getTableList&lt;br/&gt;  };&lt;br/&gt;  dialogRef.value.acceptParams(params);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 打开 drawer(新增、查看、编辑)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; drawerRef = ref();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; openDrawer = &lt;span&gt;(&lt;span&gt;title: string, rowData: Partial&amp;lt;User.ResUserList&amp;gt; = {}&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; params = {&lt;br/&gt;    title,&lt;br/&gt;    &lt;span&gt;rowData&lt;/span&gt;: { ...rowData },&lt;br/&gt;    &lt;span&gt;isView&lt;/span&gt;: title === &lt;span&gt;&quot;查看&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;api&lt;/span&gt;: title === &lt;span&gt;&quot;新增&quot;&lt;/span&gt; ? addUser : title === &lt;span&gt;&quot;编辑&quot;&lt;/span&gt; ? editUser : &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;getTableList&lt;/span&gt;: proTable.value.getTableList&lt;br/&gt;  };&lt;br/&gt;  drawerRef.value.acceptParams(params);&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;七、贡献者 👨‍👦‍👦&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;HalseySpicy&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;denganjia&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;&lt;strong&gt;&lt;sup/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>be7e885b635522c6713e29c186ea1a8a</guid>
<title>实战数据分析: 利用开源项目 Superset 搭建自助数据分析平台</title>
<link>https://toutiao.io/k/p5m36ur</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引子&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据分析（Data Analytics）以及商业智能（Business Intelligence）是很多企业实现数字化战略的重要业务模块。我们之前在&lt;span&gt;《浅谈数据：数据领域需要掌握些什么？》&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 就能提供这样的服务。本文将简单介绍如何安装部署以及使用 Superset。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5284974093264249&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vh4PtSfBxFN7RPNxNEibctL9dddubbTFOkjxdpNEBlKFpPd4RaA0yGxWcgquYfGqWnCuCk5a5kEM3nG8d7bib60Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1544&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Superset Official Site&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Superset 简介&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Superset 是 Apache 基金会孵化的开源自助数据分析平台，可以看成开源版的 &lt;span&gt;Power BI&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 或 &lt;span&gt;Tableau&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;，不过 Superset 的交互界面仅限于 Web。整个系统基于 Python Flask，集成了 MySQL、Postgres、SQL Server 等主流关系性数据库，以及 ElasticSearch、ClickHouse、Snowflake 等现代数据库。前端可视化分析界面跟 Power BI 和 Tableau 非常类似，操作也相对简便。因此，如果需要搭建一个类似 Power BI 或 Tableau 这样的企业级数据分析平台，在不氪金的情况下，Superset 是个非常不错的选择。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6483300589390962&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vh4PtSfBxFN7RPNxNEibctL9dddubbTFOShZKhFwkswMchNrPcS4CiciccaTesoktmhjcJDCRzfpZglRzBRSzZokQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3054&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Superset Dashboard&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安装 Superset&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装 Superset 最简单的方式是 &lt;span&gt;Docker&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 容器。对 Docker 不熟悉的朋友，可以查看 Docker 官网或相关资料，或者跳过本章节让懂技术的朋友帮忙安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你已经安装好了 Docker 以及 &lt;span&gt;Docker Compose&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;，现在可以在指定位置创建容器配置 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件，输入以下内容。其中，我们加入了 MySQL 容器来提供数据库服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;version:&lt;/span&gt; &lt;span&gt;&quot;3.3&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;services:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;superset:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;apache/superset&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;container_name:&lt;/span&gt; &lt;span&gt;superset&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;./startup.sh:/opt/startup.sh&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;8088:8088&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;mysql:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;container_name:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;MYSQL_DATABASE:&lt;/span&gt; &lt;span&gt;&quot;superset&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;MYSQL_ALLOW_EMPTY_PASSWORD:&lt;/span&gt; &lt;span&gt;&quot;yes&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，在同一个目录下创建初始化脚本文件 &lt;code&gt;startup.sh&lt;/code&gt;，输入以下内容。其中，加载演示数据部分已经注释掉，需要查看演示数据的朋友可以取消注释。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#!/bin/sh&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# create admin account&lt;/span&gt;&lt;br/&gt;superset fab create-admin \&lt;br/&gt; --username admin \&lt;br/&gt; --firstname Superset \&lt;br/&gt; --lastname Admin \&lt;br/&gt; --email admin@superset.com \&lt;br/&gt; --password admin&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# upgrade database&lt;/span&gt;&lt;br/&gt;superset db upgrade&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# load examples&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#superset load_examples&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# set up roles&lt;/span&gt;&lt;br/&gt;superset init&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经创建好容器配置文件以及初始化脚本文件，就可以开始启动容器并初始化了。执行以下命令来启动容器以及初始化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# start docker containers&lt;/span&gt;&lt;br/&gt;docker-compose up -d&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# initialize superset&lt;/span&gt;&lt;br/&gt;docker &lt;span&gt;exec&lt;/span&gt; -it sh /opt/startup.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当上述操作执行完毕后，我们就可以用浏览器打开 &lt;code&gt;http://localhost:8088&lt;/code&gt;，进入到 Superset 登陆页面。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5420439844760673&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vh4PtSfBxFN7RPNxNEibctL9dddubbTFOs65IlqHveUdSFlib08N05fk2vR1lXNlVw51FFartoicWuvITokXAARKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1546&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Login Page&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以输入默认用户名密码 &lt;code&gt;admin/admin&lt;/code&gt; 进入界面。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建第一个数据集&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;登陆进入 Superset 之后你会发现目前什么也没有（除非之前取消注释了加载数据）。现在我们需要进行两步操作来创建第一个数据集（Dataset）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;连接数据库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将鼠标悬浮在右上角的加号按钮，继续悬浮到 &lt;code&gt;Data&lt;/code&gt;，然后点击 &lt;code&gt;Connect database&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4942263279445728&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vh4PtSfBxFN7RPNxNEibctL9dddubbTFOJZQibzb1VbBzQo0GXnNKZWXBWiakcG1Dk0JP30YjGia6TiciblJxkia4FyPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;866&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Connect Database&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现弹窗后，选择 &lt;code&gt;MySQL&lt;/code&gt;，并输入数据库连接信息，如下图。然后点击 &lt;code&gt;Connect&lt;/code&gt;，继续点击 &lt;code&gt;Finish&lt;/code&gt; 完成数据库连接。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.669291338582677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vh4PtSfBxFN7RPNxNEibctL9dddubbTFOE2LqWvmuu7jYOBBM9Yecu9gsicekPTTXdP2Nibjaprr5pxyQ5hz095OQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Database Settings&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;设置允许上传文件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了在 Superset 上尽快体验交互式数据分析，我们将选择上传一个 Excel 数据文件到 Superset。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过在此之前，我们需要多做一步，即在 MySQL 中允许上传文件。这个可以通过 Superset 界面进行设置。操作如下。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 &lt;code&gt;Settings&lt;/code&gt; 中点击 &lt;code&gt;Database Connections&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;编辑刚刚创建的 MySQL 数据库；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;点 &lt;code&gt;Advanced&lt;/code&gt;，在 &lt;code&gt;Security&lt;/code&gt; 下勾选 &lt;code&gt;Allow file uploads to database&lt;/code&gt;，然后确定。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，现在我们可以上传 Excel 文件了！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;上传 Excel 数据文件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在右上角点击 &lt;code&gt;Upload file to database&lt;/code&gt; 然后点击 &lt;code&gt;Upload Excel file&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8045454545454546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vh4PtSfBxFN7RPNxNEibctL9dddubbTFOh6F5aHD0Cwl2Oib9qeQU1zXanPWGSDzgj0pY1oEyq2u3LrbOtw2DRXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;440&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Upload Excel file&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，在上传 Excel 页面中，选择要上传的文件，输入表名为 &lt;code&gt;sales&lt;/code&gt;，点击下方的 &lt;code&gt;Save&lt;/code&gt; 按钮，即可创建数据集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了之后的数据分析演示，我们将使用 Kaggle 上的 &lt;span&gt;Sample Sales Data&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 数据集。由于其默认 CSV 文件上传到 Superset 有数据库编码问题，我已经将其转化为 Excel 文件上传到 GitHub，可以通过 &lt;span&gt;GitHub 链接&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;下载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上传 Excel 数据文件完毕后，你可以在 &lt;code&gt;Datasets&lt;/code&gt; 中看到已经创建好的数据集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来看看如何在 Superset 中分析该数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分析销售数据&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击刚才创建好的 &lt;code&gt;sales&lt;/code&gt; 数据集，进入到分析页面。如果你对 Power BI 或者 Tableau 熟悉的话，你会发现这其实就是 Power BI 的 Visual，或 Tableau 中的 Chart。其最左侧是数据集的各个字段，旁边是数据操作区域，右侧是图标展示区域。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5777262180974478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vh4PtSfBxFN7RPNxNEibctL9dddubbTFOicIiazO2oRlibOq49R8RpuTzmotfbX7T8WAAEeqNvnfxHjhjN2yQ6lJXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3448&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Data Analysis 1&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;季节性分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我们想看看按季度的销售额是多少。将左侧的 &lt;code&gt;SALES&lt;/code&gt; 拖到 &lt;code&gt;METRICS&lt;/code&gt;，并选择 &lt;code&gt;SUM&lt;/code&gt;；然后将 &lt;code&gt;YEAR_ID&lt;/code&gt; 和 &lt;code&gt;QTR_ID&lt;/code&gt; 拖到 &lt;code&gt;DIMENSIONS&lt;/code&gt;；再点 &lt;code&gt;CREATE CHART&lt;/code&gt;。我们可以看到如下统计表格。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2832980972515856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vh4PtSfBxFN7RPNxNEibctL9dddubbTFOIfdCZV5kgViazN2HuKwszzkJxplPtSWGk5eicvkNkIoGj7TZjG7e3ia0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2838&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Quarterly Sales&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看到，销售额（Sales）似乎受季节性影响：每个冬季，也就是第四季度会有大量的销售额。这是因为，欧美国家会在圣诞节期间大量采购节日礼品以及物资，形成较高的销售额。因此，这个发现也不意外。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;相关性分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们想关心一下订单数量（Quantity Ordered）与单价（Price Each）跟优惠力度（Deal Size）的关系。我们选择 &lt;code&gt;View all charts&lt;/code&gt;，选择 &lt;code&gt;Bubble Chart&lt;/code&gt;，输入相关字段后，生成如下泡泡图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5743626062322946&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vh4PtSfBxFN7RPNxNEibctL9dddubbTFOgTlpDwJt4LRnS7tMbaibx0c50EolzAicMTibzLJKVu4V0XS4X5y5Q1duQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2824&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Bubble Chart&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，优惠力度越大，订单数量越高；而价格与订单数量没有明显的相关关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上，我们通过鼠标操作几下，就创建了两个简单的图表，从而完成了简单的可视化数据分析。Superset 虽然功能上还不及商业软件 Power BI 和 Tableau，但这对于咱们白嫖玩家来说已经完全够用！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章介绍了如何搭建安装 Superset，以及在 Superset 上创建数据集，以拖拽的方式进行可视化分析，从而帮助我们体验和理解 Superset 在数据分析方面的功能。作为 Apache 基金会孵化出来的开源项目，Superset 是非常优秀的数据分析平台，可以作为一些中小公司的选择，特别是对于有一定运维经验的程序员。不过，Superset 在功能性、易用性、技术生态等方面还达不到同类商业软件 Power BI、Tableau。例如，Power BI 的 Gateway 让其可以轻松的打通各个系统的数据，它其实已经不单是数据可视化工具了，但 Power BI 的商用许可也非常昂贵。Superset 还有其他的一些功能，例如 Dashboard，本文限于篇幅就没有介绍了，以后有机会再详细介绍一下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;社区&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您对笔者的文章感兴趣，可以加笔者微信 tikazyq1 并注明 &quot;码之道&quot;，笔者会将你拉入 &quot;码之道&quot; 交流群。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;p&gt;《浅谈数据：数据领域需要掌握些什么？》: &lt;span&gt;https://mp.weixin.qq.com/s/kthG5Sn1FFZE-uHYgvyguQ&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;p&gt;Power BI: &lt;span&gt;https://powerbi.microsoft.com&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3] &lt;/span&gt;&lt;p&gt;Tableau: &lt;span&gt;https://www.tableau.com/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;p&gt;Docker: &lt;span&gt;https://docker.com&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5] &lt;/span&gt;&lt;p&gt;Docker Compose: &lt;span&gt;https://docs.docker.com/compose/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6] &lt;/span&gt;&lt;p&gt;Sample Sales Data: &lt;span&gt;https://www.kaggle.com/datasets/kyanyoga/sample-sales-data&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7] &lt;/span&gt;&lt;p&gt;GitHub 链接: &lt;span&gt;https://github.com/tikazyq/codao-code/blob/main/2023-01/superset/sales_data_sample.xlsx&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff0bde726e3a5622def98373f11a0d67</guid>
<title>聊聊使用@RefreshScope与nacos2整合踩到的坑</title>
<link>https://toutiao.io/k/yyocnft</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.90625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/W665dT4Q22VeAFzkuQ167BDbRK4SUIL75D5j57hTayQuafoIDfFKUq7XELU5u2KLSsiaDkAic1YQoEk7V8v6tSRg/640?wx_fmt=png&quot; data-w=&quot;64&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注我们&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;1&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文的素材来源于朋友整合nacos2作为配置中心进行动态刷新时，踩到的坑。他当时遇到的问题，如下截图&lt;/span&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6254901960784314&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCcP1py1ogD0ahfJxesfhYG321AibUYTwoyicDrHrZYLvEdzncjdtDUMfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;510&quot;/&gt;&lt;br/&gt;&lt;span&gt;因为那段时间比较忙，于是我在没看朋友项目代码的基础上，就找个了看似解决方案的答案，扔了过去&lt;/span&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8086785009861933&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCZ68cHmEWW3zTGmnKKCTCRqdKkwFj03pWPAcY29La7BD99Ls7DSIaxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;507&quot;/&gt;&lt;br/&gt;&lt;span&gt;后面朋友加了这个配置，问题果然没有解决。后面就抽了一点时间，要了他的项目代码来看下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;2&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;代码示例&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为他这个项目主要是他自学nacos的项目，也没涉及啥敏感信息。本文就直接拿他的项目示例演示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;1、项目pom依赖&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;properties&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;maven.compiler.source&lt;/span&gt;&amp;gt;&lt;/span&gt;8&lt;span&gt;&amp;lt;/&lt;span&gt;maven.compiler.source&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;maven.compiler.target&lt;/span&gt;&amp;gt;&lt;/span&gt;8&lt;span&gt;&amp;lt;/&lt;span&gt;maven.compiler.target&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;java.version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;span&gt;java.version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;spring-boot.version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.3.12.RELEASE&lt;span&gt;&amp;lt;/&lt;span&gt;spring-boot.version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;spring-cloud.version&lt;/span&gt;&amp;gt;&lt;/span&gt;Hoxton.SR12&lt;span&gt;&amp;lt;/&lt;span&gt;spring-cloud.version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;spring-cloud-alibaba.version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.2.8.RELEASE&lt;span&gt;&amp;lt;/&lt;span&gt;spring-cloud-alibaba.version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;properties&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;dependencyManagement&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-alibaba-dependencies&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${spring-cloud-alibaba.version}&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-dependencies&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${spring-boot.version}&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${spring-cloud.version}&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;dependencyManagement&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-alibaba-nacos-config&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;span&gt; nacos服务端版本为2.1.1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;2、nacos配置中心地址，配置在bootstrap.yml里面&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;spring&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;cloud&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;nacos&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;server-addr&lt;/span&gt;: &lt;span&gt;localhost&lt;/span&gt;:&lt;span&gt;8848&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;3、项目的基本信息配置在application.yml里面&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;spring&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;application&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;name&lt;/span&gt;: nacos-config&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;server&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;port&lt;/span&gt;: &lt;span&gt;8030&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;4、编写一个需要动态刷新获取值的controller&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/config&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@RefreshScope&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class ConfigController {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${user.userName:123}&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private String userName;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/get&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private String get(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;userName&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;5、业务项目在nacos服务端上配置如下&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5995955510616785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCyX7ZAiblCAqqetOTkQHp3USDhvNZQ25x9FL6NxicbxlKCJkgib3ICrxdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;989&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以上就是朋友完整的代码例子。我们运行一下代码，会发现controller的userName取不到值。感兴趣的朋友，可以走查一下上述的代码，查找一下原因&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;3&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;取不到值的原因&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;理论知识铺垫&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;当我们使用cglib动态代理调用目标方法时，当方法被private修饰时，this为动态代理对象。当方法被public或者protected修饰时，this为目标对象。此外属性刷新刷的是目标对象的属性，controller的get方法可以看成是&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/get&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;get&lt;/span&gt;(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.userName;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当我们在controller加上@RefreshScope注解时，如果不改变变proxyMode这个属性值时，他默认就会生成一个cglib动态代理。当我们调用get方法，因为get为私有方法，我们可以看成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/get&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;get&lt;/span&gt;(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; cglibProxy.userName;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34204630321135177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCM4bTp9uYSNmZA3ib8ZicvZs0DgBxmgPCGQym5SMJTlmyjqvIqd2QRHuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1339&quot;/&gt;&lt;br/&gt;&lt;span&gt;此时的this是代理对象，而此时userName是代理对象的userName，代理对象的userName是空值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;4&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;解决方法&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方法一、修改@RefreshScope的proxyMode属性&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;将proxyMode改为ScopedProxyMode.DEFAULT或者ScopedProxyMode.NO&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5443864229765013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCbKOZRic8xS2MIwLNMRwicacTgicUzQCdq3BZw1l2LHtbpXfAvzLATMCug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;766&quot;/&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41214351425942963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCYyKRXV0VPZc9u0ChL9eicl4j0Q5V05RovqzbYj1iagJuUicCgqDzFO5GA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot;/&gt;&lt;br/&gt;此时this为目标对象，因此能取到值&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方法二：将目标方法的修饰符改为public或者protected&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7938931297709924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCwdEp4C6naKOwDBG4xafG9GB3l2ibC1HwATfUTbguNPFAa0Y6d3UMG7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot;/&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43756145526057033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCzWicmMvQ1JibuB2Tg9PdvRdibgWgpfvdUwiaOzoicIg7CEeSf5VhQCTC1pg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1017&quot;/&gt;&lt;br/&gt;此时this为目标对象，因此能取到值&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;3、方法三：使用属性配置类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;user&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserProperties {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; userName;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; getUserName() {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; userName;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUserName(&lt;span&gt;String&lt;/span&gt; userName) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.userName = userName;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;controller调整成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/config&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class ConfigController {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private UserProperties userProperties;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/get&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    public String get(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;userProperties&lt;/span&gt;&lt;span&gt;.getUserName&lt;/span&gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;此时controller不用加@RefreshScope也能实现动态刷新。因为属性类上的@ConfigurationProperties本身就具有动态刷新的特性&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;5&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文不算是@RefreshScope与nacos2整合踩到的坑，主要还是动态代理方面的知识，题目有点标题党了。&lt;/p&gt;&lt;p&gt;有些视频讲nacos动态刷新时，基本上都是举controller上@RerfreshScope +@value来讲解。其实利用@ConfigurationProperties也是可以达到类似的效果。如果没和springcloud整合，引入nacos配置中心的starter，使用@NacosPropertySource + @NacosValue或者@NacosRefresh也是可以实现动态刷新，感兴趣的朋友可以试一下&lt;/p&gt;&lt;p&gt;最后，朋友之前在nacos2搭建过程中，也踩到了一些坑。感兴趣的朋友可以查看如下文章&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505367&amp;amp;idx=1&amp;amp;sn=09108bf846131e954a225035f6c11c50&amp;amp;chksm=e9ed3ba1de9ab2b7a96829947f9a4cb64d7270ef10cb96ce09c320ee2d737cc9703cd7b9f91d&amp;amp;token=1802849363&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-linktype=&quot;2&quot;&gt;记一次使用nacos2踩到的坑&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-recommend-type=&quot;list-title&quot; data-mpa-template=&quot;t&quot; data-recommend-tid=&quot;7&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247503181_1&quot; data-recommend-article-time=&quot;1654387443&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/NW0r9OxcmxJXW4o5rcRYz4drUYjmsc2viaR1AGKfdYkiaoIzjnxzEJraPWnLSN95nvK3iaia5v78zEqvovpErqicShw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;聊聊基于docker部署的mysql如何进行数据恢复&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247503181&amp;amp;idx=1&amp;amp;sn=f05e6458d260c487fd564e3152763e29&amp;amp;chksm=e9ed233bde9aaa2de31e70abef843a918679a7b2430deea5a26a562ac63f1f8dc36e4e44edb5#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247503181&amp;amp;idx=1&amp;amp;sn=f05e6458d260c487fd564e3152763e29&amp;amp;chksm=e9ed233bde9aaa2de31e70abef843a918679a7b2430deea5a26a562ac63f1f8dc36e4e44edb5&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;聊聊基于docker部署的mysql如何进行数据恢复&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247497025_1&quot; data-recommend-article-time=&quot;1621123200&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/NW0r9OxcmxKGnUcib5qIhE29YFGGuxWIMHlZhzpbiaRbQoQV7otjU0oEvKACWWRCQ5AVvOZbAzrgWC4Ju4QlE95g/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;聊聊部署在docker容器里面的springboot项目如何启用arthas&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247497025&amp;amp;idx=1&amp;amp;sn=9717c58aa01b1dc4ab5a6640f3d57bbb&amp;amp;chksm=e9ed1b37de9a9221efb10c15452f97d5c57dcd63cac479a4c9d62234be1241d16a67a0bbe4e3#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247497025&amp;amp;idx=1&amp;amp;sn=9717c58aa01b1dc4ab5a6640f3d57bbb&amp;amp;chksm=e9ed1b37de9a9221efb10c15452f97d5c57dcd63cac479a4c9d62234be1241d16a67a0bbe4e3&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;聊聊部署在docker容器里面的springboot项目如何启用arthas&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247505433_2&quot; data-recommend-article-time=&quot;1661385600&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/NW0r9OxcmxJNHLXB5siaR2oQGfRjXQUvFw9VC8kRlaicZh8E6bBYB4e3DjViaHu7UoD6PW1EwBQele5o7NbjhMSFw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;这可能是网上最全的Docker工具集合&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505433&amp;amp;idx=2&amp;amp;sn=0277c5f911906ffa15d2570cde81b15e&amp;amp;chksm=e9ed386fde9ab179dabb93f411b715d21fd829f0527c02d44729f1898077e378f0a5aa50b49d#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505433&amp;amp;idx=2&amp;amp;sn=0277c5f911906ffa15d2570cde81b15e&amp;amp;chksm=e9ed386fde9ab179dabb93f411b715d21fd829f0527c02d44729f1898077e378f0a5aa50b49d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;这可能是网上最全的Docker工具集合&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247505514_1&quot; data-recommend-article-time=&quot;1662508800&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/NW0r9OxcmxLWAbicVuqAsxsfaiaib40V67cU7TCZrvdJBicBtqpgNhEy4Ly1Cj2YxKBIx2Nn26zkUDMZ7EHTlJZgHQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;怎么给生产环境的docker容器 “减肥”？&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505514&amp;amp;idx=1&amp;amp;sn=b6934ff0349c9d245ea24003733e1e11&amp;amp;chksm=e9ed381cde9ab10a6d06a5dbc220fcd974ee5de1fc79c52e99f9df1967e5c0e511e40500154f#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505514&amp;amp;idx=1&amp;amp;sn=b6934ff0349c9d245ea24003733e1e11&amp;amp;chksm=e9ed381cde9ab10a6d06a5dbc220fcd974ee5de1fc79c52e99f9df1967e5c0e511e40500154f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;怎么给生产环境的docker容器 “减肥”？&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247505514_2&quot; data-recommend-article-time=&quot;1662508800&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/NW0r9OxcmxLWAbicVuqAsxsfaiaib40V67cU7TCZrvdJBicBtqpgNhEy4Ly1Cj2YxKBIx2Nn26zkUDMZ7EHTlJZgHQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;Docker清理的常用方法&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505514&amp;amp;idx=2&amp;amp;sn=94a36e473df8a64b62130f254f0fe8b6&amp;amp;chksm=e9ed381cde9ab10a50fc1fb741f5a3ed2ffbe44a4ebeb1f0f2fb469dec8f16dfb78a8dddc515#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505514&amp;amp;idx=2&amp;amp;sn=94a36e473df8a64b62130f254f0fe8b6&amp;amp;chksm=e9ed381cde9ab10a50fc1fb741f5a3ed2ffbe44a4ebeb1f0f2fb469dec8f16dfb78a8dddc515&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Docker清理的常用方法&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>