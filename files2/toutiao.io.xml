<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c09ac25de2c23316bba237a92b1e5e2e</guid>
<title>关于聚合根，领域事件的那点事---深入浅出理解 DDD</title>
<link>https://toutiao.io/k/v17j11b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：京东物流 赵勇萍&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;最近有空会跟同事讨论DDD架构的实践落地的情况，但真实情况是，实际中对于领域驱动设计中的实体，值对象，聚合根，领域事件这些战术类的实践落地，每个人理解依然因人而异，大概率是因为这些概念还是有一些抽象，同时有有别于传统的MVC架构开发。&lt;/p&gt;

&lt;p&gt;在此，通过小demo的方式跟大家分享一下我对DDD中战术层级的理解，算是抛砖引玉，该理解仅代表我个人在现阶段的一个理解，也可能未来随着业务经验深入，还会有不同的理解。&lt;/p&gt;

&lt;p&gt;既然说是小demo，还是要从业务场景出发，也就是我最熟知的电商业务场景说起。但是该篇文章里， 我会简化一些实际业务场景中的复杂度，通过最小颗粒度的demo，来反映实践过程中的基本问题。&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;一个简单的demo业务场景&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;话不多说，我先抛出我自己假设的一个业务场景，就是我们熟知的电商网站下单购物的场景。具体细节如下：&lt;/p&gt;

&lt;h2&gt;1. 实体：&lt;/h2&gt;

&lt;p&gt;• 商品：拥有唯一标识、名称、价格、库存等属性。&lt;/p&gt;

&lt;p&gt;• 订单：拥有唯一标识、下单时间、状态等属性。订单包含多个订单项。&lt;/p&gt;

&lt;h2&gt;2. 值对象：&lt;/h2&gt;

&lt;p&gt;• 地址：拥有省、市、区、详细地址等属性。&lt;/p&gt;

&lt;h2&gt;3. 领域事件：&lt;/h2&gt;

&lt;p&gt;• 订单创建事件：当用户下单时触发该事件，包含订单信息、商品信息等数据。&lt;/p&gt;

&lt;p&gt;• 订单支付事件：当用户完成支付时触发该事件，包含订单信息、支付金额等数据。&lt;/p&gt;

&lt;p&gt;• 订单发货事件：当商家发货时触发该事件，包含订单信息、快递公司、快递单号等数据。&lt;/p&gt;

&lt;h2&gt;4. 聚合根：&lt;/h2&gt;

&lt;p&gt;• 商品聚合根：包含商品实体和相关的值对象，负责商品的创建、修改、查询等操作。&lt;/p&gt;

&lt;p&gt;• 订单聚合根：包含订单实体和相关的值对象，负责订单的创建、修改、查询等操作。&lt;/p&gt;

&lt;h2&gt;5. 对外接口服务：&lt;/h2&gt;

&lt;p&gt;• 创建订单接口：用户提交购买请求后，系统创建相应的订单，并触发订单创建事件。&lt;/p&gt;

&lt;p&gt;• 支付订单接口：用户完成支付后，系统更新订单状态，并触发订单支付事件。&lt;/p&gt;

&lt;p&gt;• 发货接口：商家发货后，系统更新订单状态，并触发订单发货事件。&lt;/p&gt;

&lt;p&gt;• 查询订单接口：用户可以根据订单号等条件查询自己的订单信息。&lt;/p&gt;

&lt;p&gt;该demo中，商品和订单是两个核心领域概念，分别由对应的聚合根负责管理。同时，通过定义领域事件，实现了不同业务场景下的数据更新和通知。最后，对外提供了一组简单的接口服务，方便系统的使用和扩展。&lt;/p&gt;

&lt;h1&gt;demo的java代码实现&lt;/h1&gt;

&lt;p&gt;好了，有了以上我们对业务场景的充分剖析，确定了子域，接下来我们该写我们的代码。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;商品实体类：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;// 省略getter/setter方法
public class Product {
    private Long id;
    private String name;
    private BigDecimal price;
    private Integer stock;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2. 订单实体类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 省略getter/setter方法
public class Order {
    private Long id;
    private LocalDateTime createTime;
    private Integer status;
    private List orderItems;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3. 订单项实体类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 省略getter/setter方法
public class OrderItem {
    private Long id;
    private Product product;
    private Integer quantity;
    private BigDecimal price;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4. 地址值对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 省略getter/setter方法 
public class Address {
    private String province;
    private String city;
    private String district;
    private String detail;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5. 领域事件类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//订单创建领域事件
public class OrderCreatedEvent {
    private Order order;
    private List orderItems;

    public OrderCreatedEvent(Order order, List orderItems) {
        this.order = order;
        this.orderItems = orderItems;
    }
}


//订单支付领域事件
public class OrderPaidEvent {
    private Order order;
    private BigDecimal amount;

    public OrderPaidEvent(Order order, BigDecimal amount) {
        this.order = order;
        this.amount = amount;
    }
}

//订单
public class OrderShippedEvent {
    private Order order;
    private String expressCompany;
    private String expressNo;

    public OrderShippedEvent(Order order, String expressCompany, String expressNo) {
        this.order = order;
        this.expressCompany = expressCompany;
        this.expressNo = expressNo;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6. 商品聚合根&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ProductAggregate {
    private ProductService productService;

    public void createProduct(Product product) {
        productService.create(product);
    }

    public void updateProduct(Product product) {
        productService.update(product);
    }

    public void deleteProduct(Long productId) {
        productService.delete(productId);
    }

    public Product getProductById(Long productId) {
        return productService.getById(productId);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7. 订单聚合根&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class OrderAggregate {
    private OrderService orderService;

    public void createOrder(Order order, List orderItems) {
        orderService.create(order);
        // 触发订单创建事件 
        DomainEventPublisher.publish(new OrderCreatedEvent(order, orderItems));
    }

    public void payOrder(Long orderId, BigDecimal amount) {
        orderService.pay(orderId, amount);
        // 触发订单支付事件
        DomainEventPublisher.publish(new OrderPaidEvent(orderService.getById(orderId), amount));
    }

    public void shipOrder(Long orderId, String expressCompany, String expressNo) {
        orderService.ship(orderId, expressCompany, expressNo);
        // 触发订单发货事件 
        DomainEventPublisher.publish(new OrderShippedEvent(orderService.getById(orderId), expressCompany, expressNo));
    }

    public Order getOrderById(Long orderId) {
        return orderService.getById(orderId);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;通过以上demo，对于实体和值对象，大家会很好理解，并且很直观。但是， 我额外想重点解释一下聚合根和领域事件的概念&lt;/p&gt;

&lt;p&gt;1. 聚合根&lt;/p&gt;

&lt;p&gt;从上面的demo可以看出，在合根类中，我们定义了商品和订单的增、删、查等操作，并且为订单定义了创建订单、支付订单、发货等业务逻辑代码。&lt;/p&gt;

&lt;p&gt;聚合根是一个对象，它代表一组相关联的对象的整体。在聚合根内部，可以包含多个实体对象和值对象。聚合根通常可以通过唯一标识符来进行识别和访问。它是整个聚合的管理者，负责维护聚合之内的一致性，并协调各个实体对象之间的关系。聚合根通常具有丰富的行为和操作，可以对聚合内部的对象进行复杂的操作。&lt;/p&gt;

&lt;p&gt;所以说，真正的聚合根内的方法是基于充血模型封装的，而不是仅仅是对对象的数据封装。在聚合根中，对象不仅封装了数据，还包含了相应的行为和业务逻辑。这意味着在一个聚合根中，对象可以自己处理自己的业务逻辑，而不需要外部的控制。就如同demo中所写的那样，订单对象可能包含一些关于订单处理和交付的方法，如确认订单、取消订单、发货等。&lt;/p&gt;

&lt;p&gt;2. 领域事件&lt;/p&gt;

&lt;p&gt;领域事件是DDD中最重要的概念之一，他是解决子域之间耦合的重要手段，因为它们提供了一种将领域概念和业务语言转化为代码的方法。当一个领域事件发生时，它会触发一些操作，这些操作可能会更改系统的状态，也可能会导致其他领域事件的发生。通过对领域事件进行建模，我们可以更好地了解业务过程并设计出更加符合实际需求的系统。&lt;/p&gt;

&lt;p&gt;在DDD中，领域事件通常由三个部分组成：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;事件名称：这个名称应该能够简洁明了地描述事件所代表的业务意义。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;相关数据：这些数据包含了事件发生时与事件相关的所有信息。例如，在一个电子商务系统中，如果订单被提交，则订单信息以及买家和卖家的信息都应该包括在该事件中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发送者和接收者：发送者通常是触发事件的对象，接收者则是事件处理的对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;领域事件在DDD中有很多用途。例如，它们可以用来触发其他业务流程、更新数据库或通知其他子系统。它们还可以用于解决一些复杂的业务逻辑问题，例如并发、数据同步和错误处理等等。&lt;/p&gt;

&lt;p&gt;总之，领域事件是DDD架构中非常重要的概念，它可以帮助我们更好地理解业务过程，设计出更加符合实际需求的系统，并提高系统的可维护性和可扩展性。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ce10fc02048a65b5d9bc6725a680a328</guid>
<title>如何防止订单重复支付？</title>
<link>https://toutiao.io/k/2l1p8eu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content &amp;#10;                       autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;想必大家对在线支付都不陌生，今天和大家聊聊如何防止订单重复支付。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;看看订单支付流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们来看看，电商订单支付的简要流程：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6925925925925925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C4kzbXmk7uBfSGPdPfibqBW5WqvRZyWiapibPibAVPKfH7kPoXsCjDDY43uA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;订单钱包支付流程&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从下单/计算开始：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;下单/结算&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：这一步虽然不是直接的支付起点，但是支付相关的金额等等信息都来自结算，此时订单的状态是未支付；&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;申请支付&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：用户选择申请支付，客户端调用支付服务，此时在系统内产生一笔支付流水，这笔流水的状态是未支付；&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;发起支付&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：支付服务调用三方支付，通常这种钱包类的支付，在发起支付这一步，会响应一些支付的链接，客户端会对链接进行对应的处理；&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;钱包支付：用户进行支付，通常是通过对应的钱包进行的，大家可以回忆一下自己在购物中，支付的过程。不同的端，对钱包支付的处理是不太一样的：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7037037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C4p98ZhlTib2N8huRibwslsxx4Xp9PVic0G4GnVkoYS4N5MjBL43aQQiav6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;京东PC端支付页&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;APP 端&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在国内，购物大部分都是在 APP 端，产品经理会想法设法把用户带到 APP，为什么我的示例图都用京东，不用淘宝呢？因为我拿 UC 打开淘宝，会直接跳转 APP。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;APP 端的钱包支付，我们应该都非常熟悉，一般是拉起钱包，支付。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8361111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C4qqz9BaMCjTVqMpNFj8KFdR1jCww9onmG9R9eHwZUhxiaCwpLdH8u5zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;APP支付&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;WAP 端&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;手机的网页站，WAP 端的支付一般是直接拉起对应的钱包，如果拉起钱包失败，就跳转界面。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8527777777777777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C431spDsyYyGQKeKPWrJruaPmVqdftL7X2upQRWUX2nAGf1rdUcbUcqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;京东支付 WAP端&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;PC 端&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;PC 端，通常是打开收银台，展示一个二维码，通过钱包扫码支付，下面是京东的微信支付扫码页。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;支付回调&lt;/strong&gt;：用户完成支付后，三方支付平台，会回调商户，通知支付结果。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;同步订单状态&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：支付服务在确认支付完成后，会向订单服务同步支付的结果，订单服务变更订单的状态，由未支付 -&amp;gt; 待发货，客户端通过轮询、长连接，或者服务端主动推送的方式，在界面上变更订单状态。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们再从支付流水的角度看一下支付状态的变化：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C4n3EXJ5FORcmaQJtrzcSQFy4RR7N3VRCvfl3Dat0nbhVEILf8J0Pu5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;支付状态变化&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么要花这么多篇幅来讲支付的业务流程、交互过程呢？因为我认为，&lt;strong&gt;&lt;span&gt;防止订单的重复支付，不止是技术上的问题，也是业务和产品上的问题&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;为什么订单会重复支付&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;未防重导致的重复支付&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以看到 PC 端支付，是扫描二维码，这些二维码，就是对应相应的支付流水，假如用户重复点击支付，如果不做防重的的话，会生成两笔支付流水，也就是两个不同的二维码，要是用户分别扫了两个不同的支付码，那么毫无疑问，就会产生重复支付。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;掉单导致的重复支付&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“我明明付款了，为什么我的订单还没支付呢？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9929328621908127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C4nbHMZ6LyrMuT2LZQoVV2beLaQFKauPvL1WwFVjpIJ2QvEXhORlQfKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;566&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;黑我钱是吧&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这就是所谓的“掉单”：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;外部掉单&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：三方支付的支付状态没有同步或者没有及时同步到商城，这叫外部掉单；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;内部掉单&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：支付服务的状态没有同步到订单，或者客户端没有及时获取到订单状态，这叫内部掉单。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;用户一看，自己付了款，结果商城里订单还未付款，但是又特别想要，可能就会再下一单，这样就重复支付了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;多渠道导致的重复支付&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们国内支付的体验还是非常快捷的，大家可能没有感觉，如果了解过海外支付的可能了解，很多支付的渠道，消耗的时间非常长。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如用户保罗选择了一种支付方式 Boleto，结果支付的网点离保罗他们村太远了，保罗又选择了 Paypal 支付。保罗去赶集的时候，又顺手去网点把 Boleto 的这一笔支付了，结果就重复支付了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种情况大家可能很少遇到，我们可以用美团下一个单，先打开微信支付。不要支付啊，接着回到美团，打开支付宝，用支付宝支付完成后，用微信接着支付。大家猜猜，两笔支付是不是都能成功？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;答案是可以。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2465116279069768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C4nibNPKJD5R1dAVsAaXxhpTd72iasRGib8HV7aibUpA6H8cxgLicLVema8aQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;645&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;美团多渠道支付&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何防止订单重复支付&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;加锁&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不管是 3.申请支付、还是 5.支付回调,都应该以订单维度加锁，防止并发下的重复操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;加锁，毫无疑问，也是分布式锁，通常我们会选择 Redis 分布式锁。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24716981132075472&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C49NibUZaTJQu3Lvow1XGgIHdFTCLMNCys8xaN39Jq6H7ghObwhwTDosA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;加锁&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;缓存结果&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;申请支付成功，支付回调成功，都应该缓存结果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再申请支付，收到成功回调的时候，都应该先去检查支付的状态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5011820330969267&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C4l8pea9uNy7F14AUrcDjjovibAnzWVQibFCuribqAcsvDCI8bUobt7bKzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;846&quot;/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;支付中流水取消&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;假如说，用户重复支付了，再次申请支付的时候，如果已经申请支付成功了，那么这笔支付肯定是要拒绝的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，要是已经存在的这笔流水还在支付中呢？我们不确定它是成功还是失败，肯定是不能拒绝支付的，因为可能用户支付失败了，但是状态还没同步，这样肯定是不行的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，我们可以取消掉正在支付中的流水，再进行支付。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2796296296296296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C4vpGliafKZrWasEYB9IYXqJF2YyH9Itic3qmiamHOlHS92H5AEnzgPoqAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;支付中流水取消&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;已支付流水退款&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在又有新的问题了，假如发起支付的时候，有流水正在支付中，如果第三方支付平台不支持取消支付，或者用户新的支付是通过不同的渠道，我们希望尽可能提高用户的支付成功率，怎么办呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以在发起支付的时候，订单还在支付中的情况下，允许用户发起多笔支付，在支付回调的时候，检查用户是否已经有成功流水，对后来的流水进行退款处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25833333333333336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C4IdntmfsrhMkubl7icUtlKFfia9Iiaj700ZLKK5kuC8a3JZlxtTePBfZAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;支付回调&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，退款是个很危险的操作，毕竟钱退了，可就很难追回来，一定要做好风险的控制。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;主动轮询与重试防止掉单&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果因为故障没有收到回调，或者没有及时收到回调，就可能会发生所谓的外部掉单。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;防止外部掉单的关键，就在于，不能傻傻地只等三方的回调通知，而要主动去查询，用户发起支付的 3s 之后，就可以发起轮询了，直到拿到支付流水的最终状态，主动轮询，一般可以这么实现：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2342857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C4mKoSobbGPcjI2icic5DDMuUEd40oraqcxiahibwPZcTQCvsJybcGFY3sMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;轮询&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1) 定时任务轮询&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用定时任务，扫描表中支付中的流水，主动查询支付的状态，定时任务的实现方式有很多，线程池、调度框架、分布式调度框架等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定时任务轮询的缺点有两个：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2) 延时消息轮询&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外一种方式就是使用延时消息。用户发起支付之后，发送一个延时消息，消费到延时消息之后，查询流水支付状态，没有拿到最终状态，就再发一个延时消息。延时消息的好处是对数据库的压力没有那么大，轮询的梯度也可以进行控制，缺点是实现起来复杂一些，而且要维护消息队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;同步+异步防止内部掉单&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;支付服务在收到异步通知回调、或者主动轮询到流水的最终状态后，要通知订单服务支付流水的变化，订单服务同步更新订单的状态，这个过程要尽可能保证通知成功，可以采用&lt;strong&gt;同步+异步&lt;/strong&gt;的方式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;同步调用&lt;/strong&gt;：支付服务调用订单服务的通知接口，有可能会因为网络等等的原因失败，也可以重试，但是根据经验，如果网络出现一些波动，重试很可能也会失败。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;异步通知&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：支付服务还应该发送一个支付成功的消息，订单服务可以利用消息队列的重试机制，来尽可能保证支付状态的同步。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里还有一个问题，客户端如何同步这个状态？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为可能服务端更新了订单状态，但是客户端的界面上还是未支付，得用户主动刷新一下，才能拿到最新的状态，这样明显是不太合适的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;服务端、客户端的状态同步，无非就拉和推:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;拉&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：很简单，就是客户端在用户跳回订单状态页的时候，轮询一会。如果用户完成支付，通常很短时间就能获取到状态的变更。当然，这种方式对客户端的性能会有一些影响，而且很出现状态同步“漏网之鱼”的情况。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;推&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：推的实现有些麻烦，Web 通常是用 Websocket，对 APP 端的推送，一般采用第三方的推送平台。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;客户端支付尽可能不外跳&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不管从产品的角度，还是技术的角度，客户端发起支付这一步，其实应该尽可能地不要外跳，PC 端使用支付服务生成的支付码，而不是跳转；移动端网页、APP 在应用内展示支付页，当然这个是由第三方支付平台决定的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.212121212121212&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfQR77RSX8KYHZVdw3JG3C4Qquj9JOlQ8mUmicktGt4KqhWJnMicvBiaVicDicibAsd9X3DDFiapHzvUIFcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;462&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;在UC内内嵌支付宝&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不知道大家留意到了没有，现在的支付宝，已经做到了不用拉起钱包，在应用内就可以完成支付，这个对于商家的意义还是比较大的，对用户体验、支付成功率，都有正面的作用，相信以国内的内卷程度，其它支付供应商，一定会“跟进”的。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651524963&amp;amp;idx=1&amp;amp;sn=f904a53ea386c2f3153ed10fb1019b72&amp;amp;chksm=bd24631c8a53ea0acbfcedb58a73b8fd7d44b71bf491f536540525dd8eafded3b408fee8da5a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;聊聊大厂都怎么防止重复下单？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊大厂都怎么防止重复下单？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651524963&amp;amp;idx=1&amp;amp;sn=f904a53ea386c2f3153ed10fb1019b72&amp;amp;chksm=bd24631c8a53ea0acbfcedb58a73b8fd7d44b71bf491f536540525dd8eafded3b408fee8da5a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;聊聊大厂都怎么防止重复下单？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651512089&amp;amp;idx=2&amp;amp;sn=d7d400b95fd5eb2f8beb723304f04775&amp;amp;chksm=bd25b1668a5238708368aabcdbf29bc0e5fdeb154e017f13e5c76ec48df476503b2c721108fa&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;领导看了我写的关闭超时订单，让我出门左转&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;领导看了我写的关闭超时订单，让我出门左转&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651523619&amp;amp;idx=1&amp;amp;sn=3cf712eb7b6d92434a9507fa101df8f3&amp;amp;chksm=bd24665c8a53ef4a0ae966819a15895f78f2fe264d239a2334fae71d09dc75f0f947b9798afc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Spring Boot + Redis 解决重复提交问题，一定用的到&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring Boot + Redis 解决重复提交问题，一定用的到&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>37cd8e212421f471bf3ba0f973dbe2ad</guid>
<title>Redis 实战篇：巧用 Bitmap 实现亿级海量数据统计</title>
<link>https://toutiao.io/k/2lv0v3u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在移动应用的业务场景中，我们需要保存这样的信息：一个 key 关联了一个数据集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的场景如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;给一个 userId ，判断用户登陆状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;显示用户某个月的签到次数和首次签到时间；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两亿用户最近 7 天的签到情况，统计 7 天内连续签到的用户总数；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，我们面临的用户数量以及访问量都是巨大的，比如百万、千万级别的用户数量，或者千万级别、甚至亿级别的访问信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们必须要选择能够非常高效地统计大量数据（例如亿级）的集合类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何选择合适的数据集合，我们首先要了解常用的统计模式，并运用合理的数据类型来解决实际问题。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;四种统计类型：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;二值状态统计；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;聚合统计；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排序统计；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基数统计。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将由&lt;strong&gt;二值状态统计类型&lt;/strong&gt;作为实战篇系列的开篇，文中将用到 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3NDkwMjAyOQ==&amp;amp;mid=2247485665&amp;amp;idx=1&amp;amp;sn=3cf8e45aaa071fa26975bca34b8878e4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;String、Set、Zset、List、hash&lt;/a&gt; 以外的拓展数据类型 &lt;code&gt;Bitmap&lt;/code&gt; 来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章涉及到的指令可以通过在线 Redis 客户端运行调试，地址：https://try.redis.io/，超方便的说。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;寄语&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;多分享多付出，前期多给别人创造价值并且不计回报，从长远来看，这些付出都会成倍的回报你。&lt;/p&gt;&lt;p&gt;特别是刚开始跟别人合作的时候，不要去计较短期的回报，没有太大意义，更多的是锻炼自己的视野、视角以及解决问题的能力。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二值状态统计&lt;/span&gt;&lt;/h1&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，什么是二值状态统计呀？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是集合中的元素的值只有 0 和 1 两种，在签到打卡和用户是否登陆的场景中，只需记录&lt;code&gt;签到(1)&lt;/code&gt;或 &lt;code&gt;未签到(0)&lt;/code&gt;，&lt;code&gt;已登录(1)&lt;/code&gt;或&lt;code&gt;未登陆(0)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如我们在判断用户是否登陆的场景中使用 Redis 的 String 类型实现（&lt;strong&gt;key -&amp;gt; userId，value -&amp;gt; 0 表示下线，1 - 登陆&lt;/strong&gt;），假如存储 100 万个用户的登陆状态，如果以字符串的形式存储，就需要存储 100 万个字符串了，内存开销太大。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，为什么 String 类型内存开销大？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;String 类型除了记录实际数据以外，还需要额外的内存记录数据长度、空间使用等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当保存的数据包含字符串，String 类型就使用简单动态字符串（SDS）结构体来保存，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.057591623036649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FbXJ7UCc6O3Gvkib1TDTc5TaYWHqO1gcpARbk5g72S74Lb3d9FVTqZUwEPA14lLx9W2FZ8IEJOnLu3HerVsaHDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;figcaption&gt;SDS&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;len&lt;/strong&gt;：占 4 个字节，表示 buf 的已用长度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;alloc&lt;/strong&gt;：占 4 个字节，表示 buf 实际分配的长度，通常 &amp;gt; len。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;buf&lt;/strong&gt;：字节数组，保存实际的数据，Redis 自动在数组最后加上一个 “\0”，额外占用一个字节的开销。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在 SDS 中除了 buf 保存实际的数据， len 与 alloc 就是额外的开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，还有一个 &lt;strong&gt;RedisObject 结构的开销&lt;/strong&gt;，因为 Redis 的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7096774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FbXJ7UCc6O3Gvkib1TDTc5TaYWHqO1gcpWKkLVZLkC7O1we74qB3ZwXDHiblPSoyU2Lg4DSCTRoiahAtppnoPy1ew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;403&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于二值状态场景，我们就可以利用 Bitmap 来实现。比如登陆状态我们用一个 bit 位表示，一亿个用户也只占用 一亿 个 bit 位内存 ≈ （100000000 / 8/ 1024/1024）12 MB。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;大概的空间占用计算公式是：(&lt;span&gt;$offset&lt;/span&gt;/8/1024/1024) MB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;什么是 Bitmap 呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bitmap 的底层数据结构用的是 String 类型的 SDS 数据结构来保存位数组，Redis 把每个字节数组的 8 个 bit 位利用起来，每个 bit 位 表示一个元素的二值状态（不是 0 就是 1）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以将 Bitmap 看成是一个 bit 为单位的数组，数组的每个单元只能存储 0 或者 1，数组的下标在 Bitmap 中叫做 offset 偏移量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了直观展示，我们可以理解成 buf 数组的每个字节用一行表示，每一行有 8 个 bit 位，8 个格子分别表示这个字节中的 8 个 bit 位，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4583333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FbXJ7UCc6O3Gvkib1TDTc5TaYWHqO1gcpQ7Xxqefic1InjoZWeyibbseXAuI3KQUP30pBUHAcha2DEgib57pS7DZrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;Bitmap&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;8 个 bit 组成一个 Byte，所以 Bitmap 会极大地节省存储空间。&lt;/strong&gt; 这就是 Bitmap 的优势。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;判断用户登陆态&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;怎么用 Bitmap 来判断海量用户中某个用户是否在线呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bitmap 提供了 &lt;code&gt;GETBIT、SETBIT&lt;/code&gt; 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要一个 key = login_status 表示存储用户登陆状态集合数据， 将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 &lt;code&gt;GETBIT&lt;/code&gt;判断对应的用户是否在线。50000 万 用户只需要 6 MB 的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SETBIT 命令&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SETBIT &amp;lt;key&amp;gt; &amp;lt;offset&amp;gt; &amp;lt;value&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置或者清空 key 的 value 在 offset 处的 bit 值（只能是 0 或者 1）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GETBIT 命令&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GETBIT &amp;lt;key&amp;gt; &amp;lt;offset&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取 key 的 value 在 offset 处的 bit 位的值，当 key 不存在时，返回 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如我们要判断 ID = 10086 的用户的登陆情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，执行以下指令，表示用户已登录。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SETBIT login_status 10086 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，检查该用户是否登陆，返回值 1 表示已登录。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GETBIT login_status 10086&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，登出，将 offset 对应的 value 设置成 0。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SETBIT login_status 10086 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用户每个月的签到情况&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在签到统计中，每个用户每天的签到用 1 个 bit 位表示，一年的签到只需要 365 个 bit 位。一个月最多只有 31 天，只需要 31 个 bit 位即可。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;比如统计编号 89757 的用户在 2021 年 5 月份的打卡情况要如何进行？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key 可以设计成 &lt;code&gt;uid:sign:{userId}:{yyyyMM}&lt;/code&gt;，月份的每一天的值 - 1 可以作为 offset（因为 offset 从 0 开始，所以 &lt;code&gt;offset = 日期 - 1&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，执行下面指令表示记录用户在 2021 年 5 月 16 号打卡。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SETBIT uid:sign:89757:202105 15 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，判断编号 89757 用户在 2021 年 5 月 16 号是否打卡。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GETBIT uid:sign:89757:202105 15&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，统计该用户在 5 月份的打卡次数，使用 &lt;code&gt;BITCOUNT&lt;/code&gt; 指令。该指令用于统计给定的 bit 数组中，值 = 1 的 bit 位的数量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BITCOUNT uid:sign:89757:202105&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我们就可以实现用户每个月的打卡情况了，是不是很赞。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;如何统计这个月首次打卡时间呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 提供了 &lt;code&gt;BITPOS key bitValue [start] [end]&lt;/code&gt;指令，返回数据表示 Bitmap 中第一个值为 &lt;code&gt;bitValue&lt;/code&gt; 的 offset 位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认情况下， 命令将检测整个位图， 用户可以通过可选的 &lt;code&gt;start&lt;/code&gt; 参数和 &lt;code&gt;end&lt;/code&gt; 参数指定要检测的范围。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们可以通过执行以下指令来获取 userID = 89757 在 2021 年 5 月份&lt;strong&gt;首次打卡&lt;/strong&gt;日期：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BITPOS uid:sign:89757:202105 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，我们需要将返回的 value + 1 ，因为 offset 从 0 开始。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;连续签到用户总数&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;在记录了一个亿的用户连续 7 天的打卡数据，如何统计出这连续 7 天连续打卡用户总数呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的 UserID  offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit = 1 就说明该用户 7 天连续打卡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果保存到一个新 Bitmap 中，我们再通过 &lt;code&gt;BITCOUNT&lt;/code&gt; 统计 bit = 1 的个数便得到了连续打卡 7 天的用户总数了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 提供了 &lt;code&gt;BITOP operation destkey key [key ...]&lt;/code&gt;这个指令用于对一个或者多个 键 = key 的 Bitmap 进行位元操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;opration&lt;/code&gt; 可以是 &lt;code&gt;and&lt;/code&gt;、&lt;code&gt;OR&lt;/code&gt;、&lt;code&gt;NOT&lt;/code&gt;、&lt;code&gt;XOR&lt;/code&gt;。当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 &lt;code&gt;0&lt;/code&gt; 。空的 &lt;code&gt;key&lt;/code&gt; 也被看作是包含 &lt;code&gt;0&lt;/code&gt; 的字符串序列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;便于理解，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40154015401540155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FbXJ7UCc6O3Gvkib1TDTc5TaYWHqO1gcpUQ9zjGicXx1Zw97aAckMrUCePUDSx9afAv7Q6g6lPjUgFEeq7IBT22g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;909&quot;/&gt;&lt;figcaption&gt;BITOP&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3 个 Bitmap，对应的 bit 位做「与」操作，结果保存到新的 Bitmap 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作指令表示将 三个 bitmap 进行 AND 操作，并将结果保存到 destmap 中。接着对 destmap 执行 BITCOUNT 统计。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 与操作&lt;br/&gt;BITOP AND destmap bitmap:01 bitmap:02 bitmap:03&lt;br/&gt;// 统计 bit 位 =  1 的个数&lt;br/&gt;BITCOUNT destmap&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单计算下 一个一亿个位的 Bitmap占用的内存开销，大约占 12 MB 的内存（10^8/8/1024/1024），7 天的 Bitmap 的内存开销约为 84 MB。同时我们最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，节省内存。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路才是最重要，当我们遇到的统计场景只需要统计数据的二值状态，比如用户是否存在、 ip 是否是黑名单、以及签到打卡统计等场景就可以考虑使用 Bitmap。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要一个 bit 位就能表示 0 和 1。在统计海量数据的时候将大大减少内存占用。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>413d17e441eb71595090004a75a0cba6</guid>
<title>读书笔记：如何成为某个领域的前 1%</title>
<link>https://toutiao.io/k/26xrtbi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;老张的求知思考世界&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;For-Think&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;专注互联网领域相关技术实践和思考，也分享职场成长、读书杂谈等内容。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0191b28333122e8bdeb0be9f8b8793a5</guid>
<title>ChatGPT真有很多人在用吗？</title>
<link>https://toutiao.io/k/usuq2qg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;span class=&quot;RichText ztext CopyrightRichText-richText css-1g0fqss&quot; options=&quot;[object Object]&quot; itemprop=&quot;text&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;209Se5aQ&quot;&gt;正文部分：&lt;/p&gt;&lt;p data-pid=&quot;CMviBkk4&quot;&gt;作为前不久刚拿到Plugin Developer的Alpha资格的人，几张图片或许是最直接能说明目前GPT的表现&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-6b40cff14daeb7112e984903d3d51d7e_720w.jpg?source=1940ef5c&quot; data-rawwidth=&quot;1179&quot; data-rawheight=&quot;2556&quot; data-size=&quot;normal&quot; data-original-token=&quot;v2-957d8f7b6459a9ba55a5ab08006e0caf&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-4df384eb55daee9a20d41b594d02c707_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-6b40cff14daeb7112e984903d3d51d7e_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1179&quot; data-rawheight=&quot;2556&quot; data-size=&quot;normal&quot; data-original-token=&quot;v2-957d8f7b6459a9ba55a5ab08006e0caf&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-4df384eb55daee9a20d41b594d02c707_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-6b40cff14daeb7112e984903d3d51d7e_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-6b40cff14daeb7112e984903d3d51d7e_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-3f3988b2998b27667bee5c9f813d963f_720w.jpg?source=1940ef5c&quot; data-rawwidth=&quot;1179&quot; data-rawheight=&quot;1525&quot; data-size=&quot;normal&quot; data-original-token=&quot;v2-bc03ddda7a3ec135aaf74c6606803547&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-4b068ed22c2b156a98c9002f0a39e7bf_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-3f3988b2998b27667bee5c9f813d963f_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1179&quot; data-rawheight=&quot;1525&quot; data-size=&quot;normal&quot; data-original-token=&quot;v2-bc03ddda7a3ec135aaf74c6606803547&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-4b068ed22c2b156a98c9002f0a39e7bf_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-3f3988b2998b27667bee5c9f813d963f_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-3f3988b2998b27667bee5c9f813d963f_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-pid=&quot;1CSBOB23&quot;&gt;至于说体验，我可以说只能说是恐怖如斯了。&lt;b&gt;（以下是一些ChatGPT调用Wolfram 进行对StableDiffusion技术解释的过程，其中调用了非常多的绘图库 效果个人觉得较之于Auto-GPT来说就是乱杀了）&lt;/b&gt;&lt;/blockquote&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-3d0d26849d3d8587b72990555a17af50_720w.jpg?source=1940ef5c&quot; data-rawwidth=&quot;1294&quot; data-rawheight=&quot;1395&quot; data-size=&quot;normal&quot; data-original-token=&quot;v2-4d1127031ac7889e978e8c0b3869c5e0&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-4edb0af604f133d58e8942c972ca69ca_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-3d0d26849d3d8587b72990555a17af50_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1294&quot; data-rawheight=&quot;1395&quot; data-size=&quot;normal&quot; data-original-token=&quot;v2-4d1127031ac7889e978e8c0b3869c5e0&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-4edb0af604f133d58e8942c972ca69ca_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-3d0d26849d3d8587b72990555a17af50_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-3d0d26849d3d8587b72990555a17af50_720w.jpg?source=1940ef5c&quot;/&gt;&lt;figcaption&gt;我询问一个关于机器学习中的Stabble-Diffusion问题 它使用了3d绘图库进行高斯函数的可视化建模&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pica.zhimg.com/50/v2-7fee90690de98f4cd386613653c5d2f5_720w.jpg?source=1940ef5c&quot; data-rawwidth=&quot;1068&quot; data-rawheight=&quot;1390&quot; data-size=&quot;normal&quot; data-original-token=&quot;v2-b9d1860555668add32c3f739f80b5a53&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-faa42ef8fbb63dbfe95b2aadbef5dacf_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-7fee90690de98f4cd386613653c5d2f5_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1068&quot; data-rawheight=&quot;1390&quot; data-size=&quot;normal&quot; data-original-token=&quot;v2-b9d1860555668add32c3f739f80b5a53&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-faa42ef8fbb63dbfe95b2aadbef5dacf_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-7fee90690de98f4cd386613653c5d2f5_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pica.zhimg.com/50/v2-7fee90690de98f4cd386613653c5d2f5_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-2e6d4c4902f82c48acdb1a642b28bfdc_720w.jpg?source=1940ef5c&quot; data-rawwidth=&quot;1071&quot; data-rawheight=&quot;1492&quot; data-size=&quot;normal&quot; data-original-token=&quot;v2-42d22efbdddd2e5f87797b70b09a607b&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-491bdd61ba80b0459a948d852fc731eb_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-2e6d4c4902f82c48acdb1a642b28bfdc_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1071&quot; data-rawheight=&quot;1492&quot; data-size=&quot;normal&quot; data-original-token=&quot;v2-42d22efbdddd2e5f87797b70b09a607b&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-491bdd61ba80b0459a948d852fc731eb_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-2e6d4c4902f82c48acdb1a642b28bfdc_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-2e6d4c4902f82c48acdb1a642b28bfdc_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pica.zhimg.com/50/v2-4a45f9942582d3a798245f13987ff06c_720w.jpg?source=1940ef5c&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;442&quot; data-size=&quot;normal&quot; data-original-token=&quot;v2-eedb2dd26b94a8fe07278ff37ad89d0f&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-cd95b02be3c03521699d03ce06e1d0e1_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-4a45f9942582d3a798245f13987ff06c_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;442&quot; data-size=&quot;normal&quot; data-original-token=&quot;v2-eedb2dd26b94a8fe07278ff37ad89d0f&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-cd95b02be3c03521699d03ce06e1d0e1_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-4a45f9942582d3a798245f13987ff06c_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pica.zhimg.com/50/v2-4a45f9942582d3a798245f13987ff06c_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;ADjvwI15&quot;&gt;在这个过程里面 他调用了很多绘图接口&lt;/p&gt;&lt;p data-pid=&quot;EfIOs5As&quot;&gt;最后针对我的疑惑做了一个完美的解答&lt;/p&gt;&lt;p data-pid=&quot;MbvBzb28&quot;&gt;我只能说是恐怖如斯&lt;/p&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>