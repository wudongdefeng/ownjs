<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f542bf12d98f3896ef1d82a2ed6025b9</guid>
<title>面向对象分析与设计的底层逻辑</title>
<link>https://toutiao.io/k/5x9px3n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;82&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.14106583072100312&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/qdzZBE73hWvNG9VjIS9sOow1MoYQgibicAhyLCiagyqhMVMBR5LiaLDIwVjiayNbjG4682icRrJOrll5bkJu9kebAQHA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;面向对象是符合人认识事物的基本方法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;人是怎么认识事物的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在面向对象出现之前，已有面向过程的分析方法，为什么面向对象被提出了呢？究其本质原因，人们发现面向过程并不是按照人正常认识事物的方式去分析软件，那么人究竟是怎么认识事物的呢，Yourdon 在《面向对象的分析》一书中提到，人类认识事物是遵循分类学的原理，分类学主要包含三点：&lt;strong&gt;区分对象及其属性；区分整体对象及其组成部分；不同对象类的形成及区分。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们现在可以回想下我们认识事物的过程，是不是和分类学所提到的 3 个要点很相似，看到一个事物，大概会感知到它的组成结构是怎样的，形状是怎样的，属于什么分类。所以，人认识事物是以对象的视角切入的，然后赋于对象具体的概念，比如苹果、梨子、汽车等等概念名称。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;348&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6028225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWib691diaoVDCHG2xSZvT0gOTW1GpVJ2NN9hFbGVchdLxPiblk7U4D4icJTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;021&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;分类与分层的两种思维&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们面对的现实世界是非常复杂的，应对复杂事物的有一个重要的方法即是抽象，抽象在实际应用过程中，又体现在两种方法上：&lt;strong&gt;分层和分类&lt;/strong&gt;。分类即是将有差异的事物归类到不同的分组中，正如我们常听到的&quot;物以类聚、人以群分&quot;的道理一样，产生分类的原因有两点：一点是事物间的关联紧密程度，不需要将所有的事物都耦合在一起；另一点是人掌握事物是有局限的，只能掌握少量的要点，比如 5~7 个要点，超过了容易忘记。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;224&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.38705738705738707&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibdsFLxsxFqXX2X86vbo4c5vNTkNah6yq6zvd60mn9eHNCGNz5SDw9rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分层是通过不同的视角看事物，每一层的关注点是不一样的，这种关注点不同是由自己的视角造成的，比如我们理解计算机，并不需要深入到二进制电信号去理解计算机。层次特性在软件设计中我们经常遇到，比如计算机体系结构、TCP 七层协议等，层次特性有一个特点：越往上越具体、越往下越抽象，越往上的内容越不稳定，也即是容易变化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;229&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3954802259887006&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibCpvHaQf9I1DzuNqSxvGaiav2VCohm3VJODfia0ibfkBNs4jBWuUhMQwRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1416&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;问题域到解空间的映射&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们把需要解决的问题称之为问题域，或者问题空间，把解决方案称之为解空间。正向上一小节中提到的事物有层次特性，不同的人理解的事物是站在各自理解的视角，这样大家的理解、沟通并不一致的。如果我们看到的问题空间是表层的，那么基于浅层次理解设计出来的方案就会不稳定，可能下次有一个小变化导致方案需要重新设计。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;324&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5606435643564357&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWib9PpnBl5FqImxPb7dZjLzYHtJvMQjiaBkINNrXHEsNULfRstyKnkwZxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以把一个软件划分成三层：场景、功能和实体，场景层是经常会变的，比如发放优惠券场景就非常多，比如有天降红包领取优惠、分享有礼领取优惠券、新人注册领取优惠券等，这种场景的更迭随着业务的调整变化得非常快，因此场景层是不稳定的。功能支撑某一些的场景集合，对比场景，功能相对而言稳定些，就像前面提到的发放优惠券场景，本质就是给用户发放优惠券，只需要提供发放优惠券的功能即可，至于哪些场景来调用它并不关注，但功能还是基于场景的集合抽象出来的，如果场景场景类型变化了，功能也就随之变化，比如担保交易和预售交易就不一样。实体是稳定的，以担保交易和预售交易为例，它的订单模型大致是一样的，只是新增加了一些信息而已。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;253&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.43782837127845886&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibvbOVCTxVq5rsdfjfva9zBzxrq7l8U4ZQCchPluC5r4Pslu4LAV5XDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，我们希望从问题空间到解空间，大家看到的、理解的是一致的，而且看到的是问题的本质而非表象，往往场景、功能是不稳定的，而面向过程又是以功能驱动的，所以在易变化的场景下，它面临的问题就比较多。比较稳定的是问题空间中的实体对象，所以面向对象分析是现实的需要。面向过程和面向对象是两个不同的视角的分析方法：&lt;strong&gt;面向过程是一种归纳的分析方法，由外到内的过程；面向对象是一种演绎的分析方法，由内到外的过程。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;三个一致性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;软件开发会经历需要分析、概要设计、详细设计、编码、测试、上线主要阶段，我们不希望每块是割裂的，比如分析做完之后，做设计阶段又要重新去做分析的工作，那么这里面就涉及到一致性的问题，&lt;strong&gt;即需求到分析的一致性、分析到设计的一致性、设计到编码的一致性。&lt;/strong&gt;这样做的好处可以保证无信息失真，因此我们急需求一种分析设计方法能做到这一点，面向对象分析与设计就能做到，因此全流程是以对象作为分析与设计的目标，在最终编码中也都是对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;177&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3062438057482656&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibcWr3I3axuBlwPEAO516cT9IJPTZ2MJoXKdOe3L196Ha60ThL7P6c3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2018&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;05&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;面向对象的底层逻辑&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;提到面向对象，有部分人会提到封装、继承、多态等特性，然后这些并不是面向对象的本质特性，比如封装，面向过程中也有封装，多态面向过程也有体现，这些特性算不上面向对象特有的特性。&lt;strong&gt;面向对象的底层逻辑是基于现实事物做的抽象映射&lt;/strong&gt;：现实事物对应软件中的对象，我们讨论解空间能对应到问题空间中的对象，两者是一一直接映射的，其它的分析方法是问题空间到解空间的间接映射。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;203&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.35038084874863984&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibd1CSDaziazA4ic62xf4XtRicLRcZtv65kWxxn6ibTJk0mRVcqhVjCKpQOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1838&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;面向对象分析与设计的全景图&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;我们面临的问题是什么&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;从顶层看，我们要完成需求到编码的工作，然而从需求到编码又会经过多个阶段，如需求分析、方案设计等，从大的层面讲，我们主要遇到三个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;做什么的问题&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看似这是一个简单的问题，但在复杂的业务场景下，对做什么的理解太重要了，因为不同的人对需求的理解是不同的，比如最近做了一个项目，有一个业务判断规则是只针对跨境订单计税，最开始开发同学的理解是判断卖家类型是否是跨境卖家，然而到了测试阶段，发现大家对这个业务规则判断理解是不一致的，跨境订单跟卖家类型是没有关系的，真正的跨境订单计税场景是 shipTo（收货地址）和 shipFrom（发货地址）国家地址是不一样的。在大项项目中，涉及到多个团队之间的协同，这样的问题异常突出。而且从业务诉求到产品需求，再到技术方案，这其中是经过了 2 次变换，每次变换是不同的角色在里面，大家的认识也会不一样。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2. 怎么做的问题&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;落实到事情具体要怎么做时，往往大家并不会出大的问题，怎么做偏具体执行阶段，程序员往往在逻辑严密性上没多大的问题，往往出问题是在第一个问题上，相当于方向弄错了，所做的工作也是无用的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3. 方法指导的问题&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们往往希望不劳而获得到一种万能的方法，能够应对所有的问题，同时又看不起低级的方法，比如大部分人对用例分析方法嗤之以鼻，想要能体现技术水平高大上的方法。其实自上世纪 70、80 年代，软件的分析设计方法并没有太大的变化，而且在我们大学期间都学过，只是大家并不认为它是一种高大上的方法而已。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5625730994152047&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibUKvwSGaZgoibsl20Xnyq8Q164w54LT7TfUMbA7wdezwdWia8anxtTShA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;分析到设计的过程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在本节中，我们推导软件分析到设计的过程，由粗到细，最终落实到我们接触到的 UML 知识上。从需求提出到编码实现，这中间有两个关键问题：一是界定目标，即是定义清楚要做什么的问题，相当于是我们做事的方向、目标；二是具体如何做的问题，即通过怎样具体的方案支撑需求目标实现。因此，我们需要一种方法能够帮助我们界定目标和表示具体方案，而且是大家互认的一种通用的方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;59&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.10219675262655205&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibYkh2aOG7HGSgyEBLu0zszDj1bTwpMyuGq8TNNrbVGXg3AULW8ycfbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2094&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过用例图可以帮我们界定目标，用例中有三个关键要素：用户、场景和目标。比如交易下单是一个用例，它的用户是买家，场景包含下单成功和下单失败两个场景，用例的目标是买家可以购买心仪的商品。当用例目标确定了，相当于界定了目标，知道需求要做什么，这个过程要反复和业务方确认好，至到最终大家对目标的理解是一致的，方向对了，具体怎么做就好办了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体怎么做用时序图表示，画时序图需要注意的一点是顶层的对象层次要一致，不能有的对象表示具体的实体对象，有的表示系统对象，即对象的层级是一致的，要么大家都是系统，比如导购系统调用交易系统，交易系统调用支付系统，要么大家都是对象，比如商品、订单等。通过时序图可以看到一个完整功能的执行步骤，它就包含具体执行的细节，如正常流程、异常流程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;138&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2387774594078319&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibN5hG0kJIRiaZOxxJvd2952ajsnia5RllarTtQVjiaAbe75XU8VKEOFdUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2094&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实在上面有一个问题，在画时序图时要确定好对象，那么这个对象是怎么来的呢？它是由健壮性图分析出来的，它里面有三个关键的对象：一个是边界对象，这个比较好理解，比如UI界面就是边界对象；另一个是控制对象，即是控制业务流程的对象，如下单服务就可以看作是控制对象；实体对象即是问题空间中的业务对象，比如订单。画健壮性图是有规则的，一般是边界对象调用控制对象，控制对象产生实体对象，比如用户下单界面是边界对象，下单服务是控制对象，订单就是实体对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;120&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2079866888519135&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWib80NzXibsLiaibKgw0qTH5DXr0icsoh1hPNUj6ecE2u2XBcb7ZxvW8T4x3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2404&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong&gt;寻找对象之路&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;对象从哪里来&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在本文第一部分第三小节中已经提到，问题空间到解空间是一一映射，我们讨论解空间中的对象时，其实它映射到问题空间中的对象，而问题空间中的对象主要来源于业务概念、业务规则、关键事件。大部分的对象是显现的，我们通过理解业务能发现，有的对象是隐性的，需要我们持续对业务有更深的理解才能发掘出来。好的对象模型是需要经过多次迭代打磨出来的，并非一次就能设计得十全十美。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;发现对象的方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;在本文第二部分第二小&lt;/span&gt;节中已经提到寻找对象的方法，不过那还只是关键显现的对象，在本节中主要讲述完整对象发现的方法，主要方法分成四个步骤：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 通过健壮性图找到关键的实体对象；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 通过结构分析方法找出更多的实体对象；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 将对象组成有机的对象模型；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 最后通过用例走查对象模型是否完备。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;243&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.42065009560229444&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibaR9uLK0QUL36eN1k8CyxeJLEkoZnbzIG0hRDc2Wfeia5KKnosK7rSRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2092&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里以一个案例来说明发现对象的过程，案例是用户在下单时，在订单上展示税的金额。首先画出健壮性图，这里的边界对象是下单界面，控制对象有两个，一个是下单服务，另一个是计税服务，实体对象也有两个，一个是计税单，一个是订单。有了计税单和订单这两个实体对象后，接下来通过结构分析方法，分析出更多的对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;190&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3286573146292585&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibibShQhw4sU6PIzXvdqWh1TibE7XG6jI5go9yBV04M5ibz0iaX6rtiacVjRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1996&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对象都是有结构的，只要我们掌握了对象的结构，基本上就能掌握对象的概貌，因此我们从对象的结构入手，去分析对象内部的结构、对象关联的结构，实质上是从两个维度出发：一是从自身的角度出发，看自己内部还包含了哪些对象，如主订单包含了子订单；另一个是从外部的角度出发，看自己还与哪些对象相关联，如计税单与订单是有关联的。这种找对象的方法我称之为结构分析方法，因为本身结构又是事物本质的一种表达方式，比如化学分子结构决定化学现象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了更好地表达出对象的结构，我的一个经验是给对象下好定义，下定义可以从不同的维度，比如功能性维度、价值性维度、目的性维度、结构性维度等，这里可以从结构性的维度去给对象下定义。以计税单为例，可以给它下一个定义：计税单是将订单金额信息转成若干个标的物计税的单据模型，从这个定义中，我们可以看到计税单是与订单有关联关系的，另一个是计税单是包含了若干个标的物，我们可以画出计税单的对象模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;212&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.36681222707423583&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibhk6qdEIYsFMUhwkyUb6u7hFS4GOiapLTOnhOPqIPibla8x6gvKtiaUJ9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2290&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当对象模型画出来后，后续我们讨论业务基本上围绕这个对象模型去讨论业务问题的，比如商品标的物哪些金额要参与计税、计税金额的计算口径是怎样的，到这里，大家再体会下&quot;问题空间到解空间一一直接映射&quot;这句话，业务上的诉求也无非是哪些订单费用项要计税，计税的逻辑是怎样的，有可能在这个场景下要扣减金本位优惠，在另外一种场景下金本位优惠不需要扣减，基于对象模型与产品、测试同学讨论问题，大家都是处于同一个维度的视角看问题，沟通理解成本会少很多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对象模型是一种可视化的表达，我们大部分的沟通问题是缺乏显性表达造成的，这句话可以这样理解，也可以那样理解，导致大家理解有偏差，现在用模型的形式沟通问题，很多偏差、歧义就消除了。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;组织对象结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们分析出一堆的对象后，还需要经过一定的组织，正如前面提到，人对事物理解是有局限的，不能一下子接受太多的事物，因此可以将它们分成一个个小的域，比如商品域、订单域、税务域等，这样当聚集一个问题时，可以只看某个子域里的对象模型即可。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;274&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.47396386822529224&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibkiam3PrD8X2h9DMicWydluj3zA7fjrkFmE9icUUTTibhX0olo9YeYjvoEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1882&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;04&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;如何分配职责&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;职责是怎么来的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;面向对象最难的点有两个：一个是找出对象；另一个是分配职责。UML 把职责定义为&quot;类元的契约或义务&quot;，因此职责的划分从本质来讲还是类元本身决定的，比如订单，它要提供订单渲染、订单创建、订单修改、订单查询的义务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;职责分为两类：一类是认知职责；另一类是行为职责。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对私有数据封装的认知。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对相关对象的认知。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对其能够导出或计算的事物的认识。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt; &lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;自己执行的行为，包括创建对象或计算。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;初始化其它对象的动作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;控制或协调其它对象的活动。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;分配职责的逻辑&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;上一小节中提到的职责有两类，认知职责是对象自身的认知范围，即它只能基于自身属性完成相应的职责，举一个例子，假如一主多子的订单，要计算总的订单金额，怎么分配职责呢？首先商品只能查到自身价格的信息，它的认识是基于商品 price 属性，一个子订单可以有多个商品，那么它也只能计算出子订单的金额信息，它的认知是基于 item 和 quantity两个属性，主订单包含所有子订单的信息，那么就可以计算出总的订单金额。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;414&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7155756207674944&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibGp8crv1FlwgEFjIvqhw7l3RrFPGg8f2qRLn8tesy68x2W1JlmqCoQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;886&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从上面的例子中我们可以看出，认知职责是基于对象属性的，正所谓&quot;不在其位、不谋其政&quot;，认知职责一定不会超过它的认识范围的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;行为职责是偏领域服务的，有的时候一个职责不属于某一个对象，比如转账，就是一个行为，让其它的职责承担并不合适，这类行为职责往往是一个显著的业务活动，比如订单渲染、订单创建就是行为职责而非认知职责。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分配职责一定要遵循&quot;信息专家&quot;模式，它的含义是将职责分配给具有完成该职责所需要信息的那个类，也即上面提到的认识产生职责。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;验证职责分配的合理性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们期望分配的职责满足&quot;高内聚、低耦合&quot;，怎么检验呢？我们再回过头来思考职责的定义：类元的契约或义务，换句话讲，职责是满足其它对象来调用的，这个就与我们画时序图的目的是一致的，每次发生一次调用，即意味着其它的对象要提供一个职责出来，因此我们可以在时序图中看对象间的调用频次，如果一个对象被调用得非常频繁，有可能这个对象承担了太多的职责，是不是可以对其拆分，把职责分配一部分出去。因此，对象职责分配并不是一蹴而就的，需要不断审视、检验。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分配职责是要遵循一定的原则，如创建者模式、信息专家模式、纯虚构模式等，这些原则会在下一篇中单独去讲。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;05&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong&gt;案例&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;案例背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这里举一个例子，说明面向过程和面向对象在分析、编写代码的差异性，计税需要判断是否满足计税规则，比如虚拟商品不计税（手机充值之类）、有些免税地址不计税、小 B 买家也不计税等，因此需要提供一个计税过滤判断逻辑。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;常规面向过程实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;面向过程的思路很简单，提供一个过滤方法依次处理下面逻辑：过滤虚拟商品计税请求、过滤免税地址计税请求、过滤小 B 买家计税请求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;62&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.10727969348659004&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibZ0fjQUlPay3vGF1xGCd1ko8deibiae6O9FxWrpDMqKibmN2VCLxQljtOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2088&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;filter&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;List&amp;lt;TaxCalculateRequest&amp;gt; request&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     filterVirtualItem(request);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     filterOuterIsland(request);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     filterPurchaseType(reqeust);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;面向对象实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;面向过程是从过程视角或者是功能视角分析问题，而面向对象是从对象的视角分析问题，过滤计税请求是计税过滤器判断计税请求是否满足计税规则，这里就包含了两个对象：计税过滤器和计税规则，判断是否满足计税要求这个职责应该是在具体的计税规则处理器中，比如是否是小 B 买家等，因此我们可以画出对象模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;406&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7027491408934707&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWvLvfbd8ibu7SnGbJC6NVUWibdicia8Yicxp31E1thP5dqw7f1592CWPlxCULaaDjt5vibD5iaqUpLOG0upA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1164&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关键代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AbstractRuleHandler&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;handler&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;TaxCalculateRequest request&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AbstractRuleHandler&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TaxCaluclateFilter.register(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;06&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在文章中提到，面向对象的底层逻辑是基于现实事物做的抽象映射，重要的不是要面向对象具体技术的使用上，而是分析问题的思维上，这是最难的，它最大的好处是问题空间到解空间是一一直接映射的，请注意是一一直接映射，它意味着我们在讨论方案的时候，完全可以映射到问题空间，如果是间接映射，也就意味着设计的方案后面会面临重新设计的可能性，因为它是基于场景或功能做出的归纳设计，而且是表层的设计。真正掌握了面向对象分析和设计的方法，也体会到其中的益处，对理解业务、方案设计、编码开发都有好处。&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;

          

          



                    
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ba2757bc20e6ffdbe471b0eeddf930ff</guid>
<title>Redis 定长队列的探索和实践</title>
<link>https://toutiao.io/k/eink2lm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;vivo 互联网服务器团队 - Wang Zhi&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、业务背景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;从技术的角度来说，技术方案的选型都是受限于实际的业务场景，都以解决实际业务场景为目标。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在我们的实际业务场景中，需要以游戏的维度收集和上报行为数据，考虑数据的量级，执行尽最大努力交付且允许数据的部分丢弃。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据上报支持游戏的维度的批量上报，支持同一款游戏128个行为进行批量上报。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据上报需要时效控制，上报的数据必须是上报时刻的前3分钟的数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;整体数据的业务形态如下图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41171875&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUaD2YKl7wc4HIwibibTLGq4LicnJ2AF11jNJ1AGTU8sIibJYibxqNyVnHt8ww/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、技术选型&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;从业务的角度来说包含数据的收集和数据的上报，我们把数据的收集比作生产者，数据的上报比作消费者，是一个典型的生产消费模型。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;生产消费模型在JVM进程内部通过队列+锁或者无锁的Disruptor来实现，在跨进程场景下通过MQ（RocketMQ/kafka）进行处理解耦。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是细化到具体业务场景来看，消息的消费有诸多限制，包括：&lt;strong&gt;游戏维度的批量行为上报，行为上报的时效限制，细化到各个技术方案选型进行对比。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;方案一&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;使用RocketMQ 或者Kafaka等消息队列来存储上报的消息，但是消费侧需要考虑在业务进程中按照游戏维度进行聚合，其中技术细节涉及按照游戏维度进行拆分，在满足消息时效性和批量性的前提下触发上报。在这种方案下消息中间件扮演的角色本质上消息的中转站，&lt;strong&gt;没有解决任何业务场景中提及的游戏维度拆分、批量性和时效性。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方案二&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;在方案一的基础上，寻求一种技术方案来解决游戏维度的&lt;strong&gt;消息分组、批量消费 、时效性&lt;/strong&gt;。通过Redis的list结构来实现队列（进一步要求实现定长队列）来解决游戏维度的消息分组；通过Redis的list支持的Lrange来实现批量消费；通过业务侧的多线程来解决时效问题，针对高频的游戏使用单独的线程池进行处理，上述两个手段能够保证消费速度大于生产速度。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方案对比&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对比两种方案后决定使用Redis的实现了一个伪消息中间件：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;通过List对象实现定长队列来保存游戏维度的行为消息（以游戏作为key的List对象来保存用户行为）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过List来保存所有的存在行为数据的游戏列表；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过Set来进行去重判断来保证2中的List对象的唯一性。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;整体的技术方案如下图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7583826429980276&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUa9HpN09L4gpjF3GS6vzN6stn7UED7qf3GJdODkZiaHomneqYO6h3sBmw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;生产过程&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;步骤一：&lt;/strong&gt;游戏维度的某行为数据PUSH到游戏维度的队列当中。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;步骤二：&lt;/strong&gt;判断游戏是否在游戏的集合Set中，如果在就直接返回，如果不在进行步骤三。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;步骤三：&lt;/strong&gt;往游戏列表中PUSH游戏。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;消费过程&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;步骤一：&lt;/strong&gt;从游戏对象的列表中循环取出一款游戏。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;步骤二：&lt;/strong&gt;通过步骤一获取的游戏对象去该游戏对象的行为数据队列中批量获取数据处理。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、技术原理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在Redis的支持命令中，在List和Set的基础命令，结合Lua脚本来实现整个技术方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;消息数据层面，通过单独的List循环维护待消费的游戏维度的数据，每个游戏维度使用定长的List来保存消息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;消息生产过程中，通过结合List的llen+lpop+rpush来实现游戏维度的定长队列，保证队列的长度可控。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;消息消费过程中，通过结合List的lrange+ltrim来实现游戏维度的消息的批量消费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在整个执行的复杂度层面，需要保证时间复杂度在0(N)常量维度，保证时间可控。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 Lua 脚本&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;EVAL script numkeys key [key ...] arg [arg ...]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：取决于脚本本身的执行的时间复杂度。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; eval &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; key1 key2 first second&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;key1&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;key2&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;first&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;second&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Redis uses the same Lua interpreter to run all the commands.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Also Redis guarantees that a script &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; executed &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; an atomic way:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;no other script &lt;span class=&quot;code-snippet__keyword&quot;&gt;or&lt;/span&gt; Redis command will be executed &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; a script &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; being executed.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;This semantic &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; similar to the one of MULTI / EXEC.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;From the point of view of all the other clients the effects of a script are either still &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; visible &lt;span class=&quot;code-snippet__keyword&quot;&gt;or&lt;/span&gt; already completed.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;Redis采用相同的Lua解释器去运行所有命令，我们可以保证，脚本的执行是原子性的。作用就类似于加了MULTI/EXEC。&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Lua 脚本内多个命令以原子性的方式执行，保证了命令执行的线程安全。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Lua 脚本结合List命令实现定长队列，实现批量消费。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Lua 脚本仅支持单个key的操作，不支持多key的操作。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 List 对象&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LLEN key&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    计算&lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;的长度&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LPOP key [count]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    从&lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;的左侧移除元素&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(N)，N为移除元素的个数。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;RPUSH key element [element ...]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    从&lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;的右侧保存元素&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(N)，N为保存元素的个数。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LRANGE key &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(S+N)， S为偏移量&lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt;， N为指定区间内元素的数量。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    下标(&lt;span class=&quot;code-snippet__keyword&quot;&gt;index&lt;/span&gt;)参数 &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt; 和 &lt;span class=&quot;code-snippet__keyword&quot;&gt;stop&lt;/span&gt; 都以 &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; 为底，也就是说，以 &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; 表示列表的第一个元素，以 &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; 表示列表的第二个元素，以此类推。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    你也可以使用负数下标，以 &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt; 表示列表的最后一个元素， &lt;span class=&quot;code-snippet__number&quot;&gt;-2&lt;/span&gt; 表示列表的倒数第二个元素，以此类推。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;LTRIM&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;stop&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(N) &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; N &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; the &lt;span class=&quot;code-snippet__built_in&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;of&lt;/span&gt; elements &lt;span class=&quot;code-snippet__keyword&quot;&gt;to&lt;/span&gt; be removed &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; the operation.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    修剪(&lt;span class=&quot;code-snippet__keyword&quot;&gt;trim&lt;/span&gt;)一个已存在的 &lt;span class=&quot;code-snippet__keyword&quot;&gt;list&lt;/span&gt;，这样 &lt;span class=&quot;code-snippet__keyword&quot;&gt;list&lt;/span&gt; 就会只包含指定范围的指定元素。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3 Set 对象&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SADD key member [member ...]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    往&lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt;集合添加数据。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SISMEMBER &lt;span class=&quot;code-snippet__keyword&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;member&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    判断&lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt;集合是否存在元素。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    时间复杂度：O(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、技术应用&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 生产消息&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;定义LUA脚本   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CACHE_NPPA_EVENT_LUA =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local retVal = 0 &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local key = KEYS[1] &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local num = tonumber(ARGV[1]) &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local val = ARGV[2] &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local expire = tonumber(ARGV[3]) &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;if (redis.call(&#x27;llen&#x27;, key) &amp;lt; num) then redis.call(&#x27;rpush&#x27;, key, val) &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;else redis.call(&#x27;lpop&#x27;, key) redis.call(&#x27;rpush&#x27;, key, val) retVal = 1 end &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;redis.call(&#x27;expire&#x27;, key, expire) return retVal&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;执行LUA脚本&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; data = &lt;span class=&quot;code-snippet__built_in&quot;&gt;JSON&lt;/span&gt;.toJSONString(nppaBehavior);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Long retVal = (Long)jedisClusterTemplate.eval(CACHE_NPPA_EVENT_LUA, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, NPPA_PREFIX + nppaBehavior.getGamePackage(), &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.valueOf(MAX_GAME_EVENT_PER_GAME), data, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.valueOf(NPPA_TTL_MINUTE * &lt;span class=&quot;code-snippet__number&quot;&gt;60&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;执行效果&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    实现固长队列的数据存储并设置过期时间&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35471204188481675&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUaEayVwcVUa0recLRu58SMWzyOTticewXXtPTIdKyBLic4L5Jia1ISUVfSQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 消费消息&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;定义LUA脚本&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    QUERY_NPPA_EVENT_LUA =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local data = {} &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local key = KEYS[1] &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;local num = tonumber(ARGV[1]) &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;data = redis.call(&#x27;lrange&#x27;, key, 0, num) redis.call(&#x27;ltrim&#x27;, key, num+1, -1) return data&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;执行LUA脚本&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Integer batchSize = NppaConfigUtils.getInteger(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;nppa.report.batch.size&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; result = jedisClusterTemplate.eval(QUERY_NPPA_EVENT_LUA, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,NPPA_PREFIX + gamePackage, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.valueOf(batchSize));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;执行效果&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    取固定数量的对象，然后保留队列的剩余的消息对象。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过整合lrange+ltrim两个命令实现消息的批量消费。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过lua脚本保证上述命令的原子性执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11583924349881797&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUaIbOiaExz4e7EUPIVyOt2I4MTpiavKu1apJmxGAXhTzpvd46e9ZPw9Wbg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.3 注意事项&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Redis集群模式下，执行Lua脚本建议传单key，多key会报重定向错误。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在不同的Redis版本下，Lua脚本针对null的返回值处理不同，参考官方文档。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;消费者的消费过程中通过循环遍历游戏列表，然后根据游戏去获取对应的消息对象，但是不同的游戏对应的热度不同，所以在消费端我们通过配置的方式为热门游戏单独开启消费线程进行消费，相当于针对不同游戏配置不同优先级的消费者。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、线上效果&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3953125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUaibA2WaicSNf0GL5MMhA1ibmiaKpPVKic98PCObaYJIX90RWzKxA3KhgLLMQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3984375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUa6oqicBibiathXXHahbzbxApWSWrMicTPt0HzVIW5SRLD5DXzRfSaBynpOg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3984375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7XcTv0ZJDTcLRW0lQ2tlUamiaygbcaBh8df25OoibR3tj0csMickRCLd3F6Rvia02wZ5kBDcqn0gLYKQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;六、适用场景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;在描述完方案的原理和实现细节之后，进一步对适用的业务场景进行下总结。整体方案是基于redis的基本数据结构构建一个伪消息队列，用以解决&lt;strong&gt;消息的单个生产批量消费&lt;/strong&gt;的场景，通过多key形式实现消息队列的多Topic模式，重要的是能够借助于redis的原生能力在O(N)的时间复杂度完成批量消费。另外该方案也可以降级作为实现先进先出定长的日志队列。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;七、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;本文主要探索在特定业务场景下通过Redis的原生命令实现类MQ的功能，创新式的通过Lua脚本组合Redis的List的基础命令，实现了消息的分组，消息的定长队列，消息的批量消费功能；整体解决方案在线上环境落地并平稳运行，为特定场景提供了一种通用的解决方案。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;—— 活动推荐——&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6133333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOPR8SfKS29VgT4rFCBPxYhL4ytjzxic6xGWdMwuUlfsJkicjfA4TufP9wjM1MHf31Vu5iaB4TuIOTCfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;本文由高可用架构转载。技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMDU1MTE1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONl06YmHad4csRU93kcbJ76JIWzEAmOSVooibFHHkzfWzzkc7dpU4H06Wp9F6Z687vIghdawxvl47A/0?wx_fmt=png&quot; data-nickname=&quot;高可用架构&quot; data-alias=&quot;ArchNotes&quot; data-signature=&quot;高可用架构公众号。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;       &lt;/section&gt;&lt;/div&gt;

          

          



                    
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>58c4b89d9321dcd011300cdf3347bff5</guid>
<title>记一次 ClickHouse 性能测试</title>
<link>https://toutiao.io/k/2pzdh5q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工作场景中，我们会采集工厂设备数据用于智能控制，数据的存储用了 InfluxDB，随着数据规模越来越大，InfluxDB 的性能越来越差，故考虑引入 ClickHouse 分担 InfluxDB 大数据分析的压力，再加上我们业务上也用到了 MySQL ，所以本文就来对比下 MySQL、InfluxDB、ClickHouse 在千万数据量下的写入耗时、聚合查询耗时、磁盘占用等各方面性能指标。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结论先行&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终的结论是，直接使用 ClickHouse 官网提供的 6600w 数据集来做对比测试，在 MySQL、InfluxDB、ClickHouse 同样分配 4c16g 资源的情况下，ClickHouse 无论是导入速度、磁盘占用、查询性能都完全碾压 MySQL 和 InfluxDB，具体对比指标如以下表格：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;MySQL&lt;/th&gt;&lt;th&gt;InfluxDB&lt;/th&gt;&lt;th&gt;ClickHouse&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;导入耗时&lt;/td&gt;&lt;td&gt;大概耗时70分钟&lt;/td&gt;&lt;td&gt;大概耗时35分钟&lt;/td&gt;&lt;td&gt;75秒&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;磁盘空间&lt;/td&gt;&lt;td&gt;12.35 G&lt;/td&gt;&lt;td&gt;5.9 G&lt;/td&gt;&lt;td&gt;2.66 G&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全表count&lt;/td&gt;&lt;td&gt;24366 ms&lt;/td&gt;&lt;td&gt;11674 ms&lt;/td&gt;&lt;td&gt;100 ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全表max/min&lt;/td&gt;&lt;td&gt;27023 ms&lt;/td&gt;&lt;td&gt;26829 ms&lt;/td&gt;&lt;td&gt;186 ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全表平均值&lt;/td&gt;&lt;td&gt;24841 ms&lt;/td&gt;&lt;td&gt;12043 ms&lt;/td&gt;&lt;td&gt;123 ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全表方差&lt;/td&gt;&lt;td&gt;24600 ms&lt;/td&gt;&lt;td&gt;OOM&lt;/td&gt;&lt;td&gt;113 ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;复杂查询1&lt;/td&gt;&lt;td&gt;30260 ms&lt;/td&gt;&lt;td&gt;OOM&lt;/td&gt;&lt;td&gt;385 ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;复杂查询2&lt;/td&gt;&lt;td&gt;470 ms&lt;/td&gt;&lt;td&gt;200 ms&lt;/td&gt;&lt;td&gt;8 ms&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了确保测试结果相对准确，以上每条sql起码执行5次，然后取中间值。其中 InfluxDB 表现比想象中的要差，甚至还不如 MySQL，可能是数据样本和测试用例不太适合 InfluxDB 场景导致的，如果大家对测试结果有疑问，可以 &lt;code&gt;git clone [https://github.com/stone0090/clickhouse-test.git](https://github.com/stone0090/clickhouse-test.git)&lt;/code&gt;项目，完整验证以上对比全过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据库简介&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MySQL&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，属于 Oracle 旗下产品，是最流行的关系型数据库管理系统之一。它所使用的 SQL 语言是用于访问数据库的最常用标准化语言。它采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型和大型网站的开发都选择 MySQL 作为网站数据库。《高性能MySQL》一书中开篇明义讲到的最核心的一句话是“MySQL并不完美，但是却足够灵活”，它是架构中的万金油，庞杂非单一的项目中总会有它的用武之地。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InfluxDB&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InfluxDB 是一个由 InfluxData 公司开发的开源时序型数据库，专注于海量时序数据的高性能读、高性能写、高效存储与实时分析，在 DB-Engines Ranking 时序型数据库排行榜上位列榜首，广泛应用于DevOps监控、IoT监控、实时分析等场景。传统数据库通常记录数据的当前值，时序型数据库则记录所有的历史数据，在处理当前时序数据时又要不断接收新的时序数据，同时时序数据的查询也总是以时间为基础查询条件，并专注于解决以下海量数据场景的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;时序数据的写入：如何支持千万级/秒数据的写入；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时序数据的读取：如何支持千万级/秒数据的聚合和查询；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;成本敏感：海量数据存储带来的是成本问题，如何更低成本地存储这些数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ClickHouse&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ClickHouse 是 Yandex（俄罗斯最大的搜索引擎）开源的一个用于实时数据分析的基于列存储的数据库，其处理数据的速度比传统方法快 100-1000 倍。ClickHouse 的性能超过了目前市场上可比的面向列的 DBMS，每秒钟每台服务器每秒处理数亿至十亿多行和数十千兆字节的数据。它是一个用于联机分析（OLAP）的列式数据库管理系统（DBMS），简单介绍一下 OLTP 和 OLAP。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;OLTP：是传统的关系型数据库，主要操作增删改查，强调事务一致性，比如银行系统、电商系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OLAP：是仓库型数据库，主要是读取数据，做复杂数据分析，侧重技术决策支持，提供直观简单的结果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那 ClickHouse OLAP 适用场景有：1）读多于写；2）大宽表，读大量行但是少量列，结果集较小；3）数据批量写入，且数据不更新或少更新；4）无需事务，数据一致性要求低；5）灵活多变，不适合预先建模。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;环境准备&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在阿里云买一台 16c64g 的服务器，操作系统 centos 7.8，使用 sealos 一键安装 k8s，使用 helm 一键安装 mysql（5.7）、influxdb（1.8）、clickhouse（22.3） ，每个应用各分配 4c16g 的资源。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 下载 sealos&lt;/span&gt;&lt;br/&gt;$ wget https://github.com/labring/sealos/releases/download/v4.0.0/sealos_4.0.0_linux_amd64.tar.gz \&lt;br/&gt;&amp;amp;&amp;amp; tar zxvf sealos_4.0.0_linux_amd64.tar.gz sealos &amp;amp;&amp;amp; chmod +x sealos &amp;amp;&amp;amp; mv sealos /usr/bin&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 初始化一个单节点 Kubernetes&lt;/span&gt;&lt;br/&gt;$ sealos run labring/kubernetes:v1.24.0 labring/calico:v3.22.1 --masters [xxx.xxx.xxx.xxx] -p [your-ecs-password]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 去掉 master 的污点，允许安装应用到 master 和 control-plane&lt;/span&gt;&lt;br/&gt;$ kubectl taint nodes --all node-role.kubernetes.io/master-&lt;br/&gt;$ kubectl taint nodes --all node-role.kubernetes.io/control-plane-&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 获取 mysql、influxdb、clickhouse 一键安装 Helm-Charts&lt;/span&gt;&lt;br/&gt;$ wget https://github.com/stone0090/clickhouse-test/archive/refs/tags/v1.0.0.tar.gz&lt;br/&gt;$ tar -zxvf v1.0.0.tar.gz&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 安装 Kubernetes 包管理工具 Helm，以及 mysql、influxdb、clickhouse 3大数据库&lt;/span&gt;&lt;br/&gt;$ sealos run labring/helm:v3.8.2&lt;br/&gt;$ helm install mysql clickhouse-test-1.0.0/helm-charts/mysql/&lt;br/&gt;$ helm install influxdb clickhouse-test-1.0.0/helm-charts/influxdb/&lt;br/&gt;$ helm install clickhouse clickhouse-test-1.0.0/helm-charts/clickhouse/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据导入&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接使用 ClickHouse 官方提供的测试数据 https://clickhouse.com/docs/zh/getting-started/example-datasets/opensky，此数据集中的数据是从完整的 OpenSky 数据集中派生和清理而来的，以说明 COVID-19 新冠肺炎大流行期间空中交通的发展情况。它涵盖了自2019年1月1日以来该网络超过2500名成员看到的所有航班，总数据量有6600w。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 在服务器 /home/flightlist 目录执行以下命令，该目录会被挂载到 mysql-pod、influxdb-pod、clickhouse-pod 内&lt;/span&gt;&lt;br/&gt;$ wget -O- https://zenodo.org/record/5092942 | grep -oP &lt;span&gt;&#x27;https://zenodo.org/record/5092942/files/flightlist_\d+_\d+\.csv\.gz&#x27;&lt;/span&gt; | xargs wget&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 批量解压 flightlist.gz 数据&lt;/span&gt;&lt;br/&gt;$ &lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; flightlist_*.csv.gz; &lt;span&gt;do&lt;/span&gt; gzip -d &lt;span&gt;&quot;&lt;span&gt;$file&lt;/span&gt;&quot;&lt;/span&gt;; &lt;span&gt;done&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 将 csv 处理成 influxdb 导入所需的 txt 格式（此过程大概耗时1小时）&lt;/span&gt;&lt;br/&gt;$ python clickhouse-test-1.0.0/influxdb_csv2txt.py&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MySQL&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 进入 mysql pod&lt;/span&gt;&lt;br/&gt;$ kubectl &lt;span&gt;exec&lt;/span&gt; -it [influxdb-podname] -- bash&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 连上 mysql 建库、建表&lt;/span&gt;&lt;br/&gt;$ mysql -uroot -p123456&lt;br/&gt;$ use &lt;span&gt;test&lt;/span&gt;;&lt;br/&gt;$ CREATE TABLE `opensky` (`callsign` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`number` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`icao24` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`registration` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`typecode` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`origin` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`destination` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,`firstseen` datetime DEFAULT NULL,`lastseen` datetime DEFAULT NULL,`day` datetime DEFAULT NULL,`latitude_1` double DEFAULT NULL,`longitude_1` double DEFAULT NULL,`altitude_1` double DEFAULT NULL,`latitude_2` double DEFAULT NULL,`longitude_2` double DEFAULT NULL,`altitude_2` double DEFAULT NULL,KEY `idx_callsign` (`callsign`),KEY `idx_origin` (`origin`),KEY `idx_destination` (`destination`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 导入数据（大概耗时70分钟）&lt;/span&gt;&lt;br/&gt;$ load data &lt;span&gt;local&lt;/span&gt; infile &lt;span&gt;&#x27;flightlist_20190101_20190131.csv&#x27;&lt;/span&gt; into table opensky character &lt;span&gt;set&lt;/span&gt; utf8mb4 fields terminated by &lt;span&gt;&#x27;,&#x27;&lt;/span&gt; lines terminated by &lt;span&gt;&#x27;\n&#x27;&lt;/span&gt; ignore 1 lines;&lt;br/&gt;&lt;span&gt;# 省略其他29条导入命令：load data local infile &#x27;flightlist_*_*.csv&#x27; into table opensky character set utf8mb4 fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27; ignore 1 lines;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 检查数据是否导入成功&lt;/span&gt;&lt;br/&gt;$ select count(*) from test.opensky;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InfluxDB&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 进入 influxdb pod&lt;/span&gt;&lt;br/&gt;$ kubectl &lt;span&gt;exec&lt;/span&gt; -it [influxdb-podname] -- bash&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 导入数据（大概耗时30分钟）&lt;/span&gt;&lt;br/&gt;$ influx -username &lt;span&gt;&#x27;admin&#x27;&lt;/span&gt; -password &lt;span&gt;&#x27;admin123456&#x27;&lt;/span&gt; -import -path=/tmp/flightlist/flightlist_20190101_20190131.txt -precision=ns;&lt;br/&gt;&lt;span&gt;# 省略其他29条导入命令：influx -username &#x27;admin&#x27; -password &#x27;admin123456&#x27; -import -path=/tmp/flightlist/flightlist_*_*.txt -precision=ns;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 检查数据是否导入成功&lt;/span&gt;&lt;br/&gt;$ influx -username &lt;span&gt;&#x27;admin&#x27;&lt;/span&gt; -password &lt;span&gt;&#x27;admin123456&#x27;&lt;/span&gt;&lt;br/&gt;$ select count(latitude_1) from test.autogen.opensky;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ClickHouse&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 进入 clickhouse pod&lt;/span&gt;&lt;br/&gt;$ kubectl &lt;span&gt;exec&lt;/span&gt; -it [clickhouse-podname] -- bash&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 连上 clickhouse 建库、建表&lt;/span&gt;&lt;br/&gt;$ clickhouse-client&lt;br/&gt;$ create database &lt;span&gt;test&lt;/span&gt;;&lt;br/&gt;$ use &lt;span&gt;test&lt;/span&gt;;&lt;br/&gt;$ CREATE TABLE opensky(callsign String,number String,icao24 String,registration String,typecode String,origin String,destination String,firstseen DateTime,lastseen DateTime,day DateTime,latitude_1 Float64,longitude_1 Float64,altitude_1 Float64,latitude_2 Float64,longitude_2 Float64,altitude_2 Float64) ENGINE = MergeTree ORDER BY (origin, destination, callsign);&lt;br/&gt;$ &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 导入数据（大概耗时75秒）&lt;/span&gt;&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; /tmp/flightlist&lt;br/&gt;$ &lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; flightlist_*.csv; &lt;span&gt;do&lt;/span&gt; cat &lt;span&gt;&quot;&lt;span&gt;$file&lt;/span&gt;&quot;&lt;/span&gt; | clickhouse-client --date_time_input_format best_effort --query &lt;span&gt;&quot;INSERT INTO test.opensky FORMAT CSVWithNames&quot;&lt;/span&gt;; &lt;span&gt;done&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 检查数据是否导入成功&lt;/span&gt;&lt;br/&gt;$ clickhouse-client&lt;br/&gt;$ SELECT count() FROM test.opensky;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;测试场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MySQL&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ mysql -uroot -p123456&lt;br/&gt;$ use test;&lt;br/&gt;-- 开启性能分析&lt;br/&gt;set profiling = 1;&lt;br/&gt;-- 查询磁盘空间&lt;br/&gt;select table_rows as `总行数`, (data_length + index_length)/1024/1024/1024 as `磁盘占用(G)` from information_schema.`TABLES` where table_name = &#x27;opensky&#x27;;&lt;br/&gt;-- 全表count&lt;br/&gt;select count(latitude_1) from opensky;&lt;br/&gt;-- 全表max/min&lt;br/&gt;select max(longitude_1),min(altitude_1) from opensky;&lt;br/&gt;-- 全表平均值&lt;br/&gt;select avg(latitude_2) from opensky;&lt;br/&gt;-- 全表方差&lt;br/&gt;select var_pop(longitude_2) from opensky;&lt;br/&gt;-- 复杂查询1：全表多个字段聚合查询&lt;br/&gt;select count(latitude_1),max(longitude_1),min(altitude_1),avg(latitude_2) from opensky;&lt;br/&gt;-- 复杂查询2：从莫斯科三个主要机场起飞的航班数量&lt;br/&gt;SELECT origin, count(1) AS c FROM opensky WHERE origin IN (&#x27;UUEE&#x27;, &#x27;UUDD&#x27;, &#x27;UUWW&#x27;) GROUP BY origin;&lt;br/&gt;-- 输出分析结果&lt;br/&gt;show profiles;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InfluxDB&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ influx -username &#x27;admin&#x27; -password &#x27;admin123456&#x27;&lt;br/&gt;$ use test;&lt;br/&gt;-- 耗时统计，queryReqDurationNs 是累计查询时间，2次任务的时间相减就是耗时&lt;br/&gt;select queryReq,queryReqDurationNs/1000/1000,queryRespBytes from _internal.&quot;monitor&quot;.httpd order by time desc limit 10;&lt;br/&gt;-- 查询磁盘空间&lt;br/&gt;select sum(diskBytes) / 1024 / 1024 /1024 from _internal.&quot;monitor&quot;.&quot;shard&quot; where time &amp;gt; now() - 10s group by &quot;database&quot;;&lt;br/&gt;-- 全表count&lt;br/&gt;select count(latitude_1) from opensky;&lt;br/&gt;-- 全表max/min&lt;br/&gt;select max(longitude_1),min(altitude_1) from opensky;&lt;br/&gt;-- 全表平均值&lt;br/&gt;select mean(latitude_2) from opensky;&lt;br/&gt;-- 全表方差&lt;br/&gt;select stddev(longitude_2) from opensky;&lt;br/&gt;-- 复杂查询1：全表多个字段聚合查询&lt;br/&gt;select count(latitude_1),max(longitude_1),min(altitude_1),mean(latitude_2) from opensky;&lt;br/&gt;-- 复杂查询2：从莫斯科三个主要机场起飞的航班数量&lt;br/&gt;SELECT count(latitude_1) AS c FROM opensky WHERE origin =~/^UUEE|UUDD|UUWW$/ GROUP BY origin;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ClickHouse&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ clickhouse-client&lt;br/&gt;$ use test;&lt;br/&gt;-- 耗时统计&lt;br/&gt;select event_time_microseconds,query_duration_ms,read_rows,result_rows,memory_usage,query from system.query_log where query like &#x27;%opensky%&#x27; and query_duration_ms &amp;lt;&amp;gt; 0 and query not like &#x27;%event_time_microseconds%&#x27; order by event_time_microseconds desc limit 5;&lt;br/&gt;-- 查询磁盘空间&lt;br/&gt;SELECT formatReadableSize(total_bytes) FROM system.tables WHERE name = &#x27;opensky&#x27;;&lt;br/&gt;-- 全表count&lt;br/&gt;select count(latitude_1) from opensky;&lt;br/&gt;-- 全表max/min&lt;br/&gt;select max(longitude_1),min(altitude_1) from opensky;&lt;br/&gt;-- 全表平均值&lt;br/&gt;select avg(latitude_2) from opensky;&lt;br/&gt;-- 全表方差&lt;br/&gt;select var_pop(longitude_2) from opensky;&lt;br/&gt;-- 复杂查询1：全表多个字段聚合查询&lt;br/&gt;select count(latitude_1),max(longitude_1),min(altitude_1),avg(latitude_2) from opensky;&lt;br/&gt;-- 复杂查询2：从莫斯科三个主要机场起飞的航班数量&lt;br/&gt;SELECT origin, count() AS c FROM opensky WHERE origin IN (&#x27;UUEE&#x27;, &#x27;UUDD&#x27;, &#x27;UUWW&#x27;) GROUP BY origin;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ClickHouse 为什么快&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、列式存储&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据是按列存储，数据即是索引；查询只访问涉及的列，降低系统I/O；每一列都由一个线程来处理，高效利用CPU资源；还为向量化执行做好了铺垫。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、数据压缩&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据压缩的本质是按照一定的步长对数据进行匹配扫描，当发现重复数据的时候就进行编码转换。因为是列式存储，所以数据特征很相似，所以数据中的重复项多，则压缩率越高，则数据体量越小，则磁盘I/O压力越小，则网络中传输越快。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、向量化执行引擎&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIMD（Single Instruction Multiple Data）即单条指令操作多条数据，它是通过数据并行以提高性能的一种方式，可以简单理解为在寄存器层面对程序中的数据做并行处理，Clickhouse 在能够提升计算效率的地方大量使用了 SIMD，通过使用 SIMD，基本上能带来几倍的性能提升。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4、多线程和分布式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式领域存在一条定律，计算移动比数据移动更加划算，这也是其核心所在，将数据的计算直接发放到数据所在的服务器，多机并行处理，再把最终的结果汇集在一起；另外 ClickHouse 也通过线程级别并行的方式为效率进一步提速，极致去利用服务器的资源。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5、多样的表引擎&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MergeTree 存储结构对写入的数据做排序然后进行有序存储，有序存储主要有两大优势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;列存文件在按块做压缩时，排序键中的列值是连续或者重复的，使得列存块的数据可以获得极致的压缩比；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储有序本身可以加速查询的索引结构，根据排序键中列的等值条件或者 rang 条件，我们可以快速找到目标所在的近似位置区间，并且这种索引结构是不会产生额外的存储开销。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MergeTree 是 ClickHouse 表引擎中最核心的引擎，其他引擎均以 MergeTree 引擎为基础，并在数据合并过程中实现了不同的特性，从而构成了 MergeTree 表引擎家族。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ClickHouse 的优缺点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：极致的查询分析性能，较低的存储成本，高吞吐的数据写入，多样化的表引擎，完备的 DBMS 功能；&lt;br/&gt;缺点：不支持事务，不支持真正的删除/更新，分布式能力较弱；不支持高并发，官方建议 QPS 为100；非标准的 SQL，join 的实现比较特殊，且性能不好；频繁小批量数据操作会影响查询性能；&lt;br/&gt;目前还没有一个 OLAP 引擎能够满足各种场景的需求，其本质原因是，没有一个系统能同时在查询效率、时效性、可维护性三个方面做到完美，只能说 ClickHouse 是为了极致查询性能做了一些取舍。&lt;br/&gt;ClickHouse 优缺点都很明显，是否采用还是要取决于和实际业务场景的契合度，适合自己的架构才是最好架构。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考引用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;识堂 | 笔记分享讨论社区，让知识说话&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InfluxDB优化配置项_sqtce的技术博客_51CTO博客&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;influxDB系列（二）--查看数据库的大小 - 立志做一个好的程序员 - 博客园&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Clickhouse技术分享_大数据_scalad_InfoQ写作社区&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b745241459bbff8c26ac00ae41202655</guid>
<title>你的 golang 程序正在悄悄内存泄漏</title>
<link>https://toutiao.io/k/95kkykp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;h2&gt;什么是内存泄漏&lt;/h2&gt;&lt;p&gt;内存泄漏是指程序运行过程中，内存因为某些原因无法释放或没有释放。简单来讲就是，有代码占着茅坑不拉屎，让内存资源造成了浪费。如果泄漏的内存越堆越多，就会占用程序正常运行的内存。比较轻的影响是程序开始运行越来越缓慢；严重的话，可能导致大量泄漏的内存堆积，最终导致程序没有内存可以运行，最终导致 OOM （Out Of Memory，即内存溢出）。但通常来讲，内存泄漏都是极其不易发现的，所以为了保证程序的健康运行，我们需要重视如何避免写出内存泄漏的代码。&lt;/p&gt;&lt;h2&gt;目录&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• &lt;code&gt;slice&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt; 误用造成内存泄漏&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• &lt;code&gt;time.Ticker&lt;/code&gt; 误用造成内存泄漏&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• channel 误用造成内存泄漏&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;slice、string 误用造成内存泄漏&lt;/h2&gt;&lt;p&gt;一般来说我们经常会使用 &lt;code&gt;a[1:3]&lt;/code&gt; 这种形式对一个 &lt;code&gt;slice&lt;/code&gt; 进行切片，但你可能不知道，如果不注意，这个操作还会导致内存泄漏。毕竟这是个&lt;span&gt;“连 golang 官方都会踩的坑”&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;呢。&lt;/p&gt;&lt;h3&gt;内存泄漏分析&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;slice&lt;/code&gt; 的结构&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这里使用一张《Go 入门指南》的图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4399641577060932&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mOIysYLDI6gBfojcUiaGWBDRxI6MBib6zx2yE57gr40zVa03m5XicECYzfmO5WKnHwKtUic58ricFrTK81icNmgicleSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;图自《Go 入门指南》&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;正如上图 &lt;code&gt;x&lt;/code&gt; 的结构所示，&lt;code&gt;slice&lt;/code&gt; 的结构实际上只记录了如下三个部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• 数组指针。指向了真正的数组地址。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• &lt;code&gt;slice&lt;/code&gt; 的长度&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• &lt;code&gt;slice&lt;/code&gt; 的容量&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当我们对 &lt;code&gt;slice&lt;/code&gt; 切片时，实际上新创建的 &lt;code&gt;slice&lt;/code&gt; 的数组指针也是指向的旧 &lt;code&gt;slice&lt;/code&gt; 指向的底层数组，只是可能指向的位置不同。也就是说，使用切片时，新产生的 &lt;code&gt;slice&lt;/code&gt; 与旧 &lt;code&gt;slice&lt;/code&gt; 共用一个底层数组。&lt;/p&gt;&lt;p&gt;正常情况下，如果没有 &lt;code&gt;y&lt;/code&gt; 这个切片，当 &lt;code&gt;x&lt;/code&gt; 不再使用了，由于 &lt;code&gt;x&lt;/code&gt; 和其指向的数组都不存在任何引用，它们会被垃圾回收机制回收。如果 &lt;code&gt;x&lt;/code&gt; 存在切片，比如上图的 &lt;code&gt;y&lt;/code&gt;，当 &lt;code&gt;x&lt;/code&gt; 不再使用时，&lt;code&gt;x&lt;/code&gt; 可以被回收，但由于 &lt;code&gt;y&lt;/code&gt; 仍在引用底层数组，垃圾回收机制不会把底层数组回收。这就造成底层数组索引为 0 的位置的内存发生了泄漏（谁也访问不到了）。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;验证一下&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;让我们使用代码验证一下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestSlice&lt;/span&gt;(t *testing.T) {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; a []&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;        a = &lt;span&gt;append&lt;/span&gt;(a, i)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; b = a[:&lt;span&gt;10&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;println&lt;/span&gt;(&amp;amp;a, &amp;amp;b)&lt;br/&gt;    &lt;span&gt;println&lt;/span&gt;(&amp;amp;a[&lt;span&gt;0&lt;/span&gt;], &amp;amp;b[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行后，输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;0xc000038748 0xc000038730&lt;br/&gt;0xc000148400 0xc000148400&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以发现，&lt;code&gt;a[0]&lt;/code&gt; 与 &lt;code&gt;b[0]&lt;/code&gt; 地址是完全一样的，可以印证 &lt;code&gt;a&lt;/code&gt; 与 &lt;code&gt;b&lt;/code&gt; 底层用的是同一个数组。当 &lt;code&gt;a&lt;/code&gt; 不再使用时，&lt;code&gt;b&lt;/code&gt; 就会只引用 &lt;code&gt;a&lt;/code&gt; 指向的底层数组的一部分。假设 &lt;code&gt;a&lt;/code&gt; 是一个大数组，而 &lt;code&gt;b&lt;/code&gt; 只引用了一小部分，这就造成了底层数组其他未被引用的部分内存泄漏。即便 &lt;code&gt;a&lt;/code&gt; 是一个小数组，如果内存中有很多类似 &lt;code&gt;b&lt;/code&gt; 引用 &lt;code&gt;a&lt;/code&gt; 这样代码，积少成多，也会导致大量内存泄漏。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;需要注意的是：由于 string 切片时也会共用底层数组，所以使用不当也会造成内存泄漏。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;其他语言中类似的情况&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Python 和 Java 都有类似 &lt;code&gt;slice&lt;/code&gt; 的概念，它们底层都大差不差，因此也会因为类似的原因导致内存泄漏。&lt;/p&gt;&lt;p&gt;比如 Python，也有切片这个概念，看下面这个代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a=[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b=tab[:&lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;(a[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;&lt;span&gt;140700163291672&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;(b[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;&lt;span&gt;140700163291672&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以发现 &lt;code&gt;a[0]&lt;/code&gt; 和 &lt;code&gt;b[0]&lt;/code&gt; 的地址是相同的。&lt;/p&gt;&lt;p&gt;又比如 Java，Java 中这个结构被称为 &lt;code&gt;SubList&lt;/code&gt;。&lt;code&gt;SubList&lt;/code&gt; 和原 &lt;code&gt;List&lt;/code&gt; 底层也是共用的一个数组，所以如果使用不当，也会造成内存泄漏。&lt;/p&gt;&lt;h3&gt;解决方案&lt;/h3&gt;&lt;p&gt;解决问题的核心是：如果我们需要使用切片时，尽量保证切片只作为局部变量使用，不会被传到方法外，这样在局部变量使用完后，该切片就会被回收。比如上文 &lt;code&gt;TestSlice&lt;/code&gt; 中的代码，执行完后，切片就会被回收，即便对切片进行切片也不会造成内存泄漏（上述代码只是用于演示会造成内存泄漏）。但如果切片被传递到其他方法中，很可能被其他方法切片，导致原有的切片出现内存泄漏。&lt;/p&gt;&lt;p&gt;如果我们不能保证将切片作为局部变量使用且不传递，则应该对需要的切片数据进行拷贝，防止内存泄漏。如下所示的两种方式均可：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestSliceSolution&lt;/span&gt;(t *testing.T) {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; a, b []&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;        a = &lt;span&gt;append&lt;/span&gt;(a, i)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    b = &lt;span&gt;append&lt;/span&gt;(b, a[:&lt;span&gt;10&lt;/span&gt;]...)&lt;br/&gt;    &lt;span&gt;println&lt;/span&gt;(&amp;amp;a[&lt;span&gt;0&lt;/span&gt;], &amp;amp;b[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//0xc000014800 0xc000020230&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestSliceSolution2&lt;/span&gt;(t *testing.T) {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; a, b []&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;        a = &lt;span&gt;append&lt;/span&gt;(a, i)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    b = &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;copy&lt;/span&gt;(b, a[:&lt;span&gt;10&lt;/span&gt;])&lt;br/&gt;    &lt;span&gt;println&lt;/span&gt;(&amp;amp;a[&lt;span&gt;0&lt;/span&gt;], &amp;amp;b[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//0xc000014800 0xc00003e6d0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;time.Ticker 误用造成内存泄漏&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;注意：&lt;code&gt;Ticker&lt;/code&gt; 和 &lt;code&gt;Timer&lt;/code&gt; 是不同的。&lt;code&gt;Timer&lt;/code&gt; 只会定时一次，而 &lt;code&gt;Ticker&lt;/code&gt; 如果不 &lt;code&gt;Stop&lt;/code&gt;，就会一直发送定时。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;可能有些人对 &lt;code&gt;Ticker&lt;/code&gt; 并不熟悉，这里给出一个使用示例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestTickerNormal&lt;/span&gt;(t *testing.T) {&lt;br/&gt;    ticker := time.NewTicker(time.Second)&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; ticker.Stop()&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;            fmt.Println(&amp;lt;-ticker.C)&lt;br/&gt;        }&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    time.Sleep(time.Second * &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;finish&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//2022-03-17 12:01:06.279504 +0800 CST m=+1.000922333&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//2022-03-17 12:01:07.281379 +0800 CST m=+2.002815014&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//finish&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//2022-03-17 12:01:08.280861 +0800 CST m=+3.002314240&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;内存泄漏分析&lt;/h3&gt;&lt;p&gt;这里我们分别对使用和不使用 &lt;code&gt;Stop&lt;/code&gt; 方法进行测试。&lt;/p&gt;&lt;p&gt;使用 &lt;code&gt;Stop&lt;/code&gt; 方法停止 &lt;code&gt;Ticker&lt;/code&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestTickerUsingStop&lt;/span&gt;(t *testing.T) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;_0000; i++ {&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() {&lt;br/&gt;            ticker := time.NewTicker(time.Second)&lt;br/&gt;            &lt;span&gt;defer&lt;/span&gt; ticker.Stop()&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++ {&lt;br/&gt;                &amp;lt;-ticker.C&lt;br/&gt;            }&lt;br/&gt;        }()&lt;br/&gt;    }&lt;br/&gt;    time.Sleep(&lt;span&gt;10&lt;/span&gt; * time.Second)&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 以下代码用于内存分析，不重要，不需要看&lt;/span&gt;&lt;br/&gt;    f, _ := os.Create(&lt;span&gt;&quot;1.prof&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; f.Close()&lt;br/&gt;    runtime.GC()&lt;br/&gt;    _ = pprof.WriteHeapProfile(f)&lt;br/&gt;    log.Println(&lt;span&gt;&quot;finish&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 &lt;code&gt;go tool pprof 1.prof&lt;/code&gt;，输入 &lt;code&gt;top&lt;/code&gt; 得到输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Dropped 11 nodes (cum &amp;lt;= 2.09MB)&lt;br/&gt;      flat  flat%   sum%        cum   cum%&lt;br/&gt;  402.16MB 96.08% 96.08%   402.16MB 96.08%  runtime.malg&lt;br/&gt;    8.67MB  2.07% 98.15%     8.67MB  2.07%  runtime.allgadd&lt;br/&gt;    6.23MB  1.49% 99.64%     6.23MB  1.49%  time.startTimer&lt;br/&gt;         0     0% 99.64%     6.23MB  1.49%  demo.TestTickerUsingStop.func1&lt;br/&gt;         0     0% 99.64%   410.83MB 98.15%  runtime.newproc.func1&lt;br/&gt;         0     0% 99.64%   410.83MB 98.15%  runtime.newproc1&lt;br/&gt;         0     0% 99.64%   410.83MB 98.15%  runtime.systemstack&lt;br/&gt;         0     0% 99.64%     6.23MB  1.49%  time.NewTicker&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不使用 &lt;code&gt;Stop&lt;/code&gt; 停止 &lt;code&gt;Ticker&lt;/code&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestTickerWithoutUsingStop&lt;/span&gt;(t *testing.T) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;_0000; i++ {&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() {&lt;br/&gt;            ticker := time.NewTicker(time.Second)&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++ {&lt;br/&gt;                &amp;lt;-ticker.C&lt;br/&gt;            }&lt;br/&gt;        }()&lt;br/&gt;    }&lt;br/&gt;    time.Sleep(&lt;span&gt;10&lt;/span&gt; * time.Second)&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 以下代码用于内存分析，不重要，不需要看&lt;/span&gt;&lt;br/&gt;    f, _ := os.Create(&lt;span&gt;&quot;2.prof&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; f.Close()&lt;br/&gt;    runtime.GC()&lt;br/&gt;    _ = pprof.WriteHeapProfile(f)&lt;br/&gt;    log.Println(&lt;span&gt;&quot;finish&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;操作同上，得到输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Dropped 10 nodes (cum &amp;lt;= 3.04MB)&lt;br/&gt;      flat  flat%   sum%        cum   cum%&lt;br/&gt;  378.65MB 62.21% 62.21%   378.65MB 62.21%  runtime.malg&lt;br/&gt;  210.02MB 34.51% 96.72%   219.83MB 36.12%  time.NewTicker&lt;br/&gt;    9.81MB  1.61% 98.33%     9.81MB  1.61%  time.startTimer&lt;br/&gt;    8.67MB  1.42% 99.75%     8.67MB  1.42%  runtime.allgadd&lt;br/&gt;         0     0% 99.75%   219.83MB 36.12%  demo.TestTickerWithoutUsingStop.func1&lt;br/&gt;         0     0% 99.75%   387.32MB 63.64%  runtime.newproc.func1&lt;br/&gt;         0     0% 99.75%   387.32MB 63.64%  runtime.newproc1&lt;br/&gt;         0     0% 99.75%   387.32MB 63.64%  runtime.systemstack&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到不使用 &lt;code&gt;Stop&lt;/code&gt; 方法时，&lt;code&gt;time.NewTicker&lt;/code&gt; 占用内存会非常高，可以得出结论，这样确实会造成内存泄漏。&lt;/p&gt;&lt;p&gt;另外，需要注意的是，如果使用 &lt;code&gt;Ticker&lt;/code&gt; 后 stop 了，却又尝试使用 &lt;code&gt;&amp;lt;-ticker.C&lt;/code&gt;，会造成 go routine 阻塞，从而导致内存泄漏。如下代码所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestTicker&lt;/span&gt;(t *testing.T) {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;NumGoroutine:&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() {&lt;br/&gt;        ticker := time.NewTicker(time.Second)&lt;br/&gt;        ticker.Stop() &lt;span&gt;// 注意，这里先 stop 了&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++ {&lt;br/&gt;            &amp;lt;-ticker.C&lt;br/&gt;        }&lt;br/&gt;        fmt.Println(&lt;span&gt;&quot;ticker finish&quot;&lt;/span&gt;)&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    time.Sleep(&lt;span&gt;5&lt;/span&gt; * time.Second)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;NumGoroutine:&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// NumGoroutine: 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// NumGoroutine: 3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;channel 误用造成内存泄漏&lt;/h2&gt;&lt;p&gt;都说 golang 10 次内存泄漏，9 次是 go routine 泄漏。可见 go channel 内存泄漏的常见性。go channel 内存泄漏主要分两种情况，我在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4ODkxNDU1Mg==&amp;amp;mid=2650112148&amp;amp;idx=1&amp;amp;sn=94893cf459e61551f6c4e008970b3aff&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《老手也常误用！详解 Go channel 内存泄漏问题》&quot; data-linktype=&quot;2&quot;&gt;《老手也常误用！详解 Go channel 内存泄漏问题》&lt;/a&gt;这篇文章有详细讲述。这里简单说一下造成内存泄漏的代码、原因。&lt;/p&gt;&lt;h3&gt;情景一： &lt;code&gt;select-case&lt;/code&gt; 造成的内存泄漏&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestLeakOfMemory&lt;/span&gt;(t *testing.T) {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;NumGoroutine:&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;   chanLeakOfMemory()&lt;br/&gt;   time.Sleep(time.Second * &lt;span&gt;3&lt;/span&gt;) &lt;span&gt;// 等待 goroutine 执行，防止过早输出结果&lt;/span&gt;&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;NumGoroutine:&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;chanLeakOfMemory&lt;/span&gt;() {&lt;br/&gt;   errCh := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) &lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() { &lt;br/&gt;      time.Sleep(&lt;span&gt;2&lt;/span&gt; * time.Second)&lt;br/&gt;      errCh &amp;lt;- errors.New(&lt;span&gt;&quot;chan error&quot;&lt;/span&gt;) &lt;span&gt;// (1)&lt;/span&gt;&lt;br/&gt;      fmt.Println(&lt;span&gt;&quot;finish sending&quot;&lt;/span&gt;)&lt;br/&gt;   }()&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; err &lt;span&gt;error&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(time.Second): &lt;span&gt;// (2) 大家也经常在这里使用 &amp;lt;-ctx.Done()&lt;/span&gt;&lt;br/&gt;      fmt.Println(&lt;span&gt;&quot;超时&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; err = &amp;lt;-errCh: &lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;         fmt.Println(err)&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;         fmt.Println(&lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于 go channel 在没有缓冲队列的时候，读取 channel 默认是阻塞的，所以 (1) 处代码会阻塞，(2) 处超时后，由于没有 go routine 读取 channel ，(1) 会一直阻塞。因此输出：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;NumGoroutine: 2&lt;br/&gt;超时&lt;br/&gt;NumGoroutine: 3&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;情景二： &lt;code&gt;for-range&lt;/code&gt; 造成的内存泄漏&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestLeakOfMemory2&lt;/span&gt;(t *testing.T) {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;NumGoroutine:&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;   chanLeakOfMemory2()&lt;br/&gt;   time.Sleep(time.Second * &lt;span&gt;3&lt;/span&gt;) &lt;span&gt;// 等待 goroutine 执行，防止过早输出结果&lt;/span&gt;&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;NumGoroutine:&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;chanLeakOfMemory2&lt;/span&gt;() {&lt;br/&gt;   ich := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;// sender&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() {&lt;br/&gt;      &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(ich)&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++ {&lt;br/&gt;         ich &amp;lt;- i &lt;span&gt;// (2)&lt;/span&gt;&lt;br/&gt;         time.Sleep(time.Millisecond) &lt;span&gt;// 控制一下，别发太快&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;   }()&lt;br/&gt;   &lt;span&gt;// receiver&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() {&lt;br/&gt;      ctx, cancel := context.WithTimeout(context.Background(), time.Second)&lt;br/&gt;      &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;range&lt;/span&gt; ich { &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; ctx.Err() != &lt;span&gt;nil&lt;/span&gt; { &lt;span&gt;// (1)&lt;/span&gt;&lt;br/&gt;            fmt.Println(ctx.Err())&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;         }&lt;br/&gt;         fmt.Println(i)&lt;br/&gt;      }&lt;br/&gt;   }()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// NumGoroutine: 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// ...(省略)...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 789&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// context deadline exceeded&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// NumGoroutine: 3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意 (1) 处代码，如果检测到 &lt;code&gt;ctx.Err() != nil&lt;/code&gt;，程序会立刻退出，但此时 &lt;code&gt;ich&lt;/code&gt; 仍在发送，这就导致代码可能阻塞在 (2) 处，造成了内存泄漏。&lt;/p&gt;&lt;h3&gt;解决方案&lt;/h3&gt;&lt;p&gt;如果接收者需要在 channel 关闭之前提前退出，为防止内存泄漏，在发送者与接收者发送次数是一对一时，应设置 channel 缓冲队列为 1；在发送者与接收者的发送次数是多对多时，应使用专门的 stop channel 通知发送者关闭相应 channel。&lt;/p&gt;&lt;p&gt;由于篇幅限制，更详细的内容可以看&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4ODkxNDU1Mg==&amp;amp;mid=2650112148&amp;amp;idx=1&amp;amp;sn=94893cf459e61551f6c4e008970b3aff&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《老手也常误用！详解 Go channel 内存泄漏问题》&quot; data-linktype=&quot;2&quot;&gt;《老手也常误用！详解 Go channel 内存泄漏问题》&lt;/a&gt;这篇文章。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;以上造成内存泄漏的示例看起来似乎都是小问题，单个示例泄漏的内存不多。但要注意，我们的上述代码可能被写在一个 go routine 中，如果每次访问，都是用一个 go routine 处理（比如后端中，每有一个请求，就会创建一个 go routine 来处理），那么是不是访问的次数越多，泄漏的内存越多。内存泄漏正是由这种看似不起眼的小问题造成的。如果放任不管或不重视，最终造成的结果就是业务频繁宕机、卡顿等。所以我们在业务中应该极其重视。&lt;/p&gt;&lt;h2&gt;参考文章&lt;/h2&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; “连 golang 官方都会踩的坑”: &lt;em&gt;https://github.com/golang/go/pull/32138&lt;/em&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;153&quot; data-ratio=&quot;0.3165905631659056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mOIysYLDI6gBfojcUiaGWBDRxI6MBib6zx61ibibchxkb86BhTEu7F1NBdlLP1CArnl4ZTxJKLKg0DkJic1qya2nVHQ/640?wx_fmt=png&quot; data-type=&quot;jpeg&quot; data-w=&quot;1314&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;145&quot; data-ratio=&quot;0.33353998760074394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mOIysYLDI6gBfojcUiaGWBDRxI6MBib6zxoZW1A2T9JyZQRedGyS4014PoSRQaqaYYB3H4onJG5p3dH4T3TuYCibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1613&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4ODkxNDU1Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/mOIysYLDI6gaYftrS8uK6spZXkmAibUtLpdGlcksGawHKaxxGgTL9F5bTcjkic63MuXPRdqQ3vr3nrxRXMUiauHkA/0?wx_fmt=png&quot; data-nickname=&quot;柳双六&quot; data-alias=&quot;liu-shuang-liu&quot; data-signature=&quot;Java / Golang / 算法 / 其他&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          

          



                    
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7eeb2bfeaba367db42124f9095d42688</guid>
<title>Golang 中反射的应用与理解</title>
<link>https://toutiao.io/k/mjhakl9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzI1MzYzMjE0MQ==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhkoWTP1gVm0Lqs480XOARyoSYjPEsRVCSF35cbWIp6cliaYic8KUfNfiaSjVnruzTQUTCA0lmv9vUmw/0?wx_fmt=png&quot; data-nickname=&quot;字节跳动技术团队&quot; data-alias=&quot;BytedanceTechBlog&quot; data-signature=&quot;字节跳动的技术实践分享&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;动手点关注 干货不迷路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 👆&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;首先来一段简单的代码逻辑热身，下面的代码大家觉得应该会打印什么呢？&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; OKR &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   id      &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   content &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getOkrDetail&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, okrId &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(*OKR, *okrErr.OkrErr)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &amp;amp;OKR{id: okrId, content: fmt.Sprint(rand.Int63())}, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getOkrDetailV2&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, okrId &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(*OKR, okrErr.OkrError)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; okrId == &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;, okrErr.OKRNotFoundError&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &amp;amp;OKR{id: okrId, content: fmt.Sprint(rand.Int63())}, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;paperOkrId&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Test001&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; okr *OKR&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   okrId, err := paperOkrId(ctx)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;####   111   ####&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   okr, err = getOkrDetail(ctx, okrId)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;####   222   ####&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   okr, err = getOkrDetailV2(ctx, okrId)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;####   333   ####&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   okr, err = getOkrDetailV2(ctx, okrId + &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;####   444   ####&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;####   555   ####&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fmt.Printf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%v&quot;&lt;/span&gt;, okr)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   Test001(context.Background())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.528125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjWxkN83b0NhibWmPT4nhH9U1TcESaq71icLzuoEwjPibicO7SkKEpQgicmCbPJAQibNYQGZSbDTDs5NVFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;在讲反射之前，先来看看 Golang 关于类型设计的一些原则&lt;/span&gt;&lt;/section&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在 Golang 中变量包括（type, value）两部分&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;理解这一点就能解决上面的简单问题了&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;type 包括 static type 和 concrete type. 简单来说 static type 是你在编码是看见的类型(如 int、string)，concrete type 是 runtime 系统看见的类型。类型断言能否成功，取决于变量的 concrete type，而不是 static type.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;接下来要说的反射，就是能够在运行时更新变量和检查变量的值、调用变量的方法和变量支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为反射。Golang 的基础类型是静态的（也就是指定 int、string 这些的变量，它的 type 是 static type），在创建变量的时候就已经确定，反射主要与 Golang 的 interface 类型相关（它的 type 是 concrete type），只有运行时 interface 类型才有反射一说。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Golang 中为什么要使用反射/什么场景可以（应该）使用反射&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;当程序运行时，&lt;/span&gt;&lt;span&gt; 我们获取到一个 interface 变量， 程序应该如何知道当前变量的类型，和当前变量的值呢？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;当然我们可以有预先定义好的指定类型， 但是如果有一个场景是我们需要编写一个函数，能够处理一类共性逻辑的场景，但是输入类型很多，或者根本不知道接收参数的类型是什么，或者可能是没约定好；也可能是传入的类型很多，这些类型并不能统一表示。这时反射就会用的上了，典型的例子如：json.Marshal。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再比如说有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定。这时就需要对函数和函数的参数进行反射，在运行期间动态地执行函数。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;举例场景：&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;比如我们需要将一个 struct 执行某种操作（用格式化打印代替），这种场景下我们有多种方式可以实现，比较简单的方式是：switch case  &lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Sprint&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(x &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; stringer &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String() &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;switch&lt;/span&gt; x := x.(&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; stringer:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; x.String()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; x&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; strconv.Itoa(x)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; x {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;wrong parameter type&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; permissionType &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是这种简单的方法存在一个问题， 当增加一个场景时，比如需要对 slice 支持，则需要在增加一个分支，这种增加是无穷无尽的，每当我需要支持一种类型，哪怕是自定义类型， 本质上是 int64 也仍然需要增加一个分支。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;反射的基本用法&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;在 Golang 中为我们提供了两个方法，分别是 reflect.ValueOf  和 reflect.TypeOf，见名知意这两个方法分别能帮我们获取到对象的值和类型。Valueof 返回的是 Reflect.Value 对象，是一个 struct,而 typeof 返回的是 Reflect.Type 是一个接口。我们只需要简单的使用这两个进行组合就可以完成多种功能。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; GetOkrDetailResp &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   OkrId   &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   UInfo   *UserInfo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ObjList []*ObjInfo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; ObjInfo &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ObjId &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   Content &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; UserInfo &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   Name         &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   Age          &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   IsLeader     &lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   Salary       &lt;span class=&quot;code-snippet__keyword&quot;&gt;float64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   privateFiled &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;NewUserInfoByReflect&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(req &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt;*&lt;span class=&quot;code-snippet__title&quot;&gt;UserInfo&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; req == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   reqType :=reflect.TypeOf(req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; reqType.Kind() == reflect.Ptr{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      reqType = reqType.Elem()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; reflect.New(reqType).Interface().(*UserInfo)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ModifyOkrDetailRespData&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(req &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   reqValue :=reflect.ValueOf(req).Elem()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fmt.Println(reqValue.CanSet())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   uType := reqValue.FieldByName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;UInfo&quot;&lt;/span&gt;).Type().Elem()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fmt.Println(uType)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   uInfo := reflect.New(uType)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   reqValue.FieldByName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;UInfo&quot;&lt;/span&gt;).Set(uInfo)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;FilterOkrRespData&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(reqData &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, objId &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; reflect.ValueOf(reqData).Elem().NumField(); i++{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fieldValue := reflect.ValueOf(reqData).Elem().Field(i)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; fieldValue.Kind() != reflect.Slice{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fieldType := fieldValue.Type() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      sliceType := fieldType.Elem() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      slicePtr := reflect.New(reflect.SliceOf(sliceType)) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      slice := slicePtr.Elem()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      slice.Set(reflect.MakeSlice(reflect.SliceOf(sliceType), &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;))  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; ;i &amp;lt; fieldValue.Len(); i++{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; fieldValue.Index(i).Elem().FieldByName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ObjId&quot;&lt;/span&gt;).Int() != objId {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         slice = reflect.Append(slice, fieldValue.Index(i))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fieldValue.Set(slice)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Test003&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; uInfo *UserInfo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   uInfo = NewUserInfoByReflect(uInfo)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   uInfo = NewUserInfoByReflect((*UserInfo)(&lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   reqData1 := &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt;(GetOkrDetailResp)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fmt.Println(reqData1.UInfo)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ModifyOkrDetailRespData(reqData1)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fmt.Println(reqData1.UInfo)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   reqData := &amp;amp;GetOkrDetailResp{OkrId: &lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;; i++{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      reqData.ObjList = &lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(reqData.ObjList, &amp;amp;ObjInfo{ObjId: &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;(i), Content: fmt.Sprint(i)})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fmt.Println(reqData)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   FilterOkrRespData(reqData, &lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fmt.Println(reqData)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;反射的性能分析与优缺点&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;大家都或多或少听说过反射性能偏低，使用反射要比正常调用要低几倍到数十倍，不知道大家有没有思考过反射性能都低在哪些方面，我先做一个简单分析，通过反射在获取或者修改值内容时，多了几次内存引用，多绕了几次弯，肯定没有直接调用某个值来的迅速，这个是反射带来的固定性能损失，还有一方面的性能损失在于，结构体类型字段比较多时，要进行遍历匹配才能获取对应的内容。下面就根据反射具体示例来分析性能：&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;测试反射结构体初始化&lt;/span&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Benchmark_Reflect_New&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; tf *TestReflectField&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   t := reflect.TypeOf(TestReflectField{})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      tf = reflect.New(t).Interface().(*TestReflectField)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   _ = tf&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Benchmark_New&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; tf *TestReflectField&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      tf = &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt;(TestReflectField)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   _ = tf&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.15625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjWxkN83b0NhibWmPT4nhH9UicGXD33KPzuTRtP9wtiahzo9lR0NsED59XodMUG22M1mLAI65eukTTGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看出，利用反射初始化结构体和直接使用创建 new 结构体是有性能差距的，但是差距不大，不到一倍的性能损耗，看起来对于性能来说损耗不是很大，可以接受。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;测试结构体字段读取/赋值&lt;/span&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Benchmark_Reflect_GetField&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; tf = &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt;(TestReflectField)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; r &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   temp := reflect.ValueOf(tf).Elem()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      r = temp.Field(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;).Int()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   _ = tf&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   _ = r&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Benchmark_Reflect_GetFieldByName&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; tf = &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt;(TestReflectField)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   temp := reflect.ValueOf(tf).Elem()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; r &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      r = temp.FieldByName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Age&quot;&lt;/span&gt;).Int()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   _ = tf&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   _ = r&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Benchmark_GetField&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; tf = &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt;(TestReflectField)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   tf.Age = &lt;span class=&quot;code-snippet__number&quot;&gt;1995&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; r &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      r = tf.Age&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   _ = tf&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   _ = r&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Benchmark_Reflect_Field&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; tf = &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt;(TestReflectField)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   temp := reflect.ValueOf(tf).Elem()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      temp.Field(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;).SetInt(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;25&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   _ = tf&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Benchmark_Reflect_FieldByName&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; tf = &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt;(TestReflectField)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   temp := reflect.ValueOf(tf).Elem()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      temp.FieldByName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Age&quot;&lt;/span&gt;).SetInt(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;25&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   _ = tf&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Benchmark_Field&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; tf = &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt;(TestReflectField)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      tf.Age = i&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   _ = tf&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;测试结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.1921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjWxkN83b0NhibWmPT4nhH9UKvgIpRbt2zo5a6HshRLHC2yE73mu4rWLWu9ib0icLOUCoxCvFTAvpbjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.209375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjWxkN83b0NhibWmPT4nhH9UYOiaeqdx6J058NDHlMMibWOpwYSoCnFD5cA2PmGzCDnEcObvSwrey36A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面可以看出，通过反射进行 struct 字段读取耗时是直接读取耗时的百倍。直接对实例变量进行赋值每次 0.5 ns，性能是通过反射操作实例指定位置字段的10 倍左右。使用 FieldByName(&quot;Age&quot;) 方法性能比使用 Field(1) 方法性能要低十倍左右，看代码的话我们会发现，FieldByName 是通过遍历匹配所有的字段，然后比对字段名称，来查询其在结构体中的位置，然后通过位置进行赋值，所以性能要比直接使用 Field(index) 低上很多。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;建议：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.如果不是必要尽量不要使用反射进行操作，&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;使用反射时要评估好引入反射对接口性能的影响。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.减少使用 FieldByName 方法&lt;/span&gt;。在需要使用反射进行成员变量访问的时候，尽可能的使用成员的序号。如果只知道成员变量的名称的时候，看具体代码的使用场景，如果可以在启动阶段或在频繁访问前，通过TypeOf() 、Type.FieldByName() 和 StructField.Index 得到成员的序号。注意这里需要的是使用的是 reflect.Type 而不是 reflect.Value，通过 reflect.Value 是得不到字段名称的。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;测试结构体方法调用&lt;/span&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BenchmarkMethod&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   t := &amp;amp;TestReflectField{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      t.Func0()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BenchmarkReflectMethod&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   v := reflect.ValueOf(&amp;amp;TestReflectField{})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      v.Method(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;).Call(&lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BenchmarkReflectMethodByName&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   v := reflect.ValueOf(&amp;amp;TestReflectField{})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      v.MethodByName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Func0&quot;&lt;/span&gt;).Call(&lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BenchmarkReflectMethod_WithArgs&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   v := reflect.ValueOf(&amp;amp;TestReflectField{})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      v.Method(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;).Call([]reflect.Value{reflect.ValueOf(i)})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BenchmarkReflectMethod_WithArgs_Mul&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   v := reflect.ValueOf(&amp;amp;TestReflectField{})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      v.Method(&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;).Call([]reflect.Value{reflect.ValueOf(TestReflectField{})})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BenchmarkReflectMethod_WithArgs_Interface&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   v := reflect.ValueOf(&amp;amp;TestReflectField{})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; tf TestInterface = &amp;amp;TestReflectField{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      v.Method(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;).Call([]reflect.Value{reflect.ValueOf(tf)})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BenchmarkMethod_WithManyArgs&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   s := &amp;amp;TestReflectField{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      s.Func4(i, i, i, i, i, i)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BenchmarkReflectMethod_WithManyArgs&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   v := reflect.ValueOf(&amp;amp;TestReflectField{})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   va := &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;([]reflect.Value, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      va = &lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(va, reflect.ValueOf(i))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      v.Method(&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;).Call(va)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BenchmarkMethod_WithResp&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   s := &amp;amp;TestReflectField{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      _ = s.Func5()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BenchmarkReflectMethod_WithResp&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   v := reflect.ValueOf(&amp;amp;TestReflectField{})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      _ = v.Method(&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;).Call(&lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;)[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;].Int()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjWxkN83b0NhibWmPT4nhH9UlXnAwQOpWEKG8omia1ypnK5BgJ0rtxEJCEkneYjhOF0P6aCHLfIq8IQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个测试结果同上面的分析相同&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;优缺点：&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;反射提高了程序的灵活性和扩展性，降低耦合性，提高自适应能力。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;合理利用反射可以减少重复代码&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;反射在 okr 中的简单应用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;OkrBaseMW&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(next endpoint.EndPoint)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;endpoint&lt;/span&gt;.&lt;span class=&quot;code-snippet__title&quot;&gt;EndPoint&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, req &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(resp &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, err error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; req == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; next(ctx, req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      requestValue := reflect.ValueOf(req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; requestValue.Type().Kind() == reflect.Ptr {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         requestValue = requestValue.Elem()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; requestValue.Type().Kind() != reflect.Struct {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; next(ctx, req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; requestValue.IsValid() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         okrBaseValue := requestValue.FieldByName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;OkrBase&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; okrBaseValue.IsValid() &amp;amp;&amp;amp; okrBaseValue.Type().Kind() == reflect.Ptr {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            okrBase, ok := okrBaseValue.Interface().(*okrx.OkrBase)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ok {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               ctx = contextWithUserInfo(ctx, okrBase)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               ctx = contextWithLocaleInfo(ctx, okrBase)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               ctx = contextWithUserAgent(ctx, okrBase)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               ctx = contextWithCsrfToken(ctx, okrBase)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               ctx = contextWithReferer(ctx, okrBase)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               ctx = contextWithXForwardedFor(ctx, okrBase)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               ctx = contextWithHost(ctx, okrBase)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               ctx = contextWithURI(ctx, okrBase)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               ctx = contextWithSession(ctx, okrBase)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; next(ctx, req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;结论：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;使用反射必定会导致性能下降，但是反射是一个强有力的工具，可以解决我们平时的很多问题，比如数据库映射、数据序列化、代码生成场景。在使用反射的时候，我们需要避免一些性能过低的操作，例如使用 FieldByName() 和MethodByName() 方法，如果必须使用这些方法的时候，我们可以预先通过字段名或者方法名获取到对应的字段序号，然后使用性能较高的反射操作，以此提升使用反射的性能。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;加入我们&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-eleid=&quot;21&quot;/&gt;&lt;span&gt;我们来自字节跳动飞书商业应用研发部（Lark Business Applications），目前我们在北京、深圳、上海、武汉、杭州、成都、广州、三亚都设立了办公区域。我们关注的产品领域主要在企业经验管理软件上，包括飞书 OKR、飞书绩效、飞书招聘、飞书人事等 HCM 领域系统，也包括飞书审批、OA、法务、财务、采购、差旅与报销等系统。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;欢迎各位加入我们。&lt;/span&gt;&lt;span&gt;扫码发现职位&amp;amp;投递简历&lt;/span&gt;&lt;span&gt;（二维码如下）&lt;/span&gt;&lt;span&gt;官网投递：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0061728395061729&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5EcwYhllQOjWxkN83b0NhibWmPT4nhH9UBFwjPAIf9jKaicdicZRmmSEBnIO2KRVnfMQd0STb0nxvnNTGibb1NVZmg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;324&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;👇 点击&lt;/span&gt;&lt;strong&gt;&lt;span&gt;阅读原文&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，欢迎各位加入我们&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;

          

          



                    
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>