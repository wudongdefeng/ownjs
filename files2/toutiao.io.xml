<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>856cd667d59cd74a5fff7d6e3f907692</guid>
<title>接口突然超时 10 宗罪。。。</title>
<link>https://toutiao.io/k/oc43cu5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有遇到过这样的场景：我们提供的某个&lt;code&gt;API接口&lt;/code&gt;，&lt;code&gt;响应时间&lt;/code&gt;原本一直都很快，但在某个不经意的时间点，突然出现了&lt;code&gt;接口超时&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许你会有点懵，到底是为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;今天跟大家一起聊聊接口&lt;/span&gt;&lt;code&gt;突然&lt;/code&gt;&lt;span&gt;超时的10个原因，希望对你会有所帮助。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.网络异常&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口原本好好的，突然出现超时，最常见的原因，可能是网络出现异常了。比如：偶然的网络抖动，或者是带宽被占满了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.1 网络抖动&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经常上网的我们，肯定遇到过这样的场景：大多数情况下我们访问某个网站很快，但偶尔会出现网页一直转圈，加载不出来的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有可能是你的网络出现了抖动，丢包了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网页请求API接口，或者接口返回数据给网页，都有可能会出现网络丢包的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;网络丢包&lt;/code&gt;可能会导致接口超时。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.1 带宽被占满&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，由于页面或者接口设计不合理，用户请求量突增的时候，可能会导致服务器的网络带宽被占满的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;服务器带宽&lt;/code&gt;指的是在一定时间内&lt;code&gt;传输&lt;/code&gt;数据的&lt;code&gt;大小&lt;/code&gt;，比如：1秒传输了10M的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户请求量突然增多，超出了1秒10M的上限，比如：1秒100M，而服务器带宽本身1秒就只能传输10M，这样会导致在这1秒内，90M数据就会延迟传输的情况，从而导致接口超时的发生。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所以对于有些高并发请求场景，需要评估一下是否需要增加服务器带宽。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.线程池满了&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们调用的API接口，有时候为了性能考虑，可能会使用&lt;code&gt;线程池&lt;/code&gt;异步查询数据，最后把查询结果进行汇总，然后返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5012285012285013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gkBWTSibwHialQQYtKbMfY7bsMJJXKydXhAoQ9862KM9Yo5rhHIQibm6YTFoza9IqEF1u8icMzrNpgMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;调用远程接口总耗时 200ms = 200ms（即耗时最长的那次远程接口调用）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java8之前可以通过实现&lt;code&gt;Callable&lt;/code&gt;接口，获取线程返回结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java8以后通过&lt;code&gt;CompleteFuture&lt;/code&gt;类实现该功能。我们这里以CompleteFuture为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserInfo &lt;span&gt;getUserInfo&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; UserInfo userInfo = &lt;span&gt;new&lt;/span&gt; UserInfo();&lt;br/&gt;    CompletableFuture userFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteUserAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteBonusAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteGrowthAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();&lt;br/&gt;&lt;br/&gt;    userFuture.get();&lt;br/&gt;    bonusFuture.get();&lt;br/&gt;    growthFuture.get();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userInfo;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我用到了executor，表示&lt;code&gt;自定义的线程池&lt;/code&gt;，为了防止高并发场景下，出现&lt;code&gt;线程&lt;/code&gt;过多的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果用户请求太多，线程池中已有的线程处理不过来，线程池会把多余的请求，放到&lt;code&gt;队列&lt;/code&gt;中&lt;code&gt;排队&lt;/code&gt;，等待&lt;code&gt;空闲&lt;/code&gt;线程的去处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果队列中排队的任务非常多，某次API请求一直在等待，没办法得到及时处理，就会出现接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，我们可以考虑是否&lt;code&gt;核心线程数&lt;/code&gt;设置太小了，或者有多种业务场景共用了同一个线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是因为核心线程池设置太小，可以将其调大一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是因为多种业务场景共用了&lt;code&gt;同一个线程池&lt;/code&gt;，可以拆分成&lt;code&gt;多个线程池&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.数据库死锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候接口超时得有点莫名其妙，特别是遇到数据库出现&lt;code&gt;死锁&lt;/code&gt;的时候。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你提供的API接口中通过某个id更新某条数据，此时，正好线上在手动执行一个批量更新数据的sql语句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该sql语句在一个事务当中，并且刚好也在更新那条数据，可能会出现死锁的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于该sql语句执行时间很长，会导致API接口的那次更新数据操作，长时间被数据库锁住，没法即使返回数据，而出现接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你说坑不坑？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以建议在执行数据库批量操作前，一定要评估数据的影响范围，不要一次性更新太多的数据，不然可能会导致很多意想不到的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，批量更新操作建议在用户访问少的时段执行，比如：凌晨。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.传入参数太多&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，偶尔的一次接口超时，是由于参数传入太多导致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：根据id集合批量查询分类接口，如果传入的id集合数据量不多，传入几十个或上百个id，不会出现性能问题。毕竟id是分类表的&lt;code&gt;主键&lt;/code&gt;，可以走&lt;code&gt;主键索引&lt;/code&gt;，数据库的查找速度是非常快的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果接口调用方，一次性传入几千个，甚至几万个id，批量查询分类，也可能会出现接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为数据库在执行sql语句之前，会评估一下耗时情况，查询条件太多，有可能走全表扫描更快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这种情况下sql语句可能会丢失索引，让执行时间变慢，出现接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们在设计&lt;code&gt;批量接口&lt;/code&gt;的时候，建议要限制传入的集合的大小，比如：500。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果超过我们设置最大的集合大小，则接口直接返回失败，并提示给用户：&lt;code&gt;一次性传入参数过多&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;该限制一定要写到接口文档中，避免接口调用方，在生产环境调用接口失败而踩坑。要在接口开发阶段通知到位。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，如果接口调用方要传入的参数就是很多怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：可能是需求不合理，或者系统设计有问题，我们要尽量在系统设计阶段就规避这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们重新进行系统设计改动比较大的话，有个临时的解决方案：在接口调用方中多线程分批调用该接口，最后将结果进行汇总。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.超时时间设置过短&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，建议我们在调用远程API接口时，要设置&lt;code&gt;连接超时时间&lt;/code&gt;和&lt;code&gt;读超时时间&lt;/code&gt;这两个参数，并且可以动态配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的好处是，可以防止调用远程API接口万一出现了性能问题，响应时间很长，把我们自己的服务拖挂的情况发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：你调用的远程API接口，要100秒才返回数据，而你设置的超时时间是100秒。这时1000个请求过来，去请求该API接口，这样会导致&lt;code&gt;tomcat线程池&lt;/code&gt;很快被占满，导致整个服务暂时不可用，至少新的请求过来，是没法即使响应的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们需要设置超时时间，并且超时时间还不能设置太长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发量不大的业务场景，可以将这两个超时时间设置稍微长一点，比如：&lt;code&gt;连接超时时间&lt;/code&gt;为10秒，&lt;code&gt;读超时时间&lt;/code&gt;为20秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发量大的业务场景，可以设置成&lt;code&gt;秒级&lt;/code&gt;或者&lt;code&gt;毫秒级&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些小伙伴为了开发方便，在多种业务场景共用这两个超时时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某一天，在并发量大的业务场景中，你将该超时时间改短了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但直接导致并发量不大的业务场景中，出现调用API接口超时的问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因此，不建议多种业务场景共用同一个&lt;code&gt;超时时间&lt;/code&gt;，最好根据并发量的不同，单独设置不同的超时时间。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.一次性返回数据太多&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有遇到过这样的需求：我们有个job，每天定时调用第三方API查询接口，获取昨天更新的数据，然后更新到我们自己的数据库表中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于第三方每天更新的数据不多，所以该API接口响应时间还是比较快的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但突然有一天，该API接口却出现了接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看日志发现，该API接口一次性返回的数据太多，而且该数据的更新时间相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就可以断定，该API接口提供方进行了批量更新操作，修改了大量的数据，导致该问题的发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使我们在job中加了&lt;code&gt;失败重试机制&lt;/code&gt;，但由于该API一次性返回数据实在太多太多，重试也很有可能会接口超时，这样会导致一直获取不到第三方前一天最新的数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所以第三方这种根据日期查询增量数据的接口，建议做成分页查询的，不然后面没准哪一天，遇到批量更新的操作，就可能出现接口超时的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 死循环&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;死循环&lt;/code&gt;也会导致接口超时？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死循环不应该在接口&lt;code&gt;测试阶段&lt;/code&gt;就发现了，为什么要到&lt;code&gt;生产环境&lt;/code&gt;才发现？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确实，绝大部分死循环问题，在测试阶段可以发现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有些无限递归隐藏的比较深，比如下面的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死循环其实有两种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;普通死循环&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无限递归&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.1 普通死循环&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候死循环是我们自己写的，例如下面这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(condition) {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;do samething&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用了&lt;code&gt;while(true)&lt;/code&gt;的循环调用，这种写法在&lt;code&gt;CAS自旋锁&lt;/code&gt;中使用比较多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当满足condition等于true的时候，则自动退出该循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果condition条件非常复杂，一旦出现判断不正确，或者少写了一些逻辑判断，就可能在某些场景下出现死循环的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现死循环，大概率是开发人员人为的bug导致的，不过这种情况很容易被测出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种隐藏的比较深的死循环，是由于代码写的不太严谨导致的。如果用正常数据，可能测不出问题，但一旦出现异常数据，就会立即出现死循环。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.2 无限递归&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要打印某个分类的所有父分类，可以用类似这样的递归方法实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printCategory&lt;/span&gt;&lt;span&gt;(Category category)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(category == &lt;span&gt;null&lt;/span&gt; &lt;br/&gt;      || category.getParentId() == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  } &lt;br/&gt;  System.out.println(&lt;span&gt;&quot;父分类名称：&quot;&lt;/span&gt;+ category.getName());&lt;br/&gt;  Category parent = categoryMapper.getCategoryById(category.getParentId());&lt;br/&gt;  printCategory(parent);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，这段代码是没有问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果某次有人误操作，把某个分类的parentId指向了它自己，这样就会出现&lt;code&gt;无限递归&lt;/code&gt;的情况。导致接口一直不能返回数据，最终会发生&lt;code&gt;堆栈溢出&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;建议写递归方法时，设定一个递归的深度，比如：分类最大等级有4级，则深度可以设置为4。然后在递归方法中做判断，如果深度大于4时，则自动返回，这样就能避免无限递归的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.sql语句没走索引&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你有没有遇到过这样一种情况：明明是同一条sql，只有入参不同而已。有的时候走的索引a，有的时候却走的索引b？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，有时候mysql会&lt;code&gt;选错索引&lt;/code&gt;，甚至有时会不走索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql在执行某条sql语句之前，会通过抽样统计来估算扫描行数，根据影响行数、区分度、基数、数据页等信息，最后综合评估走哪个索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候传入参数1，sql语句走了索引a，执行时间很快。但有时候传入参数2，sql语句走了索引b，执行时间明显慢了很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样有可能会导致API接口出现超时问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;必要时可以使用&lt;code&gt;force index&lt;/code&gt;来强制查询sql走某个索引。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.服务OOM&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前遇到过这样一种场景：一个根据id查询分类的接口，该id是&lt;code&gt;主键&lt;/code&gt;，sql语句可以走主键索引，竟然也出现了接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我当时觉得有点不可思议，因为这个接口平均耗时只有十几毫秒，怎么可能会出现超时呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但从当时的日志看，接口响应时间有5秒，的确出现了接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后从&lt;code&gt;Prometheus&lt;/code&gt;的服务内存监控中，查到了OOM问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实该API接口部署的服务当时由于&lt;code&gt;OOM&lt;/code&gt;内存溢出，其实挂了一段时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时所有的接口都出现了请求超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于&lt;code&gt;K8S&lt;/code&gt;集群有&lt;code&gt;监控&lt;/code&gt;，它自动会将挂掉的服务节点&lt;code&gt;kill&lt;/code&gt;掉，并且在容器中重新部署了一个&lt;code&gt;新的服务节点&lt;/code&gt;，幸好对用户没造成太大的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对OOM问题比较感兴趣，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247498590&amp;amp;idx=1&amp;amp;sn=214cab0f95ad3df24055d5d18a110a2a&amp;amp;chksm=c0e823b6f79faaa0fa0c310715c7e94a205add4b1557cdc5f13bda85ce7862232c6955e261b6&amp;amp;token=748942416&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;糟了，线上服务出现OOM了&lt;/a&gt;》。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.在debug&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们有时候需要在本地开发工具，比如：&lt;code&gt;idea&lt;/code&gt;中，直接连接测试环境的数据库，调试某个API接口的业务逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在开发环境，某些问题不太好复现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了排查某个bug，你在请求某个本地接口时，开启了&lt;code&gt;debug模式&lt;/code&gt;，一行行的跟踪代码，排查问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;走到某一行代码的时候，停留了很长一段时间，该行代码主要是更新某条数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，测试同学在相关的业务页面中，操作更新了相同的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种也可能会出现数据库&lt;code&gt;死锁&lt;/code&gt;的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于你在idea的debug模式中，一直都没有提交事务，会导致死锁的时间变得很长，从而导致业务页面请求的API接口出现超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然如果你对常规的接口超时问题比较感兴趣，可以看看我的另一篇文章，里面有非常详细的介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然如果你对常规的接口超时问题比较感兴趣，可以看看我的另一篇文章《&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490731&amp;amp;idx=1&amp;amp;sn=29ed0295c7990157a3a56ba33cf7f8be&amp;amp;chksm=c0ebc443f79c4d55a2bac81744992c96f97737e5d0717ec99231f4d08f57a7f0220eafdac9c9&amp;amp;token=660773166&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊接口性能优化的11个小技巧&lt;/a&gt;&lt;span&gt;》，里面有非常详细的介绍。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>78fdb273ed521317e100da2d3db58cf4</guid>
<title>面试加分项：JVM 锁优化和逃逸分析详解</title>
<link>https://toutiao.io/k/53b9i1t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JVM 在加锁的过程中，会采用自旋、自适应、锁消除、锁粗化等优化手段来提升代码执行效率。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1.1 自旋锁和自适应自旋&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在大多的处理器都是多核处理器 ，如果在多核心处理器，有让两个或者以上的线程并行执行，我们可以让一个等待线程不放弃处理器的执行时间。设置一个等待超时时间，看线程是否能够很快的释放锁，在等等待的这段时间可以执行一个空循环，让当前线程继续占用 CPU 的时间片。这就是所谓的「自旋锁」。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JVM 中可以通过 +XX:UseSpinning来开启自旋锁，在 JDK1.6 过后默认为我们开启。由于自旋锁的使用会让锁的竞争者占用更多的处理器时间， JVM 规定了一个自旋次数的一个参数。我们可以通过 -XX:PreBlockSping来进行更改（默认10次）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;偏向锁、轻量级锁的状态转化及对象 Mark Word 的关系转换入下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5464535464535465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TLH3CicPVibrfYmO00pibkCFCkLQoUfxKr3fld6DKIOWpcqTr0lzibXczvOARjjN6RW2hkVlv4ehFQrJ6KLpcDM6OQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2002&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;偏向锁、轻量级锁的状态转化及对象 Mark Word 的关系&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1.2 锁消除&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;锁消除是指虚拟机即时编译器在运行时检测到某段需要同步的代码不可能存在共享数据竞争而实施的一种对锁进行消除的优化策略。锁消除的主要判断依据于逃逸分析。如果判断一段代码，在堆上所有的数据都不会逃逸出去被别的线程访问到，那就把它当作栈上的数据对待，认为它们是私有的，同步加锁就无需进行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面是三个字符串 x, y, z 相加的例子，无论是从源代码上还是逻辑上都没有进行同步：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; concatStr(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; x, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; y, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; z) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;  x + y + z;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;String 是一个不可变的类，对字符的链接总是生成新的 String 对象来进行的，因此 Javac 编译器会对 String 链接进行自动优化，在 JDK5 之前字符串链接会转换为 StringBuffer；在 JDK5 之后会转换为 StringBuilder 对象连续的 append()操作，我们看看 javac 过后，反编译的结果:&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; concatStr(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; x, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; y, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; z) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    StringBuilder sb = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; StringBuilder();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    sb.append(x);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    sb.append(y);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    sb.append(z);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;  sb.toString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们再来看看 javap 反编译的结果：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4817251461988304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TLH3CicPVibrfYmO00pibkCFCkLQoUfxKr3PZYuia26UicTtPo2xclWyzPviaCK3bemmd7lCCR8dhUR0fZPK20uZw5Hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2736&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;javap 反编译的结果&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里大家可能会担心 StringBuilder 不是线程安全的的操作会存在线程安全的问题吗？这里的答案是不会，x + y + z 操作的优化「经过逃逸分析」过后，他的动态作用域被限制在了 concatStr方法内，就是说当前实际执行的 StringBuilder 的操作在 concatStr 方法内部，「其他的外部线程无法访问」到，所以这里「虽然有锁，但是可以被安全的消除掉。所以当我们进行编译过后，这段代码就会忽略掉所有的同步措施直接执行。」&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1.3 锁粗化&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则上，我们在写代码的时候，总是推荐将同步块的作用范围限制得尽可能的小--只在共享数据的实际操作作用域中才进行同步，这样也是为了使得需要同步的操作尽可能的变少，即使存在锁的竞争，等待的锁的线程也能很快的获取到锁。大多数情况下，上面的原则都是正确的，但是如果「一系列的连续操作都是对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体之中」的，那即使没有线程的竞争，频繁的进行相互操作也会导致不必需要的性能损耗。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;StringBuffer buffer = &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt; StringBuffer();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public void &lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    buffer.&lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;aaa&quot;&lt;/span&gt;).&lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot; bbb&quot;&lt;/span&gt;).&lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot; ccc&quot;&lt;/span&gt;); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面的代码每次调用 buffer.append 方法都需要加锁和解锁，如果 JVM 家册到有一串连续的对同一个对象加锁和解锁的操作，就会将其合并成一次范围更大的加锁解锁操作，即在第一个 append 方法执行的时候进行加锁，最后一个 append 方法结束后进行解锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2 逃逸分析&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;逃逸分析（Escape Analysis），是一种可能减少有效 Java 程序中同步负载和内存堆分配压力的跨全局函数数据流分析算法。通过逃逸分析， Java Hotspot 编译器能够分析出一个新的对象引用范围从而决定是否要将这个对象分配到堆上，「逃逸分析的基本行为就是分析对象的动态作用域。」&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2.1 方法逃逸&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当一个对象在方法里面被定义后，它可能被外部方法所引用，例如调用参数传递到其他方法中，这种称为方法逃逸。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2.2 线程逃逸&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当一个对象可能被外部线程访问到，比如：赋值给其他线程中访问的实例变量，这种称为线程逃逸。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2.3 通过逃逸分析，编译器对代码的优化&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果能够证明一个对象不会逃逸到到方法外或线程外（其他线程方法或者线程无法通过任何方法访问该变量），或者逃逸程度比较低（只逃逸出方法而不逃逸出线程）则可以对这个对象采用不同程度的优化：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;栈上分配（Stack Allocations）完全不会逃逸的局部变量和不会逃逸出线程的对象，采用栈上分配，对象就会跟随方法的结束自动销毁。以减少垃圾回收器的压力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;标量替换（Scalar Replacement）有个对象可能不需要作为一个连续的存储结果存储也能被访问到，那么对象的部分（或者全部）可以不存储在内存，而是存储在 CPU 寄存器中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同步消除（Synchronization Elimination）如果一个对象发现只能在一个线程访问到，那么这个对象的操作可以考虑不同步。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/xidongyu/p/10891303.html&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/kkkkkk/p/5543799.html&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d2caaef4174fd7a3c3e6666345f256c7</guid>
<title>单元测试利器：手把手教你使用 Mockito</title>
<link>https://toutiao.io/k/47g8sh5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：京东零售 秦浩然&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从你成为开发人员的那一天起，写单元测试终究是你逃不开的宿命！那开发人员为什么不喜欢写单元测试呢？究其原因，无外乎是依赖。依赖其他的服务、依赖运行的环境、等等，各种依赖都成为了我们写单元测试的绊脚石。那现在有个单元测试利器可以帮我们解决依赖的问题，你愿意使用一下吗？你愿意！那就是我们要学习的Mockito&lt;/p&gt;

&lt;h2&gt;一、前期准备～&lt;/h2&gt;

&lt;h3&gt;1、准备工作&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--mockito依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mockito&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mockito-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.7.19&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- junit依赖 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2、入门知识&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1）Mockito：简单轻量级的做mocking测试的框架；
2）mock对象：在调试期间用来作为真实对象的替代品；
3）mock测试：在测试过程中，对那些不容易构建的对象用一个虚拟对象来代替测试的方法就叫mock测试；
4）stub：打桩，就是为mock对象的方法指定返回值（可抛出异常）；
5）verify：行为验证，验证指定方法调用情况（是否被调用，调用次数等）；
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3、五分钟入门Demo&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test0() {
    //1、创建mock对象（模拟依赖的对象）
    final List mock = Mockito.mock(List.class);

    //2、使用mock对象（mock对象会对接口或类的方法给出默认实现）
    System.out.println(&quot;mock.add result =&amp;gt; &quot; + mock.add(&quot;first&quot;));  //false
    System.out.println(&quot;mock.size result =&amp;gt; &quot; + mock.size());       //0

    //3、打桩操作（状态测试：设置该对象指定方法被调用时的返回值）
    Mockito.when(mock.get(0)).thenReturn(&quot;second&quot;);
    Mockito.doReturn(66).when(mock).size();

    //3、使用mock对象的stub（测试打桩结果）
    System.out.println(&quot;mock.get result =&amp;gt; &quot; + mock.get(0));    //second
    System.out.println(&quot;mock.size result =&amp;gt; &quot; + mock.size());   //66

    //4、验证交互 verification（行为测试：验证方法调用情况）
    Mockito.verify(mock).get(Mockito.anyInt());
    Mockito.verify(mock, Mockito.times(2)).size();

    //5、验证返回的结果（这是JUnit的功能）
    assertEquals(&quot;second&quot;, mock.get(0));
    assertEquals(66, mock.size());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、让我们开始学习吧！&lt;/h2&gt;

&lt;h3&gt;1、行为验证&lt;/h3&gt;

&lt;p&gt;• 一旦mock对象被创建了，mock对象会记住所有的交互，然后你就可以选择性的验证你感兴趣的交互，验证不通过则抛出异常。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test1() {
    final List mockList = Mockito.mock(List.class);
    mockList.add(&quot;mock1&quot;);
    mockList.get(0);
    mockList.size();
    mockList.clear();
    // 验证方法被使用（默认1次）
    Mockito.verify(mockList).add(&quot;mock1&quot;);
    // 验证方法被使用1次
    Mockito.verify(mockList, Mockito.times(1)).get(0);
    // 验证方法至少被使用1次
    Mockito.verify(mockList, Mockito.atLeast(1)).size();
    // 验证方法没有被使用
    Mockito.verify(mockList, Mockito.never()).contains(&quot;mock2&quot;);
    // 验证方法至多被使用5次
    Mockito.verify(mockList, Mockito.atMost(5)).clear();
    // 指定方法调用超时时间
    Mockito.verify(mockList, timeout(100)).get(0);
    // 指定时间内需要完成的次数
    Mockito.verify(mockList, timeout(200).atLeastOnce()).size();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2、如何做一些测试桩stub&lt;/h3&gt;

&lt;p&gt;• 默认情况下，所有的函数都有返回值。mock函数默认返回的是null，一个空的集合或者一个被对象类型包装的内置类型，例如0、false对应的对象类型为Integer、Boolean；&lt;/p&gt;

&lt;p&gt;• 一旦测试桩函数被调用，该函数将会一致返回固定的值；&lt;/p&gt;

&lt;p&gt;• 对于 static 和 final 方法， Mockito 无法对其 when(…).thenReturn(…) 操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test2() {
    //静态导入，减少代码量：import static org.mockito.Mockito.*;
    final ArrayList mockList = mock(ArrayList.class);

    // 设置方法调用返回值
    when(mockList.add(&quot;test2&quot;)).thenReturn(true);
    doReturn(true).when(mockList).add(&quot;test2&quot;);
    System.out.println(mockList.add(&quot;test2&quot;));  //true

    // 设置方法调用抛出异常
    when(mockList.get(0)).thenThrow(new RuntimeException());
    doThrow(new RuntimeException()).when(mockList).get(0);
    System.out.println(mockList.get(0));    //throw RuntimeException

    // 无返回方法打桩
    doNothing().when(mockList).clear();

    // 为回调做测试桩（对方法返回进行拦截处理）
    final Answer&amp;lt;String&amp;gt; answer = new Answer&amp;lt;String&amp;gt;() {
        @Override
        public String answer(InvocationOnMock invocationOnMock) throws Throwable {
            final List mock = (List) invocationOnMock.getMock();
            return &quot;mock.size result =&amp;gt; &quot; + mock.size();
        }
    };
    when(mockList.get(1)).thenAnswer(answer);
    doAnswer(answer).when(mockList).get(1);
    System.out.println(mockList.get(1));    //mock.size result =&amp;gt; 0

    // 对同一方法多次打桩，以最后一次为准
    when(mockList.get(2)).thenReturn(&quot;test2_1&quot;);
    when(mockList.get(2)).thenReturn(&quot;test2_2&quot;);
    System.out.println(mockList.get(2));    //test2_2
    System.out.println(mockList.get(2));    //test2_2

    // 设置多次调用同类型结果
    when(mockList.get(3)).thenReturn(&quot;test2_1&quot;, &quot;test2_2&quot;);
    when(mockList.get(3)).thenReturn(&quot;test2_1&quot;).thenReturn(&quot;test2_2&quot;);
    System.out.println(mockList.get(3));    //test2_1
    System.out.println(mockList.get(3));    //test2_2

    // 为连续调用做测试桩（为同一个函数调用的不同的返回值或异常做测试桩）
    when(mockList.get(4)).thenReturn(&quot;test2&quot;).thenThrow(new RuntimeException());
    doReturn(&quot;test2&quot;).doThrow(new RuntimeException()).when(mockList).get(4);
    System.out.println(mockList.get(4));    //test2
    System.out.println(mockList.get(4));    //throw RuntimeException

    // 无打桩方法，返回默认值
    System.out.println(mockList.get(99));    //null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3、参数匹配器&lt;/h3&gt;

&lt;p&gt;• 参数匹配器使验证和测试桩变得更灵活；&lt;/p&gt;

&lt;p&gt;• 为了合理的使用复杂的参数匹配，使用equals()与anyX() 的匹配器会使得测试代码更简洁、简单。有时，会迫使你重构代码以使用equals()匹配或者实现equals()函数来帮助你进行测试；&lt;/p&gt;

&lt;p&gt;• 如果你使用参数匹配器,所有参数都必须由匹配器提供；&lt;/p&gt;

&lt;p&gt;• 支持自定义参数匹配器；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test3() {
    final Map mockMap = mock(Map.class);

    // 正常打桩测试
    when(mockMap.get(&quot;key&quot;)).thenReturn(&quot;value1&quot;);
    System.out.println(mockMap.get(&quot;key&quot;));     //value1

    // 为灵活起见，可使用参数匹配器
    when(mockMap.get(anyString())).thenReturn(&quot;value2&quot;);
    System.out.println(mockMap.get(anyString()));   //value2
    System.out.println(mockMap.get(&quot;test_key&quot;));    //value2
    System.out.println(mockMap.get(0)); //null

    // 多个入参时，要么都使用参数匹配器，要么都不使用，否则会异常
    when(mockMap.put(anyString(), anyInt())).thenReturn(&quot;value3&quot;);
    System.out.println(mockMap.put(&quot;key3&quot;, 3));     //value3
    System.out.println(mockMap.put(anyString(), anyInt()));     //value3
    System.out.println(mockMap.put(&quot;key3&quot;, anyInt()));    //异常

    // 行为验证时，也支持使用参数匹配器
    verify(mockMap, atLeastOnce()).get(anyString());
    verify(mockMap).put(anyString(), eq(3));

    // 自定义参数匹配器
    final ArgumentMatcher&amp;lt;ArgumentTestRequest&amp;gt; myArgumentMatcher = new ArgumentMatcher&amp;lt;ArgumentTestRequest&amp;gt;() {
        @Override
        public boolean matches(ArgumentTestRequest request) {
            return &quot;name&quot;.equals(request.getName()) || &quot;value&quot;.equals(request.getValue());
        }
    };
    // 自定义参数匹配器使用
    final ArgumentTestService mock = mock(ArgumentTestService.class);
    when(mock.argumentTestMethod(argThat(myArgumentMatcher))).thenReturn(&quot;success&quot;);
    doReturn(&quot;success&quot;).when(mock).argumentTestMethod(argThat(myArgumentMatcher));
    System.out.println(mock.argumentTestMethod(new ArgumentTestRequest(&quot;name&quot;, &quot;value&quot;)));  // success
    System.out.println(mock.argumentTestMethod(new ArgumentTestRequest()));     //null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4、执行顺序验证&lt;/h3&gt;

&lt;p&gt;• 验证执行顺序是非常灵活的-你不需要一个一个的验证所有交互,只需要验证你感兴趣的对象即可；&lt;/p&gt;

&lt;p&gt;• 你可以仅通过那些需要验证顺序的mock对象来创建InOrder对象；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test4() {
    // 验证同一个对象多个方法的执行顺序
    final List mockList = mock(List.class);
    mockList.add(&quot;first&quot;);
    mockList.add(&quot;second&quot;);
    final InOrder inOrder = inOrder(mockList);
    inOrder.verify(mockList).add(&quot;first&quot;);
    inOrder.verify(mockList).add(&quot;second&quot;);

    // 验证多个对象多个方法的执行顺序
    final List mockList1 = mock(List.class);
    final List mockList2 = mock(List.class);
    mockList1.get(0);
    mockList1.get(1);
    mockList2.get(0);
    mockList1.get(2);
    mockList2.get(1);
    final InOrder inOrder1 = inOrder(mockList1, mockList2);
    inOrder1.verify(mockList1).get(0);
    inOrder1.verify(mockList1).get(2);
    inOrder1.verify(mockList2).get(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;5、确保交互（interaction）操作不会执行在mock对象上&lt;/h3&gt;

&lt;p&gt;• 一些用户可能会在频繁地使用verifyNoMoreInteractions()，甚至在每个测试函数中都用。但是verifyNoMoreInteractions()并不建议在每个测试函数中都使用；&lt;/p&gt;

&lt;p&gt;• verifyNoMoreInteractions()在交互测试套件中只是一个便利的验证，它的作用是当你需要验证是否存在冗余调用时；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test5() {
    // 验证某个交互是否从未被执行
    final List mock = mock(List.class);
    mock.add(&quot;first&quot;);
    verify(mock, never()).add(&quot;test5&quot;);   //通过
    verify(mock, never()).add(&quot;first&quot;);  //异常

    // 验证mock对象没有交互过
    final List mock1 = mock(List.class);
    final List mock2 = mock(List.class);
    verifyZeroInteractions(mock1);  //通过
    verifyNoMoreInteractions(mock1, mock2); //通过
    verifyZeroInteractions(mock, mock2);  //异常

    // 注意：可能只想验证前面的逻辑，但是加上最后一行，会导致出现异常。建议使用方法层面的验证，如：never()；
    //      在验证是否有冗余调用的时候，可使用此种方式。如下：
    final List mockList = mock(List.class);
    mockList.add(&quot;one&quot;);
    mockList.add(&quot;two&quot;);
    verify(mockList).add(&quot;one&quot;);    // 通过
    verify(mockList, never()).get(0);    //通过
    verifyZeroInteractions(mockList);   //异常
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6、使用注解简化mock对象创建&lt;/h3&gt;

&lt;p&gt;注意！下面这句代码需要在运行测试函数之前被调用,一般放到测试类的基类或者test runner中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MockitoAnnotations.initMocks(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用内置的runner: MockitoJUnitRunner 或者一个rule : MockitoRule；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 代替 mock(ArgumentTestService.class) 创建mock对象；
@Mock
private ArgumentTestService argumentTestService;
// 若改注解修饰的对象有成员变量，@Mock定义的mock对象会被自动注入；
@InjectMocks
private MockitoAnnotationServiceImpl mockitoAnnotationService；

@Test
public void test6() {
    // 注意！下面这句代码需要在运行测试函数之前被调用,一般放到测试类的基类或者test runner中;
    MockitoAnnotations.initMocks(this);
    when(argumentTestService.argumentTestMethod(new ArgumentTestRequest())).thenReturn(&quot;success&quot;);
    System.out.println(argumentTestService.argumentTestMethod(new ArgumentTestRequest()));  //success
    System.out.println(mockitoAnnotationService.mockitoAnnotationTestMethod()); //null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;7、监控真实对象（部分mock）&lt;/h3&gt;

&lt;p&gt;• 可以为真实对象创建一个监控(spy)对象。当你使用这个spy对象时真实的对象也会也调用，除非它的函数被stub了;&lt;/p&gt;

&lt;p&gt;• 尽量少使用spy对象，使用时也需要小心形式，例如spy对象可以用来处理遗留代码;&lt;/p&gt;

&lt;p&gt;• stub语法中同样提供了部分mock的方法，可以调用真实的方法;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;完全mock：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上文讲的内容是完全mock，即创建的mock对象与真实对象无关，mock对象的方法默认都是基本的实现，返回基本类型。可基于接口、实现类创建mock对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;部分mock：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所谓部分mock，即创建的mock对象时基于真实对象的，mock对象的方法都是默认使用真实对象的方法，除非stub之后，才会以stub为准。基于实现类创建mock对象，否则在没有stub的情况下，调用真实方法时，会出现异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mockito并不会为真实对象代理函数调用，实际上它会拷贝真实对象。因此如果你保留了真实对象并且与之交互，不要期望从监控对象得到正确的结果。 当你在监控对象上调用一个没有被stub的函数时并不会调用真实对象的对应函数，你不会在真实对象上看到任何效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test7() {
    // stub部分mock（stub中使用真实调用）。注意：需要mock实现类，否则会有异常
    final StubTestService stubTestService = mock(StubTestServiceImpl.class);
    when(stubTestService.stubTestMethodA(&quot;paramA&quot;)).thenCallRealMethod();
    doCallRealMethod().when(stubTestService).stubTestMethodB();
    System.out.println(stubTestService.stubTestMethodA(&quot;paramA&quot;));  //stubTestMethodA is called, param = paramA
    System.out.println(stubTestService.stubTestMethodB());  //stubTestMethodB is called
    System.out.println(stubTestService.stubTestMethodC());  //null

    // spy部分mock
    final LinkedList&amp;lt;String&amp;gt; linkedList = new LinkedList();
    final LinkedList spy = spy(linkedList);
    spy.add(&quot;one&quot;);
    spy.add(&quot;two&quot;);
    doReturn(100).when(spy).size();
    when(spy.get(0)).thenReturn(&quot;one_test&quot;);
    System.out.println(spy.size()); //100
    System.out.println(spy.get(0)); //one_test
    System.out.println(spy.get(1)); //two

    // spy可以类比AOP。在spy中，由于默认是调用真实方法，所以第二种写法不等价于第一种写法，不推荐这种写法。
    doReturn(&quot;two_test&quot;).when(spy).get(2);
    when(spy.get(2)).thenReturn(&quot;two_test&quot;); //异常 java.lang.IndexOutOfBoundsException: Index: 2, Size: 2
    System.out.println(spy.get(2));   //two_test

    // spy对象只是真实对象的复制，真实对象的改变不会影响spy对象
    final List&amp;lt;String&amp;gt; arrayList = new ArrayList&amp;lt;&amp;gt;();
    final List&amp;lt;String&amp;gt; spy1 = spy(arrayList);
    spy1.add(0, &quot;one&quot;);
    System.out.println(spy1.get(0));    //one
    arrayList.add(0, &quot;list1&quot;);
    System.out.println(arrayList.get(0));   //list1
    System.out.println(spy1.get(0));    //one

    // 若对某个方法stub之后，又想调用真实的方法，可以使用reset(spy)
    final ArrayList&amp;lt;String&amp;gt; arrayList1 = new ArrayList&amp;lt;&amp;gt;();
    final ArrayList&amp;lt;String&amp;gt; spy2 = spy(arrayList1);
    doReturn(100).when(spy2).size();
    System.out.println(spy2.size());    //100
    reset(spy2);
    System.out.println(spy2.size());    //0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;8、&lt;a href=&quot;https://my.oschina.net/mock&quot;&gt;@Mock&lt;/a&gt; 和 @Spy的使用&lt;/h3&gt;

&lt;p&gt;• &lt;a href=&quot;https://my.oschina.net/mock&quot;&gt;@Mock&lt;/a&gt; 等价于 Mockito.mock(Object.class);&lt;/p&gt;

&lt;p&gt;• &lt;a href=&quot;https://my.oschina.net/spy1026&quot;&gt;@Spy&lt;/a&gt; 等价于 Mockito.spy(obj);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;区分是mock对象还是spy对象：
Mockito.mockingDetails(someObject).isMock();
Mockito.mockingDetails(someObject).isSpy();

@Mock
private StubTestService stubTestService;
@Spy
private StubTestServiceImpl stubTestServiceImpl;
@Spy
private StubTestService stubTestServiceImpl1 = new StubTestServiceImpl();
@Test
public void test8() {
    MockitoAnnotations.initMocks(this);
    // mock对象返回默认
    System.out.println(stubTestService.stubTestMethodB());  //null
    // spy对象调用真实方法
    System.out.println(stubTestServiceImpl.stubTestMethodC());  //stubTestMethodC is called
    System.out.println(stubTestServiceImpl1.stubTestMethodA(&quot;spy&quot;));  //stubTestMethodA is called, param = spy

    // 区分是mock对象还是spy对象
    System.out.println(mockingDetails(stubTestService).isMock());   //true
    System.out.println(mockingDetails(stubTestService).isSpy());    //false
    System.out.println(mockingDetails(stubTestServiceImpl).isSpy());    //true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;9、ArgumentCaptor（参数捕获器）捕获方法参数进行验证。（可代替参数匹配器使用）&lt;/h3&gt;

&lt;p&gt;• 在某些场景中，不光要对方法的返回值和调用进行验证，同时需要验证一系列交互后所传入方法的参数。那么我们可以用参数捕获器来捕获传入方法的参数进行验证，看它是否符合我们的要求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ArgumentCaptor介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过ArgumentCaptor对象的forClass(Class&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ArgumentCaptor的Api&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;argument.capture() 捕获方法参数&lt;/p&gt;

&lt;p&gt;argument.getValue() 获取方法参数值，如果方法进行了多次调用，它将返回最后一个参数值&lt;/p&gt;

&lt;p&gt;argument.getAllValues() 方法进行多次调用后，返回多个参数值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test9() {
    List mock = mock(List.class);
    List mock1 = mock(List.class);
    mock.add(&quot;John&quot;);
    mock1.add(&quot;Brian&quot;);
    mock1.add(&quot;Jim&quot;);
    // 获取方法参数
    ArgumentCaptor argument = ArgumentCaptor.forClass(String.class);
    verify(mock).add(argument.capture());
    System.out.println(argument.getValue());    //John

    // 多次调用获取最后一次
    ArgumentCaptor argument1 = ArgumentCaptor.forClass(String.class);
    verify(mock1, times(2)).add(argument1.capture());
    System.out.println(argument1.getValue());    //Jim

    // 获取所有调用参数
    System.out.println(argument1.getAllValues());    //[Brian, Jim]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;10、简化 ArgumentCaptor 的创建&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@Mock
private List&amp;lt;String&amp;gt; captorList;
@Captor
private ArgumentCaptor&amp;lt;String&amp;gt; argumentCaptor;
@Test
public void test10() {
    MockitoAnnotations.initMocks(this);
    captorList.add(&quot;cap1&quot;);
    captorList.add(&quot;cap2&quot;);
    System.out.println(captorList.size());
    verify(captorList, atLeastOnce()).add(argumentCaptor.capture());
    System.out.println(argumentCaptor.getAllValues());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;11、高级特性：自定义验证失败信息&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test11() {
    final ArrayList arrayList = mock(ArrayList.class);
    arrayList.add(&quot;one&quot;);
    arrayList.add(&quot;two&quot;);

    verify(arrayList, description(&quot;size()没有调用&quot;)).size();
    // org.mockito.exceptions.base.MockitoAssertionError: size()没有调用

    verify(arrayList, timeout(200).times(3).description(&quot;验证失败&quot;)).add(anyString());
    //org.mockito.exceptions.base.MockitoAssertionError: 验证失败
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;12、高级特性：修改没有测试桩的调用的默认返回值&lt;/h3&gt;

&lt;p&gt;• 可以指定策略来创建mock对象的返回值。这是一个高级特性，通常来说，你不需要写这样的测试；&lt;/p&gt;

&lt;p&gt;• 它对于遗留系统来说是很有用处的。当你不需要为函数调用打桩时你可以指定一个默认的answer；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test12(){
    // 创建mock对象、使用默认返回
    final ArrayList mockList = mock(ArrayList.class);
    System.out.println(mockList.get(0));    //null

    // 这个实现首先尝试全局配置,如果没有全局配置就会使用默认的回答,它返回0,空集合,null,等等。
    // 参考返回配置：ReturnsEmptyValues
    mock(ArrayList.class, Answers.RETURNS_DEFAULTS);

    // ReturnsSmartNulls首先尝试返回普通值(0,空集合,空字符串,等等)然后它试图返回SmartNull。
    // 如果最终返回对象，那么会简单返回null。一般用在处理遗留代码。
    // 参考返回配置：ReturnsMoreEmptyValues
    mock(ArrayList.class, Answers.RETURNS_SMART_NULLS);

    // 未stub的方法，会调用真实方法。
    //    注1:存根部分模拟使用时(mock.getSomething ()) .thenReturn (fakeValue)语法将调用的方法。对于部分模拟推荐使用doReturn语法。
    //    注2:如果模拟是序列化反序列化,那么这个Answer将无法理解泛型的元数据。
    mock(ArrayList.class, Answers.CALLS_REAL_METHODS);

    // 深度stub，用于嵌套对象的mock。参考：https://www.cnblogs.com/Ming8006/p/6297333.html
    mock(ArrayList.class, Answers.RETURNS_DEEP_STUBS);

    // ReturnsMocks首先尝试返回普通值(0,空集合,空字符串,等等)然后它试图返回mock。
    // 如果返回类型不能mocked(例如是final)然后返回null。
    mock(ArrayList.class, Answers.RETURNS_MOCKS);

    //  mock对象的方法调用后，可以返回自己（类似builder模式）
    mock(ArrayList.class, Answers.RETURNS_SELF);

    // 自定义返回
    final Answer&amp;lt;String&amp;gt; answer = new Answer&amp;lt;String&amp;gt;() {
        @Override
        public String answer(InvocationOnMock invocation) throws Throwable {
            return &quot;test_answer&quot;;
        }
    };
    final ArrayList mockList1 = mock(ArrayList.class, answer);
    System.out.println(mockList1.get(0));   //test_answer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;三、学习了这么多，牛刀小试一下！&lt;/h2&gt;

&lt;p&gt;测试实体类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Data
public class User {

    /**
     * 姓名，登录密码
     */

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;持久层DAO&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface UserDao {

    /**
     * 根据name查找user
     * @param name
     * @return
     */
    User getUserByName(String name);

    /**
     * 保存user
     * @param user
     * @return
     */
    Integer saveUser(User user);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;业务层Service接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface UserService {

    /**
     * 根据name查找user
     * @param name
     * @return
     */
    User getUserByName(String name);

    /**
     * 保存user
     * @param user
     * @return
     */
    Integer saveUser(User user);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;业务层Serive实现类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Service
public class UserServiceImpl implements UserService {

    //userDao
    @Autowired
    private UserDao userDao;

    /**
     * 根据name查找user
     * @param name
     * @return
     */
    @Override
    public User getUserByName(String name) {
        try {
            return userDao.getUserByName(name);
        } catch (Exception e) {
            throw new RuntimeException(&quot;查询user异常&quot;);
        }
    }

    /**
     * 保存user
     * @param user
     * @return
     */
    @Override
    public Integer saveUser(User user) {
        if (userDao.getUserByName(user.getName()) != null) {
            throw new RuntimeException(&quot;用户名已存在&quot;);
        }
        try {
            return userDao.saveUser(user);
        } catch (Exception e) {
            throw new RuntimeException(&quot;保存用户异常&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们的Service写好了，想要单元测试一下，但是Dao是其他人开发的，目前还没有写好，那我们如何测试呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class UserServiceTest {

    /**
     * Mock测试：根据name查询user
     */
    @Test
    public void getUserByNameTest() {
        // mock对象
        final UserDao userDao = mock(UserDao.class);
        final UserServiceImpl userService = new UserServiceImpl();
        userService.setUserDao(userDao);

        // stub调用
        final User user = new User();
        user.setName(&quot;admin&quot;);
        user.setPassword(&quot;pass&quot;);
        when(userDao.getUserByName(&quot;admin&quot;)).thenReturn(user);

        // 执行待测试方法
        final User user1 = userService.getUserByName(&quot;admin&quot;);
        System.out.println(&quot;查询结果：&quot; + JacksonUtil.obj2json(user1));  //查询结果：{&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;pass&quot;}

        // 验证mock对象交互
        verify(userDao).getUserByName(anyString());

        // 验证查询结果
        Assert.assertNotNull(&quot;查询结果为空！&quot;, user1);
        Assert.assertEquals(&quot;查询结果错误！&quot;, &quot;admin&quot;, user1.getName());
    }


    /**
     * Mock测试：保存user
     */
    @Mock
    private UserDao userDao;
    @InjectMocks
    private UserServiceImpl userService;
    @Test
    public void saveUserTest() throws Exception{
        // 执行注解初始化
        MockitoAnnotations.initMocks(this);

        // mock对象stub操作
        final User user = new User();
        user.setName(&quot;admin&quot;);
        user.setPassword(&quot;pass&quot;);
        when(userDao.getUserByName(&quot;admin&quot;)).thenReturn(user).thenReturn(null);
        when(userDao.saveUser(any(User.class))).thenReturn(1);

        // 验证用户名重复的情况
        try {
            userService.saveUser(user);
            throw new Exception();  //走到这里说明验证失败
        } catch (RuntimeException e) {
            System.out.println(&quot;重复用户名保存失败-测试通过&quot;);   //重复用户名保存失败-测试通过
        }
        verify(userDao).getUserByName(&quot;admin&quot;);

        // 验证正常保存的情况
        user.setName(&quot;user&quot;);
        final Integer integer = userService.saveUser(user);
        System.out.println(&quot;保存结果：&quot; + integer);  //保存结果：1
        Assert.assertEquals(&quot;保存失败！&quot;, 1, integer.longValue());

        verify(userDao).saveUser(any(User.class));
        verify(userDao, times(2)).getUserByName(anyString());
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据以上代码我们可以知道，当我们的待测类开发完成而依赖的类的实现还没有开发完成。此时，我们就可以用到我们的Mock测试，模拟我们依赖类的返回值，使我们的待测类与依赖类解耦。这样，我们就可以对我们的待测类进行单元测了。&lt;/p&gt;

&lt;h2&gt;四、参考文档及进一步学习～&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Mockito英文版javadoc：https://javadoc.io/static/org.mockito/mockito-core/3.3.3/org/mockito/Mockito.html
Mockito中文文档(部分)：https://blog.csdn.net/bboyfeiyu/article/details/52127551#35

Mockito使用教程：https://www.cnblogs.com/Ming8006/p/6297333.html
参数捕获器使用：https://www.journaldev.com/21892/mockito-argumentcaptor-captor-annotation
利用ArgumentCaptor（参数捕获器）捕获方法参数进行验证：https://www.iteye.com/blog/hotdog-916364
改变mock返回值：https://www.huangyunkun.com/2014/10/25/mockito-deep-stub-with-enum/
五分钟了解Mockito：https://www.iteye.com/blog/liuzhijun-1512780
使用Mockito进行单元测试：https://www.iteye.com/blog/qiuguo0205-1443344
JUnit + Mockito 单元测试：https://blog.csdn.net/zhangxin09/article/details/42422643
Mockito中@Mock与@InjectMock：https://www.cnblogs.com/langren1992/p/9681600.html
mockito中两种部分mock的实现，spy、callRealMethod：https://www.cnblogs.com/softidea/p/4204389.html
Mockito 中被 Mocked 的对象属性及方法的默认值：https://www.cnblogs.com/fnlingnzb-learner/p/10635250.html
单元测试工具之Mockito：https://blog.csdn.net/qq_32140971/article/details/90598454
引入Mockito测试用@Spy和@Mock：https://blog.csdn.net/message_lx/article/details/83308114
Mockito初探(含实例)：https://www.iteye.com/blog/sgq0085-2031319
测试覆盖率统计：https://blog.csdn.net/lvyuan1234/article/details/82836052?depth_1-utm_source=distribute.pc_relevant.none-task&amp;amp;utm_source=distribute.pc_relevant.none-task
测试覆盖率无法统计解决：https://blog.csdn.net/zhanglei082319/article/details/81536398
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4a172bbe5d7a4133cca3ddf0289ad0e2</guid>
<title>美团面试：MySQL 自增主键一定是连续的吗？</title>
<link>https://toutiao.io/k/8favlia</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7620370370370371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapfQQZJOKziaehj1pZzNHTicFkDKBMhTBzjZjys2GHM2nWd3LWt5SA7y0A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;图解学习网站：&lt;/span&gt;&lt;span&gt;xiaolincoding.com&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小林。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;美团问数据库比较多，今天分享一道美团的面试题：&lt;strong&gt;MySQL 的自增主键一定是连续的吗？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9014084507042254&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcUgshEvNSknMBvBBn04t90v42ftpY5PSfCXnKpGicbaaiawRvxiaPcff0z66lw2RnbXIbDbC3WwutNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;284&quot;/&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，自增主键可以让聚集索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但实际上，MySQL 的自增主键并不能保证一定是连续递增的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面举个例子来看下，如下所示创建一张表：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3469945355191257&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSsBiaN3ibx0tWhhbpjyQo8T8XbxLggR4GtWsaNzACbK0kWqNylfoorLHQ/640?wx_fmt=png&quot; data-w=&quot;732&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自增值保存在哪里？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;insert into test_pk values(null, 1, 1)&lt;/code&gt; 插入一行数据，再执行 &lt;code&gt;show create table&lt;/code&gt; 命令来看一下表的结构定义：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5522222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlShzcyORDsddElUwICr30F21IAjOAxMOO0bNCL1rtK8hxmnFaicH0XGeA/640?wx_fmt=png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述表的结构定义存放在后缀名为 &lt;code&gt;.frm&lt;/code&gt; 的本地文件中，在 MySQL 安装目录下的 data 文件夹下可以找到这个 &lt;code&gt;.frm&lt;/code&gt; 文件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5231481481481481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlScTWqJCIkj1IW8XVWiaAWRyjVXPIFX9ma5rmvqp5QwYEO2fRH6beMx7w/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述表结构可以看到，表定义里面出现了一个 &lt;code&gt;AUTO_INCREMENT=2&lt;/code&gt;，表示下一次插入数据时，如果需要自动生成自增值，会生成 id = 2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但需要注意的是，自增值并不会保存在这个表结构也就是 &lt;code&gt;.frm&lt;/code&gt; 文件中，不同的引擎对于自增值的保存策略不同：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）MyISAM 引擎的自增值保存在数据文件中&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）InnoDB 引擎的自增值，其实是保存在了内存里，并没有持久化。第一次打开表的时候，都会去找自增值的最大值 &lt;code&gt;max(id)&lt;/code&gt;，然后将 &lt;code&gt;max(id)+1&lt;/code&gt; 作为这个表当前的自增值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子：我们现在表里当前数据行里最大的 id 是 1，AUTO_INCREMENT=2，对吧。这时候，我们删除 id=1 的行，AUTO_INCREMENT 还是 2。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6602972399150743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlS0HgyyZPQHnFS8bF8eIA1yB2keNPXibBF2TrVkv5DsXiccd19k2ABictPQ/640?wx_fmt=png&quot; data-w=&quot;942&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果马上重启 MySQL 实例，重启后这个表的 AUTO_INCREMENT 就会变成 1。﻿也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4412811387900356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlScGQLqBeF4EwNW2n1ic8GVrn1MzcDeDpR7OL5bGsic2MCbmiaGFKpwTEow/640?wx_fmt=png&quot; data-w=&quot;562&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3287037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSPcnibHJkomqQslkzGBG2wAQTwWdXfbViaDRcm0jUqlSOrcT9UkRqlkVw/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上，是在我本地 MySQL 5.x 版本的实验，实际上，到了 MySQL 8.0 版本后，自增值的变更记录被放在了 redo log 中，提供了自增值持久化的能力，也就是实现了“如果发生重启，表的自增值可以根据 redo  log 恢复为 MySQL 重启前的值”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说对于上面这个例子来说，重启实例后这个表的 AUTO_INCREMENT 仍然是 2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了 MySQL 自增值到底保存在哪里以后，我们再来看看自增值的修改机制，并以此引出第一种自增值不连续的场景。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自增值不连续场景 1&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设某次要插入的值是 &lt;code&gt;insert_num&lt;/code&gt;，当前的自增值是 &lt;code&gt;autoIncrement_num&lt;/code&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;insert_num &amp;lt; autoIncrement_num&lt;/code&gt;，那么这个表的自增值不变&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;insert_num &amp;gt;= autoIncrement_num&lt;/code&gt;，就需要把当前自增值修改为新的自增值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，如果插入的 id 是 100，当前的自增值是 90，&lt;code&gt;insert_num &amp;gt;= autoIncrement_num&lt;/code&gt;，那么自增值就会被修改为新的自增值即 101&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一定是这样吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非也~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解过分布式 id 的小伙伴一定知道，为了避免两个库生成的主键发生冲突，我们可以让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个奇数偶数其实是通过 &lt;code&gt;auto_increment_offset&lt;/code&gt; 和 &lt;code&gt;auto_increment_increment&lt;/code&gt; 这两个参数来决定的，这俩分别用来表示自增的初始值和步长，默认值都是 1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，上面的例子中生成新的自增值的步骤实际是这样的：从 &lt;code&gt;auto_increment_offset&lt;/code&gt; 开始，以 &lt;code&gt;auto_increment_increment&lt;/code&gt; 为步长，持续叠加，直到找到第一个大于 100  的值，作为新的自增值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，这种情况下，自增值可能会是 102，103 等等之类的，就会导致不连续的主键 id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更遗憾的是，即使在自增初始值和步长这两个参数都设置为 1 的时候，自增主键 id 也不一定能保证主键是连续的&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自增值不连续场景 2&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，我们现在往表里插入一条 (null,1,1) 的记录，生成的主键是 1，AUTO_INCREMENT= 2，对吧&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSsgKOh3PPxE0GpdWWu4ce6M4REWM9E2z245FDUBh5CGYnQibUIM06SSQ/640?wx_fmt=png&quot; data-ratio=&quot;0.6874279123414071&quot; data-w=&quot;867&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我再执行一条插入 &lt;code&gt;(null,1,1)&lt;/code&gt; 的命令，很显然会报错 &lt;code&gt;Duplicate entry&lt;/code&gt;，因为我们设置了一个唯一索引字段 &lt;code&gt;a&lt;/code&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSMic0AoqHE1gWOvO3rvsibyZUazjiaen17HQnn0rgnUM3FDc10P9eytwjQ/640?wx_fmt=png&quot; data-ratio=&quot;0.5705824284304047&quot; data-w=&quot;1013&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，你会惊奇的发现，虽然插入失败了，但自增值仍然从 2 增加到了 3！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是为啥？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来分析下这个 insert 语句的执行流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;执行器调用 InnoDB 引擎接口准备插入一行记录 (null,1,1);&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB 发现用户没有指定自增 id 的值，则获取表 &lt;code&gt;test_pk&lt;/code&gt; 当前的自增值 2；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将传入的记录改成 (2,1,1);&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将表的自增值改成 3；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;继续执行插入数据操作，由于已经存在 a=1 的记录，所以报 Duplicate key error，语句返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，自增值修改的这个操作，是在真正执行插入数据的操作之前。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个语句真正执行的时候，因为碰到唯一键 a 冲突，所以 id = 2 这一行并没有插入成功，但也没有将自增值再改回去。所以，在这之后，再插入新的数据行时，拿到的自增 id 就是 3。也就是说，出现了自增主键不连续的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们已经罗列了两种自增主键不连续的情况：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;自增初始值和自增步长设置不为 1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;唯一键冲突&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，事务回滚也会导致这种情况&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自增值不连续场景 3&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在表里有一行 &lt;code&gt;(1,1,1)&lt;/code&gt; 的记录，AUTO_INCREMENT = 3：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6048951048951049&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSFjZ40sUdKXibmLhFxfXJoU5ic85QcTUhrHBlVGkqu7jUorksdy5HWAEQ/640?wx_fmt=png&quot; data-w=&quot;858&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先插入一行数据 &lt;code&gt;(null, 2, 2)&lt;/code&gt;，也就是 (3, 2, 2) 嘛，并且 AUTO_INCREMENT 变为 4：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6144455747711088&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSZYtkzeS6Ric9s0TSCsUrhCUBZ5zSwtP8LPN8HaDKLgVicU7ZVZkQlNlA/640?wx_fmt=png&quot; data-w=&quot;983&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再去执行这样一段 SQL：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36714285714285716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSPkib5TowVXBmW7Sn6xLyEU5qMBjebODMf9VyIGhK5ONz32x2MY5ZibDg/640?wx_fmt=png&quot; data-w=&quot;700&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们插入了一条 (null, 3, 3) 记录，但是使用 rollback 进行回滚了，所以数据库中是没有这条记录的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6041666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSy5lJTyl2e0aZ4nDXbJ9opGPz53rn2DEVzsxCExMTpwZwmov8Y7fSdA/640?wx_fmt=png&quot; data-w=&quot;432&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种事务回滚的情况下，自增值并没有同样发生回滚！如下图所示，自增值仍然固执地从 4 增加到了 5：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5811870100783875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSTT1fZlfeSFiahUAAA6JpW9MDC9KOxPcaYjYDDkrjoGOrtQTbsqCyoFw/640?wx_fmt=png&quot; data-w=&quot;893&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这时候我们再去插入一条数据（null, 3, 3）的时候，主键 id 就会被自动赋为 &lt;code&gt;5&lt;/code&gt; 了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42035398230088494&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSSShlKlck7uekokHiblibt0bPATQwNl5v3NFjVYK1FjKLSPWJaXtGx8bQ/640?wx_fmt=png&quot; data-w=&quot;904&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，为什么在出现唯一键冲突或者回滚的时候，MySQL 没有把表的自增值改回去呢？回退回去的话不就不会发生自增 id 不连续了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，这么做的主要原因是为了提高性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接用反证法来验证：假设 MySQL 在事务回滚的时候会把自增值改回去，会发生什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在有两个并行执行的事务 A 和 B，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请，对吧。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;假设事务 A 申请到了 id = 1， 事务 B 申请到 id=2，那么这时候表 t 的自增值是3，之后继续执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务 B 正确提交了，但事务 A 出现了唯一键冲突，也就是 id = 1 的那行记录插入失败了，那如果允许事务 A 把自增 id 回退，也就是把表的当前自增值改回 1，那么就会出现这样的情况：表里面已经有 id = 2 的行，而当前的自增 id 值是 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接下来，继续执行的其他事务就会申请到 id=2。这时，就会出现插入语句报错“主键冲突”。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9227906976744186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSOYOApB3cGAYCCP6Rx9AicTbUPecmQhObzhsd16EtkiadrDFYH9p0COoQ/640?wx_fmt=png&quot; data-w=&quot;1075&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而为了解决这个主键冲突，有两种方法：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每次申请 id 之前，先判断表里面是否已经存在这个 id，如果存在，就跳过这个 id&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很显然，上述两个方法的成本都比较高，会导致性能问题。而究其原因呢，是我们假设的这个 “允许自增 id 回退”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上，已经分析了三种自增值不连续的场景，还有第四种场景：批量插入数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自增值不连续场景 4&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;语句执行过程中，第一次申请自增 id，会分配 1 个；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，这里说的批量插入数据，不是在普通的 insert 语句里面包含多个 value 值！！！，因为这类语句在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于 &lt;code&gt;insert … select&lt;/code&gt;、replace … select 和 load data 这种类型的语句来说，MySQL 并不知道到底需要申请多少 id，所以就采用了这种批量申请的策略，毕竟一个一个申请的话实在太慢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，假设我们现在这个表有下面这些数据：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6483931947069943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSbD7VllcMdyDCv7u5uibFE8ap8oeMwAJEIdgBkgDuwJduQNBX0zs1ZTA/640?wx_fmt=png&quot; data-w=&quot;529&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建一个和当前表 &lt;code&gt;test_pk&lt;/code&gt; 有相同结构定义的表 &lt;code&gt;test_pk2&lt;/code&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4083333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSeBjnYFW3cvRcK1FYeCqgicPBdkvQGnbPSgvT86wAlgCFDBptIqEfYQA/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后使用 &lt;code&gt;insert...select&lt;/code&gt; 往 &lt;code&gt;teset_pk2&lt;/code&gt; 表中批量插入数据：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47689075630252103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSH2trqM0ibx9lc9E5ibicJWY9P4zdIdhRibYVhRfAdGg75k2gIoKasaQpEA/640?wx_fmt=png&quot; data-w=&quot;952&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，成功导入了数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看下 &lt;code&gt;test_pk2&lt;/code&gt; 的自增值是多少：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3509259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSoibW63prO8Gice263E406BO5yLPksw8s2PO6KPAiaCdMM4KxaicoIvFGZw/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上分析，是 8 而不是 6&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体来说，insert…select 实际上往表中插入了 5 行数据 （1 1）（2 2）（3 3）（4 4）（5 5）。但是，这五行数据是分三次申请的自增 id，结合批量申请策略，每次申请到的自增 id 个数都是上一次的两倍，所以：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一次申请到了一个 id：id=1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二次被分配了两个 id：id=2 和 id=3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三次被分配到了 4 个 id：id=4、id = 5、id = 6、id=7&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这条语句实际只用上了 5 个 id，所以 id=6 和 id=7 就被浪费掉了。之后，再执行 &lt;code&gt;insert into test_pk2 values(null,6,6)&lt;/code&gt;，实际上插入的数据就是（8,6,6)：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5954198473282443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSWJhQcdACvDcD18fMz5PhdUuwp3RkTILHJkVpW2OcX6icMn1hcEvnlqA/640?wx_fmt=png&quot; data-w=&quot;786&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结下自增值不连续的四个场景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;自增初始值和自增步长设置不为 1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;唯一键冲突&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务回滚&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;批量插入（如 &lt;code&gt;insert...select&lt;/code&gt; 语句）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;历史好文：&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247508002&amp;amp;idx=1&amp;amp;sn=9a59db214082ca8810dcdcb4af43c17c&amp;amp;chksm=f98de488cefa6d9ef82f7b17e5869cc1cb36a662d41d796ee85b84a9d5ae589bbd704b3a5b0d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;告别 MVCC !&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;告别 MVCC !&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247520893&amp;amp;idx=1&amp;amp;sn=7152fa58a1d03b48cfe8ef00e90aa2ea&amp;amp;chksm=f98dd6d7cefa5fc13877a1c99dcb06d03f51cbbc9afee75d0cd87f4847566746fcced9948e54&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团三面：一直追问我， MySQL 幻读被彻底解决了吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团三面：一直追问我， MySQL 幻读被彻底解决了吗？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247520657&amp;amp;idx=2&amp;amp;sn=53805d2f47b87a96db21ae13a08dac18&amp;amp;chksm=f98dd53bcefa5c2dfab473ba0087f470da66b19c32aae853390e876850c108a7dcbf78971d44&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团二面：TCP 四次挥手，可以变成三次吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团二面：TCP 四次挥手，可以变成三次吗？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247521692&amp;amp;idx=2&amp;amp;sn=433b88348f214fc2608b0d3d1edc1d94&amp;amp;chksm=f98dd136cefa5820462349f51e90650db0dfb0a1bfd070dd7d608c273790c4c8f29779034aa5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MySQL 全局锁、表级锁、行级锁，你搞清楚了吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;MySQL 全局锁、表级锁、行级锁，你搞清楚了吗？&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247523402&amp;amp;idx=2&amp;amp;sn=fc8688d2fdd8a4b458dc5b04a6719948&amp;amp;chksm=f98dd8e0cefa51f6016356a5e6cbdc07cbdc3991c1ea1d3b9201fb7c836af4e30b43d6aac013&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;面试官：MySQL 中 varchar(n) 中 n 最大取值为多少？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;面试官：MySQL 中 varchar(n) 中 n 最大取值为多少？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzUxODAzNDg4NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfTwwjfpJhXgIrYMgtVcLhQQBVb02clZfKicbxaibSTNJqXe9Zu8ydiavZKJWJAIhKcnD9hBuKU92JZQ/0?wx_fmt=png&quot; data-nickname=&quot;小林coding&quot; data-alias=&quot;CodingLin&quot; data-signature=&quot;专注图解计算机基础，让天下没有难懂的八股文！刷题网站：xiaolincoding.com&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9a8561532f158007f317f29f084b547c</guid>
<title>Spring Boot 整合 ElasticSearch 案例教程</title>
<link>https://toutiao.io/k/fig8r7w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-entry post-inner-html hairline&quot; itemprop=&quot;articleBody&quot;&gt;
            &lt;h2 id=&quot;一、ES-的使用场景&quot;&gt;&lt;a href=&quot;#一、ES-的使用场景&quot; class=&quot;headerlink&quot; title=&quot;一、ES 的使用场景&quot;/&gt;一、ES 的使用场景&lt;/h2&gt;&lt;p&gt;简单说，ElasticSearch（简称 ES）是搜索引擎，是结构化数据的分布式搜索引擎。&lt;br/&gt;我详细的介绍了如何安装，初步使用了 IK 分词器。这里，我主要讲下 SpringBoot 工程中如何使用 ElasticSearch。&lt;/p&gt;
&lt;p&gt;运行环境：JDK 7 或 8，Maven 3.0+&lt;/p&gt;
&lt;p&gt;技术栈：SpringBoot 1.5+，ElasticSearch 2.3.2&lt;/p&gt;
&lt;span id=&quot;more&quot;/&gt;

&lt;p&gt;ES 的使用场景大致分为两块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;全文检索。加上分词（IK 是其中一个）、拼音插件等可以成为强大的全文搜索引擎。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志统计分析。可以实时动态分析海量日志数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;二、运行-springboot-elasticsearch-工程&quot;&gt;&lt;a href=&quot;#二、运行-springboot-elasticsearch-工程&quot; class=&quot;headerlink&quot; title=&quot;二、运行 springboot-elasticsearch 工程&quot;/&gt;二、运行 springboot-elasticsearch 工程&lt;/h2&gt;&lt;p&gt;注意的是这里使用的是 ElasticSearch 2.3.2。是因为版本对应关系 ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Spring Boot Version (x)    Spring Data Elasticsearch Version (y)    Elasticsearch Version (z)
x &amp;lt;= 1.3.5    y &amp;lt;= 1.3.4    z &amp;lt;= 1.7.2*
x &amp;gt;= 1.4.x    2.0.0 &amp;lt;=y &amp;lt; 5.0.0**    2.0.0 &amp;lt;= z &amp;lt; 5.0.0**
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;只需要你修改下对应的 pom 文件版本号&lt;/li&gt;
&lt;li&gt;下一个 ES 的版本会有重大的更新&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;git clone 下载工程 springboot-elasticsearch ，项目地址见 GitHub - &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/JeffLi1993/springboot-learning-example&quot;&gt;https://github.com/JeffLi1993/springboot-learning-example&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;1-后台起守护线程启动-Elasticsearch&quot;&gt;&lt;a href=&quot;#1-后台起守护线程启动-Elasticsearch&quot; class=&quot;headerlink&quot; title=&quot;1. 后台起守护线程启动 Elasticsearch&quot;/&gt;1. 后台起守护线程启动 Elasticsearch&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;cd elasticsearch-2.3.2/
./bin/elasticsearch -d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面开始运行工程步骤（Quick Start）：&lt;/p&gt;
&lt;h3 id=&quot;2-项目结构介绍&quot;&gt;&lt;a href=&quot;#2-项目结构介绍&quot; class=&quot;headerlink&quot; title=&quot;2. 项目结构介绍&quot;/&gt;2. 项目结构介绍&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;org.spring.springboot.controller - Controller 层
org.spring.springboot.repository - ES 数据操作层
org.spring.springboot.domain - 实体类
org.spring.springboot.service - ES 业务逻辑层
Application - 应用启动类
application.properties - 应用配置文件，应用启动会自动读取配置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地启动的 ES ，就不需要改配置文件了。如果连测试 ES 服务地址，需要修改相应配置&lt;/p&gt;
&lt;h3 id=&quot;3-编译工程&quot;&gt;&lt;a href=&quot;#3-编译工程&quot; class=&quot;headerlink&quot; title=&quot;3.编译工程&quot;/&gt;3.编译工程&lt;/h3&gt;&lt;p&gt;在项目根目录 springboot-elasticsearch，运行 maven 指令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn clean install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.运行工程&lt;/p&gt;
&lt;p&gt;右键运行 Application 应用启动类（位置：/springboot-learning-example/springboot-elasticsearch/src/main/java/org/spring/springboot/Application.java）的 main 函数，这样就成功启动了 springboot-elasticsearch 案例。&lt;/p&gt;
&lt;p&gt;用 Postman 工具新增两个城市&lt;/p&gt;
&lt;p&gt;新增城市信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST http://127.0.0.1:8080/api/city
{
&quot;id&quot;:&quot;1&quot;,
&quot;provinceid&quot;:&quot;1&quot;,
&quot;cityname&quot;:&quot;温岭&quot;,
&quot;description&quot;:&quot;温岭是个好城市&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;POST http://127.0.0.1:8080/api/city
{
&quot;id&quot;:&quot;2&quot;,
&quot;provinceid&quot;:&quot;2&quot;,
&quot;cityname&quot;:&quot;温州&quot;,
&quot;description&quot;:&quot;温州是个热城市&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以打开 ES 可视化工具 head 插件：&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;http://localhost:9200/_plugin/head/%EF%BC%9A&quot;&gt;http://localhost:9200/_plugin/head/：&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在「数据浏览」tab，可以查阅到 ES 中数据是否被插入，插入后的数据格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;_index&quot;: &quot;cityindex&quot;,
    &quot;_type&quot;: &quot;city&quot;,
    &quot;_id&quot;: &quot;1&quot;,
    &quot;_version&quot;: 1,
    &quot;_score&quot;: 1,
    &quot;_source&quot;: {
        &quot;id&quot;: 1,
        &quot;provinceid&quot;: 1,
        &quot;cityname&quot;: &quot;温岭&quot;,
        &quot;description&quot;: &quot;温岭是个好城市&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面验证下权重分查询搜索接口的实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET http://localhost:8080/api/city/search?pageNumber=0&amp;amp;pageSize=10&amp;amp;searchContent=温岭
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据是会出现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
    {
    &quot;id&quot;: 1,
    &quot;provinceid&quot;: 1,
    &quot;cityname&quot;: &quot;温岭&quot;,
    &quot;description&quot;: &quot;温岭是个好城市&quot;
    },
    {
    &quot;id&quot;: 2,
    &quot;provinceid&quot;: 2,
    &quot;cityname&quot;: &quot;温州&quot;,
    &quot;description&quot;: &quot;温州是个热城市&quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从启动后台 Console 可以看出，打印出来对应的 DSL 语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; {
  &quot;function_score&quot; : {
    &quot;functions&quot; : [ {
      &quot;filter&quot; : {
        &quot;bool&quot; : {
          &quot;should&quot; : {
            &quot;match&quot; : {
              &quot;cityname&quot; : {
                &quot;query&quot; : &quot;温岭&quot;,
                &quot;type&quot; : &quot;boolean&quot;
              }
            }
          }
        }
      },
      &quot;weight&quot; : 1000.0
    }, {
      &quot;filter&quot; : {
        &quot;bool&quot; : {
          &quot;should&quot; : {
            &quot;match&quot; : {
              &quot;description&quot; : {
                &quot;query&quot; : &quot;温岭&quot;,
                &quot;type&quot; : &quot;boolean&quot;
              }
            }
          }
        }
      },
      &quot;weight&quot; : 100.0
    } ]
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么会出现 温州 城市呢？因为 function score query 权重分查询，无相关的数据默认分值为 1。如果想除去，设置一个 setMinScore 分值即可。&lt;/p&gt;
&lt;h3 id=&quot;三、springboot-elasticsearch-工程代码详解&quot;&gt;&lt;a href=&quot;#三、springboot-elasticsearch-工程代码详解&quot; class=&quot;headerlink&quot; title=&quot;三、springboot-elasticsearch 工程代码详解&quot;/&gt;三、springboot-elasticsearch 工程代码详解&lt;/h3&gt;&lt;p&gt;具体代码见 GitHub - &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/JeffLi1993/springboot-learning-example&quot;&gt;https://github.com/JeffLi1993/springboot-learning-example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.pom.xml 依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;

    &amp;lt;!-- Spring Boot Elasticsearch 依赖 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-data-elasticsearch&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Spring Boot Web 依赖 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Junit --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;application.properties 配置 ES 地址&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# ES
spring.data.elasticsearch.repositories.enabled = true
spring.data.elasticsearch.cluster-nodes = 127.0.0.1:9300
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认 9300 是 Java 客户端的端口。9200 是支持 Restful HTTP 的接口。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;ES 数据操作层&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;@Repository
public interface CityRepository extends ElasticsearchRepository&amp;lt;City,Long&amp;gt; {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口只要继承 ElasticsearchRepository 类即可。默认会提供很多实现，比如 CRUD 和搜索相关的实现。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;实体类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;@Document(indexName = &quot;cityindex&quot;, type = &quot;city&quot;)
public class City implements Serializable{

    private static final long serialVersionUID = -1L;

    /**
     * 城市编号
     */
    private Long id;

    /**
     * 省份编号
     */
    private Long provinceid;

    /**
     * 城市名称
     */
    private String cityname;

    /**
     * 描述
     */
    private String description;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意&lt;/p&gt;
&lt;p&gt;index 配置必须是全部小写，不然会引出异常：&lt;/p&gt;
&lt;p&gt;org.elasticsearch.indices.InvalidIndexNameException: Invalid index name [cityIndex], must be lowercase&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;ES 业务逻辑层&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Service 实现类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 城市 ES 业务逻辑实现类
*
* Created by bysocket on 07/02/2017.
  */
  @Service
  public class CityESServiceImpl implements CityService {

  private static final Logger LOGGER = LoggerFactory.getLogger(CityESServiceImpl.class);

  @Autowired
  CityRepository cityRepository;

  @Override
  public Long saveCity(City city) {

       City cityResult = cityRepository.save(city);
       return cityResult.getId();
  }

  @Override
  public List&amp;lt;City&amp;gt; searchCity(Integer pageNumber,
  Integer pageSize,
  String searchContent) {
  // 分页参数
  Pageable pageable = new PageRequest(pageNumber, pageSize);

       // Function Score Query
       FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery()
               .add(QueryBuilders.boolQuery().should(QueryBuilders.matchQuery(&quot;cityname&quot;, searchContent)),
                   ScoreFunctionBuilders.weightFactorFunction(1000))
               .add(QueryBuilders.boolQuery().should(QueryBuilders.matchQuery(&quot;description&quot;, searchContent)),
                       ScoreFunctionBuilders.weightFactorFunction(100));

       // 创建搜索 DSL 查询
       SearchQuery searchQuery = new NativeSearchQueryBuilder()
               .withPageable(pageable)
               .withQuery(functionScoreQueryBuilder).build();

       LOGGER.info(&quot;\n searchCity(): searchContent [&quot; + searchContent + &quot;] \n DSL  = \n &quot; + searchQuery.getQuery().toString());

       Page&amp;lt;City&amp;gt; searchPageResults = cityRepository.search(searchQuery);
       return searchPageResults.getContent();
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存逻辑很简单，这里不解释了。&lt;/p&gt;
&lt;p&gt;分页 function score query 搜索逻辑：&lt;/p&gt;
&lt;p&gt;先创建分页参数，然后用 FunctionScoreQueryBuilder 定义 Function Score Query，并设置对应字段的权重分值。城市名称 1000 分，description 100 分。&lt;/p&gt;
&lt;p&gt;然后创建该搜索的 DSL 查询，并打印出来。&lt;/p&gt;
&lt;h2 id=&quot;四、小结&quot;&gt;&lt;a href=&quot;#四、小结&quot; class=&quot;headerlink&quot; title=&quot;四、小结&quot;/&gt;四、小结&lt;/h2&gt;&lt;p&gt;实际场景还会很复杂。这里只是点睛之笔，后续大家优化或者更改下 DSL 语句就可以完成自己想要的搜索规则。&lt;/p&gt;

        &lt;/div&gt;

    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>