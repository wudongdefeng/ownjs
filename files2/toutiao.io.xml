<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f5e5a4ec66322c2914ea06dfb8cd5d04</guid>
<title>【大厂面试真题解析】虾皮 Shopee 后端一面十四问</title>
<link>https://toutiao.io/k/pol71im</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote&gt;&lt;p&gt;关于我：微信公众号：面试官问，原创高质量面试题，始于面试题，但不止于面试题。【大厂面试真题解析】面试系列文章将会对大家实际面试中遇到的面试题进行汇总分析，以飨读者。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;本文是作者 &lt;span&gt;gopherhiro&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt; 近期面试 Shopee 被问到的问题，本文节选了其中通用的部分进行了解析，欢迎读者将面试中遇到的问题私信我，可以帮大家整理出回答的要点。&lt;/p&gt;&lt;h2&gt;MySQL&lt;/h2&gt;&lt;h3&gt;1. 为什么要分库分表&lt;/h3&gt;&lt;p&gt;单个数据库实例能够承载的并发访问量和数据量是有限的，当系统的并发访问量或者数据量超过这个限制时，就需要考虑使用分库分表来优化系统的架构设计，使其能够承载更大的并发量和数据量，并给用户提供良好的使用体验。当然，分库和分表其实是两个事情，两者并不是都会同时出现。&lt;/p&gt;&lt;h3&gt;2. 分库解决了什么问题&lt;/h3&gt;&lt;p&gt;分库主要解决的是&lt;strong&gt;并发量大&lt;/strong&gt;的问题，因为单个数据库实例能够提供的连接数是有限的，当系统并发量不断增加，我们势必需要增加更多的微服务实例来承载更多的业务请求，而每个微服务实例都会占用一定量的数据库连接，因此，当数据库连接数不够用了，就只能通过增加数据库实例的方式来提供更多的数据库连接，进而提升系统整体的并发度。&lt;/p&gt;&lt;h3&gt;3. 分表解决了什么问题&lt;/h3&gt;&lt;p&gt;分表主要解决的是&lt;strong&gt;数据量大&lt;/strong&gt;的问题，因为单表的数据量很大时，即使并发访问量不大，但单表的存储和查询的性能已经遭遇了瓶颈，通过索引优化等手段虽然能够一定程度上提升效率，但当单表数据量超过 500 万行或者单表存储容量超过 2GB（经验值，实际要看业务的具体情况） 之后，分表就应该提上日程了。一般都是将数据拆分到多张表中，来减少单表的数据量，从而提升查询的速度。&lt;/p&gt;&lt;h3&gt;4. 乐观锁与悲观锁？在实践中是否用过，可否举例说明一下。&lt;/h3&gt;&lt;p&gt;乐观锁实际上并没有加锁，只是一种锁思想，一般通过在行数据上添加&lt;strong&gt;版本号字段&lt;/strong&gt;实现，在更新数据前，先查询出当前行数据的版本号，更新数据时，将版本号加1，并判断数据库中版本号是否等于前面我们读取出来的版本号，如果不一致，说明数据被修改过，更新失败。乐观锁的核心语句是：&lt;code&gt;update table set ... version=version+1 where id=#{id} and version=#{version};&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;乐观锁使用场景&lt;/strong&gt;：比较适合读多写少的场景，因为如果出现大量的写入操作，version字段值发生冲突的可能性就会增大，更新失败后，应用层需要不断的重新获取最新version字段数据，并重试操作，这样会增加大量的查询操作，降低了系统的吞吐量。&lt;/p&gt;&lt;p&gt;悲观锁一般是使用 &lt;code&gt;select ... for update;&lt;/code&gt; 语句锁定行数据，更新完提交事务后自动释放行数据，在此期间，其他事务无法更新这一行数据。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;悲观锁使用场景&lt;/strong&gt;：比较适合写多读少的场景，因为如果出现大量的读取操作，每次读的时候都进行加锁，会增加大量的锁的开销，降低了系统的吞吐量。&lt;/p&gt;&lt;h3&gt;5. 主键索引和唯一索引的区别？&lt;/h3&gt;&lt;p&gt;MySQL 数据库索引按照功能进行划分，可以分为：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;普通索引：没有任何的约束作用，它存在的主要意义就是提高查询效率。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;唯一索引：在普通索引的基础上，增加了唯一性约束，要求索引列的值必须唯一，但可以为空值，一张表中可以同时存在多个唯一性索引&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;主键索引：在唯一性索引的基础上又增加了不为空的约束，而且一张表里最多只能有一个主键索引，但一个主键索引中可以包含多个字段。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;全文索引：实际上用的不多，不做介绍&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Redis&lt;/h2&gt;&lt;h3&gt;1. Redis 崩溃时，如何保证数据不丢失？&lt;/h3&gt;&lt;p&gt;Redis 是一个内存键值对数据库，如果服务器进程挂掉，内存中的数据就会丢失，为了避免数据丢失，Redis 提供了三种持久化方案：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;RDB 持久化：Redis DataBase，将内存中的数据以快照（二进制）的形式保存到磁盘上，是 Redis 默认的持久化方式。执行完 RDB 持久操作后，会在指定的目录中生成一个 &lt;code&gt;dump.rdb&lt;/code&gt; 文件，在 Redis 重启时，会加载 &lt;code&gt;dump.rdb&lt;/code&gt; 文件来恢复数据到内存中。RDB 持久化可以通过手动和自动两种方式触发：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;手动方式：同步方式 save，会阻塞 Redis 主线程；异步方式 bgsave，会 fork 一个子进程，由子进程负责 RDB 文件的操作，避免阻塞 Redis 服务主进程&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;自动方式：save m n，当 m 秒内数据集发生 n 次修改时，自动触发 bgsave&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;AOF 持久化：Append Only File，基于日志来记录 Redis 的每个写操作，每个操作会追加到文件的末尾。Redis 默认不开启 AOF。需要注意的是，AOF 是在执行完 Redis 命令才记录日志的，而不是执行之前，因为 Redis 是不会对输入的命令进行语法检查的，因此，只有真正执行完命令后，才能避免将非法的命令写入 AOF 文件中。AOF 持久化方案有三种日志写回策略 &lt;code&gt;appendfsync&lt;/code&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;always：同步执行日志写回，也就是在每个命令执行完之后，立即将日志写入 AOF 文件末尾&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;everysec：每隔一秒将 AOF 内存缓冲区中的日志刷新到磁盘中&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;no：Redis 只负责将日志写入到 AOF 内存缓冲区中，由操作系统的刷盘机制决定什么时候写入磁盘&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;混合持久化：RDB 方式的优点是文件相比 AOF 小，数据恢复快，适合大规模数据恢复场景，例如数据备份等；AOF 的优点是数据一致性和完整性相比 RDB 高，通常使用 everysec 写回策略保证只有秒级的数据丢失。为了中和两者的优缺点，Redis 4.0 引入了混合持久化，也就是在两次 RDB 持久化中间，会增加 AOF 操作来记录这段时间的日志。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;2. Redis 基本数据类型及其使用场景有哪些？&lt;/h3&gt;&lt;p&gt;Redis 有五种常用的基本数据类型：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;字符串 String：不同微服务实例之间 session 共享，分布式锁、ID生成器、计数器、限速器等&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;列表 List：实现消息队列功能，缓存文章列表信息等&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;哈希 Hash：缓存用户信息 UserInfo（可能包含 userId、userName、password、email 等字段）、实现短网址生成程序&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;集合 Set：存储用户的标签信息、唯一计数器、点赞等功能&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;有序集合 ZSet：实现排行榜、时间线等功能&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;3. Redis zset 数据类型底层是如何实现的？&lt;/h3&gt;&lt;p&gt;Redis zset 底层数据结构有两种选型：压缩列表 ziplist 和跳表 skiplist，具体选择哪种数据结构要看当前存储的数据量和数据大小。当满足如下两个条件时，Redis 选择 ziplist 来实现 zset 值的存储：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;所有数据的大小都要小于 64 字节&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;元素个数小于 128 个&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当不满足以上两个条件时，则会选择使用 skiplist 来实现 zset 值的存储。&lt;/p&gt;&lt;p&gt;压缩列表是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3336252189141856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cyZVqTO3RQaRciaEOwWx8dbWYj25C8BsoHmt2NJEsUX5OYiasQhbsJmNdT646cjfe28lyO8NK1eiaqbEAC3iaLfVsw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1142&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;关于压缩列表更详细介绍可以参考极客时间的这篇文章：&lt;span&gt;52 | 算法实战（一）：剖析Redis常用数据类型对应的数据结构&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;跳表 skiplist 是在单链表基础上增加了多级索引实现的一个数据结构，能够实现 O(logn) 时间复杂度的查找、插入和删除操作。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5805604203152365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cyZVqTO3RQaRciaEOwWx8dbWYj25C8BsoVnoP3Y2t9sQ3ic4TiaFbHDHf7sKEOqJM1EsJRo3m9AEV38l1F7HiaTDDg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1142&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;关于跳表更详细介绍可以参考极客时间的这篇文章：&lt;span&gt;17 | 跳表：为什么Redis一定要用跳表来实现有序集合？&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h3&gt;4. Redis 分布式锁是如何实现的？&lt;/h3&gt;&lt;p&gt;通过调用 Redis 命令 SETNX+EXPIRE 实现，同时为了保证原子性，可以通过 lua 脚本来实现锁的设置和过期时间设置的原子性。在 Redis 2.6.12 版本后，SETNX 命令增加了过期时间参数，也可以直接使用这个重载方法，SETNX 返回 1 表示获得 key 所代表的锁，返回 0 表示获取锁失败。&lt;/p&gt;&lt;p&gt;更多关于分布式锁的问题，可以参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzNzkyMTE5OQ==&amp;amp;mid=2247483678&amp;amp;idx=1&amp;amp;sn=7d589fc1040c404c750a23d471e86ed6&amp;amp;scene=21#wechat_redirect&quot; title=&quot;场景化面试：关于分布式锁的十问十答&quot; data-linktype=&quot;2&quot;&gt;场景化面试：关于分布式锁的十问十答&lt;/a&gt;这篇文章。&lt;/p&gt;&lt;h3&gt;5. Redis分布式锁过期了但业务还没有执行完，怎么办？&lt;/h3&gt;&lt;p&gt;这种情况可以通过锁续约机制来解决，也就是通过另外一个线程使用心跳机制来不断延长锁的超时时间。&lt;/p&gt;&lt;h2&gt;业务监控相关&lt;/h2&gt;&lt;h3&gt;1. 所做业务接口性能耗时是多少？&lt;/h3&gt;&lt;p&gt;按你的系统实际回答即可，针对一般 OLTP 系统来说，接口耗时应该小于 500ms，对于高频接口，应该保证在 200ms 以内，具体还是要针对具体业务进行分析。&lt;/p&gt;&lt;h3&gt;2. 所做业务 QPS 大致是多少？&lt;/h3&gt;&lt;p&gt;这个主要是了解你的项目的并发情况，看你是否有高并发的相关经验，即使你的项目本身 QPS 不高，也应该准备下高并发相关的知识以便应对。&lt;/p&gt;&lt;h3&gt;3. 如何理解 p 分位？如 p99，p95。&lt;/h3&gt;&lt;p&gt;响应时间是指从前端发出请求开始到最后收到响应所需要的时间，对于互联网服务来说，响应时间我们更应该关注&lt;strong&gt;分位线&lt;/strong&gt;，也就是常说的 TP95、TP99 或 95 线、99 线。&lt;/p&gt;&lt;p&gt;对于 TP95而言，就是将对应接口所有请求的响应时间从小到大排序，位于 95% 这个位置的请求的响应时间，它表示至少有 95% 的请求响应时间小于等于这个值。&lt;/p&gt;&lt;h2&gt;系统设计&lt;/h2&gt;&lt;h3&gt;1. 如何设计一个分布式 ID 生成器？&lt;/h3&gt;&lt;p&gt;分布式 ID 必须保证全局唯一性，常见的方案有 UUID 和雪花算法（Snowflake）两种方案，但 UUID 相比雪花算法存在如下缺点，所以一般来说，我们都会选择雪花算法，并根据具体的业务场景进行改造：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;UUID 生成的 id 是无序的，而 Snowflake 生成的 id 是有序的，id 有序能够支持排序，也能够提升数据的写入性能&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;UUID 不具备业务含义，但 Snowflake 具备业务含义，Snowflake 的核心思想是将 64bit 的二进制数字分成若干部分，每一部分都存储有特定含义的数据，标准的 Snowflake 算法包含 1 位符号位、41 位时间戳、10 位机器 id、12 位序列号，最终拼接生成全局唯一的有序 id。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通常来说，对 Snowflake 的改造是保持前面 42 位生成方式不变，调整后面的 22 位比特位，在其中加入业务相关的信息。&lt;/p&gt;&lt;p&gt;分布式 ID 生成器的算法确定后，我们可以将其作为一个 jar 包提供给业务方使用，或者也可以将其独立封装成一个基础服务对外提供 API。具体可以根据自己项目的实际情况确定。&lt;/p&gt;&lt;p&gt;关于分布式 ID 生成器更详细介绍可以参考极客时间的这篇文章：&lt;span&gt;10 | 发号器：如何保证分库分表后ID的全局唯一性？&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; gopherhiro: &lt;em&gt;https://leetcode.cn/u/gopherhiro/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 52 | 算法实战（一）：剖析Redis常用数据类型对应的数据结构: &lt;em&gt;http://gk.link/a/11xJc&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; 17 | 跳表：为什么Redis一定要用跳表来实现有序集合？: &lt;em&gt;http://gk.link/a/11xJd&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; 10 | 发号器：如何保证分库分表后ID的全局唯一性？: &lt;em&gt;http://gk.link/a/11xJA&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>210922541b648b177611d6e1b35917df</guid>
<title>有意思，这个工具可以让你像 GitLab 一样管理数据库</title>
<link>https://toutiao.io/k/piqqkco</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Bytebase&lt;/code&gt; 是一个开源数据库 DevOps 工具，&lt;strong&gt;它相当于在整个应用程序开发生命周期中管理数据库的 GitLab&lt;/strong&gt;，它为 DBA 和开发人员提供了一个基于 Web 的工作空间，以安全有效地协作和管理数据库变更。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5tqrztXFpukRzn85BCbibKqZC7TnPWMLmBgWWV7BgtjId5lzUmcmwoiapDqDYtVya41jScv2v6q3IaEG3MNNiav1A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着 DevOps 进入主流，大部分团队采用 GitLab/GitHub 等工具来管理代码，并开始采用 Terraform 来管理基础设施，同样的，Bytebase 就是在应用程序开发期间管理数据库的这样的一个工具。Bytebase 是对现有云提供商的数据库平台或公司内部数据库运维平台的补充，虽然这些平台负责数据库实例级别的操作（例如配置数据库实例），但 Bytebase 会帮助团队使用配置的数据库来构建他们的应用程序。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;特性&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;架构 (DDL) 和数据 (DML) 变更审核工作流程&lt;/strong&gt;：与代码审查一样，Bytebase 简化了数据库变更过程，在单个工作流中，可以从开发环境一直到生产环境审查和部署数据库更改。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;SQL 质量检查&lt;/strong&gt;：Bytebase 分析 SQL 变更以执行符合您组织策略的规则。强制执行包括命名约定、反 SQL 模式检测等。生产环境和非生产环境也可以分别强制执行不同的规则。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;SQL 编辑器&lt;/strong&gt;：基于 Web 的用于查询和导出数据的 SQL 编辑器，当开发人员需要访问数据时，DBA 不再需要提供敏感的数据库凭据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;与 VCS 集成的版本控制&lt;/strong&gt;：Bytebase 可以保留完整的 Schema 变更历史记录，它还与 VCS 系统（例如 GitLab）集成。团队可以在 VCS 中管理 SQL 迁移脚本，并在代码提交时触发 Schema 部署。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;备份还原&lt;/strong&gt;：Bytebase 支持数据库级别的手动和定期备份。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多租户支持&lt;/strong&gt;：多租户服务可以为其每个租户创建单独的数据库，Bytebase 可以在单个工作流中为所有租户管理特定的数据库更改部署。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;部署&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bytebase 提供了多种部署方式，最简单就是使用 Docker 进行一键启动。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker run --init \&lt;br/&gt;  --name bytebase \&lt;br/&gt;  --restart always \&lt;br/&gt;  --add-host host.docker.internal:host-gateway \&lt;br/&gt;  --publish 8080:8080 \&lt;br/&gt;  --volume ~/.bytebase/data:/var/opt/bytebase \&lt;br/&gt;  bytebase/bytebase:1.2.2 \&lt;br/&gt;  --data /var/opt/bytebase \&lt;br/&gt;  --host http://localhost \&lt;br/&gt;  --port 8080&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的命令启动后我们可以通过 &lt;code&gt;http://localhost:8080&lt;/code&gt; 直接访问 Bytebase，就是这么简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想要在生产环境中使用，我们建议将其部署到 Kubernetes 集群中去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用下面的最基础的资源清单来部署 Bytebase，最好使用一个 Volume 来持久化数据，这里我们定义的是一个 &lt;code&gt;LoadBalancer&lt;/code&gt; 类型的 Service，当然我们也可以创建一个 Ingress 对象来进行暴露，具体使用哪种方式需要结合你 Kubernetes 集群来决定，可以在下面资源清单基础上进行修改。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;apps/v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Deployment&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;bytebase&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;bytebase&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;template:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;bytebase&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;bytebase&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;bytebase/bytebase:1.2.2&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;args:&lt;/span&gt; &lt;span&gt;[&quot;--data&quot;,&lt;/span&gt; &lt;span&gt;&quot;/var/opt/bytebase&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;--host&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;http://localhost&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;--port&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;8080&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;8080&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;volumeMounts:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;data&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;/var/opt/bytebase&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;data&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;emptyDir:&lt;/span&gt; &lt;span&gt;{}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;bytebase-entrypoint&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;LoadBalancer&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;bytebase&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;protocol:&lt;/span&gt; &lt;span&gt;TCP&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8080&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;targetPort:&lt;/span&gt; &lt;span&gt;8080&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接在 Kubernetes 集群中部署上面的对象即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外我们还可以使用 Bytebase 官方提供的安装脚本进行安装，脚本托管在 &lt;code&gt;https://github.com/bytebase/install&lt;/code&gt; 仓库。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bytebase 部署成功后，我们需要为团队成员注册账号，第一次注册的账号会被授予 &lt;code&gt;Workspace Owner&lt;/code&gt; 角色。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5503355704697986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5tqrztXFpukRzn85BCbibKqZC7TnPWMLmEDp30GFiaicRu3bqia1vjicslyXGwWicHNID1zuQicSdYlKuUcC8ES5qSnLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1043&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;admin&lt;/code&gt; 账号创建后，我们可以注册一个普通的账号会被授予 &lt;code&gt;Workspace Developer&lt;/code&gt; 角色。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.503125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5tqrztXFpukRzn85BCbibKqZC7TnPWMLmhRMWicC2R27zcbmfSdMKZrmLrb30q6K8VCqKtCkcTohphGYu4YBicA5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;登录后进入到 Bytebase 的主页我们就可以根据需要创建项目、添加数据实例或者环境了，下面的一些图展示了 Bytebase 的一些示例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6805555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5tqrztXFpukRzn85BCbibKqZC7TnPWMLm1icBict1bWCxq68IqUvvMqrDoXTEib6qV5QHDZY0RRpo4Cw9Po6n8Ohibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;figcaption&gt;图 1 - Dashboard&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.788961038961039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5tqrztXFpukRzn85BCbibKqZC7TnPWMLmehsccceUVMwOVtcEicPWFuRILPb8poIIhgXVoHU4PBafxWRvexHmmFg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1232&quot;/&gt;&lt;figcaption&gt;图 2 - SQL review issue 流水线&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6703296703296703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5tqrztXFpukRzn85BCbibKqZC7TnPWMLm8iaIInTWcdTBjBgS9rs7OLrOhboJ6ibGzGRu3beoGtggSb4A6ISicXibhQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;910&quot;/&gt;&lt;figcaption&gt;图 3 - 基于 GitLab 的 schema 迁移（Database as code）&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5859375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5tqrztXFpukRzn85BCbibKqZC7TnPWMLmMwrPvMdcAyibD4pMA5eoibJwfBObtrIRWibC3f6QFR7Og5bedsenbXlDg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3072&quot;/&gt;&lt;figcaption&gt;图 4 - 内置的 SQL 编辑器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外 Bytebase 还可以了一些在线 Demo 可以体验，地址：&lt;code&gt;https://demo.bytebase.com&lt;/code&gt;，我们可以前往进行体验。关于 Bytebase 的更多使用可以参考官方文档 https://www.bytebase.com/docs 了解更多相关信息。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Git 仓库：https://github.com/bytebase/bytebase&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MTgzNTQwNA==&quot; data-alias=&quot;gitfan&quot; data-from=&quot;0&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/5tqrztXFpulnjUO595yPz4ia90X3ejHwUszAk04ff0hsfuQl0D3RPFNiagEQbV9oib8OVvepsibXPVEddGPz4DyPbA/0?wx_fmt=png&quot; data-nickname=&quot;Github爱好者&quot; data-signature=&quot;我们是一群 Github 爱好者，专注分享有价值、有趣的开源项目和学习资料，包括 Python、Golang、Java、Rust、AI、前端、运维、数据分析、大数据、云计算、Kubernetes、Service Mesh 等领域资源。&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e57582d38ad8d90633a8eed32a926f02</guid>
<title>代码重构：面向单元测试</title>
<link>https://toutiao.io/k/8lesyke</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMJtfgIIibWJHq5cD1yDKxwpPE7hAAMuTa8tAc51KhxARWiaia3At3J4bsCwN1c9DFEdicqXic55m6tMXRbdUSibG6og/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作 者 | 杜沁园(悬衡)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重构代码时，我们常常纠结于这样的问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果需要进一步抽象的话，如何进行抽象呢？有什么通用的步骤或者法则吗？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;单元测试是我们常用的验证代码正确性的工具，但是如果只用来验证正确性的话，那就是真是 “大炮打蚊子”--大材小用，它还可以帮助我们评判代码的抽象程度与设计水平。本文还会提出一个以“可测试性”为目标，不断迭代重构代码的思路，利用这个思路，面对任何复杂的代码，都能逐步推导出重构思路。为了保证直观，本文会以一个 “生产者消费者” 的代码重构示例贯穿始终。最后还会以业务上常见的 Excel 导出系统为例简单阐述一个业务上的重构实例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阅读本文需要具有基本的单元测试编写经验（最好是 Java），但是本文不会涉及任何具体的单元测试框架和技术，因为它们都是不重要的，学习了本文的思路，可以将它们用在任意的单测工具上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;不可测试的代码&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;程序员们重构一段代码的动机是什么？可能众说纷纭：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些都是比较主观的因素，在一个老练程序员看来恰到好处的设计，一个新手程序员却可能会觉得过于复杂，不好理解。但是让他们同时坐下来为这段代码添加单元测试时，他们往往能够产生类似的感受，比如&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“单测很容易书写，很容易就全覆盖了”，那么这就是可测试的代码；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“虽然能写得出来，但是费了老大劲，使用了各种框架和技巧，才覆盖完全”，那么这就是可测试性比较差的代码；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“完全不知道如何下手写”，那么这就是不可测试的代码；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般而言，可测试的代码一般都是同时是简洁和可维护的，但是简洁可维护的代码却不一定是可测试的，比如下面的“生产者消费者”代码就是不可测试的：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    public void producerConsumer() {&lt;br/&gt;        BlockingQueue&amp;lt;Integer&amp;gt; blockingQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;();&lt;br/&gt;        Thread producerThread  = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (int i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++) {&lt;br/&gt;                blockingQueue.add(i + ThreadLocalRandom.current().nextInt(&lt;span&gt;100&lt;/span&gt;));&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        Thread consumerThread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    Integer result = blockingQueue.take();&lt;br/&gt;                    System.out.println(result);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException ignore) {&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        producerThread.start();&lt;br/&gt;        consumerThread.start();&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面这段代码做的事情非常简单，启动两个线程：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;生产者：将 0-9 的每个数字，分别加上 [0,100) 的随机数后通过阻塞队列传递给消费者；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这段代码看上去还是挺简洁的，但是，算得上一段好代码吗？尝试下给这段代码加上单元测试。仅仅运行一下这个代码肯定是不够的，因为我们无法确认生产消费逻辑是否正确执行。我也只能发出“完全不知道如何下手”的感叹，这不是因为我们的单元测试编写技巧不够，而是因为代码本身存在的问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.违背单一职责原则：这一个函数同时做了 数据传递，处理数据，启动线程三件事情。单元测试要兼顾这三个功能，就会很难写。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.这个代码本身是不可重复的，不利于单元测试，不可重复体现在 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;/&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;需要测试的逻辑位于异步线程中，对于它什么时候执行？什么时候执行完？都是不可控的；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;/&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;/&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消费者直接将数据输出到标准输出中，在不同环境中无法确定这里的行为是什么，有可能是输出到了屏幕上，也可能是被重定向到了文件中；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为第 2 点的原因，我们就不得不放弃单测了呢？其实只要通过合理的模块职责划分，依旧是可以单元测试。这种划分不仅仅有助于单元测试，也会“顺便”帮助我们抽象一套更加合理的代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可测试意味着什么?&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所有不可测试的代码都可以通过合理的重构与抽象，让其核心逻辑变得可测试，这也重构的意义所在。本章就会详细说明这一点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先我们要了解可测试意味着什么，如果说一段代码是可测试的，那么它一定符合下面的条件：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.可以在本地设计完备的测试用例，称之为 完全覆盖的单元测试；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.只要完全覆盖的单元测试用例全部正确运行，那么这一段逻辑肯定是没有问题的；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第 1 点常会令人感到难以置信，但事实比想象的简单，假设有这样一个分段函数：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.669047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKibom1QxfVUm98ThS5HnvQnjWLIYibm4prBKB57GCnibvCq2HoDJag3GuZ9j9qYpE5PedPkODEcVVtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1680&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;f(x) 看起来有无限的定义域，我们永远无法穷举所有可能的输入。但是再仔细想想，我们并不需要穷举，其实只要下面几个用例可以通过，那么就可以确保这个函数是没有问题的：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;日常工作中的代码当然比这个复杂很多，但是没有本质区别，也是按照如下思路进行单元测试覆盖的：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每一个分段其实就是代码中的一个条件分支，用例的分支覆盖率达到了 100%；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;像 2x 这样的逻辑运算，通过几个合适的采样点就可以保证正确性；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是业务代码依旧比 f(x) 要复杂很多，因为 f(x) 还有其他好的性质让它可以被完全测试，这个性质被称作引用透明：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;函数的返回值只和参数有关，只要参数确定，返回值就是唯一确定的&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现实中的代码大多都不会有这么好的性质，反而具有很多“坏的性质”，这些坏的性质也常被称为副作用：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;执行结果和当前日期有关，比如只有工作日的早上，闹钟才会响起；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好在我们可以用一些技巧将这些副作用从核心逻辑中抽离出来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;高阶函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“引用透明” 要求函数的出参由入参唯一确定，之前的例子容易让人产生误解，觉得出参和入参一定要是数据，让我们把视野再打开一点，出入参可以是一个函数，它也可以是引用透明的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;普通的函数又可以称作一阶函数，而接收函数作为参数，或者返回一个函数的函数称为高阶函数，高阶函数也可以是引用透明的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于函数 f(x) 来说，x 是数据还是函数，并没有本质的不同，如果 x 是函数的话，仅仅意味着 f(x) 拥有更加广阔的定义域，以至于没有办法像之前一样只用一个一维数轴表示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于高阶函数 f(g) (g 是一个函数)来说，只要对于特定的函数 g，返回逻辑也是固定，它就是引用透明的了， 而不用在乎参数 g 或者返回的函数是否有副作用。利用这个特性，我们很容易将一个有副作用的函数转换为一个引用透明的高阶函数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个典型的拥有副作用的函数如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ThreadLocalRandom.current().nextInt(&lt;span&gt;100&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;它生成了随机数并且加 1，因为这个随机数，导致它不可测试。但是我们将它转换为一个可测试的高阶函数，只要将随机数生成逻辑作为一个参数传入，并且返回一个函数即可：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Supplier&amp;lt;Integer&amp;gt; &lt;span&gt;g&lt;/span&gt;(&lt;span&gt;Supplier&amp;lt;Integer&amp;gt; integerSupplier&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; () -&amp;gt; integerSupplier.&lt;span&gt;get&lt;/span&gt;() + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面的 g 就是一个引用透明的函数，只要给 g 传递一个数字生成器，返回值一定是一个 “用数字生成器生成一个数字并且加1” 的逻辑，并且不存在分支条件和边界情况，只需要一个用例即可覆盖：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testG&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;        Supplier&amp;lt;Integer&amp;gt; result = g(() -&amp;gt; &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        assert result.&lt;span&gt;get&lt;/span&gt;() == &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实际业务中可以稍微简化一下高阶函数的表达， g 的返回的函数既然每次都会被立即执行，那我们就不返回函数了，直接将逻辑写在方法中，这样也是可测试的：&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;g2&lt;/span&gt;(&lt;span&gt;Supplier&amp;lt;Integer&amp;gt; integerSupplier&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; integerSupplier.&lt;span&gt;get&lt;/span&gt;() + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里我虽然使用了 Lambda 表达式简化代码，但是 “函数” 并不仅仅是指 Lambda 表达式，OOP 中的充血模型的对象，接口等等，只要其中含有逻辑，它们的传递和返回都可以看作 “函数”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;因为这个例子比较简单，“可测试” 带来的收益看起来没有那么高，真实业务中的逻辑一般比 +1 要复杂多了，此时如果能构建有效的测试将是非常有益的。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;面向单测的重构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一轮重构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们本章回到开头的生产者消费者的例子，用上一章学习到的知识对它进行重构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;那段代码无法测试的第一个问题就是职责不清晰，它既做数据传递，又做数据处理。因此我们考虑将生产者消费者数据传递的代码单独抽取出来：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    public &amp;lt;T&amp;gt; void  producerConsumerInner(Consumer&amp;lt;Consumer&amp;lt;T&amp;gt;&amp;gt; producer,&lt;br/&gt;                                           Consumer&amp;lt;Supplier&amp;lt;T&amp;gt;&amp;gt; consumer) {&lt;br/&gt;        BlockingQueue&amp;lt;T&amp;gt; blockingQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; producer.accept(blockingQueue::add)).start();&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; consumer.accept(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; blockingQueue.take();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(e);&lt;br/&gt;            }&lt;br/&gt;        })).start();&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这一段代码的职责就很清晰了，我们给这个方法编写单元测试的目标也十分明确，即验证数据能够正确地从生产者传递到消费者。但是很快我们又遇到了之前提到的第二个问题，即异步线程不可控，会导致单测执行的不稳定，用上一章的方法，我们将执行器作为一个入参抽离出去：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    public &amp;lt;T&amp;gt; void  producerConsumerInner(Executor executor,&lt;br/&gt;                                      Consumer&amp;lt;Consumer&amp;lt;T&amp;gt;&amp;gt; producer,&lt;br/&gt;                                      Consumer&amp;lt;Supplier&amp;lt;T&amp;gt;&amp;gt; consumer) {&lt;br/&gt;        BlockingQueue&amp;lt;T&amp;gt; blockingQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;();&lt;br/&gt;        executor.execute(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; producer.accept(blockingQueue::add));&lt;br/&gt;        executor.execute(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; consumer.accept(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; blockingQueue.take();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(e);&lt;br/&gt;            }&lt;br/&gt;        }));&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这时我们就为它写一个稳定的单元测试了：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testProducerConsumerInner&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        producerConsumerInner(Runnable::run,&lt;br/&gt;                (Consumer&amp;lt;Consumer&amp;lt;Integer&amp;gt;&amp;gt;) producer -&amp;gt; {&lt;br/&gt;                    producer.accept(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                    producer.accept(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;                },&lt;br/&gt;                consumer -&amp;gt; {&lt;br/&gt;                    &lt;span&gt;assert&lt;/span&gt; consumer.get() == &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;assert&lt;/span&gt; consumer.get() == &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;                });&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;只要这个测试能够通过，就能说明生产消费在逻辑上是没有问题的。一个看起来比之前的分段函数复杂很多的逻辑，本质上却只是它定义域上的一个恒等函数（因为只要一个用例就能覆盖全部情况），是不是很惊讶。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果不太喜欢上述的函数式编程风格，可以很容易地将其改造成 OOP 风格的抽象类，就像上一章提到的，传递对象和传递函数没有本质的区别：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProducerConsumer&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Executor executor;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; BlockingQueue&amp;lt;T&amp;gt; blockingQueue;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ProducerConsumer&lt;/span&gt;&lt;span&gt;(Executor executor)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.executor = executor;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.blockingQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;start&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        executor.execute(&lt;span&gt;this&lt;/span&gt;::produce);&lt;br/&gt;        executor.execute(&lt;span&gt;this&lt;/span&gt;::consume);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;consume&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;produceInner&lt;/span&gt;&lt;span&gt;(T item)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        blockingQueue.add(item);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; T &lt;span&gt;consumeInner&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; blockingQueue.take();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此时单元测试就会像是这个样子：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testProducerConsumerAbCls&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; ProducerConsumer&amp;lt;Integer&amp;gt;(Runnable::run) {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                produceInner(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                produceInner(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;consume&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;&lt;span&gt;assert&lt;/span&gt; &lt;span&gt;consumeInner&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;assert&lt;/span&gt; &lt;span&gt;consumeInner&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;== &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }.start();&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看到这些类，熟悉设计模式的读者们一定会想到 “模板方法模式”，但是我们在上面的过程从来没有刻意去用任何设计模式，正确的重构就会让你在无意间 “重新发现” 这些常用的设计模式，一般这种情况下，设计模式的使用都是正确的，因为我们一直在把代码往更加可测试的方向推荐，而这也是衡量设计模式是否使用正确的重要标准，错误的设计模式使用则会让代码更加的割裂和不可测试，后文讨论“过度设计”这个主题时会进一步深入讨论这一部分内容。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;很显然这种测试无法验证多线程运行的情况，但我故意这么做的，这部分单元测试的主要目的是验证逻辑的正确性，只有先验证逻辑上的正确性，再去测试并发才比较有意义，在逻辑存在问题的情况下就去测试并发，只会让问题隐藏得更深，难以排查。一般开源项目中会有专门的单元测试去测试并发，但是因为其编写代价比较大，运行时间比较长，数量会远少于逻辑测试。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过第一轮重构，主函数变成了这个样子（这里我最终采用了 OOP 风格）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;producerConsumer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; ProducerConsumer&amp;lt;Integer&amp;gt;(Executors.newFixedThreadPool(&lt;span&gt;2&lt;/span&gt;)) {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++) {&lt;br/&gt;                    produceInner(i + ThreadLocalRandom.current().nextInt(&lt;span&gt;100&lt;/span&gt;));&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;consume&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    Integer result = consumeInner();&lt;br/&gt;                    System.out.println(result);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }.start();&lt;br/&gt;    }&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在第一轮重构中，我们仅仅保障了数据传递逻辑是正确的，在第二轮重构中，我们还将进一步扩大可测试的范围。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第二轮重构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;代码中影响我们进一步扩大测试范围因素还有两个：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;只要将这两个逻辑像之前一样抽出来即可：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NumberProducerConsumer&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ProducerConsumer&lt;/span&gt;&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Supplier&amp;lt;Integer&amp;gt; numberGenerator;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Consumer&amp;lt;Integer&amp;gt; numberConsumer;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NumberProducerConsumer&lt;/span&gt;&lt;span&gt;(Executor executor,&lt;br/&gt;                                  Supplier&amp;lt;Integer&amp;gt; numberGenerator,&lt;br/&gt;                                  Consumer&amp;lt;Integer&amp;gt; numberConsumer)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(executor);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.numberGenerator = numberGenerator;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.numberConsumer = numberConsumer;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;produce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++) {&lt;br/&gt;            produceInner(i + numberGenerator.get());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;consume&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            Integer result = consumeInner();&lt;br/&gt;            numberConsumer.accept(result);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这次采用 OOP 和 函数式 混编的风格，也可以考虑将 numberGenerator 和 numberConsumer 两个方法参数改成抽象方法，这样就是更加纯粹的 OOP。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;它也只需要一个测试用例即可实现完全覆盖：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testProducerConsumerInner2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        AtomicInteger expectI = &lt;span&gt;new&lt;/span&gt; AtomicInteger();&lt;br/&gt;        producerConsumerInner2(Runnable::run, () -&amp;gt; &lt;span&gt;0&lt;/span&gt;, i -&amp;gt; {&lt;br/&gt;            &lt;span&gt;assert&lt;/span&gt; i == expectI.getAndIncrement();&lt;br/&gt;        });&lt;br/&gt;        &lt;span&gt;assert&lt;/span&gt; expectI.get() == &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此时主函数变成：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    public void producerConsumer() {&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; NumberProducerConsumer(Executors.newFixedThreadPool(&lt;span&gt;2&lt;/span&gt;),&lt;br/&gt;                &lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; ThreadLocalRandom.current().nextInt(&lt;span&gt;100&lt;/span&gt;),&lt;br/&gt;                System.out::println).start();&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过两轮重构，我们将一个很随意的面条代码重构成了很优雅的结构，除了更加可测试外，代码也更加简洁抽象，可复用，这些都是面向单测重构所带来的附加好处。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;你可能会注意到，即使经过了两轮重构，我们依旧不会直接对主函数 producerConsumer 进行测试，而只是无限接近覆盖里面的全部逻辑，因为我认为它不在“测试的边界”内，我更倾向于用集成测试去测试它，集成测试则不在本篇文章讨论的范围内。下一章则重点讨论测试边界的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单元测试的边界&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;边界内的代码都是单元测试可以有效覆盖到的代码，而边界外的代码则是没有单元测试保障的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上一章所描述的重构过程本质上就是一个在探索中不断扩大测试边界的过程。但是单元测试的边界是不可能无限扩大的，因为实际的工程中必然有大量的不可测试部分，比如 RPC 调用，发消息，根据当前时间做计算等等，它们必然得在某个地方传入测试边界，而这一部分就是不可测试的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;理想的测试边界应该是这样的，系统中所有核心复杂的逻辑全部包含在了边界内部，然后边界外都是不包含逻辑的，非常简单的代码，比如就是一行接口调用。这样任何对于系统的改动都可以在单元测试中就得到快速且充分的验证，集成测试时只需要简单测试下即可，如果出现问题，一定是对外部接口的理解有误，而不是系统内部改错了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;清晰的单元测试边界划分有利于构建更加稳定的系统核心代码，因为我们在推进测试边界的过程中会不断地将副作用从核心代码中剥离出去，最终会得到一个完整且可测试的核心，就如同下图的对比一样：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.43915343915343913&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKibom1QxfVUm98ThS5HnvQnsyGjG4IC22wATAElfsGISNpXnny2ZOQBOpTohTObNZvSR9KupNlUeA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;567&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重构的工作流&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好代码从来都不是一蹴而就的，都是先写一个大概，然后逐渐迭代和重构的，从这个角度来说，重构别人的代码和写新代码没有很大的区别。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从上面的内容中，我们可以总结出一个简单的重构工作流：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8321243523316062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKibom1QxfVUm98ThS5HnvQnnKJqtxtsWnDmyFtHlwibADoQMLDAc4nlTEGAxrECW5rAus6SMlRJia9g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;965&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;按照这个方法，就能够逐步迭代出一套优雅且可测试的代码，即使因为时间问题没有迭代到理想的测试边界，也会拥有一套大部分可测试的代码，后人可以在前人用例的基础上，继续扩大测试边界。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;过度设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后再谈一谈过度设计的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;按照本文的方法是不可能出现过度设计的问题，过度设计一般发生在为了设计而设计，生搬硬套设计模式的场合，但是本文的所有设计都有一个明确的目的--提升代码的“可测试性”，所有的技巧都是在过程中无意使用的，不存在生硬的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而且过度设计会导致“可测试性”变差，过度设计的代码常常是把自己的核心逻辑都给抽象掉了，导致单元测试无处可测。如果发现一段代码“写得很简洁，很抽象，但是就是不好写单元测试”，那么大概率是被过度设计了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外一种过度设计是因为过度依赖框架而无意中导致的，Java 往往习惯于将自己的设计耦合进 Spring 框架中，比如将一段完整的逻辑拆分到几个 Spring Bean 中，而不是使用普通的 Java 类，导致根本就无法在不启动容器的情况下进行完整的测试，最后只能写一堆无效的测试提升“覆盖率”。这也是很多人抱怨“单元测试没有用”的原因。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;和 TDD 的区别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文到这里都还没有提及到 TDD，但是上文中阐述的内容肯定让不少读者想到了这个名词，TDD 是 “测试驱动开发” 的简写，它强调在代码编写之前先写用例，包括三个步骤：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在开发过程中不断地重复这三个步骤。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是会实践中会发现，在繁忙的业务开发中想要先写测试用例是很困难的，可能会有以下原因：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;代码结构尚未完全确定，出入口尚未明确，即使提前写了单元测试，后面大概率也要修改&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;产品一句话需求，外加对系统不够熟悉，用例很难在开发之前写好&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此本文的工作流将顺序做了一些调整，先写代码，然后再不断地重构代码适配单元测试，扩大系统的测试边界。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不过从更广义的 TDD 思想上来说，这篇文章的总体思路和 TDD 是差不多的，或者标题也可以改叫做 “TDD 实践”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;业务实例 - 导出系统重构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;钉钉审批的导出系统是一个专门负责将审批单批量导出成 Excel 的系统：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6091148115687993&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKibom1QxfVUm98ThS5HnvQnt93trIfw7z3wKvRxu9Cjhd0JSYIj0mTHqM9HfzCXk0F1WSwlmckadA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1141&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大概步骤如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;钉钉审批导出系统比常规导出系统要更加复杂一些，因为它的表单结构并不是固定的。而用户可以通过设计器灵活配置：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7358490566037735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKibom1QxfVUm98ThS5HnvQnIiaicp1gYxibuLCRXdSh9RxjyIG8rn3uXLUPUyXDib1GL00IrBl7dBh5ibA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;954&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从上面可以看出单个审批单还具有复杂的内部结构，比如明细，关联表单等等，而且还能相互嵌套，因此逻辑很十分复杂。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我接手导出系统的时候，已经维护两年了，没有任何测试用例，代码中导出都是类似 patchXxx 的方法，可见在两年的岁月中，被打了不少补丁。系统虽然总体能用，但是有很多小 bug，基本上遇到边界情况就会出现一个 bug（边界情况比如明细里只有一个控件，明细里有关联表单，而关联表单里又有明细等等）。代码完全不可测试，完成的逻辑被 Spring Bean 隔离成一小块，一小块，就像下图一样：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6794425087108014&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKibom1QxfVUm98ThS5HnvQnkPQ4ckN0otbZnmn5meYzSIRic2prJqCINwY1IYj6vWZTNf6WiaBZpLbQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;287&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我决定将这些代码重构，不能让它继续荼毒后人，但是面对一团乱麻的代码完全不知道如何下手（以下贴图仅仅是为了让大家感受下当时的心情，不用仔细看）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.165625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKibom1QxfVUm98ThS5HnvQnicJfQ6IDW5eUJJQ9ecibMBhViaG2icql3ujOjibZfVPMtv7VOAIDfTbX46w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我决定用本文的工作流对代码进行重新梳理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;确定测试边界&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先需要确定哪些部分是单元测试可以覆盖到的，哪些部分是不需要覆盖到的，靠集成测试保证的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过分析，我认为导出系统的核心功能，就是根据表单配置和表单数据生成 excel 文件：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43473325766174803&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKibom1QxfVUm98ThS5HnvQnVNJCkI5MH4BvLBXXPwPh9TufBsia5t5sZXpib890UVN58GKLQdxxiacyg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;881&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这部分也是最核心，逻辑也最复杂的部分，因此我将这一部分作为我的测试边界，而其他部分，比如上传，发工作通知消息等放在边界之外：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33129175946547884&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKibom1QxfVUm98ThS5HnvQnwQh17cibE8USuDGv2zsRqVI5fuQRIJ0QbIHuGHkRu3qJ6BibFaWVJwHw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1796&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图中 “表单配置” 是一个数据，而 “表单数据” 其实是一个函数，因为导出过程中会不断批量分页地去查询数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不断迭代，扩大测试边界到理想状态&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我迭代的过程如下：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;大量使用 Spring Bean 导致逻辑割裂：将逻辑放到普通的 Java 类或者静态方法中；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;表单数据，流程与用户的相关信息查询是远程调用，含有副作用：通过高阶函数将这些副作用抽出去；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;导入状态落入数据库，也是一个副作用：同样通过高阶函数将其抽象出去；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最终导出的测试边界大约是这个样子：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] &lt;span&gt;export&lt;/span&gt;(&lt;span&gt;FormConfig config, DataService dataService, ExportStatusStore statusStore&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//... 省略具体逻辑, 其中包括所有可测试的逻辑, 包括表单数据转换，excel 生成&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;config：数据，表单配置信息，含有哪些控件，以及控件的配置&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;dataService: 函数，用于批量分页查询表单数据的副作用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;statusStore: 函数，用于变更和持久化导出的状态的副作用&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;DataService&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;PageList&amp;lt;FormData&amp;gt; &lt;span&gt;batchGet&lt;/span&gt;(&lt;span&gt;String formId, Long cursor, &lt;span&gt;int&lt;/span&gt; pageSize&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ExportStatusStore&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 将状态切换为 RUNNING&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;runningStatus&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 将状态置为 finish&lt;br/&gt;     * @param fileId 文件 id&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;finishStatus&lt;/span&gt;(&lt;span&gt;Long fileId&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 将状态置为 error&lt;br/&gt;     * @param errMsg 错误信息&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;errorStatus&lt;/span&gt;(&lt;span&gt;String errMsg&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在本地即可验证生成的 Excel 文件是否正确（代码经过简化）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testExport&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//  这里的 export 就是刚刚展示的导出测试边界&lt;/span&gt;&lt;br/&gt;        byte[] excelBytes = &lt;span&gt;export&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; FormConfig(), &lt;span&gt;new&lt;/span&gt; LocalDataService(),&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; LocalStatusStore());&lt;br/&gt;        assertExcelContent(excelBytes, Arrays.asList(&lt;br/&gt;                Arrays.asList(&lt;span&gt;&quot;序号&quot;&lt;/span&gt;, &lt;span&gt;&quot;表格&quot;&lt;/span&gt;, &lt;span&gt;&quot;表格&quot;&lt;/span&gt;, &lt;span&gt;&quot;表格&quot;&lt;/span&gt;, &lt;span&gt;&quot;创建时间&quot;&lt;/span&gt;, &lt;span&gt;&quot;创建者&quot;&lt;/span&gt;),&lt;br/&gt;                Arrays.asList(&lt;span&gt;&quot;序号&quot;&lt;/span&gt;, &lt;span&gt;&quot;物品编号&quot;&lt;/span&gt;, &lt;span&gt;&quot;物品名称&quot;&lt;/span&gt;, &lt;span&gt;&quot;xxx&quot;&lt;/span&gt;, &lt;span&gt;&quot;创建时间&quot;&lt;/span&gt;, &lt;span&gt;&quot;创建者&quot;&lt;/span&gt;),&lt;br/&gt;                Arrays.asList(&lt;span&gt;&quot;1&quot;&lt;/span&gt;, &lt;span&gt;&quot;22&quot;&lt;/span&gt;, &lt;span&gt;&quot;火车&quot;&lt;/span&gt;, &lt;span&gt;&quot;而非&quot;&lt;/span&gt;, &lt;span&gt;&quot;2020-10-11 00:00:00&quot;&lt;/span&gt;, &lt;span&gt;&quot;悬衡&quot;&lt;/span&gt;)&lt;br/&gt;        ));&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中 LocalDataService，LocalStatusStore 分别是内存中的数据服务，和状态变更服务实现，用于进行单元测试。assertExcelContent 是我用 poi 写的一个工具方法，用于测试内存中的 excel 文件是否符合预期。所有边界的用例都可以直接在本地测试和沉淀用例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最终的代码结构大约如下（经过简化）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7090103397341211&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKibom1QxfVUm98ThS5HnvQnwOg0xgZJDzq1jz46QPuXm6hII6EnmRzHMibqEYB58Axh8MVGsn6KbCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;677&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然到现在为止我的目的都是提升代码的可测试性，但是实际上我一不小心也提升了代码的拓展性，在完全没有相关产品需求的情况下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过 DataService 的抽象，系统可以支持多种数据源导出，比如来自搜索，或者来自 db 的，只要传入不同的 DataService 实现即可，完全不需要改动和性逻辑；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ExportStatusStore 的抽象，让系统有能力使用不同的状态存储，虽然目前使用的是 db，但是也可以在不改核心逻辑的情况下轻松切换成 tair 等其他中间件；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;果然在我重构后不久，就接到了类似的需求，比如要支持从不同的数据源导出。我们又新增了一个导出入口，这个导出状态是存储在不同的表中。每次我都暗自窃喜，其实这些我早就从架构上准备好了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单元测试的局限性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然本文是一篇单元测试布道文章，前文也将单元测试说得“神通广大”，但是也不得不承认单元测试无法解决全部的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;单元测试仅仅能保证应该的代码逻辑是正确的，但是应用开发中还有很多更加要紧的事情，比如架构设计，中间件选型等等，很多系统 bug 可能不是因为代码逻辑，而是因为架构设计导致的，此时单元测试就无法解决。因此要彻底保障系统的稳健，还是需要从单元测试，架构治理，技术选项等多个方面入手。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外一点也不得不承认，单元测试是有一定成本的，一套工作流完成的话，可能会有数倍于原代码量的单元测试，因此并不是所有代码都需要这样的重构，在时间有限的情况下，应该优先重构系统中核心的稳定的代码，在权衡好成本与价值的情况下，再开始动手。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，单元测试也是对人有强依赖的技术，侧重于前期预防，没有任何办法量化一个人单元测试的质量如何，效果如何，这一切都是出于工程自己内心的“工匠精神” 以及对代码的敬畏，相信读到最后的你，也一定有着一颗工匠的心吧。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 技 术 好 文 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 企 业 案 例 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 云 专 栏 &lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0NTE4NjA0OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/tMJtfgIIibWJZdQ8EicOpoDF9lteAE7gGBotfOe7nZWKicaoH7URJUKISmAkBp7SiakzBrEqib5ZeZYrmIUClJUt1vQ/0?wx_fmt=png&quot; data-nickname=&quot;阿里云云栖号&quot; data-alias=&quot;yunqiinsight&quot; data-signature=&quot;阿里云官网内容平台，汇聚阿里云优质内容（入门、文档、案例、最佳实践、直播等）。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4ac597598baf1bc72c581281bf623c6d</guid>
<title>中原银行实时风控体系建设实践</title>
<link>https://toutiao.io/k/nyzmdhx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;摘&lt;/strong&gt;&lt;strong&gt;要&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;本文整理自中原银行数据平台中心开发工程师陈玉强在 Flink Forward Asia 2021 行业实践专场的演讲。主要内容包括：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;建设体系&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;选型 &amp;amp; 架构&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;应用场景&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;建设成效&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Tips：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;点击&lt;/span&gt;&lt;strong&gt;&lt;span&gt;「阅读原文」&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;查看原文视频&amp;amp;PPT～&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p cid=&quot;n6&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;建设体系&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;银行是经营风险的企业，对风险进行识别、衡量、定价和防范的能力是银行核心竞争力。中原银行构建了面向反欺诈、信用风险、运营风险的业务全流程风控体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKovUMDDhctq82JXDL4icqVA3udBc9oYEvQOGBibmicq507fnXdt6HznlMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;银行业务的申请、交易、营销等环节都可能存在欺诈行为，随着技术发展，在欺诈行为团伙化、隐蔽化、专业化、实时化情况下进行反欺诈难度越来越大。同时，随着业务种类增多，传统的专家规则评分卡模型难以应付复杂的风控场景，需要借助大数据、实时计算、机器学习、知识图谱等高新技术打造高质量的授信能力。此外，是否能够及时发现和化解业务运营风险，包括流程风险、员工异常行为、资产及负债流动性风险也面临较大挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n10&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKYZN7BJgaTibLJ2323K4XCekaStS24u0JOETWdeb59GR60WiaDlDNIxRg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统技术应对这些挑战时难以实时获取用户多渠道的操作行为，难以达到全方位、实时化的防控效果。传统风控体系普遍基于专家规则进行测算，存在规则触发阈值难以控制、吸收低饱和噪音数据难度大等特点，很难通过累计规则数量来提升精准度。此外，传统系统间相对孤立、数据流通难度大、数据孤岛的情况导致了专家规则制定和模型训练难度大，不利于整体风控效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKeE9IQfL41PGSTvCv6gWkicqclCEicicsMRTLPJyIa0bHdoNfickwOAK4mA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;新的风控体系首先实现了实时化，通过流计算、内存计算等技术提高数据处理的时效性，做到了及时识别跨系统的风险行为，并通过云原生、资源弹性等技术提高系统的高并发能力。在提升硬实力的同时更注重智能化，将基于概率的机器学习模型与专家规则结合，充分释放大数据价值，避免专家规则经验盲区。此外，通过打造平台化的产品，形成不同场景的快速支撑能力和完善的风控体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKOiaBtYH9Uicdia7FUPjT0fpZ74M4CxkdTT909D2f4BGRVpDVcvU2ia2CXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近三年我们经历了对实时计算的探索、尝试和平台化建设，并将实时计算技术应用至反欺诈、事件驱动、实时 OLAP 等多种场景，2021 年底任务数量和日均处理数据量都提升数倍。在风控方面，经历了从引入国外决策系统到自研决策平台的转变，2021 年自研决策平台已经开始承接新需求和部分国外决策系统迁移而来的规则模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n16&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKaIFMc6fPWmVFms0mv2iaoia0QibmRJJYrzhA6W1YORbFibAJIbnGX8gP1Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;智能风控体系能力模型可以总结为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;风险特征识别及计算实时化；&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;融合专家规则与机器学习模型通过复杂编排提供智能化的决策能力；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过平台化屏蔽技术细节，给用户提供友好的使用体验；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在风控体系中通过标准化来制定规范、构建数据标准和开放数据能力；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;并通过构建 ModelOps 管理体系实现风险模型从需求到投产的全生命周期管理；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;此外，通过低代码、可视化的方式有助于降低使用门槛。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p cid=&quot;n69&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;选型 &amp;amp; 架构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n20&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKeJFEP7zibic3Tr7cyxibm3K4OicGSrj8QcTE00972z1BN0MKChbSKcMVMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在本体系架构中，Flink 主要用于数据清洗、实时维表加工与关联以及窗口计算等场景，通过预计算、内存计算、聚合计算实现基础指标、衍生指标、复合指标的加工，为决策模型提供特征支持。模型编排专注于编排决策集、评分卡、决策树、决策表等丰富和易用规则模型，同时在规则中可以调用指标服务、算法模型服务共同参与逻辑运算。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n22&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKxE2iatu2uql1lzBCLUJoQmPGyCamYkIwQAHPHvaRqlpicyu0DR63p1Ow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;风控体系基于云原生架构和开源技术实现，支持报文、接口、多种类型数据库。通过数据源、维表、参数配置界面化，并支持用户用 Flink SQL 编写业务逻辑，极大程度降低了实时计算的使用门槛。通过可视化编排 (DAG) 将规则/模型/指标引擎的计算能力进行组合以支撑风控决策。此外还有一些特色功能，如 SQL 评分、网关分流等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n24&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKYpS2Twia8YpySRKRFLehkyQLmwBUoJnwgO5pLo6sNcFyacnD1CaH2Pw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实时指标可以用于专家规则，实时特征可以供在线 (online) 模型训练。机器学习平台使用离线 (offline) 数据进行模型训练和模型推理，同时结合规则筛选出来的风险数据，基于离线数据进行有监督和无监督的算法训练。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;应用场景&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n27&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKxIVTGp1WibaPSHxPasmESzEhLtiaHog2xVl84bgnibZa5icomibyux7chMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;反欺诈是交易的重要环节，通常会基于黑白名单、知识图谱、司法、税务、工商等内外部数据对交易数据打宽，打宽后的数据用于专家规则和机器学习模型。交易发起系统会根据智策平台的决策结果对交易放行或加强验证。风险结果数据可作为样本，用于图数据进行关联挖掘或特征分析，或者用于有监督学习。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n29&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PK5SKOsaBJacdibwhNFNgP5fxVq9aAYAKpMrtSTcHwdC4oDjoia93tFJHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术实现方面，针对交易请求，智策平台会根据 DAG 编排逻辑来调用不同的计算引擎，并返回计算结果。同时，实时计算平台会使用交易系统数据库的变化数据计算交易/行为等实时指标。此外，历史数据会被抽取到离线数仓和数据湖中，供下游的机器学习平台使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n31&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKyagYWzp6FePVnCcVtGRz2zBGVyhWJ6EDFQNFuKy4Gx7MUSWgowmbRg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对授信狭义且简单的理解就是金融机构向客户提供资金的行为。智策平台通过评分卡、决策集等方式承载了贷前阶段 50 余个场景，日均接收授信请求约 3 万笔；对于以批量数据处理为主的贷中、贷后环节，日均处理数据 1300 万条。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKW3Xn0ytia30S7aicSlhArjtUQxFDQHpj3QTS2xM7UushcISJ7e7WjzRA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;授信场景较交易反欺诈场景在技术架构明显的差异在于它需要外部数据支持。智策平台将关联了内外部数据的交易变量进行专家规则运算、机器学习模型推理。授信场景暂时没有使用实时指标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n35&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKOGjIBU7L7XNp4ibwqGfeAItiaU9MXLbfssXObDVNjRlragbWicALWcqQA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;员工行为、信贷管理、舆情分析都在运营风险的范畴内，将冲正行为、机具管理等场景数据加工成离线运营风险指标，将高敏感行为数据加工为实时指标，通过智策平台对两类指标进行规则、模型运算而得出预警结果，进而形成风险核查事件、名单等。结果数据也会作为风险特征样本来训练算法和挖掘风险。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n37&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKHPnozHMb5ibYGfBuk9mrAv18gKaZXTqgsibBse7yOfN5KMFCWw2vmGlg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;运营风险的技术架构比较直观，每天将历史业务数据同步到数据仓库，在数仓中完成风险指标的加工，同时离线数据也会被用于模型训练。智策平台每天定时对离线指标进行规则运算，并将风险预警结果推送给下游运营系统。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;04&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p cid=&quot;n73&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;建设成效&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKfyWoY1sYO5xEJibYYr6UlWBibQfulbWydzsvhgDQINh50AyRa4pnUibSQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务成效方面，反欺诈系统对接了 14 个渠道，105 类场景，在传统反欺诈技术上引入流计算实现实时反欺诈，助力管控了 1 万多高危账户，协助阻断转出资金超千万元，实现了全年线上交易零欺诈损失。授信方面，支撑了全周期的信贷场景，包括额度评估、风险定价、贷后预警等 50 多个场景，每天处理进件 3 万余笔。每天批量处理运营指标数据 30 余万，同时通过 Flink 每天实时处理员工行为数据约 3000 万条，具备实时发现内部的高风险行为的能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n42&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKyuHgicxia0AMv9C7CUbwOebZd0SoM6aXjDrPciaKc5BBiajPw4TMoAucbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术成效方面，智策平台每天接收业务交易请求 5 万余笔，响应时间约 8 毫秒 (最新数据)。规则和模型编排场景响应时间小于 3 秒，每天处理批量数据约 1800 万条。实时计算平台日均处理数据 2.7TB，较年初增长了 5 倍。在平台化基础上，本体系具备灵活编排专家规则和机器学习模型的能力，每天调用机器学习模型服务超过 2 万次。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;公司简介：中原银行是河南省唯一的省级法人银行，截止 2021 年 6 月 30 号，总资产为 7530.02 亿。中原银行在收获众多荣誉的同时也在不断自我超越，在知名的《银行家》、《财富》等排行榜中的排名较往年都有提升。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1503268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PK4uM4yxj3ibA6gs9jFZ6pHyay4ibyFcqkdUvibVzeW1rA3TnicNUYoDfHHg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;306&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2022第四届 实时计算FLINK挑战赛&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1503268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PK4uM4yxj3ibA6gs9jFZ6pHyay4ibyFcqkdUvibVzeW1rA3TnicNUYoDfHHg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;306&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzg4OTMyNQ==&amp;amp;mid=2247499352&amp;amp;idx=1&amp;amp;sn=1cbe1c083f7d2487c4ba28c03d6b6d3b&amp;amp;chksm=fd38701aca4ff90c82f1ce6370ce6fdeca3d67997d08ad6983be58a4502f69ecae7fa4882ee0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8AsYBicEePu6KqfiaicKj5X7bAdPl6gT2PKZXtwr600utwW2Pbjq6qhlmOraG6rzibsfZibIp1lLaTaqky8Y4qiafibGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;49万&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;奖金等你来拿！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;延续 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;“鼓励师计划”&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，赢取丰厚礼品！&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;👇 &lt;/span&gt;&lt;span&gt;扫码&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;报名参赛&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;span&gt;👇&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8AsYBicEePu7J66IEWw7veZJqfXhyUQew1pWryI8vlCH13iaibklpeGqjXiatnGwvib6d73ViaCcGZicDwbCibG6mCv1Bw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;赛事官网&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;▼ 关注公众号&lt;/span&gt;&lt;span&gt;，获取更多技术干货 &lt;span&gt;▼&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU3Mzg4OTMyNQ==&quot; data-alias=&quot;apacheflinkcc&quot; data-from=&quot;0&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8AsYBicEePu6FJHxaI14AsXuzeg4SybT0hiaCSohrIY75oiaOMzhQU7RouiafjNa76k2CtD6xxB2JqnawqFqV3zg3A/0?wx_fmt=png&quot; data-nickname=&quot;Apache Flink&quot; data-signature=&quot;Flink 中文社区官微，Flink PMC 维护&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更多 Flink 相关技术问题，可扫码加入社区钉钉交流群～&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;4&quot; data-cropselx2=&quot;204&quot; data-cropsely1=&quot;1&quot; data-cropsely2=&quot;243&quot; data-fileid=&quot;100010716&quot; data-ratio=&quot;1.162531017369727&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu573SfR5B9zrZybQe6w2yUInzu48HG5BMCDdHgE77LRzrnlGSl2kzKKfp9ypsduOukxibm1W99g26w/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;806&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100010714&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naLWBBEcl44aIic1Mthe1nZiaramW5s4e8WwyCYYbTzu6uPBpgI6sxNXNymEnOYKpJpcrItUia7lS64mA/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot;/&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;点击「阅&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;读原文&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;，&lt;strong&gt;&lt;span&gt;查看原文视频&amp;amp;PPT&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>082aa303ff5ba9955cbbb2247a65b9d8</guid>
<title>go并发</title>
<link>https://toutiao.io/k/qx0xu7l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;blog-copy w-richtext&quot;&gt;&lt;p&gt;Concurrency is one of those things that&#x27;s easy to get wrong, even with Go concurrency features. Let&#x27;s review things you should consider while writing a concurrency production code.&lt;/p&gt;&lt;p&gt;The guide is split into three parts, each with a different purpose. First, we&#x27;ll talk about &quot;Rules of Thumb,&quot; which are usually the right thing to do. The second part is on what to use for writing concurrent code. And finally, we&#x27;ll cover how to write your custom concurrency primitives.&lt;/p&gt;&lt;p&gt;Before we start, I should mention that many of these recommendations will have conditions where they are not the best choice. The main situations are going to be performance and prototyping.&lt;/p&gt;&lt;h3&gt;Avoid Concurrency&lt;/h3&gt;&lt;p&gt;I&#x27;ve seen many times people using concurrency where you should not use it. It should go without saying, don&#x27;t add concurrency unless you have a good reason.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;var wg sync.WaitGroup

wg.Add(1)
go serve(&amp;amp;wg)
wg.Wait()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;p&gt;The concurrency here is entirely unnecessary, but I&#x27;ve seen this exact code in a repository. System without concurrency is much easier to debug, test and understand.&lt;/p&gt;&lt;p&gt;People also add concurrency because they think it will speed up their program. In a production environment, you are handling many concurrent requests anyways, so making one part concurrent doesn&#x27;t necessarily make the whole system faster.&lt;/p&gt;&lt;h3&gt;Prefer Synchronous API&lt;/h3&gt;&lt;p&gt;A friend of the previous rule is to prefer synchronous API. As mentioned, non-concurrent code is usually shorter and easier to test and debug.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;server.Start(ctx)
server.Stop()
server.Wait()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;p&gt;If you need concurrency when using something, it&#x27;s relatively easy to make things concurrent. It&#x27;s much more difficult to do the reverse.&lt;/p&gt;&lt;h3&gt;Use -race and t.Parallel()&lt;/h3&gt;&lt;p&gt;There are two excellent Go features that help you shake out concurrency bugs from your code.&lt;/p&gt;&lt;p&gt;First is -race, which enables the race detector to flag all the observed data races. It can be used with go test -race ./... or go build -race ./yourproject. See &lt;a href=&quot;https://go.dev/doc/articles/race_detector&quot;&gt;Data Race Detector&lt;/a&gt; for more details.&lt;/p&gt;&lt;p&gt;Second mark your tests with t.Parallel():&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func TestServer(t *testing.T) {
t.Parallel()
// ...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This makes your tests run in parallel, which can speed them up, but it also means you are more likely to find a hidden shared state that doesn&#x27;t work correctly in concurrent code. In addition to finding bugs in our codebases, we&#x27;ve also found them in third-party libraries.&lt;/p&gt;&lt;h3&gt;No global variables&lt;/h3&gt;&lt;p&gt;Avoid global variables such as caches, loggers, and databases.&lt;/p&gt;&lt;p&gt;For example, it&#x27;s relatively common for people to use log.Println inside their service, and their testing output ends in the wrong location.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func TestAlpha(t *testing.T) {
t.Parallel()
log.Println(&quot;Alpha&quot;)
}

func TestBeta(t *testing.T) {
t.Parallel()
log.Println(&quot;Beta&quot;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output from go test -v will look like:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;=== RUN   TestAlpha
=== PAUSE TestAlpha
=== RUN   TestBeta
=== PAUSE TestBeta
=== CONT  TestAlpha
=== CONT  TestBeta
2022/07/24 10:59:06 Alpha
--- PASS: TestAlpha (0.00s)
2022/07/24 10:59:06 Beta
--- PASS: TestBeta (0.00s)
PASS
ok      test.test       0.213s&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice how the &quot;Alpha&quot; and &quot;Beta&quot; are out of place. The code under test should call t.Log for any testing needs; then, the log lines will appear in the correct location. There&#x27;s no way to make it work with a global logger.&lt;/p&gt;&lt;h3&gt;Know when things stop&lt;/h3&gt;&lt;p&gt;Similarly, it&#x27;s relatively common for people to start goroutines without waiting for them to finish. &lt;em&gt;go &lt;/em&gt;keyword makes starting goroutines very easy; however, it&#x27;s not apparent that you also must wait for them to stop.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;go ListenHTTP(ctx)
go ListenGRPC(ctx)
go ListenDebugServer(ctx)
select{}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;g, ctx := errgroup.WithContext(ctx)
g.Go(func() error {
return ListenHTTP(ctx)
}
g.Go(func() error {
return ListenGRPC(ctx)
}
g.Go(func() error {
return ListenDebugServer(ctx)
}
err := g.Wait()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When you don&#x27;t know when things stop, you don&#x27;t know when to close your connections, databases, or log files. For example, some stray goroutine might use a closed database and cause panic.&lt;/p&gt;&lt;p&gt;Similarly, when you wait for all goroutines to finish, you can detect scenarios when one of the goroutines has become indefinitely blocked.&lt;/p&gt;&lt;h3&gt;Context aware code&lt;/h3&gt;&lt;p&gt;The next common issue is not handling context cancellation. It usually won&#x27;t be a problem in the production system itself. It&#x27;s more of an annoyance during testing and development. Let&#x27;s imagine you have a time.Sleep somewhere in your code:&lt;/p&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;tick := time.NewTimer(time.Minute)
defer tick.Stop()

select {
case &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;time.Sleep cannot react to any code, which means when you press Ctrl-C on your keyboard, it will stay on that line until it finishes. This can increase your test times due to some services shutting down slowly. Or, when doing upgrades on your servers, it can make them much slower to shut down.&lt;/p&gt;&lt;p&gt;&lt;em&gt;The code for the waiting on the right is much longer, but we can write helpers to simplify it.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;The other scenario where this cancellation comes up is long calculations:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;for _, f := range files {
data, err := os.ReadFile(f)
// ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;for _, f := range files {
if err := ctx.Err(); err != nil {
return err
}

data, err := os.ReadFile(f)
// ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here we can introduce a ctx.Err() call to check whether the context has been cancelled. Note ctx.Err() call is guaranteed to be concurrency safe, and it&#x27;s not necessary to check ctx.Done() separately.&lt;/p&gt;&lt;h3&gt;No worker pools&lt;/h3&gt;&lt;p&gt;People coming from other languages often resort to creating worker pools. It&#x27;s one of those tools that&#x27;s necessary when you are working with threads instead of goroutines.&lt;/p&gt;&lt;p&gt;There are many reasons to not use worker pools:&lt;/p&gt;&lt;ul role=&quot;list&quot;&gt;&lt;li&gt;They make stack traces harder to read. You&#x27;ll end up having hundreds of goroutines that are on standby.&lt;/li&gt;&lt;li&gt;They use resources even if they are not working.&lt;/li&gt;&lt;li&gt;They can be slower than spawning a new goroutine.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;You can replace your worker pools with a goroutine limiter -- something that disallows from creating more than N goroutines.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;var wg sync.WaitGroup
defer wg.Wait()
queue := make(chan string, 8)
for k := 0; k &amp;lt; 8; k++ {
wg.Add(1)
go func() {
defer wg.Done()
for work := range queue {
process(work)
}
}()
}

for _, work := range items {
queue &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;var wg sync.WaitGroup
defer wg.Wait()
limiter := make(chan struct{}, 8)
for _, work := range items {
work := work
wg.Add(1)
limiter &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We&#x27;ll later show how to make a limiter primitive easier to use.&lt;/p&gt;&lt;h3&gt;No polling&lt;/h3&gt;&lt;p&gt;Polling another system is rather wasteful of resources. It&#x27;s usually better to use some channel or signal to message the other side:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;lastKnown := 0
for {
time.Sleep(time.Second)
t.mu.Lock()
if lastKnown != t.current {
process(t.current)
lastKnown = t.current
}
t.mu.Unlock()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;lastKnown := 0
for newState := range t.updates {
if lastKnown != newState {
process(newState)
lastKnown = newState
}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Polling wastes resources when the update rates are slow. It also responds to changes slower compared to notifying directly. There are many ways to avoid polling, which could be a separate article altogether.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Of course, if you are making an external request and the external API is out of your control, you might not have any other choice than to poll.&lt;/em&gt;&lt;/p&gt;&lt;h3&gt;Defer unlocks and waits&lt;/h3&gt;&lt;p&gt;It&#x27;s easy to forget an mu.Unlock, wg.Wait or close(ch). If you always defer them, it will be much easier to see when they are missing.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;for _, item := range items {
service.mu.Lock()
service.process(item)
service.mu.Unlock()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;for _, item := range items {
func() {
service.mu.Lock()
defer service.mu.Unlock()

service.process(item)
}()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Even if your initial code is correct, then code modification can introduce a bug. For example, adding a return inside the loop after the mu.Lock() would leave the mutex locked.&lt;/p&gt;&lt;h3&gt;Don’t expose your locks&lt;/h3&gt;&lt;p&gt;The larger the scope where the locks can be used, the easier it is to make a mistake.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Set[T any] struct {
sync.Lock
Items []T
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Set[T any] struct {
mu    sync.Lock
items []T
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Name your goroutines&lt;/h3&gt;&lt;p&gt;You can make your debugging and stack traces much nicer by adding names to your goroutines:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;labels := pprof.Labels(&quot;server&quot;, &quot;grpc&quot;)
pprof.Do(ctx, labels,
func(ctx context.Context) {
// ...
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There&#x27;s an excellent article &quot;&lt;a href=&quot;https://rakyll.org/profiler-labels/&quot;&gt;Profiler labels in Go&lt;/a&gt;&quot;, which explains how to use them.&lt;/p&gt;&lt;h2&gt;Concurrency Primitives&lt;/h2&gt;&lt;p&gt;When it comes to writing production code, it&#x27;s a bad idea to use some concurrency primitives directly in your code. They can be error-prone and make code much harder to reason about.&lt;/p&gt;&lt;p&gt;When choosing primitives, prefer them in this order:&lt;/p&gt;&lt;ol role=&quot;list&quot;&gt;&lt;li&gt;no-concurrency&lt;/li&gt;&lt;li&gt;golang.org/x/sync/errgroup, golang.org/x/sync, sync.Once&lt;/li&gt;&lt;li&gt;custom primitive or another library&lt;/li&gt;&lt;li&gt;sync.Mutex in certain scenarios&lt;/li&gt;&lt;li&gt;select {&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;However, many others are useful when used for implementing your custom primitives:&lt;/p&gt;&lt;ol start=&quot;5&quot; role=&quot;list&quot;&gt;&lt;li&gt;sync.Map, sync.Pool (use a typesafe wrapper)&lt;/li&gt;&lt;li&gt;sync.WaitGroup&lt;/li&gt;&lt;li&gt;chan, go func() {&lt;/li&gt;&lt;li&gt;sync.Mutex, sync.Cond&lt;/li&gt;&lt;li&gt;sync/atomic&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;If you are surprised that chan and go func() { are so low on the list, we&#x27;ll show how people make tiny mistakes with them.&lt;/p&gt;&lt;h3&gt;Common Mistake #1: go func()&lt;/h3&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func (server *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
...
// start an async operation
go func() {
res, err := server.db.ExecContext(r.Context(), &quot;INSERT ...&quot;)
...
}()
...
}

func main() {
...

db, err := openDB(ctx)
defer db.Close()

err := server.Run(ctx)
...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice there&#x27;s no guarantee that the goroutine finishes before the database is closed. This can introduce weird test failure, where you try to insert into a closed database.&lt;/p&gt;&lt;p&gt;Similarly, another bug, r.Context() could be cancelled prematurely. Of course, this depends on the problem specifics, but when you start a background operation from your handler, you don&#x27;t want the user to cancel it.&lt;/p&gt;&lt;h3&gt;Primitive: sync.WaitGroup&lt;/h3&gt;&lt;p&gt;One of the solutions for starting goroutines is to use sync.WaitGroup. However, it also has quite a few problematic scenarios.&lt;/p&gt;&lt;p&gt;Let&#x27;s take a look at the first common mistake with sync.WaitGroup:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func processConcurrently(item []*Item) {
var wg sync.WaitGroup
defer wg.Wait()
for _, item := range items {
item := item
go func() {
process(&amp;amp;wg, item)
}()
}
}

func process(wg *sync.WaitGroup, item *Item) {
wg.Add(1)
defer wg.Done()

...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here the problem is that the processConcurrently can return before wg.Add is called. This means that we don&#x27;t wait for all the goroutines to finish.&lt;/p&gt;&lt;p&gt;The other scenario comes up when people incrementally change code:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func processConcurrently(item []*Item) {
var wg sync.WaitGroup
wg.Add(len(items))
defer wg.Wait()
for _, item := range items {
item := item
if filepath.Ext(item.Path) != &quot;.go&quot; {
continue
}
go func() {
defer wg.Done()
process(item)
}()
}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice how we moved the call to wg.Done outside of the process, making it easier to track the full concurrency. However, due to the extra if filepath.Ext statement, the code is wrong. That check was probably added by someone else at a later time. Similarly, it&#x27;s one of those cases where tests might easily miss the problem.&lt;/p&gt;&lt;p&gt;To fully fix the code, it should look like this:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func processConcurrently(item []*Item) {
var wg sync.WaitGroup
defer wg.Wait()
for _, item := range items {
item := item
if filepath.Ext(item.Path) != &quot;.go&quot; {
continue
}
wg.Add(1)
go func() {
defer wg.Done()
process(item)
}()
}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you don&#x27;t see the following parts when someone is using sync.WaitGroup, then it probably has a subtle error somewhere:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;var wg sync.WaitGroup
defer wg.Wait()
...
for ... {
wg.Add(1)
go func() {
defer wg.Done()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Use golang.org/x/sync/errgroup&lt;/h3&gt;&lt;p&gt;Instead of sync.WaitGroup there&#x27;s a better alternative that avoids many of these issues:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func processConcurrently(item []*Item) error {
var g errgroup.Group
for _, item := range items {
item := item
if filepath.Ext(item.Path) != &quot;.go&quot; {
continue
}
g.Go(func() error {
return process(item)
})
}
return g.Wait()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;errgroup.Group can be used in two ways:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;// on failure, waits other goroutines
// to stop on their own
var g errgroup.Group
g.Go(func() error {
return publicServer.Run(ctx)
})
g.Go(func() error {
return grpcServer.Run(ctx)
})
err := g.Wait()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;// on failure, cancels other goroutines
g, ctx := errgroup.WithContext(ctx)
g.Go(func() error {
return publicServer.Run(ctx)
})
g.Go(func() error {
return grpcServer.Run(ctx)
})
err := g.Wait()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can read &lt;a href=&quot;https://pkg.go.dev/golang.org/x/sync/errgroup#Group&quot;&gt;golang.org/x/sync/errgroup documentation&lt;/a&gt; for additional information. &lt;em&gt;Note, errgroup allows to limit the number of goroutines that can be started concurrently.&lt;/em&gt;&lt;/p&gt;&lt;h3&gt;Primitive: sync.Mutex&lt;/h3&gt;&lt;p&gt;Mutex is definitely a useful primitive, however you should be careful when you use it. I&#x27;ve seen quite often code that looks like:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func (cache *Cache) Add(ctx context.Context, key, value string) {
cache.mu.Lock()
defer cache.mu.Unlock()

cache.evictOldItems()
cache.items[key] = entry{
expires: time.Now().Add(time.Second),
value: value,
}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You might wonder, what&#x27;s the problem here. It&#x27;s appropriately locking and unlocking. The main problem is the call to cache.evictOldItemsand that it&#x27;s not handling context cancellation. This means that requests could end up blocking behind cache.mu.Lock, and even if they are cancelled you would need to wait for it to get unlocked before you can return.&lt;/p&gt;&lt;p&gt;Instead, you can use a chan *state, which allows you to handle context cancellation properly:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Cache struct {
state chan *state
}

func NewCache() {
content := make(chan *state, 1)
content &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Even though the evictOldItems call is still there, it won&#x27;t prevent other callers to Add to cancel their request.&lt;/p&gt;&lt;p&gt;Use sync.Mutex only for cases where you need to hold the lock for a short duration. Roughly it means that the code is O(N) or better, and N is small.&lt;/p&gt;&lt;h4&gt;Primitive: sync.RWMutex&lt;/h4&gt;&lt;p&gt;sync.RWMutex has all the same problems as sync.Mutex. However, it can also be significantly slower. Similarly, it makes it easy to have data races when you write to variables during RLock.&lt;/p&gt;&lt;p&gt;In your specific scenario, you should have benchmarks demonstrating that sync.RWMutex is faster than sync.Mutex.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Details: When there are a lot of readers and no writers, there&#x27;s a cache contention between the readers because taking a read lock mutates a mutex, which is not scalable. A writer attempting to grab the lock blocks future readers from acquiring it, so long-lived readers with infrequent writers cause long delays of no work.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Either way, you should be able to demonstrate that your use of sync.RWMutex is helpful.&lt;/p&gt;&lt;h3&gt;Primitive: chan&lt;/h3&gt;&lt;p&gt;Channels are valuable things in the Go language but are also error-prone. There are many ways to write bugs with them:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;const workerCount = 100

var wg sync.WaitGroup
workQueue := make(chan *Item)
defer wg.Wait()

for i := 0; i &amp;lt; workerCount; i++ {
wg.Add(1)
go func() {
defer wg.Done()
for item := range workQueue {
process(item)
}
}()
}

err := db.IterateItems(ctx, func(item *Item) {
workQueue &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is probably one of the common ones... forgetting to close the channel. Channels also make the code harder to review compared to using higher-level primitives.&lt;/p&gt;&lt;p&gt;Using chan for communicating between different &quot;goroutine processes&quot; in your application is fine; however, ensure that you handle context cancellations and shut down properly. Otherwise, it&#x27;s easy to introduce a deadlock.&lt;/p&gt;&lt;h3&gt;Few additional rules-of-thumb&lt;/h3&gt;&lt;p&gt;I&#x27;ve come to the conclusion that you should avoid these in your domain logic:&lt;/p&gt;&lt;ul role=&quot;list&quot;&gt;&lt;li&gt;make(chan X, N)&lt;/li&gt;&lt;li&gt;go func()&lt;/li&gt;&lt;li&gt;sync.WaitGroup&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;They are error-prone, and there are better approaches. It&#x27;s clearer to write your own higher-level abstraction for your domain logic. Of course, having them isn&#x27;t an &quot;end-of-the-world&quot; issue either.&lt;/p&gt;&lt;p&gt;I should separately note that using &quot;select&quot; is usually fine.&lt;/p&gt;&lt;h2&gt;Your own artisanal concurrency primitives&lt;/h2&gt;&lt;p&gt;I told you to avoid many things in domain code, so what should you do instead?&lt;/p&gt;&lt;p&gt;If you cannot find an appropriate primitive from golang.org/x/sync or other popular libraries... you can write your own.&lt;/p&gt;&lt;blockquote&gt;Writing a separate concurrency primitive is easier to get right than writing ad hoc concurrency logic in domain code.&lt;/blockquote&gt;&lt;p&gt;There are many ways you can write such primitives. The following are merely examples of different ways how you can write them.&lt;/p&gt;&lt;h3&gt;Sleeping&lt;/h3&gt;&lt;p&gt;Let&#x27;s take a basic thing first, sleeping a bit:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func Sleep(ctx context.Context, duration time.Duration) error {
t := time.NewTimer(duration)
defer t.Stop()

select {
case &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here we need to ensure that we appropriately react to context cancellation so that we don&#x27;t wait for a long time until we notice that context canceled the operation. Using this call is not much longer than time.Sleep itself:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;if err := Sleep(ctx, time.Second); err != nil {
return err
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Limiter&lt;/h3&gt;&lt;p&gt;I&#x27;ve found plenty of cases where you must limit the number of goroutines.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Limiter struct {
limit   chan struct{}
working sync.WaitGroup
}

func NewLimiter(n int) *Limiter {
return &amp;amp;Limiter{limit: make(chan struct{}, n)}
}

func (lim *Limiter) Go(ctx context.Context, fn func()) bool {
// ensure that we aren&#x27;t trying to start when the
// context has been cancelled.
if ctx.Err() != nil {
return false
}

// wait until we can start a goroutine:
select {
case lim.limit &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This primitive is used the same way as errgroup.Group:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;lim := NewLimiter(8)
defer lim.Wait()
for _, item := range items {
item := item
started := lim.Go(ctx, func() {
process(item)
})
if !started {
return ctx.Err()
}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Of course, if your limited goroutines are dependent on each other, then it can introduce a deadlock.&lt;/p&gt;&lt;p&gt;&lt;em&gt;AlsonNote that there&#x27;s a potential &quot;bug&quot; with using such a Limiter. You must not call limiter.Go after you have called limiter.Wait, otherwise the goroutine can be started after limiter.Wait has returned. This can also happen with sync.WaitGroup and errgroup.Group. One way to avoid this problem is to disallow starting goroutines after limiter.Wait has been called. It probably makes sense to rename it to &quot;limiter.Close&quot; in that case.&lt;/em&gt;&lt;/p&gt;&lt;h4&gt;Batch processing a slice&lt;/h4&gt;&lt;p&gt;Let&#x27;s say you want to process a slice concurrently. We can use this limiter to start multiple goroutines with the specified batch sizes:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Parallel struct {
Concurrency int
BatchSize   int
}

func (p Parallel) Process(ctx context.Context,
n, process func(low, high int)) error {

// alternatively, these panics could set a default value
if p.Concurrency &amp;lt;= 0 {
panic(&quot;concurrency must be larger than zero&quot;)
}
if p.BatchSize &amp;lt;= 0 {
panic(&quot;batch size must be larger than zero&quot;)
}

lim := NewLimiter(p.Concurrency)
defer lim.Wait()

for low := 0; low &amp;lt; n; low += p.BatchSize {
low, high := low, low + p.BatchSize
if high &amp;gt; n {
high = n
}

started := lim.Go(ctx, func() {
process(low, high)
})
if !started {
return ctx.Err()
}
}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This primitive allows to hide the &quot;goroutine management&quot; from our domain code:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;var mu sync.Mutex
total := 0

err := Parallel{
Concurrency: 8,
BatchSize: 256,
}.Process(ctx, len(items), func(low, high int) {
price := 0
for _, item := range items[low:high] {
price += item.Price
}

mu.Lock()
defer mu.Unlock()
total += price
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Running a few things concurrently&lt;/h3&gt;&lt;p&gt;Sometimes for testing, you need to start multiple goroutines and wait for all of them to complete. You can use errgroup for it; however, we can write a utility that makes it shorter:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func Concurrently(fns ...func() error) error {
var g errgroup.Group
for _, fn := range fns {
g.Go(fn)
}
return g.Wait()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A test can use it this way:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;err := Concurrently(
func() error {
if v := cache.Get(123); v != nil {
return errors.New(&quot;expected value for 123&quot;)
}
return nil
},
func() error {
if v := cache.Get(256); v != nil {
return errors.New(&quot;expected value for 256&quot;)
}
return nil
},
)
if err != nil {
t.Fatal(err)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There are many variations of this. Should the function take ctx as an argument and pass it to the child goroutines? Should it cancel all the other functions via context cancellations when one error occurs?&lt;/p&gt;&lt;h3&gt;Waiting for a thing&lt;/h3&gt;&lt;p&gt;Sometimes you want different goroutines to wait for one another:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Fence struct {
create  sync.Once
release sync.Once
wait    chan struct{}
}

// init allows to use the struct without separate initialization.
func (f *Fence) init() {
f.create.Do(func() {
f.wait = make(chan struct{})
})
}

// Release releases any waiting goroutines.
func (f *Fence) Release() {
f.init()
f.release.Do(func() {
close(f.wait)
})
}

// Released allows to write different select than
// `Fence.Wait` provides.
func (f *Fence) Released() chan struct{} {
f.init()
return f.wait
}

// Wait waits for the fence to be released and takes into account
// context cancellation.
func (f *Fence) Wait(ctx context.Context) error {
f.init()
select {
case &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When we use it together with Concurrently we can write code that looks like:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;var loaded Fence
var data map[string]int

err := Concurrently(
func() error {
defer loaded.Release()
data = getData(ctx, url)
return nil
},
func() error {
if err := loaded.Wait(ctx); err != nil {
return err
}
return saveToCache(data)
},
func() error {
if err := loaded.Wait(ctx); err != nil {
return err
}
return processData(data)
},
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Protecting State&lt;/h3&gt;&lt;p&gt;Similarly, we quite often need to protect the state when concurrently modifying it. We&#x27;ve seen how sync.Mutex is sometimes error-prone and doesn&#x27;t consider context cancellation. Let&#x27;s write a helper for such a scenario.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Locked[T any] struct {
state chan *T
}

func NewLocked[T any](initial *T) *Locked[T] {
s := &amp;amp;Locked[T]{}
s.state = make(chan *T, 1)
s.state &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then we can use it like:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;state := NewLocked(&amp;amp;State{Value: 123})
err := state.Modify(ctx, func(state *State) error {
state.Value = 256
return nil
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Async processes in a server&lt;/h3&gt;&lt;p&gt;Finally, let&#x27;s take a scenario where we want to start background goroutines inside a server.&lt;/p&gt;&lt;p&gt;Let&#x27;s first write out the server code, how we would like to use it:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;unc (server *Server) Run(ctx context.Context) error {
server.pending = NewJobs(ctx)
defer server.pending.Wait()

return server.listenAndServe(ctx)
}

func (server *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
...

started := server.pending.Go(r.Context(),
func(ctx context.Context) {
err := server.db.ExecContext(ctx, &quot;INSERT ...&quot;)
...
})
if !started {
if r.Context().Err() != nil {
http.Error(w, &quot;client closed request&quot;, 499)
return
}
http.Error(w, &quot;shutting down&quot;, http.StatusServiceUnavailable)
return nil
}

...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then let&#x27;s write the primitive:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Jobs struct {
root  context.WithContext
group errgroup.Group
}

func NewJobs(root context.Context) *Jobs {
return &amp;amp;Jobs{root: root}
}

func (jobs *Jobs) Wait() { _ = jobs.group.Wait() }

func (jobs *Jobs) Go(requestCtx context.Context, fn func(ctx context.Context)) bool {
// did the user cancel?
if requestCtx.Err() != nil {
return false
}
// let&#x27;s check whether server is shutting down
if jobs.root.Err() != nil {
return false
}

jobs.group.Go(func() error {
// Note, we use the root context and not the request context.
fn(jobs.root)
return nil
})

return true
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Of course, we can add a limiter, to prevent too many background workers to be started:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Jobs struct {
root  context.WithContext
limit chan struct{}
group errgroup.Group
}

func (jobs *Jobs) Go(requestCtx context.Context, fn func(ctx context.Context)) bool {
if requestCtx.Err() != nil || jobs.root.Err() != nil {
return false
}
select {
case &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Exercise: Retrying with backoff&lt;/h3&gt;&lt;p&gt;As a final exercise for the reader, you can try implementing a retry with backoff. The API for such a primitive can look like this:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;const (
maxRetries = 10
minWait = time.Second/10
maxWait = time.Second
)

retry := NewRetry(maxRetries, minWait, maxWait)
for retry.Next(ctx) {
...
}
if retry.Err() != nil {
return retry.Err()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Alternatively, it can be callback based:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;err := Retry(ctx, maxRetries, minWait, maxWait,
func(ctx context.Context) error {
...
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Additionally, consider where one would be better than the other.&lt;/p&gt;&lt;h2&gt;Additional resources&lt;/h2&gt;&lt;p&gt;There are many resources that can help you delve deeper.&lt;/p&gt;&lt;p&gt;You can find quite a lot of &lt;strong&gt;our own custom primitives&lt;/strong&gt; at &lt;a href=&quot;https://pkg.go.dev/storj.io/common/sync2&quot;&gt;&lt;strong&gt;storj.io/common/sync2&lt;/strong&gt;&lt;/a&gt;. This package contains most of our synchronization primitives. It contains things like &lt;em&gt;Sleep&lt;/em&gt; and &lt;em&gt;Concurrently&lt;/em&gt;, but also more advanced things like &lt;em&gt;Cycle&lt;/em&gt;, &lt;em&gt;ReadCache&lt;/em&gt; and &lt;em&gt;Throttle&lt;/em&gt;. We also have problem specific implementations of &lt;a href=&quot;https://github.com/storj/storj/blob/main/satellite/metainfo/piecedeletion/combiner.go#L15&quot;&gt;&lt;strong&gt;Combiner&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/storj/storj/blob/6df867bb3d06240da139de145aaf88077572b4b8/satellite/metainfo/piecedeletion/queue.go#L10&quot;&gt;&lt;strong&gt;Queue&lt;/strong&gt;&lt;/a&gt; that implement a combiner queue. This primitive allows to dial storage nodes, coalesce multiple deletion requests into a single request.&lt;/p&gt;&lt;p&gt;One of the best talks about Go concurrency is &quot;&lt;a href=&quot;https://www.youtube.com/watch?v=5zXAHh5tJqQ&quot;&gt;&lt;strong&gt;Rethinking Classical Concurrency Patterns&lt;/strong&gt;&lt;/a&gt;&quot; by &lt;strong&gt;Bryan C. Mills&lt;/strong&gt;. He discusses problems with worker pools and sync.Cond in-depth.&lt;/p&gt;&lt;p&gt;When you struggle with understanding data-races, then &quot;&lt;a href=&quot;https://greenteapress.com/wp/semaphores/&quot;&gt;&lt;strong&gt;Little Book of Semaphores&lt;/strong&gt;&lt;/a&gt;&quot; by &lt;strong&gt;Allen B. Downey&lt;/strong&gt; is an excellent resource. It contains many classic problems and exercises to get your brain noticing them.&lt;/p&gt;&lt;p&gt;There has been also some research on the topic &quot;&lt;a href=&quot;https://songlh.github.io/paper/go-study.pdf&quot;&gt;&lt;strong&gt;Real-World Concurrency Bugs in Go&lt;/strong&gt;&lt;/a&gt;&quot; by &lt;strong&gt;Tengfei Tu&lt;/strong&gt; et. al. It contains many additional issues not mentioned in this post.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>