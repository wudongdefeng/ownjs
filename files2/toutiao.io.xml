<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>09656ad2193226ceb6618ab42a51dcb2</guid>
<title>Solidity 非权威开发指南（5）：合约升级</title>
<link>https://toutiao.io/k/trqwnd7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;markdown编辑器&quot; data-website=&quot;https://markdown.com.cn/editor&quot;&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;所有以太坊开发者都清楚以太坊世界的一条铁律：合约一旦发布就无法修改。因此，对于合约的发布基本上都采用一种慎之又慎的态度，期望在发布前可以做到尽善尽美，力争合约能正常运行一万年。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;可是，智者千虑必有失，合约发布百分百不出问题几乎是不可能任务。一些小问题或许还可以通过类似口头约定的方式让大家克服克服，但对于重大问题，恐怕就不得不重新发布新版了。于是乎，一系列连带更新也随之而来：合约调用方、封装合约的 SDK/API 方……搞不好还会牵涉到下一级的连带更新。比如，调用该合约的合约将地址硬编码到代码里且没有提供 setter 来改变该值……太麻烦啦！&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;鉴于此，可升级合约的呼声越来越高，同时也衍生了各类方案。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是可升级合约&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;“可升级”意味着可修改，这似乎与以太坊强调的 immutable 相矛盾。但让我们再深入思考一下“可升级”的内涵：&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;合约地址不能变&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;合约状态不能丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;合约的行为可变&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;编程经验丰富的老兵此时应该会拍大腿大声叫道：&lt;strong&gt;引入一个中间层就可以做到！&lt;/strong&gt; 的确如此，可升级合约技术方案的本质就是：proxy + implementation 的分离，见下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2857142857142857&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Kh4dSb0w5FXRLVJ5w6iathtd2kDwxUehoA4OplgaGe3ktaiaJhEoNSSMic7JhacibDZn8PnUJ6j3Nl17N4oqVLsgIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;其中：&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;proxy 作为调用方和实现方的中间人使“地址不变”成为可能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 implementation 的状态保存于 proxy 中使“状态不丢失”成为可能，这一点只需在 proxy 中使用 &lt;code&gt;fallback&lt;/code&gt; + &lt;code&gt;delegatecall&lt;/code&gt; 将调用转发给 implementation 即可实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可动态注入不同的 implementation 使得“行为可变”成为可能。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;可参见本系列的第二篇快速了解 solidity 语法。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;How-To&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;使用 OpenZepplin Upgrade Plugin 可以让编写可升级合约的事情变得简单，并且考虑到 OpenZepplin 已成为合约开发中事实上的标准库以及编写可升级合约的种种限制，建议无脑采用，最简例子见下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pragma solidity ^0.8.9;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;contract MyContract is Initializable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256 public x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    function initialize(uint256 _x) public initializer {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        x = _x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// SPDX-License-Identifier: UNLICENSED&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pragma solidity ^0.8.9;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;./MyContract.sol&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;contract MyContractV2 is MyContract {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256 public y;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ts&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import { ethers, upgrades } from &quot;hardhat&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;async function main() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  const MC = await ethers.getContractFactory(&quot;MyContract&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  const mc = await upgrades.deployProxy(MC, [42]);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  await mc.deployed();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  console.log(&quot;MyContract deployed to:&quot;, mc.address);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;main();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ts&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import { ethers, upgrades } from &quot;hardhat&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;const MC_ADDRESS = &quot;部署脚本显示的地址&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;async function main() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  const MCV2 = await ethers.getContractFactory(&quot;MyContractV2&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  await upgrades.upgradeProxy(MC_ADDRESS, MCV2);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  console.log(&quot;MyContract upgraded&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;main();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;注意事项：&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;记得在 &lt;code&gt;hardhat.config.ts&lt;/code&gt; 中引入下面语句完成初始化。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ts&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;@openzeppelin/hardhat-upgrades&quot;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;上述脚本需要 network 参数，即至少要运行本地测试网络：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;npx hardhat node&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;编程限制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;编写可升级合约并不是 free style，必须遵循一定的规矩。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制 1：跟构造函数 say no&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;原因在于两点：&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从语言限制上来讲，构造函数在合约部署后不属于合约的 runtime bytecode，可简单理解为部署后就消失不见了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从逻辑上来讲，构造函数的执行应该只有一次，即使在升级的背景下，也应遵循这个原则。但是，升级合约的实质是“部署并替换”，这种情况下无法保证这一点。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;因此，可以看到，在上面的例子中都没有使用构造函数，转而使用所谓的 &lt;code&gt;initialize()&lt;/code&gt; 来完成初始化。同时，为了保证该函数只运行一次，还使用了 OpenZepplin 提供的 &lt;code&gt;initializer&lt;/code&gt; modifier。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;同理，也不要使用初始化声明，即类似下面的语句：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;uint256 public hasInitialValue = 42; // X&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;但是，&lt;code&gt;constant&lt;/code&gt; 例外，即以下语句没有问题：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;uint256 public constant hasInitialValue = 42 // √&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制 2：initialize() 只能执行一次&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;原因：见上。代码实现的注意点：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;合约继承 &lt;code&gt;Initializable&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;initializer&lt;/code&gt; modifier&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用依赖注入来获得灵活性，上例就是如此，避免在该函数中使用硬编码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在合约构造函数中调用 &lt;code&gt;_disableInitializers()&lt;/code&gt;，这主要是出于安全考虑。这时构造函数为：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/// @custom:oz-upgrades-unsafe-allow constructor&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;constructor() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    _disableInitializers();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制 3：父合约的初始化也遵循 1&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;原因依旧同 1。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;对于父合约，同样不能有构造函数，所有的初始化代码需挪到 &lt;code&gt;initialize()&lt;/code&gt; 中，只是此时不能使用 &lt;code&gt;initializer&lt;/code&gt; modifier，而需用 &lt;code&gt;onlyInitializing&lt;/code&gt; modifier 来代替。原因也很简单：若是前者，一旦被子合约的初始化函数调用，父合约的初始化函数就只能执行一次，显然不合继承的语义。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;OpenZepplin 提供了 @openzeppelin/contracts-upgradeable 来帮助已经熟悉了 @openzeppelin/contracts 的开发人员来编写可升级合约。前者提供了后者合约的可升级版，如 &lt;code&gt;ERC721Upgradeable.sol&lt;/code&gt; 对应 &lt;code&gt;ERC721.sol&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制 4：可兼容的存储布局&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;其中原因在于 solidity 的语言技术细节，未来会有专文细说。在此只需记住以下规则：相对于老版本合约，&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新版本合约中的变量声明&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;当继承多个合约时，新版本的继承顺序不变&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;父合约中的变量声明同样需要遵循：&lt;/section&gt;&lt;/li&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;注意&lt;/p&gt;&lt;p&gt;规则 3 于 1 的区别：没有“只增不删”！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;其原因很容易理解，因为在父合约中新增变量后会破坏子合约的存储布局。但问题是父合约本身也会演化，必然也有新增变量的需求。为了解决这个问题，可以使用 storage gap 的技巧来解决。说白了，就是：预留存储。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// v1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;contract Base {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256 base1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256[49] __gap;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// v2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;contract Base {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256 base1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256 base2;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256[48] __gap;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;上述代码中，v1 和 v2 的 Base 是存储布局兼容的。&lt;/p&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;注意&lt;/p&gt;&lt;p&gt;变量类型的长度关系重大，若使用 uint128，则可用两个。即：用连续两个 uint128 变量替代一个 uint256 变量。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制 5：不要在子合约使用危险操作，如 &lt;code&gt;delegatecall&lt;/code&gt; 和 &lt;code&gt;selfdestruct&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;原因：当 implementation 地址已知后，其他第三方可以不通过 proxy 直接调用它。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;虽然你可以在 implementation 里限制调用方的地址，但并不是所有情况下都可以这么做。因此避免危险操作是上策。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制 6：确保使用可升级库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;范围： import 的合约和 lib，确保它们可以正常工作于可升级场景。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;除了 OpenZeppelin，还可以看看这个库 solidstate-solidity。正如其 readme 所言：&lt;strong&gt;Upgradeable-first Solidity smart contract development library .&lt;/strong&gt; 未来或许有介绍它的专门文章。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Proxy Patterns&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;proxy 是可升级合约的底层技术基础，了解其典型模式有助于更好地编程。典型的 proxy pattern 有：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Transparent Proxy&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UUPS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Beacon&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Diamond&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;OpenZeppelin 对于前三者提供了支持，暂时不支持 diamond。相比起前三者，diamond 更复杂并且野心也更大，期望提供一种通用的支持可扩展合约开发的架构模式，它在 solidstate 中得到了广泛的应用。但由于相对复杂，此文略过。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;对于前三种：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Beacon 的应用范围不如前两种广泛，但它支持不同代理升级到不同实现；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;但个人认为，若真是有这样的需求，不如直接采用 diamond 可能更好。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Transparent Proxy 拥有更长的历史，OpenZeppelin 的可升级库最早基于它完成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UUPS 则属于后起之秀，相比 Transparent Proxy，它更轻量也更通用，这也意味着它的升级逻辑更便宜。因此 OpenZeppelin 推荐优先使用它。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;在 OpenZeppelin 合约库中，三种 proxy pattern 都有对应的实现，并且文档也提供了相应的示例和部署/升级脚本，在此就不再赘述。由于文档中并没有给出 UUPS 的范例，这里简单的描述一下。针对前面的例子：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pragma solidity ^0.8.9;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;contract MyContractUups is UUPSUpgradeable, OwnableUpgradeable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256 public x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    function initialize(uint256 _x) public initializer {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        x = _x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        __Ownable_init();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;其他的 v2 合约和部署/更新几乎一样。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Transparent Proxy、UUPS 和 Beacon 的主要区别主要两点：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;是否需要 proxy admin&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 Transparent Proxy 中，该组件负责完成 upgrade 逻辑。但 UUPS 和 Beacon 中都没有它。因此，Transparent Proxy 存在有 admin owner 的概念，同时其 ownership 也可以转移。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UUPS 的升级逻辑由 implementation 完成，可以看到上面的代码示例中，它覆盖了 &lt;code&gt;_authorizeUpgrade&lt;/code&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Beacon 的升级逻辑则由 beacon 的 owner 完成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;在哪存放 implementation 的地址&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Transparent Proxy 和 UUPS 都将该地址存在 proxy 合约中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Beacon 则将其存放在 beacon 合约里。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其余细节&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;EIP1882&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;支撑 UUPS 的标准是 EIP1822，有兴趣的可以自行了解。此外，从 OpenZepplin 的接口文档和代码也可了解其细节。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;EIP1967&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;关于 implementation 的地址保存，前文说过：它存放于 proxy 合约中。但同时，支撑 proxy 的技术基础又是 delegatecall。它的特性是执行的上下文是 caller 的上下文而非 callee 的上下文。即，任何状态的变化其实发生在 caller 的空间。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;那么随之而来的问题是：如果 proxy 中自己有变量定义，同时将调用转发给 implementation 时又会保留它的状态，那么此时必然会导致有冲突。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Kh4dSb0w5FXRLVJ5w6iathtd2kDwxUehoZXjplcfFqqAw04NvZibsGo59YIxMUJOJOmA3Jic9ZV402Nda5UNfxiaDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;EIP1967 便是为了解决这个问题，定义了一组标准存储槽来解决这个问题。本质上是对 proxy 中的变量存储槽进行了伪随机化处理。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;函数冲突&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;即 proxy 和 implementation 中出现同名函数时，到底该不该转发？这可以通过 caller 来处理，以 Transparant Proxy 为例：&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;至此，关于可升级合约的基本要点已经罗列完成，剩下的就是去挖掘相关的代码和文档啦！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f79fea7d8b1da936bfcd133e98f24c86</guid>
<title>从 Kubernetes 争霸过程看 Google 开源套路</title>
<link>https://toutiao.io/k/kqd2i5k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3718120805369127&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/K1sI6IqaK7bHboPiaLKm8MMRaf1aURSewatq3uvicibjDQyjPVIEzc5k5oDKaURKAs4vuXIgrrvWEK0uT2yMDXXUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;745&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、先说结论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;首先、&lt;span&gt;云原生时代到&lt;/span&gt;&lt;span&gt;了，大家已经不再仅仅满足于Docker构建镜像，企业用户更需要编排、管理和调度。其次，而Kubernetes作为Google内部秘密从头开发的 Borg2.0 版本，一诞生就具有完整的功能和良好的扩展架构，很多方面都已经吊打其他0.1版本的竞品了。不仅仅如此，Kubernetes的金主爸爸拥有如此核弹头级别的大杀器，为了占领市场居然完全不要钱完全开源免费白送（这和早期微软系统在国内坐视盗版免费占领市场有类似的效果）。不仅不要钱，还拉帮结派找了红帽等很多小弟构建CNCF基金会（是不是很安卓的开放手机联盟很像），生生造出一个基金会标准和生态降维打击竞品。真是占据了天时（云原生时代）地利（Brog2.0）人和（开源+基金会）等要素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，其中也有劣势：就是Docker和Hadoop等开源项目抢了Google内部系统的风头，提前占领了开源屌丝市场（这也正是Google后来在开源疯狂砸钱的原因，当然最近已经控制了云原生平台后就开始砍开源经费了）。Docker通过内置的Swarm来获得前期的竞争优势。正如大家害怕微软IE一家独大的局面再次上演，Google敏锐地抓住了这个机会很好地通过合纵连横策略打败了Docker。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、Kubernetes争霸简史&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Docker是一个开发、交付和运行应用程序的开放平台，开发者可以在此打包他们的应用及依赖到一个可移植的容器中，然而发布到运行平台上。&lt;/span&gt;&lt;span&gt;在Docker走红之前LXC已经在一些公司内部得到应用。&lt;/span&gt;&lt;span&gt;比如，2008年Google推出的PaaS平台 GAE（Google App Engine）就采用了LXC。&lt;/span&gt;&lt;span&gt;在GAE中Google使用了一个能够对LXC进行编排和调度的工具Borg——后来Kubernetes借鉴了它的很多设计。&lt;/span&gt;&lt;span&gt;整体而言LXC的应用范围不广，主要是一些有技术实力的大公司在应用。&lt;/span&gt;&lt;span&gt;LXC虽然解决了应用的隔离，但并没有解决可移植性问题，而这个问题被Docker完美地解决了。&lt;/span&gt;&lt;span&gt;Docker有三个最重要的概念：&lt;/span&gt;&lt;span&gt;镜像、仓库、容器，其中镜像是基石，也是Docker最重要的创新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，Docker只是满足了应用软件生命周期中的一部分需求，随着越来越多的企业开始采用Docker技术来开发和部署应用，特别是要规模化部署应用，它们发现自己面临一个现实的问题，就是要对多个容器进行编排、管理和调度。&lt;/span&gt;&lt;span&gt;就在这个时候，Google带着Kubernetes下场了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Google是云计算概念的最早提出者，不仅有PaaS平台GAE，还有Google云GCP，但提到云计算人们首先提到的却是AWS，Google的存在感很弱。&lt;/span&gt;&lt;span&gt;多年运行GCP和Borg的经验，使得Google非常认可容器技术，也深知目前Docker在规模化使用场景下的不足。&lt;/span&gt;&lt;span&gt;Google从当时大火的容器市场看到了机会，而且这里也存在一些商业机会：&lt;/span&gt;&lt;span&gt;如果容器得到广泛应用，那些在AWS运行的应用就有可能自由地移植到GAE和Google云上运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2013年夏天，Kubernetes联合创始人Craig McLuckie和Joe Beda、Brendan Burns等开始讨论容器编排系统的开发，并决定采用开源的方式来开发这个系统。&lt;/span&gt;&lt;span&gt;经过多次找机会向Google高层游说，最后这个项目终于被Google批准开源。&lt;/span&gt;&lt;span&gt;并首次在2014年6月举行的DockerCon 2014大会上正式发布。&lt;/span&gt;&lt;span&gt;实际上并不是只有Google看到了容器市场的新需求，就在DockerCon 2014大会上，就有多家公司推出了自己的容器编排系统。&lt;/span&gt;&lt;span&gt;其中有影响力的还有Docker、Mesos等，而Google的进场让原本就竞争激烈的容器编排市场火上浇油。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;ocker也希望提供更多平台层能力，向PaaS进化，为企业最终要部署的网站、服务、数据库，是云计算业务提供解决方案——这才是Docker的目标。&lt;/span&gt;&lt;span&gt;2014年7月，Docker收购OrchardLabs正式开始涉足容器编排领域，Orchard Labs的容器编排工具fig当时很有名，这个fig就是DockerCompose的前身。&lt;/span&gt;&lt;span&gt;Docker Compose虽然能编排多个容器，但是只能对单个服务器上的容器进行操作，而不能实现在多个机器上进行容器的创建和管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2015年初Docker发布Swarm，算是正式向Kubernetes宣战了。&lt;/span&gt;&lt;span&gt;在容器规模较小的场景下，许多用户更喜欢使用Docker Swarm，因为它平滑地内置于Docker平台中。&lt;/span&gt;&lt;span&gt;如果Docker Swarm能成功，那Docker就将通吃容器市场，这就和CoreOS、Red Hat等一些公司产生了利益冲突，这为Docker后来的败退埋下了伏笔。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;Kubernetes的成长过程中，CoreOS发挥了重要作用。&lt;/span&gt;&lt;span&gt;Docker容器发布以后，CoreOS将这一技术集成到自己的操作系统中，2014年发布了自己容器编排框架fleet，这是最早提供云环境自动部署和调度集群资源的容器软件之一。&lt;/span&gt;&lt;span&gt;Kubernetes出现后，CoreOS放弃了fleet而转向了Kubernetes，并后来推出了容器运行时rkt来替换Docker的容器运行时RunC。&lt;/span&gt;&lt;span&gt;2018 年1月30日，红帽斥资 2.5 亿美元收购了CoreOS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Kubernetes项目中，红帽是仅次于Google的重要角色。&lt;/span&gt;&lt;span&gt;红帽的OpenShift是最早一批PaaS平台（2011年发布，和Cloud Foundry同一年）之一。&lt;/span&gt;&lt;span&gt;2013年9月，Docker大火的时候，红帽将Docker嵌入到红帽Linux企业版RHEL中，并完全重建了OpenShift。&lt;/span&gt;&lt;span&gt;作为一个PaaS平台，也需要容器编排功能，红帽需要选一个。&lt;/span&gt;&lt;span&gt;红帽在得知Kubernetes项目并最终开源后果断放弃和Mesos合作选择了Kubernetes。&lt;/span&gt;&lt;span&gt;2015年6月，OpenShift Enterprise 3在红帽峰会上发布，其中内嵌了Docker和Kubernetes，这给Kubernetes后来的成功打下了坚实的基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mesos是容器编排市场上另一个主要玩家。&lt;/span&gt;&lt;span&gt;Mesos最初是加州大学伯克利分校的一个项目，目的是创建下一代集群管理器，一直在努力提高集群的利用效率和性能。&lt;/span&gt;&lt;span&gt;作为一个面向资源管理的项目，容器编排其实只是其中的一个功能模块，叫Marathon。&lt;/span&gt;&lt;span&gt;Mesos在2014年成为首批支持Docker容器的容器编排框架之一。&lt;/span&gt;&lt;span&gt;实际上Mesos不仅仅可以支持Docker，还可以支持Java应用集群。&lt;/span&gt;&lt;span&gt;Mesos的最大优势是它在运行关键任务时的成熟度，它比其他许多的容器技术更成熟，2015年Kubernetes 1.0刚出来时也只具有管理100台服务器的能力，而Mesos当时已经有管理上万台机器的案例。&lt;/span&gt;&lt;span&gt;Mesos被Twitter、苹果（Siri）、Netflix等公司所采用。&lt;/span&gt;&lt;span&gt;相比Docker与Kubernetes，Mesos侧重在传统的资源管理，不如前两者天生是面向多云和集群的，它在应对多云和集群管理时面临很多新的挑战。&lt;/span&gt;&lt;span&gt;后来随着外部竞争的恶化逐渐淡出了历史舞台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kubernetes脱胎于已经在Google内部运行了多年的Borg项目，但并没有直接延用Borg，属于Borg2.0版本。&lt;/span&gt;&lt;span&gt;Kubernetes设计了一套稳定可扩展的API接口、预置服务发现、容器网络、及可扩展等关键特性。&lt;/span&gt;&lt;span&gt;其概念抽象非常符合理想的分布式调度系统。&lt;/span&gt;&lt;span&gt;Kubernetes的一个成功之处就是提供了一个规范，可以让你描述集群的架构、定义服务的最终状态，由它来帮助你的系统达到和维持在这个状态。&lt;/span&gt;&lt;span&gt;同时和Docker、Mesos相比，Kubernetes强大的生态为应用程序开发人员提供了丰富强大的工具，用于编排无状态的Docker容器，让开发人员减少了对基础设施和操作团队的依赖。&lt;/span&gt;&lt;span&gt;另外，Kubernetes作为CNCF下的开源项目，使得它与Docker相比更容易得到认可和支持。&lt;/span&gt;&lt;span&gt;相比Docker后来将Swarm全部内置到Docker项目，完全是和Kubernetes整个社区竞争。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Docker虽然以创新性的技术通过开源社区取得了巨大的成功，但是在独自对抗Google、红帽巨头乃至整个云计算产业最后以失败收场。&lt;/span&gt;&lt;span&gt;不仅仅是Docker，其他云厂商也失去了一家独大的可能，而 Google 则成为了云原生的最大赢家。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、类似案例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;类似的案例还有很多，比如Chrome、Firefox通过免费打败IE，比如安卓联盟通过开放手机联盟打败诺基亚、Windows Phone，WASM通过免费/标准在浏览器领域打败Flash、JVM、ActiveX。而作为一个反面教材，Qt因为缺少真正的盟友而失去了进一步发展壮大的机会。总结而言，首先东西要好，但不能吃独食，所以还需要一个不差钱的金主爸爸。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5057471264367817&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K1sI6IqaK7a9yqzqNrGQzz5syNFibkOyDxRn4uEFpsricnNLBiaefqqgxlB9wDibGHhHiaM5PVtBHaY2obIhpSCnicdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;522&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8312a4598cf3a7194a444ef9f7b2268f</guid>
<title>Java 应用上云后被 kill 问题分析与解决</title>
<link>https://toutiao.io/k/th616z9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;246&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFt7tV2c2jtpwQxziaCpO0DmgAv1lgEN2niayVWYbKUYxmqpM2AWAlkpTrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作者&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;92600&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-role=&quot;circle&quot; data-width=&quot;100%&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YE1dmj1Pw7lCBD0jNG4KrPrs1QcStP0KfRK1jwkibIiauY5Xyib2044asfJy5gUjkiadibhTGKzJFeF6YkIadfcFoicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;80&quot; title=&quot;微信图片_20230112103059.jpg&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;李杰&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;2020年2月份加入去哪儿旅行酒店报价中心研发团队，云原生SIG成员，主要负责国内酒店报价实时和离线计算模块的研发和维护。喜欢钻研云原生相关开发，完成JVM参数校验功能，解决容器应用的OOM被kill等问题。&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自从公司 2021 年 11 月份开始全面容器化后，酒店报价中心团队快速响应，迁移了 98% 的应用，由原来的 kvm 或实体机器到容器上，我们的多个应用出现了频繁被 kill 的情况，主要包括两大类：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;本文主要介绍发现问题以及解决问题的过程。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题一：应用长时间 GC&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;应用 GC 时间长导致 k8s 检活失败，k8s 会 kill 掉业务应用。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;182&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.315625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtxN7TpY8pVRBmv3Me4qpyRpuXEceqRFmicZZicqjiaYr1Rtia2GKHYorbUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当时我们团队的两个应用在发布到 docker上以后，出现了频繁重启的现象，发布后一天内重启次数高达 29 次左右，提示也仅仅是 “时间：2021-11-25T21:34:58+08:00 原因：Error kill” 看不到具体的问题，只能到对应的容器内部去寻找线索了。具体排查过程如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1、确认为啥会被 kill ？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;164&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2836676217765043&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtVwUKT6VhaBCg06eGfvlmOPDCygQiaZtmdQMtNicx8uvMfATibu4SiaFUKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;698&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;215&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.37265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFticcRoakF9mzX3eod2eBxOPy3Dv0aTTwJ0UNMqhPAiama52R7EC9Bxm8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;首先通过 dmesg 命令，查看容器所在主机上的日志。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;发现是存在 OOM kill 掉的 Java 应用，但是对比了下这个 total-vm 和我们自己的应用配置发现差别很大，不是我们的应用进程，我们的配置是：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;153&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.26484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtzAzbJA7tZ9iasxlOfuyXibvK4YX10ibrT2J8ypLGxanaspudJw2nib81MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;舍弃了这个方向后转向了 k8s 的日志（ps：为啥第一次不看这个，是因为这个日志的查看时需要权限的，前期没有权限，只能自己动手先看方便的），发现了在被 kill 之前出现了3次 unhealthy 的 k8s 日志，且返回请求状态不是200。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;250&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtTfdaVT9INjS9TK93mtWo8cHht0bU9t42vACLhmx9kSDJhnNhLeKJbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看下为什么会有检活请求异常，检查业务访问日志，发现这个时间点是有接收到请求，手动访问也是成功的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是当时为啥会有访问状态不是 200 的问题呢？怀疑当时业务进程是有大量任务在跑，响应超时问题导致， 所以开始排查业务的具体日志。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2、发现问题&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在排查日志的时候发现了导致该问题的根本原因，本质是 GC 时间过长导致。查看重启前的容器 GC 日志：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;260&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.44921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtGal2ibYtQIBhz12Y1jIn2ZNAu2BLgd1On1aWgdSIgxLLj9R8I1Kmtkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;容器被重启是在 2021-11-25T21:34:58+08:00 重启的。在这个时间点前，也就是被 kill 之前的一次 GC 时间高达 18s + 7s 。至此，原因就很清晰了：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为应用进程的 GC 导致服务不能正常响应 k8s 的检活请求，k8s 认为应用“死”了，触发了 kill 和重启操作！&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过 GC 日志，分析主要耗时点。推荐 GC 分析工具：https://gceasy.io/，调整 JVM参数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;k8s 调整了检活机制，由原来超时 10s、20s，最后调整为 2min。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过分析日志发现主要的长时 GC 是因为新生代晋升失败，扩大 young 区和堆大小优化 JVM 参数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题二：内存碎片&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;问题现象是应用管理平台上出现了容器 “OOM kill” 的提示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;49&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.08515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtzmLzR0bOWPWdjOfnheJSicGLWcg1cu69LmSaib9mzBfz5p9K1DS1DghQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于 OOM kill 的提示，开始分析应用日志，发现堆区、栈区并没有出现 OOM 的问题，怀疑是堆外内存内存溢出导致，因此，尝试添加相应的JVM参数以观察堆外内存的使用情况。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;95&quot; data-backw=&quot;300&quot; data-ratio=&quot;0.31666666666666665&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtU1Joo1oXwFHbQ9LqK4GcRxJw4D2jCEDA7rEqMz8q41gaaKwxDcFMhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;观察是否是有堆外内存没有释放，再加上 OOM 没有明显征兆，写了脚本定时 30s 看下使用情况。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;363&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6290322580645161&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFt5qL4wGf5AORmL2BXOia0hpuKDe5RyRCAexTiboxzrNfjfiar6QkVnmiaiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图是在容器启动后的 1 分钟 到 容器即将被 kill 时的 JVM 内存分配对比图：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;282&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.48828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtMSLERcBwRWC6snj00VtXnAurgJDGibjuNzcrFicsXB5NEibQSPLH8O4OA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;187&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.32421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtXiaG8WmiaAYo0n3c428KDZP9lpXNica9ZO6F5DnTt7SzRPbjS4NoqQaPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;发现 JVM 的使用内存并没有明显变化（12491M→ 12705M），且整体没有超过 docker 分配的内存限制（docker limit Memory:12G），但是为什么会有 OOM 呢？哪块的内存使用升高导致了 OOM 呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;查询了大量的资料，排查方向转向内存这块。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用 pmap 分析 Java 进程的内存映射关系：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;177&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.30546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtZxBdrDApKC1lBzv2WMGbZwlqBzIIG41ibt39cebVibabGeXsQFuX9TkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;369&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFthC5EmEDvnl7wvTQich7ZWiay3X8yFP65Fc4qPXTNibvMLyxGeNCeQFK9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pmap说明&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Address: 内存开始地址&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Kbytes: 占用内存的字节数（KB）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;RSS: 保留内存的字节数（KB）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Dirty: 脏页的字节数（包括共享和私有的）（KB）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Mode: 内存的权限：read、write、execute、shared、private (写时复制)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Offset: 文件偏移&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Device: 设备名 (major:minor)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;发现可疑的地方有两个 1029712KB（1005M）的内存块和较多64M内存块，linux 默认使用的 glibc 的 ptmalloc 内存分配器，有这个问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Glibc为什么会有64M的内存块的问题？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在进程申请内存时，根据需要分配的内存大小由内存分配器来想内核申请具体的内存区域，那么为什么会有内存分配器来申请内存，而不是进程直接向系统申请呢？因为系统调用的开销比较大，这样做是非常不值的。同时，在 linux下分配堆内存需要使用 brk系统调用，而这个系统调用只是简单地改变堆顶指针而已，也就是将堆扩大或者缩小。举个例子，进程分别申请了 M2 和 M1 两块内存，运行了一段时间后，M2 内存不需要了，需要回收了。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;315&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtOoH1dDE3ZbIxOb8hR9rZNZJlSx4PC8wfdaAriaGcamicYyOgwDznqYQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用系统处理的话，只能使用 brk 移动指针，那么 M1 也会被回收掉，这样显然是不行的。所以引入内存分配器，把 M2 的内存缓存下来，等到进程需要再次申请内存空间时不需要使用系统调用，而是直接从缓存中分配，这个动作就是由内存分配器完成的。内存分配器不仅提升了运行效率，还提高了内存的使用率。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;195&quot; data-backw=&quot;578&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtpADTYiazRiau2SL1dHxonCuTvGpZXXUxrqD8DU8mNex8QvQNiaIztfrLg/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1180&quot; data-cropy1=&quot;38.78892733564014&quot; data-cropy2=&quot;436.88581314878894&quot; data-ratio=&quot;0.33728813559322035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtP5XcxLs0MM253LpUfK5vhOiaSSmSbxPdVkq4YTKUssO4WL4voYY4W2A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1180&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;glibc 的内存分配器（ptmalloc）的结构如图所示，一个进程就有一个主分配区和若干个从分配区。所有的线程申请内存时，都要经过主分配区申请，多线程时就需要通过锁机制来保证分配的正确性，从分区就应运而生了，ptmalloc 根据系统对分配区的争用情况动态增加分配区的数量。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;323&quot; data-backw=&quot;578&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtB8yx5gQeYnjxIAaGWqvwLdbmHMKtMiaLANAoJYEuAYob6wnplZib3xhw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;46.50519031141869&quot; data-cropy2=&quot;761.7993079584776&quot; data-ratio=&quot;0.559375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtf5DL8ZXS5Gcib2DhSurSbtibr1vDpf6kmqkfvacbFBytNvFfO8tCC6OA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在申请内存时，glibc 每次申请新的内存时，主分配区是可以通过 brk 或者 mmap 来向系统申请的，但是非主分配的内存只能通过 mmap 申请了，在64位机器上每次申请的虚拟内存区块大小是 64MB ，最大为8倍的 CPU 数量。且从分配区一旦创建，就不会被回收了。这个就是该问题中发现的 64MB 内存块产生的原因。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;进程申请内存的简单步骤如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1. 通过 fastbins 查找合适内存块，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 1没有，从 small bin 中获取，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 2没有，从 unsorted bin 中获取，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 3没有，从 large bin 中获取，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5. 4没有，从 top chunk 中，&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;6. 5不够，向系统申请 brk/mmap。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;内存回收的简单步骤如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1. 判断是否是 mmap 映射，是直接回收&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 判断是否邻近 top chunk&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 不是2，根据 size 放到不同的 bins 中&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 是2，判断 top chunk 中邻近内存是否在使用 是 合并 top chunk&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;5. 合并后判断 top chunk 大小，超过阈值（默认128k），但是开始分配128k不会回收。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过翻阅资料发现，现在市面上有不少内存分配器的实现，如 tcmalloc ，jemalloc 等，在这里我们选择了 jemalloc。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;jemalloc&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;jemalloc 是一个通用的 malloc(3) 实现，强调碎片避免和可扩展的并发支持。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;避免内存碎片和性能点提升&lt;/span&gt;&lt;/em&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;性能对比&lt;/span&gt;&lt;/em&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;419&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.72421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtGFhO9VbmS0lDQvYxXnrJRUgsNnHIhdtVBA18CRgUKoLgliaO2JKyCWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在灰度环境尝试替换为 jemalloc 的内存管理器：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;安装 jemalloc&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;125&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.215625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFt3ftebN2axibmticbwDMImNfZAia9LdeiaFwfvC7mB6uxAk0E1BKmXqYukA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;也可尝试安装 tcmalloc&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;83&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.14453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtAavAQTGR8mvDF8R8GB3WX2NQDdGFTdecfl4tBicpPwrTyBgMTLWLcAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;验证下是否使用成功了&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.43666666666666665&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFt1PicjGcJlFGhlFrXxibSianAQ3aKptG9oia8CUUPoqsgWWLkt0YKqZMMOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;发现 &#x27;64MB&#x27; 的空间映射已经不存在了，且在观察时间范围内还有一次内存的下降， 观察一周一直平稳运行，没有出现 OOM kill 的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;295&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtb6zmT6XuxPH5icW8ia2kGYv8D0GgucUPjicXMUqGuxDq0A1sSbdGTv9Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;140&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.24296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFticHia3RiaChXvfsXVm4JiaBw5MnfoibHYkPrV6GWSQDY7OibVQMXMjhHiaibjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;问题处理流程&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;705&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.220458553791887&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtl42R11h0B6W4vrdVmfOsJWhIKnicGFxuPDaFPtRjqV4dDnFDaicFeyZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;发现问题，就是个人前进的一大步。要发现问题，就要抓细节，不放弃再加上有头脑的处理问题！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;工具优化&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;340&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.58828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtd2ke3fIYJPfQzfYIVBJPt4KUQeNMwTqWfGTySJs7KDK7sK38jz1sYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参考文件：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;华庭 ：《Glibc内存管理-Ptmalloc2 源代码分析》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JeMalloc-UncP 知乎&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://jemalloc.net/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;splitline&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;116417&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;splitline&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;116349&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06201550387596899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFt0AwrkK9RA0HZUV67P2ib1y67NNCibcMbMfX5hwG4A3hwx7qDleYfa36Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;516&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; draggable=&quot;true&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4746666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YE1dmj1Pw7lmPPfFYjwklIwjg232Sqg8q81Q0AdYRBAcCOA8dsorJIGEu7Ln2Tht5jthVsykWiavcoONdDoia1iag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YE1dmj1Pw7mKjQn2D8icpMz0hEWr0b0HpdmRw30s4KMuOvYEEvKDavzDFHzq0niavVRibVDdUCalyjb1ibj6cHsXhQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2b81198bdea50cffa96baed8b4f2144b</guid>
<title>一看就懂！任务提交的资源判断在 Taier 中的实践</title>
<link>https://toutiao.io/k/680fwur</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4255556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGdQLc0HmssKnfVOGLsN4k8CKMSYfLGF9RT5SS7p7w9BicuHpSYpVeGLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;作者 / 月白&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编辑 / 阿晗&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Taier 介绍&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Taier 是袋鼠云开源项目之一，是一个分布式可视化的DAG任务调度系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;旨在降低ETL开发成本、提高大数据平台稳定性，大数据开发人员可以在 Taier 直接进行业务逻辑的开发，而不用关心任务错综复杂的依赖关系与底层的大数据平台的架构实现，将工作的重心更多地聚焦在业务之中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;项目地址：&lt;span&gt;https://github.com/DTStack/Taier&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;563&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;462&quot; data-ratio=&quot;0.9734375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGpeHhHxfZCyJf1tibBRphZiaImuPYztdhB24hp6oMuzNoRrOgELoMY6RQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Taier 资源判断&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Taier 基于插件式架构设计，用户在界面开发任务并提交运行。提交运行插件又划分为worker-plugins、datasource-plugins双插件类型。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在任务提交的时候，Taier需要判断是否有足够的资源来执行，否则一股脑地提交任务，最终会拖垮环境，导致服务的不可用。&lt;span&gt;&lt;strong&gt;根据环境资源的剩余情况来动态调整提交任务的速率&lt;/strong&gt;&lt;/span&gt;是Taier必不可少的一项功能，那么Taier究竟是怎么来判断资源的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;什么是资源？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对一个系统而言，首先要定义出资源的种类，然后将每种资源量化，才能进行管理，这就是资源抽象的过程。那么，想回答上文中「Taier是如何判断资源」的这个问题，就需要先理清楚，在一个分布式、多环境的系统中，什么是资源，又为什么要有“资源”这个概念？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们通常所说的“资源”都是硬件资源，包括CPU使用/内存使用/磁盘用量/IO/网络流量等等，这是比较粗粒度的。也可以是抽象层次更高的TPS/请求数之类的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;资源可以用来衡量系统的瓶颈。系统能否充分利用资源，什么时候可以持续提交任务，什么时候需要暂停提交任务，比如当总体资源充裕时，可以把对应的任务全部提交上去。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;&lt;span&gt;● &lt;span&gt;以Yarn框架介绍为例&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6189711&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGXgqVrqy1ueBZtB0zTGWfGqc20I252ibwRwO42ePTXkUwtX9qudML53A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;622&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ResourceManager 是一个全局的资源管理器，负责整个系统的资源管理和分配，包括 scheduler 、Application Manager和 Node Manager。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对调度器来说，YARN 提供了多种直接可用的调度器， Fair Scheduler 和 Capacity Scheduler 等。调度器仅根据各个应用程序的资源需求进行资源分配,分配的基本单位是Container，而容器里面是将内存、CPU、网络、磁盘封装到一起。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在Yarn的web 界面，我们可以直观的看到当前Yarn集群剩余的内存、CPU核数、运行的Container数量。对提交到yarn上的任务来说，资源就是：内存、CPU、磁盘等可用信息。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2703379&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGW3nZiaxBMv7kGb32ceXe1qgYz24Vbek99xjJOyt3rLNDUCdxhNj9Qgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;799&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;所以在提交到Yarn上执行的任务，我们可以根据ResourceManager 获取Yarn集群当前剩余的内存、CPU核数来进行判断，任务能否满足提交条件等规则。其中，最基本的规则就是:&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;  //  &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;• Yarn集群剩余的内存  &amp;gt;= 当前任务所需的内存&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• Yarn集群剩余的CPU核数 &amp;gt;= 当前任务所需的CPU核数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;何时去判断资源？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;任务在界面开发完成之后，点击运行的按钮，开始从等待提交的状态切换。在提交运行的时候，任务组装好集群配置信息进入下一个阶段——&lt;strong&gt;&lt;span&gt;资源判断&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这个阶段开始判断资源是否满足任务提交。如果任务满足则进行提交，如果任务不满足，则定时、延时、重试直到资源满足任务执行条件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2038217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfG75ttVKwDib8v8nyPDiaToCbTmw05SAwX4ibGVG7oN5W9qXYu2SGx0umlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;785&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;怎样去判断资源？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在worker-plugins提交的抽象类中，有一个通用的方法judgeSlots 去判断资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;judgeSlots 的判断结果分为以下四种:&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;  //  &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;• &lt;strong&gt;OK: &lt;/strong&gt;资源判断满足，任务可以提交&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• &lt;strong&gt;NOT_OK: &lt;/strong&gt;不满足任务所需资源，需要延时重试&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• &lt;strong&gt;LIMIT_ERROR: &lt;/strong&gt;任务参数设置错误: CPU核数或内存为0等场景&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• &lt;strong&gt;EXCEPTION:&lt;/strong&gt; 任务资源判断异常: ResourceManager连接异常等场景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGE7SmI2XT3vwNGUR4yWrV73icQSTbibP5GrKnQypKWko7DfiaGYfgLn88Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;&lt;span&gt;● 以Spark任务为例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;下文我们以Spark任务为例，看看Spark的提交插件是如何获取对应的ResourceManager信息并进行资源判断的。&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGMaHdthxsA33WUyNUbe0pu6hu3Ns1ua0BefAPkOpVkZow6xT7yIiawicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;可以看到根据Yarn集群信息获取了以下信息：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;  //  &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;• 根据Yarn集群信息初始化YarnClient&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• 获取Yarn集群队列下的ACCEPTED状态任务，是否大于控制台yarnAccepterTaskNumber 参数设置&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• 获取Yarn集群队列的剩余CPU核数和内存信息&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2415131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGpaIXHs5ZM3nPU3DxbGQpV8X7bbsmQUENWtEXprkfmOJWFxxl0v5rqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1031&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;然后根据JobClient所携带的任务参数信息，获取了Driver、Executor 的相关内存和CPU信息并进行计算。&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.254386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGibrcLoK7d1Fz34g87zTEuxlCEAVDeYkJsmDhSALhXC0dBMic4NhSDDng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;798&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最后将获取到的Yarn集群信息和任务所需的资源信息按照固定规则进行比对，返回对应的资源判断结果。资源判断的结果将会实时在 Taier 的界面上展示，所以在任务处于等待提交状态的时候，可以去控制台-&amp;gt;队列，管理并查看该任务资源判断信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.275&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGeyXeLFRbofHia65ZuC1wV3iaZEPOTVTgX8ye35WickN6Yd5u2UDMrp7aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Taier 未来规划&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;展望未来，为进一步提升Taier的使用场景，同时也为了减少Hadoop生态在Taier中的依赖，&lt;strong&gt;&lt;span&gt;Taier后续会扩展更多的任务类型&lt;/span&gt;&lt;/strong&gt;。除了支持对接Hadoop集群外，Taier也会陆续支持相关类型的local模式运行，完善更多的场景使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Taier团队非常期待得到每一个人的反馈，能够和其他优秀开发者共同合作，进一步推动Taier的技术发展。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果您对Taier有兴趣，希望可以参与到我们的建设中来，一起交流，一起进步，为 Taier变得更好贡献一点你的代码和意见，这将是我们，同时也是 Taier莫大的荣幸。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;＋&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfG7hcau6vHI8BNUtCRzovUknsC7qjwzJMOx5iaD8rh5bhaI2e7z3E0O5Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;▫ &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5ODYyNTkxMA==&amp;amp;mid=2247494989&amp;amp;idx=1&amp;amp;sn=43d754d9895f2b40e6f7b3d78b9c7ee3&amp;amp;chksm=fe43f654c9347f429e92760d30db923ee42fcbd9ee7d8cb3625092b00b6f6ff25746eb6af2f9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;DAG任务调度系统 Taier 演进之道，探究DataSourceX 模块&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;DAG任务调度系统 Taier 演进之道，探究DataSourceX 模块&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;▫ &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5ODYyNTkxMA==&amp;amp;mid=2247494697&amp;amp;idx=1&amp;amp;sn=2b0d4144249ea9a12550daa446dbf768&amp;amp;chksm=fe43f730c9347e2690de5d66a3d39b4e21db99018b66beec0419376a6f646d28365646328d1b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;官宣！Taier1.3新版本正式发布，新鲜功能抢先体验&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;官宣！Taier1.3新版本正式发布，新鲜功能抢先体验&lt;/a&gt;&lt;/p&gt;&lt;p&gt;▫ &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5ODYyNTkxMA==&amp;amp;mid=2247494417&amp;amp;idx=1&amp;amp;sn=7151e3a47d59a557b5e13954792ed29e&amp;amp;chksm=fe43f008c934791e874dd28e8286615c1756d3dadd1382fd93d18be807178400b64978435079&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一文读懂：开源大数据调度系统Taier1.2版本新增的「工作流」到底是什么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;一文读懂：开源大数据调度系统Taier1.2版本新增的「工作流」到底是什么？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▫ &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5ODYyNTkxMA==&amp;amp;mid=2247493745&amp;amp;idx=2&amp;amp;sn=0b7ed813dd5298b41eed663a46eabe8d&amp;amp;chksm=fe43f368c9347a7ea9c947275d151c7a1e296787a14c883031258630c989b9574451c29e4e80&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;任务or实例 详解大数据DAG调度系统Taier任务调度丨直播回顾&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;任务or实例 详解大数据DAG调度系统Taier任务调度丨直播回顾&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;开&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;源&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;交&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;流&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt; ● ChunJun&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://github.com/DTStack/chunjun&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://gitee.com/dtstack_dev_0/chunjun&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt; ● Taier&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://github.com/DTStack/Taier&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://gitee.com/dtstack_dev_0/taier&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt; ● ChengYing&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://github.com/DTStack/chengying&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://gitee.com/dtstack_dev_0/chengying&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt; ● Molecule&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://github.com/DTStack/molecule&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://gitee.com/dtstack_dev_0/molecule&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfG4klDpcKicL2rCjdBJ6FA7icVr5NFk4Q62AN0FEtk25sgehOT0opsnW3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;袋鼠云开源技术框架交流群&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;钉钉群｜30537511&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.3333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfG50aDClVlK4jnuxHEco8KhhBRcibf2BhicjzaOWy4Tn2CMVyYGMoJbugw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;点击&lt;span&gt;“阅读原文”&lt;/span&gt;，直达开源社区！&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.04&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGX9wDOtuGq4l2jWxDVcBC0If6MHktToFzjUWkKkXwQ0eY4uGXicnDRRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a92860839f0e3f418c165a6e30cd29f3</guid>
<title>多云环境下的安全挑战与防护建议</title>
<link>https://toutiao.io/k/pn2h500</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;随着云计算技术的广泛应用，业务系统上云给企业带来了诸多便利。但在上云过程中，越来越多的企业不愿意“将鸡蛋全都放在一个篮子里”，而是会根据不同业务系统的特性、对网络带宽质量的要求、数据的敏感性以及政策合规等多方面原因，选择多个云或者混合云模式来部署不同的业务系统。这使得多云技术架构应用得到了快速发展，同时也引入了新的安全问题，给企业多云环境应用带来新的风险和挑战。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;多云环境的安全挑战&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;云计算的应用会存在安全漏洞，不法分子可能会利用这些漏洞来谋取利益。而应用多云环境的组织，除了会面临传统的云安全威胁，也需要面对多云环境自身的应用挑战：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;不同云之间的统一化管理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;每家云提供商都用一套专有方式来识别云上资产，难以通过统一的规则来命名一些关键属性。例如，为了识别实例，AWS使用了“实例ID”，Azure使用了“虚拟机ID”，而GCP则使用“虚拟机实例ID”。因此对于采用多云策略的组织来说，如何实现统一化的管理、报告和分析，具有很大的挑战性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;多云使用增加安全隐患&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不同云环境之间的应用差异仍然较为严重，安全能力、安全策略、安全操作习惯等均有较大的不同，用户难以通过统一的方式对庞大的资产进行运维和管理，因此可能因为安全策略不统一导致安全管理工作的疏漏，并由此引发新的安全风险。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;统一安全运营难度大&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;大多数云服务商提供的内置服务只适用于自身的云平台上。当业务需求驱使组织采用多云策略时，这种孤岛现象可能导致严重问题，势必需要一种满足安全需求的有效控制措施。为了保持竞争优势，各大CSP（Cloud Service Provider，云服务提供商）都提供各自的安全工具供客户使用，但是实现方式差异很大，没有统一的标准，企业学习、使用的难度较大。同时，不同云之间使用了不同的运营术语，这无疑也增加了多云环境的安全运营难度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;传统云安全风险依然存在&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;传统云环境中存在主机安全、应用安全和数据安全等问题，在多云环境中依旧存在，而在网络层，由于业务层面通过隧道或代理打通多云或云上云下环境，让多云环境的安全防护边界更加模糊。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;多云安全的防护建议&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;企业组织需要进一步保障多云架构下业务运行安全，在原有云安全能力基础上，全面升级为统一服务、统一运营、统一运维、统一调度、统一配置以及统一权限的多云安全一体化防护体系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;全面洞察不同云上的资产&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;“看不见的东西往往难以保护”，所以应该洞察尽可能多的资产。企业组织应该积极与CSP（云计算服务提供商）合作以获得更全面的云资产可见性，也可以考虑购买或订购第三方云原生解决方案，以实现持续收集数据，并通过统一的管理中心控制所有云应用的配置管理。企业的安全团队和运营团队还应该选择可以同时管理内部资产和云资产的工具。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;实现自动化的安全管理流程&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;为了加强多云安全，企业应该实施自动化安全流程，以处理日常任务，并实施能自行修复安全问题的编排程序。组织可以通过自动化、机器学习和人工智能来帮助安全团队开展运营工作，技术创新可以帮助安全团队提升工作效率，处理更多事务，比如规范数据、建立基准、检测异常、自动执行重复任务、快速检索信息以及自动执行标准化安全策略和配置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;将云上的安全防护左移&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;组织需要将自动化安全流程集成到编程和应用程序开发中，将安全能力融入到云应用的开发中。通过安全能力左移，可以将安全测试和安全技术迁址到软件开发的早期阶段。在多云安全领域，安全“左移”需要把更多的自动化、安全和网络功能直接融入到应用程序开发中，以便安全人员根据应用程序要求，匹配相应的安全能力和措施。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;04&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;与每个云服务商共同承担责任&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;每家CSP对于其所需要承担的安全责任都会有不同的想法。企业要充分了解这些具体的责任，并相应地制定云安全策略：首先，云服务提供商应该提供关于客户如何考虑和降低风险的有效建议并加以实施，同时还应该对如何管理风险实施自己的内部控制；其次，云供应商应该列出各种风险及各自的解决方案，提供完善的服务水平协议，隐私保护政策等能够承担责任的说明；最后，多云企业用户应该明确自身和多云厂商的责任和角色，能够清楚的说明每个云服务提供商的责任有哪些。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;05&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;了解每家CSP的服务特点&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;组织需要搞清楚每家CSP的基础设施、安全工具（比如谷歌云安全指挥中心或Azure安全中心）、API接口规范及其他技术事项。企业只有了解到每家服务提供商的工作原理及特点后，才能实现统一的资源管理、访问控制策略设计、统一操作模式，同时简化安全运营和管理的难度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;06&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;加固多云基础设施&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;企业应该通过锁定端口、访问途径、应用程序接口等方式加固云基础设施，并将基础设施即代码（IaC）解决方案集成到云管理流程中。组织不应该让任何不需要的端口保持敞开，也不应该让任何休眠账户保持活跃，更不能让第三方软件处于失控的状态，IaC将帮助企业安全团队管理这些问题。在多云架构应用中，任何云应用程序和实例都应该按运营策略严格锁定起来，运行最少的服务并不断审视配置状态及管理要求，以确保任何基于云的基础设施尽可能具有弹性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;07&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;统一身份和访问管理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;构建多云环境下的统一身份权限管控平台，是企业开展多云架构应用必须要解决的问题。组织需要能够通过单一系统控制用户访问云和内部平台上的所有资产，实现这个目标不仅要实现单点登录，还要考虑统一身份管控、统一权限管控和云上用户行为审计，这对企业来说具有一定的挑战性。企业可以将基于角色或属性的权限控制整合到多云管理控制台中，或采用零信任的思路构建身份管理能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;08&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;记录一切能够审计的数据&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;组织可能需要查阅大量日志来修复安全问题及其他问题，这需要消耗大量的存储容量，但是却非常有必要，以便威胁搜索和调查。目前，市面上已经有了大量价格更便宜的云存储服务，企业可以用更低的预算投入，实现对所有日志信息的记录。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;参考链接：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;https://www.scmagazine.com/resource/cloud-security/how-to-strengthen-your-multi-cloud-security-posture&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.darkreading.com/zscaler/5-ways-cybersecurity-for-cloud-workloads-will-evolve-in-2023&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>