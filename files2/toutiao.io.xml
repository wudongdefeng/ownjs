<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e1d5d72c3249d1a95f9f8da3c8986a6c</guid>
<title>八万字《高并发的哲学原理》第五章：拆分网络单点(上)--应用网关、负载均衡和路由器(网关)</title>
<link>https://toutiao.io/k/2qnehmg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;本文共 7000 字，阅读大约需要 23 分钟。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;上一篇文章的末尾，我们提到了一个假想出来的五万 QPS 的系统，以及这种规模的系统架构中必然存在的负载均衡器，那本篇文章我们就来一起利用负载均衡搭建一个能够支撑五万 QPS 的系统。&lt;/section&gt;&lt;h2&gt;“监听 HTTPS 443 端口的进程”这个单点&lt;/h2&gt;&lt;p&gt;之前，我们拆出了“监听 HTTPS 443 端口的进程”这个单点，并用 kong 网关来承载了这个单点。目前，在 2 vCore 的虚拟机上，2000 QPS 的压力对应的大约是 20% 的 CPU 占用率，经过换算我们可以知道：假如 kong 的性能可以随着核心数增加而线性提升的话，在维持最大 40% CPU 占用率的情况下，需要：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;(50000 / 2000) &lt;em&gt;2&lt;/em&gt; (20% / 40%) = 25 核&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在这里我们先假设我们搞了一个 25 核的虚拟机，接住了这五万 QPS（实际上接不住，我们后面会说），那这个 Kong 网关到底是什么玩意儿呢？它就是标题中的“应用网关”。&lt;/p&gt;&lt;h3&gt;应用网关&lt;/h3&gt;&lt;p&gt;应用网关，又称 API 网关，顾名思义，它就是所有 API 请求的大门：自己接下所有的 HTTP/HTTPS/TCP 请求，再将请求转发给真正的上游服务器。而这些上游服务器可能是一堆虚拟机，也可能是一堆容器，甚至可以是多个数据中心各自的应用网关。由于应用网关做的事情非常少，所以它能支撑很高 QPS 的系统。&lt;/p&gt;&lt;p&gt;常见的应用网关软件有 HAProxy、Nginx、Envoy 等，而 Cisco、Juniper、F5 等一体化设备厂商也有相关的硬件产品。&lt;/p&gt;&lt;p&gt;应用网关除了提升系统容量外，还有很多别的优势。&lt;/p&gt;&lt;h4&gt;1. 解放后端架构&lt;/h4&gt;&lt;p&gt;经过对应用网关两年的使用，我现在认为所有系统都应该放在应用网关的背后，包括开发环境。&lt;/p&gt;&lt;p&gt;应用网关对后端架构的解放作用实在是太大了，可以让你在后端玩出花来：各种语言、各种技术、各种部署形式、甚至全国各地的机房都可以成为某条 URL 的最终真实服务方，让你的后端架构彻底起飞。&lt;/p&gt;&lt;h4&gt;2. TLS 卸载&lt;/h4&gt;&lt;p&gt;终端用户访问应用网关的时候采用的是 HTTPS 协议，这个协议是需要对数据进行加密解密的，应用网关非常适合干这件事情，而背后的业务系统只提供标准 HTTP 协议即可，降低了业务系统的部署复杂度和资源消耗。&lt;/p&gt;&lt;h4&gt;3. 身份验证和安全性提升&lt;/h4&gt;&lt;p&gt;应用网关可以对后端异构系统进行统一的身份验证，无需一个一个单独实现。也可以统一防火墙白名单，后端系统防火墙只对网关 ip 开放，极大提升了后端系统的安全性，降低了海量服务器安全管理的难度。甚至可以针对某条 API 进行单独鉴权，让系统的安全管控能力大幅提升。&lt;/p&gt;&lt;h4&gt;4. 指标和数据收集&lt;/h4&gt;&lt;p&gt;由于所有流量都会经过网关，所以对指标进行收集也变的简单了，你甚至可以将双向流量的内容全部记录下来，用于数据统计和安全分析。&lt;/p&gt;&lt;h4&gt;5. 数据压缩与转换&lt;/h4&gt;&lt;p&gt;应用网关还可以统一对流量进行 gzip 压缩，可以将所有业务一次性升级到 HTTP/2 和 HTTP/3，可以对数据进行格式转换（XML 到 JSON）和修改（增加/修改/删除字段），总是就是能各种上下其手，翻云覆雨，随心所欲。&lt;/p&gt;&lt;h3&gt;负载均衡&lt;/h3&gt;&lt;p&gt;应用网关的另一个价值就是负载均衡了：可以将请求的流量按照各种比例分发给不同的后端服务器，提升系统容量；可以做红蓝发布和金丝雀发布；可以针对流量特点做灰度发布；可以主动调节各个后端服务器的压力；屏蔽失效的后端服务器等等。&lt;/p&gt;&lt;h4&gt;低负载下应用网关和负载均衡可以是同一个软件&lt;/h4&gt;&lt;p&gt;虽然应用网关和负载均衡是两个不同的概念，但在低负载系统里，他们两个往往由同一个软件来扮演，例如前面说到的 Kong 网关就同时具备这两个功能。&lt;/p&gt;&lt;h2&gt;拆分应用网关&lt;/h2&gt;&lt;p&gt;一个五万 QPS 的系统，是无法使用 25 核的单机安装 Kong 网关来承载的，因为此时单机 TCP 连接数已经达到了十万以上，在这个条件下强如 Nginx 也达到性能极限了，性能不再增长甚至会开始下降，用户体验也会迅速变差。此时，我们需要对应用网关进行拆分。&lt;/p&gt;&lt;h3&gt;应用网关怎么拆&lt;/h3&gt;&lt;p&gt;逻辑上，应用网关执行的是“反向代理+数据过滤”任务，并没有要求应用网关只能由一台服务器来承接，换句话说，应用网关&lt;code&gt;不是单点&lt;/code&gt;，只要多个节点的行为一致，那就可以共同承接这五万 QPS 的真实用户流量。&lt;/p&gt;&lt;p&gt;我们只需要在多台机器上装上同样版本的应用网关软件，然后在他们之间同步配置文件即可。Kong 采用的策略是让多个实例连接同一个&lt;code&gt;PostgreSQL&lt;/code&gt;数据库，每五秒从数据库获取一次最新的配置，如果数据库挂掉，那就保持内存中的现有配置继续运行。&lt;/p&gt;&lt;p&gt;Kong 集群追求的是“最终一致性”，不追求五秒的得失，反而让系统格外地容易扩展，格外的健壮，最后一篇文章我们还会见到使用类似思维的“DNS 分布式拆分”。这个朴素的分布式架构颇有毛子暴力美学的风范，后面我们讨论列存储 clickhouse 的时候还能见到。&lt;/p&gt;&lt;p&gt;如果单个应用网关扛不住五万 QPS，那我们搞一个负载均衡器放在应用网关的前面，架构图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8650306748466258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA3ENoeFVCSfeyaSoUibPZYLYSwKvVf2YNWyRL868SmEFxamMQFjia1gtFb5KN3cuBt7Z33mwUZMV3UA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1304&quot;/&gt;&lt;/p&gt;&lt;h2&gt;分层的网络&lt;/h2&gt;&lt;h3&gt;负载均衡器为何能抗住五万 QPS&lt;/h3&gt;&lt;p&gt;看到这里有人可能会疑惑，既然单机的 Nginx 都顶不住五万 QPS 带来的 TCP 资源开销，那负载均衡器如何抗住呢？因为负载均衡器承载的是比 Nginx 所承载的 TCP 更下面一层的协议：IP 协议。&lt;/p&gt;&lt;p&gt;至此，我们正式进入了网络拆分之路，这条路很难走，但收益也会很大，最终我们将得到一个 200Gbps 带宽的&lt;code&gt;软件定义负载均衡集群&lt;/code&gt;，让我们正式开始。&lt;/p&gt;&lt;h3&gt;网络是分层的&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3932702418506835&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA3ENoeFVCSfeyaSoUibPZYLYwM5J4u0tvW3oWeDcq9hiaF97E0rjnGnwoLvYlr8vCroTOIJYuIc9fJw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1902&quot;/&gt;&lt;/p&gt;&lt;center&gt;经典 TCP/IP 四层网络协议的首部&lt;/center&gt;&lt;p&gt;上面这张图引用自我的另一个系列文章：软件工程师需要了解的网络知识：从铜线到HTTP（三）—— TCP/IP¹。&lt;/p&gt;&lt;p&gt;如果你查看过网页的源代码，你就能知道网页背后是一段 HTML 代码，这段代码是被&lt;code&gt;层层包裹&lt;/code&gt;之后，再在网络中传输的，就像上图中一样。以太网之所以拥有如此之强的扩展性和兼容能力，就是因为它的“分层特性”：每一层都有专门的硬件设备来对网络进行扩展，最终组成了这个容纳全球数十亿台网络设备的“互联网”。最近，这些传统硬件设备的工作越来越多地被软件所定义，即&lt;code&gt;软件定义网络&lt;/code&gt;(SDN)。&lt;/p&gt;&lt;h3&gt;应用数据是什么&lt;/h3&gt;&lt;p&gt;应用数据就是网页背后的 HTTP 协议所包含的全部数据。&lt;/p&gt;&lt;p&gt;我们使用 Charles 反向代理软件可以轻易地得到 HTTP 协议的细节。下面我们展示一个普通的 GET 例子。使用浏览器访问 http://httpbin.org （自己尝试的时候不要选择 HTTPS 网站）：&lt;/p&gt;&lt;h4&gt;请求内容&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;GET / HTTP/1.1&lt;br/&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&lt;br/&gt;Accept-Encoding: gzip, deflate&lt;br/&gt;Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&lt;br/&gt;Cache-Control: max-age=0&lt;br/&gt;Connection: keep-alive&lt;br/&gt;Host: httpbin.org&lt;br/&gt;Upgrade-Insecure-Requests: 1&lt;br/&gt;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.54&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数据解释：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;第一行有三个元素：HTTP 方法、uri、HTTP 版本&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;之后的每一行均以冒号&lt;code&gt;:&lt;/code&gt;作为间隔符，左边是 key，右边是 value&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;HTTP 协议中，换行采用的不是 Linux 系统的 \n，而是跟 Windows 一样的 \r\n&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;响应内容&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK&lt;br/&gt;Date: Wed, 04 Jan 2023 12:07:36 GMT&lt;br/&gt;Content-Type: text/html; charset=utf-8&lt;br/&gt;Content-Length: 9593&lt;br/&gt;Connection: keep-alive&lt;br/&gt;Server: gunicorn/19.9.0&lt;br/&gt;Access-Control-Allow-Origin: *&lt;br/&gt;Access-Control-Allow-Credentials: true&lt;br/&gt;&lt;br/&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&lt;br/&gt;    &amp;lt;title&amp;gt;httpbin.org&amp;lt;/title&amp;gt;&lt;br/&gt;    &amp;lt;link href=&quot;https://fonts.googleapis.com/css?family=Open+Sans:400,700|Source+Code+Pro:300,600|Titillium+Web:400,600,700&quot;&lt;br/&gt;        rel=&quot;stylesheet&quot;&amp;gt;&lt;br/&gt;    &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/flasgger_static/swagger-ui.css&quot;&amp;gt;&lt;br/&gt;    &amp;lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;/static/favicon.ico&quot; sizes=&quot;64x64 32x32 16x16&quot; /&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;    &amp;lt;a href=&quot;https://github.com/requests/httpbin&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on Github&quot;&amp;gt;&lt;br/&gt;    &amp;lt;/a&amp;gt;&lt;br/&gt;    ... ... 此处省略一万个字&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;响应数据的基本规则和请求一样，第一行的三个元素分别是 协议版本、状态码、状态码的简短解释。唯一的不同是，返回值里面还有 HTTP body。&lt;/p&gt;&lt;h5&gt;HTTP header 和 HTTP body&lt;/h5&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;两个换行即 \r\n\r\n 之前的内容为 HTTP header&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;两个换行之后的内容为 HTTP body&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;HTTP body 就是你在浏览器“查看源代码”所看到的内容&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;HTTP 下面是 TCP 层&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6573529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA3ENoeFVCSfeyaSoUibPZYLYm94vcoJnudG9DAov3BptbRSV7egY07mpyyvGKBmzkbbPicG2ljia7icXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;center&gt;TCP 首部图示&lt;/center&gt;&lt;h4&gt;TCP 首部重要数据描述&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;TCP 首部中最重要的数据是&lt;code&gt;源端口&lt;/code&gt;和&lt;code&gt;目的端口&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;他们各由 16 位二进制数组成，2^16 = 65536，所以网络端口的范围是 0-65535&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我们可以注意到，目的端口号这个重要数据是放在 TCP 首部的，和更下层的 IP 首部、以太网帧首部毫无关系&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;TCP 下面是 IP 层&lt;/h3&gt;&lt;p&gt;全球所有公网 IPv4 组成了一个大型网络，这个 IP 网络其实就是&lt;code&gt;互联网&lt;/code&gt;的本体。（IPv6 比较复杂，本文再次不做详细讨论，以下示例均基于 IPv4）&lt;/p&gt;&lt;p&gt;在 IP 层中，每台设备都有一个 ip 地址，形如&lt;code&gt;123.123.123.123&lt;/code&gt;：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;IPv4 地址范围为 0.0.0.0 - 255.255.255.255&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;255 为 2 的 8 次方减一，也就是说用八位二进制可以表示 0-255&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;四个八位即为 32 位，4 个字节&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;IP 首部有哪些信息&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5528846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA3ENoeFVCSfeyaSoUibPZYLYicAc4IbskwTZvLbeGwEuvQAFOkA9GURaUOGELTuPBhO897VSCaR1dQA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;624&quot;/&gt;&lt;/p&gt;&lt;p&gt;从上图可以看出，ip 首部有 20 字节的固定长度是用来存储这个 IP 数据包的基本信息的：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;源地址 32 位（4 个字节）：123.123.123.123&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;目的地址 32 位（4 个字节）：110.242.68.3&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;协议 8 位（1 个字节）：内部数据包使用的协议，即 TCP、UDP 或 ICMP（就是 ping 命令使用的协议）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;首部检验和 16 位（2 个字节）：此 IP 首部的数据校验和，用于验证 IP 首部的数据完整性&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;ip 首部最重要的数据是&lt;code&gt;源 ip 地址&lt;/code&gt;和&lt;code&gt;目的 ip 地址&lt;/code&gt;&lt;/h4&gt;&lt;h3&gt;IP 层下面是 MAC 层(物理层)&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3555992141453831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA3ENoeFVCSfeyaSoUibPZYLYRu9jSgPq1m5EXJLYo4OL4ewZcjJ62niaumGY4Ar8KGyHZADuFGRaycw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1018&quot;/&gt;&lt;/p&gt;&lt;p&gt;物理层中的二进制数据以上图中的格式进行组织，其基本单元被称为“MAC 帧”。&lt;/p&gt;&lt;p&gt;每一台网络设备的 MAC 帧的长度不一定一致，默认为 1500，即 IP 层的数据会按照这个长度进行分包。在局域网速度跑不到协商速率，需要做性能优化时（例如 iSCSI 网络磁盘），可以使用“巨型帧”技术，将这个数字增加到一万，可以提升网络传输性能。不过，根据我的实际优化经验，绝大多数场景下，巨型帧对网络性能的提升小于 5%，属于一种聊胜于无的优化手段。&lt;/p&gt;&lt;p&gt;目的地址和源地址均为 MAC 地址，形式如 AA:BB:CC:DD:EE:FF，共有六段，每一段是一个两位的 16 进制数，两位 16 进制数换算成二进制就是 8 位，所以 MAC 地址的长度为 8*6 = 48 位。&lt;/p&gt;&lt;p&gt;类型字段采用 16 位二进制表示更上一层（ip 层）的网络层数据包的类型：IPv4、IPv6、ARP、iSCSI、RoCE 等等。&lt;/p&gt;&lt;p&gt;MAC 层就是交换机工作的地方，我们下篇文章会讲。&lt;/p&gt;&lt;h2&gt;Nginx 的性能极限&lt;/h2&gt;&lt;p&gt;在真实世界中，QPS 一般比保持 TCP 连接的客户端的数量要少，在此我们假设为四分之一，即：有 20 万个客户端设备在这段时间内访问我们的系统，每个客户端设备平均每 4 秒发送一个 HTTPS 请求。&lt;/p&gt;&lt;h3&gt;单台 Nginx 反向代理的性能极限&lt;/h3&gt;&lt;p&gt;由于 Nginx 不仅需要建立 TCP 连接，还需要将 TCP 连接中发送过来的数据包和某个进程/线程进行匹配，还需要对 HTTP 协议的信息进行解析、识别、转换、添加，所以它也有 QPS 上限：&lt;/p&gt;&lt;p&gt;在 2015 年主流的服务器 CPU 上，Nginx 官方在进行了极限优化的情况下进行了反向代理性能测试，在“建立 TCP 连接-发送 HTTPS 请求-断开 TCP 连接”的极限拉扯下，最高性能为 6W QPS（SSL TPS RSA 2048bit）²。&lt;/p&gt;&lt;p&gt;假设我们使用最新的服务器硬件，当虚拟机 CPU 达到 32 vCore 的时候，未经优化的单机 Nginx 性能就已经达到极限，能承受大约 1 万 HTTPS QPS，对应的连接用户就是 4 万，这个数字其实已经很夸张了。&lt;/p&gt;&lt;h2&gt;TCP 负载均衡器为何能抗住五万 QPS&lt;/h2&gt;&lt;p&gt;我们假设单台 Kong 应用网关的极限为 1 万 QPS，于是我们就需要五台 Kong，那这五台 Kong 前面的 TCP 负载均衡为何能够抗住呢？因为 TCP 负载均衡器要干的事情比 Kong 少非常多：它只需要在 IP 层做少量的工作即可。&lt;/p&gt;&lt;h3&gt;使用负载均衡器拆分 TCP 单点&lt;/h3&gt;&lt;p&gt;TCP 协议是一种“可靠地传输信息”的方法，它不仅有三次握手四次挥手等复杂的控制流程，还会对每一个报文段进行排序、确认、重发等操作来保证最终数据的完整和正确，所以，TCP 本身就是一种需要很多资源处理的&lt;code&gt;单点&lt;/code&gt;，接下来我们开始拆这个单点。&lt;/p&gt;&lt;h3&gt;TCP 负载均衡器的工作过程&lt;/h3&gt;&lt;p&gt;我们假设客户端 ip 为 123.123.123.123，负载均衡器的 ip 为 110.242.68.3（公网）和 10.0.0.100（私网），五台 Kong 服务器的 ip 为 10.0.0.1 ~ 10.0.0.5，架构图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8775252525252525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA3ENoeFVCSfeyaSoUibPZYLY0fpcxRuUicslPo9gALgZzI5SGicb41dRwTV7WY14GEnbDbf8SzwIVpOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1584&quot;/&gt;&lt;/p&gt;&lt;p&gt;负载均衡器的工作过程如下：&lt;/p&gt;&lt;h4&gt;1. 接收数据（左侧）&lt;/h4&gt;&lt;p&gt;负载均衡器接收客户端数据包（报文）的过程如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;负载均衡器收到了一个 ip 报文：源地址 123.123.123.123，目的地址 110.242.68.3&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ip 报文内包裹着一个 TCP 报文，详情如下：源端口 52387，目的端口 443&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;注意，负载均衡器只是接收了一个 IP 报文，并没有和客户端进行三次握手，并没有和客户端建立“TCP 连接”&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;2. 发送数据给上游服务器（右侧）&lt;/h4&gt;&lt;p&gt;在接收到客户端的 IP 报文以后，负载均衡器会找一台上游服务器，准备把数据发送过去：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;内部 TCP 报文首部：源端口 45234，目的端口 443&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TCP 报文外面包裹的 IP 首部：源地址 10.0.0.100，目的地址 10.0.0.1&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;负载均衡器将包裹着 TCP 数据包的 IP 报文发送了出去&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;3. 建立两个报文的映射关系并进行数据转发&lt;/h4&gt;&lt;p&gt;负载均衡器会在内存里创建两个五元组：&lt;/p&gt;&lt;p&gt;左侧五元组&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;左侧源地址 123.123.123.123&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;左侧目的地址 110.242.68.3&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;左侧源端口 52387&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;左侧目的地址 443&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;协议 TCP&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;右侧五元组&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;右侧源地址 10.0.0.100&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;右侧目的地址 10.0.0.1&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;右侧源端口 45234&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;右侧目的地址 443&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;协议 TCP&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;然后，负载均衡器会关联这两个五元组：对两侧发来的数据包（报文）进行拆包和修改（两个地址+两个端口），并从另一侧发送出去。&lt;/p&gt;&lt;h3&gt;这是什么？这就是你家的路由器（网关）呀&lt;/h3&gt;&lt;p&gt;看过我《软件工程师需要了解的网络知识》系列文章的同学应该能一眼看出，这就是网关的工作模式，你家几百块的路由器主要干的就是这个工作。&lt;/p&gt;&lt;h4&gt;为什么性能开销比 Kong 低&lt;/h4&gt;&lt;p&gt;我们可以看出，负载均衡器/网关只需要做两件事：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;建立两个五元组并关联&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;修改数据包的地址和端口，再将数据包发送出去&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这个操作在网络领域内被称作 NAT（网络地址转换）。&lt;/p&gt;&lt;p&gt;由于这个工作非常简单，其中大部分的工作都可以用专用硬件来解决：例如开发专门的五元组存储和关联芯片，开发专门的 NPU（网络数据包处理器）来进行快速数据修改。所以，家用路由器可以做到在 300 块终端售价的情况下实现超过 1Gbit/S 的 NAT 性能。&lt;/p&gt;&lt;h4&gt;Kong 网关需要建立“TCP 连接”&lt;/h4&gt;&lt;p&gt;Kong 网关需要真的和客户端“建立 TCP 连接”：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;三次握手建立连接&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对数据包进行排序、校验，收到心跳包需要回复&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;需要将这个 TCP 连接和一个进程/线程进行绑定：&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;在收到数据以后，找出这个进程/线程，把数据发送给它&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;等进程/线程回复以后，再找到该进程/线程对应的那个 TCP 连接，把数据发送出去&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4&gt;四层负载均衡（L4）和七层负载均衡（L7）&lt;/h4&gt;&lt;p&gt;在卖负载均衡的商业公司那里，应用网关也叫七层负载均衡，因为它工作在 OSI 七层网络模型的第七层，而我们讨论的工作在 IP 层的负载均衡叫四层负载均衡，工作在 OSI 七层网络模型的第四层。再看到 L4 L7 这两个词，你们就能一眼看穿它了，其实一点都不神秘。&lt;/p&gt;&lt;h3&gt;还记得我们的目标吗？一百万 QPS&lt;/h3&gt;&lt;p&gt;我们通过使用一个负载均衡器，可以完美抗下五万 QPS 的负载：一个 TCP 负载均衡器，下挂五个安装了 Kong 应用网关的虚拟机，再下挂 N 台虚拟机，无论是 PHP 语言还是 golang，都可以实现五万 QPS 的设计目标。&lt;/p&gt;&lt;h3&gt;接下来&lt;/h3&gt;&lt;p&gt;下一篇文章，我们将着手突破普通 Linux 系统网络性能的上限：使用软件定义网络（SDN）替代百万人民币的负载均衡硬件，并最终搭建出一个能够支撑 200 Gbps 带宽的负载均衡集群。&lt;/p&gt;&lt;h3&gt;参考资料&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;软件工程师需要了解的网络知识：从铜线到HTTP（三）—— TCP/IP https://lvwenhan.com/tech-epic/487.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6W QPS（SSL TPS RSA 2048bit） https://www.nginx.com/resources/datasheets/nginx-plus-sizing-guide/&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本系列文章已经汇总成开源技术书《PPHC》发布在 Github：https://github.com/johnlui/PPHC&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>08eaeb3aba0caa4db81bc3d0be7ef45d</guid>
<title>代码质量管理平台 SonarLint 在监控宝中的实践总结</title>
<link>https://toutiao.io/k/39hakmk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：云智慧开发工程师 Kori Zhang。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cloudwise.com/cn/page/synmonitoring.html&quot;&gt;点击直达监控宝官网&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;监控宝作为云智慧推出的新一代用户体验监控工具，向用户提供了 IT 性能监控（IT Performance Monitoring）的 SaaS 产品服务。Sonar（代码质量管理平台）是一个开源平台，用于管理源代码的质量。从 Sonar 1.6 版本开始，Sonar 从一个质量数据报告工具，转变成为代码质量管理平台。本文将通过介绍免费开源 IDE 扩展 SonarLint 的使用方法，总结 SonarLint 在监控宝中的落地实践效果。&lt;/p&gt;

&lt;h2&gt;SonarLint 是什么&lt;/h2&gt;

&lt;p&gt;SonarLint 是一个免费的开源 IDE 扩展,可在您编写代码时查找和修复错误、漏洞和代码质量问题。&lt;/p&gt;

&lt;h3&gt;SonarLint 作用&lt;/h3&gt;

&lt;p&gt;SonarLint 发现的问题后，会根据问题类型给出推荐的的范例代码协助开发人员找到合适的修改思路。&lt;/p&gt;

&lt;h3&gt;SonarLint 安装使用&lt;/h3&gt;

&lt;p&gt;SonarLint 目前支持多种 IDE 的插件安装，我使用的是 idea 所以这里介绍在 idea 中的安装方式其它的可以查看官网 sonar。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 选择file→settings→plugins→输入sonarlint。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27c89aff01ef4e06a91a327ef77650c6%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 下图显示为已安装过的界面，所以界面为 uninstall，如果没安装显示的则是 install，安装完重启之后就可以使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e12ce8dd6a1f4bb5ac2f2df0bb59a7cc%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 右键项目进行如下操作：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d221cef8085a4630b125a79f73e34740%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 执行之后可以看到如下信息，如果代码中有不合理的地方会在 report 中显示。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c550713762174689bc76d6b5667a1963%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其他设置请参考: &lt;a href=&quot;https://blog.csdn.net/baixf/article/details/88534198&quot;&gt;https://blog.csdn.net/baixf/article/details/88534198&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;监控宝中 SonarLint 实践效果&lt;/h3&gt;

&lt;p&gt;SonarLint 已在监控宝 jkbFileServer、Alertd 重构、jkbApiServer 重构中运用，实践效果如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  SonarLint 的及时反馈，可以帮助我们在编写阶段就保持一定的代码质量进而提高编码能力；&lt;/li&gt;
&lt;li&gt;  通过 Sonar 扫描后减少不必要返工；&lt;/li&gt;
&lt;li&gt;  SonarLint 配合 IDE 使用方便；&lt;/li&gt;
&lt;li&gt;  对于完美主义的程序员绝对是利器。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Alibaba代码规范插件 vs SonarLint&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;  Alibaba 代码规范插件比较关心的是代码规范，编码风格上的，例如命名规范、注释、代码行数等；&lt;/li&gt;
&lt;li&gt;  SonarLint 比较关心代码正确性，存在的问题、风险、漏洞等，例如重复代码、空指针、安全漏洞。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总体来讲，Alibaba 代码规范插件与 SonarLint ****二者侧的重点不同。机器配置高的情况下建议二者配合使用，可提高工程整体的代码质量，并且能够在编码阶段规避风险，提高程序的健壮性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cloudwise.com/cn/page/synmonitoring.html&quot;&gt;点击直达监控宝官网&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6f080f8861e2e9be746ff6c13a2c6ad9</guid>
<title>如何从 0 开始搭建 Vue 组件库</title>
<link>https://toutiao.io/k/i15vxw7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：京东零售 陈艳春&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;组件设计是通过对功能及视觉表达中元素的拆解、归纳、重组，并基于可被复用的目的，形成规范化的组件，通过多维度组合来构建整个设计方案，將这些组件整理在一起，便形成组件库。本文我们主要讲述基于Vant CLI的自建组件库。Vant CLI 是一个基于 Vite 实现的 Vue 组件库构建工具，通过 Vant CLI 可以快速搭建一套功能完备的 Vue 组件库。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;建立组件库的意义&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;首先组件库可以给我们降本提效，其次可以保持视觉风格统一以及交互一致，可以帮助我们快速构建使用场景，便于多个项目后续迭代升级 。&lt;/p&gt;

&lt;p&gt;视觉风格统一以及交互的一致性，可以减少用户学习成本培养用户习惯，让产品拥有良好的用户体验。比如一个四级地址的选择组件，在整个产品中应该就一种交互方式，如果一会是滚动选择，一会是点击选择，会让用户操作起来比较烦躁，统一交互可以减少用户学习成本。&lt;/p&gt;

&lt;p&gt;新产品上线后，还需要不断的去完善，在迭代过程中可能会新增其他功能，这时候我们就可以只修改组件库一套代码，所有不同项目相同组件就可以达到了迭代升级的效果。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;如何创建组件库&lt;/strong&gt;&lt;/h2&gt;

&lt;h3&gt;&lt;strong&gt;一、梳理组件清单&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;首先梳理出项目中样式相同的模块，和产品讨论未来会有哪些规划，现有的组件是否能够满足需求，是否需要补充设计方案，清单整理完毕后，将每一个组件建成一个独立任务，像日常需求那样，方便随时更新使用。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;二、场景整合&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;把自己变成产品的深度用户，把现有线上产品完整体验一遍，绘制用户行为路径，并和需求方沟通了解后续计划，将组件的所有的当前/潜在应用场景总结出来，尽可能不遗漏场景。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;三、组件库框架选型&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;看了开源的 Vue3 组件库，总结了一些前端目前流行的趋势，列出来多个版本和框架的，本文只讨论 Vue3 版本。&lt;/p&gt;

&lt;p&gt;1.element-plus - 经典中的经典，全面支持 Vue 3&lt;/p&gt;

&lt;p&gt;2.tdesign-vue-next - 鹅厂优质 UI 组件，配套工具完满，设计工整，文档清晰&lt;/p&gt;

&lt;p&gt;3.arco-design-vue- 字节跳动开源 UI 组件库，大厂逻辑，设计文档完美&lt;/p&gt;

&lt;p&gt;4.ant-design-vue - 蚂蚁前端 UI 库，面向企业级中后台&lt;/p&gt;

&lt;p&gt;5.naive-ui - 宝藏 Vue UI 库，Vue UI 新星，从 Vue 3 起步&lt;/p&gt;

&lt;p&gt;6.vant - 有赞团队开源移动 UI 组件库，全面支持 Vue 3&lt;/p&gt;

&lt;p&gt;7.nutui - 京东出品，移动端友好，面向电商业务场景&lt;/p&gt;

&lt;p&gt;8.vuetify - 老牌 Vue UI ，基于谷歌的 Material Design 样式开发&lt;/p&gt;

&lt;p&gt;9.varlet - Varlet 是一个基于 Vue3 开发的 Material 风格移动端组件库，全面拥抱 Vue3 生态，由社区建立起来的组件库团队进行维护。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;四、组件库搭建&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;我们以Vant CLI为例来详细剖析具体搭建过程:&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;（1）首先确保本地node版本^12.13.0 || ^14.15.0 || &amp;gt;=16.0.0&lt;/strong&gt;&lt;/h4&gt;

&lt;h4&gt;&lt;strong&gt;（2）执行以下命令可以快速创建一个基于 Vant CLI 的项目&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;yarn create vant-cli-app
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;（3）手动安装&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# 通过 npm
npm i @vant/cli -D

# 通过 yarn
yarn add @vant/cli -D

# 通过 pnpm
pnpm add @vant/cli -D
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;（4）手动配置&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;vant-cli dev&quot;,
    &quot;test&quot;: &quot;vant-cli test&quot;,
    &quot;lint&quot;: &quot;vant-cli lint&quot;,
    &quot;build&quot;: &quot;vant-cli build&quot;,
    &quot;prepare&quot;: &quot;husky install&quot;,
    &quot;release&quot;: &quot;vant-cli release&quot;,
    &quot;build-site&quot;: &quot;vant-cli build-site&quot;
  },
  &quot;nano-staged&quot;: {
    &quot;*.md&quot;: &quot;prettier --write&quot;,
    &quot;*.{ts,tsx,js,vue,less,scss}&quot;: &quot;prettier --write&quot;,
    &quot;*.{ts,tsx,js,vue}&quot;: &quot;eslint --fix&quot;
  },
  &quot;eslintConfig&quot;: {
    &quot;root&quot;: true,
    &quot;extends&quot;: [&quot;@vant&quot;]
  },
  &quot;prettier&quot;: {
    &quot;singleQuote&quot;: true
  },
  &quot;browserslist&quot;: [&quot;Chrome &amp;gt;= 51&quot;, &quot;iOS &amp;gt;= 10&quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;（5）本地启动&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;npm run dev启动项目，页面如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b370cbd3f56e4848b0b5410705065f02%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注：介绍、快速上手、定制主题、编码规范、开发指南是根据自己组内的规范编写。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;（6）如何开发组件库&lt;/strong&gt;&lt;/h4&gt;

&lt;h5&gt;&lt;strong&gt;目录结构&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;•仓库的组件代码位于 src 下，每个组件一个文件夹&lt;/p&gt;

&lt;p&gt;•docs 目录下是文档网站的代码，本地开发时可以在目录下运行 npm run dev 开启文档网站&lt;/p&gt;

&lt;p&gt;项目主要目录如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;m-tetris
├─ build     # 构建
├─ docs      # 文档
├─ es        # 打包
├─ lib       # 打包
├─ site      # 静态站点资源
├─ src       # 组件
├─ test      # 单测
└─ static    # 图片等资源
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;strong&gt;添加新组件&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;添加新组件时，请按照下面的目录结构组织文件，并在 &lt;code&gt;vant.config.js&lt;/code&gt; 中配置组件名称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;src
└─ button
   ├─ demo             # 示例代码
   ├─ test             # 单元测试
   ├─ index.vue        # 组件入口
   ├─ index.less       # 组件样式
   └─ README.md        # 组件文档说明
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;strong&gt;本地测试&lt;/strong&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;# 打包,生成lib es文件夹
npm run build

# 生成压缩包
npm pack

# 在项目中安装测试包
npm install 压缩包的绝对路径（例如：/Users/用户名/work/XXX/XXX.0.tgz）
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;五、如何发布到公司npm私服或者npm官网&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;所有公司内网用户都能够发布包到 jnpm 库。&lt;/p&gt;

&lt;p&gt;如果你之前没有发布包的经验，请先查看 npm 官方文档 &lt;a href=&quot;https://docs.npmjs.com/cli/publish&quot;&gt;npm publish&lt;/a&gt; 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 拉取最新的master
# 构建npm包
npm run build

# 登录（如已登录，请忽略）
npm login

# 发布
# 如果是公司私服、请保证源是公司源
npm publish
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;六、如何在项目中使用组件&lt;/strong&gt;&lt;/h3&gt;

&lt;h4&gt;&lt;strong&gt;方式一. 自动按需引入组件 (推荐)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;﻿&lt;a href=&quot;https://github.com/ant-design/babel-plugin-import&quot;&gt;babel-plugin-import&lt;/a&gt; 是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 安装插件
npm i babel-plugin-import -D
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// 在.babelrc 中添加配置
// 注意：webpack 1 无需设置 libraryDirectory
{
  &quot;plugins&quot;: [
    [&quot;import&quot;, {
      &quot;libraryName&quot;: &quot;xxx-vant&quot;,
      &quot;libraryDirectory&quot;: &quot;es&quot;,
      &quot;style&quot;: true
    }]
  ]
}

// 对于使用 babel7 的用户，可以在 babel.config.js 中配置
module.exports = {
  plugins: [
    [&#x27;import&#x27;, {
      libraryName: &#x27;xxx-vant&#x27;,
      libraryDirectory: &#x27;es&#x27;,
      style: true
    }, &#x27;xxx-vant&#x27;]
  ]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// 接着你可以在代码中直接引入 xxx-vant 组件
// 插件会自动将代码转化为方式二中的按需引入形式
import { IndexBar } from &#x27;xxx-vant&#x27;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;方式二. 手动按需引入组件&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在不使用插件的情况下，可以手动引入需要的组件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Button from &#x27;xxx-vant/lib/index-bar&#x27;;
import &#x27;xxx-vant/lib/index-bar/style&#x27;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;方式三. 导入所有组件&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;xxx-vant 支持一次性导入所有组件，引入所有组件会增加代码包体积，因此不推荐这种做法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Vue from &#x27;vue&#x27;;
import Jdxxx from &#x27;xxx-vant&#x27;;
import &#x27;xxx-vant/lib/index.css&#x27;;

Vue.use(Jdxxx);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;﻿  &lt;/p&gt;

&lt;p&gt;参考资料：vant-cli官网：&lt;a href=&quot;https://github.com/youzan/vant/blob/HEAD/packages/vant-cli/README.zh-CN.md&quot;&gt;https://github.com/youzan/vant/blob/HEAD/packages/vant-cli/README.zh-CN.md&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>38330594edfef7557d38f70c76ac3335</guid>
<title>面试官问：数据库 delete 表数据，磁盘空间还是被一直占用，为什么?</title>
<link>https://toutiao.io/k/hi4anbn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section&gt;&lt;span&gt;点击上方 &lt;/span&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;java那些事 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，选择 &lt;/span&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;星标 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;公众号&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h4&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;pre&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;重磅资讯，干货，第一时间送达&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;---&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLE0FodVK68Ipic1a28yfeqkdlUU1zalCmTDoqtbtqQqHku61kI596n3KaFPCuG4pmK4AsRw3ibfwdIQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近有个上位机获取下位机上报数据的项目，由于上报频率比较频繁且数据量大，导致数据增长过快，磁盘占用多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了节约成本，定期进行数据备份，并通过delete删除表记录。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;明明已经执行了delete，可表文件的大小却没减小，令人费解&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目中使用Mysql作为数据库，对于表来说，一般为表结构和表数据。表结构占用空间都是比较小的，一般都是表数据占用的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们使用 delete删除数据时，确实删除了表中的数据记录，但查看表文件大小却没什么变化。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Mysql数据结构&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;凡是使用过mysql，对B+树肯定是有所耳闻的，MySQL InnoDB 中采用了 B+ 树作为存储数据的结构，也就是常说的索引组织表，并且数据时按照页来存储的。因此在删除数据时，会有两种情况：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;表文件大小未更改和mysql设计有关&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如想要删除 R4 这条记录：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8135048231511254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupW7nbpkzYTeXbSdJBcu3Gj7H5gw1ibdTibQOUAdRQP6mkCftfMOuasx4CHnoYOSEr9ZibEWKe2FvgibyA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;622&quot;/&gt;为什么delete表数据，磁盘空间却还是被占用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB 直接将 R4 这条记录标记为删除，称为可复用的位置。如果之后要插入 ID 在 300 到 700 间的记录时，就会复用该位置。&lt;strong&gt;由此可见，磁盘文件的大小并不会减少。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通用删除整页数据也将记录标记删除，数据就复用用该位置，与删除默写记录不同的是，删除整页记录，当后来插入的数据不在原来的范围时，都可以复用位置，而如果只是删除默写记录，是需要插入数据符合删除记录位置的时候才能复用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，无论是数据行的删除还是数据页的删除，都是将其标记为删除的状态，用于复用，所以文件并不会减小。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;那怎么才能让表大小变小&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DELETE只是将数据标识位删除，并没有整理数据文件，当插入新数据后，会再次使用这些被置为删除标识的记录空间，可以使用OPTIMIZE TABLE来回收未使用的空间，并整理数据文件的碎片。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;OPTIMIZE TABLE 表名;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：OPTIMIZE TABLE只对MyISAM, BDB和InnoDB表起作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，也可以执行通过ALTER TABLE重建表&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ALTER TABLE 表名 ENGINE=INNODB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;有人会问OPTIMIZE TABLE和ALTER TABLE有什么区别？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;alter table t engine = InnoDB（也就是recreate），而optimize table t 等于recreate+analyze&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Online DDL&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，再说一下Online DDL，dba的日常工作肯定有一项是ddl变更，ddl变更会锁表，这个可以说是dba心中永远的痛，特别是执行ddl变更，导致库上大量线程处于“Waiting for meta data lock”状态的时候。因此在 5.6 版本后引入了 Online DDL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Online DDL推出以前，执行ddl主要有两种方式copy方式和inplace方式，inplace方式又称为(fast index creation)。相对于copy方式，inplace方式不拷贝数据，因此较快。但是这种方式仅支持添加、删除索引两种方式，而且与copy方式一样需要全程锁表，实用性不是很强。Online方式与前两种方式相比，不仅可以读，还可以支持写操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行online DDL语句的时候，使用ALGORITHM和LOCK关键字，这两个关键字在我们的DDL语句的最后面，用逗号隔开即可。示例如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;ALTER TABLE tbl_name ADD COLUMN col_name col_type, ALGORITHM=INPLACE, LOCK=NONE;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ALGORITHM选项&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;INPLACE：替换：直接在原表上面执行DDL的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;COPY：复制：使用一种临时表的方式，克隆出一个临时表，在临时表上执行DDL，然后再把数据导入到临时表中，在重命名等。这期间需要多出一倍的磁盘空间来支撑这样的 操作。执行期间，表不允许DML的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DEFAULT：默认方式，有MySQL自己选择，优先使用INPLACE的方式。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;LOCK选项&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;SHARE：共享锁，执行DDL的表可以读，但是不可以写。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NONE：没有任何限制，执行DDL的表可读可写。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;EXCLUSIVE：排它锁，执行DDL的表不可以读，也不可以写。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DEFAULT：默认值，也就是在DDL语句中不指定LOCK子句的时候使用的默认值。如果指定LOCK的值为DEFAULT，那就是交给MySQL子句去觉得锁还是不锁表。不建议使用，如果你确定你的DDL语句不会锁表，你可以不指定lock或者指定它的值为default，否则建议指定它的锁类型。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行DDL操作时，ALGORITHM选项可以不指定，这时候MySQL按照INSTANT、INPLACE、COPY的顺序自动选择合适的模式。也可以指定ALGORITHM=DEFAULT，也是同样的效果。如果指定了ALGORITHM选项，但不支持的话，会直接报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OPTIMIZE TABLE 和 ALTER TABLE 表名 ENGINE=INNODB都支持Oline DDL，但依旧建议在业务访问量低的时候使用&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;delete 删除数据时，其实对应的数据行并不是真正的删除，仅仅是将其标记成可复用的状态，所以表空间不会变小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以重建表的方式，快速将delete数据后的表变小（OPTIMIZE TABLE 或ALTER TABLE），在 5.6 版本后，创建表已经支持 Online 的操作，但最好是在业务低峰时使用&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;更多精彩内容，&lt;strong&gt;关注我们&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;▼▼&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile data-weui-theme=&quot;light&quot; class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MjM5MTM0NjQ2MQ==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/jNmCBexQlC5YGTbia3dRd6YFXWAlPsJK3gZQap6oK8Vk7BLiaBbsvq3BwicyEKwJiaIfeAYXzucAvXP00PKQKVLzJQ/0?wx_fmt=png&quot; data-nickname=&quot;java那些事&quot; data-alias=&quot;csh624366188&quot; data-signature=&quot;分享java开发中常用的技术，分享软件开发中各种新技术的应用方法。每天推送java技术相关或者互联网相关文章。关注“java那些事”，让自己做一个潮流的java技术人！《java程序员由笨鸟到菜鸟》系列文章火热更新中。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果看到这里，说明你喜欢这篇文章，&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;标星（置顶）&lt;/span&gt;&lt;span&gt;本公众号可以第一时间接受到博文推送。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt; “分享、点赞&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;在看” 支持一波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;img data-type=&quot;png&quot; data-ratio=&quot;1&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lolOWBY1tkwzw3lDgVHOcuEv7IVq2gCXN5rPlfruYGicNRAP8M5fbZZk7VHjtM8Yv1XVjLFxXnrCQKicmser8veQ/640?wx_fmt=png&quot;/&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cac1419b70cb87fee0d22a9132ee7c31</guid>
<title>从实现到原理，聊聊 Java 中的 SPI 动态扩展</title>
<link>https://toutiao.io/k/x9omrl4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;八股文背多了，相信大家都听说过一个词，&lt;strong&gt;SPI扩展&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的面试官就很喜欢问这个问题，&lt;strong&gt;SpringBoot的自动装配是如何实现的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上，你一说是基于spring的SPI扩展机制，再把&lt;code&gt;spring.factories&lt;/code&gt;文件和&lt;code&gt;EnableAutoConfiguration&lt;/code&gt;提一下，那么这个问题就答的八九不离十了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像四五年前，我去面试的时候被问到这个问题，&lt;strong&gt;SPI动态扩展机制&lt;/strong&gt;这几个词从嘴里一说出来，就把面试官唬的一愣一愣的。可能他们也没见过这么能装逼的，一句话能简简单单说明白，非要拽一个听上去很高大上的词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话说回来，被唬住的可不止是面试官，其实还有我自己。至于SPI扩展究竟是个啥，是怎么实现的，我当时也根本不明白。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过现在的面试就是这样，对线八股文，要想唬住面试官，就得先唬住自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们今天暂且不提spring的SPI扩展，先来看看java本身自带的SPI扩展机制是怎么一回事。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、简介&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SPI的全称是&lt;code&gt;Service Provider Interface&lt;/code&gt;，翻译过来就是&lt;strong&gt;服务提供者的接口&lt;/strong&gt;，它所实现的其实是一种服务的发现机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么说起来可能还是有点不好理解，我举个例子来类比一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在spring项目中，写service层代码前，会约定俗成的会添加一个接口层。然后通过spring中的依赖注入，可以借助&lt;code&gt;@Autowired&lt;/code&gt;等方式注入这个接口的实现类的实例对象，之后对于service的调用一般也基于接口操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单形容就是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.569620253164557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvsQXtFUib1xJNic4PaV02N4RkhlZClwoIA8JKJkmIt4VeQRf8w3Ipue8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;711&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，接口、实现类都是由服务提供方提供，我们可以把controller看作服务调用者，调用方只管调用接口就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然也有声音认为，大部分情况下service只有一个实现类，接口层显得有些多余。但是在《Head First Design Patterns》这本书中，大佬们还是建议过：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Program to an interface, not an implementation.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，就是常说的&lt;strong&gt;要面向接口编程&lt;/strong&gt;。至于好处，也不外乎是降低耦合度、方便日后扩展、提高了代码的灵活性和可维护性等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面这个例子里，这个接口层和其中的方法我们可以称之为&lt;strong&gt;API&lt;/strong&gt;，而我们要讨论的&lt;strong&gt;SPI&lt;/strong&gt;和它相比，有类似也有差异，还是先看图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5540355677154583&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvncqKicLHDvfeVsq4WkkUqDl3qc9iceQNmRMHQnN1Ka1RDV20ltwMmwHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;731&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，就是服务的调用方定义一个接口规范，可以由不同的服务提供者实现。并且，调用方能够通过某种机制来发现服务提供方，并通过接口调用它的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过对比，我们可以看出它们虽然都有着&lt;strong&gt;接口&lt;/strong&gt;这一层面，但还是有很大的不同：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API中的接口是服务提供者给服务调用者的一个功能列表，而SPI中更多强调的是，服务调用者对服务实现的一种约束，服务提供者根据这种约束实现的服务，可以被服务调用者发现。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了，Java中的SPI实现的就是，你按我的接口规范实现服务，我就能通过某种机制为这个接口寻找到这个服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么说起来可能还有些抽象，下面我们举一个例子，类比具体描述一下这个过程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、定义接口&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说起智能家居系统，大家现在都比较熟悉了，只要是相同品牌下的产品，连上wifi就能够通过手机app控制了，非常方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然产品不断更新换代，型号更新层出不穷，但是同种家电在app上操作起来，功能一般都是一样的。就拿空调来说，我们在app上操作起来一般也就三个主要功能：&lt;strong&gt;开关&lt;/strong&gt;，&lt;strong&gt;选模式&lt;/strong&gt;，&lt;strong&gt;调节温度&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我现在在客厅、卧室、书房安装了3款不同型号的空调，并把它们都接入到了我app中，那么之后的操作都是相同的几个按键，简单粗暴。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0044444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvxlScQERnvm4oEuDerMyhic9faUia6bFDysgEkDfggrIyYQZMwlV4OunQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;450&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考一下，无论是开关还是调温，都是通过app去调用设备的接口罢了，那么如果不同型号的空调各写各的接口，后端app在开发的时候光对接接口都麻烦的要死。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决方法也很简单，我先定义一套接口规范，不管你以后什么型号的空调，都按我的规范来实现接口。以后只要我能发现你的设备，那么都可以按相同的方法来调用接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么下面就先来定义这么一套接口规范，如果你以后想要接入智能家居系统，那么就要遵循这个规范来开发接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新建一个项目作为标准，就叫&lt;code&gt;aircondition-standard&lt;/code&gt;好了，然后创建一个接口。除了3个操作以外，我们再添加一个获取空调型号的方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IAircondition&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 获取型号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;getType&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 开关&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;turnOnOff&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 调节温度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;adjustTemperature&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; temperature)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 模式变更&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;changeModel&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; modelId)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个接口后面要给服务的实现方来使用，用maven把它打成jar包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mvn clean install&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后服务提供者在项目中就可以引入这个jar包了，有了这套规范，就保证了产品后期不管怎么更新换代，都能接入到系统来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、服务实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;制定并发布完规则后，&lt;strong&gt;挂式空调&lt;/strong&gt;作为第一个服务提供者就来了，新建一个项目&lt;code&gt;aircondition-hanging-type&lt;/code&gt;，并引入刚才打好的jar包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cn.hydra&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;aircondition-standard&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建服务类，并实现前面定义的接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HangingTypeAircondition&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IAircondition&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getType&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;HangingType&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;turnOnOff&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;挂式空调开关&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;adjustTemperature&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;挂式空调调节温度&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;changeModel&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;挂式空调更换模式&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目的&lt;code&gt;resources&lt;/code&gt;的目录下，创建&lt;code&gt;META-INF/services&lt;/code&gt;目录，然后以前面定义的接口名&lt;code&gt;com.cn.hydra.IAircondition&lt;/code&gt;创建文件，并在文件中写入实现类的全限定名。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;com.cn.hydra.HangingTypeAircondition&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个项目结构非常简单：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgveHdCpm2HIKiaO6icEPnuL6CrkPbqr3AsqEwIOXOgN9dr0RIrgg7c7mGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，一个服务方的简单实现就搞定了，用maven打成jar包，之后就可以提供给调用方使用了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，我们可以再创建一个&lt;strong&gt;立式空调&lt;/strong&gt;的项目&lt;code&gt;aircondition-vertical-type&lt;/code&gt;，也只创建一个服务类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VerticalTypeAircondition&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IAircondition&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getType&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;VerticalType&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;turnOnOff&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;立式空调开关&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;adjustTemperature&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;立式空调调节温度&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;changeModel&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;立式空调更换模式&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是按上面的命名规则，创建一个配置文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;com.cn.hydra.VerticalTypeAircondition&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，打成jar包就完事了，至于服务调用者如何去发现和调用这两个服务，下面详细再说。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、服务发现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在两个服务提供方都实现了接口，下面关键的一步就是服务发现，这一步java中的spi发现机制已经帮我们实现好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个新项目&lt;code&gt;aircondition-app&lt;/code&gt;，引入上面打好的两个jar包。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cn.hydra&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;aircondition-hanging-type&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cn.hydra&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;aircondition-vertical-type&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照上面的说法，虽然每个服务提供者对于接口都有不同的实现，但是作为调用者来说，它并不需要关心具体的实现类，我们要做的是通过接口来调用服务提供者实现的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，就是关键的服务发现环节，我们写一个方法，根据型号去调用对应空调的开关方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AirconditionApp&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; AirconditionApp().turnOn(&lt;span&gt;&quot;VerticalType&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;turnOn&lt;/span&gt;&lt;span&gt;(String type)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        ServiceLoader&amp;lt;IAircondition&amp;gt; load = ServiceLoader&lt;br/&gt;                .load(IAircondition&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (IAircondition iAircondition : load) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;检测到:&quot;&lt;/span&gt;+iAircondition.getClass().getSimpleName());&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (type.equals(iAircondition.getType())){&lt;br/&gt;                iAircondition.turnOnOff();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38996763754045305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvYBqibxHMVIqx42OIMadPlpEnmEeUrKoEtibrMlZiaeyRoT02eDH6Z2BAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;618&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，测试过程中，通过定义的接口&lt;code&gt;IAircondition&lt;/code&gt;发现了两个实现类，并通过参数，调用了特定实现类的某个方法。整段代码中没有出现过具体的服务实现类，操作都是通过接口调用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、原理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了spi的工作流程，我们再来看看它的实现，其实最关键的就是上面代码中出现的&lt;code&gt;ServiceLoader&lt;/code&gt;这个类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的示例代码中，对于&lt;code&gt;ServiceLoader&lt;/code&gt;的&lt;code&gt;load()&lt;/code&gt;方法的结果，我们用&lt;code&gt;for&lt;/code&gt;循环进行了遍历，这一点我们看一下源码就能明白，因为&lt;code&gt;ServiceLoader&lt;/code&gt;实现了&lt;code&gt;Iterable&lt;/code&gt;这一接口，而整个服务发现的核心，就在它的&lt;code&gt;iterator()&lt;/code&gt;方法中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7875457875457875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvdUlKNx3BzhJ2pv9XwI01QibpNSffOFWSHmYpaic8XJUkzVonrX39rN7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;819&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意这里面有两个关键的东西，找一下在源码中定义的地方：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3041018387553041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvE0VBUWsoZBLPtbbnMYAEzeIrvRZobcicssFXVTwELSL08GMgfR0C3UA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注释写的非常明白，&lt;code&gt;providers&lt;/code&gt;就是一个缓存，在迭代器中如果先从这里面进行查找，如果里面有就继续往下找，没有了的话就用这个懒加载的&lt;code&gt;lookupIterator&lt;/code&gt;查找。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么就简单了，接着往下看&lt;code&gt;LazyIterator&lt;/code&gt;，看看它里面的&lt;code&gt;hasNext()&lt;/code&gt;和&lt;code&gt;next()&lt;/code&gt;两个方法是怎么实现的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7274939172749392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvAP4huniaR59K63vBeUib5IH6qb6jtMHfzMzAcRDF16Mhz17J5dWYgsWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个&lt;code&gt;acc&lt;/code&gt;是一个安全管理器，在前面通过&lt;code&gt;System.getSecurityManager()&lt;/code&gt;判断并赋值，debug看一下这里都是&lt;code&gt;null&lt;/code&gt;，所以直接看&lt;code&gt;hasNextService()&lt;/code&gt;和&lt;code&gt;nextService()&lt;/code&gt;方法就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;hasNextService()&lt;/code&gt;方法中，会取出接口取出实现类的类名放到&lt;code&gt;nextName&lt;/code&gt;中：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5337124289195776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvIMlNdWpAIiam0JdBV8qibErZ92LXKd1SX63XpGVomaSXqQnmic7nicSaaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1231&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，在&lt;code&gt;nextService()&lt;/code&gt;方法中，则会先加载这个实现类，然后实例化对象，最终放入缓存中去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.54911131898971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvAiaW8tAn7dwe1IIg1RrQOoQb52FtG5T4m5n956kQjcibkeHbRicMNxVJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1069&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在迭代器的迭代过程中，会完成所有实现类的实例化，其实归根结底，还是基于java反射去实现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6、应用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说spi的实际应用，大家最常见的应该就是日志框架&lt;code&gt;slf4j&lt;/code&gt;了，它利用spi实现了插槽式接入其他具体的日志框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了，&lt;code&gt;slf4j&lt;/code&gt;本身就是个日志门面，并不提供具体的实现，需要绑定其他具体实现才能真正的引入日志功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们可使用&lt;code&gt;log4j2&lt;/code&gt;作为具体的绑定器，只需要在pom中引入&lt;code&gt;slf4j-log4j12&lt;/code&gt;，就可以使用具体功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;slf4j-api&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.0.3&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;slf4j-log4j12&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.0.3&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入项目后，点开它的jar包看一下具体结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5280701754385965&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvxMMqIrpO7wlicS3DSMr9WcHGXY9kunxXEqc5RgaPANJv7rZdHm3gAzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有发现一个彩蛋，先说为什么我们pom中引入的明明是&lt;code&gt;slf4j-log4j12&lt;/code&gt;，实际上引入的是&lt;code&gt;slf4j-reload4j&lt;/code&gt;？翻一下官网的文档：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3105196451204056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgviaXF5VXaPPpfWPQ7QU8AGrdHl3k52AjRGibsTXS6jSysdVvI4Y0SmoYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大意就是在2015年和2022年，&lt;code&gt;log4j1.x&lt;/code&gt;就已经宣布&lt;code&gt;end of life&lt;/code&gt;终止了，原因也不难猜，估计是因为频繁爆出的漏洞。在那之后，&lt;code&gt;slf4j-log4j&lt;/code&gt;在构建阶段就会自动重定向到&lt;code&gt;slf4j-reload4j&lt;/code&gt;了，并且官方也强烈建议使用&lt;code&gt;slf4j-reload4j&lt;/code&gt;作为替代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再回头看一下jar包的&lt;code&gt;META-INF.services&lt;/code&gt;里面，通过spi注入了&lt;code&gt;Reload4jServiceProvider&lt;/code&gt;这个实现类，它实现了&lt;code&gt;SLF4JServiceProvider&lt;/code&gt;这一接口，在它的初始化方法&lt;code&gt;initialize()&lt;/code&gt;中，会完成初始化等工作，后续可以继续获取到&lt;code&gt;LoggerFactory&lt;/code&gt;和&lt;code&gt;Logger&lt;/code&gt;等具体日志对象。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7、总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中的SPI提供了一种比较特别的服务发现和调用机制，通过接口灵活的将服务调用与服务提供者分离，用于提供给第三方实现扩展时还是很方便的。但是也有缺点，比方说一旦加载一个接口，就会把所有实现类都加载进来，可能会加载到不需要的冗余服务。不过站在整体角度上，还是给我们提供了一种非常不错的框架扩展、集成的思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这次的分享就到这里，我是Hydra，我们下篇再见。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>