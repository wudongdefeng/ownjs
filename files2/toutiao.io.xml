<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7809e7942d4cafb83d6d3b81214eba36</guid>
<title>突破知识盲点分析可运行jar包的点点滴滴</title>
<link>https://toutiao.io/k/vfyqexb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h3&gt;&lt;a id=&quot;_0&quot;/&gt;每日一句&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;不同的人生，有不同的幸福。去发现你所拥有幸运，少抱怨上苍的不公，把握属于自己的幸福。你，我，我们大家都可以经历幸福的人生。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;&lt;a id=&quot;_4&quot;/&gt;背景介绍&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;经常会头疼于一个jar包是如何制作的，包括maven的打包方式，springboot的打jar包的原理，jar包稍稍有错误就会完全无法运行。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;&lt;a id=&quot;jar_8&quot;/&gt;压缩jar包&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;大家都知道，java应用项目按照JSR标准协议，一般采用jar包进行运行，java程序可以打包成一个jar。此外，当然你必须指定一个拥有main方法的main class类作为Java程序的入口，同时它也是启动JVM进程的入口&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;a id=&quot;jar_12&quot;/&gt;制作只含有字节码文件的jar包&lt;/h4&gt; 
&lt;p&gt;我们先来看只含有字节码文件，即只含有class文件的jar包怎么制作，这是最简单的形式&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;jarhello_16&quot;/&gt;最简单的jar包——直接输出hello&lt;/h5&gt; 
&lt;p&gt;最终生成的jar包结构&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;META-INF
Hello.class
&lt;/code&gt;&lt;/pre&gt; 
&lt;h6&gt;&lt;a id=&quot;_25&quot;/&gt;方法步骤&lt;/h6&gt; 
&lt;ol&gt;&lt;li&gt;用记事本写一个Hello.java的文件&lt;/li&gt;&lt;/ol&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; agrs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;用命令行进入到该目录下，编译这个文件&lt;/li&gt;&lt;/ol&gt; 
&lt;pre&gt;&lt;code&gt;javac Hello.java 
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;将编译后的Hello.class文件打成jar包&lt;/li&gt;&lt;/ol&gt; 
&lt;pre&gt;&lt;code&gt;jar -cvf hello.jar Hello.class 
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt;&lt;li&gt;c（create）：表示要创建一个新的jar包，&lt;/li&gt;&lt;li&gt;v（view）：表示创建的过程中在控制台输出创建过程的一些信息。&lt;/li&gt;&lt;li&gt;f（file）表示给生成的jar包命名&lt;/li&gt;&lt;/ul&gt; 
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;运行jar包&lt;/li&gt;&lt;/ol&gt; 
&lt;pre&gt;&lt;code&gt;java -jar hello.jar
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;这时会报如下错误 hello.jar中没有主清单属性。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;添加Main-Class属性&lt;/li&gt;&lt;/ol&gt; 
 
&lt;h5&gt;&lt;a id=&quot;jarhello_68&quot;/&gt;含有两个类的jar包——通过调用输出hello&lt;/h5&gt; 
&lt;p&gt;最终生成的jar包结构&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;META-INF
Tom.class
Hello.class
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;方法步骤&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;用记事本写一个Hello.java和一个Tom.java的文件，目的是让Hello调用Tom的speak方法&lt;/li&gt;&lt;/ol&gt; 
&lt;pre&gt;&lt;code&gt; class Hello{
     public static void main(String[] agrs){
         Tom.speak();
     }
 }
 class Tom{
     public static void speak(){
         System.out.println(&quot;hello&quot;);
     }
 }
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;编译： javac Hello.java&lt;/li&gt;&lt;/ol&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;此时Hello.java和Tom.java同时被编译，因为Hello中调用了Tom，在编译Hello的过程中发现还需要编译Tom&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;打jar包，这次我们换一种方式直接定义Main-Class。&lt;/li&gt;&lt;/ol&gt; 
&lt;pre&gt;&lt;code&gt;Manifest-Version: 1.0
Created-By: 1.8.0_121 (Oracle Corporation)
Main-Class: Hello
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;事先准备好上述的MANIFEST.MF文件，并存放在META-INF文件夹下，此时打jar包的命令如下&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;jar -cvfm hello.jar META-INF\MANIFEST.MF Hello.class Tom.class 
&lt;/code&gt;&lt;/pre&gt; 
 
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;运行 java -jar hello.jar ，此时成功在控制台看到 hello ，成功&lt;/li&gt;&lt;/ol&gt; 
&lt;h5&gt;&lt;a id=&quot;jarhello_119&quot;/&gt;有目录结构的jar包——通过引包并调用输出hello&lt;/h5&gt; 
&lt;p&gt;最终生成的jar包结构&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;META-INF
com
　Tom.class
Hello.class
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;我们将上一个稍稍变化一下，将Tom这个类放在com包下，源文件目录结构变成&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;com
  Tom.java
Hello.java
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;同时Tom.java需要在第一行声明自己的包名&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;package com;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Hello.java需要引入Tom这个类，同样要在第一行进行import&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;import com.Tom;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h6&gt;&lt;a id=&quot;_144&quot;/&gt;方法步骤&lt;/h6&gt; 
&lt;ol&gt;&lt;li&gt; &lt;p&gt;编译Hello.java&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;打jar包，同样准备好MANIFEST文件&lt;/p&gt; &lt;/li&gt;&lt;/ol&gt; 
&lt;pre&gt;&lt;code&gt; jar -cvfm hello.jar META-INF\MANIFEST.MF Hello.class com
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;注意，最后一个com表示把com这个文件夹下的所有文件都打进jar包&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt; &lt;p&gt;运行 java -jar hello.jar ，此时成功在控制台看到 hello ，成功&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;优化过程&lt;/p&gt; &lt;/li&gt;&lt;/ol&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;com包下是有Tom.java源文件的，也被打进了jar包里，这样不太好，能不能优化一下javac命令，使所有的编译后文件编译到另一个隔离的地方呢，答案是可以的&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;在编译Hello.java时，先新建一个target文件夹。然后我们用如下命令：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;javac Hello.java -d target
&lt;/code&gt;&lt;/pre&gt; 
 
&lt;pre&gt;&lt;code&gt;jar -cvfm hello.jar META-INF\MENIFEST.MF *
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;注意最后一个位置变成了*，表示把当前目录下所有文件都打在jar包里&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;至此，我们可以总结出，制作一个只含有class字节码文件的jar包，以下命令足以&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;javac 要编译的文件 -d 目标位置&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;jar -cvfm 命名 MANIFEST文件 class类文件1 class类文件2&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h5&gt;&lt;a id=&quot;jarjar_183&quot;/&gt;制作含有jar文件的jar包&lt;/h5&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;我们将场景稍稍变得复杂一点，看看jar包中需要引入其他jar包的场景&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ol&gt;&lt;li&gt;两个jar包间相互调用——调用jar外的jar输出hello&lt;/li&gt;&lt;/ol&gt; 
&lt;p&gt;最终生成的jar包结构&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;hello.jar
tom.jar
&lt;/code&gt;&lt;/pre&gt; 
&lt;h6&gt;&lt;a id=&quot;_196&quot;/&gt;方法步骤&lt;/h6&gt; 
&lt;p&gt;准备：将上述一中写好的那个不带包的tom.jar复制过来（目的是调用里面的speak方法）&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;编写一个Hello.java并将其编译成Hello.class，注意，由于Hello里面引用了Tom类的speak方法，因此在打jar包时应使用-cp参数，将tom.jar包引入&lt;/li&gt;&lt;/ol&gt; 
&lt;pre&gt;&lt;code&gt; javac -cp tom.jar Hello.class
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这里的 -cp 表示 -classpath，指的是把tom.jar加入classpath路径下&lt;/p&gt; 
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt; &lt;p&gt;将hello.class打成jar包，步骤略&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;此时运行 java -jar 发现报错 ClassNotFoundException：Tom&lt;/p&gt; &lt;/li&gt;&lt;/ol&gt; 
&lt;p&gt;原因很简单，引入jar包需要在MANIFEST.MF文件中配置一个新属性：Class-Path，路径指向你需要的所有jar包，现在MANIFEST.MF这个文件应该变成&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Manifest-Version: 1.0
Created-By: 1.8.0_121 (Oracle Corporation)
Main-Class: Hello
Class-Path: Tom.jar
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;修改这个文件，再次运行，发现成功在控制台输出 hello&lt;/li&gt;&lt;/ol&gt; 
 
&lt;h5&gt;&lt;a id=&quot;jarjarjarjarhello_228&quot;/&gt;jar包中含有jar包——调用jar内的jar输出hello&lt;/h5&gt; 
&lt;p&gt;最终生成的jar包结构&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;META-INF
Hello.class
tom.jar
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt;&lt;li&gt;当项目中我们把所需要的第三方jar包也打进了我们自己的jar包中时，如果仍然按照上述操作方式，会报找不到Class异常。原因就是jar引用不到放在自己内部的jar包。&lt;/li&gt;&lt;/ul&gt; 
&lt;h5&gt;&lt;a id=&quot;jar_240&quot;/&gt;制作含有资源文件的jar包&lt;/h5&gt; 
&lt;h6&gt;&lt;a id=&quot;jarjar_242&quot;/&gt;资源文件在jar包内部——读取jar内的文件&lt;/h6&gt; 
&lt;p&gt;最终生成的jar包结构&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;META-INF
Hello.class
text.txt
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;方法步骤&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token import&quot;&gt;&lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InputStream&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token import&quot;&gt;&lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;BufferedReader&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token import&quot;&gt;&lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InputStreamReader&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token class-name&quot;&gt;Hello&lt;/span&gt; hello &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;token class-name&quot;&gt;InputStream&lt;/span&gt; is &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hello&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getResourceAsStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;text.txt&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;token function&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;is&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

     
     &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InputStream&lt;/span&gt; inputStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token class-name&quot;&gt;InputStreamReader&lt;/span&gt; reader &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;inputStream&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token class-name&quot;&gt;BufferedReader&lt;/span&gt; br &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;reader&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; s &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; br&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
             &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         inputStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h5&gt;&lt;a id=&quot;jarjar_279&quot;/&gt;资源文件在另一个jar包内部——读取另一个jar内的文件&lt;/h5&gt; 
&lt;p&gt;最终生成的jar包结构&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;hello.jar
resource.jar
　text.txt
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;方法步骤&lt;/p&gt; 
&lt;p&gt;同1一样，只不过需要在MANIFEST文件中将resource.jar加入classpath&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token import&quot;&gt;&lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InputStream&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token import&quot;&gt;&lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;BufferedReader&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token import&quot;&gt;&lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InputStreamReader&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  
  &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token class-name&quot;&gt;Hello&lt;/span&gt; hello &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;token class-name&quot;&gt;InputStream&lt;/span&gt; is &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hello&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getResourceAsStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;text.txt&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;token function&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;is&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; 
    
     &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InputStream&lt;/span&gt; inputStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token class-name&quot;&gt;InputStreamReader&lt;/span&gt; reader &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;inputStream&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token class-name&quot;&gt;BufferedReader&lt;/span&gt; br &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;reader&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; s &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; br&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
             &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         inputStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h5&gt;&lt;a id=&quot;jarjar_318&quot;/&gt;资源文件在jar包外部——读取jar外的文件&lt;/h5&gt; 
&lt;p&gt;最终生成的jar包结构&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;hello.jar
text.txt
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;方法步骤&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token import&quot;&gt;&lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InputStream&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token import&quot;&gt;&lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;BufferedReader&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token import&quot;&gt;&lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InputStreamReader&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token import&quot;&gt;&lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;FileInputStream&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token class-name&quot;&gt;Hello&lt;/span&gt; hello &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;token class-name&quot;&gt;InputStream&lt;/span&gt; is &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;FileInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;text.txt&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token function&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;is&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    
     &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InputStream&lt;/span&gt; inputStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token class-name&quot;&gt;InputStreamReader&lt;/span&gt; reader &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;inputStream&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token class-name&quot;&gt;BufferedReader&lt;/span&gt; br &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;reader&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; s &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; br&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
             &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         inputStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;hr/&gt; 
&lt;h3&gt;&lt;a id=&quot;jar_357&quot;/&gt;运行jar包&lt;/h3&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;具体的方法是修改jar包内目录META-INF下的MANIFEST.MF文件&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;比如有个叫做demo.jar的jar包，里面有一个拥有main方法的main class：demo.mainClassName&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;jar包中有个MANIFEST.MF文件，就只要在MANIFEST.MF里面添加如下一句话：Main-Class: demo.mainClassName&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;然后我们可以在控制台里输入java -jar test.jar即可以运行这个jar&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;如果这个项目需要引用其他第三方的jar包，在IDE里面以项目jar包的形式引用了这个叫做some.jar的包，当时放在项目的lib子目录下，最后项目打包时把这个some.jar也打进来了，但是用java -jar 执行这个test.jar的时候报找不到Class异常，原因就是jar引用不到放在自己内部的jar包&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;a id=&quot;classpath_369&quot;/&gt;classpath参数设置方式&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;运行时将其加入classpath的方式行不行？就是在运行jar的同时加入classpath参数。&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;java -classpath some.jar -jar test.jar
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;这种方式是不行的，因为使用classpath指定的jar是由AppClassloader（系统型类加载器）来加载，java命令加了-jar 参数以后，AppClassloader就只关注test.jar范围内的class了，classpath参数失效&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt; 
&lt;h5&gt;&lt;a id=&quot;jar_379&quot;/&gt;那该怎么引用其他的jar包呢？&lt;/h5&gt; 
&lt;h6&gt;&lt;a id=&quot;_381&quot;/&gt;方法一&lt;/h6&gt; 
&lt;p&gt;&lt;strong&gt;Bootstrap Classloader来加载这些类&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;我们之前在讲述类加载器的时候也介绍过，可以在运行时使用如下参数：&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;-Xbootclasspath：完全取代系统Java classpath.最好不用。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;-Xbootclasspath/a:：在系统class加载后加载。一般用这个。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;-Xbootclasspath/p: 在系统class加载前加载,注意使用，和系统类冲突就不好了.&lt;/p&gt; 
   &lt;/li&gt;&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;win32系统每个jar用分号隔开，unix系统下用冒号隔开&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h6&gt;&lt;a id=&quot;_400&quot;/&gt;方法二&lt;/h6&gt; 
&lt;p&gt;使用Extension Classloader来加载&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;你可以把需要加载的jar都扔到%JRE_HOME%/lib/ext下面，这个目录下的jar包会在Bootstrap Classloader工作完后由Extension Classloader来加载。非常方便，非常省心&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h6&gt;&lt;a id=&quot;_406&quot;/&gt;方法三&lt;/h6&gt; 
&lt;p&gt;使用AppClassloader来加载，不过不需要classpath参数了，我们在MANIFEST.MF中添加如下代码：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Class-Path: lib/some.jar&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;lib是和test.jar同目录的一个子目录，test.jar要引用的some.jar包就在这里面。如果有多个jar包需要引用的情况&lt;/strong&gt;：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Class-Path: lib/some.jar lib/some2.jar&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;每个单独的jar用空格隔开就可以了。注意使用相对路径。&lt;/strong&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;另：如果META-INF 下包含INDEX.LIST文件的话，可能会使Class-Path配置失效。INDEX.LIST是Jar打包工具打包时生成的索引文件，删除对运行不产生影响&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>54181d1f0612b442f4e7568846aecd1e</guid>
<title>SpringBoot版的低代码开发平台，关联无 SQL，性能高10倍！</title>
<link>https://toutiao.io/k/r6anm56</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;点击关注公众号，Java干货&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;及时送达&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzU4MDUyMDQyNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/knmrNHnmCLEX3M6DvCn5gKuBOaMMVu9lUJAvwH2k66nV9VgGG0cyczd1ryib06P1z5pF72Le3HUr5loicnQx36lg/0?wx_fmt=png&quot; data-nickname=&quot;小哈学Java&quot; data-alias=&quot;xiaoha_java&quot; data-signature=&quot;专注于Java领域干货分享，不限于BAT面试, 算法，数据库，Spring Boot, 微服务,高并发, JVM, Docker容器，ELK相关知识，期待与您一同进步。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5324074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufA6p3DJWtJ5tsNnHJuL0zHTlkGY29KQCHxXVu5gs7ISpmLopicpTMIyCszFYSUFa0FhibYHXUlZqpQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&amp;amp;random=0.5790490192780733&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来源：开源技术专栏&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;diboot 的设计理念&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Web 开发需要一个普适的基础框架，把复杂的问题简单化，最好还能做到更佳性能，规避常见的坑&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序员很难被替代，但程序员应该聚焦于数据结构设计、业务实现、难点解决，重复 CRUD 没啥长进&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;低代码是未来的趋势，CRUD 类重复有规律的工作是可以被自动化甚至被省掉的&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;diboot 主要技术栈&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;后端 Java + 关系数据库，跟紧 Spring 体系 (Spring Boot、Spring Cloud)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ORM 站队 Mybatis，通用 Mappe r框架选用 Mybatis-plus&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;权限: spring boo 版本使用 Shiro+JWT；spring cloud 版本使用 spring security + oauth2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前后分离，前端选型 Vue，支持 ElementUI 和 Antd vue pro&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于diboot-core的CRUD和常规关联的功能实现，代码量比传统Mybatis项目减少80%+，且性能更好更易维护。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;diboot 基础组件&lt;/span&gt;&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、 diboot-core: 精简优化内核：写的更少，性能更好&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;单表CRUD无SQL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关联绑定无SQL（注解自动绑定）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据字典无SQL（注解自动绑定）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跨表查询无SQL（自动构建QueryWrapper与查询）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BaseService扩展增强，支持常规的单表及关联开发场景接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他常用工具类、状态码、异常处理的更优实践封装&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;基于diboot-core的CRUD和常规关联的功能实现，代码量比传统Mybatis项目减少80%+，且性能更好更易维护。&lt;/p&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、IAM 身份认证基础组件 及 配套VUE前端框架（diboot-antd-admin、diboot-element-admin）&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;开箱即用的RBAC角色权限模型与预置组织人员岗位模型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于无状态token的认证授权，支持刷新token&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;简化的BindPermission注解，支持兼容shiro的简化权限配置与自动鉴权&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动提取需要鉴权的后端接口, 借助前端功能方便配置菜单按钮权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无缝适配redis，引入redis依赖即可启用shiro的redis缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持基于注解的数据权限实现、简化的Log注解记录操作日志等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持灵活的扩展能力（扩展多种登录方式、灵活替换用户实体类、自定义缓存等）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、diboot-file 文件相关处理组件&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;EasyExcel轻量封装，支持Java注解校验与&lt;code&gt;@ExcelBind*&lt;/code&gt;注解实现字典及关联字段的&lt;code&gt;name-value&lt;/code&gt;转换，并提供完善的校验错误提示&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文件存储接口化，预置本地存储，简单扩展OSS、分布式存储等实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;封装常用的文件上传下载、图片压缩水印等常用处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4、diboot-scheduler 定时任务组件&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Quartz定时任务统一管理及日志的最佳实践封装&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@CollectThisJob&lt;/code&gt;注解提供定时任务定义，自动收集供前端选择&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5、diboot-message 消息通知组件&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通用的消息模板&amp;amp;模板变量的设计方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持多通道的消息通知发送&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6、diboot-mobile 移动端组件&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;提供了配套的 &lt;code&gt;diboot-mobile-ui&lt;/code&gt; ，内置了多种登录方式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持 账号密码登录、微信小程序登录（自动注册）微信公众号登录（自动注册）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;diboot-core (diboot-core-starter) 使用步骤&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;引入依赖&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;   &amp;lt;groupId&amp;gt;com.diboot&amp;lt;/groupId&amp;gt;&lt;br/&gt;   &amp;lt;artifactId&amp;gt;diboot-core-spring-boot-starter&amp;lt;/artifactId&amp;gt;&lt;br/&gt;   &amp;lt;version&amp;gt;{latestVersion}&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或 Gradle:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;compile(&lt;span&gt;&quot;com.diboot:diboot-core-spring-boot-starter:{latestVersion}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;配置参数（数据源）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#datasource config&lt;/span&gt;&lt;br/&gt;spring.datasource.url=jdbc:mysql://localhost:3306/diboot_example?characterEncoding=utf8&amp;amp;serverTimezone=GMT%2B8&lt;br/&gt;spring.datasource.username=diboot&lt;br/&gt;spring.datasource.password=123456&lt;br/&gt;spring.datasource.hikari.maximum-pool-size=5&lt;br/&gt;spring.datasource.hikari.driver-class-name=com.mysql.cj.jdbc.Driver&lt;br/&gt;-------------------------------------------------------------------------&lt;br/&gt;&lt;span&gt;#diboot-core-spring-boot-starter的可选参数配置：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 是否初始化sql，默认true，初始化之后（或非开发环境）可以改为false关闭检测&lt;/span&gt;&lt;br/&gt;diboot.core.init-sql=&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;配置config类&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;diboot-core-starter&lt;/code&gt; 默认预置了 mybatis-plus 的分页配置（使用 mybatis-plus 3.4.x的 MybatisPlusInterceptor 最新配置方式）。如果您依赖的是&lt;code&gt;core-starter&lt;/code&gt;，则无需再次配置 mybatis-plus 的分页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要添加其他&lt;code&gt;Interceptor&lt;/code&gt;，则需要重新定义 &lt;code&gt;MybatisPlusInterceptor&lt;/code&gt;。示例如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Bean&lt;br/&gt;public MybatisPlusInterceptor &lt;span&gt;&lt;span&gt;mybatisPlusInterceptor&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();&lt;br/&gt;    interceptor.addInnerInterceptor(new PaginationInnerInterceptor());&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; interceptor;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//同时core-starter中也默认配置了HttpMessageConverters，如果需要更改默认配置， 则需要在配置类中重新定义HttpMessageConverters。&lt;br/&gt;@Bean&lt;br/&gt;public HttpMessageConverters &lt;span&gt;&lt;span&gt;jacksonHttpMessageConverters&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;注意：&lt;code&gt;diboot-core-starter&lt;/code&gt; 预置了默认的配置以及字典表相关的接口实现，如果是老项目中仅依赖 &lt;code&gt;diboot-core&lt;/code&gt;（非&lt;code&gt;diboot-core-starter&lt;/code&gt;），则还需要将 diboot 的包路径加入 ComponentScan 中&lt;/p&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;diboot 新手体验&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 IDE 中克隆 playground 项目&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&quot;&lt;code&gt;File -&amp;gt; New -&amp;gt; Project from version control...&lt;/code&gt;&quot;菜单打开克隆项目对话框:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20257510729613734&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLFRbLYQfgw1lc5nRowUCOFGPicics02Aex1icGFUK8bSjmyVzd7shPNsOGA2CWK091ylYb2rLZmm9D7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1165&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;URL 中输入如下 playground 项目路径，指定项目本地路径（避免中文路径），点击 Clone 按钮 :&lt;code&gt;https://gitee.com/dibo_software/playground.git&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31798806479113384&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLFRbLYQfgw1lc5nRowUCOFGbF98TjHx3zazaiaVtdSI5RA0gEQXrpUKL8iauIqqXXsPX2yR1zQltREA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1173&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;待克隆完成后，在右侧 Maven 视图中，添加 demo 项目下的 pom.xml&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5761245674740484&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLFRbLYQfgw1lc5nRowUCOFGcBttw3PupF9AsNzKXga5WhzYOnMa0hicHZlZOcXqNsGE27YTIYGKmbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1156&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准备数据库后使用 devtools 初始化代码&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、点击控制台中打印出的 URL，进入devtools操作页面。（个人用户初次使用需要扫码）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、初次启动 devtools 会提示初始化组件的基础代码（为了方便自定义修改，devtools 将controller 等代码生成到本地项目中）。依次点击各组件的&quot;生成代码&quot;按钮。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5123674911660777&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLFRbLYQfgw1lc5nRowUCOFGS78iby2mIx3eeJia2Bdt3vAjjVXJnRKt1qMiarAPsdymW8SrS0I87Umicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、打开 demo 目录下的 java 目录，将会看到相关组件的初始化代码已生成。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;注意：如果启动前端发现验证码无法显示，则需要检查是否执行了这个步骤并重启了项目。登录验证相关的 controller 需要此步骤中生成&lt;/p&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源地址：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://gitee.com/dibo_software/diboot&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;pre&gt;&lt;pre&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;pre&gt;&lt;pre&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100015743&quot; data-ratio=&quot;0.08658008658008658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/TNUwKhV0JpTGQqtlGfEHkjibtshlaDwVKzjqq2pnpmYC14bKxDtSuhpWZWfVcicj5PFsoSMzuzicKIWZbsBpGXiaicg/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; data-type=&quot;gif&quot; data-w=&quot;462&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;pre&gt;&lt;pre&gt;&lt;pre data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(167, 167, 167)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(63, 63, 63)&quot; data-style=&quot;letter-spacing: 0.544px; font-size: 16px; color: rgb(63, 63, 63); word-spacing: 1px; line-height: inherit;&quot;&gt;&lt;section data-mpa-template-id=&quot;1250&quot; data-mpa-category=&quot;divider&quot; data-style=&quot;margin-right: 0.5em; margin-left: 0.5em; white-space: normal; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; color: rgb(0, 0, 0); letter-spacing: 0px; word-spacing: 2px;&quot; data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(230, 230, 230)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(0, 0, 0)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; data-style=&quot;margin: 10px 0em; color: rgb(89, 89, 89); letter-spacing: 0.544px;&quot; data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(138, 138, 138)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(89, 89, 89)&quot;&gt;&lt;section data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(138, 138, 138)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(89, 89, 89)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(138, 138, 138)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(89, 89, 89)&quot;&gt;&lt;p data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(106, 104, 111)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(106, 104, 111)&quot;&gt;1. &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&amp;amp;mid=2247512811&amp;amp;idx=1&amp;amp;sn=368c7f5f5d7ad0880d78fd737ba6cf47&amp;amp;chksm=fd57626dca20eb7b270a158f0e74276218cdb2ed0bbf2d877f3b38f0936a5e4fb99d1841e425&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;8种专坑同事的 SQL 写法，性能降低100倍，不来看看？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;8种专坑同事的 SQL 写法，性能降低100倍，不来看看？&lt;/a&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(138, 138, 138)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(89, 89, 89)&quot;&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(106, 104, 111)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(106, 104, 111)&quot;&gt;2. &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&amp;amp;mid=2247512806&amp;amp;idx=1&amp;amp;sn=318c6db2e1d16c5d9521ce9b9a2fb2ac&amp;amp;chksm=fd576260ca20eb76728e35c1f117aa1d061c1bb018bed5f9395ca8bb44aa86acae73d0320371&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringBoot 过滤器、拦截器、监听器对比及使用场景&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;SpringBoot 过滤器、拦截器、监听器对比及使用场景&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(138, 138, 138)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(89, 89, 89)&quot;&gt;&lt;span&gt;3. &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&amp;amp;mid=2247512770&amp;amp;idx=1&amp;amp;sn=231c80cb7f2c7ddfd19832e7215ef830&amp;amp;chksm=fd576244ca20eb52023344e6fc24b8a4f379d4335d76f848c674f2477e265b2c66cc70c6561f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;面试官：海量请求下的接口并发解决方案，具体聊聊吧&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;面试官：海量请求下的接口并发解决方案，具体聊聊吧&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(106, 104, 111)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(106, 104, 111)&quot;&gt;4. &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&amp;amp;mid=2247512752&amp;amp;idx=1&amp;amp;sn=1dc4358cdb01e724825d22881c63318e&amp;amp;chksm=fd576236ca20eb20ac8abbd00aa4279849c65d4203e308ed1bd9b8344dd73943979b1e38703e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;10分钟快速构建一套自己的虚拟开发环境，Vagrant 堪称效率神器！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;10分钟快速构建一套自己的虚拟开发环境，Vagrant 堪称效率神器！&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-style=&quot;margin-right: 0.5em; margin-left: 0.5em; white-space: normal; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0px; word-spacing: 2px; color: rgb(62, 62, 62); text-align: center;&quot; data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(168, 168, 168)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(62, 62, 62)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100015744&quot; data-ratio=&quot;0.5552731893265566&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/knmrNHnmCLEVGGmicJODkfibhcqyUwmTSC8CUvAMG78wPemfibvQ502uFs9jlziaLP50YcTs4rL9hQuzX32PAUOPHA/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;gif&quot; data-w=&quot;787&quot;/&gt;&lt;/p&gt;&lt;pre data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(138, 138, 138)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(89, 89, 89)&quot; data-style=&quot;letter-spacing: 0.544px; text-size-adjust: auto; word-spacing: 2px; color: rgb(89, 89, 89);&quot;&gt;&lt;p data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(168, 168, 168)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(62, 62, 62)&quot; data-style=&quot;margin-top: 5px; margin-bottom: 5px; white-space: normal; color: rgb(62, 62, 62); letter-spacing: 0.544px; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 14px; line-height: normal;&quot;&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(120, 172, 254)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(120, 172, 254)&quot;&gt;最近面试BAT，整理一份面试资料&lt;/span&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(61, 167, 66)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(61, 167, 66)&quot;&gt;《&lt;strong data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(61, 167, 66)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(61, 167, 66)&quot;&gt;Java面试BATJ通关手册&lt;/strong&gt;》&lt;/span&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(120, 172, 254)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(120, 172, 254)&quot;&gt;，覆盖了Java核心技术、JVM、Java并发、SSM、微服务、数据库、数据结构等等。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(156, 156, 156)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(74, 74, 74)&quot; data-style=&quot;margin-top: 15px; margin-bottom: 15px; letter-spacing: 0.544px; white-space: pre-line; line-height: 30px; color: rgb(74, 74, 74); font-family: Avenir, -apple-system-font, 微软雅黑, sans-serif;&quot;&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(120, 172, 254)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(120, 172, 254)&quot;&gt;获取方式：点“&lt;/span&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(61, 167, 66)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(61, 167, 66)&quot;&gt;在看&lt;/span&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(120, 172, 254)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(120, 172, 254)&quot;&gt;”，关注公众号并回复 &lt;/span&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(61, 167, 66)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(61, 167, 66)&quot;&gt;Java&lt;/span&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(120, 172, 254)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(120, 172, 254)&quot;&gt; 领取，更多内容陆续奉上。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;PS：因公众号平台更改了推送规则，如果不想错过内容，记得读完点一下&lt;/span&gt;&lt;strong&gt;“&lt;span&gt;在看&lt;/span&gt;”&lt;/strong&gt;&lt;span&gt;，加个&lt;/span&gt;&lt;strong&gt;“&lt;span&gt;星标&lt;/span&gt;”&lt;/strong&gt;&lt;span&gt;，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;点&lt;strong&gt;“在看”&lt;/strong&gt;支持小哈呀，谢谢啦&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f8aca38d84b675c36738fd700cce03e8</guid>
<title>解密负载均衡算法</title>
<link>https://toutiao.io/k/ider1pe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;负载均衡器是一种软件或硬件设备，它起到了将网络流量分散到一组服务器的作用，可以防止任何一台服务器过载。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;负载均衡算法就是负载均衡器用来在服务器之间分配网络流量的逻辑（算法是一组预定义的规则），有时候也叫做负载均衡的类型。负载均衡算法的种类非常多，包括从简单的轮询负载均衡算法到基于响应状态信息的自适应负载均衡算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;负载均衡算法的选择会影响负载分配机制的有效性，从而影响性能和业务连续性（也就是对外承诺的SLA），选择正确的负载均衡算法会对应用程序性能产生重大影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;本文将会介绍常见的负载均衡算法，并结合主流负载均衡软件或硬件设备介绍各种负载均衡算法的实现方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;1&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;常见负载均衡算法介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Round Robin（轮询负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在所有负载均衡算法中，轮询负载均衡算法是最简单的、最常用的负载均衡算法。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;客户端请求以简单的轮换方式分发到应用程序服务器上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，假设有三台应用程序服务器：第一个客户端请求发送到第一台应用程序服务器，第二个客户端请求发送到第二台应用程序服务器，第三个客户端请求发送到第三台应用程序服务器，第四个客户端请求重新从第一台应用程序服务器开始，依次往复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.603448275862069&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzCh86OpyxXhrsru5u0EOQq5nMuXEODu6pQF0t4gLgW1q2Q0ju2n1FhneyAbm1qBeHyF3REg9K0uVg/640?wx_fmt=png&quot; data-w=&quot;812&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;轮询负载均衡适合所有客户端请求都需要相同的服务器负载，并且所有的服务器实例都具有相同的服务器容量和资源（比如网络带宽和存储）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Weighted Round Robin（加权轮询负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;加权负载均衡算法与轮询算法相似，增加了根据每个服务器的相对容量来将请求分散到不同服务器的能力。&lt;/span&gt;&lt;span&gt;它适合将传入的客户端请求分散到一组具有不同功能或具有不同负载容量的服务器上。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;服务器集群管理员根据一个标准为每个应用程序服务器分配一个权重，这个标准表示每个服务器对请求的相对处理能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，如果在其他资源都是无穷多的情况下，假如服务器#1的CPU核心数是服务器#2和服务器#3的CPU核心数的二倍，那么服务器#1的权重更高，而服务器#2和#3的权重相同（都比#1低）。如果我们有4个连续的客户端请求，那么有2次请求发送到#1，另外2次请求分别发送到#2和#3。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加权轮询负载均衡算法描述的是在一段时间内负载的分布情况，不同的加权轮询负载均衡算法可能会产生不同的选择序列，不应该对处理下一次负载的服务器进行假设。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6054590570719603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzCh86OpyxXhrsru5u0EOQq5zY1LZKhBJ0WzjZnyjpU7m4vhwzkicgxXuFg0KVB5ngDwia0SKttPfbVw/640?wx_fmt=png&quot; data-w=&quot;806&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Least Connections（最少连接负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;最少连接负载均衡算法又叫做最少等待请求算法（Least Outstanding Request, LOR）。&lt;/span&gt;&lt;span&gt;最少连接负载均衡是一种动态负载均衡算法，客户端请求被分发到在接收到请求时活动连接数最少的应用服务器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在应用服务器具有类似规格的情况下，一台服务器可能会因为连接数过多而过载（无法接收请求也属于过载），这个算法考虑了活动连接负载。这种技术适合具有不同连接时间的传入请求（多机房）以及一组在处理能力和可用资源方面相对相似的服务器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Weighted Least Connections（加权最少连接负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;加权最少连接建立在最少连接负载均衡算法上，考虑不同的应用程序服务器特性。与加权轮询负载均衡算法相同，服务器集群管理员根据一个标准为每个应用程序服务器分配一个权重，这个标准表示每个服务器对请求的相对处理能力。负载均衡器根据活动链接和分配的服务器权重做出负载平衡决策（例如，使用连接数乘以权重的倒数，选择值最高的服务器）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Resource Based（基于资源的负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;基于资源的负载均衡算法又叫做自适应负载均衡算法。&lt;/span&gt;&lt;span&gt;基于资源的负载均衡算法根据后端服务器提供的状态指标来做出决策。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个状态指标可以由一个运行在服务器上的自定义应用程序（比如agent），或从基础设施提供方的开放接口获取。负载均衡器定期查询每台服务器的状态指标，然后适当地调整服务器的动态权重。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在这种方式下，负载均衡算法实际上是在每台真实服务器上执行健康检查。&lt;/span&gt;&lt;span&gt;这个算法适用于任何需要来自每台服务器的详细健康检查信息来做出负载均衡决策的情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如：此算法适用于工作负载多变且需要详细的应用程序性能和状态来评估服务器运行状态的任何应用程序（例如CPU密集型的最短路径计算，或其他高性能计算场景）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Fixed Weighting（固定权重负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;固定权重负载均衡算法允许服务器集群管理员根据他们的标准为每个应用程序服务器分配一个权重，以表示每个服务器的相对流量处理能力。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;权重最高的应用服务器将接收所有流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果权重最高的应用服务器出现故障，所有流量将会被引导到下一个权重最高的应用服务器。此方法适用于单个服务器能够处理所有预期传入请求的工作负载，如果当前活动的服务器发生故障，一个或多个“热备用”服务器可以直接用于承担负载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Weighted Response Time（加权响应时间负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;加权响应时间负载均衡算法使用应用程序的响应时间来计算服务器权重。响应速度最快的应用程序服务器接收下一个请求。&lt;/span&gt;&lt;span&gt;此方法适用于应用程序响应时间是最重要的问题的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;当应用程序提供的是对外开放服务时尤为重要，因为对外开放服务都会为合作伙伴提供服务级别协议（Service Level Argument，SLA），而SLA中承诺的主要就是服务的可用性与服务的响应时间（TP99、TP999等）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Source IP Hash（源地址哈希负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;源地址哈希负载均衡算法使用客户端请求的源IP与目标IP地址生成唯一的哈希密钥，用于将客户端请求分配给特定的服务器。如果传输层会话中断，可以重新密钥，因此客户端请求将会被定向到它之前使用的统一服务器。当客户端对于每个连续连接始终返回到同一服务器至关重要时，此方法最适用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务端研发经常接触的数据库事务就适用于此场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Consistent Hash（一致性哈希负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一致性哈希负载均衡算法类似于源地址哈希，不同在于一致性哈希负载均衡算法可以使用任意应用参数组成唯一的哈希密钥，并且当服务器集群发生变化时可以尽可能少地进行数据迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;2&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;常见负载均衡算法实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;本节将会介绍各种常见负载均衡算法的实现方式，某些负载均衡算法具有多种不同的实现方式，并且每种实现方式都有各自适用的场景，这些不同的实现方式也会在本节进行介绍。同时本节中会假设所有的请求都是线性的，不会处理并发安全相关的细节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Round Robin（轮询负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在所有负载均衡算法中，轮询负载均衡算法实现起来最简单，只需要一个变量表示当前位置并不断增加即可。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;public class RoundRobinLoadBalancer {&lt;br/&gt;&lt;br/&gt;    private final List instances;&lt;br/&gt;&lt;br/&gt;    private int position;&lt;br/&gt;&lt;br/&gt;    public RoundRobinLoadBalancer(List instances) {&lt;br/&gt;        this.instances = instances;&lt;br/&gt;        this.position = ThreadLocalRandom.current().nextInt(instances.size());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public ServiceInstance peek(HttpServletRequest request) {&lt;br/&gt;        int peeked = (position++) &amp;amp; Integer.MAX_VALUE;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; instances.get(peeked % instances.size());&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里有两个需要注意的点：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Weighted Round Robin（加权轮询负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;加权轮询负载均衡算法有很多主流的实现，并且各自都有各自的优点。虽然加权负载均衡产生任意符合全总分配比例分布的选择序列都是合适的，但在短时间窗口内是否能够选择尽可能多的节点提供服务仍是评价加权负载均衡实现的质量的关键指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、数组展开方式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;数组展开实现方式是一种适用空间换时间的策略，适用于较小的服务器集群或专用型负载均衡设备。它的优点是速度非常快，与Round Robin实现完全一致。它的缺点也很明显，当权重的总和很大时会带来很大的内存开销。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;public class WeightedLoadBalancer {&lt;br/&gt;&lt;br/&gt;    private final List instances;&lt;br/&gt;&lt;br/&gt;    private int position;&lt;br/&gt;&lt;br/&gt;    public WeightedLoadBalancer(List instances) {&lt;br/&gt;        this.instances = expandByWeight(instances);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public ServiceInstance peek(HttpServletRequest request) {&lt;br/&gt;        int peeked = (position++) &amp;amp; Integer.MAX_VALUE;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; instances.get(peeked % instances.size());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private List expandByWeight(List instances) {&lt;br/&gt;        List newInstances = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (ServiceInstance instance : instances) {&lt;br/&gt;            int bound = instance.getWeight();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (int w = 0; weight &amp;lt; bound; weight++) {&lt;br/&gt;                newInstances.add(instance);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        Collections.shuffle(newInstances);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; newInstances;&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里有三个需要注意的点：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;当实例按权重展开成数组的时候，可能会出现实例权重都很大，但是它们的最大公约数不为1，这个时候可以使用最大公约数来减少展开后的数组大小。因为最大公约数的诸多限制，例如任意自然数N与N+1互质，任意自然数N与1互质，所以很容易出现优化失败的情况，因此本示例并未给出，感兴趣的可以去看Spring Cloud相关PR[1]。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在实例按权重展开成数组后，需要对得到的数组进行洗牌，以保证流量尽可能均匀，避免连续请求相同实例（Java中实现的洗牌算法是Fisher-Yates算法，其他语言可以自行实现）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因为是在构建负载均衡器的时候按权重展开成数组的，所以在负载均衡器构建完成后无法再改变实例的权值，对于频繁动态变更权重的场景不适用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;2、上界收敛选择方式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;上界收敛选择方式提前计算出所有权重的最大值，并将初始上界设置为所有权重的最大值，接下来我们一轮一轮地去遍历所有实例，并找到权重大于等于上界的实例。当前轮遍历结束后，所有大于等于上界的元素都被选取到了，接下来开始尝试权重更低的节点，直到最后上界为0时，将其重新置为最大值。目前OpenResty （有人在issue #44[2]上分析了这种算法）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5879888268156425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzCh86OpyxXhrsru5u0EOQq5n38X8J2NialajzZe3OuXlSE7qePumpNYYHLn6bOP8eUl9eMiaFIOs5vg/640?wx_fmt=png&quot; data-w=&quot;1432&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5876577840112202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzCh86OpyxXhrsru5u0EOQq5CoYvIB3cbKRAU9oPLRkDypa9ZRCN2vSnd6MgpuaDnPhHiaoPcpS9LdA/640?wx_fmt=png&quot; data-w=&quot;1426&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5955678670360111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzCh86OpyxXhrsru5u0EOQq5wLmC58Om9icOao3yKUUdbrOxqsgSrdujHbgrpGkMQq6ZxqgbKCXib6icA/640?wx_fmt=png&quot; data-w=&quot;722&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;public class WeightedLoadBalancer {&lt;br/&gt;&lt;br/&gt;    private final List instances;&lt;br/&gt;&lt;br/&gt;    private final int max;&lt;br/&gt;&lt;br/&gt;    private final int gcd;&lt;br/&gt;&lt;br/&gt;    private int bound;&lt;br/&gt;&lt;br/&gt;    private int position;&lt;br/&gt;&lt;br/&gt;    public WeightedLoadBalancer(List instances) {&lt;br/&gt;        this.instances = instances;&lt;br/&gt;        this.max = calculateMaxByWeight(instances);&lt;br/&gt;        this.gcd = calculateGcdByWeight(instances);&lt;br/&gt;        this.position = ThreadLocalRandom.current().nextInt(instances.size());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public ServiceInstance peek(HttpServletRequest request) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (bound == 0) {&lt;br/&gt;            bound = max;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (instances.size() &amp;gt; 0) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (int peeked = position; peeked &amp;lt; instances.size(); peeked++) {&lt;br/&gt;                ServiceInstance instance = instances.get(peeked);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (instance.getWeight() &amp;gt;= bound) {&lt;br/&gt;                    position = peeked + 1;&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            position = 0;&lt;br/&gt;            bound = bound - gcd;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private static int calculateMaxByWeight(List instances) {&lt;br/&gt;        int max = 0;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (ServiceInstance instance : instances) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (instance.getWeight() &amp;gt; max) {&lt;br/&gt;                max = instance.getWeight();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; max;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private static int calculateGcdByWeight(List instances) {&lt;br/&gt;        int gcd = 0;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (ServiceInstance instance : instances) {&lt;br/&gt;            gcd = gcd(gcd, instance.getWeight());&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; gcd;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private static int gcd(int a, int b) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (b == 0) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; a;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; gcd(b, a % b);&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;里面有四个需要注意的点：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果是短频率请求，将会一直访问高权重实例，导致在短时间窗口内负载看起来并不均匀。这个可以通过改变方向，从下界向上界逼近来解决。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;每一轮后降低上界的值可以取所有权重的最大公约数，因为如果每次下降1的话，中间这些轮会反复请求权重最高的那些实例，导致负载不均衡。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;虽然最大公约数可以减少下降次数，但是如果权重相差非常多，并且所有元素都是互质的（n与n+1互质，任意自然数n与1互质，在实践中非常容易出现），那么在上界下降的过程中将会带来很多空转。这个可以参考广度优先遍历的思想，使用先入先出的队列来减少空转。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;与数组展开方式遇到的问题相同，因为是在构建负载均衡器的时候计算最大公约数的值，所以对于频繁动态变更权重的场景依旧会有很大的性能开销，但是相较于数组展开方式可以避免频繁动态分配数组导致的性能与内存碎片问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;3、权重轮转实现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;权重轮转算法中将会存储两个权重的值，一个是不会变化的原始权重，一个是会随着每次选择变化的当前权重。权重轮转实现中维护了一个循环不变量——所有节点的当前权重的和为0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每轮遍历过程中所有实例的有效权重都会增加它的原始权重，并选择出当前权重最高的节点。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;选择出权重最高的节点后将它的当前权重减去所有实例权重的总和，以避免它再次被选择。NGINX中加权轮询负载均衡算法使用此实现。这种算法的优势是它很平滑，低权重节点的等待时间较短，并且每轮权重轮转的最小正周期很小，是所有服务器实例权重的和。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在NGINX中又叫做平滑加权负载均衡（Smooth Weighted Load Balancing，SWRR）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5994397759103641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzCh86OpyxXhrsru5u0EOQq5cxSs3wzygpue6BxXn5xCQ0xIzYk8U6FUcXGVtnibJiaVuWVUb4SG7wibg/640?wx_fmt=png&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;public class WeightedLoadBalancer {&lt;br/&gt;&lt;br/&gt;    private final List instances;&lt;br/&gt;&lt;br/&gt;    public WeightedLoadBalancer(List instances) {&lt;br/&gt;        this.instances = instances;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public ServiceInstance peek(HttpServletRequest request) {&lt;br/&gt;        ServiceInstance best = null;&lt;br/&gt;        int total = 0;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (ServiceInstance instance : instances) {&lt;br/&gt;            total += instance.getWeight();&lt;br/&gt;            instance.setCurrentWeight(instance.getCurrentWeight() + instance.getWeight());&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (best == null || instance.getCurrentWeight() &amp;gt; best.getCurrentWeight()) {&lt;br/&gt;                best = instance;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (best != null) {&lt;br/&gt;            best.setCurrentWeight(best.getCurrentWeight() - total);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; best;&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里面有三个需要注意的点：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;权重轮转非常适合实例变化频率非常高的集合，因为它不需要提前构建数据结构&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;权重轮转实现的效率与实例数量相关，时间复杂度是O(n)，当集群服务器数量非常大时需要限制每次参与选择的服务器数量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;权重轮转实现需要修改服务器实例的数据结构，当服务实例是由其他机构提供时无法使用此实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;4、EDF（Earliest Deadline First）实现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;EDF算法最早被用在CPU调度上，EDF是抢占式单处理器调度的最佳调度算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;EDF实现与权重轮转实现相似，引入了名为deadline的额外变量，可以认为权重越高的服务器实例完成任务的时间越快，那么在假设所有请求的成本相同时，所需要花费的时间是权重的倒数，所以可以很自然地选择可以最早空闲出来提供服务的服务器实例，并将任务分配给它。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;实现EDF算法只需要将每个下游服务器实例与deadline绑定，然后以deadline为优先级维护到优先队列中，并不断取出队首元素，调整它的deadline，并将它重新提交到优先队列中。知名Service Mesh代理Envoy使用了此方法实现加权负载均衡，以及蚂蚁开源网络代理SOFAMosn中也实现了此方法。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;public class WeightedLoadBalancer {&lt;br/&gt;&lt;br/&gt;    private final PriorityQueue entries;&lt;br/&gt;&lt;br/&gt;    public WeightedLoadBalancer(List instances) {&lt;br/&gt;        this.entries = instances.stream().map(EdfEntry::new).collect(Collectors.toCollection(PriorityQueue::new));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public ServiceInstance peek(HttpServletRequest request) {&lt;br/&gt;        EdfEntry entry = entries.poll();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (entry == null) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;        }&lt;br/&gt;        ServiceInstance instance = entry.instance;&lt;br/&gt;        entry.deadline = entry.deadline + 1.0 / instance.getWeight();&lt;br/&gt;        entries.add(entry);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private static class EdfEntry implements Comparable {&lt;br/&gt;&lt;br/&gt;        final ServiceInstance instance;&lt;br/&gt;&lt;br/&gt;        double deadline;&lt;br/&gt;&lt;br/&gt;        EdfEntry(ServiceInstance instance) {&lt;br/&gt;            this.instance = instance;&lt;br/&gt;            this.deadline = 1.0 / instance.getWeight();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        @Override&lt;br/&gt;        public int compareTo(EdfEntry o) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Double.compare(deadline, o.deadline);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;EDF每次选择的算法复杂度为O(log(n))，相较于数组展开要慢，但相较于上界收敛选择在最坏情况下以及权重轮转都需要O(n)的时间复杂度来说，其性能表现的非常好，并且对于超大集群，其性能下降不明显。其空间复杂度为O(n)，不会造成很大的内存开销。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Least Connections（最少连接负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、遍历比较方式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;最简单的实现方式，遍历所有实例，并找出当前连接数最少的实例。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;public class LeastConnectionLoadBalancer {&lt;br/&gt;&lt;br/&gt;    private final List instances;&lt;br/&gt;&lt;br/&gt;    public LeastConnectionLoadBalancer(List instances) {&lt;br/&gt;        this.instances = instances;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public ServiceInstance peek(HttpServletRequest request) {&lt;br/&gt;        ServiceInstance best = null;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (ServiceInstance instance : instances) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (best == null || instance.getConnections() &amp;lt; best.getConnections()) {&lt;br/&gt;                best = instance;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (best != null) {&lt;br/&gt;            best.setConnections(best.getConnections() + 1);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; best;&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;2、堆维护方式&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;所有动态有序集合都可以通过优先队列来实现，与EDF算法相同，取出队首的元素，修改它的优先级，并放回队列中。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;public class LeastConnectionLoadBalancer {&lt;br/&gt;&lt;br/&gt;    private final PriorityQueue instances;&lt;br/&gt;&lt;br/&gt;    public LeastConnectionLoadBalancer(List instances) {&lt;br/&gt;        this.instances = instances.stream().collect(toCollection(&lt;br/&gt;                () -&amp;gt; new PriorityQueue&amp;lt;&amp;gt;(comparingInt(ServiceInstance::getConnections))));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public ServiceInstance peek(HttpServletRequest request) {&lt;br/&gt;        ServiceInstance best = instances.poll();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (best == null) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;        }&lt;br/&gt;        best.setConnections(best.getConnections() + 1);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; best;&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;Weighted Least Connections（加权最少连接负载均衡算法）&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;加权最少连接负载均衡算法的实现方式与最少连接负载均衡算法相同，只是在计算时增加了权重相关的参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、遍历比较方式&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;public class LeastConnectionLoadBalancer {&lt;br/&gt;&lt;br/&gt;    private final List instances;&lt;br/&gt;&lt;br/&gt;    public LeastConnectionLoadBalancer(List instances) {&lt;br/&gt;        this.instances = instances;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public ServiceInstance peek(HttpServletRequest request) {&lt;br/&gt;        ServiceInstance best = null;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (ServiceInstance instance : instances) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (best == null || instance.getConnections() * best.getWeight() &amp;lt; best.getConnections() * instance.getWeight()) {&lt;br/&gt;                best = instance;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (best != null) {&lt;br/&gt;            best.setConnections(best.getConnections() + 1);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; best;&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;Tips，在不等式中 a/b &amp;lt; c/d 与 ad &amp;lt; bc等价，并且可以避免除法带来的性能与精度问题。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;2、堆维护方式&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;public class LeastConnectionLoadBalancer {&lt;br/&gt;&lt;br/&gt;    private final PriorityQueue instances;&lt;br/&gt;&lt;br/&gt;    public LeastConnectionLoadBalancer(List instances) {&lt;br/&gt;        this.instances = instances.stream().collect(toCollection(&lt;br/&gt;                () -&amp;gt; new PriorityQueue&amp;lt;&amp;gt;(comparingDouble(ServiceInstance::getWeightedConnections))));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public ServiceInstance peek(HttpServletRequest request) {&lt;br/&gt;        ServiceInstance best = instances.poll();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (best == null) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;        }&lt;br/&gt;        best.setConnections(best.getConnections() + 1);&lt;br/&gt;        best.setWeightedConnections(1.0 * best.getConnections() / best.getWeight());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; best;&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Weighted Response Time（加权响应时间负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加权响应时间负载均衡算法使用统计学的方法，通过历史的响应时间来得到预测值，使用这个预测值来选择相对更优的服务器实例。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;得到预测值的方法有很多，包括时间窗口内的平均值、时间窗口内的TP99、历史所有响应时间的指数移动加权平均数（EWMA）等等。其中Linkerd与APISIX使用了EWMA算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;通过历史的响应时间来得到预测值这个操作通常是CPU开销很大的，实际使用时可以不用遍历所有元素，而是使用K-临近元素或直接随机选择两个元素进行比较即可，这种启发式方法办法无法保证全局最优但是可以保证不至于全局最差。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Source IP Hash（源地址哈希负载均衡算法）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;源地址哈希负载均衡以任意算法将请求地址映射成整型数，并将这个整型数映射到实例列表的下标。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;public class IpHashLoadBalancer {&lt;br/&gt;&lt;br/&gt;    private final List instances;&lt;br/&gt;&lt;br/&gt;    public IpHashLoadBalancer(List instances) {&lt;br/&gt;        this.instances = instances;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public ServiceInstance peek(HttpServletRequest request) {&lt;br/&gt;        int h = hashCode(request);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; instances.get(h % instances.size());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private int hashCode(HttpServletRequest request) {&lt;br/&gt;        String xForwardedFor = request.getHeader(&lt;span&gt;&quot;X-Forwarded-For&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (xForwardedFor != null) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; xForwardedFor.hashCode();&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; request.getRemoteAddr().hashCode();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里有一个需要注意的点：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;面向公网提供服务的负载均衡器前面可能会经过任意多层反向代理服务器，为了获取到真实的源地址，需要先获取X-Forwarded-For头部，如果该头部不存在再去获取TCP连接的源地址。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;3&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;负载均衡技术扩展&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;服务注册表与发现（Service Registry and Service Discovery）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在维护大型服务器集群时，服务器实例随时都有可能被创建或移除，当服务器被创建或移除时，集群管理员需要到各个负载均衡设备上去更新服务器实例列表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务注册表会在内部维护服务对应的服务器实例列表。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在服务器实例被创建并成功运行服务后，服务器实例会去服务注册表中注册自身，包括网络地址（IPv4/IPv6）、服务端口号、服务协议（TCP/TLS/HTTP/HTTPS）以及自身提供的服务名称等等，有的服务注册表本身也会提供主动健康检查的能力（如Eureka与Consul）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在服务器实例正常退出时会在服务注册表执行反注册逻辑，这个时候服务注册表就会将这个服务器实例从服务器实例列表中移除。&lt;/span&gt;&lt;span&gt;即使服务器实例异常退出导致无法执行反注册逻辑，服务注册表也会通过主动健康检查机制将这个异常的服务器实例从服务器实例列表中移除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在拥有服务注册表后，负载均衡设备不需要再手动维护服务器实例列表，而是当请求到来时从服务注册表中拉取对应的服务器实例列表，并在这个服务器实例列表中进行负载均衡。&lt;/span&gt;&lt;span&gt;为了提高服务的可用性，负载均衡设备会在本地（内存或本地文件注册表）缓存这些服务器实例列表，以避免由于负载均衡设备与服务注册表无法连接而导致服务不可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;缓存及重新获取服务器列表的策略根据不同业务场景有不同的实现，在Spring Cloud Loadbalancer中是通过缓存过期而触发重新获取的逻辑，当服务注册表不可用时，因为负载均衡设备中无可用的服务器备份而导致服务完全不可用；在大部分的负载均衡设备中将缓存获取与更新逻辑改为定时器主动刷新的机制，这样当服务注册表不可用时可以主动决定是否将旧数据标记为过期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;尽管本地缓存可以提高服务的可用性，但是要注意负载均衡设备在使用的仍旧是旧的服务提供方列表，当长时间无法获取到新的服务提供方列表时，负载均衡设备应当舍弃旧的服务提供方列表，并将服务不可用的问题暴露出来，通过基础设施提供的监控与告警能力通知集群管理员来进行处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;健康检查（Health Check）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;健康检查本质是一个预定规则，它向负载均衡器背后的服务器集群中的所有成员发送相同的请求，以确定每个成员服务器是否可以接受客户端请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于某些类型的健康检查，通过评估来自服务器的响应以及收到服务器响应所需的时间以确定每个成员服务器的运行状态。&lt;/span&gt;&lt;span&gt;通常情况下，当成员服务器的状态变为不健康时，负载均衡器应该快速地将其从服务器实例列表中移除，并在成员服务器状态恢复正常时将其重新添加回服务器实例列表中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于网络层负载均衡器（也叫做NLB或L4LB），通过建立TCP连接，根据是否能够成功建立连接以及建立连接所需要的时间来确定成员服务器的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于应用层负载均衡器（也叫做ALB或L7LB），通过发送应用层协议（不只是HTTP协议）定义的用于健康检查的请求报文，并根据响应报文内容以及整个请求从建立连接到完整收到所有响应所花费的时间来确定成员服务器的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用负载均衡器没有固定的模式。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，对于提供HTTP协议服务的应用，可以提供用于健康检查的URL，设置通过健康检查的HTTP状态码（或状态码集），并验证响应报文中用于表示服务器状态的字段（通过JSONPath或XMLPath等提取）是否是预期值等方式来确认成员服务器状态；对于RPC协议，可以提供专门的ping-pong服务，负载均衡器根据RPC协议组装请求报文，并发送ping请求到成员服务器上，并根据成员服务器返回的内容是否为pong响应来确认成员服务器的状态，具体设计可以参考websocket的ping-pong机制[4]。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;慢启动（Slow Start）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负载均衡器中的慢启动思想来自于TCP的拥塞控制理论，其核心也是为了避免大量请求涌入刚刚启动完成的应用程序，导致大量请求阻塞、超时或异常的情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;众所周知，Java是半编译半解释型语言，包括Java语言在内，现代解释型语言的解释器都带有即时编译器（Just In Time，JIT），JIT编译器会跟踪每个方法的执行点，对那些热点路径（Hotspot）进行更高效的优化，这也是Hotspot JVM名字的由来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;而JIT对热点路径的优化全都来自于自应用程序启动以来的所有方法调用，也就是说应用程序的系统承载能力是随着程序的运行而不断得到强化的，经过JIT优化的Java代码甚至可以得到近似GCC中O3（最高级别）优化的性能。跟多关于JIT编译器的细节可以看Oracle的Java开发者指南[5]。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时，现代应用程序都不可避免的会使用本地缓存，当应用程序刚刚启动时内存中的缓存是空的，随着应用程序的运行，不断地访问外部系统获取数据并将数据写入到内存缓存中，应用程序与外部系统的交互会不断减少，应用程序的系统承载能力也会逐渐达到峰值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;上面是应用程序在启动后性能不断提升的因素中最常见的，初次之外还有很多的因素。所以为了避免大量请求涌入刚刚启动完成的应用程序的现象发生，负载均衡器会通过慢启动的方式，随着服务器运行不断增加这些服务器实例的权重，最终达到服务器的实际权重，从而达到动态调整分配给这些服务器实例的流量的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;服务器权重变化算法有很多，包括随时间线性增长、随时间对数增长、随时间指数增长、随时间变幂增长、与随时间按Logistic增长等。目前京东服务框架（JSF）实现的是随时间线性增长；envoy实现了随时间变幂增长，并引入了渐进因子来调整变化速率。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6994106090373281&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzCh86OpyxXhrsru5u0EOQq5fjUdVic6zUTbK9pAIv29iayBvEeztprpIYLTicpfEEdicsibCfGQunFb6Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1018&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;4&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;负载均衡技术是网络代理与网关组件最核心的组成部分，本文简单介绍了什么是负载均衡技术、常见的负载均衡算法以及常见负载均衡算法的实现，并给出了负载均衡技术的扩展，为将来更深入学习网络代理相关技术打下基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;相关链接：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://github.com/spring-cloud/spring-cloud-commons/pull/1140&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://github.com/openresty/lua-resty-balancer/issues/44&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://github.com/nginx/nginx/blob/master/src/http/ngx_http_upstream_round_robin.c#L431&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://datatracker.ietf.org/doc/html/rfc6455#section-5.5&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://docs.oracle.com/cd/E11882_01/java.112/e10588/chnine.htm#JJDEV09000&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;分布式实验室策划的《&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Kubernetes实战集训营&lt;/strong&gt;&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;》正式上线了。这门课程通过5天线上培训，4个课后大作业，40天课后辅导，把Kubernetes的60多个重要知识点讲给你，并通过实战让你掌握Kubernetes。培训重实战、重项目、更贴近工作，边学边练，2月25日正式开课。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6675925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDfnpQfKV54uI4BDj5lm9xTAmoiajj5NZSagdeVo6iaOyCHD1ou01epaQkZZIBFYc42BtAYyBEpqU3g/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>37f51d43a0eef3c53a641e600cd518fd</guid>
<title>这么做，你也可以开发JavaScript库！</title>
<link>https://toutiao.io/k/15pfkyt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;👆&lt;/span&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;span&gt;博文视点Broadview&lt;/span&gt;&lt;span&gt;”，获取更多书讯&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05669291338582677&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nr1VNxfeqxVOw2nPJHVH4xeZibzPY5F4ibOuOZLMsUMrzIibGB6KMw7EurSKv6DkrtLzuhYdBa30A9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近一年，互联网裁员现象愈演愈烈，很多大厂裁员的消息冲上了微博热搜，这不禁让很多程序员心中焦虑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6870229007633588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3mRiba3fGiaybyUnHlhpoaoCRdbkibQrtCNnvLD9QNU4NSVqPGyyCTicskOXGTmkF7iaCgH6I9WRndIERw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;393&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我也时常在想，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;什么样的人能够抵御这场互联网寒冬，抑或不怕重走一遍求职路呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;答案其实很简单，就是那些在无意义的“重复造轮子”内卷中依然能够修炼技术水平，具备真正的技术实力的人！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于前端开发工程师而言，很多人在日复一日的“写页面”中慢慢弱化了自身的技术实力，当意识到这一点时，又希望能够扭转这种局面，提升技术功力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但这又带了一个新的问题：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;通过什么来提升技术功力呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;我认为，开发JavaScript库是一个很好的途径。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回首过去十年，我一直致力于开源库的开发和维护，一路走来，我也从这个领域的“小白”慢慢成长为“专家”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这十年，支撑我坚持在库开发领域耕耘的是热爱分享，我特别希望能把自己做的东西分享给别人，分享的内容既可以是课程、博客文章，也可以是代码。&lt;span&gt;在我看来，一份分享出去的代码片段，就是一个开源库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;十年来，前端技术推陈出新，新的开源库如雨后春笋般涌现，相信大部分读者都曾从这些开源库中受益。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;平日里，我们更多关注的是库的使用，很少关注库开发技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，JavaScript库开发技术在这十年中也经历了快速发展，其中基于新的技术标准开发而成的库，我将其称为&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;“现代JavaScript库”&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于前端技术发展迅速，如今开发一个现代JavaScript库并不容易，其中涉及非常多的知识、工具和经验。比如，库如何兼容日益复杂的前端环境，库如何使用打包工具，库的单元测试如何做，等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正因为这种复杂性，目前npm上的开源库并不都是现代JavaScript库，很多开源库还在使用十几年前相对比较原始的技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了依赖开发技术，将一个库开源还需要很多准备工作。一个库开源后的运营和维护也涉及很多知识。由于缺乏经验，很多库开源后并没有被推广开来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;有人可能会问，为什么要学习JavaScript库开发技术呢？学会开发JavaScript库有什么好处呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，开发JavaScript库能够带来非常多的好处。就像我前面提到的，从开发JavaScript库开始，修炼自己的技术水平，对于求职、转型、技术进阶，都大有裨益。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我现身说法，开发和开源库不仅可以帮助他人解决问题，也能给自己带来很多成长。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;总之，开发和开源现代JavaScript库可以带来非常大的收获，我希望每一个前端开发者都不要错过这个机会。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，我有一个愿望，那就是，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;人人都可以开发自己的JavaScript库。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再小的个体也应该有机会在社区中发声，社区不应该只要月亮的光辉，漫天繁星同样是美好世界的重要组成，只要我们愿意，每个人都可以开发属于自己的JavaScript库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每一个前端开发者都身处两个世界，即业务世界和开源世界。大部分人熟悉业务世界，但对开源世界了解不多。所谓“技多不压身”，&lt;span&gt;多了解开源世界，融入开源世界，你一定会有更多收获。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，开发和开源一个现代JavaScript库并非易事，上述困难阻碍了很多读者开发自己的JavaScript库，我也曾被这些困难深深折磨过。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过十年的摸爬滚打，我不禁想：如果能有一个师傅手把手教我该多好，那我当初能少走多少弯路！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于此，我终于下定决心写一本现代JavaScript库开发领域的图书，将自己十年的经验总结沉淀，希望能够手把手教各位读者快速掌握现代JavaScript库开发技术，于是便有了&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《现代JavaScript库开发：原理、技术与实战》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一书。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.00125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3mRiba3fGiaybyUnHlhpoaoCRSospiciaoMTfmTQ6HLUwWYib5ZcnWNHmqfVqP0Pm2l2u6e5iar7qEngmyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-width=&quot;215px&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;34405&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;本书内容&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本书主要涵盖三部分内容，可以满足读者不同阶段的学习诉求。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第1～5章&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;介绍如何开发和开源一个现代JavaScript库，这部分内容可以帮助读者快速达成库开发目标。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第6～7章&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;介绍现代JavaScript库的设计最佳实践和安全最佳实践，这部分内容可以极大提高读者开发JavaScript库的质量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第8～11章&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;为实战部分，本书精选了9个典型库作为案例，带领读者了解不同类型的JavaScript库的开发要点。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8455696202531645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3mRiba3fGiaybyUnHlhpoaoCRImBYFWiaL5HkVVy4VibIHvujAic7ka3ysX7NsiakAYvbt4ltU2kIniccGfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;790&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;34405&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;专家书评&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;每个前端工程师都想开发自己的框架或库，然而大部分开发者在繁杂的业务代码中都在使用别人的框架或库。本书教你如何从零开始创建自己的库，如何突破技术瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;——Deno核心代码贡献者、vscode-deno作者  迷渡（justjavac）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然这本书的主题是设计与实现库，但读完之后会发现，书中那些使代码更加健壮可靠、使开发流程更加方便轻松的知识，无论是否用于开发一个库，都会对我们很有帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;——Apache Member、Apache ECharts项目管理委员会主席  羡辙&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过跟随作者的思路由浅入深地进行实践，你能切身体会到开源库的创作精髓，这种临摹和实践无疑会帮你扎实基础，让你在不知不觉间有所收获，得到提高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;——稀土掘金社区负责人  月影&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近年来，越来越多的企业开始有自研或修改库的需求，非常高兴看到具有实际经验的工程师愿意抽出大量精力去完成一本系统介绍前端库开发的书。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;——极客时间《重学前端》专栏作者  程劭非（winter）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.567807351077313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3mRiba3fGiaybyUnHlhpoaoCRRqX5gtUvflSl7YyxGvWkcG4bM9Me1Bcia3hgD4ajm8wCt0jChd9QU2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;96391&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;十年开源经验沉淀&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;3.5044359949302915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3mRiba3fGiaybyUnHlhpoaoCROQo3B1zGIpRlG4nG2Ia11ZyNg1G0j1blfulsyUWppqMyH30xYcOPgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.4302030456852792&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3mRiba3fGiaybyUnHlhpoaoCR0DGy2qlGSZfxcHKbTHpf9ypicDkCE0vlM9gqJJvLib7QUrCnqSibK8sJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;788&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p draggable=&quot;true&quot;&gt;&lt;span&gt;如今，本书已全面上线，如果你也想开发属于自己的JavaScript库，提升开发技能，精进自身开发技术，一定不可以错过本书哦~~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3mRiba3fGiaybyUnHlhpoaoCRRXITUhnrcNACmCF5eJTuLaCiaBdHx4UP1F3GxX5Be02qfbGiaMdgDn1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot; data-width=&quot;149px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;京东限时五折优惠，快快扫码抢购吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;发布：刘恩惠&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;审核：陈歆懿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Puv74VHDtgNjyJbpQvt1gicgSpjrlpDy6BheYoAmtjiaF7cdIuPkuUlFkw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1920&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;29.8961937716263&quot; data-ratio=&quot;0.01574074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Pu8DQL5f0FQIuDZC87yrAuNLy4frEdlMeWkthrlzczb0RbMOBQCAwDrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;如果喜欢本文&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;欢迎&lt;/span&gt; &lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;留言&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享至朋友圈&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 三连&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;92644&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt; &lt;strong&gt;热文推荐 &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;574&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;244&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3m3jibtjia3lCrCvUY6N19QMZ3FjCcpuHouXkdLicQVUiaLicgR8cgSbk7RA8G427GKowhbEvVefuJp53g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▼点击阅读原文，了解本书详情~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a24eadd208993423093c7a009595f0ac</guid>
<title>流量路由技术解析</title>
<link>https://toutiao.io/k/ivv6tqt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-backh=&quot;108&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/yvBJb5IiafvmiaBnXvbGDru5fwoNCGwhCdc2xA5ahKkfBePMIjkboicYBKINVBY43ZVG1CibXJORibIAzkhpAke0PhQ/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;流量路由，顾名思义就是将具有某些属性特征的流量，路由到指定的目标。流量路由是流量治理中重要的一环，本节内容将会介绍流量路由常见的场景、流量路由技术的原理以及实现。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;流量路由的业务场景&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以基于流量路由标准来实现各种业务场景，如标签路由、金丝雀发布、同机房优先路由等。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;标签路由是按照标签为维度对目标负载进行划分，符合条件的流量匹配至对应的目标，从而实现标签路由的能力。&lt;/span&gt;&lt;span&gt;当然基于标签路由的能力，赋予标签各种含义我们就可以实现各种流量路由的场景化能力。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4398447606727037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl2uBTFj2ZZJWib9cF3aAuwQwLnLiaRq43HPPt5nMRvaDa6U1FYM6VtuLgEo0k5iceOzhK2TaUUIibJJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1546&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;金丝雀发布是一种降低在生产中引入新软件版本的风险的技术，方法是在将更改推广到整个基础架构并使其可供所有人使用之前，缓慢地将更改推广到一小部分用户。&lt;/span&gt;&lt;span&gt;金丝雀发布是一种在黑与白之间，能够平滑过渡的一种发布方式。&lt;/span&gt;&lt;span&gt;让一部分用户继续用旧版本，一部分用户开始用新版本，如果用户对新版本没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到新版本上面来。&lt;/span&gt;&lt;span&gt;一直都有听说，安全生产三板斧的概念：&lt;/span&gt;&lt;span&gt;可灰度、可观测、可回滚。&lt;/span&gt;&lt;span&gt;那么灰度发布能力就是帮助企业软件做到快速迭代验证的必备能力。&lt;/span&gt;&lt;span&gt;在K8s中金丝雀发布的最佳实践如下：&lt;/span&gt;&lt;span&gt;第一步：&lt;/span&gt;&lt;span&gt;新建灰度 Deployment，部署新版本的镜像，打上新版本的标签。&lt;/span&gt;&lt;span&gt;第二步：&lt;/span&gt;&lt;span&gt;配置针对新版本的标签路由规则。&lt;/span&gt;&lt;span&gt;第三步：&lt;/span&gt;&lt;span&gt;验证成功，扩大灰度比例。&lt;/span&gt;&lt;span&gt;第四步：&lt;/span&gt;&lt;span&gt;若验证成功，将稳定版本的应用更新成最新镜像；&lt;/span&gt;&lt;span&gt;若验证失败，把灰度的 Deployment 副本数调整到 0 或删除该 Deployment。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当企业的发展，微服务的数量会逐渐增多。在有一定规模的一定数量的微服务情况下，一次发版可能涉及到的服务数量会比较多，微服务链路也相当较长。全链路灰度可以保证特定的灰度流量可以路由到所有涉及到的灰度版本中。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7704918032786885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl2uBTFj2ZZJWib9cF3aAuwQYPZL6nDK92PBYrSDYwjZ7HM8Iuiann47iaNjE5WVnVHgcic9ZGhEBMQDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1098&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;当企业的对稳定性的要求变高时，企业的应用会选择部署在多个可用区中提高应用的可用性，避免某个可用区出现问题后导致影响应用的可用性。当应用在不同的可用区部署时，应用间跨可用区调用可能会被因为远距离调用造成的网络延迟影响，同可用区优先路由会让我们的Consumer应用优先调用当前可用区内的Provider应用，可以很好地减少这种远距离调用造成的影响，同时当某个可用区出现问题后，我们只需在流量入口处将当前可用区的流量隔离掉，其他可用区的流量不会访问至当前可用区的节点，可以很好地控制某个可用区出现问题后的影响面。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41410256410256413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl2uBTFj2ZZJWib9cF3aAuwQv8q7hc5FaseibrAejLXnzlzWfJOaqAGIFn3wUbdlBjPd5BOKmGhQh7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1560&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;流量路由能力实现的场景众多，上面只是列举了一些典型的场景，下面我们将从流量路由原理入手，剖析流量路由的实现与技术细节。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;流量路由原理&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;需要实现上述所提的流量路由的场景，那么对于Consumer应用来说，同一个 Provider 应用的不同节点之间是有一些特殊的标识。&lt;span&gt;金丝雀发布场景来说，新版本代码所部署的节点需要被标上成新版本的标识；同机房优先路由来说，Provider节点要被标识上机房的信息；全链路灰度场景来说，灰度环境的节点需要被带上灰度标。因此，我们需要在Provider服务注册的过程中，就在注册到注册中心的地址信息中带上治理场景所需的标识。&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;首先介绍一下节点打标的能力，我们先看看 Apache Dubbo 的设计，其中 Dubbo 服务节点的地址信息使用 URL 模型来承载。&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; URL &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; Serializable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; protocol;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; host;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; int port;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; path;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; final Map&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;&amp;gt; parameters;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;举个简单的例子，假如 Consumer 收到这样一条 dubbo://10.29.0.102:20880/GreetingService?tag=gray&amp;amp;az=az_1 地址信息，表示 GreetingService 服务使用的是 dubbo 协议，服务绑定的 ip 与 port 分别为  10.29.0.102 跟 20880，该地址携带上了 tag=gray、az=az_1 这样两条元数据信息，分别表示当前节点的标签为灰度，当前节点所处的可用区（az：Availability Zone 为云上的机房的可用区概念）为 az_1 。那么节点打标的能力其实就比较明确了，我们在服务提供者向注册中心注册服务地址之前，我们在当前服务提供者的地址信息上增加需要增加的元数据信息比如 `verion = gray`，比如在 Apache Dubbo 的 URL 中增加 paramters 信息，一般来说元数据信息都是 k-v 的 map 结构，这样框架向注册中心注册该节点时会为其添加需要的标签信息`verison=gray`。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;相似的， Spring Cloud 中通过表示服务节点信息的抽象&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Server&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MetaInfo&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; String host;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; port = &lt;span class=&quot;code-snippet__number&quot;&gt;80&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;Sentinel2.0 希望作为流量治理能力的实现，考虑到会被较多框架即成，因此需要考虑到各个框架的通用点以及本身设计的易用性，Sentinel2.0 中使用 Instance 模型表示服务节点信息的抽象，并且在其中保留了原有类型的引用。&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; Instance {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; host;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Integer port;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Map&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;&amp;gt; metadata;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; targetInstance;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;其中 metadata 用来存储用于服务治理的元数据，比如AZ标、版本标签等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到目前为止，我们算是搞明白了 Consumer 收到的 Provider 的地址列表长什么样子。假设 Consumer 收到了 如下图所示 GreetingService 服务的6条地址，那么我们该如何进行选择呢？&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5821596244131455&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl2uBTFj2ZZJWib9cF3aAuwQVV8iaXO7Efn5EKGVMP5WAlibQlhuN4yfyG8orAIO3DlviaJA1nf3kNfoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;639&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;算是进入到正题，我们看一下 Sentinel2.0 是如何实现流量路由能力的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前我们在 Sentinel2.0 中分别抽象了InstanceManager、RouterFilter 以及 LoadBalancer 三个对象，并通过 ClusterManager 将它们管理起来。其中 InstanceManager 将地址列表按需进行存储与管理，RouterFilter做为流量路由能力实现的主体，LoadBalancer做为负载均衡能力实现的主体。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31274638633377133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl2uBTFj2ZZJWib9cF3aAuwQ8UNAer7WCiahp9YdeChGhLS0CO7II15kboLPO3AgZmzhMb2Znworoiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1522&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Dubbo 在收到注册中心同步过来的 Provider URL 之后会生成对应的 Invoker ，Invoker 列表我们可以理解为就是可以调用的 Provider 节点列表的抽象。流量路由则是需要将传入的 Invoker 列表按照路由规则进行路由筛选，筛选出符合路由规则的服务提供者，即符合路由规则的 Invoker 列表。我们如何可以通过 Sentinel2.0 的抽象来实现流量路由的能力呢？当地址通知下来后，我们需要通过 instanceManager#storeInstances 将地址列表进行缓存。&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(BitList&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.notify(invokers);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    instanceManager.storeInstances(invokersToInstances(invokers));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;在流量路由处，我们则调用 clusterManager#route 实现地址路由。&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; BitList&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; doRoute(BitList&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation, &lt;span class=&quot;code-snippet__built_in&quot;&gt;boolean&lt;/span&gt; needToPrintMessage, Holder&amp;lt;RouterSnapshotNode&amp;lt;T&amp;gt;&amp;gt; routerSnapshotNodeHolder, Holder&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;&amp;gt; messageHolder) throws RpcException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TrafficContext trafficContext = getTrafficContext(invocation);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;Instance&amp;gt; instances = clusterManager.route(trafficContext);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; instancesToInvokers(instances);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;其中 ClusterManager 会将路由执行的逻辑交给 RouterFiler.route 进行执行。&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Instance&amp;gt; route(TrafficContext context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Instance&amp;gt; instances = instanceManager.getInstances();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (RouterFilter routerFilter : routerFilterList) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        instances = routerFilter.filter(instances, context);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; instances;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;每个 RouterFilter 服务路由都可以包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用哪些服务提供者；一次微服务调用的地址列表可以由多个 RouterFilter 服务路由共同影响，比如我们希望当前的 Consumer 流量访问到在同时符合灰度发布以及同可用区优先调用路由规则的节点上。我们可以按照需求增加路由链中的 RouterFilter，并且路由链的 Route 方法是循环调用每个 RouterFilter 的 Route 方法。并且上一个 Router 的输出 Invoker 列表会做为下一个 Router 的输入。介绍到这里，大家可能对下图会有一个更加深刻的理解了。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05560882070949185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl2uBTFj2ZZJWib9cF3aAuwQLtcwnmsqp6CK9PSI87fkrHqAIRCibZGOy2mTYiaN6EIBYdmiagNHh55MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2086&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;路由的整体模型大家已经理解了，我们来重点看一下具体的 RouterFilter 服务路由是如何实现的。&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RouterFilter&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;List&amp;lt;Instance&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(List&amp;lt;Instance&amp;gt; instanceList, TrafficContext context)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; TrafficException&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;RouterFilter 的 Route 方法会在每次请求调用时被执行，Route 方法有关键的两个入参 InstanceList 跟 TrafficContext，instanceList 是可调用的服务提供者节点列表的抽象。&lt;/span&gt;&lt;span&gt;TrafficContext 是当前调用流量的请求上下文的抽象，我们可以从中读到请求中携带着的 RouterFilter 所关心的一些元数据（比如当前请求的AZ信息、请求参数中指定 key 的值等内容）。&lt;/span&gt;&lt;span&gt;Route 方法会在每次调用时候根据请求中的上下文信息结合路由规则计算出当前请求需要匹配的目标节点特征，并遍历当前的地址列表，根据目标节点特征进行地址过滤。&lt;/span&gt;&lt;span&gt;筛选出目标节点的地址列表，是输入地址列表的子集，然后传递给下一个 RouterFilter。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;RouterFilter 的 Route 方法逻辑的伪代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;Instance&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(List&amp;lt;Instance&amp;gt; instanceList, TrafficContext context)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; TrafficException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;Instance&amp;gt; targetInstances = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Instance instance : instanceList) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (trafficRouteMatch(instance, context)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            targetInstances.add(instance);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; targetInstances;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;instanceList 为输入地址列表，targetInstances 为输出地址列表即当前 Router 服务路由的结果。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span/&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;Sentinel2.0流量路由规划&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6217765042979942&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl2uBTFj2ZZJWib9cF3aAuwQBqRRic86ehKdSqgpsPptvMxBmQe9HJrOheFsJog1D9HtvsyGQqYpvaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2792&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Sentinel2.0 将基于 OpenSergo 流量路由规则实现基本的流量路由能力，支持多种流量路由策略、负载均衡策略、虚拟工作负载等。Sentinel2.0 期望支持 Http、RPC、SQL等微服务各种流量的路由能力，并且可以快速被各主流微服务框架所集成。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>