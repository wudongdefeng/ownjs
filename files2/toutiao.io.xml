<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3561cc544ba2d04c9a2045ee7ec92468</guid>
<title>ElasticSearch 必知必会：Reindex 重建索引</title>
<link>https://toutiao.io/k/9bqeyyu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者： 京东物流 康睿&lt;/p&gt;

&lt;h1&gt;1.重建索引需求背景&lt;/h1&gt;

&lt;h2&gt;1.1 集群版本升级&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ES版本兼容性&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 同一大版本范围内升级，索引读写兼容&lt;/li&gt;
&lt;li&gt; 不同大版本升级，索引读写不兼容，需要重建索引&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-296fe1a7ee57c2ef25de80e720b1226dec0.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.2 集群迁移&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;集群索引迁移&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 集群迁移，索引服务不停机，数据提前迁移&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;1.3 索引分片数量调整&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;分片数量变更&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 原有分片数量太少，重建变多&lt;/li&gt;
&lt;li&gt; 原有分片数量太多，重建变少&lt;/li&gt;
&lt;li&gt; ES索引分片，一旦创建，原索引是不能修改分片数量的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-8ba1391a4c62e1bf6bce1b612d6bb556cc0.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.4 索引文档结构变更&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;文档结构变更&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 字段类型变更，已有索引字段类型是不可以修改的&lt;/li&gt;
&lt;li&gt; 字段属性变更，历史数据的字段属性是不会刷新的&lt;/li&gt;
&lt;li&gt; 文档对象结构变更&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-9d5ee23efd1d8028ffd8e85c508a16a8913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;2.常用重建索引方式&lt;/h1&gt;

&lt;h2&gt;2.1 Reindex初识&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;索引重建说明&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 重建是创建新索引，原有索引保留&lt;/li&gt;
&lt;li&gt; 原有索引_source必须开启，否则找不到原始数据&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;索引重建建议，严格业务场景，目标索引mapping结构建议先创建好，不使用es动态推测字段类型的方式。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;POST_reindex
{
  &quot;source&quot;: {
    &quot;index&quot;: &quot;原始索引&quot;
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;新目标索引&quot;
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2.2 Url参数解读&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;URL参数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; refresh，目标索引是否立即刷新&lt;/li&gt;
&lt;li&gt; waif_for_active_shards, 重建索引分片响应设置&lt;/li&gt;
&lt;li&gt; Scroll, 快照查询时间&lt;/li&gt;
&lt;li&gt; slicing, 重建并行任务切片&lt;/li&gt;
&lt;li&gt; Max_docs , 单次最大数据量，条数&lt;/li&gt;
&lt;li&gt; requests_per_second . 单次执行的重建文档数据量&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;2.3 Request body参数解读&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;请求参数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; confilicts, 索引数据冲突如何解决，直接覆盖还是中断&lt;/li&gt;
&lt;li&gt; source: 原索引配置信息&lt;/li&gt;
&lt;li&gt; dest，新索引配置信息&lt;/li&gt;
&lt;li&gt; script，脚本处理，修改原索引信息后再写入新索引 &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-1afc445a1eb13ad2b860241a5c209f43323.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;2.4 Response 参数解读&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;响应参数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 成功数&lt;/li&gt;
&lt;li&gt; 更新数&lt;/li&gt;
&lt;li&gt; 新增数&lt;/li&gt;
&lt;li&gt; 失败数 &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-9cbe9dd366839afa93aa18178a94284c171.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;2.5 重建索引任务管控&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;任务管控必要性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 重建索引是一个异步任务，由ES后台进程完成调度执行，集群可能有并行其他异步任务，有时需要中断停止或查看进度&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;任务管控API&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; _tasks，服务端API &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-14a997ca4ca51e177585639487c8ab249ee.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;3.高级索引重建方式&lt;/h1&gt;

&lt;h2&gt;3.1 单秒数据量阈值控制&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;单秒数据量控制&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; requests_per_second&lt;/li&gt;
&lt;li&gt; 默认1000，设置-1则不限制&lt;/li&gt;
&lt;li&gt; 生产重建时，建议控制范围500-1000左右&lt;/li&gt;
&lt;li&gt; 控制重建速度，防止集群瞬间IO过大 &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-a4236ad6661cd007bd03d73f4e22335d789.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;3.2人工切片&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;数据切片应用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 人为指定切片数量，并行任务&lt;/li&gt;
&lt;li&gt; 用于降低索引redinx速度&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;POST_reindex
{
  &quot;source&quot;: {
    &quot;index&quot;: &quot;my-index-000001&quot;,
    &quot;slice&quot;: {
      &quot;id&quot;: 0,  // 执行下标，从0开始，即0切第一批数据做迁移，1切第二批数据做迁移
      &quot;max&quot;: 2  // 切分分片数
    }
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;my-new-index-000001&quot;
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-06ff1991472b2676387561eb8d561729ec1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3.3 自动切片&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;自动切片&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 仅需指定自动切片大小即可，后续的调度由es完成&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;POST_reindex?slices=5&amp;amp;refresh
{
  &quot;source&quot;: {
    &quot;index&quot;: &quot;my-index-000001&quot;
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;my-new-index-000001&quot;
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3.4 限制reindex重建数据的范围&lt;/h2&gt;

&lt;h3&gt;3.4.1 query&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;限制查询条件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 基于DEL语言规则编写，可以任意复杂，限制数据范围&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;POST_reindex
{
  &quot;source&quot;: {
    &quot;index&quot;: &quot;my-index-000001&quot;,
    &quot;query&quot;: {
      &quot;term&quot;: {
        &quot;user.id&quot;: &quot;kimchy&quot;
      }
    }
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;my-new-index-000001&quot;
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.4.2 max docs&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;限制数据条数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 限制重建数据总条数，默认全部&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;POST_reindex
{
  &quot;max_docs&quot;: 1,
  &quot;source&quot;: {
    &quot;index&quot;: &quot;my-index-000001&quot;
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;my-new-index-000001&quot;
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3.5 多索引重建&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;多索引重建&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; ES也支持将多个索引数据合并到一个索引里面去&lt;/li&gt;
&lt;li&gt; 若多个索引数据ID相同，则会相互覆盖&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;POST_reindex
{
  &quot;source&quot;: {
    &quot;index&quot;: [&quot;my-index-000001&quot;, &quot;my-index-000002&quot;]
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;my-new-index-000002&quot;
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3.6 限制重建索引数据字段&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;限制重建索引数据字段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; source filter&lt;/li&gt;
&lt;li&gt; 原有数据字段过多，需要限制筛选部分进行重建&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;POST_reindex
{
  &quot;source&quot;: {
    &quot;index&quot;: &quot;my-index-000001&quot;,
    &quot;_source&quot;: [&quot;user.id&quot;, &quot;_doc&quot;]
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;my-new-index-000001&quot;
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3.7 字段重命名&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;字段名重命名&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 原有的数据字段名称不合理，重新按照新字段命名&lt;/li&gt;
&lt;li&gt; 基于脚本机制修改&lt;/li&gt;
&lt;li&gt; ES字段名称原始是不允许修改的，但通过脚本可以操作 &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-84330122cc607aa0058a05e1378b8c4e8ce.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;3.8 修改原始文档数据&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;修改原始文档数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 基于脚本 &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-00109656572f16056719d790001ba8d451c.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;4.跨集群索引重建&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;跨集群操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt; 基于集群通信，类同远程机制&lt;/li&gt;
&lt;li&gt; 需设置跨集群白名单，配置在dist集群 &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-f9b4d72562829d53a06ac796b21f14cbebf.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;5.索引重建注意事项&lt;/h1&gt;

&lt;h2&gt;5.1 数据量阈值控制&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;控制好索引重建速率，防止过快&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;5.2 索引访问交叉影响&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;建议先新建好dist索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>188eb6ad5d61525ebae2caa7b8265851</guid>
<title>程序员“起名”头痛根治指南</title>
<link>https://toutiao.io/k/o39bs28</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：marinewu，腾讯 PCG 客户端开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;There are only two hard things in Computer Science: cache invalidation and naming things.&lt;/p&gt;&lt;p&gt;-- Phil Karlton&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件开发中一个著名的反直觉就是“起名儿”，这个看上去很平凡的任务实际上很有难度。身边统计学显示，越是有经验的程序员，越为起名头痛，给小孩起名儿都没这么费劲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名的困难可能来自于以下几个方面：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;信息压缩：命名的本质是把类/方法的信息提炼成一个或几个词汇，这本身需要对抽象模型的准确理解和概括。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;预测未来：类/方法的职责可能会在未来有变化，现在起的名字需要考虑未来可能的变动。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语言能力：缺少正确的语法知识，或是缺少足够的词汇量。本来英文就不是大部分中国人的母语，更甚者，计算机的词汇表不同于日常交流词汇表，有大量黑话。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不良设计：混乱的职责分布、不清晰的抽象分层、错误的实现，都会导致无法起出好的名字。在这个意义上，起名字其实是对设计的测试： 如果起不出名字来，很可能是设计没做好 -- 重新想想设计吧。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名就像写作，会写字不等于会写作。而且，命名更多像是一门艺术[注](此处艺术的含义取自于 Knuth -- 命名会诉诸品味和个人判断。)，不存在一个可复制的命名操作手册。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文描述一些实用主义的、可操作的、基于经验的命名指南，并提供了一个代码词汇表，和部分近义词辨析。本文没有涉及讨论名字的形而上学，例如如何做更好的设计和抽象以利于命名，也没有涉及如何划分对象等，也无意讨论分析哲学。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;命名原则&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名是一门平衡准确性和简洁性的艺术 -- 名字应该包含足够的信息能够表达完整的含义，又应该不包含冗余的信息。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;准确 Precision&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名字最重要的属性是&lt;strong&gt;准确&lt;/strong&gt;。名字应该告诉用户这个对象/方法的意图 -- “它是什么” 和 “它能做什么”。 事实上，它是体现意图的第一媒介 -- 名字无法表现含义时读者才会阅读文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名字应该是有信息量的、无歧义的。以下一些策略可以增加名字的准确度：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可读&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最基本的语法原理，是一个类（Class/Record/Struct/... 随你喜欢)应该是一个名词，作为主语。一个方法应该是动词，作为谓语。 换言之，&lt;strong&gt;类“是什么”，方法“做什么”&lt;/strong&gt;, 它们应该是可读的，应该是 &lt;code&gt;[Object] [Does ...]&lt;/code&gt; 式的句子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可读是字面意思，意味着它应该是通顺的，所以应该：&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;避免 API 中使用缩写&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像是给老板的汇报中不会把商业计划写成 Busi Plan 一样，也不应该在公开 API 中使用一些奇怪的缩写。现在已经不是 1970 年了，没有一个方法不能超过 8 个字符的限制。把类/方法的名字写全，对读者好一点，可以降低自己被同事打一顿的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;creat&lt;/code&gt; 是个错误，是个错误，是个错误！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，首字母缩略词的术语是可行并且推荐的，如 &lt;code&gt;Http&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt;, &lt;code&gt;Url&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是可用的、得到普遍认可的缩写：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;configuration -&amp;gt; config&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;identifier -&amp;gt; id&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;specification -&amp;gt; spec&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;statistics -&amp;gt; stats&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;database -&amp;gt; db (only common in Go)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;regular expression -&amp;gt; re/regex/regexp&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;未得到普遍认可的缩写：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;request -&amp;gt; req&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;response -&amp;gt; resp/rsp&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;service -&amp;gt; svr&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;object -&amp;gt; obj&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;metadata -&amp;gt; meta&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;business -&amp;gt; busi&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;req/resp/svr 在服务名称中很常见。这非常糟糕。请使用全称。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;再次说明：以上的说明是针对 API 名称，具体包括公开对象/函数名字、RPC/Web API 名字。在局部变量使用缩写不受此影响。&lt;/p&gt;&lt;/blockquote&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;避免双关&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对类/方法的命名，不要使用 2 表示 To, 4 表示 For。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func foo2Bar(f *Foo) *Bar   &lt;span&gt;// BAD&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;func fooToBar(f *Foo) *Bar  &lt;span&gt;// GOOD&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;func to(f *Foo) *Bar        &lt;span&gt;// Good if not ambiguous.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;2/4 这种一般只有在大小写不敏感的场合才会使用，例如包名 e2e 比 endtoend 更可读。能区分大小写的场合，不要使用 2/4。&lt;/p&gt;&lt;/blockquote&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;合乎语法&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然不能完全符合语法（例如通常会省略冠词），但是，方法的命名应该尽量符合语法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Car&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; tireReplace(Tire tire);  &lt;span&gt;// BAD, reads like &quot;Car&#x27;s tire replaces&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; replaceTire(Tire tire);  &lt;span&gt;// GOOD, reads like &quot;replace car&#x27;s tire&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于命名的语法见“语法规则”一章。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用&lt;strong&gt;单一&lt;/strong&gt;的概念命名&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名本质上是分类（taxonomy）。即，选择一个单一的分类，能够包含类的全部信息，作为名字。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;考虑以下的角度：&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，把大象装进冰箱，需要有三步 -- 打冰箱门打开，把大象放进去，把冰箱门关上。但是，这可以用单一的概念来描述：“放置”。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Fridge&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    public &lt;span&gt;void&lt;/span&gt; openDoorAndMoveObjectIntoFridgeAndCloseDoor(Elephant elphant); &lt;span&gt;// BAD&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    public &lt;span&gt;void&lt;/span&gt; put(Elephant elphant); &lt;span&gt;// GOOD&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应该使用所允许的&lt;strong&gt;最细粒度&lt;/strong&gt;的分类&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免使用过于宽泛的类别。例如，这世界上所有的对象都是“对象”，但显然，应该使用能够完整描述对象的、最细颗粒度的类别。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Fridge&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    public put(Elephant elephant);   &lt;span&gt;// GOOD.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    public dealWith(Elephant elephant);  &lt;span&gt;// BAD: deal with? Anything can be dealt with. How?&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简而言之，名字应该是包含所有概念的分类的&lt;strong&gt;下确界&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简洁 Simplicity&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名字长通常会包含更多信息，可以更准确地表意。但是，过长的名字会影响可读性。例如，“王浩然”是一个比“浩然·达拉崩吧斑得贝迪卜多比鲁翁·米娅莫拉苏娜丹尼谢莉红·迪菲特（defeat）·昆图库塔卡提考特苏瓦西拉松·蒙达鲁克硫斯伯古比奇巴勒·王”可能更好的名字。(来自于&lt;a href=&quot;https://www.bilibili.com/video/BV1sx411k7ug/&quot; data-linktype=&quot;2&quot;&gt;达啦崩吧&lt;/a&gt;)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此，我提出一个可能会有争议的观点：所有的编程语言的命名风格应该是&lt;strong&gt;趋同&lt;/strong&gt;的。不同于通常认为 Java 的命名会倾向于详尽，Go 的命名会倾向于精简，所有的语言对具体的“名字到底有多长”的建议应该是几乎一样的 -- 对外可见应该更详细，内部成员应该更精简。具体地：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;public，如 public 类的名字、public 方法的名字 - 应该详细、不使用缩写、减少依赖上下文。通常是&lt;strong&gt;完整名词短语&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;non-public，如类成员、私有方法 - 不使用缩写、可以省略上下文。下界是&lt;strong&gt;单词&lt;/strong&gt;，不应该使用单字符。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;local，如函数的局部变量 - 基本上是风格是自由的。不影响可读性的前提下，例如函数方法长度很短，可以使用单字符指代成员。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述规则像是 Go 的风格指南。但是，并没有规定 &lt;strong&gt;Java&lt;/strong&gt; 不能这样做。事实上，Java 的冗长是 Java 程序员的自我束缚。即使在 Java 的代码里，也可以这样写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BazelRuntime&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    public boolean exec(Command cmd) {&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; m = cmd.mainCommand();  &lt;span&gt;// YES, you can use single-letter variables in Java.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，在 Go 的代码中也不应该出现大量的无意义的缩写，尤其是导出的结构体和方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;type struct Runtime {} &lt;span&gt;// package name is bazel, so bazel prefix is unnecessary&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;type struct Rtm {}  &lt;span&gt;// BAD. DO NOT INVENT ABBREVIATION!&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，由于语言特性，在命名风格上可能会有差异。例如，由于 Go 的导入结构体都需要加包前缀，所以结构名中通常不会重复包前缀；但 C++/Java 通常不会依赖包名。但是，上述的原则仍然是成立的 -- 可见度越高，应该越少依赖上下文，并且命名越详尽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Google Go Style Guide 是唯一详尽讨论命名长度的风格指南，非常值得参考，并且&lt;strong&gt;不限于 Go 编程&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://google.github.io/styleguide/go/decisions#variable-names&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一致 Consistency&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个容易被忽略的命名的黄金原则是&lt;strong&gt;一致性&lt;/strong&gt;。换言之，名字的选取，在项目中应该保持一致。遵守代码规范，避免这方面的主观能动性，方便别人阅读代码。通常情况下，一个差的、但是达成共识的代码规范，也会远好于几个好的、但是被未达成共识的规范。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.566&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvauBhEtVLicFXOicg241ic96QicKbhNo9WmhzQjk8hKYhqlBQic6QlydhbqYeeZzOIm09IyXEzdb7CnJUiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;这个图我能用到下辈子: xkcd 927&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是仅符合代码规范是不够的。如同所有的语言，同一个概念，有多个&lt;strong&gt;正确&lt;/strong&gt;的写法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑以下的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;message Record {&lt;br/&gt;    int32 start_time_millis = &lt;span&gt;1&lt;/span&gt;;  &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    int32 commited_at = &lt;span&gt;2&lt;/span&gt;;  &lt;span&gt;// Wait. Why not commit_time? Anything special?&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    int32 update_time = &lt;span&gt;3&lt;/span&gt;; &lt;span&gt;// What unit? Also millis?&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    google.types.Timestamp end_time = &lt;span&gt;4&lt;/span&gt;;   &lt;span&gt;// WTF? Why only end_time is typed?&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几种都是合理的(虽然不带单位值得商榷）。但是，如果在一个代码中出现了多种风格，使用起来很难预测。您也不想使用这样的 API 吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在修改代码的时候，应该查看上下文，&lt;strong&gt;选择已有的处理方案&lt;/strong&gt;。一致性大于其它要求，即使旧有的方案不是最好的，在做局部修改时，也应该保持一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个可考虑的建议是项目的技术负责人应该为项目准备项目的专有词汇表。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;语法规则&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;类/类型&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类应该是&lt;strong&gt;名词&lt;/strong&gt;形式，通常由单个名词或名词短语组成。其中，主要名词会作为名词短语的末尾。例如 Thread, PriorityQueue, MergeRequestRepository。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;名词短语通常不使用所有格。如，并非 &lt;code&gt;ServiceOfBook&lt;/code&gt;，也不是 &lt;code&gt;BooksService&lt;/code&gt; (省略 &#x27;），而是 &lt;code&gt;BookService&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;接口&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口的命名规则和类相同。除此之外，当接口表示&lt;strong&gt;可行动类型&lt;/strong&gt;时，可使用另一个语法，即 &lt;code&gt;Verb-able&lt;/code&gt;。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface Serializable {&lt;br/&gt;  byte[] serialize();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public interface Copyable&amp;lt;T&amp;gt; {&lt;br/&gt;  T copy();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public interface Closable {&lt;br/&gt;  &lt;span&gt;void&lt;/span&gt; close();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（Go 通常不使用这个命令风格。只在 Java/C++ 中使用。）&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;辅助类&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只在 Java（注 1）中使用。一个类或概念所有的辅助方法应该聚合在同一个辅助类。这个类应该以被&lt;strong&gt;辅助类的复数形式&lt;/strong&gt;出现。不推荐使用 &lt;code&gt;Helper/Utils&lt;/code&gt; 后缀表示辅助类。尤其不推荐使用 &lt;code&gt;Utils/Helpers&lt;/code&gt; 做类名，把所有的辅助方法包进去。如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Collections&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// For Collection&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Strings&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// For String&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseRuleClasses&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// For BaseRuleClass&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StringUtils&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// WORSE!&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StringHelper&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// WORSE!&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注 1: 客观来说，这适用于所有强制 OOP 的语言（所有强制把方法放在类里的语言）。但是除了 Java, 没有别的语言这么烦啦。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法通常是&lt;strong&gt;谓语（动词）&lt;/strong&gt;，或是 &lt;strong&gt;谓宾（动词+名词）&lt;/strong&gt; 结构。注意以上语法中，动词都在最前端。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Expander&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; expand(&lt;span&gt;String&lt;/span&gt; attribute);  &lt;span&gt;// 主-谓&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; expandAndTokenizeList(&lt;span&gt;String&lt;/span&gt; attribute, List&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; values);  &lt;span&gt;// 主-谓-宾&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，有以下特例值得注意：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;访问器 Getter&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接使用所 Get 的对象的&lt;strong&gt;名词形式&lt;/strong&gt;，即 &lt;code&gt;Foo()&lt;/code&gt;。不要使用 &lt;code&gt;GetFoo()&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Java: 所有的 Getter 都需要一个 get 前缀是来自于过时的 Java Beans Specification，以及 Javaer 的思想钢印。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Counts&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;;  // &lt;span&gt;GOOD&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;GetCounts&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;;  // &lt;span&gt;BAD&lt;/span&gt;: &lt;span&gt;UNNECESSARY&lt;/span&gt;.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;断言 Predicate&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言函数指返回结果是布尔型（即真伪值）的函数。它们通常有以下命名格式：&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;系动词： 主-系-表&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即 &lt;code&gt;isAdjective()&lt;/code&gt; 或 &lt;code&gt;areAdjective()&lt;/code&gt; 格式，表示是否具有某个二元属性。类似于 Getter，可以省略系语，只使用表语，即： &lt;code&gt;adjective()&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;IsDone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {} &lt;span&gt;// OK-ish. But could be better.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Done&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {} &lt;span&gt;// GOOD. Why bother with is/are?&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;CheckEnabled&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; { &lt;span&gt;// BAD. Nobody cares if it is &quot;checked&quot;. Just tell the user if it is enabled.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; enabled;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Enabled&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {} &lt;span&gt;// GOOD.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;情态动词： 主-助谓-谓-(宾/表)&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;情态动词也是常见的断言形式。常见的是以下三个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;should: 查询当前是否&lt;strong&gt;应该&lt;/strong&gt;执行给定的实义动词。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;can: 查询当前类所在状态是否&lt;strong&gt;可以&lt;/strong&gt;执行给定的实义动词。某些情况下，也可以使用&lt;strong&gt;第三人称单数&lt;/strong&gt;作为更简洁的代替。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;must: 特殊形式。不同于前两者，会&lt;strong&gt;执行&lt;/strong&gt;给定的实义动词。must 表示执行必须成功，否则会抛出不可恢复错误 (throw/panic)。类似于 C++ 中常见的 OrDie 后缀。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Compile&lt;/span&gt;&lt;span&gt;(s &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;Regexp&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;  // &lt;span&gt;Returns&lt;/span&gt; &lt;span&gt;error&lt;/span&gt; &lt;span&gt;upon&lt;/span&gt; &lt;span&gt;failure&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;MustCompile&lt;/span&gt;&lt;span&gt;(s &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;Regexp&lt;/span&gt;   // &lt;span&gt;Panics&lt;/span&gt; &lt;span&gt;upon&lt;/span&gt; &lt;span&gt;failure&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(r Regexp)&lt;/span&gt; &lt;span&gt;CanExpand&lt;/span&gt;&lt;span&gt;(s &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; // &lt;span&gt;Whether&lt;/span&gt; &lt;span&gt;s&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;legal&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;can&lt;/span&gt; &lt;span&gt;be&lt;/span&gt; &lt;span&gt;expanded&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(r Regexp)&lt;/span&gt; &lt;span&gt;Expands&lt;/span&gt;&lt;span&gt;(s &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; // &lt;span&gt;Whether&lt;/span&gt; &lt;span&gt;r&lt;/span&gt; &lt;span&gt;expands&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;, &lt;span&gt;i&lt;/span&gt;.&lt;span&gt;e&lt;/span&gt;. &lt;span&gt;r&lt;/span&gt; &lt;span&gt;can&lt;/span&gt; &lt;span&gt;expand&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(r Regexp)&lt;/span&gt; &lt;span&gt;ShouldReset&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; // &lt;span&gt;Whether&lt;/span&gt; &lt;span&gt;the&lt;/span&gt; &lt;span&gt;state&lt;/span&gt; &lt;span&gt;requires&lt;/span&gt; &lt;span&gt;reset&lt;/span&gt;. &lt;span&gt;Does&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;perform&lt;/span&gt; &lt;span&gt;de&lt;/span&gt;-&lt;span&gt;facto&lt;/span&gt; &lt;span&gt;reset&lt;/span&gt;.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(r Regexp)&lt;/span&gt; &lt;span&gt;Reset&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;   // &lt;span&gt;De&lt;/span&gt;-&lt;span&gt;facto&lt;/span&gt; &lt;span&gt;reset&lt;/span&gt;.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;表尝试： 主-maybe/try-谓-（宾/表）&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文 &quot;must&quot; 的反面，表示尝试性的执行，并且失败不会造成严重后果：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;maybe 前缀用以表示指定的行为有前置条件，也在方法中执行。如果前置条件不满足，不会执行指定行为。通常不会出现在公开 API。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;try 通常用于 &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/exceptions-and-performance&quot; data-linktype=&quot;2&quot;&gt;Try-Parse Pattern&lt;/a&gt;，用于避免抛出异常。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt; maybeExecute() {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!predicate()) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// execute&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::unique_ptr&amp;lt;DateTime&amp;gt; ParseOrDie(std::string_view dateTime);&lt;br/&gt;&lt;br/&gt;bool TryParse(string_view dateTime, DateTime* dateTime);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第三人称单数&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个常见场景是我们希望表示类拥有某些属性，但是使用助动词并不合适。如果前文描述，常见的选择是使用&lt;strong&gt;第三人称单数的&lt;a href=&quot;https://en.wikipedia.org/wiki/Stative_verb&quot; data-linktype=&quot;2&quot;&gt;静态动词(Stative verb)&lt;/a&gt;(注 1)&lt;/strong&gt; 表示类满足给定断言。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func (l *List) Contains(e interface{}) bool&lt;br/&gt;&lt;br/&gt;func (r Regexp) Expands(s string) bool&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注 1: 简单地说，静态动词是表示状态的动词，与动态动词(Dynamic verb)表示动作对应。或言“持续性动词”。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一阶逻辑 First-order logic, Predicate Logic&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一阶逻辑量词也是常见的前缀：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;all 表示&lt;strong&gt;所有&lt;/strong&gt;对象满足给定要求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;any 表示&lt;strong&gt;任意&lt;/strong&gt;对象满足给定要求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;none 表示&lt;strong&gt;没有任何&lt;/strong&gt;对象满足给定要求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语法： &lt;code&gt;&amp;lt;一阶量词&amp;gt;&amp;lt;动词|形容词&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Stream&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// Returns whether all elements of this stream match the provided predicate.&lt;/span&gt;&lt;br/&gt;    boolean allMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; p);&lt;br/&gt;    &lt;span&gt;// Returns whether any elements of this stream match the provided predicate.&lt;/span&gt;&lt;br/&gt;    boolean anyMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; p);&lt;br/&gt;    &lt;span&gt;// Returns whether no elements of this stream match the provided predicate.&lt;/span&gt;&lt;br/&gt;    boolean noneMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; predicate)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;介词&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介词经常与某些动词固定搭配，因此，通常可以省略动词，而只使用介词作为方法名称。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;to: 转换至另一对象，等价于 convertTo。to 会产生一个全新的对象，通常不持有对原对象的引用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;as: 返回某个视图，等价于 returnViewAs。一个“视图(View)” 通常是对原有对象的另一角度的抽象，通常会持有对原有数据的引用，而不会产生新的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;of/from/with：构造新对象，等价于 createOutOf/createFrom/createWith。见下文“工厂模式”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;on: 监听事件，等价于 actUpon。见下文“事件”。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Foo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt; &lt;span&gt;toList&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// Convert to (Construct a new instance of) a new List. Creates a new list.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt; &lt;span&gt;asList&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// Return a List as a different **view**. Holds reference of the original reference.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; Foo &lt;span&gt;of&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;    &lt;span&gt;// Construct Foo as a factory method.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; Foo &lt;span&gt;from&lt;/span&gt;&lt;span&gt;(Bar)&lt;/span&gt;&lt;/span&gt;;  &lt;span&gt;// Construct Foo from Bar.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;Foo &lt;span&gt;with&lt;/span&gt;&lt;span&gt;(Bar)&lt;/span&gt;&lt;/span&gt;;  &lt;span&gt;// Construct a new Foo by replacing Bar with new Bar.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;&lt;span&gt;(ClickEvent e)&lt;/span&gt;&lt;/span&gt;;  &lt;span&gt;// Act upon click event.&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考资料：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://journal.stuffwithstuff.com/2016/06/16/long-names-are-long/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://journal.stuffwithstuff.com/2009/06/05/naming-things-in-code/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://habr.com/en/post/567870/#names_in_engineering&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://medium.com/wix-engineering/naming-convention-8-basic-rules-for-any-piece-of-code-c4c5f65b0c09&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://github.com/kettanaito/naming-cheatsheet&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[[Effective Java]] Item 68: Adhere to generally accepted naming conventions&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;词汇表&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下文按用途归类了常见动词和名词，并对同义近义词进行了辨析。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类/名词&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;类继承&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Abstract/Base
Impl
Default&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Interface: 通常不需要额外的表示。不要加 &lt;code&gt;I&lt;/code&gt; 前缀，或后缀 &lt;code&gt;FooInterface&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Abstract class: 通常会添加 &lt;code&gt;Abstract/Base&lt;/code&gt; 前缀以明确属性。这是因为 Interface/Impl 是常见的，Class 也是常见的，但是基于继承的抽象类是特殊的、应该予以避免的，应该给予特殊标记。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Implementation:&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果不实现接口，通常不需要任何特殊修饰符。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果以 &quot;is-a&quot; 的方式实现了某个接口，那么通常实现会以 &lt;code&gt;{InterfaceName}Impl&lt;/code&gt; 的方式命名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果一个类实现了多个接口，那么通常这个类应该是以作为主要目标的接口为基础命名。例如 &lt;code&gt;class BazelBuilderImpl implements BazelBuilder, AutoClosable, Serializable&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果一个接口有多个实现，通常会基于它们本身的实现特点命名，并且&lt;strong&gt;不&lt;/strong&gt;使用 &lt;code&gt;Impl&lt;/code&gt; 后缀。&lt;code&gt;Default&lt;/code&gt; 通常用来命名默认的实现，即其它实现如果不存在会 fallback 到的实现。如果所有的实现都是平等地位，那么不要使用 &lt;code&gt;Default&lt;/code&gt; 命名。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// https://github.com/bazelbuild/bazel with some fake examples&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;public interface SkyFunction {}&lt;br/&gt;&lt;br/&gt;public abstract &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractFileChainUniquenessFunction&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SkyFunction&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;public &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultSkyFunction&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SkyFunction&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;public &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BazelModuleInspectorFunction&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SkyFunction&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;public interface VisibilityProvider {}&lt;br/&gt;&lt;br/&gt;public final &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VisibilityProviderImpl&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;C++ 的 interface 是通过抽象类不存在基类成员变量模拟。通常接口所有的成员函数都是公开纯虚函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;Impl&lt;/code&gt; 表示实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Abstract class: 通常会添加 &lt;code&gt;Base&lt;/code&gt; 后缀以明确属性。这是因为 Interface/Impl 是常见的，Class 也是常见的，但是基于继承的抽象类是特殊的、应该予以避免的，应该给予特殊标记。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// levelDB&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// includes/db.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DB&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;  virtual ~DB(); &lt;span&gt;// MUST!&lt;/span&gt;&lt;br/&gt;  virtual Status Delete(&lt;span&gt;const&lt;/span&gt; WriteOptions&amp;amp;, &lt;span&gt;const&lt;/span&gt; Slice&amp;amp;) = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// db/db_impl.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DBImpl&lt;/span&gt; : &lt;span&gt;public&lt;/span&gt; &lt;span&gt;DB&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// rocksDB&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Base class&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CacheShardBase&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Go 的 interface 从来不是用来做 &quot;is-a&quot; 定义的。Go 的 interface 契约通过 &lt;strong&gt;duck typing&lt;/strong&gt; 满足。interface 应该在消费方定义，而非提供方。因此， &lt;code&gt;interface Foo/struct FooImpl&lt;/code&gt; &lt;strong&gt;不应该出现&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 也并没有抽象类，虽然可以将一个结构体嵌入到另一个结构体中。所以 &lt;code&gt;Base/Abstract&lt;/code&gt; 也极少出现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;原则上，Go 的类关系更为简化，命名更强调意义优先，因此在命名时避免使用修饰性前后缀。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;异常&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Exception/Error&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有的&lt;strong&gt;异常&lt;/strong&gt;扩展应该以 &lt;code&gt;Exception&lt;/code&gt; 为后缀。所有的&lt;strong&gt;错误&lt;/strong&gt;应该以 &lt;code&gt;Error&lt;/code&gt; 为后缀。 对异常和错误的区别请参见 https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IllegalArgumentException&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;public &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OutOfMemoryError&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++ 的 &lt;code&gt;exception&lt;/code&gt; 通常指语法特性，与 &lt;code&gt;throw&lt;/code&gt; 对应，而 &lt;code&gt;error&lt;/code&gt; 可以用来表示具体的异常错误。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// stdlib&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::exception;&lt;br/&gt;std::runtime_error&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有的错误都是 &lt;code&gt;error&lt;/code&gt;。因此，所有自定义的对 &lt;code&gt;error&lt;/code&gt; 的扩展都以 &lt;code&gt;Error&lt;/code&gt; 作为后缀。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;os.PathError&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Test&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java/Go/C++ 均使用 Test 作为测试类的后缀。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;模块&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Module/Component&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Module/Component 通常会在框架中使用。不同的语言/框架对于 Module/Component 有不同的定义。 在非框架代码中应该减少使用 Module/Componenet 等命名，因为可能与已有框架冲突，并且 Module/Componenet 过于宽泛而缺少实质意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Module/Component 是意义相近的词，都可以表示“模块”或者“组件”。两者虽然有细微的分别，但是框架通常都显式（即在文档中指定，或者通过框架语义约束）地把它们定义为框架语境下的某些结构层级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结，Module/Component 命名应该注意：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;只应该在框架代码中使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Module/Component 应该在框架的语境中给出确切的定义。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Service&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Service 通常用于作为 C-S 架构下的服务提供者的名称的后缀，如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;HelloService&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但除此之外，Service 可以表示任何&lt;strong&gt;长期存活的、提供功能的组件&lt;/strong&gt;。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BackgroundService &lt;span&gt;// Android 后台服务&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;ExecutorService &lt;span&gt;// 线程池执行服务，也是服务&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;BAD: 不要使用 Svr 缩写。使用全称。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;容器&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Holder/Container/Wrapper&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Holder/Container/Wrapper 都表示“容器”，具有同一个意图：为一个类增加额外的数据/功能，例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;添加某些语境下的元数据(Decorator 模式)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;做适配以在另一个环境中使用（Adapter 模式）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常的结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ObjectHolder&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  private final &lt;span&gt;Object&lt;/span&gt; object;&lt;br/&gt;  &lt;span&gt;// other stuff ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  public &lt;span&gt;Object&lt;/span&gt; object() {}&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Other methods&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三个词没有区别。在同一个项目中，应该&lt;strong&gt;保持一致&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;控制类&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Manager/Controller&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Manager 和 Controller 是同义词。它们通常用来表示专门控制某些类的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个词有以下几个常见场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Manager 管理资源，如 &lt;code&gt;DownloadManager&lt;/code&gt;, &lt;code&gt;PackageManager&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Manager 通常特指管理对象的生命周期，从创建到销毁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Controller 通常在某些架构中，尤其是 MVC (Model-View-Controller）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使如此，Manager/Controller 是无意义词汇，出现时充满了可疑的味道 -- 类应该管理它们自己。 Controller/Manager 多了一层抽象，而这很可能是多余的。 认真考虑是否需要 Manager/Controller。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;辅助类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Util/Utility/Utils/Helper/{ClassName}s&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;辅助类是强制 OOP 的语言(i.e. Java) 所需要的特殊类。通常它们是一些辅助方法的合集。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将与某个类型相关的辅助方法放在一个类中，并且以复数形式命名辅助类。如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Java std lib&lt;/span&gt;&lt;br/&gt;public final &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Strings&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;public final &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Lists&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;public final &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Collections&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免使用 &lt;code&gt;Util/Utility/Utils/Helper&lt;/code&gt;。它们是无意义词汇。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用全局方法。如果担心命名污染，将之置入更细粒度的 namespace。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用全局方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;函数式&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Function/Predicate/Callback&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Function 通常表示任意函数。 Predicate 表示命题，即通常返回类型为 &lt;code&gt;bool&lt;/code&gt;。 Callback 指回调函数，指将函数作为参数传递到其它代码的某段代码的引用。换言之， Function 可以作为 Callback 使用。因此，Callback 在现代函数式编程概念流行后，通常很少使用。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟悉 Java 8 开始提供的函数式语义。如果可以使用标准库的语义，不要自己创建名词。 注意 &lt;code&gt;Function&lt;/code&gt; 指单入参、单出参的函数。如果是多入参的函数，直接定义 FunctionalInterface 并且按用途命名，例如 &lt;code&gt;OnClickListener.listen(Context, ClickEvent)&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// java.util.function&lt;/span&gt;&lt;br/&gt;Predicate&amp;lt;T&amp;gt;   &lt;span&gt;// f(T) -&amp;gt; bool&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Function&lt;/span&gt;&amp;lt;T, R&amp;gt; &lt;span&gt;// f(T) -&amp;gt; R&lt;/span&gt;&lt;br/&gt;Consumer&amp;lt;T&amp;gt;    &lt;span&gt;// f(T) -&amp;gt; void&lt;/span&gt;&lt;br/&gt;Supplier&amp;lt;T&amp;gt;    &lt;span&gt;// f() -&amp;gt; T&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;first-class 函数的标准类型为 &lt;code&gt;std::function&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++ 表示命名函数对象的惯用法是 &lt;code&gt;fun&lt;/code&gt;。Stdlib 中会缩写 &lt;code&gt;function&lt;/code&gt; 为 &lt;code&gt;fun&lt;/code&gt;，如 &lt;code&gt;pmem_fun_ref&lt;/code&gt;，因此与 stdlib 一致，在代码中不要使用 &lt;code&gt;fn&lt;/code&gt; 或是 &lt;code&gt;func&lt;/code&gt; 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 通常使用 &lt;code&gt;Func&lt;/code&gt; 或是 &lt;code&gt;Fn&lt;/code&gt; 表示函数类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;type ProviderFunc func(config ConfigSource, source PassPhraseSource) (Provider, error)&lt;br/&gt;&lt;br/&gt;type cancelFn func(context.Context) error&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在同一个项目中，应该&lt;strong&gt;保持一致&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为参数时，函数不会特意标明 &lt;code&gt;Fn&lt;/code&gt;，而是遵从普通的参数命名方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func Sort(less func(a, b string) int)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;换言之，函数是一等公民。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;设计模式类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类/方法通常都按它们的行为模式来命名。恰好，设计模式就归类抽象了很多行为模式。所以设计模式提供了很多好的名字。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建式&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Factory: 工厂模式。通常，使用工厂方法即可，不需要一个额外的工厂类。只有当工厂特别复杂，或者工厂有状态时再考虑使用工厂类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Builder：构建者模式。一般来说 Builder 都是作为 inner class，如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Foo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FooBuilder&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;行为式&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Adapter: 适配器&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 GoF 中 Adapter 本来是将一个类封装以可以被作为另一个类型被调用，这样调用方不需要额外改变代码。这种用途通常被内化到容器上，见上文[容器类]部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在现代，Adapter 更多地被作为 数据类 -&amp;gt; 数据类的转化，如常见的 pb -&amp;gt; pb：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProtoAdapter&lt;/span&gt;&amp;lt;&lt;span&gt;S&lt;/span&gt;, &lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Message&lt;/span&gt;&amp;gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Decorator：装饰器&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 GoF 中 Decorator 本来是将一个类作为抽象类，通过组合+继承实现添加功能。实际上现代的编程实践中往往通过直接提供一个容器的封装提供装饰功能，见上文 [容器类]部分。 所以 GoF 式 Decorator 并不常见，除非像 Python 在语法层面提供了装饰器。在 Java 中类似的功能是&lt;strong&gt;注解&lt;/strong&gt;。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Delegation：委派模式&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GoF 中是非常基本的模式：由一个类负责接受请求，并把请求转发到合适的实例类中执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RealPrinter&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Printer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  RealPrinter printer;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Delegate 非常常见，也提供了两个名字，请注意区分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Delegate&lt;/code&gt; 是&lt;strong&gt;被委任&lt;/strong&gt;的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Delegator&lt;/code&gt; 是&lt;strong&gt;委任&lt;/strong&gt;对象。
所以，通常情况下 &lt;code&gt;Delegator&lt;/code&gt; 在命名中会更常见，类似于 &lt;code&gt;Dispatcher&lt;/code&gt;。&lt;code&gt;Delegate&lt;/code&gt; 更多作为一个类型或是接口被实现。具体的选择参见 [编排] 部分。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Facade: 外观模式&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GoF 中 Facade Pattern 通常是指为子系统提供一个更高层的统一界面，屏蔽子系统的独有的细节。 在现实中，Facade 通常用来为非常复杂的类/系统定义一个较为简化的界面，如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// proto, extremely complicated TripResponse&lt;/span&gt;&lt;br/&gt;message TripResponse {&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  string last_message = &lt;span&gt;3279&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TripResponseFacade&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  private final TripResponse response;&lt;br/&gt;&lt;br/&gt;  Trip trip();&lt;br/&gt;&lt;br/&gt;  Endpoint source(); &lt;span&gt;// Abstracted and processed&lt;/span&gt;&lt;br/&gt;  Endpoint target(); &lt;span&gt;// Abstracted and processed&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Facade 与 Adapter 的主要区别在于 Facade 的主要目的是为了&lt;strong&gt;简化&lt;/strong&gt;，或者说更高层次的抽象，并且通常简化的界面不服务于专门的对接类。 Adapter 通常是为了一个特定的对接类实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意 &lt;code&gt;Facade&lt;/code&gt; 命名通常可以省略。仅当你的意图是明确告知用户这是关于某个类的外观时使用。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Proxy：代理模式&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GoF 中代理模式用来添加一层抽象，以对实际类进行控制，并添加某些行为（如 lazy/memoized），或是隐藏某些信息（例如可见性或是执行远程调用）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Proxy 与 Facade 的区别在于 Proxy 通常是为了额外的控制/记录等行为，而非只是为了更高的抽象/简化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意 Proxy 作为代码模式时，通常不应该出现在命名之中。使用具体的 Proxy 的目的作为命名，如 &lt;code&gt;LazyCar&lt;/code&gt; 或是 &lt;code&gt;TracedRuntime&lt;/code&gt;，而非 &lt;code&gt;CarProxy&lt;/code&gt; 或是 &lt;code&gt;RuntimeProxy&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Proxy 还有另一个含义就是真正的“代理”，如代理服务器。在这种情况下，使用 Proxy 是合适且应该的。这也是另一个为什么代理模式不应该用 Proxy 命名的原因。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Iterator: 迭代器&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时至今日仍然最常见的模式之一。Interator 有以下两个术语，不要混淆：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Iterable： 迭代容器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Iterator： 迭代器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Visitor: 访问者模式&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问者模式用来遍历一个结构内的多个对象。对象提供 &lt;code&gt;accept(Visitor)&lt;/code&gt; 方法，调用 &lt;code&gt;Visitor.visit&lt;/code&gt; 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使如此，&lt;code&gt;Visitor&lt;/code&gt; 应该并不常见，因为它可以简单地被函数式的写法替换：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Car&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;void&lt;/span&gt; accept(Consumer&amp;lt;Car&amp;gt; visitor); &lt;span&gt;// No longer need to define Visitor class.&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Observer/Observable: 观察者模式&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Observer/Publisher/Subscriber/Producer/Consumer&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时至今日最常见的模式之一。和事件驱动编程(Event-based)有紧密关系 -- Oberservable 发布消息，所有注册的 Obeserver 会接收消息。 Publisher/Subscriber 也是类似的，它们的区别在于 Observer 模式往往是强绑定的 -- 注册和分发通常在 Observable 类中实现； 而 PubSub 模式通常有专门的 Message Broker，即 Publisher 与 Subscriber 是完全解耦的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PubSub 与 Producer/Consumer 的区别是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Publisher/Subscriber: 在事件流系统中，表示 &lt;strong&gt;1:N&lt;/strong&gt; 广播/订阅。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Producer/Consumer: 在整个流系统中，专指 &lt;strong&gt;1:1&lt;/strong&gt; 生产/消费。Producer/Consumer 也是 Pub/Sub 系统的组件（广播也是一对一广播的）。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;有些系统(Kafka)使用 Consumer Group 表示 Subscriber。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有的消息注册的模式由三部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Notification： 消息本身&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Sender：消息发送者/注册&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Receiver： 消息接收者&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于命名参见 [事件] 部分。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Strategy：策略模式&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Strategy/Policy&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;策略模式在 GoF 中用以指定某个行为在不同场景下的不同实现，作为“策略”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Strategy 模式往往不是很显式。现代通常使用 Strategy 表示实际的“策略”，即对信息不同的处理策略，而不采取 Strategy 模式的含义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在“策略”这个语义中，Strategy/Policy 没有区别。在同一个项目中，应该&lt;strong&gt;保持一致&lt;/strong&gt;。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Command：命令模式&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令模式在 GoF 中以类开代表实际行动，将行动封装，以支持重复、取消等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Command 在现代编程实践中可以通过简单的函数式方案替换，如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Function&lt;/span&gt;&amp;lt;T, T&amp;gt; command; &lt;span&gt;// Java&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;std::&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&amp;lt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;&amp;amp;(&lt;span&gt;const T&amp;amp;&lt;/span&gt;)&amp;gt; &lt;span&gt;command&lt;/span&gt;; // &lt;span&gt;C&lt;/span&gt;++&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Command&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;T*&lt;/span&gt;) &lt;span&gt;T&lt;/span&gt;* // &lt;span&gt;Go&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现代通常使用 Command 表示实际的“命令”，而不采取 Command 模式的含义。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Null Object 模式&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Tombstone&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Null Object 模式不在 GoF 当中。它是一个用来代替 null 的 object，对其所有的操作都会被吞掉。 Null Object 主要是为了避免空指针。 合理的&lt;strong&gt;零值&lt;/strong&gt;，例如 go time.Time = 0，也可以理解为一种 Null Object。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常会有一个专门的对象表示 Null Object。可以借用 &lt;code&gt;Tombstone&lt;/code&gt; 表示 Null Object。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Object Pool 对象池模式&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Pool&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象池模式不在 GoF 当中。它是将一系列昂贵的对象创建好放在一个池子中，并使用户通过向池子申请对象，而不再自己手动地创建/销毁对象。最著名的池化的例子是线程池，即 ThreadPool。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pool 通常用来表示对象池子，例如 &lt;code&gt;ThreadPool, ConnectionPool&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Arena&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Arena 是指 &lt;a href=&quot;https://en.wikipedia.org/wiki/Region-based_memory_management&quot; data-linktype=&quot;2&quot;&gt;Region-based memory management&lt;/a&gt;，是指一片连续的内存空间，用户在其中分配创建对象，管理内存。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前/后缀&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并发/异步&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Concurrent
Synchronized
Async&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们需要特别标明一个类是线程安全的。通常这是特意为了与另一个线程不安全的实现做区分。典型的例子是 &lt;code&gt;HashMap&lt;/code&gt; 和 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;。如果一个类只是单纯是线程安全的，那么通常不需要在名字里特意说明，在文档里说明即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/** This class is designed to be thread safe. */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SomeClassThreadSafe&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** This class is immutable thus thread safe. */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SomeClassImmutable&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Concurrent&lt;/code&gt; 通常是用来说明该类是线程安全的前缀。&lt;code&gt;Synchronized&lt;/code&gt; 是另一个在 Java 中可用的标明类是线程安全的前缀。但是，这通常说明这个类是通过 &lt;code&gt;synchronized&lt;/code&gt; 机制来保证线程安全的，所以只在 Java 中使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个常见的场景是同一个&lt;strong&gt;方法&lt;/strong&gt;有两种实现：同步阻塞和异步不阻塞的。在这种情况下，通常会命名异常不阻塞的方法为 &lt;code&gt;{synchronizedMethod}Async&lt;/code&gt;，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public T exec();&lt;br/&gt;public Future&amp;lt;T&amp;gt; execAsync();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个异步的方法并没有对应的同步方法，通常不需要加 &lt;code&gt;Async&lt;/code&gt; 后缀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中，如果一个方法是意图在其它协程中异步执行，不需要加 &lt;code&gt;Async&lt;/code&gt; 后缀。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存/惰性&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Cached/Buffered
Lazy
Memoized&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名词辨析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Cached 表示&lt;strong&gt;获取&lt;/strong&gt;的对象会被缓存，保留一段时间，在缓存期间不会重新获取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Buffered 与 Cached 同义。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Lazy 表示这个对象会被在第一次调用时&lt;strong&gt;创建&lt;/strong&gt;，之后一直保留&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Memoized 通常表示执行结果会在第一次&lt;strong&gt;计算&lt;/strong&gt;后被记忆，之后不会再重复计算&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意 Buffered 不应该与 Buffer 混淆。 Buffer 作为名词专指“缓冲区”。
注意 Cached 不应该与 Cache 混淆。 Cache 作为名词专指“缓存”。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cached/Buffered 应该在项目中是&lt;strong&gt;一致&lt;/strong&gt;的。 Cached/Lazy/Memoized 取决于对象是被获取的，还是创建的，还是计算获得的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不可变性&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Mutable
Immutable&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Mutable 显式地声明一个类是可变的，Immutable 显式地声明一个类是不可变的。 通常情况下，类似于并发安全性，是否可变应该在类文档中说明，而不应该在类名中，显得臃肿。只有当一个类同时有可变/不可变版本时，可以使用 &lt;code&gt;Class/ImmutableClass&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;存储/数据/处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据类&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Object
Data
Value
Record
Entity
Instance&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面几个都可以用来表示一个表示数据的类。但是这些词是典型的“无意义词汇”，如果把它们从名字中删除，仍然可以表示完整意义，那么应该删掉。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CarObject&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CarEntity&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CarInstance&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Car&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MapKey&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MapValue&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// OK. Couldn&#x27;t be shortened.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LoggingMetricsData&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LoggingMetricsValue&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LoggingMetricsRecord&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Logging&lt;/span&gt; &lt;span&gt;Metrics&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DrivingRecord&lt;/span&gt; &lt;/span&gt;{} &lt;span&gt;// OK. Couldn&#x27;t be shortened.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Statistics/Stats&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表示“统计数据”。 Stats 是公认的可用的 Statistics 的缩写，Java/C++/Go 均可。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;存储&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Storage
Database
Store
DB&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Cache&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Verbs:
- save/store/put&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Storage/Database/Store/DB 都可以作为“存储服务”，即广义上的“数据库”（不是必须是完整的 DBMS）。 其中，在 C++/Go 中 DB 是常见且可接受的。在 Java 中通常使用全称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目内应该选择一个术语保持一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;save/store/put&lt;/code&gt; 在数据库类中是同义词。同一个项目中应该保持&lt;strong&gt;一致&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据格式&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Schema
Index
Format
Pattern&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名词辨析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Schema 借用数据库的概念，指数据的&lt;strong&gt;结构&lt;/strong&gt;模式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Index 借用数据库的概念，专指数据的&lt;strong&gt;索引&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Format/Pattern 通常是泛指的“模式/格式”概念。实际出现时，Format/Pattern 往往和字符串相关，如 Java 使用 Pattern 表示正则表达式。在非公共代码中，Format/Pattern 通常过于宽泛，应该考虑选用更细化的名词。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;哈希&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Hash/Digest/Fingerprint/Checksum&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hash/Digest 哈希是一种将任何数据映射到一个较小的空间的方法。映射通常被称为**哈希函数(Hash Function)&lt;strong&gt;，映射值通常被称为&lt;/strong&gt;摘要(Digest)**。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; Hash(Data) = Digest&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Checksum 出自编码论，可以理解为一种特殊的哈希函数，用来检查文件的&lt;strong&gt;完整性&lt;/strong&gt;。换言之，如果一份数据出现了任何变动，Checksum 应该期待会改变。（但是 Checksum 实际上并不要求唯一性，见 Fingerpint）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fingerprint 类似于 Checksum，但是 Fingerprint 通常更严格，它通常要求最少有 64-bit，使得任何两个文件只要不同，几乎（概率意义上接近 2^-64）不可能有同一份指纹，即&lt;strong&gt;唯一性&lt;/strong&gt;。（但是 Fingerprint 的定义不要求密码安全性即 cryptographic）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 Checksum 只是作为文件变更校验，而 Fingerprint 可以作为数据的唯一标记。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在命名时，优先使用 Fingerprint/Checksum，或其它特定指定用途的术语。当以上均不合适时，回退到更泛化的概念，即 Digest。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;流式编程&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Stream
Source/Sink
Pipe/Piped&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流式编程通常有自己的专有词汇表。具体地：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Stream 表示流式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Source 表示数据源（输入），Sink 表示 数据汇（输出）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;动词词汇表，如 map/reduce/join/filter/iterate/do/window/key/evict/peek/trigger/slide/...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原则是：选择你的团队里最常使用的流式处理系统所使用的词汇表。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;状态&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;State/Status&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很讽刺地，很多人认为这两个词有区别，但是他们认为区别的点各不相同。见下文参考文献。笔者倾向于认为它们其实没什么本质区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鼓励使用 State 表示状态。因为 HTTP 和 RPC 已经占用了 Status 这个术语，为了避免误解，使用 State 表示自定义状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://stackoverflow.com/questions/1162816/naming-conventions-state-versus-status&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://softwareengineering.stackexchange.com/questions/219351/state-or-status-when-should-a-variable-name-contain-the-word-state-and-w&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;鼓励使用 State: https://google.aip.dev/216&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;计数&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Num/Count/Size/Length/Capacity&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Num/Count 表示数量，但不强制是某个 collection 的长度。推荐使用 Count。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Size/Length 表示容器&lt;a href=&quot;https://km.woa.com/group/45812/articles/show/%E5%AE%B9%E5%99%A8%E5%9C%A8%E8%BF%99%E9%87%8C%E6%B3%9B%E6%8C%87%E2%80%9C%E8%83%BD%E5%AE%B9%E7%BA%B3%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E2%80%9D%EF%BC%8C%E4%B8%8D%E7%89%B9%E6%8C%87%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%AE%B9%E5%99%A8%E3%80%82&quot; data-linktype=&quot;2&quot;&gt;1&lt;/a&gt;的&lt;strong&gt;当前&lt;/strong&gt;容量。遵循语言惯例，通常使用 Size。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Capacity 通常表示容器的&lt;strong&gt;最大&lt;/strong&gt;容量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方法/动词&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动词是句子的精髓。选择精准的动词是代码可读性的关键。 本章对动作做了分类，并且提供了部分备选。如果动词有反义词，它们会被聚合在一个词条中。 本章的词汇有两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;动词&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以执行一个动作为主的某些行为类，即 -er 模式，如 Producer。 -able 模式，如 Writable 是类似的，因为不再赘述。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建/提供&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Producer/Provider/Supplier/Generator/Constructor/Factory
Builder.build&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Verbs:&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;create/from/of/with/valueOf/instance/getInstance/newInstance/getFoo/newFoo&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;get/peek&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;make/generate&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建/提供名词辨析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Producer/Supplier/Provider 同义词，都表示“提供一个对象”。这些提供者可能是惰性的(Lazy)。实例未必由这些提供者创建（虽然通常是）。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;它们对应的动词是工厂方法的常见命名，即:&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;create/from/of/with/valueOf/instance/getInstance/newInstance/getFoo/newFoo&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;推荐在项目中使用同一种命名。推荐使用 of/from，更短。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Generator 通常专指某些需要经过计算的、特殊的对象，例如 ID。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Constructor 通常是指一个复杂对象的构建器，不是指构造函数。它通常用于比 Builder 更复杂的构建 (Builder 通常不会附带逻辑）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Factory 是专职的工厂类。当工厂方法较为复杂，需要抽出，或者有状态的工厂时使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Builder 见前文 [Builder 构建者模式]&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动词辨析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;get vs peek&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;get 是广义的“获取”，在绝大部分场景下适用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;peek 也是“获取”对象，但是这里强调的是对原对象&lt;strong&gt;无副作用&lt;/strong&gt;。在函数式编程中会用来作为不破坏数据流的旁路操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;create vs make vs generate&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;消费&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Consumer.accept/consume/poll&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费名词：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Consumer 是最常见的“消费者”，通常表示某个数据流的终端消费方。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对应的动词是 accept 或是 consume，遵守所使用消息队列框架的命名风格，否则，项目内保持&lt;strong&gt;一致&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;poll 特指数据是通过轮询(poll)，即 Consumer 通常主动获取消息，而非被推送(push)后处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意区分&lt;em&gt;轮 xun&lt;/em&gt; 中文的歧义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;poll 翻译为轮询，指一个客户端间断性地向外进行获取数据的&lt;strong&gt;行为&lt;/strong&gt;策略。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;round-robin 翻译为轮循，指以单一的方向循环接受信息/资源的&lt;strong&gt;分发&lt;/strong&gt;策略。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意轮询是 poll 不是 pull，虽然后者直觉上是“拉取&lt;strong&gt;，但&lt;/strong&gt; poll 强制间断性地主动地采样/获取数据，是正式的计算机术语。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查找&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Verbs:
- find/search/query&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同义词。推荐在项目中保持&lt;strong&gt;一致&lt;/strong&gt;。 具体地，这几个词实际上有细微的不一致。通常情况下它们可能有以下区分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;find 查询单个结果，search 查询一列符合条件的结果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;find 表示“找到”，即终态，search 表“搜索”，即行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;query 表示“查询”，类似于 search，但是暗示可能会有更高的成本。
但是，不要做这种程度的细分，大部分人认为它们是同义词。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考 https://stackoverflow.com/questions/480811/semantic-difference-between-find-and-search&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;拷贝&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Verbs:
- copy/clone&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同义词。遵循语言惯例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 使用 clone。 Go/C++ 使用 copy。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;添加&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Verbs:
- add/append/put/insert/push&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动词辨析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;append 专指添加到列表末。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;insert 强调可以插入到列表的任何位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;add 是通用的列表添加方案，&lt;code&gt;add(E)&lt;/code&gt; 等同于 &lt;code&gt;append&lt;/code&gt;，&lt;code&gt;add(index, E)&lt;/code&gt; 等同于 &lt;code&gt;insert&lt;/code&gt;。&lt;code&gt;addAll&lt;/code&gt; 用于批量添加。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;put 通常用于列表之外的添加场景。如 map, iostream。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;push 仅用于某些数据结构，如栈。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于自定义的可添加 api，应该贴近底层的标准库的数据结构所使用的动词。作为泛用的添加，使用 add。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;更新&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Verbs:
- set/update/edit&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同义词。在代码 API 中使用 set，在 RPC API 中使用 update。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;删除&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Verbs:
- remove/delete/erase/clear/pop&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动词辨析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;remove/delete/erase 是同义词。严格来说，remove 指移除，即暂时从容器中取出放置在一边，delete/erase 指删除，即将对象整个清除。但是在日常编程中不需要做这种区分。通常，代码 API 中使用 remove（或依语言惯例），RPC API 中使用 delete 作为标准方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;clear 通常表示 1) 清理列表，等效于 removeAll 2）清理状态，即恢复类到初始化状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pop 只在栈/队列等数据结构中使用，通常会返回对象并从数据结构中移除。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编排&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Scheduler/Dispatcher/Coordinator/Orchestrator/Delegator
- Verb: schedule/dispatch/orchestrate&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Scheduler/Dispatcher 均借用于操作系统概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名词辨析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Scheduler: 通常 Scheduler 用于分发&lt;strong&gt;中长期 Job&lt;/strong&gt;。换言之，Scheduler 通常涉及到资源分配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Dispatcher: 通常只负责接受事件，采用某些固定的策略分发任务，例如 round-robin。不涉及资源分配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Coordinator: 通常作为 Scheduler/Dispatcher 的同义词。鉴于其模糊性，推荐使用更细化的 Scheduler/Dispatcher&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Orchstrator：执行比简单的分发，即 scheduler/dispatcher 更复杂的任务/流程编排。通常，这些任务有前后依赖关系，会形成一个有向无环图。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对应动词为 orchestrate。 Orchestrator 的输出通常是工作流，即 Workflow。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Delegator: 专指委任。虽然形式类似，但是 Delegator 强调单纯的委任。参见 [Delegation: 委派模式]。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检查/验证&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Validator/Checker/Verifier
- Verb: validate/check/verify/assert&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Validation/Verification 的明确区分来自于软件测试。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Validation 通常指对产品符合用户/顾客预期的验证。外部用户会参与。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Verification 通常指产品合规/符合给定规范。通常是内部流程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在程序中，不沿用这种区分。通常：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Validator 用于输入检测&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Verifier 用于运行的不变量检测&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体地：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;check 用于输入校验。 validate 用于复杂的输入校验。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;assert/verify 用于不变量验证，尤其在单元测试中&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public &lt;span&gt;void&lt;/span&gt; process(&lt;span&gt;String&lt;/span&gt; s, ComplicatedObject co) {&lt;br/&gt;  checkNotNull(s); &lt;span&gt;// check&lt;/span&gt;&lt;br/&gt;  validateComplicatedObject(co); &lt;span&gt;// validate&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;@Test&lt;br/&gt;public &lt;span&gt;void&lt;/span&gt; testProcess() {&lt;br/&gt;  process(&lt;span&gt;&quot;ss&quot;&lt;/span&gt;, co);&lt;br/&gt;&lt;br/&gt;  Truth.assertThat(...); &lt;span&gt;// assert&lt;/span&gt;&lt;br/&gt;  verifyZeroInvocations(co); &lt;span&gt;// verify&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;执行/操作&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Task/Job/Runnable&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Executor/Operator/Processor/Runner
- Verb: exec/execute/do/process/run&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名词辨析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Runnable 是泛用的“带上文的可执行代码块”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Task 粒度比 Job 更细&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Job 通常是耗时更长的任务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，推荐不做区分，认为它们都是同义词。使用 Task 或者 Job 作为类名。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名词辨析： Processor/Executor/Operator 是从计算机架构借用的概念。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Executor: 常见。通常对应 Job/Task&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对应 execute。 exec 是可接受的公认的缩写。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Operator: 通常对应某些具体的操作类。更多使用本义，即操作符。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Processor：更多在文本文档(work/document processor)、数据处理(data processor) 语境下使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Runner: 通常对应 Runnable&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，推荐不做区分，认为它们都是同义词。日常编程中，使用 Executor 作为 Job 执行器。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开启 vs 关闭&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;toggle/switch/enable/disable/turnOn/turnOff/activate/deactivate&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二元状态的开启关闭。上述全是同义词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目中保持统一。注意比起 &lt;code&gt;toggle(bool)&lt;/code&gt; 和 &lt;code&gt;switch(bool)&lt;/code&gt;，更推荐分离的 &lt;code&gt;enable/disable&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取 vs 写入&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Reader/Prefetcher/Fetcher/Downloader/Loader
- Verb: read/get/fetch/load/retrieve
Writer/Uploader
- Verb: write/upload&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Lifecycle:
- open/close&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名词辨析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Reader 通常是从 stdio/文件/其它 Source 中读取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Fetcher 通常是从远端拉取数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Downloader 类似于 Fetcher，但是通常内容是文件等 blob，而非结构化数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Prefetcher 强调预热拉取，通常是拉取到缓存中。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对应动词 prefetch 或是简单的 fetch&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Loader 是泛用词汇，表示广义的“加载”。通常可以表示上述的任何一种。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Retrieve 是 Fetch 的同义词。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;具体地，fetch/load 是有语义的细微差别。但是，不需要做具体的细分。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先使用 read/fetch/download，当均不合适时，回退到 load。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;序列化 vs 反序列化&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Serializer
- Verb: serialize/pack/marshal
Deserializer
- Verb: deserialize/unpack/unmarshal&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动词辨析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;pack 指打包，将数据打包为一个不可拆分的（通常是不透明的）对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;serialize 指序列化，将数据转换为可以被存储/传输的（通常是二进制）格式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;marshal 强调意图 -- 将一个对象从程序 A 转移到程序 B 中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，不需要做这个区分。可以认为它们都是&lt;strong&gt;同义词&lt;/strong&gt;。按语言惯例使用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;C++: Serialize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java: Serialize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go: Marshal&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Python: Pack&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意反序列化是 deserialize, 比 unserialize 更常见。 但 pack -&amp;gt; unpack, marshal -&amp;gt; unmarshal。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://en.wikipedia.org/wiki/Marshalling_(computer_science)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://en.wikipedia.org/wiki/Serialization&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;转换&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Applier/Converter/Transformer/Mapper
- Verb: apply/convert/transform/map/to/translate&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以认为它们都是&lt;strong&gt;同义词&lt;/strong&gt;。在项目中应该保持一致。 严格来说，Mapper 更多指同一数据的两种形式的双向映射，例如数据库存储和运行时对象。 在 Applier/Converter/Transformer 中，Applier 最为常见，因为源自设计模式。 Mapper 在框架中较常见。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;匹配&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Filter/Matcher
- Verb: query/filter/match&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以认为它们都是&lt;strong&gt;同义词&lt;/strong&gt;。 在项目中应该保持一致。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;事件&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Event&lt;/p&gt;&lt;p&gt;Listener/Notifier Verbs: notify
Observer/Observable Verbs: observe
Handler Verbs: handle
Publisher/Subscriber
Publisher/Consumer&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 [Observer Pattner: 观察者模式] 中已经解释。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Observer 是正宗的观察者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Listner/Notifier 通常可以用来作为 Observer/Observable 的同义词。但是 Listener 也可能表示其它含义，如 TraceListener，视框架而定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Handler 也是同义词。它与 Listener/Observer 的区别在于，它表示&lt;strong&gt;唯一&lt;/strong&gt;的事件处理器。而 Listener/Observer 可能有多个。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Publisher/Subscriber: 在事件流系统中，表示 &lt;strong&gt;1:N&lt;/strong&gt; 广播/订阅。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Producer/Consumer: 在整个流系统中，专指 &lt;strong&gt;1:1&lt;/strong&gt; 生产/消费。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;见 https://stackoverflow.com/questions/42471870/publish-subscribe-vs-producer-consumer&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文本处理&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Regex/Pattern/Template&lt;/p&gt;&lt;p&gt;Pruner/Stripper/Trimmer
Formatter/Prettier
Resolver/Parser/Expander&lt;/p&gt;&lt;p&gt;- Verb: compile/parse/resolve/expand
- Verb: format/split/separate/merge/join&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，一个程序中有 20% 的代码在处理字符串。所以与文本相关的内容非常多。这里没有列出全部。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“模板”名词解析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Regex 专指正则表达式。另一个常见的缩写是 Regexp。应该与语言保持一致。C++ 使用 Regex。Go 使用 Regexp。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;编译使用 compile。 正则本身就是一种 formal language，因此使用 compile 是正统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;匹配对应动词为 expand/match/match&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Pattern 在 Java 中表示正则表达式。虽然 Pattern 可能通指“模式”，但是通常不在编程中使用。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;编译使用 compile&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对应动词为 match/split&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Template 指模板，通常不是正则形式的，而是简单的匹配替换模板，如 HTML 模板。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“修剪”动名词解析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Pruner.prune: 指清理掉过时的、不应存在的内容&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Stripper.strip: 指清理掉多余的、过度生长的内容&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Trimmer.trim: 泛指修剪，使其更好看。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，Prune/Strip/Trim 在编程中通常认为是&lt;strong&gt;同义词&lt;/strong&gt;。它们通常情况下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Strip/Trim 指去掉头尾的多余空格&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Prune 可能会进行其它的裁剪&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语言可能会为之赋予特殊含义，例如在 Java 11 中，Trim 会清理掉所有的普通空格，而 Strip 会清理掉所有的 Unicode 空格。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://stackoverflow.com/questions/51266582/difference-between-string-trim-and-strip-methods-in-java-11&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“格式化”动名词解析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Formatter.format 是将对象进行格式化。通用名词。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Prettier.pprint 专指将数据整理为便于人类可读的的输出格式。典型的例子是 Python 的 pprint。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“解析”动名词解析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Expander.expand 通常用于 DSL/Schema 解析，专指将某些 DSL &lt;strong&gt;展开&lt;/strong&gt;，如变量替换，展开 glob。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Parser.parse 类似于 parse，但强调将文本进行句法解析，形成格式化的中间层表示。借用了编译器术语。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Resolver.resolve Resolve 通常指从人类可读的定义（可能有歧义或不精确）向机器可读的定义（精确的、可解析的）的转换。例如，域名 -&amp;gt; ip 的解析，依赖包的版本号的解析（打平）。(!) resolve 不同于 expand/parse 的文本&lt;strong&gt;解析&lt;/strong&gt;。这是一个相同中文不同英文的易混淆例子。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;生命周期&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Lifecycle&lt;/p&gt;&lt;p&gt;Initializer/Finalizer&lt;/p&gt;&lt;p&gt;Verb:
- init/setup/prepare
- pause/resume
- start/begin
- end/terminate/stop/halt
- destroy/release/shutdown/teardown&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生命周期解析： 一个对象的生命周期，称为 Lifecycle，通常有以下流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建。通常由语言特性支持，不属于生命周期管理范围。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化：init。init 是 initialize 的全称，通常用来初始化一个类到可用状态。应该尽量避免创建之外的额外初始化步骤，一个对象应该尽可能在创建后就处于已初始化状态。额外的状态会让这个类更难正确使用。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;setup/prepare 是 init 的&lt;strong&gt;同义词&lt;/strong&gt;。应该在项目内统一，推荐为 init。setUp 通常在测试中使用，用于作为每个测试用例设计的前置步骤。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;init vs prepare: 具体地细分，init 的语义通常指“在&lt;strong&gt;类生命周期&lt;/strong&gt;层面处在正常可执行状态”，prepare 的语义通常指“在&lt;strong&gt;业务&lt;/strong&gt;层面做好准备”&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;开始： start/begin。通常用于这个对象正式开始正常工作，即切换到 running 状态。在切换到其它状态之前这个类会一直保持在 running 状态。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;start/begin 是同义词。通常使用 start 作为动词“开始”，使用 begin 作为列表的头。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;暂停： pause。pause 应该使得类暂停运行，从 running 状态切换到 paused 状态。这段时间这个类应该不再工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;恢复：resume。resume 与 pause 是成对的。 resume 会恢复 paused 到 running 状态。通常，pause/resume 可以无限次随时切换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;停止：stop/end/terminate/halt。停止类运行，与 start 对应。通常情况下，一个类 stop 意味着不会再重新启动。通常情况下，停止状态的类应该拒绝任何请求。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;stop/end/terminate/halt 是&lt;strong&gt;同义词&lt;/strong&gt;。不要做区分处理，在项目中保持一致。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;销毁：destroy/release/shutdown/teardown/exit。彻底销毁对象。此后，对象不再处于可用状态。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;destroy 强调销毁对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;release 强调释放资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;teardown 通常与 setup 对应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exit 通常指程序退出。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;shutdown 是通用“彻底关闭”的动词。当 destroy/release 不合适时，回退到 shutdown。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 gracefullyShutdown 表示优雅关闭。这通常意味着是前几个行为的集合：停止服务、释放资源、刷新缓冲区、销毁对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;destroy/release/shutdown/teardown 是&lt;strong&gt;近义词&lt;/strong&gt;。具体地：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;计算&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Calculator&lt;/p&gt;&lt;p&gt;Verb:
- compute/calculate/calc&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Calculator 而非 Computer 表示某个运算的执行器。Computer 虽然也是“计算器”，但是在代码语境下有歧义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;compute/calculate/calc 可以认为是&lt;strong&gt;同义词&lt;/strong&gt;。如果是 Calculator，使用 calculate。其它情况下，使用 compute。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;元数据（配置/环境/...）&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Option/Config/Configuration/Setting/Preference/Property/Parameter/Argument&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Context/Environment&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Info/Metadata/Manifest/Version&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置名词解析： 这个有类似的名词辨析，但是它们在编程时通常认为都是“配置”的同义词。它们还会出现在用户界面，尤其是 Settings/Options/Preferences。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编程的角度，Option/Config/Configuration 是同义词，均表示配置。惯例使用 &lt;code&gt;Options&lt;/code&gt; 作为子类定义一个类所需的配置，尤其是作为依赖注入时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Property 表示单个属性, 而且通常是 k-v 结构。换言之，Option/Config 通常由多个 Properties 组织。只有当 Property 是动态属性时，才定义特殊的 Property 类，否则，在 Option 中定义具体的域表示 Property。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;struct Options {&lt;br/&gt;  int fur_layer_count; &lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;  int fur_layer_count_property; &lt;span&gt;// Bad! Property unnecessary&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  struct ColorProperty {&lt;br/&gt;    int a;&lt;br/&gt;    int r;&lt;br/&gt;    int g;&lt;br/&gt;    int b;&lt;br/&gt;  } &lt;span&gt;// Bad! Prefer Color.&lt;/span&gt;&lt;br/&gt;  ColorProperty color;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数解析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Parameter：通常表示在接口处定义的参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Argument：指实际传入接口的参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func foo(param string)&lt;br/&gt;&lt;br/&gt;foo(arg)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://stackoverflow.com/questions/156767/whats-the-difference-between-an-argument-and-a-parameter&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上下文名词辨析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Context 指上下文，通常用于在 API 之间传递与一次执行相关的信息。在 RPC 处理中非常常见，例如 https://pkg.go.dev/context 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Environment 指环境。这个名词从系统环境变量而来。通常，这表示在程序启动后保持稳定的环境数据，不随所执行的内容（如 rpc 请求）变化而变化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元数据辨析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Info 泛指&lt;strong&gt;信息&lt;/strong&gt;。而元数据相当于特定的“关于数据”的信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Metadata 标准用语，专指&lt;strong&gt;元数据&lt;/strong&gt;。避免使用 Info 代表元数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Manifest 专指&lt;strong&gt;文件清单&lt;/strong&gt;，描述一个模块中的文件/功能/其它组成结构的&lt;strong&gt;列表&lt;/strong&gt;。Manifest 来自于货运术语，Ship Manifest 用以列出所有的船员和船队所有的船只。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;Version 专指程序的&lt;strong&gt;版本元数据&lt;/strong&gt;，例如 &lt;code&gt;TrpcVersion&lt;/code&gt;。如果一个类专指版本，使用 Version 是最精确合适的。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaucOLGrSdOD99g8RPhbZiaRR2Q7TLue7A2K5P7ReBgEIkxeDFPB8A9p7bibHwYOuBAibzkhgkE9h2ozw/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>243fc0a9d6dd494df78370766abb7557</guid>
<title>这代码居然有差别？CPU 友好的代码该这样写</title>
<link>https://toutiao.io/k/9hhdw36</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;blockquote data-first-child=&quot;&quot; data-pid=&quot;7TplAEdV&quot;&gt;本文用实际用例阐述了用心组织的代码也能让性能提升百倍，我们不应该停留在CRUD的漩涡中。下面来看看这个神奇的现象。&lt;/blockquote&gt;&lt;p data-pid=&quot;XaD-KEnP&quot;&gt;作者 | 王再军(曦峰)&lt;/p&gt;&lt;p data-pid=&quot;MsqYqTpv&quot;&gt;来源 | 阿里开发者公众号&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;一、震惊，这代码居然有差别！&lt;/h2&gt;&lt;p data-pid=&quot;gsWgGzOb&quot;&gt;CPU友好的代码与我们平时的那些CRUD操作可能没啥关系。但是用心组织的代码其实也能让性能提升百倍。我们不应该停留在CRUD的漩涡中。今天我给大家带来一个很神奇的现象，文章不长，原理通用，还请大家耐心看完！&lt;/p&gt;&lt;p data-pid=&quot;mAkva4ux&quot;&gt;我们可以先看下面的矩阵计算。&lt;/p&gt;&lt;p data-pid=&quot;CThnL35o&quot;&gt;大家也可以自己思考一下，如果是你来实现一个矩阵的乘法，你会怎么来做。&lt;/p&gt;&lt;p data-pid=&quot;cvuHTXtM&quot;&gt;下图是我给出的A、B、C 三个解题的思路。大家觉得在Jvm里面，下面的代码性能会有区别么？如果有的话，哪一个会快一点？如果没有的话，又为什么？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6de70ebb1ee1ce8bd4e996e2d585e7dc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2400&quot; data-rawheight=&quot;1340&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-6de70ebb1ee1ce8bd4e996e2d585e7dc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2400&quot; data-rawheight=&quot;1340&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-6de70ebb1ee1ce8bd4e996e2d585e7dc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-6de70ebb1ee1ce8bd4e996e2d585e7dc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;7AZXWPjS&quot;&gt;这里停顿两秒。&lt;/p&gt;&lt;p data-pid=&quot;mLZx1ToI&quot;&gt;/...1&lt;/p&gt;&lt;p data-pid=&quot;-g4pFO4B&quot;&gt;/...2&lt;/p&gt;&lt;p data-pid=&quot;XLLbju54&quot;&gt;现在是公布答案的时间，下图是benchmark运行的结果（具体的运行代码和结果查看文末的附件），是否和你想的一样呢。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5f6af17f39f10f01b72cf38d77f9ea2f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1468&quot; data-rawheight=&quot;828&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-5f6af17f39f10f01b72cf38d77f9ea2f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1468&quot; data-rawheight=&quot;828&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-5f6af17f39f10f01b72cf38d77f9ea2f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-5f6af17f39f10f01b72cf38d77f9ea2f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;IBOCGoud&quot;&gt;x轴是计算数组的大小。y轴是所消耗的时间。&lt;/p&gt;&lt;p data-pid=&quot;1PWYjYrS&quot;&gt;最上两条线是 B 代码块儿的结果，中间是 A 代码块儿的结果，最下面是 C 代码块儿的结果。&lt;/p&gt;&lt;p data-pid=&quot;V3NSvjR8&quot;&gt;&lt;b&gt;从运行时间角度看结果是： TC  &amp;lt; TA &amp;lt; TB。 从性能角度看结果是：PC &amp;gt;  PA  &amp;gt; PB。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;Z5VmSM9F&quot;&gt;&lt;b&gt;大家猜对结果了么？是不是很你想的一样呢？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;MfVpm17M&quot;&gt;&lt;b&gt;如果不是的话，那就慢慢往下面看吧。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;二、为什么会有性能差别？&lt;/h2&gt;&lt;p data-pid=&quot;UHY82EKN&quot;&gt;要想知道这个问题的答案，我们需要知道两个知识点，缺一不可。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;Pxe6i0QR&quot;&gt;首先，我们需要知道Java二维数组的存储结构是什么样子的。&lt;/li&gt;&lt;li data-pid=&quot;CINNlaJK&quot;&gt;其次，我们需要知道CPU在计算的时候它L1、L2、L3的缓存机制。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;2.1 知识点&lt;/h2&gt;&lt;h3&gt;2.1.1 知识点一 -- Java二维数组的存储结构&lt;/h3&gt;&lt;p data-pid=&quot;rY8CGX5C&quot;&gt;下图便是Java二维数组的一个存储方式示意图，意思是 int[][] array_A = new int[4][3]。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d854147b750a790226f7f68154bc7f48_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1468&quot; data-rawheight=&quot;1027&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-d854147b750a790226f7f68154bc7f48_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1468&quot; data-rawheight=&quot;1027&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-d854147b750a790226f7f68154bc7f48_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d854147b750a790226f7f68154bc7f48_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;CNAhyjBY&quot;&gt;在一个数组里面存的都是“指针”，指向真实存放数据的地址块。&lt;/p&gt;&lt;p data-pid=&quot;U-6PK2g1&quot;&gt;&lt;b&gt;每一行的数据是连续的地址，但是行与行之间的地址就不一定连续了。这一点很重要，后面会用到。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3&gt;2.1.2 知识点二 -- CPU的缓存机制&lt;/h3&gt;&lt;p data-pid=&quot;7hPbWn48&quot;&gt;CPU架构是会演进的，高低端的参数也不一定相同。但我们毕竟不是CPU的制造者，不必每一个CPU都去细扣，我们只需要理解他的原理，在适当的时候做一些抽象方便理解就可以了。&lt;/p&gt;&lt;p data-pid=&quot;RcvJbYZ_&quot;&gt;下图是我当前Mac的CPU参数，大家需要注意2个东西，L2缓存、L3缓存。这2个参数就是影响我们今天讨论的性能的主要因素。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-79d8fdc42dfc1f8ce5ebb6e0bced870c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;614&quot; data-rawheight=&quot;192&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-79d8fdc42dfc1f8ce5ebb6e0bced870c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;614&quot; data-rawheight=&quot;192&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-79d8fdc42dfc1f8ce5ebb6e0bced870c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-79d8fdc42dfc1f8ce5ebb6e0bced870c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;7Qod8mnI&quot;&gt;下面是各个缓存的CPU的访问时间：&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;缓存速率表&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;类型&lt;/td&gt;&lt;td&gt;缓存什么&lt;/td&gt;&lt;td&gt;延迟（周期数）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CPU寄存器&lt;/td&gt;&lt;td&gt;4字节或8字节&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;L1高速缓存&lt;/td&gt;&lt;td&gt;64字节块&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;L2高速缓存&lt;/td&gt;&lt;td&gt;64字节块&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;L3高速缓存&lt;/td&gt;&lt;td&gt;64字节块&lt;/td&gt;&lt;td&gt;50&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;虚拟内存/缓冲区缓存（主存）&lt;/td&gt;&lt;td&gt;4KB页&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;vFC8AK8s&quot;&gt;L1 、L2、L3、主存  的大小是逐渐增大，速度是逐渐减小的。&lt;/p&gt;&lt;p data-pid=&quot;1e8fXv4g&quot;&gt;下面是现代CPU的一个架构示意图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7a9dcdc038242ac632bd98523df004ac_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1582&quot; data-rawheight=&quot;1384&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-7a9dcdc038242ac632bd98523df004ac_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1582&quot; data-rawheight=&quot;1384&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-7a9dcdc038242ac632bd98523df004ac_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-7a9dcdc038242ac632bd98523df004ac_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;jzPnAGjz&quot;&gt;其中：&lt;/p&gt;&lt;p data-pid=&quot;kKBM6EHs&quot;&gt;Regs，是寄存器。&lt;/p&gt;&lt;p data-pid=&quot;MJlYM2bf&quot;&gt;d-cache，是数据缓存。&lt;/p&gt;&lt;p data-pid=&quot;9ubSraZ1&quot;&gt;i-cache，是指令缓存。本次我们并不讨论这个缓存快的影响。&lt;/p&gt;&lt;p data-pid=&quot;H4Cw-k9p&quot;&gt;L1、L2、L3和主存的缓存的内容，可以参考下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3379e01b3aa0e0898e726756f4f628c9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1468&quot; data-rawheight=&quot;925&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-3379e01b3aa0e0898e726756f4f628c9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1468&quot; data-rawheight=&quot;925&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-3379e01b3aa0e0898e726756f4f628c9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3379e01b3aa0e0898e726756f4f628c9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;TMaC1jcx&quot;&gt;图片来自：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.deskdecode.com/what-is-cpu-central-processing-unit-and-how-its-work/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;deskdecode.com/what-is-&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;cpu-central-processing-unit-and-how-its-work/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-pid=&quot;EiXoqULL&quot;&gt;CPU的缓存里面还有很多的细节，我就先忽略了，知道上面的信息就已经足够我们理解今天的问题了。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;2.2 性能损失的原因 -- 缓存命中率&lt;/h2&gt;&lt;p data-pid=&quot;VX4EA42j&quot;&gt;有了上面的各级别的缓存参考之后，我们可以想象一下，如果把上面的图像换成是我们的二维数组呢。是不是就是下面这样（可能没有那么严谨，但是不妨碍我们理解）。&lt;/p&gt;&lt;p data-pid=&quot;YuHh4R_F&quot;&gt;在RAM（主存）的数据是这样的：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9aaedd5aef2d70b721ef087fd0d04c40_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1468&quot; data-rawheight=&quot;777&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-9aaedd5aef2d70b721ef087fd0d04c40_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1468&quot; data-rawheight=&quot;777&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-9aaedd5aef2d70b721ef087fd0d04c40_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9aaedd5aef2d70b721ef087fd0d04c40_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;OOg4XCDb&quot;&gt;L3缓存就是这样的（红色框选中部分）：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dd7b859dadac4094da13719c4a5e222a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;812&quot; data-rawheight=&quot;678&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-dd7b859dadac4094da13719c4a5e222a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;812&quot; data-rawheight=&quot;678&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-dd7b859dadac4094da13719c4a5e222a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-dd7b859dadac4094da13719c4a5e222a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;bGCrpTjg&quot;&gt;L2缓存就是这样的（红色框选中部分）：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fce3061d845eac0052d16323ac0d3e0f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;728&quot; data-rawheight=&quot;682&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-fce3061d845eac0052d16323ac0d3e0f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;728&quot; data-rawheight=&quot;682&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-fce3061d845eac0052d16323ac0d3e0f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-fce3061d845eac0052d16323ac0d3e0f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;YRyl1RJY&quot;&gt;有了这个这些层级的缓存之后，CPU在计算的时候就可以不用来回的到速度极慢的RAM（主存）中去找数组的数据了。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3&gt;2.2.1 友好的遍历方式&lt;/h3&gt;&lt;p data-pid=&quot;PXFctKom&quot;&gt;假设上面的数据的变量名称是A，成员使用 a 来表述。&lt;/p&gt;&lt;p data-pid=&quot;y07uHQII&quot;&gt;我们取数据按照 &lt;b&gt;从左到右，再从上到下&lt;/b&gt; 的顺序来进行遍历。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1f3b14ee46cdb06c1b56da3bd38fc3b5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1950&quot; data-rawheight=&quot;1066&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-1f3b14ee46cdb06c1b56da3bd38fc3b5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1950&quot; data-rawheight=&quot;1066&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-1f3b14ee46cdb06c1b56da3bd38fc3b5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-1f3b14ee46cdb06c1b56da3bd38fc3b5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;8ZEuLEnh&quot;&gt;对于L2缓存来说，&lt;/p&gt;&lt;p data-pid=&quot;Qs8MsdmI&quot;&gt;第一次获取数据 a11（“1”）的时候其实是没有数据的，所以会耗时去把 a11，a12，a13（“1，2，3”）都取回来缓存起来。&lt;/p&gt;&lt;p data-pid=&quot;ILVoIPJv&quot;&gt;当第二次取 a12、a13的时候候就直接从L2缓存取了。这样 cache 命中率就是&lt;b&gt; 66.7%.&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;PvtOl_s8&quot;&gt;对于L3的情况类似。&lt;/p&gt;&lt;p data-pid=&quot;bUiAq-99&quot;&gt;这样的遍历方式对于CPU来说是一个很友好且高效的。 &lt;/p&gt;&lt;p data-pid=&quot;3THFQ_JM&quot;&gt;&lt;b&gt;C代码块 就是这种横向优先的访问方式。 &lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;XvcL0Oq0&quot;&gt;&lt;b&gt;A代码块 里面对 arrays_A 的方式是横向优先遍历的，但是在处理 arrays_B 的时候就是纵向遍历的（也就是下面即将提到的方式）。   &lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;j_FArDXX&quot;&gt;&lt;b&gt;B代码块 所有的访问都是纵向的（不友好的遍历方式）。因为发挥不出CPU缓存的效果，所以性能最差。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3&gt;2.2.2 不友好的遍历方式&lt;/h3&gt;&lt;p data-pid=&quot;7PtdlYBM&quot;&gt;&lt;b&gt;从上到下，再从左到右。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e4dab24f7dfb7f5c62336b0a2eb65016_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1842&quot; data-rawheight=&quot;1050&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-e4dab24f7dfb7f5c62336b0a2eb65016_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1842&quot; data-rawheight=&quot;1050&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-e4dab24f7dfb7f5c62336b0a2eb65016_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e4dab24f7dfb7f5c62336b0a2eb65016_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;_w9zMbNc&quot;&gt;&lt;b&gt;为啥这是一个不好的遍历方式呢？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;a9g4FG1t&quot;&gt;这个得结合上一节Java的二维数组的存储结构一起看。再来回顾一下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-82b97aa9a5f3384bf28a5dca23a89b65_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1550&quot; data-rawheight=&quot;1084&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-82b97aa9a5f3384bf28a5dca23a89b65_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1550&quot; data-rawheight=&quot;1084&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-82b97aa9a5f3384bf28a5dca23a89b65_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-82b97aa9a5f3384bf28a5dca23a89b65_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;w2XPl58d&quot;&gt;从上面的存储的结构图来看，其实 a11，a12，a13 与 a21，a22，a23 行与行之间并不是连续的。所以对于L1、L2、L3缓存来说很有可能是不能一起被缓存的（这里用了可能，具体得看L1、L2、L3的容量和数组的大小）。虽然是可能，但是通常都不会一起出现。&lt;/p&gt;&lt;p data-pid=&quot;-2yCiudN&quot;&gt;有了这个知识之后，我们再来看，先从上到下，再从左到右的顺序的缓存命中率。&lt;/p&gt;&lt;p data-pid=&quot;8XjIo4-C&quot;&gt;第一次，获取 a11，但是缓存里面没有，找到 a11 之后就把  a11，a12，a13 缓存下来了。&lt;/p&gt;&lt;p data-pid=&quot;g9u76Tad&quot;&gt;第二次，获取 a21，但是缓存里面没有，找到 a21 之后就把  a21，a22，a23  缓存下来了，假设有CPU有两行的缓存空间。&lt;/p&gt;&lt;p data-pid=&quot;wfD3hBoi&quot;&gt;第三次，获取 a31，但是缓存里面没有，找到 a31 之后把  a31，a32，a33  缓存下来，并且把  a11，a12，a13  替换掉（缓存的空间有限，虽然具体的替换策略有很多种，并且还和数据本身的Hash有关系，这里就假设把第一次的结果覆盖了）。&lt;/p&gt;&lt;p data-pid=&quot;WLm3yq6Y&quot;&gt;后面的逻辑重复之前的步骤。 最后得到的缓存命中率就是 &lt;b&gt;0% &lt;/b&gt;。&lt;/p&gt;&lt;p data-pid=&quot;oad2sbGh&quot;&gt;结合文章开头的缓存速率表格，我们就不难发现，如果我们每次都不命中缓存的话，那么延迟带来的耗时将会相差一个数量级。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;三、总结&lt;/h2&gt;&lt;p data-pid=&quot;nwclpIw3&quot;&gt;再来回顾一下我们之前的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6de70ebb1ee1ce8bd4e996e2d585e7dc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2400&quot; data-rawheight=&quot;1340&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-6de70ebb1ee1ce8bd4e996e2d585e7dc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2400&quot; data-rawheight=&quot;1340&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-6de70ebb1ee1ce8bd4e996e2d585e7dc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-6de70ebb1ee1ce8bd4e996e2d585e7dc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;dZPV7V7V&quot;&gt;&lt;b&gt;C代码块 是横向优先的访问方式。 &lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;kfD1Ehq6&quot;&gt;&lt;b&gt;A代码块 里面对 arrays_A 的方式是横向顺序访问的，但是在处理 arrays_B 的时候就是纵向遍历的。   &lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;69HrL9lP&quot;&gt;&lt;b&gt;B代码块 所有的访问都是纵向的（不友好的遍历方式）。因为发挥不出CPU缓存的效果，所以性能最差。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;lrN5_Arz&quot;&gt;Java的二维数组在内存里面是行连续的，但是行与行之间不一定连续。CPU在缓存大小有限的情况下，不可能把所有的数据都缓存下来。再加上每一层级访问速度的硬件限制，就导致了上面的性能结果。&lt;/p&gt;&lt;p data-pid=&quot;lSQ4CExY&quot;&gt;相信大家也和我一样，知道原理之后，也不是那么迷惑了。&lt;/p&gt;&lt;p data-pid=&quot;TV7OmbCT&quot;&gt;在实际的业务环境中，我们不一定能遇到这种纯计算的场景。但是我们还是应该尽量顺序访问数据，不管是什么样的数据。投其所好，方能够优化代码性能。&lt;/p&gt;&lt;p data-pid=&quot;DE-tZhaq&quot;&gt;其次，我们在访问数据的时候，还是需要了解各种语言背后实际的存储结构和CPU的缓存原理，本次是讲述的是Java，但是这个思想其他语言其实也是受用的。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;四、附件&lt;/h2&gt;&lt;h2&gt;4.1 运行的环境&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;JMH version: 1.36
VM version: JDK 11.0.13, Java HotSpot(TM) 64-Bit Server VM, 11.0.13+10-LTS-370
型号名称： MacBook Pro
型号标识符：  MacBookPro15,2
处理器名称：  四核Intel Core i5
处理器速度：  2.4 GHz
处理器数目：  1
核总数：  4
L2缓存（每个核）：  256 KB
L3缓存： 6 MB
超线程技术：  已启用
内存： 16 GB
系统固件版本： 1715.60.5.0.0 (iBridge: 19.16.10647.0.0,0)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;4.2 整个benchmark的java代码&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import org.openjdk.jmh.annotations.*;
/**
 * 矩阵 C = AB 的计算
 *
 * @author wzj
 * @date 2023/02/09
 */
@BenchmarkMode(Mode.AverageTime)
@State(value = Scope.Benchmark)
// 预热3次
@Warmup(iterations = 3, time = 1)
// 循环 10 次
@Measurement(iterations = 10, time = 1)
public class ArrayTestBenchmark {
    // 数组大小设置
    private final int N = 1000;
    private final int[][] arrays_A = new int[N][N];
    private final int[][] arrays_B = new int[N][N];
    @Setup
    public void setUp() {
        for (int i = 0; i &amp;lt; N; i++) {
            for (int j = 0; j &amp;lt; N; j++) {
                arrays_A[i][j] = i + j;
                arrays_B[i][j] = i + j;
            }
        }
    }
    @Benchmark
    public void ijk() {
        final int[][] arrays_C = new int[N][N];
        for (int i = 0; i &amp;lt; N; i++) {
            for (int j = 0; j &amp;lt; N; j++) {
                int sum = 0;
                for (int k = 0; k &amp;lt; N; k++) {
                    sum += arrays_A[i][k] * arrays_B[k][j];
                }
                arrays_C[i][j] += sum;
            }
        }
        assert arrays_C.length &amp;gt; 0;
    }
    @Benchmark
    public void jik() {
        final int[][] arrays_C = new int[N][N];
        for (int j = 0; j &amp;lt; N; j++) {
            for (int i = 0; i &amp;lt; N; i++) {
                int sum = 0;
                for (int k = 0; k &amp;lt; N; k++) {
                    sum += arrays_A[i][k] * arrays_B[k][j];
                }
                arrays_C[i][j] += sum;
            }
        }
        assert arrays_C.length &amp;gt; 0;
    }
    @Benchmark
    public void jki() {
        final int[][] arrays_C = new int[N][N];
        for (int j = 0; j &amp;lt; N; j++) {
            for (int k = 0; k &amp;lt; N; k++) {
                int r_B = arrays_B[k][j];
                for (int i = 0; i &amp;lt; N; i++) {
                    arrays_C[i][j] += arrays_A[i][k] * r_B;
                }
            }
        }
        assert arrays_C.length &amp;gt; 0;
    }
    @Benchmark
    public void kji() {
        final int[][] arrays_C = new int[N][N];
        for (int k = 0; k &amp;lt; N; k++) {
            for (int j = 0; j &amp;lt; N; j++) {
                int r_B = arrays_B[k][j];
                for (int i = 0; i &amp;lt; N; i++) {
                    arrays_C[i][j] += arrays_A[i][k] * r_B;
                }
            }
        }
        assert arrays_C.length &amp;gt; 0;
    }
    @Benchmark
    public void kij() {
        final int[][] arrays_C = new int[N][N];
        for (int k = 0; k &amp;lt; N; k++) {
            for (int i = 0; i &amp;lt; N; i++) {
                int r_A = arrays_A[k][i];
                for (int j = 0; j &amp;lt; N; j++) {
                    arrays_C[i][j] += r_A * arrays_B[k][j];
                }
            }
        }
        assert arrays_C.length &amp;gt; 0;
    }
    @Benchmark
    public void ikj() {
        final int[][] arrays_C = new int[N][N];
        for (int i = 0; i &amp;lt; N; i++) {
            for (int k = 0; k &amp;lt; N; k++) {
                int r_A = arrays_A[k][i];
                for (int j = 0; j &amp;lt; N; j++) {
                    arrays_C[i][j] += r_A * arrays_B[k][j];
                }
            }
        }
        assert arrays_C.length &amp;gt; 0;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;4.3 多次运行benchmark的结果&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5e3d2f72a17fb8eb06bc7da0a95d3558_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;883&quot; data-rawheight=&quot;344&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5e3d2f72a17fb8eb06bc7da0a95d3558_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;883&quot; data-rawheight=&quot;344&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5e3d2f72a17fb8eb06bc7da0a95d3558_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5e3d2f72a17fb8eb06bc7da0a95d3558_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;六、引用&lt;/h2&gt;&lt;ol&gt;&lt;li data-pid=&quot;MAza3wIL&quot;&gt;《深入理解计算机操作系统》&lt;/li&gt;&lt;li data-pid=&quot;-9U00RXg&quot;&gt;《深入理解Java虚拟机》&lt;/li&gt;&lt;/ol&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote data-pid=&quot;_3JuUCyM&quot;&gt;&lt;b&gt;版权声明：&lt;/b&gt;本文内容由阿里云实名注册用户自发贡献，版权归原作者所有，阿里云开发者社区不拥有其著作权，亦不承担相应法律责任。具体规则请查看《&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/768092&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;阿里云开发者社区用户服务协议&lt;/a&gt;》和《&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/768093&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;阿里云开发者社区知识产权保护指引&lt;/a&gt;》。如果您发现本社区中有涉嫌抄袭的内容，填写&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//yida.alibaba-inc.com/o/right&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;侵权投诉表单&lt;/a&gt;进行举报，一经查实，本社区将立刻删除涉嫌侵权内容。&lt;/blockquote&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a1dd4ce651b4eb7feb2c5f453fee4592</guid>
<title>面试必备：四种经典限流算法讲解</title>
<link>https://toutiao.io/k/l8w1kbx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好,我是&lt;strong&gt;田螺&lt;/strong&gt;.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近一位朋友去拼夕夕面试,被问了这么一道题:&lt;strong&gt;限流算法有哪些?用代码实现令牌桶算法&lt;/strong&gt;。跟&lt;strong&gt;星球好友&lt;/strong&gt;讨论了一波,发现大家都忘记得差不多了.所以田螺哥再整理一波，常见的四种限流算法,以及简单代码实现,相信大家看完,会&lt;strong&gt;茅塞顿开&lt;/strong&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.682648401826484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpy8GI0lVc3XJIbOB95yYCAuMEuUficu6ibULz1h7zZ7Ny9DLRQA4jo6M3zPYXDxCYwMoL3xaXOzZUUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 固定窗口限流算法&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 什么是固定窗口限流算法&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;固定窗口限流算法（&lt;code&gt;Fixed Window Rate Limiting Algorithm&lt;/code&gt;）是一种最简单的限流算法，其原理是在&lt;strong&gt;固定时间窗口&lt;/strong&gt;(&lt;code&gt;单位时间&lt;/code&gt;)内限制请求的数量。该算法将时间分成固定的窗口，并在每个窗口内限制请求的数量。具体来说，算法将请求按照时间顺序放入时间窗口中，并计算该时间窗口内的请求数量，如果请求数量超出了限制，则拒绝该请求。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设单位时间(固定时间窗口)是&lt;code&gt;1&lt;/code&gt;秒，限流阀值为&lt;code&gt;3&lt;/code&gt;。在单位时间&lt;code&gt;1&lt;/code&gt;秒内，每来一个请求,计数器就加&lt;code&gt;1&lt;/code&gt;，如果计数器累加的次数超过限流阀值&lt;code&gt;3&lt;/code&gt;，后续的请求全部拒绝。等到&lt;code&gt;1s&lt;/code&gt;结束后，计数器清&lt;code&gt;0&lt;/code&gt;，重新开始计数。如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.512962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpy8GI0lVc3XJIbOB95yYCAuotUYFfQOAtHyD1Ez88gbHttk9VqhQZWMWCe5PNg6TRTmtJI06VKpgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 固定窗口限流的伪代码&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   public static Integer counter = 0;  //统计请求数&lt;br/&gt;   public static long lastAcquireTime =  0L;&lt;br/&gt;   public static final Long windowUnit = 1000L ; //假设固定时间窗口是1000ms&lt;br/&gt;   public static final Integer threshold = 10; // 窗口阀值是10&lt;br/&gt;   &lt;br/&gt;    /**&lt;br/&gt;     * 固定窗口时间算法&lt;br/&gt;     * 关注公众号：捡田螺的小男孩&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    public synchronized boolean &lt;span&gt;&lt;span&gt;fixedWindowsTryAcquire&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        long currentTime = System.currentTimeMillis();  //获取系统当前时间&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (currentTime - lastAcquireTime &amp;gt; windowUnit) {  //检查是否在时间窗口内&lt;br/&gt;            counter = 0;  // 计数器清0&lt;br/&gt;            lastAcquireTime = currentTime;  //开启新的时间窗口&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (counter &amp;lt; threshold) {  // 小于阀值&lt;br/&gt;            counter++;  //计数统计器加1&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 固定窗口算法的优缺点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;优点&lt;/strong&gt;：固定窗口算法非常简单，易于实现和理解。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缺点&lt;/strong&gt;：存在&lt;strong&gt;明显的临界问题&lt;/strong&gt;，比如: 假设限流阀值为&lt;code&gt;5&lt;/code&gt;个请求，单位时间窗口是&lt;code&gt;1s&lt;/code&gt;,如果我们在单位时间内的&lt;code&gt;前0.8-1s&lt;/code&gt;和&lt;code&gt;1-1.2s&lt;/code&gt;，分别并发5个请求。虽然都没有超过阀值，但是如果算0.8-1.2s,则并发数高达10，&lt;strong&gt;已经超过单位时间1s不超过5阀值的定义&lt;/strong&gt;啦。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4046296296296296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpy8GI0lVc3XJIbOB95yYCAu6RufYL2HdRjiblnjlEGjEhfzQCOcqCp60XwCNh1OG05gggwic9UBVbRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 滑动窗口限流算法&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 什么是滑动窗口限流算法&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;滑动窗口限流算法是一种常用的限流算法，用于控制系统对外提供服务的速率，防止系统被过多的请求压垮。它将单位时间周期分为&lt;code&gt;n&lt;/code&gt;个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。&lt;strong&gt;它可以解决固定窗口临界值的问题&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一张图解释滑动窗口算法，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.600925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpy8GI0lVc3XJIbOB95yYCAuEnvh4Vf0VN2jlX6J0WqsRynhvEQ7F6jWpGTWtUgVXD7hDFpBZTU4kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设单位时间还是&lt;code&gt;1&lt;/code&gt;s，滑动窗口算法把它划分为&lt;code&gt;5&lt;/code&gt;个小周期，也就是滑动窗口（&lt;strong&gt;单位时间&lt;/strong&gt;）被划分为&lt;code&gt;5&lt;/code&gt;个小格子。每格表示&lt;code&gt;0.2s&lt;/code&gt;。每过&lt;code&gt;0.2s&lt;/code&gt;，时间窗口就会往右滑动一格。然后呢，每个小周期，都有自己独立的计数器，如果请求是&lt;code&gt;0.83s&lt;/code&gt;到达的，&lt;code&gt;0.8~1.0s&lt;/code&gt;对应的计数器就会加&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们来看下，滑动窗口,去解决固定窗口限流算法的临界问题，思想是怎样&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;假设我们&lt;code&gt;1s&lt;/code&gt;内的限流阀值还是&lt;code&gt;5&lt;/code&gt;个请求，&lt;code&gt;0.8~1.0s&lt;/code&gt;内（比如&lt;code&gt;0.9s&lt;/code&gt;的时候）来了&lt;code&gt;5&lt;/code&gt;个请求，落在黄色格子里。时间过了&lt;code&gt;1.0s&lt;/code&gt;这个点之后，又来&lt;code&gt;5&lt;/code&gt;个请求，落在紫色格子里。如果是固定窗口算法，是不会被限流的，但是滑动窗口的话，每过一个小周期，它会右移一个小格。过了&lt;code&gt;1.0s&lt;/code&gt;这个点后，会右移一小格，当前的单位时间段是&lt;code&gt;0.2~1.2s&lt;/code&gt;，这个区域的请求已经超过限定的&lt;code&gt;5&lt;/code&gt;了，已触发限流啦，实际上，紫色格子的请求都被拒绝啦。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当滑动窗口的&lt;strong&gt;格子周期划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 滑动窗口限流算法的伪代码实现&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; /**&lt;br/&gt;     * 单位时间划分的小周期（单位时间是1分钟，10s一个小格子窗口，一共6个格子）&lt;br/&gt;     */&lt;br/&gt;    private int SUB_CYCLE = 10;&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 每分钟限流请求数&lt;br/&gt;     */&lt;br/&gt;    private int thresholdPerMin = 100;&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 计数器, k-为当前窗口的开始时间值秒，value为当前窗口的计数&lt;br/&gt;     */&lt;br/&gt;    private final TreeMap&amp;lt;Long, Integer&amp;gt; counters = new TreeMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;   /**&lt;br/&gt;     * 滑动窗口时间算法实现&lt;br/&gt;     */&lt;br/&gt;     public synchronized boolean &lt;span&gt;&lt;span&gt;slidingWindowsTryAcquire&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        long currentWindowTime = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) / SUB_CYCLE * SUB_CYCLE; //获取当前时间在哪个小周期窗口&lt;br/&gt;        int currentWindowNum = countCurrentWindow(currentWindowTime); //当前窗口总请求数&lt;br/&gt;&lt;br/&gt;        //超过阀值限流&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (currentWindowNum &amp;gt;= thresholdPerMin) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        //计数器+1&lt;br/&gt;        counters.get(currentWindowTime)++;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;   /**&lt;br/&gt;    * 统计当前窗口的请求数&lt;br/&gt;    */&lt;br/&gt;    private int countCurrentWindow(long currentWindowTime) {&lt;br/&gt;        //计算窗口开始位置&lt;br/&gt;        long startTime = currentWindowTime - SUB_CYCLE* (60s/SUB_CYCLE-1);&lt;br/&gt;        int count = 0;&lt;br/&gt;&lt;br/&gt;        //遍历存储的计数器&lt;br/&gt;        Iterator&amp;lt;Map.Entry&amp;lt;Long, Integer&amp;gt;&amp;gt; iterator = counters.entrySet().iterator();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (iterator.hasNext()) {&lt;br/&gt;            Map.Entry&amp;lt;Long, Integer&amp;gt; entry = iterator.next();&lt;br/&gt;            // 删除无效过期的子窗口计数器&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (entry.getKey() &amp;lt; startTime) {&lt;br/&gt;                iterator.remove();&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                //累加当前窗口的所有计数器之和&lt;br/&gt;                count =count + entry.getValue();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 滑动窗口限流算法的优缺点&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;简单易懂&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;精度高（通过调整时间窗口的大小来实现不同的限流效果）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可扩展性强（可以非常容易地与其他限流算法结合使用）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;突发流量无法处理（&lt;strong&gt;无法应对短时间内的大量请求，但是一旦到达限流后，请求都会直接暴力被拒绝。酱紫我们会损失一部分请求，这其实对于产品来说，并不太友好&lt;/strong&gt;），需要合理调整时间窗口大小。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 漏桶限流算法&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 什么是漏桶限流算法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶限流算法（&lt;code&gt;Leaky Bucket Algorithm&lt;/code&gt;）是一种流量控制算法，用于控制流入网络的数据速率，以防止网络拥塞。它的思想是将数据包看作是水滴，漏桶看作是一个固定容量的水桶，数据包像水滴一样从桶的顶部流入桶中，并通过桶底的一个小孔以一定的速度流出，从而限制了数据包的流量。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;漏桶限流算法的基本工作原理是：对于每个到来的数据包，都将其加入到漏桶中，并检查漏桶中当前的水量是否超过了漏桶的容量。如果超过了容量，就将多余的数据包丢弃。如果漏桶中还有水，就以一定的速率从桶底输出数据包，保证输出的速率不超过预设的速率，从而达到限流的目的。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.674074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpy8GI0lVc3XJIbOB95yYCAuzlcOW3n5fvNhx7lJfWqMM8k45aHZTWiboZwT3HbS5U3bOnyOPMm8yzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;流入的水滴，可以看作是访问系统的请求，这个流入速率是不确定的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;桶的容量一般表示系统所能处理的请求数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果桶的容量满了，就达到限流的阀值，就会丢弃水滴（拒绝请求）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流出的水滴，是恒定过滤的，对应服务按照固定的速率处理请求。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 漏桶限流算法的伪代码实现&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; /**&lt;br/&gt; * LeakyBucket 类表示一个漏桶,&lt;br/&gt; * 包含了桶的容量和漏桶出水速率等参数，&lt;br/&gt; * 以及当前桶中的水量和上次漏水时间戳等状态。&lt;br/&gt; */&lt;br/&gt;public class LeakyBucket {&lt;br/&gt;    private final long capacity;    // 桶的容量&lt;br/&gt;    private final long rate;        // 漏桶出水速率&lt;br/&gt;    private long water;             // 当前桶中的水量&lt;br/&gt;    private long lastLeakTimestamp; // 上次漏水时间戳&lt;br/&gt;&lt;br/&gt;    public LeakyBucket(long capacity, long rate) {&lt;br/&gt;        this.capacity = capacity;&lt;br/&gt;        this.rate = rate;&lt;br/&gt;        this.water = 0;&lt;br/&gt;        this.lastLeakTimestamp = System.currentTimeMillis();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * tryConsume() 方法用于尝试向桶中放入一定量的水，如果桶中还有足够的空间，则返回 &lt;span&gt;true&lt;/span&gt;，否则返回 &lt;span&gt;false&lt;/span&gt;。&lt;br/&gt;     * @param waterRequested&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    public synchronized boolean tryConsume(long waterRequested) {&lt;br/&gt;        leak();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (water + waterRequested &amp;lt;= capacity) {&lt;br/&gt;            water += waterRequested;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 。leak() 方法用于漏水，根据当前时间和上次漏水时间戳计算出应该漏出的水量，然后更新桶中的水量和漏水时间戳等状态。&lt;br/&gt;     */&lt;br/&gt;    private void &lt;span&gt;&lt;span&gt;leak&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        long now = System.currentTimeMillis();&lt;br/&gt;        long elapsedTime = now - lastLeakTimestamp;&lt;br/&gt;        long leakedWater = elapsedTime * rate / 1000;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (leakedWater &amp;gt; 0) {&lt;br/&gt;            water = Math.max(0, water - leakedWater);&lt;br/&gt;            lastLeakTimestamp = now;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;注意:   &lt;code&gt;tryConsume() &lt;/code&gt; 和 &lt;code&gt;leak() &lt;/code&gt;方法中，都需要对桶的状态进行同步，以保证线程安全性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 漏桶限流算法的优缺点&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可以平滑限制请求的处理速度，避免瞬间请求过多导致系统崩溃或者雪崩。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以控制请求的处理速度，使得系统可以适应不同的流量需求，避免过载或者过度闲置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以通过调整桶的大小和漏出速率来满足不同的限流需求，可以灵活地适应不同的场景。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;需要对请求进行缓存，会增加服务器的内存消耗。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于流量波动比较大的场景，需要较为灵活的参数配置才能达到较好的效果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但是面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这不是我们想看到的啦。流量变突发时，我们肯定希望系统尽量快点处理请求，提升用户体验嘛。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 令牌桶算法&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 什么是令牌桶算法&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;令牌桶算法是&lt;strong&gt;一种常用的限流算法&lt;/strong&gt;，可以用于限制单位时间内请求的数量。该算法维护一个固定容量的令牌桶，每秒钟会向令牌桶中放入一定数量的令牌。当有请求到来时，如果令牌桶中有足够的令牌，则请求被允许通过并从令牌桶中消耗一个令牌，否则请求被拒绝。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7490740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpy8GI0lVc3XJIbOB95yYCAuBXblNe3sgP2GBGS6WhwCQHgvnR1Bv5UtefVd2et5rZVFkm3mBAZyNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 令牌桶算法的伪代码实现&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * TokenBucket 类表示一个令牌桶&lt;br/&gt; */&lt;br/&gt;public class TokenBucket {&lt;br/&gt;&lt;br/&gt;    private final int capacity;     // 令牌桶容量&lt;br/&gt;    private final int rate;         // 令牌生成速率，单位：令牌/秒&lt;br/&gt;    private int tokens;             // 当前令牌数量&lt;br/&gt;    private long lastRefillTimestamp;  // 上次令牌生成时间戳&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 构造函数中传入令牌桶的容量和令牌生成速率。&lt;br/&gt;     * @param capacity&lt;br/&gt;     * @param rate&lt;br/&gt;     */&lt;br/&gt;    public TokenBucket(int capacity, int rate) {&lt;br/&gt;        this.capacity = capacity;&lt;br/&gt;        this.rate = rate;&lt;br/&gt;        this.tokens = capacity;&lt;br/&gt;        this.lastRefillTimestamp = System.currentTimeMillis();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * allowRequest() 方法表示一个请求是否允许通过，该方法使用 synchronized 关键字进行同步，以保证线程安全。&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    public synchronized boolean &lt;span&gt;&lt;span&gt;allowRequest&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        refill();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (tokens &amp;gt; 0) {&lt;br/&gt;            tokens--;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * refill() 方法用于生成令牌，其中计算令牌数量的逻辑是按照令牌生成速率每秒钟生成一定数量的令牌，&lt;br/&gt;     * tokens 变量表示当前令牌数量，&lt;br/&gt;     * lastRefillTimestamp 变量表示上次令牌生成的时间戳。&lt;br/&gt;     */&lt;br/&gt;    private void &lt;span&gt;&lt;span&gt;refill&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        long now = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (now &amp;gt; lastRefillTimestamp) {&lt;br/&gt;            int generatedTokens = (int) ((now - lastRefillTimestamp) / 1000 * rate);&lt;br/&gt;            tokens = Math.min(tokens + generatedTokens, capacity);&lt;br/&gt;            lastRefillTimestamp = now;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 令牌桶算法的优缺点&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;稳定性高&lt;/strong&gt;：令牌桶算法可以控制请求的处理速度，可以使系统的负载变得稳定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;精度高&lt;/strong&gt;：令牌桶算法可以根据实际情况动态调整生成令牌的速率，可以实现较高精度的限流。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;弹性好&lt;/strong&gt;：令牌桶算法可以处理突发流量，可以在短时间内提供更多的处理能力，以处理突发流量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Guava&lt;/code&gt;的&lt;code&gt;RateLimiter&lt;/code&gt;限流组件，就是基于令牌桶算法实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;实现复杂：相对于固定窗口算法等其他限流算法，令牌桶算法的实现较为复杂。对短时请求难以处理：在短时间内有大量请求到来时，可能会导致令牌桶中的令牌被快速消耗完，从而限流。这种情况下，可以考虑使用漏桶算法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时间精度要求高：令牌桶算法需要在固定的时间间隔内生成令牌，因此要求时间精度较高，如果系统时间不准确，可能会导致限流效果不理想。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来说，令牌桶算法具有较高的稳定性和精度，但实现相对复杂，适用于对稳定性和精度要求较高的场景。&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是捡田螺的小男孩，大家如果觉得面试题的答案有不对的地方，在评论区提出来哈，一起进步，加油~ 如果觉得文章对你有帮助，麻烦给个三连支持一下哈，感谢！&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg3NzU5NTIwNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxpY5pHeUUaicHSaqaylBb25Rbib0ocE4ZmXWdicS9tbGvFc9qvbiaNDibKKvuFYqlUdSW6VicXhoLNHfMQ/0?wx_fmt=png&quot; data-nickname=&quot;捡田螺的小男孩&quot; data-alias=&quot;&quot; data-signature=&quot;专注后端技术栈，热爱分享，热爱交朋友，热爱工作总结。毕业于华南理工大学，软件工程专业~&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6af9ef245e3d2f098f499ddb0cfd86f3</guid>
<title>ChatGPT 支持终端命令行啦，基于gpt-3.5-turbo</title>
<link>https://toutiao.io/k/i9mm7rb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ChatGPT 支持终端命令行啦，基于gpt-3.5-turbo&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支持连续对话，在终端输入asst即可开启对话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如让它写个feapder的爬虫，实际对答如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5305539691604797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mRjgDkvlL1NGaIw0r5qWBFvCr32X1pAVSulNGoTMj3xD3Lhibuo6lnshGzYJfGDCnwq5NWibhn2fn3K0oxoNjIdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3502&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安装&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pip install asst&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;没有OPENAI_API_KEY，可联系微信 boris_tm&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置&lt;code&gt;OPENAI_API_KEY=&quot;chatgpt的密钥&quot;&lt;/code&gt;到环境变量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「mac或linux下」&lt;/strong&gt;临时设置的方式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; OPENAI_API_KEY=your key&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;永久设置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vim ~/.bash_profile&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 在合适的位置添加环境变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; OPENAI_API_KEY=&lt;span&gt;&quot;your key&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「window下设置为系统环境变量」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考：https://blog.csdn.net/xue_nuo/article/details/114793534&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; asst&lt;/span&gt;&lt;br/&gt;You: hello&lt;br/&gt;Bot: Hi there!&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请求超时&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;国内用户因为墙的原因，无法直接访问chatgpt，需使用魔法。如vpn或代理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理使用方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置&lt;code&gt;ASST_PROXY=&quot;代理&quot;&lt;/code&gt;到环境变量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; ASST_PROXY=&lt;span&gt;&quot;username:password@ip:port&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;境外代理举例&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「推荐：brightdata」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不需要公司、不需要实名，准备好邮箱即可&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://brightdata.grsm.io/r0g6zla8seqs&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若提示认证，选择支付宝即可，并不需要真正的认证&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;充值支持支付宝&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用方式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;选择机房代理，因为便宜。追求稳定选择住宅&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23876404494382023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mRjgDkvlL1NGaIw0r5qWBFvCr32X1pAVDPJib1Mfe1v7z4WbtzhxMKMiaVWib3Sew6hEyeZg4bluhwgBkVKfJ4v7w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;712&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;配置：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9223107569721115&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mRjgDkvlL1NGaIw0r5qWBFvCr32X1pAV7GA5I8CxN4ElXZ16ndGDGvj3ZMsPrib51v94FUzl7DzsdKxYLl2LDfA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2008&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;查看访问参数&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5079617834394905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mRjgDkvlL1NGaIw0r5qWBFvCr32X1pAVLFzUokxib4CHYDy0YKMHmkHw0RsUGWcMwdFKqGUicpYtBSS9tsiaNNUJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1256&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;配置代理&lt;/p&gt;&lt;p&gt;设置&lt;code&gt;ASST_PROXY=&quot;代理&quot;&lt;/code&gt;到环境变量&lt;/p&gt;&lt;p&gt;如：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; ASST_PROXY=&lt;span&gt;&quot;用户名:密码@主机&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;OPENAI_API_KEY&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; 没有OPENAI_API_KEY，可联系微信 boris_tm&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>