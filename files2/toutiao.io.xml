<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3cca7b50affea12754da844a038a9de9</guid>
<title>SPI 机制，「可插拔」的奥义所在</title>
<link>https://toutiao.io/k/wulnrhz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小菜。一个希望能够成为 &lt;strong&gt;吹着牛X谈架构&lt;/strong&gt; 的男人！如果你也想成为我想成为的人，不然点个关注做个伴，让小菜不再孤单！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文主要介绍 &lt;code&gt;SPI 机制&lt;/code&gt;&lt;/p&gt;&lt;p&gt;如有需要，可以参考&lt;/p&gt;&lt;p&gt;如有帮助，不忘 &lt;strong&gt;点赞&lt;/strong&gt; ❥&lt;/p&gt;&lt;p&gt;微信公众号已开启，&lt;strong&gt;菜农曰&lt;/strong&gt;，没关注的同学们记得关注哦！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们上篇文章讲到了 Java 中 Agent 用法，不少小伙伴都觉得该方式比较偏门，平常开发不常用（几乎没用）。其实不然，不常用是跟项目挂钩，项目不常用不代表该方法机制不常用，因此很多时候我们学习不能坐井观天，认为项目中没用到就可以不学，跟着项目成长往往不能成长~！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;上篇跳转入口：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4ODA5MzUwOQ==&amp;amp;mid=2247487746&amp;amp;idx=1&amp;amp;sn=cf6b4e186e41a4e3c5991abfc4ab0a00&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Java 高级用法，写个代理侵入你？&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这篇我们将继续讲 Java 中的另一个知识点，也就是 &lt;code&gt;SPI&lt;/code&gt; 机制，乍听感觉依然陌生，这时可别再打退堂鼓！往下看你就会发现原来平时开发中经常看到！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、SPI&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这篇文章以&lt;code&gt;问题&lt;/code&gt;作为导向，用问题来驱动学习，小菜先抛出几个问题，下面将针对这几个问题进行解释并扩展&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;什么是 SPI ？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SPI 和 API 的区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;平常中有使用到 SPI 吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、什么是 SPI&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SPI 是三个单词的缩写 &lt;code&gt;S&lt;/code&gt;ervice &lt;code&gt;P&lt;/code&gt;rovider &lt;code&gt;I&lt;/code&gt;nterface，字面意思：服务提供接口。它是 Java 提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架&lt;code&gt;扩展和替换&lt;/code&gt;组件。具体作用便是为这些被扩展的 API 寻找服务实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而Java SPI 便是 JDK 内置的一种服务提供发现机制，常用于创建可扩展、可替换组件的应用程序，是java中&lt;code&gt;模块化&lt;/code&gt;与&lt;code&gt;插件化&lt;/code&gt;的关键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们提到了两个概念，分别是 &lt;code&gt;模块化&lt;/code&gt;和&lt;code&gt;插件化&lt;/code&gt;。模块化很好理解，就是将一个项目分成多个模块，模块间可能存在相互依赖（也就是通过 maven 的方式），有使用微服务开发的同学就毫不陌生了，如果没有使用微服务开发也不打紧，单体项目中为了界定 control，service，repository层，也会将每个领域单独提取成模块，而不是以目录的方式~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6918918918918919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWtaCPITnAibAfLvsXy322apkV5z80S9J8jEKEiad3nn8eYP2B6ibAMYHOictg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;185&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、类加载机制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们已经说到了 &lt;strong&gt;SPI&lt;/strong&gt; 较为粗浅的概念，小菜这里不打算直接深入 SPI，在深入 SPI 之前，我们先了解一下  Java 中的类加载机制。类加载机制可能实际开发中并不会去在意，但是它却无处不在，而这个也是面试的一大热点话题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM中，类加载器默认是使用双亲委派原则，默认的类加载器包括&lt;code&gt;Bootstarp ClassLoader&lt;/code&gt;、&lt;code&gt;Extension ClassLoader&lt;/code&gt; 和 &lt;code&gt;System ClassLoader（Application ClassLoader）&lt;/code&gt;，当然可能还有自定义类加载器~自定义类加载器可以通过继承 &lt;strong&gt;java.lang.classloader&lt;/strong&gt; 来实现&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各个类加载器作用范围如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Bootstrap ClassLoader：负责加载 JDK 自带的 rt.jar 包中的类文件，是所有类加载的父类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Extension ClassLoader：负责加载 java 的扩展类库从 &lt;strong&gt;jre/lib/ect&lt;/strong&gt;或 &lt;strong&gt;java.ext.dirs&lt;/strong&gt; 系统属性指定的目录下加载类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;System ClassLoader：负责从 classpath 环境变量中加载类文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载继承关系图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6229773462783171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWta2q8qBA6z5xaCw4CAOdfXrFw3gFrrwUovfJeIHbJI7ibibItoByxlicslQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;618&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1）双亲委派模型&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是双亲委派模型？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个类加载器收到加载类的任务时，会先交给自己的父加载器去完成，一级一级往上，因此最后都会传递到 Bootstrap ClassLoader 进行加载，只有当父加载器无法完成加载任务的时候，才会尝试自己进行加载&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么要这样设计呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、采用双亲委派原则可以避免相同类重复加载，每个加载器在进行类加载任务的时候都会委派给自己的父类加载器进行加载，如果父类加载无法加载才自己进行加载，避免重复加载的局面&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、可以保证类加载的安全性，不管是哪个加载器加载这个类，最终都是委托给顶层的加载器进行加载，保证任何加载器最终得到的都是同一个类对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载过程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7593014426727411&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWtadFxdtdeiaC9wSo2CwYRkdrddibYQrsNxZZffrMombAI5jd6Vo9aicYkxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1317&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这样做的缺陷？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子类加载器可以使用父类加载器已经加载过的类，而父类加载器无法使用子类加载器加载过的类（类似继承的关系）。这里就可以扯到 Java SPI 了，Java 提供了很多服务提供者接口（SPI），它可以允许第三方为这些接口提供实现，比如数据库中的 SPI 服务 - JDBC，这些 SPI 的接口由Java核心类提供，实现者确实第三方，这样就会存在问题，提供者由 Bootstrap ClassLoader加载，而实现者是由第三方自定义类加载器加载，而这个时候顶层类加载就无法使用子类加载器加载过的类&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3236994219653179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWta9dc62Nx72z3oy8uM2UYXKHicL6ticjNybggIgvTb3iabSIDjPMXZPSIww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;519&quot;/&gt;&lt;figcaption&gt;=&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要解决这个问题就得打破双亲委派原则&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用线程上下文类加载器（ContextClassLoader）加载&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 应用上下文加载器默认是使用AppClassLoader，想要在父类加载器使用到子类加载器加载的类可以使用 &lt;code&gt;Thread.currentThread().getContextClassLoader()&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们想要加载资源可以使用以下方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 使用线程上下文类加载器加载资源&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;{&lt;br/&gt;    String name = &lt;span&gt;&quot;java/sql/Array.class&quot;&lt;/span&gt;;&lt;br/&gt;    Enumeration&amp;lt;URL&amp;gt; urls = Thread.currentThread().getContextClassLoader().getResources(name);&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (urls.hasMoreElements()) {&lt;br/&gt;        URL url = urls.nextElement();&lt;br/&gt;        System.out.println(url.toString());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、Java SPI&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完类加载机制，我们再回到 Java SPI 来，我们先通过例子熟悉下 SPI 的使用方式&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用过程图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4898236092265943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWtapx7vzZUibz2tHg7eLibBMviamTWAwnCy63Qx33OQc8d6UhcshvxLcfv5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更加通俗的理解，SPI 实际上就是一种&lt;code&gt;策略模式&lt;/code&gt;的实现，基于接口编程再配合上配置文件来读取。这也符合我们的编程方式：&lt;code&gt;可插拔&lt;/code&gt;~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用例子如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;项目结构&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8755458515283843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWta7gPeNLzIFzKJMMvI76BcFicWPCF6mRibg52eUYC5tOfErBhXhDIRD1Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;458&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ICustomSvc&lt;/code&gt;：服务提供接口（也就是 SPI）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;CustomSvcOne/CustomSvcTwo&lt;/code&gt;：实现者（这里直接在一个项目中简单实现，也可以通过 jar 包导入的方式实现）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cbuc.life.spi.service.ICustomSvc&lt;/code&gt;：配置文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文件内容&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9404934687953556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWta8SZOSbrJwN2eTyccqS2aQ7KxxYKodELpqliaS0UY6LicU9LibReRf10Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1378&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们启动 &lt;code&gt;CustomTest&lt;/code&gt; 查看控制台结果&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2772727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWta3ibuhZhHb3QqvRsr6Pkhw4MtVVCktExGtjlARpp3KSUpzezqH7yHHeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;220&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到是可以加载到我们的实现类的方法，而这也就意味着已经实现了SPI 的功能&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1）实现原理&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我们上面使用SPI的时候可以看到一个关键的类那就是&lt;code&gt;ServiceLoader&lt;/code&gt; ，该类位于 &lt;code&gt;java.util&lt;/code&gt;包下，我们直接点进 &lt;code&gt;load()&lt;/code&gt; 方法查看如何调用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点进 &lt;code&gt;load()&lt;/code&gt; 方法我们首先看到以下代码&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17732558139534885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWtaZUDnbalDicibJd4DuiaD6Ydh9QiaS4poG9G2aPuSrFyUliaP5ibPu2scwMEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;688&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该块代码只是简单的声明了使用线程上下文加载器，我们继续跟进 &lt;code&gt;ServiceLoader.load(service, cl)&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22530864197530864&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWtaSeIoDibuxYI14CboKxsc91EwV797iaCuicXibaticETkibWI7DqgMibCQUBSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;648&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该块代码也没啥内容，声明返回了 ServiceLoader 对象，这个对象有什么文章？我们可以查看这个类声明&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceLoader&lt;/span&gt;&amp;lt;&lt;span&gt;S&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Iterable&lt;/span&gt;&amp;lt;&lt;span&gt;S&lt;/span&gt;&amp;gt;&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到这个对象实现了 &lt;code&gt;Iterable&lt;/code&gt; 接口，说明具有迭代的方法，可以猜测这样是为了取出我们定义 &lt;strong&gt;SPI&lt;/strong&gt; 的所有实现类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类的构造函数如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20634920634920634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWta22riaT3RG2L71x0Bic5gXtuIEA3oUEsxVibTJcFXiaFqUPHsicntIJa3FzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;882&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点在于 &lt;code&gt;reload()&lt;/code&gt; 方法，我们继续跟进&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5073891625615764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWtaXEB5XW2usOR0ibk4YO9Y8S8C8pkh0GZ99pA5x3zp5pHrg9sDib0tl2VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里将注释一起截取出来，我们可以看到这句话 &lt;code&gt;方法将惰性查找实例化&lt;/code&gt;，说明了上述说到实现 &lt;code&gt;Iterable&lt;/code&gt; 接口的用处，我们这里可以先点进 &lt;code&gt;iterator()&lt;/code&gt; 方法查看是如何实现的&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8558322411533421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWta9uicx3VibUDpU4CV0icayYkKLiabL0jsGzrvoP0aIkXQmAg8ygwV8xqycA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;763&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到有个关键的缓存，该缓存存储 &lt;code&gt;provider&lt;/code&gt;,每次操作的时候都会去该缓存中查找，如果存在则返回，否则采用 &lt;code&gt;LazyIterator&lt;/code&gt; 进行查找，我们进行进入到&lt;code&gt;LazyIterator&lt;/code&gt;类中查看如何实现，由于该类代码过长，我们直接截取关键代码，有兴趣的同学可以自行查看完整代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6095764272559853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWtabzFkRo0YF0BaJdnwZNhicgzRHoDLlOkSiaibCsVF3KotNiaPyKNEzIDjPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1086&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到该代码的实现顿时豁然开朗了，我们看到了熟悉的目录名 &lt;code&gt;META-INF/services/&lt;/code&gt;，该代码会去指定目录下获取文件资源，然后通过上传传入的线程上下文类加载器进行类加载，这样子我们的 SPI 实现类就可以供项目使用了~ 看完不得不感叹 &lt;strong&gt;妙啊&lt;/strong&gt;~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里为止，我们就已经拆解了 JAVA SPI 的使用以及实现原理，看完后是不是觉得该技巧也没有离我们很远~！&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Java SPI 机制更好的实现了 &lt;code&gt;可插拔&lt;/code&gt; 的开发理念，使得第三方服务模块的装配与调用者的业务代码相分离，也就是 &lt;code&gt;解耦&lt;/code&gt; 的概念，我们应用程序可以根据实际业务需要进行动态插拔。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、扩展&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring SPI&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然 SPI 机制不仅仅在 JDK 中实现，我们日常开发用到的 Spring 以及 Dubbo 框架都有对应的 SPI 机制。在Spring Boot中好多配置和实现都有默认的实现，我们如果想要修改某些配置，我们只需要在配置文件中写上对应的配置，那么项目应用的便是我们定义的配置内容，而这种方式就是采用 SPI 实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java SPI 与 Spring SPI 的区别&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;JDK 使用的加载工具类是 &lt;code&gt;ServiceLoader&lt;/code&gt;，而 Spring 使用的是 &lt;code&gt;SpringFactoriesLoader&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JDK 目录命名方式是&lt;code&gt;META-INF/services/提供方接口全类名&lt;/code&gt;，而 Spring 使用的是 &lt;code&gt;META-INF/spring-factories&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用 Spring Boot 中我们会将想要注入 IOC 容器的类将全类限定名写到 &lt;code&gt;META-INF/spring.factories&lt;/code&gt;文件中，在 Spring Boot 程序启动的时候就会由 &lt;strong&gt;SpringFactoriesLoader&lt;/strong&gt; 进行加载，扫描每个 jar 包 class-path 目录下的 &lt;code&gt;META-INF/spring.factories&lt;/code&gt; 配置文件，然后解析 properties 文件，找到指定名称的配置后返回&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5215469613259669&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P7WuIzkp9iaUuMibQzNk4UHbSWDaH1fWta846haQxOZ8cXpiaxyzfibnxhh1JRRWBeZJssib3cicP7p7lDttIO17bQww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1810&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说 SPI 在我们实际开发中随处可见，不止 Spring ，比如JDBC加载数据库驱动，SLF4J加载不同提供商的日志实现还有 Dubbo 使用SPI的方式实现框架的扩展等等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要空谈，不要贪懒，和小菜一起做个&lt;code&gt;吹着牛X做架构&lt;/code&gt;的程序猿吧~点个关注做个伴，让小菜不再孤单。咱们下文见！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;今天的你多努力一点，明天的你就能少说一句求人的话！&lt;em&gt;我是小菜，一个和你一起变强的男人。&lt;/em&gt; &lt;code&gt;💋&lt;/code&gt;微信公众号已开启，&lt;strong&gt;菜农曰&lt;/strong&gt;，没关注的同学们记得关注哦！&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>71c61b8251f9d6f40f48a4b7b7c692bd</guid>
<title>美团一面：为什么线程崩溃崩溃不会导致 JVM 崩溃</title>
<link>https://toutiao.io/k/l9ztu3e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.18273381294964028&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU8h8QYrHeibbpq0MLf3Ov6l7q5icQVPvjL6uLVcoV6m6ODVT9BfSEfZ3gFDlTYMnPxmpGJibDfEvabw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;点击关注公众号，Java干货&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;及时送达&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable js_wx_tap_highlight&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzU4MDUyMDQyNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/knmrNHnmCLEX3M6DvCn5gKuBOaMMVu9lUJAvwH2k66nV9VgGG0cyczd1ryib06P1z5pF72Le3HUr5loicnQx36lg/0?wx_fmt=png&quot; data-nickname=&quot;小哈学Java&quot; data-alias=&quot;xiaoha_java&quot; data-signature=&quot;专注于Java领域干货分享，不限于BAT面试, 算法，数据库，Spring Boot, 微服务,高并发, JVM, Docker容器，ELK相关知识，期待与您一同进步。&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot; has-insert-preloading=&quot;1&quot; data-index=&quot;0&quot; data-origin_num=&quot;44&quot; data-isban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;网上看到一个很有意思的美团面试题：为什么线程崩溃崩溃不会导致 JVM 崩溃，这个问题我看了不少回答，但发现都没答到根上，所以决定答一答，相信大家看完肯定会有收获，本文分以下几节来探讨&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程崩溃，进程一定会崩溃吗&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进程是如何崩溃的-信号机制简介&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为什么在 JVM 中线程崩溃不会导致 JVM 进程崩溃&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;openJDK 源码解析&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;线程崩溃，进程一定会崩溃吗&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;一般来说如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃，为什么系统要让进程崩溃呢，这主要是因为在进程中，&lt;strong&gt;各个线程的地址空间是共享的&lt;/strong&gt;，既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9715370018975332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU8h8QYrHeibbpq0MLf3Ov6lribyJQz7knHBWnFceHjvlj6ZAiciadmsPY7IMjgkdxl8SxSR95wzusl8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;527&quot; title=&quot;线程共享代码段，数据段，地址空间，文件&quot;/&gt;&lt;figcaption&gt;线程共享代码段，数据段，地址空间，文件&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;非法访问内存有以下几种情况，我们以 C 语言举例来看看&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;针对只读内存写入数据&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;char&lt;/span&gt; *s = &lt;span&gt;&quot;hello world&quot;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 向只读内存写入数据，崩溃&lt;/span&gt;&lt;br/&gt;   s[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;&#x27;H&#x27;&lt;/span&gt;; &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;访问了进程没有权限访问的地址空间（比如内核空间）&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; *p = (&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;0xC0000fff&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;   // 针对进程的内核空间写入数据，崩溃&lt;/span&gt;&lt;br/&gt;   *p = &lt;span&gt;10&lt;/span&gt;; &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 32 位虚拟地址空间中，p 指向的是内核空间，显然不具有写入权限，所以上述赋值操作会导致崩溃&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;访问了不存在的内存，比如&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; *a = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;   *a = &lt;span&gt;1&lt;/span&gt;;     &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;以上错误都是访问内存时的错误，所以统一会报 Segment Fault 错误（即段错误），这些都会导致进程崩溃&lt;/p&gt;&lt;h3&gt;&lt;span&gt;进程是如何崩溃的-信号机制简介&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;那么线程崩溃后，进程是如何崩溃的呢，这背后的机制到底是怎样的，答案是&lt;strong&gt;信号&lt;/strong&gt;，大家想想要干掉一个正在运行的进程是不是经常用 kill -9 pid 这样的命令，这里的 kill 其实就是给指定 pid 发送终止信号的意思，其中的 9 就是信号，其实信号有很多类型的，在 Linux 中可以通过 &lt;code&gt;kill -l&lt;/code&gt;查看所有可用的信号&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33094812164579607&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU8h8QYrHeibbpq0MLf3Ov6lEsDjTB5TO65X36LkVIdHbwvaqjRUzR0LjqIRGAV7yYvfP03OjVWWFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1118&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当然了发 kill 信号必须具有一定的权限，否则任意进程都可以通过发信号来终止其他进程，那显然是不合理的，实际上 kill 执行的是系统调用，将控制权转移给了内核（操作系统），由内核来给指定的进程发送信号&lt;/p&gt;&lt;p&gt;那么发个信号进程怎么就崩溃了呢，这背后的原理到底是怎样的？&lt;/p&gt;&lt;p&gt;其背后的机制如下&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU 执行正常的进程指令&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;调用 kill 系统调用向进程发送信号&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进程收到操作系统发的信号，CPU 暂停当前程序运行，并将控制权转交给操作系统&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;调用 kill 系统调用向进程发送信号（假设为 11，即 SIGSEGV，一般非法访问内存报的都是这个错误）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;操作系统根据情况执行相应的信号处理程序（函数），一般执行完信号处理程序逻辑后会让进程退出&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;注意上面的第五步，如果进程没有注册自己的信号处理函数，那么操作系统会执行默认的信号处理程序（一般最后会让进程退出），但如果注册了，则会执行自己的信号处理函数，这样的话就给了进程一个垂死挣扎的机会，它收到 kill 信号后，可以调用 exit() 来退出，&lt;strong&gt;但也可以使用 sigsetjmp，siglongjmp 这两个函数来恢复进程的执行&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 自定义信号处理函数示例&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 自定义信号处理函数，处理自定义逻辑后再调用 exit 退出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;sigHandler&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; sig)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Signal %d catched!\n&quot;&lt;/span&gt;, sig);&lt;br/&gt;  &lt;span&gt;exit&lt;/span&gt;(sig);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  signal(SIGSEGV, sigHandler);&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; *p = (&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;0xC0000fff&lt;/span&gt;;&lt;br/&gt;  *p = &lt;span&gt;10&lt;/span&gt;; &lt;span&gt;// 针对不属于进程的内核空间写入数据，崩溃&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 以上结果输出: Signal 11 catched!&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;如代码所示&lt;/strong&gt;：注册信号处理函数后，当收到 SIGSEGV 信号后，先执行相关的逻辑再退出&lt;/p&gt;&lt;p&gt;另外当进程接收信号之后也可以不定义自己的信号处理函数，而是选择忽略信号，如下&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 忽略信号&lt;/span&gt;&lt;br/&gt;  signal(SIGSEGV, SIG_IGN);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 产生一个 SIGSEGV 信号&lt;/span&gt;&lt;br/&gt;  raise(SIGSEGV);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;正常结束&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说虽然给进程发送了 kill 信号，但如果进程自己定义了信号处理函数或者无视信号就有机会逃出生天，当然了 kill -9 命令例外，不管进程是否定义了信号处理函数，都会马上被干掉&lt;/p&gt;&lt;p&gt;说到这大家是否想起了一道经典面试题：如何让正在运行的 Java 工程的优雅停机，通过上面的介绍大家不难发现，其实是 JVM 自己定义了信号处理函数，这样当发送 kill pid 命令（默认会传 15 也就是 SIGTERM）后，JVM 就可以在信号处理函数中执行一些资源清理之后再调用 exit 退出。这种场景显然不能用 kill -9，不然一下把进程干掉了资源就来不及清除了&lt;/p&gt;&lt;h3&gt;&lt;span&gt;为什么线程崩溃不会导致 JVM 进程崩溃&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;现在我们再来看看开头这个问题，相信你多少会心中有数，想想看在 Java 中有哪些是常见的由于非法访问内存而产生的 Exception 或 error 呢，常见的是大家熟悉的 StackoverflowError 或者 NPE（NullPointerException）,NPE 我们都了解，属于是访问了不存在的内存&lt;/p&gt;&lt;p&gt;但为什么栈溢出（Stackoverflow）也属于非法访问内存呢，这得简单聊一下进程的虚拟空间，也就是前面提到的共享地址空间&lt;/p&gt;&lt;p&gt;现代操作系统为了保护进程之间不受影响，所以使用了虚拟地址空间来隔离进程，进程的寻址都是针对虚拟地址，每个进程的虚拟空间都是一样的，而线程会共用进程的地址空间，以 32 位虚拟空间，进程的虚拟空间分布如下&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2405345211581291&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU8h8QYrHeibbpq0MLf3Ov6lJbAtmPp0qZckAw8PAoALLG6j3LNYevSwHjrFUV6q0FrSVdDq4NVicQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;449&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那么 stackoverflow 是怎么发生的呢，进程每调用一个函数，都会分配一个栈桢，然后在栈桢里会分配函数里定义的各种局部变量，假设现在调用了一个无限递归的函数，那就会持续分配栈帧，但 stack 的大小是有限的（Linux 中默认为 8 M，可以通过 ulimit -a 查看），如果无限递归很快栈就会分配完了，此时再调用函数试图分配超出栈的大小内存，就会发生段错误，也就是 stackoverflowError&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.94140625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU8h8QYrHeibbpq0MLf3Ov6lAZlrrAy3ahWYicGHfCkXwjwiaWicfQnfY3F7IP2bXmsRicKD9aupiafuBWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;好了，现在我们知道了 StackoverflowError 怎么产生的，那问题来了，既然 StackoverflowError 或者 NPE 都属于非法访问内存， JVM 为什么不会崩溃呢，有了上一节的铺垫，相信你不难回答，其实就是因为 JVM 自定义了自己的信号处理函数，拦截了 SIGSEGV 信号，针对这两者不让它们崩溃，怎么证明这个推测呢，我们来看下 JVM 的源码来一探究竟&lt;/p&gt;&lt;h3&gt;&lt;span&gt;openJDK 源码解析&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;HotSpot 虚拟机目前使用范围最广的 Java 虚拟机，据 R 大所述， Oracle JDK 与 OpenJDK 里的 JVM 都是 HotSpot VM，从源码层面说，两者基本上是同一个东西，OpenJDK 是开源的，所以我们主要研究下 Java 8 的 OpenJDK 即可，地址如下：&lt;span&gt;https://github.com/AdoptOpenJDK/openjdk-jdk8u&lt;/span&gt;，有兴趣的可以下载来看看&lt;/p&gt;&lt;p&gt;我们只要研究 Linux 下的 JVM，为了便于说明，也方便大家查阅，我把其中关于信号处理的关键流程整理了下（忽略其中的次要代码）&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5355691056910569&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU8h8QYrHeibbpq0MLf3Ov6lKUkW94asyrUG3eovoKdtNChwS7WFZeicR5UErAokPK2Ibwhuz3cYsxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;984&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以看到，在启动 JVM 的时候，也设置了信号处理函数，收到 SIGSEGV，SIGPIPE 等信号后最终会调用 JVM_handle_linux_signal 这个自定义信号处理函数，再来看下这个函数的主要逻辑&lt;/p&gt;&lt;pre&gt;&lt;code&gt;JVM_handle_linux_signal(&lt;span&gt;int&lt;/span&gt; sig,&lt;br/&gt;                        &lt;span&gt;siginfo_t&lt;/span&gt;* info,&lt;br/&gt;                        &lt;span&gt;void&lt;/span&gt;* ucVoid,&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; abort_if_unrecognized) {&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// Must do this before SignalHandlerMark, if crash protection installed we will longjmp away&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 这段代码里会调用 siglongjmp，主要做线程恢复之用&lt;/span&gt;&lt;br/&gt;  os::ThreadCrashProtection::check_crash_protection(sig, t);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (info != &lt;span&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; uc != &lt;span&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; thread != &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;    pc = (address) os::Linux::ucontext_get_pc(uc);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Handle ALL stack overflow variations here&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (sig == SIGSEGV) {&lt;br/&gt;      &lt;span&gt;// Si_addr may not be valid due to a bug in the linux-ppc64 kernel (see&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// comment below). Use get_stack_bang_address instead of si_addr.&lt;/span&gt;&lt;br/&gt;      address addr = ((NativeInstruction*)pc)-&amp;gt;get_stack_bang_address(uc);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 判断是否栈溢出了&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (addr &amp;lt; thread-&amp;gt;stack_base() &amp;amp;&amp;amp;&lt;br/&gt;          addr &amp;gt;= thread-&amp;gt;stack_base() - thread-&amp;gt;stack_size()) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (thread-&amp;gt;thread_state() == _thread_in_Java) {&lt;/code&gt;&lt;code&gt;            &lt;strong&gt;&lt;span&gt;// 针对栈溢出 JVM 的内部处理&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (sig == SIGSEGV &amp;amp;&amp;amp;&lt;br/&gt;               !MacroAssembler::needs_explicit_null_check((&lt;span&gt;intptr_t&lt;/span&gt;)info-&amp;gt;si_addr)) {&lt;br/&gt;         &lt;strong&gt;&lt;span&gt;// 此处会做空指针检查&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;      stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 如果是栈溢出或者空指针最终会返回 true，不会走最后的 report_and_die，所以 JVM 不会退出&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (stub != &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// save all thread context in case we need to restore it&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (thread != &lt;span&gt;NULL&lt;/span&gt;) thread-&amp;gt;set_saved_exception_pc(pc);&lt;br/&gt;&lt;br/&gt;    uc-&amp;gt;uc_mcontext.gregs[REG_PC] = (&lt;span&gt;greg_t&lt;/span&gt;)stub;&lt;br/&gt;    &lt;strong&gt;&lt;span&gt;// 返回 true 代表 JVM 进程不会退出&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;VMError &lt;span&gt;err&lt;/span&gt;&lt;span&gt;(t, sig, pc, info, ucVoid)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 生成 hs_err_pid_xxx.log 文件并退出&lt;/span&gt;&lt;br/&gt;  err.report_and_die();&lt;br/&gt;&lt;br/&gt;  ShouldNotReachHere();&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// Mute compiler&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从以上代码（注意看加粗的红线字体部分）我们可以知道以下信息&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;发生 stackoverflow 还有空指针错误，确实都发送了 SIGSEGV，只是虚拟机不选择退出，而是自己内部作了额外的处理，其实是恢复了线程的执行，并抛出 StackoverflowError 和 NPE，这就是为什么 JVM 不会崩溃且我们能捕获这两个错误/异常的原因&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果针对 SIGSEGV 等信号，在以上的函数中 JVM 没有做额外的处理，那么最终会走到 report_and_die 这个方法，这个方法主要做的事情是生成 hs_err_pid_xxx.log crash 文件（记录了一些堆栈信息或错误），然后退出&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;至此我相信大家明白了为什么发生了 StackoverflowError 和 NPE 这两个非法访问内存的错误，JVM 却没有崩溃。原因其实就是虚拟机内部定义了信号处理函数，而在信号处理函数中对这两者做了额外的处理以让 JVM 不崩溃，另一方面也可以看出如果 JVM 不对信号做额外的处理，最后会自己退出并产生 crash 文件 hs_err_pid_xxx.log（可以通过 -XX:ErrorFile=/var/&lt;em&gt;log&lt;/em&gt;/hs_err.log 这样的方式指定），这个文件记录了虚拟机崩溃的重要原因，所以也可以说，虚拟机是否崩溃只要看它是否会产生此崩溃日志文件&lt;/p&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;正常情况下，操作系统为了保证系统安全，所以针对非法内存访问会发送一个 SIGSEGV 信号，而操作系统一般会调用默认的信号处理函数（一般会让相关的进程崩溃），但如果进程觉得&quot;罪不致死&quot;，那么它也可以选择自定义一个信号处理函数，这样的话它就可以做一些自定义的逻辑，比如记录 crash 信息等有意义的事，回过头来看为什么虚拟机会针对 StackoverflowError 和 NullPointerException 做额外处理让线程恢复呢，针对 stackoverflow 其实它采用了一种&lt;span&gt;栈回溯&lt;/span&gt;的方法保证线程可以一直执行下去，而捕获空指针错误主要是这个错误实在太普遍了，为了这一个很常见的错误而让 JVM 崩溃那线上的 JVM 要宕机多少次，所以出于工程健壮性的考虑，与其直接让 JVM 崩溃倒不如让线程起死回生，并且将这两个错误/异常抛给用户来处理&lt;/p&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100015743&quot; data-ratio=&quot;0.08658008658008658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/TNUwKhV0JpTGQqtlGfEHkjibtshlaDwVKzjqq2pnpmYC14bKxDtSuhpWZWfVcicj5PFsoSMzuzicKIWZbsBpGXiaicg/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; data-type=&quot;gif&quot; data-w=&quot;462&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;pre&gt;&lt;pre&gt;&lt;pre data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(167, 167, 167)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(63, 63, 63)&quot; data-style=&quot;letter-spacing: 0.544px; font-size: 16px; color: rgb(63, 63, 63); word-spacing: 1px; line-height: inherit;&quot;&gt;&lt;section data-mpa-template-id=&quot;1250&quot; data-mpa-category=&quot;divider&quot; data-style=&quot;margin-right: 0.5em; margin-left: 0.5em; white-space: normal; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; color: rgb(0, 0, 0); letter-spacing: 0px; word-spacing: 2px;&quot; data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(230, 230, 230)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(0, 0, 0)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; data-style=&quot;margin: 10px 0em; color: rgb(89, 89, 89); letter-spacing: 0.544px;&quot; data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(138, 138, 138)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(89, 89, 89)&quot;&gt;&lt;section data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(138, 138, 138)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(89, 89, 89)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(138, 138, 138)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(89, 89, 89)&quot;&gt;&lt;p data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(106, 104, 111)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(106, 104, 111)&quot;&gt;1. &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&amp;amp;mid=2247512193&amp;amp;idx=1&amp;amp;sn=4aa86b542ca93ea67c6e6715b85eefc0&amp;amp;chksm=fd576007ca20e9115b5d8bc68c33183c38fec130f6d7da4f241a905fa6ed3e76712862ba6606&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我司用了 5 年的单点登录方案！从实现到部署实战详解，稳的一批!&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;我司用了 5 年的单点登录方案！从实现到部署实战详解，稳的一批!&lt;/a&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(138, 138, 138)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(89, 89, 89)&quot;&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(106, 104, 111)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(106, 104, 111)&quot;&gt;2. &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&amp;amp;mid=2247512168&amp;amp;idx=1&amp;amp;sn=fe1962a759c9697d6a916ac259d500c1&amp;amp;chksm=fd5760eeca20e9f8995e52629232d5b1b80e61b0925f6dde53f78863676b0ec7af719cd8a42a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringBoot+ElasticSearch 实现模糊查询，批量CRUD，排序，分页，高亮&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;SpringBoot+ElasticSearch 实现模糊查询，批量CRUD，排序，分页，高亮&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(138, 138, 138)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(89, 89, 89)&quot;&gt;&lt;span&gt;3. &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&amp;amp;mid=2247512163&amp;amp;idx=1&amp;amp;sn=eea81c05aaab027f526ec0d4bf898f44&amp;amp;chksm=fd5760e5ca20e9f33140a6cc0bfef24d4f897b2d300903f4be94dd29be955b4afa1bd1023db5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;非常强，批处理框架 Spring Batch 就该这么用！（场景实战）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;非常强，批处理框架 Spring Batch 就该这么用！（场景实战）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(106, 104, 111)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(106, 104, 111)&quot;&gt;4. &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&amp;amp;mid=2247512131&amp;amp;idx=1&amp;amp;sn=246484f135ebd17fa941a620da69aea8&amp;amp;chksm=fd5760c5ca20e9d3141965e34e221fac733a30f825b1d4e4d0e323591e1c95b2a39dd4ade1ac&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringBoot 还在用 if 校验参数？那你真的太low了，老司机都是这么玩的！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;SpringBoot 还在用 if 校验参数？那你真的太low了，老司机都是这么玩的！&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-style=&quot;margin-right: 0.5em; margin-left: 0.5em; white-space: normal; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0px; word-spacing: 2px; color: rgb(62, 62, 62); text-align: center;&quot; data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(168, 168, 168)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(62, 62, 62)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100015744&quot; data-ratio=&quot;0.5552731893265566&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/knmrNHnmCLEVGGmicJODkfibhcqyUwmTSC8CUvAMG78wPemfibvQ502uFs9jlziaLP50YcTs4rL9hQuzX32PAUOPHA/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;gif&quot; data-w=&quot;787&quot;/&gt;&lt;/p&gt;&lt;pre data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(138, 138, 138)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(89, 89, 89)&quot; data-style=&quot;letter-spacing: 0.544px; text-size-adjust: auto; word-spacing: 2px; color: rgb(89, 89, 89);&quot;&gt;&lt;p data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(168, 168, 168)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(62, 62, 62)&quot; data-style=&quot;margin-top: 5px; margin-bottom: 5px; white-space: normal; color: rgb(62, 62, 62); letter-spacing: 0.544px; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 14px; line-height: normal;&quot;&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(120, 172, 254)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(120, 172, 254)&quot;&gt;最近面试BAT，整理一份面试资料&lt;/span&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(61, 167, 66)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(61, 167, 66)&quot;&gt;《&lt;strong data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(61, 167, 66)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(61, 167, 66)&quot;&gt;Java面试BATJ通关手册&lt;/strong&gt;》&lt;/span&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(120, 172, 254)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(120, 172, 254)&quot;&gt;，覆盖了Java核心技术、JVM、Java并发、SSM、微服务、数据库、数据结构等等。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(156, 156, 156)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(74, 74, 74)&quot; data-style=&quot;margin-top: 15px; margin-bottom: 15px; letter-spacing: 0.544px; white-space: pre-line; line-height: 30px; color: rgb(74, 74, 74); font-family: Avenir, -apple-system-font, 微软雅黑, sans-serif;&quot;&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(120, 172, 254)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(120, 172, 254)&quot;&gt;获取方式：点“&lt;/span&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(61, 167, 66)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(61, 167, 66)&quot;&gt;在看&lt;/span&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(120, 172, 254)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(120, 172, 254)&quot;&gt;”，关注公众号并回复 &lt;/span&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(61, 167, 66)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(61, 167, 66)&quot;&gt;Java&lt;/span&gt;&lt;span data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(120, 172, 254)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(120, 172, 254)&quot;&gt; 领取，更多内容陆续奉上。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;PS：因公众号平台更改了推送规则，如果不想错过内容，记得读完点一下&lt;/span&gt;&lt;strong&gt;“&lt;span&gt;在看&lt;/span&gt;”&lt;/strong&gt;&lt;span&gt;，加个&lt;/span&gt;&lt;strong&gt;“&lt;span&gt;星标&lt;/span&gt;”&lt;/strong&gt;&lt;span&gt;，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;点&lt;strong&gt;“在看”&lt;/strong&gt;支持小哈呀，谢谢啦&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b791eb704ef8e2b535b146152690d9f6</guid>
<title>面试必备：MySQL 八股文系列</title>
<link>https://toutiao.io/k/7olzy1z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 三大范式&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一范式：确保每列保持原子性，数据表中的所有字段值都是不可分解的原子值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二范式：确保表中的每列都和主键相关。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三范式：确保每列都和主键列直接相关而不是间接相关。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 反范式化&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们应从业务角度出发，设计出符合范式准则要求的表结构。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;反范式化指的是通过增加冗余或重复的数据来换时间增加效率,违反第二第三范式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;反范式化可以减少关联查询时，join表的次数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在一些场景下，可以通过 JSON 数据类型进行反范式设计，提升存储效率。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. mysql的几种引擎，有什么区别&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;/th&gt;&lt;th&gt;InnoDB&lt;/th&gt;&lt;th&gt;MyISAM&lt;/th&gt;&lt;th&gt;MEMORY&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;事物安全&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;td&gt;不支持&lt;/td&gt;&lt;td&gt;不支持&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;对外建的支持&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;td&gt;不支持&lt;/td&gt;&lt;td&gt;不支持&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;存储限制&lt;/td&gt;&lt;td&gt;64TB&lt;/td&gt;&lt;td&gt;有&lt;/td&gt;&lt;td&gt;有&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;空间使用&lt;/td&gt;&lt;td&gt;高&lt;/td&gt;&lt;td&gt;低&lt;/td&gt;&lt;td&gt;低&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内存使用&lt;/td&gt;&lt;td&gt;高&lt;/td&gt;&lt;td&gt;低&lt;/td&gt;&lt;td&gt;高&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;插入数据的速度&lt;/td&gt;&lt;td&gt;低&lt;/td&gt;&lt;td&gt;高&lt;/td&gt;&lt;td&gt;高&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1  InnoDB、MyISAM 对比&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;InnoDB支持事务，MyISAM不支持。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB 支持外键，而 MyISAM 不支持。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键。MyISAM是非聚集索引，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB 不保存表的具体行数。MyISAM 用一个变量保存了整个表的行数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Innodb 有 redolog 日志文件，MyISAM 没有。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Innodb：frm是表定义文件，ibd是数据文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Myisam：frm是表定义文件，myd是数据文件，myi是索引文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB 支持表、行锁，而 MyISAM 支持表级锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB 必须有唯一索引(主键),如果没有指定的话 InnoDB 会自己生成一个隐藏列 Row_id 来充当默认主键，MyISAM 可以没有。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 为什么要使用自增主键&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;１.普通索引的 B+ 树上存放的是主键索引的值，如果该值较大，会「导致普通索引的存储空间较大」&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;２.使用自增 id 做主键索引新插入数据只要放在该页的最尾端就可以，直接「按照顺序插入」，不用刻意维护&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.页分裂容易维护，当插入数据的当前页快满时，会发生页分裂的现象，如果主键索引不为自增 id，那么数据就可能从页的中间插入，页的数据会频繁的变动，「导致页分裂维护成本较高」&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 什么是索引?&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;百度百科的解释：索引是对数据库表的一列或者多列的值进行排序一种结构，使用索引可以快速访问数据表中的特定信息。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引就一本书的目录，可以极大的提高我们在数据库的查询效率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 索引的优缺点？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;大大加快数据检索的速度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将随机I/O变成顺序I/O(因为B+树的叶子节点是连接在一起的)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加速表与表之间的连接&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从空间角度考虑，建立索引需要占用物理空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从时间角度 考虑，创建和维护索引都需要花费时间，例如对数据进行增删改的时候都需要维护索引。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 索引的数据结构？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引的数据结构主要有 B+ 树和哈希表，对应的索引分别为 B+ 树索引和哈希索引。InnoDB 默认的索引类型为 B+ 树索引。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 索引的类型有哪些?&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 主要的索引类型主要有 FULLTEXT，HASH，BTREE，RTREE。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;FULLTEXT&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;FULLTEXT 即全文索引，MyISAM存储引擎和InnoDB存储引擎在MySQL5.6.4以上版本支持全文索引，一般用于查找文本中的关键字，多在CHAR，VARCHAR，TAXT 等数据类型上创建全文索引。全文索引主要是用来解决&lt;code&gt;WHERE name LIKE &quot;%wekenw%&quot;&lt;/code&gt;等针对文本的模糊查询效率低的问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HASH&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HASH 即哈希索引，哈希索引多用于等值查询，时间复杂夫为o(1)，效率非常高，但不支持排序、范围查询及模糊查询等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;BTREE&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BTREE 即 B+ 树索引，INnoDB存储引擎默认的索引，支持排序、分组、范围查询、模糊查询等，并且性能稳定。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RTREE&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RTREE 即空间数据索引，多用于地理数据的存储，相比于其他索引，空间数据索引的优势在于范围查找。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 索引的种类有哪些？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主键索引：数据列不允许重复，不能为NULL，一个表只能有一个主键索引&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组合索引：由多个列值组成的索引。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;唯一索引：数据列不允许重复，可以为NULL，索引列的值必须唯一的，如果是组合索引，则列值的组合必须唯一。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全文索引：对文本的内容进行搜索。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;普通索引：基本的索引类型，可以为NULL&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5 什么是聚簇索引，什么是非聚簇索引？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;聚簇索引：将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非聚簇索引：将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.6 索引的设计原则？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最适合创建索引的列是出现在 WHERE 或 ON 子句中的列，或连接子句中的列而不是出现在SELECT关键字后的列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引列的基数越大、索引列的区分度越高，索引的效果越好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽量使用短索引，因为较小的索引涉及到的磁盘I/O较少，并且索引高速缓存中的块可以容纳更多的键值，会使得查询速度更快。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽量利用最左前缀。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要过度索引，每个索引都需要额外的物理空间，维护也需要花费时间，所以索引不是越多越好。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.7 索引失效的场景有哪些?&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不要在索引上做任何操作（计算、函数、自动/手动类型转换），不然会导致索引失效而转向全表扫描。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不能继续使用索引中范围条件（bettween、&amp;lt;、&amp;gt;、in等）右边的列 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引字段上使用（！= 或者 &amp;lt; &amp;gt;）判断时，会导致索引失效而转向全表扫描。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描，也是最左前缀原则。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引字段使用 or 时，会导致索引失效而转向全表扫描。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.8 创建索引的语法：&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先创建一个表：&lt;code&gt;create table t1 (id int primary key,username varchar(20),password varchar(20));&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建单个索引的语法：&lt;code&gt;CREATE INDEX 索引名 on 表名（字段名）&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引名一般是：&lt;code&gt;表名_字段名&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给id创建索引：&lt;code&gt;CREATE INDEX t1_id on t1(id);&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建联合索引的语法：&lt;code&gt;CREATE INDEX 索引名 on 表名（字段名1，字段名2）&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给 username 和 password 创建联合索引：&lt;code&gt;CREATE index t1_username_password ON t1(username,password)&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中index还可以替换成 unique，primary key，分别代表唯一索引和主键索引&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除索引：&lt;code&gt;DROP INDEX t1_username_password ON t1&lt;/code&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.数据库的事务&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1 什么是事务?其特性是什么?&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务是指是程序中一系列操作必须全部成功完成，有一个失败则全部失败&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1.「原子性（Atomicity）」：要么全部执行成功，要么全部不执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.「一致性（Consistency）」：事务前后数据的完整性必须保持一致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.「隔离性（Isolation）」：隔离性是当多个事务同事触发时，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4.「持久性（Durability）」：事务完成之后的改变是永久的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2 事务的隔离级别?&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1.「读已提交」：即能够「读取到那些已经提交」的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.「读未提交」：即能够「读取到没有被提交」的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.「可重复读」：可重复读指的是在一个事务内，最开始读到的数据和事务结束前的「任意时刻读到的同一批数据都是一致的」。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4.「可串行化」：最高事务隔离级别，不管多少事务，都是「依次按序一个一个执行」。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3 隔离性实现原理：&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;隔离性的实现原理比较特殊，是通过数据库锁的机制实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;隔离性分四个级别：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;读未提交：一个事务可以读到另外一个事务未提交的数据。脏读&lt;/p&gt;&lt;p&gt;实现：事务在读数据的时候并未对数据进行加锁。&lt;/p&gt;&lt;p&gt;事务在发生更新数据的瞬间，必须先对其加 行级共享锁，直到事务结束才释放。&lt;/p&gt;&lt;p&gt;举例：事务A读取某行记录时(没有加锁)，事务2也能对这行记录进行读取、更新。当事务B对该记录进行更新时，事务A读取该记录，能读到事务B对该记录的修改版本，即使该修改尚未被提交。&lt;/p&gt;&lt;p&gt;事务A更新某行记录时，事务B不能对这行记录做更新，直到事务A结束。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;读已提交：一个事务可以读到另外一个事务提交的数据。不可重复读&lt;/p&gt;&lt;p&gt;实现：事务对当前被读取的数据加 &lt;code&gt;行级共享锁&lt;/code&gt;（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；&lt;/p&gt;&lt;p&gt;事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 &lt;code&gt;行级排他锁&lt;/code&gt;，直到事务结束才释放。&lt;/p&gt;&lt;p&gt;原理：事务A读取某行记录时，事务B也能对这行记录进行读取、更新；当事务B对该记录进行更新时，事务A再次读取该记录，读到的只能是事务B对其更新前的版本，或者事务B提交后的版本。事务A更新某行记录时，事务B不能对这行记录做更新，直到事务1结束。&lt;/p&gt;&lt;p&gt;流程描述：事务A读操作会加上&lt;code&gt;共享锁&lt;/code&gt;，事务B写操作时会加上&lt;code&gt;排他锁&lt;/code&gt;，当事务B正在写操作时，事务A要读操作，发现有排他锁，事务A就会阻塞，等待排他锁释放(事务B写操作提交才会释放)，才能进行读操作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可重复读&lt;/p&gt;&lt;p&gt;实现：事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 &lt;code&gt;行级共享锁&lt;/code&gt;，直到事务结束才释放；&lt;/p&gt;&lt;p&gt;事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 &lt;code&gt;行级排他锁&lt;/code&gt;，直到事务结束才释放。&lt;/p&gt;&lt;p&gt;举例：事务A读取某行记录时，事务B也能对这行记录进行读取、更新；当事务B对该记录进行更新时，事务A再次读取该记录，读到的仍然是第一次读取的那个版本。事务A更新某行记录时，事务B不能对这行记录做更新，直到事务1结束。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可串行化(Serializable) 写操作串联执行&lt;/p&gt;&lt;p&gt;实现：事务在读取数据时，必须先对其加 &lt;code&gt;表级共享锁&lt;/code&gt; ，直到事务结束才释放；&lt;/p&gt;&lt;p&gt;事务在更新数据时，必须先对其加 &lt;code&gt;表级排他锁&lt;/code&gt; ，直到事务结束才释放。&lt;/p&gt;&lt;p&gt;举例：事务A正在读取A表中的记录时，则事务B也能读取A表，但不能对A表做更新、新增、删除，直到事务A结束。事务A正在更新A表中的记录时，则事务B不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务A结束。&lt;/p&gt;&lt;p&gt;原理：在读操作时，加&lt;code&gt;表级共享锁&lt;/code&gt;，事务结束时释放；写操作时候，加&lt;code&gt;表级独占锁&lt;/code&gt;，事务结束时释放。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「MySQL的默认隔离级别是可重复读。」&lt;/strong&gt;数据库的隔离级别分别可以解决数据库的脏读、不可重复读、幻读等问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29055007052186177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6dG42unCkRBUqDYeegFhS8QpKEUPD82yIdP1MOouczk6vPVbGJ2AaGd0j2vggdEqSrEhC8ibeKqUwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;709&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1.「脏读」&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;脏读指的是「读到了其他事务未提交的数据」，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2.「不可重复读」&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对比可重复读，不可重复读指的是在同一事务内，「不同的时刻读到的同一批数据可能是不一样的」。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3.「幻读」&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现「好像刚刚的更改对于某些数据未起作用」，但其实是事务B刚插入进来的这就叫幻读。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.4 隔离级别是如何实现的？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务的隔离机制主要是依靠锁机制和MVCC(多版本并发控制)实现的，提交读和可重复读可以通过MVCC实现，串行化可以通过锁机制实现。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 什么是MVCC，有什么作用?&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MVCC:多版本并发控制，主要用来提高数据库的并发性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MVCC的作用就是在不加锁的情况下，解决数据库读写冲突问题，并且解决脏读、幻读、不可重复读等问题，但是不能解决丢失修改问题。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 数据库的锁&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.1 什么是数据库的锁？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当数据库有并发事务的时候，保证数据访问顺序的机制称为锁机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库的锁与隔离级别的关系？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33063209076175043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6dG42unCkRBUqDYeegFhS8QQ3lhwdc5lflGicf1wmTjTgPo8RpamjEB0KblNNcOOTYPqmiaQvhRJeIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;617&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.2 数据库锁的类型有哪些？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2608695652173913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6dG42unCkRBUqDYeegFhS8QbMKm2cVDwf9YCXxn8Fg31K8UiaWicapflhJvtExyyC27Gwg4Vicee1qBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MyISAM 默认采用表级锁，InnoDB 默认采用行级锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从锁的类别上区别可以分为共享锁和排他锁&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;共享锁：共享锁又称读锁，简写为S锁，一个事务对一个数据对象加了S锁，可以对这个数据对象进行读取操作，但不能进行更新操作。并且在加锁期间其他事务只能对这个数据对象加S锁，不能加X锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排他锁：排他锁又称为写锁，简写为X锁，一个事务对一个数据对象加了X锁，可以对这个对象进行读取和更新操作，加锁期间，其他事务不能对该数据对象进行加X锁或S锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.3 什么是数据库的乐观锁和悲观锁，如何实现？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乐观锁：系统假设数据的更新在大多数时候是不会产生冲突的，所以数据库只在更新操作提交的时候对数据检测冲突，如果存在冲突，则数据更新失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乐观锁实现方式：一般通过版本号和CAS算法实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。通俗讲就是每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;悲观锁的实现方式：通过数据库的锁机制实现，对查询语句添加for updata。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.4 什么是死锁？如何避免？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁是指两个或者两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。在 MySQL 中，MyISAM 是一次获得所需的全部锁，要么全部满足，要么等待，所以不会出现死锁。在 InnoDB 存储引擎中，除了单个 SQL 组成的事务外，锁都是逐步获得的，所以存在死锁问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何避免MySQL发生死锁或锁冲突：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果不同的程序并发存取多个表，尽量以相同的顺序访问表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在程序以批量方式处理数据的时候，如果已经对数据排序，尽量保证每个线程按照固定的顺序来处理记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在事务中，如果需要更新记录，应直接申请足够级别的排他锁，而不应该先申请共享锁，更新时在申请排他锁，因为在当前用户申请排他锁时，其他事务可能已经获得了相同记录的共享锁，从而造成锁冲突或者死锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽量使用较低的隔离级别。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽量使用索引访问数据，使加锁更加准确，从而减少锁冲突的机会。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;合理选择事务的大小，小事务发生锁冲突的概率更低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽量用相等的条件访问数据，可以避免Next-Key锁对并发插入的影响。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要申请超过实际需要的锁级别，查询时尽量不要显示加锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于一些特定的事务，可以表锁来提高处理速度或减少死锁的概率。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. B 树和 B+ 树的区别？&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;B 树中的内部节点和叶子节点均存放键和值，而 B+ 树的内部节点只有键没有值，叶子节点存放所有的键和值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;B＋ 树的叶子节点是通过相连在一起的，方便顺序检索。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8493894165535957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6dG42unCkRBUqDYeegFhS8QZNeiavN72WDhQclGyZF5bvffrSyUdqwJY8Kx2CHBIMK6eDQ7126SV3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 数据库为什么使用 B+ 树而不是 B 树？&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;B 树适用于随机检索，而 B+ 树适用于随机检索和顺序检索。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B+ 树的空间利用率更高，因为 B 树每个节点要存储键和值，而 B+ 树的内部节点只存储键，这样 B+ 树的一个节点就可以存储更多的索引，从而使树的高度变低，减少了 I/O 次数，使得数据检索速度更快。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B+ 树的叶子节点都是连接在一起的，所以范围查找，顺序查找更加方便。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B+ 树的性能更加稳定，因为在 B+ 树中，每次查询都是从根节点到叶子节点，而在 B 树中，要查询的值可能不在叶子节点，在内部节点就已经找到。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.1 什么情况适合使用 B 树呢？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 B 树的内部节点也可以存储值，所以可以把一些频繁访问的值放在距离根节点比较近的地方，这样就可以提高查询效率。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. MySQL执行SQL语句的的流程？&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7895522388059701&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6dG42unCkRBUqDYeegFhS8Q3GibBVsibmlaxeDD7RLBnCbDcB3E9nhicL8QN1qdyPcqG7aGrXLIAIdtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1.通过连接器跟客户端「建立连接」。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.通过查询「缓存查询」之前是否有查询过该 sql。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.通过分析器「分析该 sql 的语义」是否正确，包括格式，表等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4.通过优化器「优化该语句」，比如选择索引，join 表的连接顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;5.「验证权限」，验证是否有该表的查询权限。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;6.通过执行器调用存储引擎执行该 sql，然后返回「执行结果」。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11. binlog、undolog、relaylog、redolog？&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;binlog 是归档日志，属于 Server 层的日志，是一个二进制格式的文件，用于「记录用户对数据库更新的SQL语句信息」。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要作用：主从复制、数据恢复。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;undolog 是 InnoDB 存储引擎的日志，用于保证数据的原子性，「保存了事务发生之前的数据的一个版本，也就是说记录的是数据是修改之前的数据，可以用于回滚」，同时可以提供多版本并发控制下的读（MVCC）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要作用：事务回滚、实现多版本控制(MVCC)。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;relaylog 是中继日志，「在主从同步的时候使用到」，它是一个中介临时的日志文件，用于存储从master节点同步过来的binlog日志内容。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;redolog 是 「InnoDB 存储引擎所特有的一种日志」，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以做「数据恢复并且提供 crash-safe 能力」。当有增删改相关的操作时，会先记录到 Innodb 中，并修改缓存页中的数据，「等到 mysql 闲下来的时候才会真正的将 redolog 中的数据写入到磁盘当中」。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12. 说说两阶段提交。&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两阶段提交分为 prepare 和 commit 阶段：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;准备阶段：事物 SQL 先写入 redo log buffer，然后做一个事物准备标记，在将log buffer 中的数据刷新到 redo log。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提交阶段：将事物产生的 binlog 写入文件，刷新磁盘。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;再在 redo log 中做一个事物提交的标记，并把 binlog 写成功的标记也一并写入 redo log 文件。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景分析两阶段提交如何保证数据库的一致性。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;准备阶段，redo log 刷新到磁盘了，但是 binlog 写磁盘前发生了 mysql实例 crash，这时会发生怎样的操作呢？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;即使 redo log 写盘成功了，但由于 binlog 未写入成功，需要执行回滚操作来保证数据库的一致性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提交阶段，binlog 写盘成功了，这时 mysql 实例 crash了。这时 binlog 已经确保写成功了，我们在重启实例进行恢复的时候，只需要让 redo log 重做一次就可以了。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13. 分库分表相关&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.1 分库分表方案:&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.2 常用的分库分表中间件：&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.3 分库分表可能遇到的问题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;事务问题：需要用分布式事务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跨节点Join的问题：解决这一问题可以分两次查询实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据迁移，容量规划，扩容等问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跨分片的排序分页问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.4 数据库如何进行垂直拆分以及水平拆分的原理是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;垂直拆分&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;专库专用
一个数据库由很多表的构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;拆分后业务清晰，拆分规则明确。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统之间整合或扩展容易。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据维护简单。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;部分业务表无法join，只能通过接口方式解决，提高了系统复杂度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;受每种业务不同的限制存在单库性能瓶颈，不易数据扩展跟性能提高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务处理复杂。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;水平拆分&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垂直拆分后遇到单机瓶颈，可以使用水平拆分。相对于垂直拆分的区别是：垂直拆分是把不同的表拆到不同的数据库中，而水平拆分是把同一个表拆到不同的数据库中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对于垂直拆分，水平拆分不是将表的数据做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中 的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中，主要有分表，分库两种模式，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不存在单库大数据，高并发的性能瓶颈。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对应用透明，应用端改造较少。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照合理拆分规则拆分，join操作基本避免跨库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提高了系统的稳定性跟负载能力。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;拆分规则难以抽象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分片事务一致性难以解决。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据多次扩展难度跟维护量极大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跨库join性能较差。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14. Mysql 主从之间是怎么同步数据的?&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.master 主库将此次更新的事件类型「写入到主库的 binlog 文件」中。2.master 「创建 log dump 线程通知 slave」 需要更新数据。3.「slave」 向 master 节点发送请求，「将该 binlog 文件内容存到本地的 relaylog 中」。4.「slave 开启 sql 线程」读取 relaylog 中的内容，「将其中的内容在本地重新执行一遍」，完成主从数据同步。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5397727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6dG42unCkRBUqDYeegFhS8QadO9tTomoZ60n1AdZGWsnN3mn799Ug29GIkDHnFEFicP7jLUBSkQPzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;704&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.1 同步策略&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.「全同步复制」：主库强制同步日志到从库，等全部从库执行完才返回客户端，性能差。2.「半同步复制」：主库收到至少一个从库确认就认为操作成功，从库写入日志成功返回ack确认。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.2 主从延迟要怎么解决?&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;主从复制分了五个步骤进行：&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46189024390243905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6dG42unCkRBUqDYeegFhS8Qibdp2bdDMQVqBxQJyd386zX0Avlia96C7JPIy1eDGy8k3AbIsAlW0gjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主库的更新事件(update、insert、delete)被写到binlog。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从库发起连接，连接到主库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此时主库创建一个binlog dump thread，把binlog的内容发送到从库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;主从同步延迟的原因:&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;主从同步延迟的解决办法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.MySQL 5.6 版本以后，提供了一种「并行复制」的方式，通过将 SQL 线程转换为多个 work 线程来进行重放。2.「提高机器配置」增加从服务器，目的分散读的压力，从而降低服务器负载。3.在业务初期就选择合适的分库、分表策略，「避免单表单库过大」带来额外的复制压力
4.「避免长事务」。5.「避免让数据库进行各种大量运算」。6.对于一些对延迟很敏感的业务「直接使用主库读」。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15. 如何优化 SQL，说说你的 Sql 调优思路吧&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5491452991452992&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6dG42unCkRBUqDYeegFhS8QNtVrLFrp0U2wtbSk0qn5hgXTx7dq7yfcpNRlnyuln0hqNky7JBLPKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;468&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;「表结构优化」&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;拆分字段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字段类型的选择&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字段类型大小的限制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;合理的增加冗余字段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新建字段一定要有默认值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;「索引方面」&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;索引字段的选择&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用好mysql支持的索引下推，覆盖索引等功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;唯一索引和普通索引的选择&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;「查询语句方面」&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;避免索引失效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;合理的书写where条件字段顺序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;小表驱动大表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以使用force index()防止优化器选错索引&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;「分库分表」&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16. 了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关参数：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;slow_query_log：是否开启慢日志查询，1表示开启，0表示关闭。slow_query_log_file：MySQL数据库慢查询日志存储路径。long_query_time：慢查询阈值，当SQL语句查询时间大于阈值，会被记录在日志上。log_queries_not_using_indexes：未使用索引的查询会被记录到慢查询日志中。log_output：日志存储方式。“FILE”表示将日志存入文件。“TABLE”表示将日志存入数据库。如何对慢查询进行优化？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析语句的执行计划，查看SQL语句的索引是否命中
优化数据库的结构，将字段很多的表分解成多个表，或者考虑建立中间表。优化LIMIT分页。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17. 字段为什么要设置成 not null?&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先说一点，NULL和空值是不一样的，空值是不占用空间的，而NULL是占用空间的，所以字段设为NOT NULL后仍然可以插入空值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字段设置成not null主要有以下几点原因：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NULL值会影响一些函数的统计，如count，遇到NULL值，这条记录不会统计在内。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B树不存储NULL，所以索引用不到NULL，会造成第一点中说的统计不到的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NOT IN子查询在有NULL值的情况下返回的结果都是空值。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18. varchar和char的区别？&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;varchar表示变长，char表示长度固定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储容量不同，对于 char 来说，最多能存放的字符个数为255。对于 varchar，最多能存放的字符个数是 65532。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储速度不同，char 长度固定，存储速度会比 varchar 快一些，但在空间上会占用额外的空间，属于一种空间换时间的策略。而 varchar 空间利用率会高些，但存储速度慢，属于一种时间换空间的策略。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.1 为什么 VarChar 建议不要超过255?&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当定义varchar长度小于等于255时，长度标识位需要一个字节(utf-8编码)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当大于255时，长度标识位需要两个字节，并且建立的索引也会失效。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.2 varchar(10)和int(10)代表什么含义?&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;varchar 的10代表了申请的空间长度，也是可以存储的数据的最大长度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int 的10只是代表了展示的长度，不足10位以0填充。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的，只是在展示时按照长度展示。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19. drop、delete和truncate的区别？&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;drop&lt;/th&gt;&lt;th&gt;delete&lt;/th&gt;&lt;th&gt;truncate&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;速度&lt;/td&gt;&lt;td&gt;快&lt;/td&gt;&lt;td&gt;逐行删除，慢&lt;/td&gt;&lt;td&gt;较快&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;类型&lt;/td&gt;&lt;td&gt;DDL&lt;/td&gt;&lt;td&gt;DML&lt;/td&gt;&lt;td&gt;DDL&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;回滚&lt;/td&gt;&lt;td&gt;不可回滚&lt;/td&gt;&lt;td&gt;可回滚&lt;/td&gt;&lt;td&gt;不可回滚&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;删除内容&lt;/td&gt;&lt;td&gt;删除整个表，数据行、索引都会被删除&lt;/td&gt;&lt;td&gt;表结构还在，删除表的一部分或全部数据&lt;/td&gt;&lt;td&gt;表结构还在，删除表的全部数据&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结：删除整个表，使用drop，删除表的部分数据使用delete，保留表结构删除表的全部数据使用truncate。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20 对慢查询如何优化？&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.1 如何查找查询速度慢的原因？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;记录慢查询日志，分析查询日志，可以使用pt-query-digest工具进行分析。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;slow_query_log：是否开启慢日志查询，1表示开启，0表示关闭。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;slow_query_log_file：MySQL数据库慢查询日志存储路径。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;long_query_time：慢查询阈值，当SQL语句查询时间大于阈值，会被记录在日志上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;log_queries_not_using_indexes：未使用索引的查询会被记录到慢查询日志中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;log_output：日志存储方式。“FILE”表示将日志存入文件。“TABLE”表示将日志存入数据库。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;show profile&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;set&lt;/span&gt; profiling=&lt;span&gt;1&lt;/span&gt;; //开启，服务器上所有执行语句会记录执行时间，存到临时表中&lt;br/&gt;&lt;span&gt;show&lt;/span&gt; &lt;span&gt;profiles&lt;/span&gt;&lt;br/&gt;&lt;span&gt;show&lt;/span&gt; profile &lt;span&gt;for&lt;/span&gt; &lt;span&gt;query&lt;/span&gt; 临时表&lt;span&gt;ID&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;show status&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;show status 会返回一些计数器，show global status 会查看所有服务器级别的所有计数。有时根据这些计数，可以推测出哪些操作代价较高或者消耗时间多。&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;show processlist&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察是否有大量线程处于不正常的状态或特征：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1889055472263868&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6dG42unCkRBUqDYeegFhS8QOy3f917zFiclrgWLeCjfGeQeQ4eYySsyUaHO9y6asPkfsYtiaLP6yT4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 explain 分析语句&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析慢语句是否命中索引：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2434402332361516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6dG42unCkRBUqDYeegFhS8QdHyPibnP9F3NEfEIOchvaSyvt1yCVwibibn0W9yQOBQtwEulAo60Jul2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.2 如何对慢查询进行优化？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分析语句的执行计划，查看SQL语句的索引是否命中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;优化数据库的结构，将字段很多的表分解成多个表，或者考虑建立中间表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;优化LIMIT分页。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>94227c8768da286ef20e95db60759690</guid>
<title>一篇文章彻底搞定信号</title>
<link>https://toutiao.io/k/y0rue15</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.信号是什么？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;信号其实就是一个软件中断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;输入命令，在Shell下启动一个前台进程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户按下Ctrl-C，键盘输入产生一个硬件中断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果CPU当前正在执行这个进程的代码，则该进程的用户空间代码暂停执行， CPU从用户态切换到内核态处理硬件中断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;终端驱动程序将Ctrl-C解释成一个SIGINT信号，记在该进程的PCB中（也可以说发送了一个SIGINT信号给该进程）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当某个时刻要从内核返回到该进程的用户空间代码继续执行之前，首先处理PCB中记录的信号，发现有一个SIGINT信号待处理，而这个信号的默认处理动作是终止进程，所以直接终止进程而不再返回它的用户空间代码执行。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，由ctrl+c产生的硬件中断就是一个信号。Ctrl+C产生的信号只能发送给前台进程，命令后加&amp;amp;就可放到后台运行。Shell可同时运行一个前台进程和任意多个后台进程，只有前台进程才能接受到像CTRL+C这种控制键产生的信号。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.信号的种类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用命令查看：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;kill&lt;/span&gt; -l&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非可靠信号：1~31号信号，信号可能会丢失
可靠信号：34~64号信号，信号不可能丢失&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3163538873994638&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9ricY7CY550a2uKUobe3Kvk3kWbkqjd9PZQJjxj8rzKPvnRnckQCFJEURRHS421mII0LLQDIBe6yQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1492&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIGHUP：1号信号，Hangup detected on controlling terminal or death of controlling process（在控制终端上挂起信号，或让进程结束），ation：term&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIGINT：2号信号，Interrupt from keyboard（键盘输入中断，&lt;strong&gt;ctrl + c&lt;/strong&gt; ），action：term&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIGQUIT：3号信号，Quit from keyboard（键盘输入退出&lt;strong&gt;，ctrl+ |&lt;/strong&gt; ），action：core，产生core dump文件&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIGABRT：6号信号，Abort signal from abort(3)（非正常终止，&lt;strong&gt;double free&lt;/strong&gt;），action：core&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIGKILL：9号信号，Kill signal（杀死进程信号），action：term，该信号不能被阻塞、忽略、自定义处理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIGSEGV：11号信号，Invalid memory reference（无效的内存引用，解引用空指针、内存越界访问），action：core&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIGPIPE：13号信号，Broken pipe: write to pipe with no readers（管道中止: 写入无人读取的管道，会导致管道破裂），action：term&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIGCHLD：17号信号，Child stopped or terminated（子进程发送给父进程的信号，但该信号为忽略处理的）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIGSTOP：19号信号，Stop process（停止进程），action：stop&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIGTSTP：20号信号，Stop typed at terminal（终端上发出的停止信号，&lt;strong&gt;ctrl + z&lt;/strong&gt;），action：stop&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的信号采取的动作和详细信息可查看：&lt;strong&gt;man 7 signal&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.信号的产生&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1硬件产生&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;硬件产生即通过终端按键产生的信号：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ctrl + c：SIGINT(2)，发送给前台进程，&amp;amp; 进程放到后台运行，fg 把刚刚放到后台的进程，再放到前台来运行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ctrl + z：SIGTSTP(20)，一般不用，除非有特定场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ctrl + | ：SIGQUIT(3)，产生core dump文件&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产生core dump文件的条件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;当前OS一定不要限制core dump文件的大小，&lt;span&gt;ulimit&lt;/span&gt; -a&lt;br/&gt;磁盘空间要足够&lt;br/&gt;如何产生：&lt;br/&gt;3.1 解引用空指针，收到11号信号，产生core dump文件&lt;br/&gt;3.2 内存访问越界，程序一旦崩溃，就会收到11号信号，也就会产生core dump文件&lt;br/&gt;3.3 double free，收到6号信号，并产生core dump。&lt;br/&gt;3.4 free（NULL），不会崩溃&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2软件产生&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件产生即调用系统函数向进程发信号&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;kill函数&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;kill&lt;/span&gt;&lt;span&gt;(&lt;span&gt;pid_t&lt;/span&gt; pid, &lt;span&gt;int&lt;/span&gt; sig)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;参数解释：&lt;br/&gt;pid：进程号&lt;br/&gt;sig：要发送的信号值&lt;br/&gt;返回值：成功返回&lt;span&gt;0&lt;/span&gt;，失败返回&lt;span&gt;-1&lt;/span&gt;，并设置错误&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;kill命令：kill -[信号] pid，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;abort：void abort(void);，收到6号信号，谁调用该函数，谁就收到信号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;alarm：unsigned int alarm(unsigned int seconds);，收到14号信号，告诉内核在seconds秒后给进程发送SIGALRM信号，该信号默认处理动作为终止当前进程。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.信号的注册&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;信号注册又分为可靠信号的注册和非可靠信号的注册。信号注册实际上是一个位图和一个sigqueue队列。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3350864012021037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9ricY7CY550a2uKUobe3KvkTBEXPrVvFs38ib0M7Y4qo28A2d56ICsNN6tAs74rLk4qsxFZ52DITpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1331&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1非可靠信号的注册&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当进程收到非可靠信号时：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;将非可靠信号对应的比特位置为1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加sigqueue节点到sigqueue队列当中，但是，在添加sigqueue节点的时候，队列当中已然有了该信号的sigqueue节点，则不添加&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2可靠信号的注册&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当进程所受到可靠信号时：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在sig位图中更改信号对应的比特位为1
不论之前sigqueue队列中是否存在该信号的sigqueue节点，都再次添加sigqueue节点到sigqueue队列当中去&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.信号的注销&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1非可靠信号的注销&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;信号对应的比特位从1置为0
将该信号的sigqueue节点从sigqueue队列当中进行出队操作&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2可靠信号的注销&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将该信号的sigqueue节点从sigqueue队列当中进行出队操作
需要判断sigqueue队列当中是否还有相同的sigqueue节点：①没有了：信号比特位从1置为0
②还有：不会更改sig位图中的比特位&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.信号阻塞&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1信号是怎样阻塞的？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2593984962406015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9ricY7CY550a2uKUobe3Kvk99FkDzl9fZ3Vd07lRU9kfcUKdN5UMYhniabBtiawOhjLxE5Y8dD5K6Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;信号的阻塞，并不会干扰信号的注册。信号能注册，但不能被立即处理，
将block位图中对应的信号比特位置为1，表示阻塞该信号
进程收到该信号，还是一如既往的注册
当进程进入到内核空间，准备返回用户空间的时候，调用do_signal函数，就不会立即去处理该信号了
当该信号不被阻塞后，就可以进行处理了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2sigprocmask&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数原型：int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
参数解释：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;how，该做什么样的操作&lt;br/&gt;SIG_BLOCK：设置信号为阻塞&lt;br/&gt;SIG_UNBLOCK：解除信号阻塞&lt;br/&gt;SIG_SETMASK：替换阻塞位图&lt;br/&gt;&lt;span&gt;set&lt;/span&gt;：用来设置阻塞位图&lt;br/&gt;SIG_BLOCK：设置某个信号为阻塞，block（&lt;span&gt;new&lt;/span&gt;） = block（old） | &lt;span&gt;set&lt;/span&gt;&lt;br/&gt;SIG_UNBLOCK：解除某个信号阻塞，block（&lt;span&gt;new&lt;/span&gt;）= block（old） &amp;amp; （~&lt;span&gt;set&lt;/span&gt;）&lt;br/&gt;SIG_SETMASK：替换阻塞位图，block（&lt;span&gt;new&lt;/span&gt;）= &lt;span&gt;set&lt;/span&gt;&lt;br/&gt;oldset：原来的阻塞位图&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例：下述例子，信号全部被阻塞，采用kill -9，将该进程结束掉&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;signcallback&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; signumber)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;change the signal %d\n&quot;&lt;/span&gt;,signumber);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;sigset_t&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;sigset_t&lt;/span&gt; oldset;&lt;br/&gt;  sigfillset(&amp;amp;&lt;span&gt;set&lt;/span&gt;);&lt;span&gt;//所有比特位全置为1，则信号全部会被阻塞&lt;/span&gt;&lt;br/&gt;  sigprocmask(SIG_BLOCK,&amp;amp;&lt;span&gt;set&lt;/span&gt;,&amp;amp;oldset);&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  {&lt;br/&gt;    sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：此时发送信号是不会有作用的，采用kill -9强杀掉&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18668831168831168&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9ricY7CY550a2uKUobe3KvkCnztEHmgg8e3z8ibefT5jAgh3FxE2UYn7ETBbRCNd8sLR1gJAdEFErg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.信号未决&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.1 未决概念&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际执行信号的处理动作称为信号递达（Delivery），信号从产生到递达之间的状态，称为信号未决（Pending）。进程可以选择阻塞（Block）某个信号。被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作。注意，阻塞和忽略是不同的，只要信号被阻塞就不会递达，而忽略是、在递达之后可选的一种处理动作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.2 sigpending&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数原型：int sigpending(sigset_t *set);
读取当前进程的未决信号集，通过set参数传出。调用成功返回0，出错返回-1.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;signalcallback&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; signumber)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;chang signumber %d\n&quot;&lt;/span&gt;,signumber);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;printsigset&lt;/span&gt;&lt;span&gt;(&lt;span&gt;sigset_t&lt;/span&gt; *&lt;span&gt;set&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(;i &amp;lt; &lt;span&gt;32&lt;/span&gt;;i++)&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(sigismember(&lt;span&gt;set&lt;/span&gt;,i))&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;putchar&lt;/span&gt;(&lt;span&gt;&#x27;1&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;putchar&lt;/span&gt;(&lt;span&gt;&#x27;0&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  signal(&lt;span&gt;2&lt;/span&gt;,signalcallback);&lt;br/&gt;  signal(&lt;span&gt;10&lt;/span&gt;,signalcallback);&lt;br/&gt;  &lt;span&gt;sigset_t&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;sigset_t&lt;/span&gt; oldset;&lt;br/&gt;  &lt;span&gt;sigset_t&lt;/span&gt; pending;&lt;br/&gt;  sigfillset(&amp;amp;&lt;span&gt;set&lt;/span&gt;);&lt;span&gt;//所有比特位全部置为1，则信号会全部被阻塞&lt;/span&gt;&lt;br/&gt;  sigprocmask(SIG_BLOCK,&amp;amp;&lt;span&gt;set&lt;/span&gt;,&amp;amp;oldset);&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  {&lt;br/&gt;    sigpending(&amp;amp;pending);&lt;br/&gt;    printsigset(&amp;amp;pending);&lt;br/&gt;    sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2464219041692595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9ricY7CY550a2uKUobe3KvkoVhriaIhSp1iaQ5UiaG3pyJH5ycDC2j47WlzaCyJZyWcFmFtAJygyyOxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1607&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.信号的处理方式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34615384615384615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9ricY7CY550a2uKUobe3KvkQxprCPDXUyJ6iasazPFrcibgPNeanIdb4xBr6U9cOBRI2xIgg0AtIuTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;每个信号都有两个标志位分别表示阻塞和未决，还有一个函数指针表示处理动作。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述例子中：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;SIGHUP信号未阻塞也未产生过，当它递达时执行默认处理动作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SIGINT信号产生过，但正在被阻塞，所以暂时不能递达。虽然它的处理动作是忽略，但在没有解除阻塞之前不能忽略这个信号，因为进程仍有机会改变处理动作之后再解除阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SIGQUIT信号未产生过，一旦产生SIGQUIT信号将被阻塞，它的处理动作是用户自定义函数sighandler。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.1signal函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该函数可以更改信号的处理动作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;(*&lt;span&gt;sighandler_t&lt;/span&gt;)&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;sighandler_t&lt;/span&gt; &lt;span&gt;signal&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; signum, &lt;span&gt;sighandler_t&lt;/span&gt; handler)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;参数解释：&lt;br/&gt;&lt;br/&gt;signum：更改的信号值&lt;br/&gt;handler：函数指针，要更改的动作是什么&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，该函数内部也调用了sigaction函数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.2sigaction函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读取和修改与指定信号相关联的处理动作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sigaction&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; signum, &lt;span&gt;const&lt;/span&gt; struct sigaction *act, struct sigaction *oldact)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数解释：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;signum：待更改的信号值&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;struct sigaction结构体：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt;     (*sa_handler)(&lt;span&gt;int&lt;/span&gt;);&lt;span&gt;//函数指针，保存了内核对信号的处理方式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt;     (*sa_sigaction)(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;siginfo_t&lt;/span&gt; *, &lt;span&gt;void&lt;/span&gt; *);&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sigset_t&lt;/span&gt;   sa_mask;&lt;span&gt;//保存的是当进程在处理信号的时候，收到的信号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt;        sa_flags;&lt;span&gt;//SA_SIGINFO，OS在处理信号的时候，调用的就是sa_sigaction函数指针当中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//保存的值0，在处理信号的时候，调用sa_handler保存的函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt;     (*sa_restorer)(&lt;span&gt;void&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;signcallback&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; signumber)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;change signumber %d\n&quot;&lt;/span&gt;,signumber);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;sigaction&lt;/span&gt; &lt;span&gt;act&lt;/span&gt;;&lt;/span&gt;&lt;span&gt;//act为入参&lt;/span&gt;&lt;br/&gt;  sigemptyset(&amp;amp;act.sa_mask);&lt;br/&gt;  act.sa_flags = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  act.sa_handler = signcallback;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;sigaction&lt;/span&gt; &lt;span&gt;oldact&lt;/span&gt;;&lt;/span&gt;&lt;span&gt;//oldact为出参&lt;/span&gt;&lt;br/&gt;  sigaction(&lt;span&gt;3&lt;/span&gt;,&amp;amp;act,&amp;amp;oldact);&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  {&lt;br/&gt;    sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24405705229793978&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9ricY7CY550a2uKUobe3KvkYpiaictLYiaTuSNyfvvZqnqgMCWPYsO622qUcgZmASHTibFiat7VfHlyK6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;631&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.3 自定义信号处理的流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44707520891364905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9ricY7CY550a2uKUobe3Kvkg2A2K58aelicsyqFbPOVj8ibPEq3TmJpaHt6trbwKDBM5KqzNscukuqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1436&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;task_struct&lt;/strong&gt;结构体中有一个&lt;strong&gt;struct sighand_struct&lt;/strong&gt;结构体。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;struct sighand_struct&lt;/strong&gt;结构体有一个&lt;strong&gt;struct k_sigaction action[_NSIG]&lt;/strong&gt;结构体数组。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该数组中，其中的&lt;strong&gt;_sighandler_t sa_handler&lt;/strong&gt;保存的是信号的处理方式，通过改变其指向，可以实现我们对自定义信号的处理。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.信号的捕捉&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.1信号捕捉的条件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这就称为信号捕捉。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.2信号捕捉流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7468193384223919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9ricY7CY550a2uKUobe3Kvkj53A1lsGWBYia4Oa5xhHqmK60a5m3dRSpPZcM3KTqum59oyBj11P8BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核态返回用户态会调用do_signal函数，两种情况：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;无信号：sys_return函数，返回用户态&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;有信号：先处理信号，信号返回，再调用do_signal函数
例：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;程序注册了SIGQUIT信号的处理函数sighandler。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当前正在执行main函数，这时发生中断或异常切换到内核态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在中断处理完毕后要返回用户态的main函数之前检查到有信号SIGQUIT递达。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核决定返回用户态后不是恢复main函数的上下文继续执行，而是执行sighandler函数， sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系，是两个独立的控制流程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.常用信号集操作函数&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sigemptyset&lt;/span&gt;&lt;span&gt;(&lt;span&gt;sigset_t&lt;/span&gt; *&lt;span&gt;set&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;：&lt;span&gt;//将比特位图全置为0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sigfillset&lt;/span&gt;&lt;span&gt;(&lt;span&gt;sigset_t&lt;/span&gt; *&lt;span&gt;set&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;span&gt;//将比特位图全置为1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sigaddset&lt;/span&gt;&lt;span&gt;(&lt;span&gt;sigset_t&lt;/span&gt; *&lt;span&gt;set&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; signum)&lt;/span&gt;&lt;/span&gt;;&lt;span&gt;//将该set位图，多少号信号置为1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sigdelset&lt;/span&gt;&lt;span&gt;(&lt;span&gt;sigset_t&lt;/span&gt; *&lt;span&gt;set&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; signum)&lt;/span&gt;&lt;/span&gt;;&lt;span&gt;//将该set位图，多少号信号置为0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sigismember&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;sigset_t&lt;/span&gt; *&lt;span&gt;set&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; signum)&lt;/span&gt;&lt;/span&gt;;&lt;span&gt;//信号signum是否是set位图中的信号&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.SIGCHLD信号&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该信号是子进程在结束是发送给父进程的信号，但是该信号的处理方式是默认处理的。父进程对子进程发送过来的SIGCHLD信号进行了忽略处理，就会导致子进程成为僵尸进程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以自定义该信号的处理方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;signcallback&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; signumber)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;change signal %d\n&quot;&lt;/span&gt;,signumber);&lt;br/&gt;  wait(&lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  signal(&lt;span&gt;17&lt;/span&gt;,signcallback);&lt;br/&gt;  &lt;span&gt;pid_t&lt;/span&gt; pid = fork();&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(pid &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  {&lt;br/&gt;    perror(&lt;span&gt;&quot;fork&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(pid == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;I am child\n&quot;&lt;/span&gt;);&lt;br/&gt;    sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;12&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;      sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指令查看后台：&lt;strong&gt;ps aux | grep ./fork&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11685625646328852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9ricY7CY550a2uKUobe3Kvk1HnrmYoqS0gcYfRtIrmkia7wfX8BB4zt4ycwkCAMM35AklKtEDX9N4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;967&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa78302f321d2e8611a0ab96f708d0af</guid>
<title>软件架构的 23 个基本原则</title>
<link>https://toutiao.io/k/hkkmk7g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;5. 单一职责（Single Responsibility）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;该原则的主要思想是限定软件系统的每个构建块只承担唯一的责任。无论构建块的作用域是什么，是插件、包、类、函数，甚至是变量，应该只有一个职责。这篇文章更深入的讨论了这一原则：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://medium.com/p/6b886f6d943e&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6. DRY（Don’t Repeat Yourself）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该原则旨在通过避免重复代码来消除冗余。如果存在针对某些行为的现有功能，则应该重复使用，而不是在多个实例中拷贝相同的代码片段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个知识片段在系统中都必须有单一、明确、权威的表示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;7. 开闭原则（Open-Closed）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;软件构件应该对扩展开放，对修改关闭。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一原理的简单描述首先是由Bertrand Meyer提出的。每次都需要修改的软件系统只会变得一团糟，并且这种混乱的程序很容易在每次修改时出现错误。每个新功能都应该最大限度的增加新代码，最小限度减少旧代码的更改，理想情况下对旧代码的更改为零。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;8. 持久化透明（Persistence Ignorance）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;持久化透明的理念是，代码应该不受任何数据库或持久性技术的影响。业务逻辑应该与任何技术无关。如果明天，有更好、更有效、更便宜的持久化技术，应该能够以不影响上层抽象的方式改变系统的这一部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;9. YAGNI&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;You ain’t gonna need it. 这一原则试图避免软件系统的过早优化。开发人员通常会在系统中过度设计一些东西，以期在将来的某个时候会有帮助，但这一时刻往往不会到来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;10. 童子军规则（Boy Scout Rule）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在离开的时候要让露营地比来的时候更干净。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的主要思想是，当开发时遇到反模式，要坚持重构代码。随着时间的推移，这会提高代码质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;11. 里氏替换原则（Liskov-Subsititution）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果对于每个类型为S的对象o1，都有一个类型为T的对象o2，这样对于用T定义的所有程序P，当o1取代o2时，P的行为不变，那么S就是T的子类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Barbara Liskov的这个定义可能听起来很混乱，但本质上这个原则简单易懂。如果重述上面的定义，该原则的意思是: 在使用继承时，继承的层次结构应该在功能和业务逻辑方面保持一致。子类应该是可以相互替换的，并且不能改变父类的行为。作为一个简单的例子，可以用“臭名昭著的正方形/矩形”问题。其中正方形不应该是矩形的子类型，因为这两个几何形状的高度和长度的定义是不同的（正方形的高度和长度是相等的，而矩形的高度和长度是不同的）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;12. 封装（Encapsulation）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;软件系统的不同构建块应该通过封装来限制外界对其组件的访问，可以通过在类范围内设置组件为私有或在插件范围内设置访问限制来实现（就Java而言），从而隐藏信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;13. 松耦合（Loose Coupling）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;软件架构中最重要的原则之一是松耦合，这一原则表明软件系统的依赖关系应该松散，系统的一部分发生变化，对其他部分的影响应该最小。松耦合可以通过依赖倒置、异步消息中间件、事件源等实现。下面的文章深入探讨了软件工程中不同形式的耦合：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://medium.com/p/4d5cf2b3e99e&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;14. 内聚（Cohesion）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内聚是指模块内的元素依赖的程度。某种意义上说，是对类的方法和数据以及该类所服务的某种统一目的或概念之间关系强度的度量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;构建高内聚的类是一种最佳实践，有利于实现单一责任原则、松耦合等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;15. 接口隔离（Interface Segregation）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接口隔离原则指出，不应强迫客户端依赖不使用的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应该明确的是，这个原则主要适用于静态类型的编程语言，如Java、C等。在像Python或Ruby这样的动态类型语言中，这个原则没有太大意义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以想象这样一种情况，我们的Income和Expense用例都依赖于支持这两种用例的业务逻辑功能。因此Income用例的很多依赖都和Expense用例相关，而Expense用例的依赖情况也有相同的问题。基于以上讨论，ISP违规情况如下：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>