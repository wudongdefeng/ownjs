<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>561618ac2464a271954f92fc0edeb096</guid>
<title>官宣: 阳了……</title>
<link>https://toutiao.io/k/cspnaqr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             defaultNoSetting&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;上周看着北京的朋友们陆陆续续阳了，还在几个群里拍着胸脯说要做钉子户，结果这周立马打脸。&lt;/p&gt;&lt;p&gt;周三老婆说有点不舒服，公司同组同事有阳了，我还没怎么在意，想着也许是天冷降温身体不适应吧。到了晚上她就有点低烧，不过感觉还好。&lt;/p&gt;&lt;p&gt;第二天周四，老婆在床上躺了一天，下午精神好点还看了部&amp;lt;独行月球&amp;gt;。我喉咙开始发痒，但因为本来就有咽炎，想着许是咽炎严重了也说不定。晚上给老婆测来抗原，两条杠，这下放心了😂。睡觉的时候她体温升高到了39，吃了粒布洛芬，辗转反侧一晚上没睡好。&lt;/p&gt;&lt;p&gt;周五起来我就觉得有点头痛，颈椎炎发作的感觉，但中午胃口还行，吃了十几只饺子。但到了快傍晚的时候，实在撑不住了，只能躺床上，测了抗原，一条杠，不过没多久就开始反胃，冲到厕所里吐了2、3回，把肚子给吐了个干干净净。晚上持续低烧，全身酸痛，一晚上没睡好。&lt;/p&gt;&lt;p&gt;周六两个人躺床上，主卧变成了隔离房间，门口放了两个小板凳用来传递东西，老人小孩都没事，在外面该干嘛干嘛。下午又测了下抗原，还是一条杠，看来我身体素质可以啊😎。到了晚上体温上升到了38.7，吃了布洛芬，睡眠比昨天倒是好了点，能睡着会儿了。&lt;/p&gt;&lt;p&gt;周日又是躺平的日子，全身酸痛乏力，体温始终保持在不超过38度的低烧范围，最近两天都没怎么吃东西，5个饺子，两顿粥，没胃口，也不觉得饿，基本上靠喝电解质水过日子。下午又测抗原，总算中队长了，这下放心了。&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.336405529953917&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9utHkjMdE0XY7bgtMmia0pS9S5tT9Uu5VYAT4o67ddQ1ajicJ5KSSD4IMekibohX0icEJv2DCh2A8bG0fgZcY7PzoA/640?wx_fmt=jpeg&quot; data-type=&quot;jpg&quot; data-w=&quot;3472&quot;/&gt;&lt;/section&gt;​&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;就算普通流感，发烧也很不好受，大家还是尽量做好防护，能晚点中就晚点中，尽量别一波中，这样中了可以有杨康照顾😂。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这周实在是没力气发技术文章了，抱歉抱歉，大家多注意身体。&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;10000&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9ce12e2caae22536e6780d5b14d07a80</guid>
<title>警惕 JDK8 UDP 和 Thread.interrupt 的 Bug</title>
<link>https://toutiao.io/k/a9culim</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线上业务在热点流量大的情况下（业务采用 Java 编程语言实现），单机偶发出现 Hystrix 熔断，接口无法提供服务。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoLEiakqDBLqaW0pN96MoNSTKoeFHLDq6BibyEWtZvyam8rP9icNS1CWvzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2850&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Hystrix circuit &lt;span class=&quot;code-snippet__keyword&quot;&gt;short&lt;/span&gt;-circuited and &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; OPEN&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;# 代表Hystrix在一个窗口时间内失败了N次，发生短路。短路时间默认为 5 秒，5秒之内拒绝所有的请求，之后开始运行。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11873840445269017&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoSJcUibVIDS69pzpkhtZOJMKmuicHvbcOkmFxmeKxwVwDEHuyQ00RicCtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1078&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;统计了一下 1 个小时内居然有 5 万多条。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最初怀疑依赖下游的某个 RPC 接口出现问题。但从监控来看，异常时间点多个 RPC 接口异常率都有所上升。所以考虑是自身单机存在什么问题，导致调用依赖的 &lt;span&gt;RPC &lt;/span&gt;接口失败，产生了大量的熔断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里还有很重要的一点：&lt;strong&gt;在单机出现问题第一时间，摘掉了流量，过半小时后恢复流量，依旧熔断无法恢复&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若摘掉流量后，静置一段时间放开流量服务恢复，证明可能是由于流量过载导致的问题，如 JVM 内存不够，GC 回收不过来，频繁 GC。这样的话流量掐掉后，GC 一段时间后内存够用，服务恢复正常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若摘掉流量后，静置一段时间放开流量服务依旧熔断。在单机出现问题的场景下，很&lt;/span&gt;&lt;span&gt;可能是 JVM 内部的问题（包括应用自身问题或者 JVM 的一些问题，如死锁）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;排查&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常排查这种自身问题可从几个方面入手：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU Load、使用率、内存使用率是否过高；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网卡出入速率是否有抖动，包括 TCP 重传；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;磁盘 IOPS 是否过高，导致一些 sys call 阻塞；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JVM 是否出现 STW 动作，包括不限于 GC、JIT 等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;是否有 OOM、StackOverflow、死锁等现象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码出现 Bug；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;虚拟化对应用进行 STW 动作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据这些逐一分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 监控CPU和内存如下图所示&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5964912280701754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoDAH7rrquhpKS0hpIe9HfM2Weas7Aia3xac4NhiboxK4FPn3qNawfJamw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2280&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CPU 有明显的抖动，内存使用率正常（18:30 断崖式下滑是对服务进行了上线，可忽略不管）。注意：问题发生在 19:00 以后。可以看到 CPU 在出问题时间段内有明显的波动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 查看监控网卡如下图所示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5964912280701754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoDAH7rrquhpKS0hpIe9HfM2Weas7Aia3xac4NhiboxK4FPn3qNawfJamw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2280&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 19:00 之后出问题的时间段网卡出入速率略有波动，可忽略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 查看磁盘 IOS 如下图所示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5784982935153583&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoAmiaam521xrvppn9GcLU8ia2Ua2OzFzV1yUryN0m4VvFHCEBB7Fe1lZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1172&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;磁盘 IOPS 虽然比较高，但 19:00 前后都比较平均。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 查看 gclog 如下图所示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2911944202266783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoFR8jwT83AdDk0C3efjyf21MGeAZ7fiaztU4JRfFvRdPcN1H9S95I89g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2294&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然 Young GC 比较频繁，但回收的比例还是比较大，耗时也不高。没有明显的其他原因导致 STW 占用时间长的迹象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 打印线程栈如下图所示&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7280606717226435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoKnulKYiamBMr1Ym3T6MT1h3IkrI0yJYmIT2Jg5slBh7pZ532sibXkCicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1846&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;jstack 打出的线程栈就很明显了，最下面直接显示了死锁！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6. Review了最近上线的代码，改动很小没有问题。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7. 由于打印线程栈出现死锁，问题很明显，不用排查虚拟化了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题很明显了，JVM 出现了死锁，导致 Hystirx 熔断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;从死锁的日志来看，似乎跟 DNS 相关。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;难道 Java 的 DNS 有啥 Bug？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;分析&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8485158648925282&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoSQzNzEcXHINGdKJY7uCJsjZtmskibAyTutAy7o36uNTNglia2gqibVf2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1954&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在死锁线程栈中很明显地标记出了 pool-486-thread-132 在等 0x00000006b77f2098 这把锁，&lt;/span&gt;&lt;span&gt;并且这把锁被 hstirx-*** 线程持有着。同时 hstirx-*** 在等待 0x00000006b77f2128 这把锁，并且这把锁被 pool-486-thread-132 线程持有着。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5717344753747323&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoT20DxQibc4syBdSwCOrria8FwLEKicrasQ2kepLKjYwgva3iaSj7MUeUmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1868&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这俩个线程栈中同时出现了 DNS 和 DatagramChannel 相关的类，证明死锁很大一部分原因是由 DNS 在发 UDP 包的情况下产生了死锁。我们知道死锁是俩个线程对相同临界区资源竞争时，加锁不当产生的。复习下死锁的四个必要条件：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;互斥条件&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;请求和保持条件&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：当进程因请求资源而阻塞时，对已获得的资源保持不放；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;不剥夺条件&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;环路等待条件&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在发生死锁时，必然存在一个进程–资源的环形链。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那我们使用的 DNS 为啥会出现这样的问题？&lt;strong&gt;难道是 JDK 或者是 dnsjava（我们使用了dnsjava）的 Bug？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;排查 Bug 的最好方法就是阅读源码，我们可以通过死锁的线程栈自底向上逐层跟踪代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24582104228121926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAofiaI9ByOKeLcck2GbhDLzwianoZEMSQcOlZB3cHnhECJ5HC26icicM0iaJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2034&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先看 histirx-*** 的死锁线程栈 ：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 从业务调用点开始，这里我们的业务向 BatchExecutor（公司内部封装的线程池操作）提交了线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0856353591160221&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAollgbIueDf5TVnYUw70A3sqYLywib4aZic1icJRFpickLeiaSogLCAiaiaxDcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1448&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 本质上调用 AbstractExecutorService.invokeAll 方法，该方法在线程池中的线程执行结束时，finally 会触发 FutureTask.cancel 方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.032258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoZJkwaYhfglic0s9vNRrA54ibiaC9sYEZkXApoThY1v240hu3ibVafWeOkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1364&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3268206039076377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAojt2fKqS6l1fLbPeUUoLNvhxNmPsV0GLicW0VqT9CiadyyEZm3xgWh8DA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 由于在调用 cancel 方法对 mayInterruptIfRunning 实参传递的是 true，所以会执行 Thread.interrupt 方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5874799357945425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoqHFg7SepKsPmcVPoBlExxLcfibQmDZ6qGC1iaWI0seSU4cSC6jqN4xHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1246&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. Thread.interrupt 会对 blockerlock 加锁，根据线程栈，我们看到 intterupt 后会执行 DatagramChannelImpl.implCloseSelectableChannel 方法关闭 UDP 链接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6200527704485488&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoSCjGbkKRrGMhzydDen9tCry1Yia3XuR56eFXtsa7z7ghY0uRaTiboOyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5. 而 implCloseSelectableChannel 方法要拿到 stateLock 的锁，根据线程栈，此时出现锁等待。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7291666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAo0tJ4F3NC6odZFWCgyEkmNhdrqvmG5zsVX8S7dC94QL2qrm6Kvr3Fag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1152&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再看 pool-486-thread-132 的死锁线程栈：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 这个线程栈比较长，直接从 at org.xbill.DNS.UDPClient.connect(UDPClient.java:107) 开始看。可以从包名看出，这是做 dnsjava 向 DNS server 发起 UDP 请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8138613861386138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAovics1gtT7ibf3Skdic1kmoZLBsg17ZHEDot5YPXn37ckevibkv8TYZdDXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2020&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. connect 方法 通过 DatagramChannel.connect 开启 UDP 连接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2465753424657534&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoFrI0m4VgnNuIwhQBLD78jNlQWvABevWMwVbW8nqj0W6KBMtFQgBf8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1022&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. &lt;/span&gt;&lt;span&gt;DatagramChannel.connect中会锁住readLock、writeLock、stateLock，即线程栈中的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;readLock locked &amp;lt;0x00000006b77f20f8&amp;gt; (a java.lang.Object)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;writeLock locked &amp;lt;0x00000006b77f2110&amp;gt; (a java.lang.Object)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;stateLock locked &amp;lt;0x00000006b77f2128&amp;gt; (a java.lang.Object)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并锁住 bloackingLock 即线程栈中的 locked &amp;lt;0x00000006b77f20e0&amp;gt; (a java.lang.Object)，&lt;/span&gt;&lt;span&gt;然后分配 Buffer 并执行 receive 方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8347613219094248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAolOzq4LufCzxWia5hguNfaicaTZIiaPB2b22ae1LNYYyDLc9CprI4dWKLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1634&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 receive 方法并根据线程栈逐层往下，recevie 方法 finally 最后会执行 end 方法。end 方法调用到最后实际上调用了 Thread.blockedOn，bockedOn 需要拿到 blockerLock 锁。此时这个锁 &amp;lt;0x00000006b77f2098&amp;gt; 正在被 histirx-*** 线程持有着。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16216216216216217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAodCLu68HyDyjIrlCyvJed6TQuJzcFg9aZGMSazD6m1qcbexXsrAG6hA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33860759493670883&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoqtweOB3MNUoAwOULAFEdxLf8NcgX1NaooSM4vAKskvqlSwWq9smKjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1264&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3207070707070707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoV5am5HukUVwCVXKBngu4v0DzTlNEOM5PGAFmwAXIgA4R2foKLhzJuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个链路看起来，似乎是由一个线程建立 UDP 并发包，一个线程对该线程进行 interrupt，就会产生死锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一点，也有人在 OpenJDK 的 Bug 列表中提出， JDK-8228765。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23902439024390243&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoO4XmxHgjSIT2gF5TwldaW7uM54wdKle9KQ1WH4TicAh01dibzCXCsviag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1230&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;那么线上为啥会出现 hystrix 线程对另外一个 HTTP 请求正在 DNS 解析线程进行 interrupt 的动作？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里简单说明下：我们的业务中会通过 BatchExecutor 提交一个异步的业务逻辑，并且超时时间为 300ms。若 300ms 以后未正常返回结果，自然会执行 finally。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18038528896672504&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAos3tP7zyeHLoppribvXiaSBxGmCrt1kvMKHsNL49Q1x7rvepO8lGrpZ7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于在异步业务逻辑比较复杂，&lt;strong&gt;请求多个 RPC 或其他资源时，&lt;/strong&gt;&lt;strong&gt;若一个请求超过 300ms，其他业务逻辑也会被超时终止，即被 interrupt。当有 DNS 时，便会触发这个 Bug。&lt;/strong&gt;业务流量大的情况下触发概率比较大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;复现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过上面的分析并参考 JDK-8228765，我们可以构造 2 个线程，一个发 UDP 包，一个对其进行 interrupt 操作，参考如下代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; java.net.InetSocketAddress;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; java.net.StandardSocketOptions;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; java.nio.channels.DatagramChannel;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.ThreadLocalRandom;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;UDPReceiver&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-snippet__type&quot;&gt;String&lt;/span&gt;[] args) &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;code-snippet__type&quot;&gt;IOException&lt;/span&gt;, &lt;span class=&quot;code-snippet__type&quot;&gt;InterruptedException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__type&quot;&gt;DatagramChannel&lt;/span&gt; receiver = &lt;span class=&quot;code-snippet__type&quot;&gt;DatagramChannel&lt;/span&gt;.&lt;span class=&quot;code-snippet__keyword&quot;&gt;open&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        receiver.setOption(&lt;span class=&quot;code-snippet__type&quot;&gt;StandardSocketOptions&lt;/span&gt;.&lt;span class=&quot;code-snippet__type&quot;&gt;SO_REUSEADDR&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        receiver.bind(new &lt;span class=&quot;code-snippet__type&quot;&gt;InetSocketAddress&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;8000&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__type&quot;&gt;UDPSender&lt;/span&gt; sender = new &lt;span class=&quot;code-snippet__type&quot;&gt;UDPSender&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        new &lt;span class=&quot;code-snippet__type&quot;&gt;Thread&lt;/span&gt;(sender).start(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__type&quot;&gt;System&lt;/span&gt;.out.&lt;span class=&quot;code-snippet__built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;before interrupt&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            sender.interruptThis(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__type&quot;&gt;System&lt;/span&gt;.out.&lt;span class=&quot;code-snippet__built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;after interrupt&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__type&quot;&gt;Thread&lt;/span&gt;.sleep(&lt;span class=&quot;code-snippet__type&quot;&gt;ThreadLocalRandom&lt;/span&gt;.current().nextLong(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; java.net.InetSocketAddress;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; java.net.StandardSocketOptions;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; java.nio.ByteBuffer;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; java.nio.channels.DatagramChannel;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.ThreadLocalRandom;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;UDPSender&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; InetSocketAddress target = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; InetSocketAddress(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;8000&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Thread thisThread;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;interruptThis&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; != thisThread) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            thisThread.interrupt(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        thisThread = Thread.currentThread(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                DatagramChannel sender = DatagramChannel.open();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                sender.setOption(StandardSocketOptions.SO_REUSEADDR, &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                sender.connect(target); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                System.out.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;sending...&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                sender.send(ByteBuffer.allocate(&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;).putInt(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;), target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                System.out.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;sending success...&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Thread.sleep(ThreadLocalRandom.current().nextLong(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示，在跑几轮后 before interrupt 的时候出现死锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6765578635014837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoEvC8hUXSgWa2JouxlpUPjKVYbaYwD1FkL56lgsXaumA1Pyg62bd75Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1348&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;打印线程栈，最后可看到死锁信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;jstack -l &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;pid&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7120181405895691&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoIluYlxKK3CqpJMxQMqFAUVUKqQI2uMfwibGQmmhaX4U6LbjSs1bZavg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1764&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程 Thread-0 等待的锁对象 0x000000076b0f9668 由主线程在执行 UDPSender.interruptThis 时锁住，即对 Thread-0 线程进行 interrupt。根据 Thread.interrupt 方法的描述，若当前线程处于 IO 方法阻塞时，通道会被关闭，会抛出 ClosedByInterruptException 异常并设置中断状态为 true。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49806451612903224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoGurNn4t8SpYyaicShtbl8sXHV7za3xuMLc8IR97LqMQEy5CzqgKLP5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1550&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;死锁的整个过程如下：先看 new Thread(sender).start() 即 Thread-0 的执行。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看死锁的线程栈调用链路执行情况，参考代码推导：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30303030303030304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoqicV482FQo5uk9Xfwc8gEjnTww1F7ibk77VvambicOBfxAHmg2ibUS3MCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1584&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. DatagramChannelImp l实现了AbstractInterruptibleChannel。在DatagramChannelImpl.send 方法中会拿到两把锁，注意其中一把为 stateLock，即线程中的 - locked &amp;lt;0x000000076b1e2be8&amp;gt; (a java.lang.Object)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6880189798339265&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoNZAxv9SCLb3Bcy5NKxzmFpjibYvGxxj3sf1PcibUFRjV9jCxibmt9klfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1686&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 在 write 方法中，可以看到调用 this.begin 方法，即 AbstracInterruptibleChannel.begin。在 IOUtil.write 真正发包完成后，会执行 finally 中的 this.end 方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.93646408839779&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoXtkLdfjSynlRzuAMRtYHU10YDYk9ibAdNHC5bgosibNZnoKWdxuuxrBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1448&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;AbstracInterruptibleChannel.begin 注册了收到 interrupt 后要执行的逻辑，注意这里，下面会用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6132686084142395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoagGVwnS695R5Js5tIzh2uMPPXibjrHwxp6y2aA3dFMxyC8EgQm3bdlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 在 AbstractInterruptibleChannel.end 方法中通过 blockedOn 方法标记 block 状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4413309982486865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAolb0X8GkXa5J0EB8ITSPjLtzIvwrlLMSicpFkBn58c3e7afltdWlN3LQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. blockedOn 会最终调到 Thread.blockedOn 方法，且实参为当前 Thread-0 线程。&lt;strong&gt;注意这里&lt;/strong&gt;，要拿到 blockerlock，即线程栈中的 - waiting to lock &amp;lt;0x000000076b0f9668&amp;gt; (a java.lang.Object)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37349397590361444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoNE0hGcicOgEibaXdw6veKzTBUjJdldr8M982Y8sHsvxIF9WrjrgSUJ9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再看 sender.interruptThis() 的执行：可以看死锁的线程栈调用链路执行情况，参考代码推导。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2688039457459926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoP9Xah2rQ3k30A7901CicMxxdZuogianFMR2AGWbBZ16TSTLs7OH4skTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1622&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3341614906832298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAo2VGMlyNfdXW0bBrFv6Zby2pMukCW1gRcib26fKDFZ78dElA3FSYcic2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1610&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 在 Thread.interrupt 方法中会调用 b.interrupt，注意这里会拿到 blokcerLock，即线程栈中的 - locked &amp;lt;0x000000076b0f9668&amp;gt; (a java.lang.Object)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40610687022900765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAofCc81eQUIicVHhNojXMwZXRJW1JsLAOW4UDKjnhicLicRT8wCbVpGDVUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1310&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. b.interrupt 会触发 AbstracInterruptibleChannel 在 begin 方法中实现的 interrupt 方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7114568599717115&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoOpPKZ65G0ibmM9lkBdIzpTfy3wCVz7PgiaD8AmbhGPBuclJfsw0jBOoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1414&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 通过 AbstracInterruptibleChannel.implCloseChannel 关闭通道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42788461538461536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAoUA8ichxpLITZKeJFGaeukibM0wW3nZ1RWT0DCUib4cwBXkU9fMDnGZoSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1248&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 在 DatagramChannelImpl.implCloseChannel 的实现中，要拿到 stateLock 这把锁。注意这里就是线程栈中的 - waiting to lock &amp;lt;0x000000076b1e2be8&amp;gt; (a java.lang.Object)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzn9AZ8V5s3ibMLoxKCGnpAokfZb04TWZRFC92icoQibOjBML8obUIAtHPiaN3mTfwdE6fBibPdrUzt6yQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的分析可以很明显的看出，主线程触发 Thread-0 的 interrupt 动作时，在执行 interupt 方法持有了 blockerLock 锁。关闭通道要拿 stateLock 锁，而 Thread-0 在发包时先拿到了 stateLock 锁，并且设置 block 状态时要拿 blockerLock 锁，此时出现死锁！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解决方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据 OpenJDK 的 Bug 列表中的说明 JDK-8228765 ，这个 &lt;span&gt;B&lt;/span&gt;&lt;span&gt;ug &lt;/span&gt;从 JDK-8039509 就开始有了，一直到 JDK13 才修复。所以，要么升级 &lt;span&gt;JDK &lt;/span&gt;到 13，要么死！我选择了死。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们项目中使用了 dnsjava，在 dnsjava的 Github上 issues#69 里也是有报这个 Bug的。另外在 logstash 中也有类似的问题 issues#117。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然如果选择了死，那就是遇到了重启服务器了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JVM 的 &lt;span&gt;Bu&lt;/span&gt;&lt;span&gt;g &lt;/span&gt;也很多，同时也很诡异，需要 &lt;strong&gt;仔细观察运行时状态&lt;/strong&gt; + &lt;strong&gt;阅读源码&lt;/strong&gt; 才能分析出原因，如果你不想分析原因，可以用 Google 搜搜看，很可能已经有了答案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;排查问题思路很重要，由于业务环境通常比较复杂，在大流量、大数据量的情况下会有各种千奇百怪的问题，需要有足够的耐心和较广的知识面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;62&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;转自：bd7xzz，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：blog.csdn.net/kid_2412/article/details/128125053&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651485965&amp;amp;idx=2&amp;amp;sn=2f40e8e8808cb70797293cef4702692c&amp;amp;chksm=bd251b728a52926433341d8ecd5200bc5baf63d6d3964befd6b12c112e09a148cdc93b225a00&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;JDK 的 3 个 bug&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;JDK 的 3 个 bug&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651485965&amp;amp;idx=2&amp;amp;sn=2f40e8e8808cb70797293cef4702692c&amp;amp;chksm=bd251b728a52926433341d8ecd5200bc5baf63d6d3964befd6b12c112e09a148cdc93b225a00&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;JDK 的 3 个 bug&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651514496&amp;amp;idx=1&amp;amp;sn=b233961c09e943cfb21dc69c19e2d8e7&amp;amp;chksm=bd258aff8a5203e94e0bcbd223d15a45931ca39e00c5c8e0f8a298491e4e0ee7a5af484acff7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;太极限了，JDK的这个BUG都能被我踩到&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;太极限了，JDK的这个BUG都能被我踩到&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651489163&amp;amp;idx=1&amp;amp;sn=e1cc38f81b31ef3f8cdb357e05843c96&amp;amp;chksm=bd25eff48a5266e2742271e3ca4702ec7567930d79f27cd721dceb12e2fbd9eb97ac65ac24f3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我的程序跑了60多小时，就是为了让你看一眼JDK的BUG导致的内存泄漏&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;我的程序跑了60多小时，就是为了让你看一眼JDK的BUG导致的内存泄漏&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9af075e20140322bed3d0b872827d368</guid>
<title>John Resig：Write Code Every Day</title>
<link>https://toutiao.io/k/18d36gh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;作为一名技术工作者，如何让自己的技术能力保持与时俱进？&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于这个主题，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Jo&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;hn Resig (&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;著名&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;库-- &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;jQuery&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的创始人,《精通 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;》作者)曾发表过一篇题为 “&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Write code Every Day&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;” 的优秀文章（&lt;/span&gt;&lt;span&gt;https://johnresig.com/blog/write-code-every-day&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/la8s6uvJibdQrLt52uPibwpYf3icqcwYKMJiaVGTibibxQDLzcTTU8KqqG0Cc0HCTLr87w0ML5e6qJvGT2iaenG2FqXMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下是在下译文， &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Enjoy&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;去年秋天，我在业余项目（&lt;span&gt;https://github.com/jeresig&lt;/span&gt;）上的工作陷入了困境：我没有取得足够的进展，而且我也找不到一种两全的方法：可以让我既不牺牲在可汗学院&lt;span&gt;（&lt;/span&gt;&lt;span&gt;https://www.khanacademy.org/&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;的工作，又可以完成更多&lt;span&gt;业余项目的&lt;/span&gt;工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我在做&lt;span&gt;业余项目&lt;/span&gt;的时候遇到了几个主要问题。我主要在周末工作，有时在工作日的晚上工作。事实表明，这种策略对我来说效果并不好。为了&lt;span&gt;能&lt;/span&gt;在周末尽可能多且高质量地&lt;span&gt;完成&lt;/span&gt;工作，我承受着巨大的压力(如果我做不到，就会觉得自己很失败)。这就是一个问题，因为我不能保证每个周末都是空闲的，也不能保证我可以连续两天整天整天都在写代码 (这意味着没有任何放松或&lt;span&gt;做其他有趣事情的机会&lt;/span&gt;)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有一个问题是，一周的时间间隔太长了，你会很容易忘记哪些是上一次正在做的任务，哪些是遗留下来的任务(即使你做了笔记，也很难一下子回忆起细节)。更不用说如果你错过一个周末，那么你的项目就两周没有进展了。这种持续数周的不作为可能是致命的 (我曾有许多&lt;span&gt;业余&lt;/span&gt;项目就是由于这样的注意力匮乏而夭折的)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Jennifer Dewalt&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 去年完成了一项令人难以置信的工作，她通过在180 天内创建180个网站来自学编程（&lt;/span&gt;&lt;span&gt;https://jenniferdewalt.com&lt;/span&gt;&lt;span&gt;），受&lt;span&gt;此&lt;/span&gt;启发，我觉得有必要尝试类似的策略: 每天都做我的&lt;span&gt;业余&lt;/span&gt;项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.33402489626556015&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdQrLt52uPibwpYf3icqcwYKMJVuVxK3icgc9DOQKcOeGuAyVEhbiaZBrSyb5TjBRcInOPXukDnXT6iaTGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Illustration by Steven Resig&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我决定为自己制定几条规则：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 我必须每天写代码。我可以写文档、博客文章或其他东西，但这必须是我写的代码之外的东西。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 它必须是有用的代码。不能调整缩进，不能重新格式化代码，如果可能的话，也不能重构。(所有这些事情都是允许的，但不能当天只干这些。)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 所有的代码必须在午夜之前写好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 代码必须是开源的，并放到 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Github&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中一些规&lt;/span&gt;&lt;span&gt;则是&lt;/span&gt;&lt;span&gt;随&lt;/span&gt;&lt;span&gt;意&lt;/span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;span&gt;严格来说，代码不需要在当天的午夜前写好，但我想避免熬夜写出漏洞百出的代码。&lt;/span&gt;&lt;span&gt;代码也不需要是开源的或在 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Github&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;上，这只是迫使我更加注意所写的代码 (会考虑到代码的可重用性，以及尽可能在早期就创建好一些模块)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到目前为止，我已经非常成功了，我已经连续工作了将近 20 周。我想把它写下来，因为它完全改变了我的编程习惯，同时对我的生活和心理也产生了显著的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.15352697095435686&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdQrLt52uPibwpYf3icqcwYKMJACXoHOeqTnWfg0F9PSHR29XAEc6EzzjWhibNKjp2k8y5t9I9GFiaVWHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于编程习惯的改变，发生了一些有趣的事情:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;写最低限度的可行代码&lt;/strong&gt;。我强迫自己每天至少写 30 分钟代码。(在短时间内写出有意义的代码真的不是一件容易得事情。) 有些工作日我还会多干一点（通常不超过一个小时），&lt;span&gt;有时&lt;/span&gt;周末我能工作一整天。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;编码成为一种习惯&lt;/strong&gt;。需要注意的是，我并不特别关心别人对上面 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Github&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 图表的看法。我觉得在这次尝试中最重要的收获是：这是你为自己的生活所做的改变，而不是为了让别人满意而做出的改变。这同样适用于任何形式的节食或锻炼：如果你不关心如何提升自己，那么你永远不会真正成功。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;抗击焦虑&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。在开始&lt;span&gt;这次&lt;/span&gt;&lt;span&gt;尝&lt;/span&gt;&lt;span&gt;试&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;之前，我经常会因为没有完成 &quot;足够的&quot;工作或没有取得 &quot;足够的&quot;进展而感到高度焦虑（&lt;span&gt;这两者都是相对无法量化的，因为&lt;/span&gt;我的&lt;span&gt;业余&lt;/span&gt;项目没有明确的截止日期）。我意识到，&lt;strong&gt;取得进展的感觉与取得实际进展一样重要。&lt;/strong&gt;这让我大开眼界。一旦我开始每天都能取得持续的进展，焦虑就开始消失了。&lt;span&gt;我能心平气和地对待每天&lt;/span&gt;&lt;span&gt;完成&lt;/span&gt;&lt;span&gt;的工作&lt;/span&gt;，不再有急于完成任何工作的&lt;span&gt;过度欲望&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于周末&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。在周末完成工作曾经对&lt;span&gt;推动项目&lt;span&gt;前进&lt;/span&gt;&lt;/span&gt;&lt;span&gt;至关重要&lt;/span&gt;（因为&lt;span&gt;通常情况下，&lt;/span&gt;&lt;span&gt;周末&lt;/span&gt;是我完成重要业余项目编码的唯一时间）。&lt;span&gt;而现在情况不太一样了——这是一件好事&lt;/span&gt;。如果把业余项目的事情累积下来到周末去完成，结果只会是让自己失望。我很少能完成所有我期望要做的工作，这就迫使我推掉一些我喜欢的周末活动（吃点心、参观博物馆、去公园、与我的伙伴共度时光等），&lt;span&gt;以便能完成更多的工作&lt;/span&gt;。我深切地感觉到，虽然&lt;span&gt;业余项&lt;/span&gt;真的很重要，但&lt;span&gt;它们不应&lt;/span&gt;&lt;span&gt;该把生活排&lt;/span&gt;&lt;span&gt;除在外&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;后台运行&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;每&lt;/span&gt;&lt;span&gt;天&lt;/span&gt;&lt;span&gt;写&lt;/span&gt;&lt;span&gt;业余项目&lt;/span&gt;&lt;span&gt;代码的一个有意思的副作用是，你当前的任务会经常在你的脑海中运行。&lt;/span&gt;&lt;span&gt;因此，当我去散步、洗澡或&lt;span&gt;从事其他&lt;/span&gt;&lt;span&gt;不需要动脑的活动时&lt;/span&gt;，&lt;span&gt;我就可以思考我之后该写什么代码，并找到解决之法&lt;/span&gt;。而&lt;/span&gt;&lt;span&gt;当我每周或每隔一周写一次代码时，这种情况就不会发生。&lt;/span&gt;&lt;span&gt;相反，时间会被消耗在思考其他任务上，或者常常被&lt;span&gt;业余&lt;/span&gt;&lt;span&gt;项目&lt;/span&gt;没有取得任何进展的焦虑所取代。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;上下文切换&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span/&gt;。再次投入一个&lt;span&gt;业&lt;/span&gt;&lt;span&gt;余&lt;/span&gt;&lt;span&gt;项目&lt;/span&gt;中时，总是会有一个上下文切换的成本。不幸的是，在做完&lt;span&gt;一个项目整&lt;/span&gt;&lt;span&gt;整一周之后，再回头思考另一个项目一周前的情况，这是极其困难的&lt;/span&gt;。而保持每天编码对此就很有帮助了，因为工作之间的时间间隔更短，&lt;span&gt;上下文切&lt;/span&gt;&lt;span&gt;换&lt;/span&gt;&lt;span&gt;的成本就小了，&lt;/span&gt;我也能更容易记住自己在做什么。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;工作平衡&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;span&gt;这种改变&lt;/span&gt;最重要的方面之一是可以学习如何更好地平衡工作/生活/业余项目。&lt;span&gt;知道每天都要为这个项目工作，所以我必须得更好地平衡我的时间&lt;/span&gt;。如果我被安排在晚上外出，直到很晚才回来，&lt;span&gt;那么我就需要在当天早些时候就做业余项目，然后再开始我在可汗学院的主要工作&lt;/span&gt;。此外，如果我还没有完成我的工作，&lt;span&gt;而且很晚了还在外面&lt;/span&gt;，&lt;span&gt;那么我就会赶紧回家完成它&lt;/span&gt;(而不是错过一天)。应该指出的是，&lt;span&gt;我发现我花在爱好上的时间更少了（如木版画）&lt;/span&gt;，但这是一个合理的权衡，&lt;span&gt;我需要接受&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;外在的感知&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;span&gt;这一切还有一个额外的好处&lt;/span&gt;，就是可以在外部传达这个新习惯。我的小伙伴知道我必须每天完成这项工作，因此有时必须围绕它来安排活动。当我说 &quot;是的，我们可以出去玩/看电影/等等，但稍后我&lt;span&gt;必须先&lt;/span&gt;完成我的编码工作&quot;，能得到&lt;span&gt;&lt;span&gt;小伙&lt;/span&gt;&lt;span&gt;伴&lt;/span&gt;的&lt;/span&gt;理解和采纳，这是相当令人欣慰的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;写了多少代码？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我很难相信在过去的几个月里我写了多少代码。我创建了几个新的网站，重写了一些框架，并创建了大量的新的 node 模块。&lt;span&gt;我写得太多了&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span/&gt;&lt;span&gt;有时会忘记我写的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;东西&lt;/span&gt;&lt;span&gt;——甚至几周前的工作都像是遥远的记忆&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;我对自己完成的工作量感到非常满意。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我认为这种习惯的改变是一个巨大的成功，并希望在我力所能及的情况下继续保持。&lt;/span&gt;&lt;span&gt;同时，我将尽我所能向其他希望完成大量业余项目的人推荐这一策略。&lt;/span&gt;&lt;span&gt;让我知道这个技巧是否对你有用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;—— &lt;/span&gt;&lt;span&gt;我非常想听到更多的轶事。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;这篇文章发在了 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Hacker News&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 上，更多对这篇文章的评论，请移步：&lt;/span&gt;&lt;span&gt;https://news.ycombinator.com/item?id=7568675&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;P.S. &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;看了一下作者近 3 年的 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Git&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 提交记录，真的是说到做到。越牛逼，越勤勉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2217343578485181&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/la8s6uvJibdQrLt52uPibwpYf3icqcwYKMJlibmNkh0wDuVuplW09DqMsrM5fKGtYWUYsAm4Hloc7aL6FdmviacbBUA/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1822&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22026431718061673&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/la8s6uvJibdQrLt52uPibwpYf3icqcwYKMJmB8XH6X6Cq5safyF4CUDXIJkHk6l8JULSN8TJGNTpxibiaKQYCp9A8vA/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1816&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.225414364640884&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/la8s6uvJibdQrLt52uPibwpYf3icqcwYKMJzHEialrl9pjdhQskP8yEdHiab6Vb8MsykBbyl27CJcq77QSTGHJLyDOQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1810&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3ff433ee2a82cc1b4916e744e2888443</guid>
<title>面试官问我Redis分布式锁踩坑，我一口气说了10个</title>
<link>https://toutiao.io/k/b4qnmjm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是&lt;code&gt;田螺&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发中，经常会碰到秒杀抢购等业务。为了避免并发请求造成的&lt;strong&gt;库存超卖&lt;/strong&gt;等问题，我们一般会用到&lt;code&gt;Redis&lt;/code&gt;分布式锁。但是使用&lt;code&gt;Redis&lt;/code&gt;分布式锁，很容易踩坑哦~ 本文田螺哥将给大家分析阐述，&lt;code&gt;Redis&lt;/code&gt;分布式锁的&lt;code&gt;10&lt;/code&gt;个坑~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2772232304900181&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpyfxib2vibKYpbqvANW02ue7aH0gfso6FEUFNiax38q3DOep19VjO5IiawGyQnubSoT8OHcCuNGhnIMMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2204&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 非原子操作（setnx + expire）&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一说到实现&lt;code&gt;Redis&lt;/code&gt;的分布式锁，很多小伙伴马上就会想到&lt;code&gt;setnx+ expire&lt;/code&gt;命令。也就是说，先用&lt;code&gt;setnx&lt;/code&gt;来抢锁，如果抢到之后，再用&lt;code&gt;expire&lt;/code&gt;给锁设置一个&lt;strong&gt;过期&lt;/strong&gt;时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;（jedis.setnx(lock_key,lock_value) == 1）{ //加锁&lt;br/&gt;    jedis.expire(lock_key，timeout）; //设置过期时间&lt;br/&gt;    doBusiness //业务逻辑处理&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块代码是&lt;strong&gt;有坑&lt;/strong&gt;的，因为&lt;code&gt;setnx&lt;/code&gt;和&lt;code&gt;expire&lt;/code&gt;两个命令是分开写的，并不是原子操作！如果刚要执行完&lt;code&gt;setnx&lt;/code&gt;加锁，正要执行&lt;code&gt;expire&lt;/code&gt;设置过期时间时，进程&lt;code&gt;crash&lt;/code&gt;或者要重启维护了，那么这个锁就“&lt;strong&gt;长生不老&lt;/strong&gt;”了，别的线程永远获取不到锁啦。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.被别的客户端请求覆盖（ setnx + value为过期时间）&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决：&lt;strong&gt;发生异常时，锁得不到释放的问题&lt;/strong&gt;。有小伙伴提出，可以把&lt;strong&gt;过期时间&lt;/strong&gt;放到&lt;code&gt;setnx&lt;/code&gt;的&lt;code&gt;value&lt;/code&gt;里面。如果加锁失败，再拿出&lt;code&gt;value&lt;/code&gt;值和当前系统时间校验一下是否过期即可。伪代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;long expireTime = System.currentTimeMillis() + timeout; //系统时间+设置的超时时间&lt;br/&gt;String expireTimeStr = String.valueOf(expireTime); //转化为String字符串&lt;br/&gt;&lt;br/&gt;// 如果当前锁不存在，返回加锁成功&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (jedis.setnx(lock_key, expireTimeStr) == 1) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;// 如果锁已经存在，获取锁的过期时间&lt;br/&gt;String oldExpireTimreStr = jedis.get(lock_key);&lt;br/&gt;&lt;br/&gt;// 如果获取到的老的预期过期时间，小于系统当前时间，表示已经过期了&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (oldExpireTimreStr != null &amp;amp;&amp;amp; Long.parseLong(oldExpireTimreStr) &amp;lt; System.currentTimeMillis()) {&lt;br/&gt;&lt;br/&gt;     //锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）&lt;br/&gt;    String oldValueStr = jedis.getSet(lock_key, expireTimeStr);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (oldValueStr != null &amp;amp;&amp;amp; oldValueStr.equals(oldExpireTimreStr)) {&lt;br/&gt;      //考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;        &lt;br/&gt;//其他情况，均返回加锁失败&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种实现的方案，也是有坑的：如果锁过期的时候，并发多个客户端同时请求过来，都执行&lt;code&gt;jedis.getSet()&lt;/code&gt;，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，&lt;strong&gt;可能被别的客户端覆盖&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 忘记设置过期时间&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前&lt;code&gt;review&lt;/code&gt;代码的时候，看到这样实现的分布式锁，&lt;strong&gt;伪代码&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;try{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(jedis.setnx(lock_key,lock_value) == 1){//加锁&lt;br/&gt;     doBusiness //业务逻辑处理&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; //加锁成功，处理完业务逻辑返回&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;; //加锁失败&lt;br/&gt;} finally {&lt;br/&gt;    unlock(lockKey);- //释放锁&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块有什么问题呢？是的，&lt;strong&gt;忘记设置过期时间了&lt;/strong&gt;。如果程序在运行期间，机器突然挂了，代码层面没有走到&lt;code&gt;finally&lt;/code&gt;代码块，即在宕机前，锁并没有被删除掉，这样的话，就没办法保证解锁，所以这里需要给&lt;code&gt;lockKey&lt;/code&gt;加一个过期时间。注意哈，使用分布式锁，&lt;strong&gt;一定要设置过期时间哈&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 业务处理完，忘记释放锁&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多小伙伴，会使用&lt;code&gt;Redis&lt;/code&gt;的&lt;code&gt;set&lt;/code&gt;指令扩展参数来实现分布式锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;set&lt;/span&gt;指令扩展参数：SET key value[EX seconds][PX milliseconds][NX|XX]&lt;br/&gt;&lt;br/&gt;- NX :表示key不存在的时候，才能&lt;span&gt;set&lt;/span&gt;成功，也即保证只有第一个客户端请求才能获得锁，&lt;br/&gt;  而其他客户端请求只能等其释放锁，才能获取。&lt;br/&gt;- EX seconds :设定key的过期时间，时间单位是秒。&lt;br/&gt;- PX milliseconds: 设定key的过期时间，单位为毫秒&lt;br/&gt;- XX: 仅当key存在时设置值&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小伙伴会写出如下伪代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime)==1){ //加锁&lt;br/&gt;   doBusiness //业务逻辑处理&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; //加锁成功，处理完业务逻辑返回&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;; //加锁失败&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块伪代码，初看觉得没啥问题，但是细想，不太对呀。因为&lt;strong&gt;忘记释放锁&lt;/strong&gt;了！如果每次加锁成功，都要&lt;strong&gt;等到超时时间才释放锁&lt;/strong&gt;，是会有问题的。这样程序不高效，应当每次处理完业务逻辑，&lt;strong&gt;都要释放锁&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;try{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime)==1){//加锁&lt;br/&gt;     doBusiness //业务逻辑处理&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; //加锁成功，处理完业务逻辑返回&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;; //加锁失败&lt;br/&gt;} finally {&lt;br/&gt;    unlock(lockKey);- //释放锁&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. B的锁被A给释放了&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下这块伪代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;try{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;,expireTime)==1){//加锁&lt;br/&gt;     doBusiness //业务逻辑处理&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; //加锁成功，处理完业务逻辑返回&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;; //加锁失败&lt;br/&gt;} finally {&lt;br/&gt;    unlock(lockKey); //释放锁&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家觉得会&lt;strong&gt;有哪些坑&lt;/strong&gt;呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;假设在这样的并发场景下：&lt;code&gt;A、B&lt;/code&gt;两个线程来尝试给Redis的key&lt;code&gt;lockKey&lt;/code&gt;加锁，&lt;code&gt;A&lt;/code&gt;线程先拿到锁（假如锁超时时间是&lt;code&gt;3&lt;/code&gt;秒后过期）。如果线程&lt;code&gt;A&lt;/code&gt;执行的业务逻辑很耗时，超过了&lt;code&gt;3&lt;/code&gt;秒还是没有执行完。这时候，&lt;code&gt;Redis&lt;/code&gt;会自动释放&lt;code&gt;lockKey&lt;/code&gt;锁。刚好这时，线程&lt;code&gt;B&lt;/code&gt;过来了，它就能抢到锁了，开始执行它的业务逻辑，恰好这时，线程&lt;code&gt;A&lt;/code&gt;执行完逻辑，去释放锁的时候，它就把&lt;code&gt;B&lt;/code&gt;的锁给释放掉了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确的方式应该是，在用&lt;code&gt;set&lt;/code&gt;扩展参数加锁时，放多一个这个线程请求的&lt;strong&gt;唯一标记&lt;/strong&gt;，比如&lt;code&gt;requestId&lt;/code&gt;，然后释放锁的时候，&lt;strong&gt;判断一下是不是刚刚的请求&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;try{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;,expireTime)==1){//加锁&lt;br/&gt;     doBusiness //业务逻辑处理&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; //加锁成功，处理完业务逻辑返回&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;; //加锁失败&lt;br/&gt;} finally {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (requestId.equals(jedis.get(lockKey))) { //判断一下是不是自己的requestId&lt;br/&gt;      unlock(lockKey);//释放锁&lt;br/&gt;    }   &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 释放锁时，不是原子性&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上的这块代码，还是有坑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;if&lt;/span&gt; (requestId.equals(jedis.get(lockKey))) { //判断一下是不是自己的requestId&lt;br/&gt;      unlock(lockKey);//释放锁&lt;br/&gt;    }   &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为判断是不是当前线程加的锁和释放锁&lt;strong&gt;不是一个原子操作&lt;/strong&gt;。如果调用&lt;code&gt;unlock(lockKey)&lt;/code&gt;释放锁的时候，锁已经过期，所以这把锁已经可能已经不属于当前客户端，会&lt;strong&gt;解除他人加的锁&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，这个坑就是：&lt;code&gt;判断和删除&lt;/code&gt;是两个操作，不是原子的，有一致性问题。&lt;code&gt;释放锁必须保证原子性&lt;/code&gt;，可以使用&lt;code&gt;Redis+Lua&lt;/code&gt;脚本来完成，类似&lt;code&gt;Lua&lt;/code&gt;脚本如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&#x27;get&#x27;&lt;/span&gt;,KEYS[1]) == ARGV[1] &lt;span&gt;then&lt;/span&gt; &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&#x27;del&#x27;&lt;/span&gt;,KEYS[1]) &lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; 0&lt;br/&gt;end;  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 锁过期释放，业务没执行完&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁后，如果超时了，&lt;code&gt;Redis&lt;/code&gt;会自动释放清除锁，&lt;strong&gt;这样有可能业务还没处理完，锁就提前释放了&lt;/strong&gt;。怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些小伙伴认为，稍微把锁过期时间设置长一些就可以啦。其实我们&lt;strong&gt;设想一下&lt;/strong&gt;，是否可以给获得锁的线程，&lt;strong&gt;开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前开源框架Redisson解决了这个问题。我们一起来看下&lt;code&gt;Redisson&lt;/code&gt;底层原理图吧：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.627633209417596&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpyfxib2vibKYpbqvANW02ue7aea1Nz6USPVr0h6NQXvl8uEfAlcbNCd1F0icZUcgZSibjmwWAWtDia9csw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1614&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要线程&lt;code&gt;一&lt;/code&gt;加锁成功，就会启动一个&lt;code&gt;watch dog&lt;/code&gt;看门狗，它是一个&lt;strong&gt;后台线程&lt;/strong&gt;，会每隔&lt;code&gt;10&lt;/code&gt;秒检查一下，如果线程一还持有锁，那么就会不断的延长锁&lt;code&gt;key&lt;/code&gt;的生存时间。因此，&lt;code&gt;Redisson&lt;/code&gt;就是使用&lt;code&gt;Redisson&lt;/code&gt;解决了&lt;strong&gt;锁过期释放，业务没执行完问题&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. Redis分布式锁和@transactional一起使用失效&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家看下这块伪代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Transactional&lt;br/&gt;public void updateDB(int lockKey) {&lt;br/&gt;  boolean lockFlag = redisLock.lock(lockKey);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!lockFlag) {&lt;br/&gt;    throw new RuntimeException(“请稍后再试”);&lt;br/&gt;  }&lt;br/&gt;   doBusiness //业务逻辑处理&lt;br/&gt;   redisLock.unlock(lockKey);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在事务中,使用了&lt;code&gt;Redis&lt;/code&gt;分布式锁.这个方法一旦执行,事务生效，接着就&lt;code&gt;Redis&lt;/code&gt;分布式锁生效，代码执行完后,先释放&lt;code&gt;Redis&lt;/code&gt;分布式锁,然后再提交事务数据，最后事务结束。在这个过程中,事务没有提交之前,分布式锁已经被释放，&lt;strong&gt;导致分布式锁失效&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;spring&lt;/code&gt;的&lt;code&gt;Aop&lt;/code&gt;，会在&lt;code&gt;updateDB&lt;/code&gt;方法之前开启事务，之后再加锁，当锁住的代码执行完成后，再提交事务，因此锁住的代码块执行是在事务之内执行的，可以推断在代码块执行完时，事务还未提交，锁已经被释放，此时其他线程拿到锁之后进行锁住的代码块，读取的库存数据不是最新的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确的实现方法,可以在&lt;code&gt;updateDB&lt;/code&gt;方法之前就&lt;strong&gt;上锁&lt;/strong&gt;，即还没有开事务之前就加锁，那么就可以保证线程的安全性.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.锁可重入&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面讨论的&lt;code&gt;Redis&lt;/code&gt;分布式锁，都是&lt;strong&gt;不可重入的&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所谓的&lt;strong&gt;不可重入&lt;/strong&gt;，就是当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，会阻塞，不可以再次获得锁。同一个人拿一个锁 ，只能拿一次不能同时拿&lt;code&gt;2&lt;/code&gt;次。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不可重入的分布式锁的话，是可以满足&lt;strong&gt;绝大多数的业务场景&lt;/strong&gt;。但是有时候一些业务场景，我们还是需要&lt;strong&gt;可重入的分布式锁&lt;/strong&gt;，大家实现分布式锁的过程中，&lt;strong&gt;需要注意一下&lt;/strong&gt;，你当前的业务场景是否需要可重入的分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Redis&lt;/code&gt;只要解决这两个问题，就能&lt;strong&gt;实现重入锁&lt;/strong&gt;了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;怎么保存当前持有的线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;怎么维护加锁次数（即重入了多少次）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现一个可重入的分布式锁，我们可以参考&lt;code&gt;JDK&lt;/code&gt;的&lt;code&gt;ReentrantLock&lt;/code&gt;的设计思想。实际上，可以直接使用&lt;code&gt;Redisson&lt;/code&gt;框架，它是支持可重入锁的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.Redis主从复制导致的坑&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;Redis&lt;/code&gt;分布式锁的话，要注意&lt;code&gt;Redis&lt;/code&gt;&lt;strong&gt;主从复制的坑&lt;/strong&gt;。因为&lt;code&gt;Redis&lt;/code&gt;一般都是集群部署的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3738229755178908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpyfxib2vibKYpbqvANW02ue7aetaWd92j4agK9Voic5fHkibicVNDUG7pibbibkJibB4AN7uCyTJ06LicUzK7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程一在&lt;code&gt;Redis&lt;/code&gt;的&lt;code&gt;master&lt;/code&gt;节点上拿到了锁，但是加锁的&lt;code&gt;key&lt;/code&gt;还没同步到&lt;code&gt;slave&lt;/code&gt;节点。恰好这时，&lt;code&gt;master&lt;/code&gt;节点发生故障，一个&lt;code&gt;slave&lt;/code&gt;节点就会升级为&lt;code&gt;master&lt;/code&gt;节点。线程二就可以获取同个&lt;code&gt;key&lt;/code&gt;的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，Redis作者 antirez提出一种高级的分布式锁算法：&lt;code&gt;Redlock&lt;/code&gt;。&lt;code&gt;Redlock&lt;/code&gt;核心思想是这样的：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;搞多个Redis master部署，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们假设当前有&lt;code&gt;5&lt;/code&gt;个&lt;code&gt;Redis master&lt;/code&gt;节点，在&lt;code&gt;5&lt;/code&gt;台服务器上面运行这些&lt;code&gt;Redis&lt;/code&gt;实例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpyfxib2vibKYpbqvANW02ue7amhuNrszCEVQtqjOEO01lKY9PcvtAFu5Mg7RheshKQ2PWaAHOu3F1IA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedLock的实现步骤如下:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取当前时间，以毫秒为单位。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按顺序向&lt;code&gt;5&lt;/code&gt;个&lt;code&gt;master&lt;/code&gt;节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为&lt;code&gt;10&lt;/code&gt;秒，则超时时间一般在&lt;code&gt;5-50&lt;/code&gt;毫秒之间,我们就假设超时时间是&lt;code&gt;50ms&lt;/code&gt;吧）。如果超时，跳过该&lt;code&gt;master&lt;/code&gt;节点，尽快去尝试下一个&lt;code&gt;master&lt;/code&gt;节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端使用当前时间减去开始获取锁时间（即步骤&lt;code&gt;1&lt;/code&gt;记录的时间），得到获取锁使用的时间。当且仅当超过一半（&lt;code&gt;N/2+1&lt;/code&gt;，这里是&lt;code&gt;5/2+1=3&lt;/code&gt;个节点）的&lt;code&gt;Redis master&lt;/code&gt;节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，&lt;code&gt;10s&amp;gt; 30ms+40ms+50ms+4m0s+50ms&lt;/code&gt;）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果取到了锁，&lt;code&gt;key&lt;/code&gt;的真正有效时间就变啦，需要减去获取锁所使用的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果获取锁失败（没有在至少&lt;code&gt;N/2+1个master&lt;/code&gt;实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的&lt;code&gt;master&lt;/code&gt;节点上解锁（即便有些&lt;code&gt;master&lt;/code&gt;节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简化下步骤就是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;按顺序向5个master节点请求加锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据设置的超时时间来判断，是不是要跳过该master节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果获取锁失败，解锁！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考与感谢&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Redis分布式锁失效的场景&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;redis分布式锁-可重入锁&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Redis分布式锁失效的场景: &lt;em&gt;https://blog.csdn.net/he247052163/article/details/119413877&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;redis分布式锁-可重入锁: &lt;em&gt;https://www.cnblogs.com/x-kq/p/14801527.html&lt;/em&gt;&lt;span/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>15d9ddd72c2b888e08cf510b610c5e24</guid>
<title>你的团队是王者还是青铜（下）</title>
<link>https://toutiao.io/k/zbco7qx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;p&gt;我们接着&lt;a href=&quot;https://insights.thoughtworks.cn/how-to-efficiently-manage-a-development-team-1/&quot; title=&quot;上篇&quot;&gt;上篇&lt;/a&gt;继续聊。&lt;/p&gt;
&lt;h2&gt;问题4：谁动了团队的时间？如果重来一个迭代，你有7*40个小时的投资，你要如何决策团队的工作安排？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;“小溪，一会约开卡；小溪，我这有个问题；小溪，一会约验收......”&lt;br/&gt;
“龙哥，第三方集成那边临时有个会议，需要来沟通一下；龙哥，客户那里有个代码规范变化了，你来看一眼；龙哥，API设计的不对；龙哥，日志找不到了......”&lt;br/&gt;
“阿泰，七哥，早上新开的卡都先别做了，有另外一个feature进来”&lt;br/&gt;
“小波（刚加入团队2周），需要你去另一个团队”&lt;br/&gt;
“刚打开微信准备回复一个消息，看到之前同事的消息又顺手处理一下，一封邮件从屏幕上弹了出来，又顺手点开”&lt;br/&gt;
。。。。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.amazon.com/Agile-Culture-Leading-through-Ownership/dp/0321940148&quot;&gt;“公司特别热衷于保护，保护了那么多的东西，却总是没能护住最脆弱也最稀有的东西：员工的时间和注意力...，这是我们最稀缺的资源”  &lt;/a&gt;。而在Thoughtworks，每位项目人员的工作时间也是对客户的承诺，是我们作为团队最重要的资产。&lt;/p&gt;
&lt;p&gt;那么，作为团队的Leader你是否计算过团队成员的时间投资成本，你是否可以保护好每位项目人员工作时间的合理投资？&lt;/p&gt;
&lt;p&gt;我观察到主要有以下几个反模式：&lt;/p&gt;
&lt;h3&gt;1. 团队成员经常被未计划的事务打扰&lt;/h3&gt;
&lt;p&gt;大多数程序员在写代码时都有一个体验，那就是一旦打开IDE，开始写代码后，就可以很快进入心流的状态，思路全是代码、测试，编写逻辑，方法名入参出参等等，&lt;/p&gt;
&lt;p&gt;这个时候的大脑会很兴奋，一直在忙碌地计算着，好不容易代码看懂，也弄清逻辑了，马上测试就要通过了。突然有同事找你问个问题，或者PM来问你进度，或者说临时有个外部会议，临时任务等等。&lt;/p&gt;
&lt;p&gt;等你再回来的时候，就发现“完了芭比Q了“。咦，我刚才做到哪里了，脑子出现短暂的空白。而要想再回到原来写代码的地方，就需要一段时间来调取之前的记忆。如果经常被打断，效率和工作体验都会大打折扣。&lt;/p&gt;
&lt;p&gt;漫画《&lt;a href=&quot;http://laughyouth.com/darao/&quot;&gt;当一个程序员一天被打扰 10 次，后果很惊人&lt;/a&gt;》里面就有这样的分享：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个程序员被打搅后，他需要10-15分钟的时间才能重新恢复到之前的编程状态。&lt;/li&gt;
&lt;li&gt;当修改一个程序函数时被打搅，只有十分之一的程序员能在一分钟内回到之前的思路。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实，这背后的逻辑就在于任务切换是需要成本的。小到写代码，大到团队。频繁的切换工作上下文，就会消耗大量的时间在切换上而非专注地完成任务。&lt;/p&gt;
&lt;p&gt;而最讨厌的是，这些切换成本并不容易显性地被表达，到站会的时候，你可能会发现，好像也没有什么阻碍，但进度并没有按预期进行。&lt;/p&gt;
&lt;p&gt;如果团队频繁出现这样的状况，这样的“暗时间”越多，整体的效率就会越差，团队成员的体验和工作状态也会受到影响。&lt;/p&gt;
&lt;p&gt;如果你想要一个低效的团队，那么随时打扰、调整计划，无目的的任务安排，你一定会成功。而作为投资人的你，无疑是失败的。&lt;/p&gt;
&lt;h3&gt;2. 团队一天的时间经常被切割的很小&lt;/h3&gt;
&lt;p&gt;切分60分钟有很多方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1*60&lt;/li&gt;
&lt;li&gt;2*30&lt;/li&gt;
&lt;li&gt;4*15&lt;/li&gt;
&lt;li&gt;25+10+5+5+5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;《&lt;a href=&quot;https://book.douban.com/subject/35135787//&quot;&gt;重来3&lt;/a&gt;》用一个数学题形象地展示了时间的切分策略给效率带来的影响。上面的算式结构都是60，可是效果却完全不同，质量也完全不同。&lt;/p&gt;
&lt;p&gt;如果个人一天的时间被切分成这样，很多都是零碎时间也很难说可以做出有效的思考和有质量的工作，而如果你的团队大多数人的时间也是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;9:15 站会，&lt;/li&gt;
&lt;li&gt;10点IPM&lt;/li&gt;
&lt;li&gt;11点测试策略讨论&lt;/li&gt;
&lt;li&gt;3点Retro&lt;/li&gt;
&lt;li&gt;5点Code Review&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样被切分的零碎时间片段，如何能有高效的产出。&lt;/p&gt;
&lt;h3&gt;3. 多任务处理，团队认知负荷过载&lt;/h3&gt;
&lt;p&gt;虽然多任务处理是职场人士需要掌握的一种能力，但在一个迭代内，多种任务并行处理无疑是增加团队的认知负担，想象一下如果超过6个特性在一个迭代内出现，对团队的消耗是什么？忙乱的假象，以及不必要的团队认知负荷。&lt;/p&gt;
&lt;p&gt;对于一个5-7人的Scrum团队来讲，这个迭代基本就是包干到户。因为，一旦一个团队整体认知负荷过载，团队就无法像一个单元一样运转，每个人都在试图努力完成个体任务，却无法关心是否能给团队带来最大的收益。&lt;/p&gt;
&lt;p&gt;通常在一个迭代里有超过3个复杂领域的特性开发，就需要重新复盘你的迭代计划和团队边界的设计。&lt;/p&gt;
&lt;h3&gt;4. 前后端联调的集体内耗&lt;/h3&gt;
&lt;p&gt;我们都知道，没做完的事情也会在大脑中留下一个隐藏的进程，时不时蹦出来，打断你正在做的事情。&lt;/p&gt;
&lt;p&gt;在”前后端分离“的交付团队中，最常见的是前端开发完成等待后端的例子。前端已经工作在下一张故事卡，但这时候未完成的卡就会像后台的进程一样在工作，站会的时候还会被重新激活。&lt;/p&gt;
&lt;p&gt;这件未完工件（WIP，Work in Progress）不仅引起QA的关注，PM、BA其它角色都在关注它的状态。什么时候可以联调，什么时候可以被验收？这带来的是一种无意识的集体内耗。&lt;/p&gt;
&lt;p&gt;WIP越多，被动的等待越多，这种无意识的内耗就越多。&lt;/p&gt;
&lt;h3&gt;5.  救火模式在工作，总在做紧急的事情&lt;/h3&gt;
&lt;p&gt;总是点火再救火的事后补偿模式。比如团队突然发现方案的漏洞，很多已知问题（比如技术风险）但没有去思考如何解决，结果被问题赶着跑，进入了负向循环的圈里。&lt;/p&gt;
&lt;h3&gt;怎么办&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;敏捷团队谚语：不能搞定事情保护团队，为团队扫清障碍的Scrum Master不是好PM。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;团队的时间和注意力就像客户和团队的投资一样，有成本有收益，需要有合理的投资策略才能取得成功。如果团队无法在迭代的窗口内专注工作，又如何能要求他们给出高质量的工作。&lt;/p&gt;
&lt;p&gt;那，怎么办呢？&lt;/p&gt;
&lt;p&gt;作为手握这么多资产的你，需要向团队和客户交出合理的答卷。幸运的是，不论《&lt;a href=&quot;https://m.douban.com/book/subject/5325618/&quot;&gt;高效能人士的七个习惯&lt;/a&gt;》，还是《&lt;a href=&quot;https://e.jd.com/30189634.html&quot;&gt;卓有成效的个人管理者&lt;/a&gt;》等个人效能的书，都已经给出了很多提高效能和时间管理策略。而这些放到团队这个有机的生命体上同样适用。&lt;/p&gt;
&lt;p&gt;这里分享几个tips：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 主动规划，建立内外规律的沟通计划，约定时间窗口，有效保证团队的大块工作时间和工作习惯&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个应对碎片化工作最好的习惯，就是主动规划工作任务和时间。对于团队也是一样，需要主动的规划，建立有序的内外沟通计划，避免被别人的安排打乱了你的计划，这样提升了团队的抗干扰能力和效率的同时，也提升了更大范围组织的协同效率。如下图示例：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/how-to-efficiently-manage-a-development-team-2-1.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/how-to-efficiently-manage-a-development-team-2-1-1024x545.png&quot; alt=&quot;团队时间规划&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从站会开始安排团队的一天&lt;/li&gt;
&lt;li&gt;Code Review尽量安排在一天的结束前&lt;/li&gt;
&lt;li&gt;为BA/QA/Dev角色协作的任务建立规律的时间段，如用户故事的开卡验收尽量放在下午的开始&lt;/li&gt;
&lt;li&gt;为必要的外部干系人的沟通预留时间（比如PO的相关计划会议和Showcase验收会议)&lt;/li&gt;
&lt;li&gt;和第三方集成或沟通会议要么是上午要么是开始的时候&lt;/li&gt;
&lt;li&gt;为迭代的几大集体会议预留时间段，且保持规律的节奏。如果一周一个迭代，那么周二可以开始新的迭代，下午进行IPM/技术方案共识的时间，周一下午是本迭代的retro时间。&lt;/li&gt;
&lt;li&gt;为团队的集体学习留足时间&lt;/li&gt;
&lt;li&gt;为团队迭代关键任务（比如最后的冲刺发布）预留时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;约定这些时间的时候都应遵循以下原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量给所有角色规划可以专注工作的大块时间&lt;/li&gt;
&lt;li&gt;尽量放在一个周期的开始和结束&lt;/li&gt;
&lt;li&gt;尽量保持不变的规律和节奏对外建立简单的沟通规律&lt;/li&gt;
&lt;li&gt;与团队约定，并让所有相关人看到并遵循&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于一个敏捷团队来讲，变是唯一不变的东西，上述这样的规划也并不是一成不变的，这样的建议更多的是可以保证团队中明确的协作任务可以被有序地执行，以保障大部分的时间和注意力可以是高效的。&lt;/p&gt;
&lt;p&gt;善于规划的人胜，善于规划的团队也定能保持专注和高效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 管理团队的认知负荷，约束团队的认知边界与职责，创造心流体验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;认知负荷在早期的项目管理中很少被提及，但是随着知识工作者的出现，团队的认知负荷成为越来越多决策的重要要素之一。对于一个Scrum团队的建议是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量维持且有意识去维持较小的规模（5-8人）&lt;/li&gt;
&lt;li&gt;同一迭代不要超过3个复杂领域的特性开发&lt;/li&gt;
&lt;li&gt;人员尽量变动不要超过20%&lt;/li&gt;
&lt;li&gt;保持稳定的交付节奏，即使偶尔加班也不要连轴。因为通常连轴的工作量和压力容易影响交付，以及长期的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 培养和赋能团队要事第一的习惯，与团队共识哪些事情是团队第一优先级的事情，哪些是不重要的、无价值的可以不做，哪些能工具化或者委托团队外的他人代办&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要将团队的迭代任务，高优先级的任务，识别的风险按照紧急重要的时间四象限进行排列，并可视化，建立处理流程，确保团队将时间和注意力放在第一优先级的任务上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 制定定期的风险Review会议，提前处理或规避风险，防止风险变成突然的Surprise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 屏蔽不需要的变化，让不得不发生的变化有序地发生&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多时候的变化是不可避免的，也很多时候有些无序的干扰。团队Leader一个很重要的工作就是扮演好团队的干扰过滤器，对于无序的干扰和任务安排，需要有明确果断的处理措施，避免再次发生。尤其在迭代冲刺的时候，不要让外界的沟通随意侵入我们的团队，让我们的Dev变成客服和PO小秘书，让我们的交付节奏受阻。尤其是一些小的变化就有可能导致团队指数级的影响和成本丧失。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;坦诚讲，让开发保持聚焦避免被打扰是PM赢得项目人员尊重的重要Credit之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为团队Leader的你，需要保护好团队最重要的东西：时间和注意力，有策略的管理人员变动、任务变动、工作打扰、多种任务并行开发、前后端联调、等待浪费、上下文切换这些暗时间的消耗；主动为团队构建内外的沟通计划和要务优先的行为习惯，保持良好的认知边界，做好干扰屏蔽器避免无谓的打扰，而这些看似细微的选择和习惯就会给团队带来不一样的投资回报。&lt;/p&gt;
&lt;p&gt;善于进行规划的人，可以无形中比别人多出许多时间。团队管理也是一样，可以让团队成员间减少过多”暗时间“的消耗。这不仅是对团队的交代，也是为客户提供服务的专业行为和态度。&lt;/p&gt;
&lt;p&gt;那么，如果重来一个迭代，你的团队有7个人，一个迭代两个周，总共2&lt;em&gt;40&lt;/em&gt;7的工作时间，你又会如何制定投资规划呢？&lt;/p&gt;
&lt;h2&gt;问题5：团队的关系有多远，信任的电量还剩多少？如果用1-10分的尺子来衡量，你们团队是几分？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/how-to-efficiently-manage-a-development-team-2-2.jpg&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/how-to-efficiently-manage-a-development-team-2-2-1024x768.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;
（图片来源：&lt;a href=&quot;https://unsplash.com/photos/CDoKLQeUHyk&quot;&gt;https://unsplash.com/photos/CDoKLQeUHyk&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;人脑有两个神经特质可以让我们与其它人群建立信任并协作。这种信任关系可以影响人的脑活动和能量状态，激发渴望，可以对人的行为起到非常强的杠杆作用。&lt;/p&gt;
&lt;p&gt;信任是将一群人从团伙变成团队的前提，是团队高效协作不可或缺的基础。不管是《团队协作的五种障碍》还是《&lt;a href=&quot;https://www.amazon.cn/dp/B007H4NQ26&quot;&gt;管理3.0 培养和提升敏捷领导力&lt;/a&gt;》、《&lt;a href=&quot;https://e.jd.com/30340367.html&quot;&gt;敏捷革命&lt;/a&gt;》这些经典书籍里都提到了信任关系对于构建敏捷团队的重要性。&lt;/p&gt;
&lt;p&gt;我想分享另外一本书《&lt;a href=&quot;https://www.amazon.com/Agile-Culture-Leading-through-Ownership/dp/0321940148&quot;&gt;The Agile Culture: Leading through Trust and Ownership &lt;/a&gt;》中的信任-责任模型，谈谈我对敏捷团队的信任和 Ownership 的理解，以及作为新Leader如何把脉和构建这样的关系。&lt;/p&gt;
&lt;h3&gt;1. 认识TRUST-OWNERSHIP MODEL&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/how-to-efficiently-manage-a-development-team-2-3.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/how-to-efficiently-manage-a-development-team-2-3-1024x742.png&quot; alt=&quot;TRUST-OWNERSHIP MODEL&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;敏捷文化的核心或者源泉是对团队的”信任和Ownership“，团队的每个人知道项目想要取得的结果，并对结果肩负责任，它们是团队活力和创新的基础，也是高绩效的基础。&lt;/p&gt;
&lt;p&gt;只有信任不放权并不能促成这样的变化，必须依靠信任和Ownership的珠联璧合才可以释放团队的潜力，做出改变迈向高效。团队从左下象限向右上象限走得越高，越容易获得更大的成就和价值。&lt;/p&gt;
&lt;p&gt;图中的纵轴，指Leader以及公司流程表现出来对团队的信任程度。&lt;/p&gt;
&lt;p&gt;信任越低对团队的控制越高，流程、跟踪、治理、控制、审查、报告、汇报、申请许可、繁杂的审批流程这些微管理手段会越来越多；信任越高对团队的赋能就越高，只存在轻量且必要的流程协助团队完成任务。团队懂得项目的重要性，致力于为客户交付价值，信守承诺，优化现有过程，持续改进取得成绩。&lt;/p&gt;
&lt;p&gt;横轴，指团队对项目和公司所做出的的承诺以及表现出来的 Ownership 。&lt;/p&gt;
&lt;p&gt;Ownership 越高，团队的承诺也越高，团队成员会尽全力完成团队共同的目标；反之，Ownership越低，则承诺越低，绩效就越差：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;”我只完成领导安排的任务“&lt;/li&gt;
&lt;li&gt;”我是老板我知道该做什么“&lt;/li&gt;
&lt;li&gt;”严格规定团队做什么如何做“&lt;/li&gt;
&lt;li&gt;”替团队做重大决定“&lt;/li&gt;
&lt;li&gt;”对问题保持沉默“&lt;/li&gt;
&lt;li&gt;”出了问题就抱怨其他人“&lt;/li&gt;
&lt;li&gt;”成不了交付不了与我何干“&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这也是命令和控制象限中团队的常见行为特征，可能因为过往的失败或者所处公司发展的不同阶段以及文化的影响，最终营造了一个互相抱怨的环境，而非共同努力，共同面对，一起克服困难。这样团队的士气也会受影响，项目延迟交付，效率低下是常见问题。&lt;/p&gt;
&lt;p&gt;看到这里，你可以先试问一下自己是否有如下的行为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有问过团队某件事情可否能做到之前，就要求承诺一个某日之前的Deadline&lt;/li&gt;
&lt;li&gt;没有和团队讨论或考虑其它可行的办法之前，就要求团队承诺”按我说的做“&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些看起来简单的行为，团队会马上意识到不信任，士气低迷将由此而生，就这样形成了团队不可见的隐性冲突。&lt;/p&gt;
&lt;p&gt;图中，左上的失败象限指领导完全信任团队但团队并不在乎所做的事情，对结果没有责任，做坏了做好了和我无关，没有绩效。团队处于失败象限，领导就会担心团队不作为而加强控制，或换人或拆团队或收回决策权等，快速地转向命令与控制。&lt;/p&gt;
&lt;p&gt;右下的冲突象限则是因为团队之间、团队与Leader之间的信任几乎为零，互不认可。团队处于冲突状态，要么冲突激化造成失败，要么沉默不发言，而苟于领导的安排。在这种状态下，停留越长伤害越大，对团队和成果都是如此。而Leader要么调整资源重建团队信任，要么团队放弃，让领导收回所有权，进入强命令与控制。&lt;/p&gt;
&lt;h3&gt;2. 把脉你的团队现状&lt;/h3&gt;
&lt;p&gt;那么，在了解了TRUST-Ownership Model之后，你和你的团队处在哪个象限？团队的信任电量和Ownership还剩多少？如果用1-10分的尺子来衡量，你们团队是几分？&lt;/p&gt;
&lt;p&gt;这里一并也分享以下问题帮你和你的团队进行分析，书中有详细的信任-责任的评估表格，若有需要可以参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否有成员连续几天在站会上说“马上就做完了”&lt;/li&gt;
&lt;li&gt;是否有成员在不打招呼的情况下直接把他人刚提交的代码删了重写&lt;/li&gt;
&lt;li&gt;大家在开会时都会建言献策吗？还是一言堂？&lt;/li&gt;
&lt;li&gt;是否有成员在会议讨论中（比如Retro/IPM）全程路人甲，一言不发&lt;/li&gt;
&lt;li&gt;大家是否敢于暴露问题？是否敢于承认错误？&lt;/li&gt;
&lt;li&gt;是否可以在团队中放心地谈论自己的弱点吗？&lt;/li&gt;
&lt;li&gt;大家彼此间互相了解吗？每位成员在沟通时会相互尊重吗（尤其在重要时刻）？&lt;/li&gt;
&lt;li&gt;对于其他成员的困难，大家是积极伸手相助，献言献策，还是默不作声，漠然视之？&lt;/li&gt;
&lt;li&gt;是否有成员推卸责任，抱怨他人的行为导致了自己的过失，甚至诬陷他人&lt;/li&gt;
&lt;li&gt;大家是否能轻松交流想法，给同事结构化的反馈？&lt;/li&gt;
&lt;li&gt;是否总有各种议论和冲突&lt;/li&gt;
&lt;li&gt;工作只是走过场，不分配的任务没有人认领&lt;/li&gt;
&lt;li&gt;有意无意的迟到&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. 认识信任和Ownership&lt;/h3&gt;
&lt;p&gt;在谈到How前，让我们再进一步了解信任和 Ownership 是什么。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;信任要先予之方能得之。信任他人者，他人信任之。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Stephen M.R. covey说“信任就是相信一个人的品质和能力，信任的四个核心是诚实、动机、能力、成果。”&lt;/p&gt;
&lt;p&gt;从心理学的角度，信任=相信意图乃至行为，信任是哪怕对他人意图或行为的积极预期会导致自身出现弱点，也愿意予以接受的一种心理状态。信任也是别人对你是一个怎么样的人的认知，以及对你会做什么的预期。&lt;/p&gt;
&lt;p&gt;从行为层面，信任指团队成员相信彼此的言行是出于好意，在团队里不必过分小心或互相戒备，成员间放心地接受彼此的批评。互相信任意味着大家开诚布公，彼此可以真诚地沟通交流。&lt;/p&gt;
&lt;p&gt;而麦肯锡有一个重要的信任公式，它提炼了建立信任的4个要素：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/how-to-efficiently-manage-a-development-team-2-4.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/how-to-efficiently-manage-a-development-team-2-4-1024x402.png&quot; alt=&quot;信任公式&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1）可信度：这人是不是专家。&lt;/p&gt;
&lt;p&gt;你是否让他人可以相信你这个人。这取决于你解决问题的能力、经验、专业知识、资源等等；这个人的专业能力是否真有别人说的那么出色，是否能够胜任这份工作呢？过往的履历中是否做过足以让我值得信任的事情。说白了就是这事我能不能信你，能不能给你时间，给你空间，给你机会，给你资源。&lt;/p&gt;
&lt;p&gt;2）可靠度：这人是不是能出活。&lt;/p&gt;
&lt;p&gt;你是否靠谱，你是否能按时、保质地干成事。”凡事有交代，件件有着落，事事有回音“。以及言出必行、表里如一。&lt;/p&gt;
&lt;p&gt;3）亲密度：和这人工作是不是让我感到舒服。&lt;/p&gt;
&lt;p&gt;你是否有亲和力，招人喜欢，是否愿意接近你，和对方熟不熟，有多熟。比如工作之余是否原意和你喝两杯，聊几句，想起你的时候是不是有些温暖。互相越了解信任越高。&lt;/p&gt;
&lt;p&gt;4）自我取向（自私度）：你是否以自我为中心，做事总先考虑自己的利益。即使你很可信、可靠也很熟，但如果你总是从自我出发而不是他人或者团队优先的视角考虑问题，也难以取得他人的信任。人呢只有相信你的意图，然后才能相信的你的这个人。&lt;/p&gt;
&lt;p&gt;Ownership 原意指所有权，又称完全物权。在民法上，权利人对标的物可以直接全面排他性支配特定物的物权。工作中的 Ownership 泛指对目标任务的所有权、主人翁意识等，它的另一层含义是指拥有权利的同时也拥有同等的责任，团队充分掌握自己负责的工作任务目标，拥有做出决策的权利，且敢于担当，积极主动去解决问题。&lt;/p&gt;
&lt;p&gt;简单总结一句话，信任和Ownership是：&lt;/p&gt;
&lt;p&gt;我相信你能胜任这项工作，你会与大家分享相关的信息，你言出必行，我相信你的承诺，而且你对整个团队有良好的动机。&lt;/p&gt;
&lt;p&gt;作为Leader需要深入理解信任和 Ownership，才有助于我们更好地构建之。&lt;/p&gt;
&lt;h4&gt;如何构建团队的信任和Ownership&lt;/h4&gt;
&lt;p&gt;对新晋Leader，从原先独挡一面的团队贡献者到带领团队。往往对如何赢得团队信任和带领团队的工作上存在挑战，一方面既要快速的做出成绩证明自己的能力，另一方面又要能够敢于授权为团队负责。&lt;/p&gt;
&lt;p&gt;在这里我给出以下几点建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;做人：尊重谦逊，坦诚开放，让团队更多的人了解你&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;人非机器。信任的前提是尊重，每一位成员都是平等不同的个体，有着各自的优势和多样性。尽管不可言说，但尊重、信任、坦诚这些种种关系人们是可以通过你的言行举止感知到的。遇到重大关头的时候，就会如人饮水冷暖自知。只有且必须尊重每一位成员（话语权、信息权、所有权等），才能产生信任和 Ownership，成为Trusted Leader。&lt;/p&gt;
&lt;p&gt;其次，信任的构建要先与之，才能得之。加入团队伊始或者角色转变的时候，首先需要让团队更多的了解你，信任始于你迈出的第一步给团队留下的第一印象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;风趣的自我介绍&lt;/li&gt;
&lt;li&gt;对项目情况的了解&lt;/li&gt;
&lt;li&gt;倾听当前遇到的挑战&lt;/li&gt;
&lt;li&gt;1:1成员沟通&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再次，在于信息的透明和沟通到位，及时地让大家看到问题、进展及反馈，避免surprise；在涉及团队相关决策的时候，更需要和团队建立预先沟通和商量的渠道，邀请共创和共同改进，制定规则，激活Ownership。&lt;/p&gt;
&lt;p&gt;最后，坦诚和开放。我们每一个人都是有局限的，出错是很正常的，尤其是在刚开始去接受一个新挑战的时候。出错之后试图掩饰错误不懂装懂是最愚蠢的行为。也没有必要试图维护”我“的正确性，而是需要坦诚错误、承认局限、聚焦改进。&lt;/p&gt;
&lt;p&gt;因为作为Leader，确保“正确的事情和以正确的方法做事情”，比 ”自己是不是正确“的更重要。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;成事：发现和带领团队解决棘手的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;带领一群知识工作者或者极客，一个很重要的赢得信任的条件在于成事。大家更容易因为你的能力和专业而佩服和跟随你。因此，作为Leader，带领一帮专业人士的时候更重要的是通过成事来获得团队的信任。&lt;/p&gt;
&lt;p&gt;你可以选择团队当前的棘手挑战入手，充分了解情况，过往的努力和障碍，然后从小的改进入手，分享你的行动计划，把问题解决展示承诺。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;促进：成为团队的催化剂，增进了解，培育文化，鼓励有效冲突，引导团队以正确的方式做事。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Leader是团队的催化剂，需要善用各种活动将团队成员凝聚在一起，增加彼此的了解。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Team building活动&lt;/li&gt;
&lt;li&gt;Do Food一起做饭&lt;/li&gt;
&lt;li&gt;新人Onboard的仪式感&lt;/li&gt;
&lt;li&gt;Small success-阶段性的庆祝&lt;/li&gt;
&lt;li&gt;Hometown Story&lt;/li&gt;
&lt;li&gt;TEAM Appreciations&lt;/li&gt;
&lt;li&gt;我想听和/你想讲分享活动&lt;/li&gt;
&lt;li&gt;心情曲线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Leader是团队的Facilitator。信任意味着敢于反馈和质疑。Leader既要凝聚和团结大家，又要鼓励冲突，激发善意，因为表面和谐的假象对于解决问题和团队的成就并没有什么用。&lt;/p&gt;
&lt;p&gt;有冲突并不是坏事，坏在于Finger point，人人相轻、互相指责，缺乏包容理解。因此Leader在冲突下的规则建立和正确的引导就很重要，包括发言规则、罗伯特仪式法则、结构化的围绕事实的反馈、基于倾听的对话都是必备的工具箱。&lt;/p&gt;
&lt;p&gt;Leader同时也是Enabler。对于专业人员来说，最大的驱动力是在技术专业高度上的攀登，这是深深刻印在骨子里，绝不是物质刺激的外部力量所能带动的。一个真正的软件技术人会不断地对新技术、新问题，方案，对架构代码都有着无法抑制的好奇心、冲动、不服输、以及成就感。如果这个缺乏，我可以肯定地说绝无可能做到优秀。所以作为Leader，要关注团队的学习分享和工程卓越的文化氛围，保护这些时间的花费和投入，这是内在原生的驱动力，而这些投入也是值得的，因为这是我们所坚持正确做事的方式，比如：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/how-to-efficiently-manage-a-development-team-2-5.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/how-to-efficiently-manage-a-development-team-2-5-1024x451.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4. 保护：识别Bad Apple，及时介入并制止&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/how-to-efficiently-manage-a-development-team-2-6.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/how-to-efficiently-manage-a-development-team-2-6-1024x646.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里的坏苹果是个隐喻，它指的一种行为，而不是一个人。这种行为就像一种疾病，它让团队生病，让其他人不舒服，或者让其他人也表现得不好，即引起破窗效应。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt;有毒(toxic)行为（欺凌、嘲笑/严重取笑他人、侮辱、骚扰 - 种族、年龄或性别）&lt;/p&gt;
&lt;p&gt;冷漠（缺乏纪律、缺乏主人翁意识、缺乏责任感、缺乏热情）&lt;/p&gt;
&lt;p&gt;有感染性（Finger-point、安全问题-不锁屏、CI红着过夜）&lt;/p&gt;
&lt;p&gt;为什么要关注？&lt;/p&gt;
&lt;p&gt;好事不出门坏事传千里。1个坏的行为比100个好的行为所产生的破坏力更大。不及时制止会让整个团队就像一筐子苹果的故事一样都受到影响。 &lt;/p&gt;
&lt;p&gt;作为 Leader，当发现有一个坏苹果时，需要能够及时识别它。发现后不要责备个人而是关注机制的改进。要去了解和分析坏苹果这种行为的影响，改善机制，并快速执行。&lt;/p&gt;
&lt;h3&gt;5. 写在最后&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你接纳了一种工具，也就意味着你接受了潜藏在这种工具内的管理哲学。-克莱.舍基&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于一个敏捷团队，信任和 Ownership 的文化基因有多重要，就毋庸置疑了。我们鼓励团队拥抱变化，尽早和不断交付有价值的软件。而如今内外环境的不确定性、时间和节奏予以的多重挑战，时时刻都在对企业和团队做着”压力测试“，就更需要团队正视这种不确定性、彼此信任、积极沟通、主动响应变化，兑现承诺，并持续地改进。&lt;/p&gt;
&lt;p&gt;这样的团队一定不是被安排和计划出来的，而是靠一个好的Leader带领大家一起构建起来的。作为新晋Leader则需要身先士卒做人成事，从“要求”信任到“赢得”信任。人们在这样Leader的带领下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享愿景与目标&lt;/li&gt;
&lt;li&gt;快速获得任务所需的信息资源&lt;/li&gt;
&lt;li&gt;有序规范的协作&lt;/li&gt;
&lt;li&gt;肩负信任和Ownership&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;团队管理是一门科学也是一门艺术，而真诚是最好的套路。五个问题帮你把脉，从青铜到王者你学会了吗？&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>