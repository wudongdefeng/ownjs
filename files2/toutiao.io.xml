<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6d6188964c427020c50ef1b0a9d7e8c4</guid>
<title>IM 跨平台技术学习（三）：vivo 的 Electron 技术栈选型、全方位实践总结</title>
<link>https://toutiao.io/k/uaa9ymi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;td class=&quot;t_f&quot; id=&quot;postmessage_21074&quot;&gt;&amp;#13;
&lt;a target=&quot;_blank&quot; href=&quot;http://www.52im.net/thread-2792-1-1.html&quot;&gt;&amp;#13;
&lt;img class=&quot;g_js_scan_my_qr_4tiezi&quot; src=&quot;http://www.52im.net/template/qu_115style/img/52im_qr_4tiezi3.png&quot; alt=&quot;微信扫一扫关注！&quot; title=&quot;微信扫一扫关注！&quot;/&gt;&amp;#13;
&lt;/a&gt;&amp;#13;
&lt;p class=&quot;dc_zhaiyao2&quot;&gt;本文由vivo技术团队Yang Kun分享，原题“electron 应用开发优秀实践”，即时通讯网有修订。&lt;/p&gt;&lt;br/&gt;&amp;#13;
&lt;h2 class=&quot;dc_h2head&quot;&gt;1、引言&lt;/h2&gt;&lt;br/&gt;&amp;#13;
在上篇《&lt;a href=&quot;http://www.52im.net/thread-4039-1-1.html&quot; target=&quot;_blank&quot;&gt;Electron初体验(快速开始、跨进程通信、打包、踩坑等)&lt;/a&gt;》的分享中，我们已经对Electron跨端框架的开发有了大概的了解。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;本篇将基于vivo技术团队的技术实践，详细阐述了vivo在使用Electron进行跨端桌面开发时的技术栈选型考量，同时分享了在打包构建、版本更新、性能优化、质量保障、安全性等方面的实践方案和踩坑总结。&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13763&quot; aid=&quot;13763&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130413rjxgzfgbyxeg55fz.png&quot; file=&quot;data/attachment/forum/202209/23/130413rjxgzfgbyxeg55fz.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_cover-opti.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_cover-opti.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13763_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;cover-opti.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(16.04 KB, 下载次数: 42)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NjN8ZDczZjY5M2J8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13763&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13763&amp;amp;handlekey=savephoto_13763&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:04&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h2 class=&quot;dc_h2&quot;&gt;2、系列文章&lt;/h2&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;本文是系列文章中的第3篇，本系列总目录如下：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h2 class=&quot;dc_h2head&quot;&gt;3、技术背景&lt;/h2&gt;&lt;br/&gt;&amp;#13;
因业务发展，我们需要用到桌面端技术，技术特性涉及离线可用、调用桌面系统能力等要求。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;那么什么是桌面端开发？&lt;/strong&gt;&lt;strong&gt;一句话概括就是：&lt;/strong&gt;以 Windows 、MacOS 和 Linux 为操作系统的桌面软件开发。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
对此我们做了详细的技术调研：桌面端的开发方式主要有 Native 、 QT 、 &lt;a href=&quot;https://flutter.cn/&quot; target=&quot;_blank&quot;&gt;Flutter&lt;/a&gt; 、 NW 、 &lt;a href=&quot;http://www.52im.net/thread-2616-1-1.html&quot; target=&quot;_blank&quot;&gt;Electron&lt;/a&gt; 、 &lt;a href=&quot;https://github.com/tarui&quot; target=&quot;_blank&quot;&gt;Tarui&lt;/a&gt; 。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;这些技术各自优劣势如下表格所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13743&quot; aid=&quot;13743&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130139pnuyiurg4ui44y1y.png&quot; file=&quot;data/attachment/forum/202209/23/130139pnuyiurg4ui44y1y.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_1.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_1.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13743_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;1.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(23.07 KB, 下载次数: 41)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NDN8ZTkxMTAwMDZ8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13743&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13743&amp;amp;handlekey=savephoto_13743&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:01&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;我们最终的桌面端技术选型是 Electron&lt;/strong&gt;，Electron 是一个可以使用 Web 技术来开发跨平台桌面应用的开发框架。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;其技术组成如下：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;div&gt;&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;Electron = Chromium + Node.js + Native API&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;各技术能力如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13744&quot; aid=&quot;13744&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130146z6nu4zv94nv3966j.jpg&quot; file=&quot;data/attachment/forum/202209/23/130146z6nu4zv94nv3966j.jpg&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_2.jpg&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_2.jpg&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13744_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;2.jpg&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(32.56 KB, 下载次数: 42)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NDR8MmY5MmRlZmR8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13744&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13744&amp;amp;handlekey=savephoto_13744&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:01&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;整体架构如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13745&quot; aid=&quot;13745&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130153twdz8olwy7lklxoy.png&quot; file=&quot;data/attachment/forum/202209/23/130153twdz8olwy7lklxoy.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_3.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_3.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13745_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;3.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(18.9 KB, 下载次数: 40)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NDV8YjJiOWRmZDR8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13745&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13745&amp;amp;handlekey=savephoto_13745&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:01&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;Electron 是多进程架构，架构具有以下特点：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;由一个主进程和 N 个渲染进程组成；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;主进程承担主导作用，用于完成各种跨平台和原生交互；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;渲染进程可以是多个，使用 Web 技术开发，通过浏览器内核渲染页面；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;主进程和渲染进程通过进程间通信来完成各种功能。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
这里回顾一下 Electron 进程间通信技术原理。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
electron 使用 IPC （&lt;font&gt;interprocess communication&lt;/font&gt;） 在进程之间进行通信。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13746&quot; aid=&quot;13746&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130159lv9lxdisclqd73ss.png&quot; file=&quot;data/attachment/forum/202209/23/130159lv9lxdisclqd73ss.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_4.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_4.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13746_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;4.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(20.14 KB, 下载次数: 46)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NDZ8OTQ1NjIyNDd8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13746&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13746&amp;amp;handlekey=savephoto_13746&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:01&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
其提供了 IPC 通信模块，主进程的 ipcMain 和渲染进程的 ipcRenderer。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
从 electron 源码中可以看出， ipcMain 和 ipcRenderer 都是 EventEmitter 对象。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;源码如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13747&quot; aid=&quot;13747&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130206u7907tztf67tt4z5.png&quot; file=&quot;data/attachment/forum/202209/23/130206u7907tztf67tt4z5.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_5.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_5.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13747_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;5.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(71.51 KB, 下载次数: 45)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NDd8ZGRhMjkxYWN8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13747&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13747&amp;amp;handlekey=savephoto_13747&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:02&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
看到源码实现，是不是觉得 IPC 不难理解了。知其本质，方可游刃有余。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
限于篇幅，这里对Electron的基础知识就不再展开，有兴趣的读者可回顾一下本系列的前两篇《&lt;a href=&quot;http://www.52im.net/thread-2616-1-1.html&quot; target=&quot;_blank&quot;&gt;快速了解新一代跨平台桌面技术——Electron&lt;/a&gt;》、《&lt;a href=&quot;http://www.52im.net/thread-4039-1-1.html&quot; target=&quot;_blank&quot;&gt;Electron初体验(快速开始、跨进程通信、打包、踩坑等&lt;/a&gt;)》（&lt;font&gt;这篇中的“5、进程详解”特别介绍了Electron进程间的关系以及通信原理&lt;/font&gt;）。&lt;br/&gt;&amp;#13;
&lt;h2 class=&quot;dc_h2&quot;&gt;4、开发技术栈选型&lt;/h2&gt;&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;4.1&lt;/span&gt;编程语言选型&lt;/h3&gt;&lt;br/&gt;&amp;#13;
我们最终选择的是Typescript，理由如下。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;针对开发者：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;Javascript 的超集（无缝支持所有的 es2020+ 所有的特性，学习成本小）；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;编译生成的 JavaScript 的代码保持很好的可读性；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;可维护性明显增强；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;完整的 OOP 的支持（extends, interface， private， protect， public等）；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;5）&lt;/strong&gt;&lt;/i&gt;类型即文档；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;6）&lt;/strong&gt;&lt;/i&gt;类型的约束，更少的单元测试的覆盖；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;7）&lt;/strong&gt;&lt;/i&gt;更安全的代码。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;针对工具：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;更好的重构能力；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;静态分析自动导包；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;代码错误检查；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;代码跳转；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;5）&lt;/strong&gt;&lt;/i&gt;代码提示补齐。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;社区支持：&lt;/strong&gt;大量的社区的类型定义文件 提升开发效率。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;4.2&lt;/span&gt;构建工具选型&lt;/h3&gt;&lt;br/&gt;&amp;#13;
我们选择的是 &lt;a href=&quot;https://github.com/electron-userland/electron-forge&quot; target=&quot;_blank&quot;&gt;Electron-Forge&lt;/a&gt;。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;理由很充分：&lt;/strong&gt;Electron-Forge简单而又强大，目前 electron 应用最好的构建工具之一。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
这里提一下 &lt;a href=&quot;https://github.com/electron-userland/electron-builder&quot; target=&quot;_blank&quot;&gt;electron-builder&lt;/a&gt; 其和 &lt;a href=&quot;https://github.com/electron-userland/electron-forge&quot; target=&quot;_blank&quot;&gt;electron-forge&lt;/a&gt; 的介绍和区别。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;看下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13749&quot; aid=&quot;13749&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130227epi8px1xl22r0bb1.png&quot; file=&quot;data/attachment/forum/202209/23/130227epi8px1xl22r0bb1.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_6.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_6.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13749_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;6.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(49.16 KB, 下载次数: 42)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NDl8NmNlMzU4N2F8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13749&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13749&amp;amp;handlekey=savephoto_13749&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:02&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
两者最大的区别在于自由度，两者在能力上基本没什么差异了，从官方组织中的排序看，有意优先推荐 electron-forge 。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;4.3&lt;/span&gt;Web方案选型&lt;/h3&gt;&lt;br/&gt;&amp;#13;
我们采用的是 &lt;a href=&quot;https://cn.vuejs.org/&quot; target=&quot;_blank&quot;&gt;Vue3&lt;/a&gt; ，同时使用 &lt;a href=&quot;https://vitejs.cn/&quot; target=&quot;_blank&quot;&gt;Vite&lt;/a&gt; 作为构建工具，具体优点，大家可以查看官网介绍，这套组合是目前主流的 Web 开发方案。&lt;br/&gt;&amp;#13;
        &lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;4.4&lt;/span&gt;monorepo方案选型&lt;/h3&gt;&lt;br/&gt;&amp;#13;
目前的 monorepo 生态百花齐放，正确的实践方法应该是集大成法，也就是取各家之长，目前的趋势也是如此，各开源 monorepo 工具达成默契，专注自己擅长的能力。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
如 pnpm 擅长依赖管理， turbo 擅长构建任务编排。遂在 monorepo 技术选型上，我选择了 &lt;a href=&quot;https://pnpm.io&quot; target=&quot;_blank&quot;&gt;pnpm&lt;/a&gt; 和 &lt;a href=&quot;https://turborepo.org/&quot; target=&quot;_blank&quot;&gt;turbo&lt;/a&gt; 。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
以下是pnpm的&lt;a href=&quot;https://pnpm.io/&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;：&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13748&quot; aid=&quot;13748&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130220lgscgqsdjjms4qxv.png&quot; file=&quot;data/attachment/forum/202209/23/130220lgscgqsdjjms4qxv.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_7.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_7.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13748_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;7.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(51.58 KB, 下载次数: 44)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NDh8MTdhNzNhOWN8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13748&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13748&amp;amp;handlekey=savephoto_13748&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:02&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;pnpm 理由如下：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;目前最好的包管理工具（pnpm 吸收了npm、yarn、lerna等主流工具的精华，并去其糟粕）；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;生态、社区活跃且强大；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;结合 workspace 可以完成 monorepo 最佳设计和实践；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;在管理多项目的包依赖、代码风格、代码质量、组件库复用等场景下，表现出色；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;5）&lt;/strong&gt;&lt;/i&gt;在框架、库的开发、调试、维护方面，表现出色。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
相比于 vue 官网，在使用 pnpm 上，我加了 workspace 。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;&lt;a href=&quot;https://turborepo.org/&quot; target=&quot;_blank&quot;&gt;turbo&lt;/a&gt; 理由如下：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;它是一个高性能构建系统（拥有增量构建、云缓存、并行执行、运行时零开销、任务管道、精简子集等特性）；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;具有非常优秀的任务编排能力（可以弥补 pnpm 在任务编排上的短板）。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;4.5&lt;/span&gt;本地数据库选型&lt;/h3&gt;&lt;br/&gt;&amp;#13;
Electron 应用数据库有非常多的选择如 &lt;a href=&quot;https://github.com/typicode/lowdb&quot; target=&quot;_blank&quot;&gt;lowdb&lt;/a&gt; 、 &lt;a href=&quot;https://www.sqlite.org/index.html&quot; target=&quot;_blank&quot;&gt;sqlite3&lt;/a&gt; 、 electron-store 、 pouchdb 、 dedb 、 rxdb 、 dexie 、 ImmortalDB 等。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
这些数据库都有一个特性，那就是无服务器。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;Electron本地数据库技术选型考虑因素主要有：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;生态（使用者数量、维护频率、版本稳定度）；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;能力；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;性能；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;其他（和使用者技术匹配度）。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;我们通过以下渠道进行了相关调研：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;github 的 issues、commit、fork、star；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;sourcegraph 关键字搜索结果数；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;npm 包下载量、版本发布；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;官网和博客。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
给出四个最优选择，分别是 lowdb 、 sqlite3 、 nedb 、 electron-store 。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;我们的理由如下：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;&lt;font&gt;lowdb&lt;/font&gt;：生态、能力、性能三方面表现优秀， json 形式的存储结构， 支持 lodash 、 ramda 等 api 操作，利于备份和调用；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;&lt;font&gt;sqlite3&lt;/font&gt;：生态、能力、性能三方面表现优秀， Nodejs 关系型数据库第一选择方案；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;&lt;font&gt;nedb&lt;/font&gt;：能力、性能三方面表现优秀，缺点是基本不维护了，但底子还在，尤其操作是 MongoDB 的子集，对于熟悉 MongoDB 的使用者来说是绝佳选择；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;&lt;font&gt;electron-store&lt;/font&gt;：生态表现优秀，轻量级持久化方案，简单易用。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
我们使用的数据库最终选型是 &lt;a href=&quot;https://github.com/typicode/lowdb&quot; target=&quot;_blank&quot;&gt;lowdb&lt;/a&gt; 方案。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;PS：&lt;/strong&gt;提一下 &lt;a href=&quot;https://pouchdb.com/&quot; target=&quot;_blank&quot;&gt;pouchdb&lt;/a&gt; ，如果需要将本地数据同步到远端数据库，可以使用 pouchdb ，其和 &lt;a href=&quot;https://couchdb.apache.org/&quot; target=&quot;_blank&quot;&gt;couchdb&lt;/a&gt; 可以轻松完成同步。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;4.6&lt;/span&gt;脚本工具选型&lt;/h3&gt;&lt;br/&gt;&amp;#13;
软件开发过程中，将一些流程和操作通过脚本来完成，可以有效地提高开发效率和幸福度。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
依赖 node runtime 的优秀选择就两个：&lt;a href=&quot;https://github.com/shelljs/shelljs&quot; target=&quot;_blank&quot;&gt;shelljs&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/google/zx&quot; target=&quot;_blank&quot;&gt;zx&lt;/a&gt; 。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;选择 zx 的理由如下：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;自带 fetch 、 chalk 等常用库，使用方便快捷；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;多个子进程方便快捷（执行远端脚本、解析 md 、 xml 文件脚本、支持 ts），功能丰富且强大；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;谷歌出品、大厂背景，生态非常活跃。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
至此，技术选型就介绍完了。&lt;br/&gt;&amp;#13;
&lt;h2 class=&quot;dc_h2&quot;&gt;5、打包构建实践&lt;/h2&gt;&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;5.1&lt;/span&gt;应用图标生成&lt;/h3&gt;&lt;br/&gt;&amp;#13;
不同尺寸图标的生成有以下方法。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;Windows：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;MacOS：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;5.2&lt;/span&gt;二进制文件构建&lt;/h3&gt;&lt;br/&gt;&amp;#13;
本章节内容是基于 electron-forge 阐述的，不过原理是一样的。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
在开发桌面端应用时，会有场景要用到第三方的二进制程序，比如 ffmpeg 这种。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
在构建二进制程序时，要关注以下两个注意项。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;二进制程序不能打包进 asar 中 可以在构建配置文件（&lt;font&gt;forge.config.js&lt;/font&gt;）进行如下设置：&lt;br/&gt;&amp;#13;
&lt;div&gt;&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;const os = require(&#x27;os&#x27;)&amp;#13;
const platform = os.platform()&amp;#13;
const config = {&amp;#13;
  packagerConfig: {&amp;#13;
    // 可以将 ffmpeg 目录打包到 asar 目录外面&amp;#13;
    extraResource: [`./src/main/ffmpeg/`]&amp;#13;
  }&amp;#13;
}&amp;#13;
&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;&amp;#13;
&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;开发和生产环境，获取二进制程序路径方法是不一样的 可以采用如下代码进行动态获取：&lt;br/&gt;&amp;#13;
&lt;div&gt;&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;import { app } from &#x27;electron&#x27;&amp;#13;
import os from &#x27;os&#x27;&amp;#13;
import path from &#x27;path&#x27;&amp;#13;
const platform = os.platform()&amp;#13;
const dir = app.getAppPath()&amp;#13;
let basePath = &#x27;&#x27;&amp;#13;
if(app.isPackaged) basePath = path.join(process.resourcesPath)&amp;#13;
else basePath = path.join(dir, &#x27;ffmpeg&#x27;)&amp;#13;
const isWin = platform === &#x27;win32&#x27;&amp;#13;
// ffmpeg 二进制程序路径&amp;#13;
const ffmpegPath = path.join(basePath, `${platform}`, `ffmpeg${isWin ? &#x27;.exe&#x27; :&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;5.3&lt;/span&gt;按需构建&lt;/h3&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;如何对跨平台二进制文件进行按需构建呢？&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
比如桌面应用中用到了 ffmpeg ， 它需要有 windows 、 mac 和 linux 的下载二进制。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
在打包的时候，如果不做按需构建，则会将 3 个二进制文件全部打到构建中，这样会让应用体积增加很多。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
可以在 &lt;font&gt;forge.config.js &lt;/font&gt;配置文件中进行如下配置，即可完成按需构建。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;代码如下：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;div&gt;&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;const platform = os.platform()&amp;#13;
const config = {&amp;#13;
  packagerConfig: {&amp;#13;
    extraResource: [`./src/main/ffmpeg/${platform}`]&amp;#13;
  },&amp;#13;
}&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;&amp;#13;
通过 platform 变量来把对应系统的二进制打到构建中，即可完成对二进制文件的按需构建。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;5.4&lt;/span&gt;性能优化&lt;/h3&gt;&lt;br/&gt;&amp;#13;
主要是构建速度和构建体积优化，构建速度这块不好优化。这里重点说下构建体积优化，拿 mac 系统举例说明， 在 electron 应用打包后，查看应用包内容。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13750&quot; aid=&quot;13750&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130238kr7fofuud1reenaf.png&quot; file=&quot;data/attachment/forum/202209/23/130238kr7fofuud1reenaf.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_8.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_8.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13750_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;8.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(33.33 KB, 下载次数: 47)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NTB8MjU1NzU5MDl8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13750&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13750&amp;amp;handlekey=savephoto_13750&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:02&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
可以看到有一个 app.asar 文件。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;这个文件用 asar 解压后可以看到有以下内容：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13751&quot; aid=&quot;13751&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130244naqz22tthhc6cq22.png&quot; file=&quot;data/attachment/forum/202209/23/130244naqz22tthhc6cq22.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_9.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_9.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13751_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;9.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(13.84 KB, 下载次数: 40)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NTF8OWFlZDFjMmV8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13751&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13751&amp;amp;handlekey=savephoto_13751&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:02&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
可以看出 asar 中的文件，就是我们构建后的项目代码，从图中可以看到有 &lt;font&gt;node_modules&lt;/font&gt; 目录， 这是因为在 electron 构建机制中，会自动把 dependencies 的依赖全部打到 asar 中。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;结合上述分析，我们的优化措施有以下4点：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;将 web 端构建所需的依赖全部放到 devDependencies 中，只将在 electron 端需要的依赖放到 dependencies；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;将和生产无关的代码和文件从构建中剔除；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;对跨平台使用的二进制文件，如 ffmpeg 进行按需构建（上文按需构建已介绍）；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;对 node_modules 进行清理精简。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;这里提下第&lt;i&gt;&lt;strong&gt; 4）&lt;/strong&gt;&lt;/i&gt; 点，如何对 node_modules 进行清理精简呢？&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;如果是 yarn 安装的依赖：&lt;/strong&gt;我们可以在根目录使用下面命令进行精简：&lt;br/&gt;&amp;#13;
&lt;div&gt;&lt;pre class=&quot;brush: bash; gutter: true&quot;&gt;yarn autoclean -I&amp;#13;
yarn autoclean -F&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;如果是 pnpm 安装的依赖：&lt;/strong&gt;第&lt;i&gt;&lt;strong&gt; 4）&lt;/strong&gt;&lt;/i&gt;点应该不起作用了。我在项目中使用 yarn 安装依赖，然后执行上述命令后，发现打包体积减少了 6M ， 虽然不多，但也还可以。&lt;br/&gt;&amp;#13;
&lt;h2 class=&quot;dc_h2&quot;&gt;6、版本更新实践&lt;/h2&gt;&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;6.1&lt;/span&gt;全量更新&lt;/h3&gt;&lt;br/&gt;&amp;#13;
全量更新就是通过下载最新的包或者 zip 文件，进行软件更新，需要替换所有的文件。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;整体设计流程图如下：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13752&quot; aid=&quot;13752&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130252bm0ta2d0k2wwnq2x.png&quot; file=&quot;data/attachment/forum/202209/23/130252bm0ta2d0k2wwnq2x.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_10.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_10.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13752_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;10.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(24.29 KB, 下载次数: 42)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NTJ8NDI5ZGYxYTF8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13752&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13752&amp;amp;handlekey=savephoto_13752&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:02&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;按照流程图去实现，我们需要做以下事情：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;开发服务端接口，用来返回应用最新版本信息；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;渲染进程使用 axios 等工具请求接口，获取最新版本信息；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;封装更新逻辑，用来对接口返回的版本信息进行综合比较，判断是否更新；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;通过 ipc 通信将更新信息传递给主进程；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;5）&lt;/strong&gt;&lt;/i&gt;主进程通过 electron-updater 进行全量更新；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;6）&lt;/strong&gt;&lt;/i&gt;将更新信息通过 ipc 推送给渲染进程；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;7）&lt;/strong&gt;&lt;/i&gt;渲染进程向用户展示更新信息，若更新成功，则弹出弹窗告诉用户重启应用，完成软件更新。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;6.2&lt;/span&gt;增量更新&lt;/h3&gt;&lt;br/&gt;&amp;#13;
增量更新是通过拉取最新的渲染层打包文件，覆盖之前的渲染层代码，完成软件更新，此方案只需替换渲染层代码，无需替换所有文件。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13753&quot; aid=&quot;13753&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130300dk47oko0q46klyr4.png&quot; file=&quot;data/attachment/forum/202209/23/130300dk47oko0q46klyr4.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_11.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_11.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13753_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;11.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(27.7 KB, 下载次数: 41)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NTN8YTI2YjJjMjd8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13753&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13753&amp;amp;handlekey=savephoto_13753&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:03&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;按照流程图去实现，我们需要做以下事情：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;渲染进程定时通知主进程检测更新；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;主进程检测更新；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;需要更新，则拉取线上最新包；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;删除旧版本包，复制线上最新包，完成增量更新；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;5）&lt;/strong&gt;&lt;/i&gt;通知渲染进程，提示用户重启应用完成更新。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
全量更新和增量更新各有优势，&lt;strong&gt;多数情况下，采用增量更新来提高用户更新体验，同时使用全量更新作为兜底更新方案&lt;/strong&gt;。&lt;br/&gt;&amp;#13;
&lt;h2 class=&quot;dc_h2&quot;&gt;7、性能优化实践&lt;/h2&gt;&lt;br/&gt;&amp;#13;
打包构建优化在上节内容中已经详细介绍过了，这里不再介绍，下面将介绍我们对“启动时优化”和“运行时优化”的实践。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;7.1&lt;/span&gt;启动时优化&lt;/h3&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;主要从以下几个方面着手：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;使用 v8-compile-cache 缓存编译代码；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;优先加载核心功能，非核心功能动态加载；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;使用多进程，多线程技术；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;采用 asar 打包：会加快启动速度；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;5）&lt;/strong&gt;&lt;/i&gt;增加视觉过渡：loading + 骨架屏。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
&lt;font&gt;&lt;i&gt;&lt;strong&gt;7.1.1）&lt;/strong&gt;&lt;/i&gt;使用 v8-compile-cache 缓存编译代码：&lt;/font&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;使用 V8 缓存数据，为什么要这么做呢？&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
因为 electorn 使用 V8 引擎运行 js ， V8 运行 js 时，需要先进行解析和编译，再执行代码。其中，解析和编译过程消耗时间多，经常导致性能瓶颈。而 V8 缓存功能，可以将编译后的字节码缓存起来，省去下一次解析、编译的时间。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
主要使用 v8-compile-cache 来缓存编译的代码，做法很简单：&lt;strong&gt;在需要缓存的地方加一行&lt;/strong&gt;。&lt;br/&gt;&amp;#13;
&lt;div&gt;&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;require(&#x27;v8-compile-cache&#x27;)&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;其他使用方法请查看此链接文档 ：&lt;/strong&gt;&lt;a href=&quot;https://www.npmjs.com/package/v8-compile-cache&quot; target=&quot;_blank&quot;&gt;https://www.npmjs.com/package/v8-compile-cache&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;font&gt;&lt;i&gt;&lt;strong&gt;7.1.2）&lt;/strong&gt;&lt;/i&gt;优先加载核心功能，非核心功能动态加载：&lt;/font&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;伪代码如下：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;div&gt;&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;export function share() {&amp;#13;
  const kun = require(&#x27;kun&#x27;)&amp;#13;
  kun()&amp;#13;
}&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;7.2&lt;/span&gt;运行时优化&lt;/h3&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;主要从以下几个方面着手：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;对渲染进程 进行 Web 性能优化；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;对主进程进行轻量瘦身。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
&lt;font&gt;&lt;i&gt;&lt;strong&gt;7.2.1）&lt;/strong&gt;&lt;/i&gt;对渲染进程 进行 Web 性能优化：&lt;/font&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;用一个思维导图来完整阐述如何进行 Web 性能优化，如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13754&quot; aid=&quot;13754&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130308bxaqar3xmmcq600v.png&quot; file=&quot;data/attachment/forum/202209/23/130308bxaqar3xmmcq600v.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_12.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_12.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13754_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;12.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(92.28 KB, 下载次数: 44)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NTR8ZjM4N2NjNmZ8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13754&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13754&amp;amp;handlekey=savephoto_13754&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:03&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
上图基本包含了性能优化的核心关键点和内容，大家可以以此作为参考，去做性能优化。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;font&gt;&lt;i&gt;&lt;strong&gt;7.2.2）&lt;/strong&gt;&lt;/i&gt;对主进程进行轻量瘦身：&lt;/font&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
核心方案就是将运行时耗时、计算量大的功能交给新开的 node 进程去执行处理。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;伪代码如下：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;div&gt;&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;const { fork } = require(&#x27;child_process&#x27;)&amp;#13;
let { app } = require(&#x27;electron&#x27;)&amp;#13;
&amp;#13;
function createProcess(socketName) {&amp;#13;
  process = fork(`xxxx/server.js`, [&amp;#13;
    &#x27;--subprocess&#x27;,&amp;#13;
    app.getVersion(),&amp;#13;
    socketName&amp;#13;
  ])&amp;#13;
}&amp;#13;
&amp;#13;
const initApp = async () =&amp;gt; {&amp;#13;
  // 其他初始化代码...&amp;#13;
  let socket = await findSocket()&amp;#13;
  createProcess(socket)&amp;#13;
}&amp;#13;
&amp;#13;
app.on(&#x27;ready&#x27;, initApp)&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;&amp;#13;
通过以上代码，将耗时、计算量大的功能，放在&lt;font&gt; server.js&lt;/font&gt; ，然后再 fork 到新开 node 进程中进行处理。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
至此，性能优化实践就介绍完了。&lt;br/&gt;&amp;#13;
&lt;h2 class=&quot;dc_h2&quot;&gt;8、质量保障实践&lt;/h2&gt;&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;8.1&lt;/span&gt;概述&lt;/h3&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;质量保障的全流程措施如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13755&quot; aid=&quot;13755&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130317us404quuiwwttny0.png&quot; file=&quot;data/attachment/forum/202209/23/130317us404quuiwwttny0.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_13.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_13.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13755_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;13.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(31.88 KB, 下载次数: 41)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NTV8YjY4YjRkMmN8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13755&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13755&amp;amp;handlekey=savephoto_13755&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:03&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;本节主要从以下3个方面分享：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
下面将会依次介绍上述内容。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;8.2&lt;/span&gt;自动化测试&lt;/h3&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;自动化测试是什么？&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13756&quot; aid=&quot;13756&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130324oilullcaccuypt6l.png&quot; file=&quot;data/attachment/forum/202209/23/130324oilullcaccuypt6l.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_14.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_14.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13756_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;14.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(24.48 KB, 下载次数: 40)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NTZ8Nzg4MmZjNWJ8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13756&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13756&amp;amp;handlekey=savephoto_13756&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:03&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
上图是做自动化测试一个完整步骤，大家可以看图领会。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
自动化测试主要分为 单元测试、集成测试、端到端测试。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;三者关系如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13757&quot; aid=&quot;13757&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130330umgeir49r8jeak9e.png&quot; file=&quot;data/attachment/forum/202209/23/130330umgeir49r8jeak9e.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_15.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_15.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13757_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;15.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(14.45 KB, 下载次数: 46)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NTd8ZDMzMjM4ZDF8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13757&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13757&amp;amp;handlekey=savephoto_13757&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:03&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;一般情况下：&lt;/strong&gt;作为软件工程师，我们做到一定的单元测试就可以了。而且从我目前经验来说，如果是写业务性质的项目，基本上不会编写测试相关的代码。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
自动化测试主要是用来编写库、框架、组件等需要作为单独个体提供给他人使用的。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
electron 的测试工具推荐 &lt;a href=&quot;https://github.com/vitest-dev/vitest&quot; target=&quot;_blank&quot;&gt;vitest&lt;/a&gt; 、 spectron 。具体用法参考官网文档即可，没什么特别的技巧。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;8.3&lt;/span&gt;崩溃监控&lt;/h3&gt;&lt;br/&gt;&amp;#13;
对于 GUI 软件，尤其桌面端软件来说，崩溃率非常重要，因此需要对崩溃进行监控。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;崩溃监控原理如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13758&quot; aid=&quot;13758&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130336elptzlqg2ltqeb7u.png&quot; file=&quot;data/attachment/forum/202209/23/130336elptzlqg2ltqeb7u.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_16.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_16.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13758_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;16.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(32.67 KB, 下载次数: 39)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NTh8ZmI0YmY1ZTd8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13758&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13758&amp;amp;handlekey=savephoto_13758&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:03&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;崩溃监控技巧：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;渲染进程崩溃后，提示用户重新加载；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;通过 preload 统一初始化崩溃监控；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;主进程、渲染进程通过 process.crash() 进行模拟崩溃；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;对崩溃日志进行收集分析。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
崩溃监控做好后，如果发生崩溃，该如何治理崩溃呢？&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;8.4&lt;/span&gt;崩溃治理&lt;/h3&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;崩溃治理难点：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;定位出错栈困难：Native 错误栈，无操作上下文；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;调试门槛高：C++ 、 IIdb/GDB；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;运行环境复杂：机器型号、系统、其他软件。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;崩溃治理技巧：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;及时升级 electron；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;用户操作日志和系统信息；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;复现和定位问题比治理重要；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;把问题交给社区解决，社区响应快；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;5）&lt;/strong&gt;&lt;/i&gt;善于用 devtool 分析和治理内存问题。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
&lt;h2 class=&quot;dc_h2head&quot;&gt;9、安全性实践&lt;/h2&gt;&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;9.1&lt;/span&gt;概述&lt;/h3&gt;&lt;br/&gt;&amp;#13;
俗话说的好，安全大于天，保证 electron 应用的安全也是一项重要的事情。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;本章节将安全分为以下 5 个方面：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;源码泄漏；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;asar；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;源码保护；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;应用安全；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;5）&lt;/strong&gt;&lt;/i&gt;编码安全。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
下面将会依次介绍上述内容。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;9.2&lt;/span&gt;源码泄漏&lt;/h3&gt;&lt;br/&gt;&amp;#13;
目前 electron 在源码安全做的不好，官方只用 asar 做了一下很没用的源码保护，&lt;strong&gt;到底有多没用呢？&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
你只需要下载 asar 工具，然后对 asar 文件进行解压就可以得到里面的源码了。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13759&quot; aid=&quot;13759&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130344wqqqe8wqq6n16wdq.png&quot; file=&quot;data/attachment/forum/202209/23/130344wqqqe8wqq6n16wdq.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_17.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_17.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13759_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;17.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(100.65 KB, 下载次数: 42)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NTl8ODg1MWI4ZDZ8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13759&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13759&amp;amp;handlekey=savephoto_13759&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:03&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
通过图中操作即可看到语雀应用的源码。&lt;strong&gt;上面提到的 asar 是什么呢？&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;9.3&lt;/span&gt;asar介绍&lt;/h3&gt;&lt;br/&gt;&amp;#13;
asar 是一种将多个文件合并成一个文件的类 tar 风格的归档格式。Electron 可以无需解压整个文件，即可从其中读取任意文件内容。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;可以直接看 electron 源码，都是 ts 代码，容易阅读，源码如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13760&quot; aid=&quot;13760&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130350ssgsztbvgfbghh8s.png&quot; file=&quot;data/attachment/forum/202209/23/130350ssgsztbvgfbghh8s.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_18.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_18.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13760_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;18.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(81.38 KB, 下载次数: 44)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NjB8MDk3ZjJlMTh8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13760&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13760&amp;amp;handlekey=savephoto_13760&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:03&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;9.4&lt;/span&gt;源码保护&lt;/h3&gt;&lt;br/&gt;&amp;#13;
避免源码泄漏，按照从低到高的源码安全，可以分为几个程度。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;具体如下：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;asar；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;代码混淆；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;WebAssembly；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;Language bindings。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;其中：&lt;/strong&gt;Language bindings 是最高的源码安全措施，其实使用 C++ 或 Rust 代码来编写 electron 应用代码，通过将 C++ 或 Rust 代码编译成二进制代码后，破译的难度会变高。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
这里我说下如何使用 Rust 去编写 electron 应用代码。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;方案是：使用 napi-rs 作为工具去编写，如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13761&quot; aid=&quot;13761&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130357t1h1gshe9rkanh57.png&quot; file=&quot;data/attachment/forum/202209/23/130357t1h1gshe9rkanh57.png&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_19.png&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_19.png&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13761_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;19.png&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(44.97 KB, 下载次数: 40)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NjF8ZmMwZGQ1NTl8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13761&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13761&amp;amp;handlekey=savephoto_13761&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:03&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
我们采用 pnpm-workspace 去管理 Rust 代码，使用 napi-rs 。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;比如我们写一个 sum 函数，rs代码如下：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;div&gt;&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;fn sum(a: f64, b: f64) -&amp;gt; f64 {&amp;#13;
  a + b&amp;#13;
}&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;此时我们加上 napi 装饰代码，如下所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;div&gt;&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;use napi_derive::napi;&amp;#13;
&amp;#13;
#[napi]&amp;#13;
fn sum(a: f64, b: f64) -&amp;gt; f64 {&amp;#13;
  a + b&amp;#13;
}&amp;#13;
&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;&amp;#13;
在通过 napi-cli 将上述代码编译成 node 可以调用的二进制代码。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;编译后，在electron使用上述代码，如下所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;div&gt;&lt;pre class=&quot;brush: javascript; gutter: true&quot;&gt;import { sum as rsSum } from &#x27;@rebebuca/native&#x27;&amp;#13;
// 输出 7&amp;#13;
console.log(rsSum(2, 5))&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;&amp;#13;
napi-rs 的使用请阅读官方文档，地址是：&lt;a href=&quot;https://napi.rs/&quot; target=&quot;_blank&quot;&gt;https://napi.rs/&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
至此，language bindings 的阐述就完成了。我们通过这种方式，可以完成对重要功能的源码保护。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;9.5&lt;/span&gt;应用安全&lt;/h3&gt;&lt;br/&gt;&amp;#13;
目前熟知的一个安全问题是克隆攻击，此问题的主流解决方案是将用户认证信息和应用设备指纹进行绑定。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;整体流程如如下图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&amp;#13;
&lt;ignore_js_op&gt;&amp;#13;
&amp;#13;
&lt;img id=&quot;aimg_13762&quot; aid=&quot;13762&quot; src=&quot;http://www.52im.net/static/image/common/none.gif&quot; zoomfile=&quot;data/attachment/forum/202209/23/130404k4m02z4dmgqd62ir.jpg&quot; file=&quot;data/attachment/forum/202209/23/130404k4m02z4dmgqd62ir.jpg&quot; class=&quot;zoom&quot; inpost=&quot;1&quot; alt=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_20.jpg&quot; title=&quot;IM跨平台技术学习(三)：vivo的Electron技术栈选型、全方位实践总结_20.jpg&quot;/&gt;&amp;#13;
&amp;#13;
&lt;div class=&quot;tip tip_4 aimg_tip&quot; id=&quot;aimg_13762_menu&quot; disautofocus=&quot;true&quot;&gt;&amp;#13;
&lt;div class=&quot;xs0&quot;&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;20.jpg&lt;/strong&gt; &lt;em class=&quot;xg1&quot;&gt;(22.16 KB, 下载次数: 43)&lt;/em&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&amp;#13;
&lt;a href=&quot;http://www.52im.net/forum.php?mod=attachment&amp;amp;aid=MTM3NjJ8YTU1N2U5ZGV8MTY2NDc1Nzk0MnwwfDQwNDQ%3D&amp;amp;nothumb=yes&quot; target=&quot;_blank&quot;&gt;下载附件&lt;/a&gt;&amp;#13;
&amp;#13;
 &lt;a href=&quot;http://www.52im.net/&quot; id=&quot;savephoto_13762&quot; url=&quot;home.php?mod=spacecp&amp;amp;ac=album&amp;amp;op=saveforumphoto&amp;amp;aid=13762&amp;amp;handlekey=savephoto_13762&quot;&gt;保存到相册&lt;/a&gt;&amp;#13;
&amp;#13;
&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;p class=&quot;xg1 y&quot;&gt;&lt;span title=&quot;2022-09-23 13:04&quot;&gt;10 天前&lt;/span&gt; 上传&lt;/p&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;p class=&quot;tip_horn&quot;/&gt;&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/ignore_js_op&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;strong&gt;如上图所示：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;应用设备指纹生成：可以用上文阐述的 napi-rs 方案去实现；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;用户认证信息和设备指纹绑定：使用服务端去实现。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
&lt;h3 class=&quot;dc_h3&quot;&gt;&lt;span&gt;9.6&lt;/span&gt;编码安全&lt;/h3&gt;&lt;br/&gt;&amp;#13;
&lt;strong&gt;主要有以下措施：&lt;/strong&gt;&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
&lt;ul&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/i&gt;常用的 web 安全，比如防 xss 、 csrf；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/i&gt;设置 node 可执行环境；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/i&gt;窗体开启安全选项；&lt;/li&gt;&lt;li&gt;&lt;i&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/i&gt;限制链接跳转。&lt;br/&gt;&amp;#13;
&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&amp;#13;
以上具体细节不再介绍，自行搜索上述方案。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
除此之外，还有个官方推荐的最佳安全实践，有空可以看看，地址如下：&lt;a href=&quot;https://www.electronjs.org/docs/latest/tutorial/security&quot; target=&quot;_blank&quot;&gt;https://www.electronjs.org/docs/latest/tutorial/security&lt;/a&gt;。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
至此，安全性这块实践就介绍完了。&lt;br/&gt;&amp;#13;
&lt;h2 class=&quot;dc_h2&quot;&gt;10、本文小结&lt;/h2&gt;&lt;br/&gt;&amp;#13;
本文介绍了我们对跨系统桌面端技术的调研、确定技术选型，以及用 electron 开发过程中，总结的实践经验及踩坑填坑过程，如构建、性能优化、质量保障、安全等。&lt;br/&gt;&amp;#13;
&lt;br/&gt;&amp;#13;
希望对读者在开发跨端桌面应用过程中有所帮助，文章难免有不足和错误的地方，欢迎读者评论。&lt;br/&gt;&amp;#13;
&lt;h2 class=&quot;dc_h2&quot;&gt;11、参考资料&lt;/h2&gt;&lt;br/&gt;&amp;#13;
[1] &lt;a href=&quot;https://www.electronjs.org/zh/docs/latest&quot; target=&quot;_blank&quot;&gt;Electron官方开发者手册&lt;/a&gt;&lt;br/&gt;&amp;#13;
[2] &lt;a href=&quot;http://www.52im.net/thread-2616-1-1.html&quot; target=&quot;_blank&quot;&gt;快速了解新一代跨平台桌面技术——Electron&lt;/a&gt;》&lt;br/&gt;&amp;#13;
[3] &lt;a href=&quot;http://www.52im.net/thread-4039-1-1.html&quot; target=&quot;_blank&quot;&gt;Electron初体验(快速开始、跨进程通信、打包、踩坑等)&lt;/a&gt;&lt;br/&gt;&amp;#13;
[4] &lt;a href=&quot;https://blog.csdn.net/qq_39235055/article/details/111995373&quot; target=&quot;_blank&quot;&gt;Electron 基础入门 简单明了，看完啥都懂了&lt;/a&gt;&lt;br/&gt;&amp;#13;
[5] &lt;a href=&quot;http://www.52im.net/thread-3651-1-1.html&quot; target=&quot;_blank&quot;&gt;网易云信Web端IM的聊天消息全文检索技术实践&lt;/a&gt;&lt;/td&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>95add56bbae3838e81000c4cdd281369</guid>
<title>干货｜十分钟读懂字节跳动的 Doris 湖仓分析实践</title>
<link>https://toutiao.io/k/ovsrlzz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34629629629629627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r1mQp3by2Sld0NkibWF5Vsz1LQe1HgegziaWJguUStKR8snibKMUNeVjHNicJqPIDDJs7osvkLGjRnoBg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;本文为字节跳动数据平台研发工程师在DataFunSummit大会演讲实录，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;关注字节跳动数据平台微信公众号，回复【0929】，领取本次分享PPT。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r0iaam0Y3z0iaV3ak0jib0hf2JTr0JNSbZIGpzpan9EAkNsKP0JBoQgRsqDpnxbFYcezyOwCDBPQQicLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;文 | 军令 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;来自字节跳动数据平台E-MapReduce团队&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;Doris简介&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Doris是一种MPP架构的分析型数据库，主要面向多维分析，数据报表，用户画像分析等场景。自带分析引擎和存储引擎，支持向量化执行引擎，不依赖其他组件，兼容MySQL协议。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Apache Doris具备以下几个特点：&lt;/span&gt;&lt;/section&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;良好的架构设计，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;支持高并发低延时的查询服务，支持高吞吐量的交互式分析。多FE均可对外提供服务，并发增加时，线性扩充FE和BE即可支持高并发的查询请求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;支持批量数据load和流式数据load，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;支持数据更新。支持Update/Delete语法，unique/aggregate数据模型，支持动态更新数据，实时更新聚合指标。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;提供了高可用，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;容错处理，高扩展的企业级特性。FE Leader错误异常，FE Follower秒级切换为新Leader继续对外提供服务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;支持聚合表和物化视图。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;多种数据模型，支持aggregate，replace等多种数据模型，支持创建rollup表，支持创建物化视图。rollup表和物化视图支持动态更新，无需用户手动处理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;MySQL协议兼容，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;支持直接使用MySQL客户端连接，非常易用的数据应用对接。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;Doris由Frontend（以下简称FE）和Backend（以下简称BE）组成，其中FE负责接受用户请求，编译，优化，分发执行计划，元数据管理，BE节点的管理等功能，BE负责执行由FE下发的执行计划，存储和管理用户数据。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5808383233532934&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r0iaam0Y3z0iaV3ak0jib0hf2JhvSwrTyGcHY7syAmmt7iaQgcTkrd1k1WSsLtdm6XicfibZoy7Ex3t5JfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1336&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;数据湖格式Hudi简介&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Hudi是下一代流式数据湖平台，为数据湖提供了表格式管理的能力，提供事务，ACID，MVCC，数据更新删除，增量数据读取等功能。支持Spark，Flink，Presto，Trino等多种计算引擎。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.48359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r0iaam0Y3z0iaV3ak0jib0hf2JobR98Po2MvEibrhS28OkPIystMuTFJn9Zib1oibrOURkgQFA7ETArlJ7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hudi根据数据更新时行为不同分为两种表类型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r0iaam0Y3z0iaV3ak0jib0hf2JicjwmCAkm98mpfhxu7fxQiaSm2dtdRQlo54QH5FapFOWQ1mmIFIs52eQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;针对Hudi的两种表格式，存在3种不同的查询类型：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r0iaam0Y3z0iaV3ak0jib0hf2JJAz7EvUibJcYcronuG4s7tXCl23g615teKkDXT6VWqYsRibqb2k9aNOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;Doris分析Hudi数据的技术背景&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在数仓业务中，随着业务对数据实时性的要求越来越高，T+1数仓业务逐渐往小时级，分钟级，甚至秒级演进。实时数仓的应用也越来越广，也经历了多个发展阶段。目前存在着多种解决方案。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;Lambda架构&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Lambda将数据处理流分为在线分析和离线分析分为两条不同的处理路径，两条路径互相独立，互不影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;离线分析处理T+1数据，使用Hive/Spark处理大数据量，不可变数据，数据一般存储在HDFS等系统上。如果遇到数据更新，需要overwrite整张表或整个分区，成本比较高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在线分析处理实时数据，使用Flink/Spark Streaming处理流式数据，分析处理秒级或分钟级流式数据，数据保存在Kafka或定期（分钟级）保存到HDFS中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该套方案存在以下缺点：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;Kappa架构&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;随着在线分析业务越来越多，Lambda架构的弊端就越来越明显，增加一个指标需要在线离线分别开发，维护困难，离线指标可能和在线指标对不齐，部署复杂，组件繁多。于是Kappa架构应运而生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kappa架构使用一套架构处理在线数据和离线数据，使用同一套引擎同时处理在线和离线数据，数据存储在消息队列上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kappa架构也有一定的局限：&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;基于数据湖的实时数仓&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;针对Lambda架构和Kappa架构的缺陷，业界基于数据湖开发了Iceberg, Hudi, DeltaLake这些数据湖技术，使得数仓支持ACID, Update/Delete, 数据Time Travel, Schema Evolution等特性，使得数仓的时效性从小时级提升到分钟级，数据更新也支持部分更新，大大提高了数据更新的性能。兼具流式计算的实时性和批计算的吞吐量，支持的是近实时的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上方案中其中基于数据湖的应用最广，但数据湖模式无法支撑更高的秒级实时性，也无法直接对外提供数据服务，需要搭建其他的数据服务组件，系统较为复杂。基于此背景下，部分业务开始使用Doris来承接，业务数据分析师需要对Doris与Hudi中的数据进行联邦分析，此外在Doris对外提供数据服务时既要能查询Doris中数据，也要能加速查询离线业务中的数据湖数据，因此我们开发了Doris访问数据湖Hudi中数据的特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;Doris分析Hudi数据的设计原理&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;基于以上背景，我们设计了Apache Doris中查询数据湖格式Hudi数据，因Hudi生态为java语言，而Apache Doris的执行节点BE为C++环境，而C++ 无法直接调用Hudi java SDK，针对这一点，我们有四种解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;实现Hudi C++ client，在BE中直接调用Hudi C++ client去读写Hudi表。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;该方案需要完整实现一套Hudi C++ client，开发周期较长，后期Hudi行为变更需要同步修改Hudi C++ client，维护较为困难。&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;BE通过thrift协议发送读写请求至Broker，由Broker调用Hudi java client读取Hudi表。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;该方案需要在Broker中增加读写Hudi数据的功能，目前Broker定位仅为fs的操作接口，引入Hudi打破了Broker的定位。第二，数据需要在BE和Broker之间传输，性能较低。&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;在BE中使用JNI创建JVM，加载Hudi java client去读写Hudi表。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;该方案需要在BE进程中维护JVM，有JVM调用Hudi java client对Hudi进行读写。读写逻辑使用Hudi社区java实现，可以维护与社区同步；同时数据在同一个进程中进行处理，性能较高。但需要在BE维护一个JVM，管理较为复杂。&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用BE arrow parquet c++ api读取hudi parquet base file，hudi表中的delta file暂不处理。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;该方案可以由BE直接读取hudi表的parquet文件，性能最高。但当前不支持base file和delta file的合并读取，因此仅支持COW表Snapshot Queries和MOR表的Read Optimized Queries，不支持Incremental Queries。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上，我们选择方案四，第一期实现了COW表Snapshot Queries和MOR表的Read Optimized Queries，后面联合Hudi社区开发base file和delta file合并读取的C++接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;Doris分析Hudi数据的技术实现&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h1/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Doris中查询分析Hudi外表使用步骤非常简单。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;创建Hudi外表&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;建表时指定engine为Hudi，同时指定Hudi外表的相关信息，如hive metastore uri，在hive metastore中的database和table名字等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;建表仅仅在Doris的元数据中增加一张表，无任何数据移动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;建表时支持指定全部或部分hudi schema，也支持不指定schema创建hudi外表。指定schema时必须与hiveMetaStore中hudi表的列名，类型一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Example：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   CREATE TABLE example_db.t_hudi &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ENGINE=HUDI&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    PROPERTIES (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;hudi.database&quot; = &quot;hudi_db&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;hudi.table&quot; = &quot;hudi_table&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;hudi.hive.metastore.uris&quot;  =  &quot;thrift://127.0.0.1:9083&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CREATE TABLE example_db.t_hudi (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    column1 int,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    column2 string)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ENGINE=HUDI&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    PROPERTIES (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;hudi.database&quot; = &quot;hudi_db&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;hudi.table&quot; = &quot;hudi_table&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;hudi.hive.metastore.uris&quot;  =  &quot;thrift://127.0.0.1:9083&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    );&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;查询Hudi外表&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7404092071611253&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r0iaam0Y3z0iaV3ak0jib0hf2Jg8uZJtrnNwcHwxqibKLPPj5zKBicHohueibswv1chsf3eEiaroBAoYavtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1564&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;后期规划&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;目前Apche Doris查询Hudi表已合入社区，当前已支持COW表的Snapshot Query，支持MOR表的Read Optimized Query。对MOR表的Snapshot Query暂时还未支持，流式场景中的Incremental Query也没有支持。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后续还有几项工作需要处理，我们和社区也在积极合作进行中：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MOR表的Snapshot Query。MOR表实时读需要合并读取Data file与对应的Delta file，BE需要支持Delta file AVRO格式的读取，需要增加avro的native读取方式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;COW/MOR表的Incremental Query。支持实时业务中的增量读取。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BE读取Hudi base file和delta file的native接口。目前BE读取Hudi数据时，仅能读取data file，使用的是parquet的C++ SDK。后期我们和联合Hudi社区提供Huid base file和delta file的C++/Rust等语言的读取接口，在Doris BE中直接使用native接口来查询Hudi数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-1&quot;/&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;本文为字节跳动数据平台研发工程师在DataFunSummit大会演讲实录，&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关注字节跳动数据平台微信公众号，回复【0929】，领取本次分享PPT。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;span&gt;产品介绍&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;火山引擎 E-MapReduce&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;支持构建开源Hadoop生态的企业级大数据分析系统，完全兼容开源，提供 Hadoop、Spark、Hive、Flink集成和管理，帮助用户轻松完成企业大数据平台的构建，降低运维门槛，快速形成大数据分析能力。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;后台回复数字“3”了解产品&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;40&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/jC2t9Zib67r2rAVRBzMMF9nV9BqFPOhzHwu1XL92AFW8jK9zAQXmo5FcO2W6Ce3ld46owl9H8H1toPneEsh4mNA/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;阅读原文，&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;立即跳&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;转火山引擎&lt;span&gt;E-MapReduce&lt;/span&gt;官网了&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;解详情&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34629629629629627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r1mQp3by2Sld0NkibWF5Vsz1LQe1HgegziaWJguUStKR8snibKMUNeVjHNicJqPIDDJs7osvkLGjRnoBg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8a5dfc18754c4caf11d0daea43bfe772</guid>
<title>专注于性能的 SolidJS</title>
<link>https://toutiao.io/k/evt2bgp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SolidJS 一个用于构建用户界面，简单高效、性能卓越的 JavaScript 库。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;性能-始终在UI速度和内存利用率基准测试中名列前茅&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强大-可组合的响应式原语与 JSX 的灵活性相结合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实用-合理且量身定制的 API 使开发变得有趣而简单。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产力-人体工程化设计和熟悉程度使得构建简单或复杂的东西变得轻而易举。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2MjcxNTQ0Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V0dLQzNJW15CVaCoNjposvTpccciaj05o5nPiaqfLRRfTQiaYFYPN41Etrrqt8jPOWukPmJWt3lYxwuA/0?wx_fmt=png&quot; data-nickname=&quot;全栈修仙之路&quot; data-alias=&quot;FerRoad&quot; data-signature=&quot;专注分享 TS、Vue3、前端架构和源码解析等技术干货。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;专注于性能&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能仅次于原生JS&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7167449139280125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/T81bAV0NNN9rPEWTIEia5Tuv3NIIYp9xibZDRvwmaQbFkfRo9UYzr1ttN4yq395mg5Xf2GPEt3Q0TJgJYZVbO24w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2556&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;一个简单的例子&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render } from &lt;span&gt;&quot;solid-js/web&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;const App = () =&amp;gt; &amp;lt;div&amp;gt; hello solidjs!&amp;lt;/div&amp;gt;&lt;br/&gt;&lt;br/&gt;render(() =&amp;gt; &amp;lt;App/&amp;gt;, document.getElementById(&lt;span&gt;&quot;app&quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写过react的应该很熟悉这段代码，jsx片段，render函数。会让你感觉既熟悉又现代。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;响应式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;createSignal&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render } from &lt;span&gt;&quot;solid-js/web&quot;&lt;/span&gt;;&lt;br/&gt;import { createSignal } from &lt;span&gt;&quot;solid-js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;Counter&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    const [count, setCount] = createSignal(0);&lt;br/&gt;    setInterval(() =&amp;gt; setCount(count() + 1), 1000);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;{count()}&amp;lt;/div&amp;gt;;&lt;br/&gt;}&lt;br/&gt;    &lt;br/&gt;render(() =&amp;gt; &amp;lt;Counter /&amp;gt;, document.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;signal是solid中基本的响应单元，createSignal类似react中的useState,传递给createSignal调用的参数是初始值，createSignal返回一个两个==函数==的数组，第一个getter，第二个是setter，第一个返回的值是一个getter而不是一个值，使用的时候需要调用，框架拦截读取值的任何位置来进行自动跟踪，从而响应式更新，所以调用getter的位置很重要，和react不同的是，例如setState触发更新，react会生成Fiber树，进行diff算法，最后执行dom操作。solid则是直接调用编译好的dom操作方法，没有虚拟dom比较。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;createEffect&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render } from &lt;span&gt;&#x27;solid-js/web&#x27;&lt;/span&gt;;&lt;br/&gt;import { createSignal, createEffect } from &lt;span&gt;&#x27;solid-js&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;Counter&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    const [count, setCount] = createSignal(0);&lt;br/&gt;    &lt;br/&gt;    createEffect(() =&amp;gt; {&lt;br/&gt;        console.log(&lt;span&gt;&#x27;count is :&#x27;&lt;/span&gt;, count())&lt;br/&gt;    })&lt;br/&gt;    &lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;lt;button onClick={() =&amp;gt; setCount(count() + 1)}&amp;gt;Click me&amp;lt;/button&amp;gt;;&lt;br/&gt;}&lt;br/&gt;    &lt;br/&gt;render(() =&amp;gt; &amp;lt;Counter /&amp;gt;, document.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;createEffect接收一个函数，监听其执行情况，createEffect会自动订阅在执行期间读取的所有Signal，并在Signal值之一发生改变的时候，重新运行此函数。count更改的时候，createEffect函数就会运行，从而点击一次，就打印一次结果。类似react的useEffect&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;useEffect(() =&amp;gt; {/*....*/}, [count])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;衍生Signal&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render } from &lt;span&gt;&quot;solid-js/web&quot;&lt;/span&gt;;&lt;br/&gt;import { createSignal } from &lt;span&gt;&quot;solid-js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;Counter&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    const [count, setCount] = createSignal(0);&lt;br/&gt;    &lt;br/&gt;    const doubleCount = () =&amp;gt; count() * 2&lt;br/&gt;    &lt;br/&gt;    setInterval(() =&amp;gt; setCount(count() + 1), 1000);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;Count: {doubleCount()}&amp;lt;/div&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;render(() =&amp;gt; &amp;lt;Counter /&amp;gt;, document.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次没有直接使用count(), 而是使用了doubleCount函数包了一层count() * 2, 日志正常打印2倍的count(), 意味着任何包装count()的函数，都是一个Signal，访问JSX中的js表达式也是，只要访问一个signal，就会触发更新。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Props&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Props是组件执行的时候传进来的对象，Props是只读的，并且具备对象getter的响应性的，但是响应性，只能通过props.propsName的形式来访问，才能被追踪到。不能解构props，解构就会脱离追踪范围而失去响应。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;默认Props&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// greeting.jsx&lt;br/&gt;import { mergeProps } from &lt;span&gt;&quot;solid-js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default &lt;span&gt;function&lt;/span&gt; Greeting(props) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;lt;h3&amp;gt;{props.greeting || &lt;span&gt;&quot;Hi&quot;&lt;/span&gt;} {props.name || &lt;span&gt;&quot;John&quot;&lt;/span&gt;}&amp;lt;/h3&amp;gt;&lt;br/&gt;&lt;br/&gt;    &amp;lt;!--const { greeting, name } = props--&amp;gt;&lt;br/&gt;    &amp;lt;!--&lt;span&gt;return&lt;/span&gt; &amp;lt;h3&amp;gt;{greeting || &lt;span&gt;&#x27;Hi&#x27;&lt;/span&gt;} {name || &lt;span&gt;&#x27;John&#x27;&lt;/span&gt;}&amp;lt;/h3&amp;gt;--&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// main.jsx&lt;br/&gt;&lt;br/&gt;import { render } from &lt;span&gt;&quot;solid-js/web&quot;&lt;/span&gt;;&lt;br/&gt;import { createSignal } from &lt;span&gt;&quot;solid-js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;import Greeting from &lt;span&gt;&quot;./greeting&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;App&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  const [name, setName] = createSignal();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;lt;&amp;gt;&lt;br/&gt;    &amp;lt;Greeting greeting=&lt;span&gt;&quot;Hello&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;Greeting name=&lt;span&gt;&quot;Jeremy&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;Greeting name={name()} /&amp;gt;&lt;br/&gt;    &amp;lt;button onClick={() =&amp;gt; setName(&lt;span&gt;&quot;Jarod&quot;&lt;/span&gt;)}&amp;gt;Set Name&amp;lt;/button&amp;gt;&lt;br/&gt;  &amp;lt;/&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;render(() =&amp;gt; &amp;lt;App /&amp;gt;, document.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然SolidJS也是提供了一个工具函数mergeProps，使得具有响应性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// greeting.jsx&lt;br/&gt;import { mergeProps } from &lt;span&gt;&quot;solid-js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default &lt;span&gt;function&lt;/span&gt; Greeting(props) {&lt;br/&gt;  const merged = mergeProps({ greeting: &lt;span&gt;&quot;Hi&quot;&lt;/span&gt;, name: &lt;span&gt;&quot;John&quot;&lt;/span&gt; }, props)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;lt;h3&amp;gt;{merged.greeting} {merged.name}&amp;lt;/h3&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分离Props&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;合并props用到的地方很少，我们经常用到的是解构组件传进来的props，然后将其他props分离出来，再传递下去。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// greeting.jsx&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default &lt;span&gt;function&lt;/span&gt; Greeting(props) {&lt;br/&gt;  const { greeting, name, ...others } = props;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;lt;h3 {...others}&amp;gt;{greeting} {name}&amp;lt;/h3&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接解构分离，设置name的时候，不会更新，也就是解构的时候失去了响应性。但是solid为我们提供了分离props的函数splitProps，来保持响应性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// greeting.jsx&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default &lt;span&gt;function&lt;/span&gt; Greeting(props) {&lt;br/&gt;  const [&lt;span&gt;local&lt;/span&gt;, others] = splitProps(props, [&lt;span&gt;&quot;greeting&quot;&lt;/span&gt;, &lt;span&gt;&quot;name&quot;&lt;/span&gt;]);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;lt;h3 {...others}&amp;gt;{local.greeting} {local.name}&amp;lt;/h3&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Store&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内嵌式响应&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;solid可以独立处理嵌套更新，是因为它提供了一细粒度响应式，也就是哪里需要更新，就更新哪里，指哪打哪。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render } from &lt;span&gt;&quot;solid-js/web&quot;&lt;/span&gt;;&lt;br/&gt;import { For, createSignal } from &lt;span&gt;&quot;solid-js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;const App = () =&amp;gt; {&lt;br/&gt;  const [todos, setTodos] = createSignal([])&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; input;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; todoId = 0;&lt;br/&gt;&lt;br/&gt;  const addTodo = (text) =&amp;gt; {&lt;br/&gt;    // setTodos([...todos(), { id: ++todoId, text, completed: &lt;span&gt;false&lt;/span&gt; }]);&lt;br/&gt;    const [completed, setCompleted] = createSignal(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;    setTodos([...todos(), { id: ++todoId, text, completed, setCompleted }]);&lt;br/&gt;  }&lt;br/&gt;  const toggleTodo = (id) =&amp;gt; {&lt;br/&gt;    // setTodos(todos().map((todo) =&amp;gt; (&lt;br/&gt;    //   todo.id !== id ? todo : { ...todo, completed: !todo.completed }&lt;br/&gt;    // )));&lt;br/&gt;    const index = todos().findIndex((t) =&amp;gt; t.id === id);&lt;br/&gt;    const todo = todos()[index];&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (todo) todo.setCompleted(!todo.completed())&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;&amp;gt;&lt;br/&gt;      &amp;lt;div&amp;gt;&lt;br/&gt;        &amp;lt;input ref={input} /&amp;gt;&lt;br/&gt;        &amp;lt;button&lt;br/&gt;          onClick={(e) =&amp;gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!input.value.trim()) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            addTodo(input.value);&lt;br/&gt;            input.value = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;          }}&lt;br/&gt;        &amp;gt;&lt;br/&gt;          Add Todo&lt;br/&gt;        &amp;lt;/button&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;      &amp;lt;For each={todos()}&amp;gt;&lt;br/&gt;        {(todo) =&amp;gt; {&lt;br/&gt;          const { id, text } = todo;&lt;br/&gt;          console.log(`Creating &lt;span&gt;${text}&lt;/span&gt;`)&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;&lt;br/&gt;            &amp;lt;input&lt;br/&gt;              &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;checkbox&quot;&lt;/span&gt;&lt;br/&gt;              checked={todo.completed}&lt;br/&gt;              onchange={[toggleTodo, id]}&lt;br/&gt;            /&amp;gt;&lt;br/&gt;            &amp;lt;span&lt;br/&gt;              style={{ &quot;text-decoration&quot;: todo.completed ? &quot;line-through&quot; : &quot;none&quot;}}&lt;br/&gt;            &amp;gt;{text}&amp;lt;/span&amp;gt;&lt;br/&gt;          &amp;lt;/div&amp;gt;&lt;br/&gt;        }}&lt;br/&gt;      &amp;lt;/For&amp;gt;&lt;br/&gt;    &amp;lt;/&amp;gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;render(App, document.getElementById(&lt;span&gt;&quot;app&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种方式，第一种是追踪todos()更新，效果是新增的时候会触发渲染，等到toggleTodo的时候还是会触发渲染，第二种是，嵌套更新，追踪对象的属性completed(), 新增的时候追踪todos()变化，渲染dom，等到toggleTodo的时候，只会触发数据更新，dom已经渲染了，没有必要再次渲染了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建store&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;store是代理对象，属性可以被跟踪，那么是不是可以实现内嵌式响应，createStore接收一个初始值，返回一个类似于signal的读/写的两个元素，第一个是元素只读的store代理，第二个是setter函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render } from &lt;span&gt;&quot;solid-js/web&quot;&lt;/span&gt;;&lt;br/&gt;import { For, createSignal } from &lt;span&gt;&quot;solid-js&quot;&lt;/span&gt;;&lt;br/&gt;import { createStore } from &lt;span&gt;&quot;solid-js/store&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;const App = () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; input;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; todoId = 0;&lt;br/&gt;  const [store, setStore] = createStore({ todos: [] });&lt;br/&gt;  const addTodo = (text) =&amp;gt; {&lt;br/&gt;    setStore(&lt;span&gt;&#x27;todos&#x27;&lt;/span&gt;, (todos) =&amp;gt; [...todos, { id: ++todoId, text, completed: &lt;span&gt;false&lt;/span&gt; }]);&lt;br/&gt;    };&lt;br/&gt;  const toggleTodo = (id) =&amp;gt; {&lt;br/&gt;    setStore(&lt;span&gt;&#x27;todos&#x27;&lt;/span&gt;, (t) =&amp;gt; t.id === id, &lt;span&gt;&#x27;completed&#x27;&lt;/span&gt;, (completed) =&amp;gt; !completed);&lt;br/&gt;    };&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;&amp;gt;&lt;br/&gt;      &amp;lt;div&amp;gt;&lt;br/&gt;        &amp;lt;input ref={input} /&amp;gt;&lt;br/&gt;        &amp;lt;button&lt;br/&gt;          onClick={(e) =&amp;gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!input.value.trim()) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            addTodo(input.value);&lt;br/&gt;            input.value = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;          }}&lt;br/&gt;        &amp;gt;&lt;br/&gt;          Add Todo&lt;br/&gt;        &amp;lt;/button&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;      &amp;lt;For each={store.todos}&amp;gt;&lt;br/&gt;        {(todo) =&amp;gt; {&lt;br/&gt;          const { id, text } = todo;&lt;br/&gt;          console.log(`Creating &lt;span&gt;${text}&lt;/span&gt;`)&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;&lt;br/&gt;            &amp;lt;input&lt;br/&gt;              &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;checkbox&quot;&lt;/span&gt;&lt;br/&gt;              checked={todo.completed}&lt;br/&gt;              onchange={[toggleTodo, id]}&lt;br/&gt;            /&amp;gt;&lt;br/&gt;            &amp;lt;span&lt;br/&gt;              style={{ &quot;text-decoration&quot;: todo.completed ? &quot;line-through&quot; : &quot;none&quot;}}&lt;br/&gt;            &amp;gt;{text}&amp;lt;/span&amp;gt;&lt;br/&gt;          &amp;lt;/div&amp;gt;&lt;br/&gt;        }}&lt;br/&gt;      &amp;lt;/For&amp;gt;&lt;br/&gt;    &amp;lt;/&amp;gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;render(App, document.getElementById(&lt;span&gt;&quot;app&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;内置组件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Show&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;条件渲染&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render } from &lt;span&gt;&#x27;solid-js/web&#x27;&lt;/span&gt;;&lt;br/&gt;import { createSignal, Show } from &lt;span&gt;&#x27;solid-js&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;App&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  const [loggedIn, setLoggedIn] = createSignal(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;  const toggle = () =&amp;gt; setLoggedIn(!loggedIn())&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;Show&lt;br/&gt;        when={loggedIn()}&lt;br/&gt;        fallback={() =&amp;gt; &amp;lt;button onClick={toggle}&amp;gt;Log &lt;span&gt;in&lt;/span&gt;&amp;lt;/button&amp;gt;}&lt;br/&gt;        &amp;gt;&lt;br/&gt;        &amp;lt;button onClick={toggle}&amp;gt;Log out&amp;lt;/button&amp;gt;&lt;br/&gt;    &amp;lt;/Show&amp;gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;render(() =&amp;gt; &amp;lt;App /&amp;gt;, document.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;For&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;循环遍历,数据是固定的，index是可追踪的signal，涉及到dom移动的时候，不会触发重新创建dom。只是index独立更新，数据并不会更新。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render } from &lt;span&gt;&#x27;solid-js/web&#x27;&lt;/span&gt;;&lt;br/&gt;import { createSignal, For } from &lt;span&gt;&#x27;solid-js&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;App&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  const [cats, setCats] = createSignal([&lt;br/&gt;  { id: &lt;span&gt;&#x27;J---aiyznGQ&#x27;&lt;/span&gt;, name: &lt;span&gt;&#x27;Keyboard Cat&#x27;&lt;/span&gt; },&lt;br/&gt;  { id: &lt;span&gt;&#x27;z_AbfPXTKms&#x27;&lt;/span&gt;, name: &lt;span&gt;&#x27;Maru&#x27;&lt;/span&gt; },&lt;br/&gt;  { id: &lt;span&gt;&#x27;OUtn3pvWmpg&#x27;&lt;/span&gt;, name: &lt;span&gt;&#x27;Henri The Existential Cat&#x27;&lt;/span&gt; }&lt;br/&gt; ]);&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;ul&amp;gt;&lt;br/&gt;      &amp;lt;For each={cats()}&amp;gt;&lt;br/&gt;  {(cat, i) =&amp;gt; (&lt;br/&gt;    &amp;lt;li&amp;gt;&lt;br/&gt;      &amp;lt;a target=&lt;span&gt;&quot;_blank&quot;&lt;/span&gt; href={`https://www.youtube.com/watch?v=&lt;span&gt;${cat.id}&lt;/span&gt;`}&amp;gt;&lt;br/&gt;        {i() + 1}: {cat.name}&lt;br/&gt;      &amp;lt;/a&amp;gt;&lt;br/&gt;    &amp;lt;/li&amp;gt;&lt;br/&gt;  )}&lt;br/&gt;&amp;lt;/For&amp;gt;&lt;br/&gt;    &amp;lt;/ul&amp;gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;render(() =&amp;gt; &amp;lt;App /&amp;gt;, document.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Index&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Index和For不同的是，Index是数据项是signal，索引是固定的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render } from &lt;span&gt;&#x27;solid-js/web&#x27;&lt;/span&gt;;&lt;br/&gt;import { createSignal, Index } from &lt;span&gt;&#x27;solid-js&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;App&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  const [cats, setCats] = createSignal([&lt;br/&gt;  { id: &lt;span&gt;&#x27;J---aiyznGQ&#x27;&lt;/span&gt;, name: &lt;span&gt;&#x27;Keyboard Cat&#x27;&lt;/span&gt; },&lt;br/&gt;  { id: &lt;span&gt;&#x27;z_AbfPXTKms&#x27;&lt;/span&gt;, name: &lt;span&gt;&#x27;Maru&#x27;&lt;/span&gt; },&lt;br/&gt;  { id: &lt;span&gt;&#x27;OUtn3pvWmpg&#x27;&lt;/span&gt;, name: &lt;span&gt;&#x27;Henri The Existential Cat&#x27;&lt;/span&gt; }&lt;br/&gt; ]);&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;ul&amp;gt;&lt;br/&gt;      &amp;lt;Index each={cats()}&amp;gt;&lt;br/&gt;  {(cat, i) =&amp;gt; (&lt;br/&gt;    &amp;lt;li&amp;gt;&lt;br/&gt;      &amp;lt;a target=&lt;span&gt;&quot;_blank&quot;&lt;/span&gt; href={`https://www.youtube.com/watch?v=&lt;span&gt;${cat().id}&lt;/span&gt;`}&amp;gt;&lt;br/&gt;        {i + 1}: {cat().name}&lt;br/&gt;      &amp;lt;/a&amp;gt;&lt;br/&gt;    &amp;lt;/li&amp;gt;&lt;br/&gt;  )}&lt;br/&gt;&amp;lt;/Index&amp;gt;&lt;br/&gt;    &amp;lt;/ul&amp;gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;render(() =&amp;gt; &amp;lt;App /&amp;gt;, document.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Switch&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;处理互斥条件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render } from &lt;span&gt;&quot;solid-js/web&quot;&lt;/span&gt;;&lt;br/&gt;import { createSignal, Show, Switch, Match } from &lt;span&gt;&quot;solid-js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;App&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  const [x] = createSignal(7);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    //使用show实现&lt;br/&gt;    &amp;lt;!--&amp;lt;Show--&amp;gt;&lt;br/&gt;    &amp;lt;!--  when={x() &amp;gt; 10}--&amp;gt;&lt;br/&gt;    &amp;lt;!--  fallback={--&amp;gt;&lt;br/&gt;    &amp;lt;!--    &amp;lt;Show--&amp;gt;&lt;br/&gt;    &amp;lt;!--      when={5 &amp;gt; x()}--&amp;gt;&lt;br/&gt;    &amp;lt;!--      fallback={&amp;lt;p&amp;gt;{x()} is between 5 and 10&amp;lt;/p&amp;gt;}--&amp;gt;&lt;br/&gt;    &amp;lt;!--    &amp;gt;--&amp;gt;&lt;br/&gt;    &amp;lt;!--      &amp;lt;p&amp;gt;{x()} is less than 5&amp;lt;/p&amp;gt;--&amp;gt;&lt;br/&gt;    &amp;lt;!--    &amp;lt;/Show&amp;gt;--&amp;gt;&lt;br/&gt;    &amp;lt;!--  }--&amp;gt;&lt;br/&gt;    &amp;lt;!--&amp;gt;--&amp;gt;&lt;br/&gt;    &amp;lt;!--  &amp;lt;p&amp;gt;{x()} is greater than 10&amp;lt;/p&amp;gt;--&amp;gt;&lt;br/&gt;    &amp;lt;!--&amp;lt;/Show&amp;gt;--&amp;gt;&lt;br/&gt;    //使用Switch实现&lt;br/&gt;    &amp;lt;Switch fallback={&amp;lt;p&amp;gt;{x()} is between 5 and 10&amp;lt;/p&amp;gt;}&amp;gt;&lt;br/&gt;  &amp;lt;Match when={x() &amp;gt; 10}&amp;gt;&lt;br/&gt;    &amp;lt;p&amp;gt;{x()} is greater than 10&amp;lt;/p&amp;gt;&lt;br/&gt;  &amp;lt;/Match&amp;gt;&lt;br/&gt;  &amp;lt;Match when={5 &amp;gt; x()}&amp;gt;&lt;br/&gt;    &amp;lt;p&amp;gt;{x()} is less than 5&amp;lt;/p&amp;gt;&lt;br/&gt;  &amp;lt;/Match&amp;gt;&lt;br/&gt;&amp;lt;/Switch&amp;gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;render(() =&amp;gt; &amp;lt;App /&amp;gt;, document.getElementById(&lt;span&gt;&quot;app&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Dynamic&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比&lt;code&gt;&amp;lt;Show&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;Switch&amp;gt;&lt;/code&gt; 组件更简练&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render, Dynamic } from &lt;span&gt;&quot;solid-js/web&quot;&lt;/span&gt;;&lt;br/&gt;import { createSignal, Switch, Match, For } from &lt;span&gt;&quot;solid-js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;const RedThing = () =&amp;gt; &amp;lt;strong style=&lt;span&gt;&quot;color: red&quot;&lt;/span&gt;&amp;gt;Red Thing&amp;lt;/strong&amp;gt;;&lt;br/&gt;const GreenThing = () =&amp;gt; &amp;lt;strong style=&lt;span&gt;&quot;color: green&quot;&lt;/span&gt;&amp;gt;Green Thing&amp;lt;/strong&amp;gt;;&lt;br/&gt;const BlueThing = () =&amp;gt; &amp;lt;strong style=&lt;span&gt;&quot;color: blue&quot;&lt;/span&gt;&amp;gt;Blue Thing&amp;lt;/strong&amp;gt;;&lt;br/&gt;&lt;br/&gt;const options = {&lt;br/&gt;  red: RedThing,&lt;br/&gt;  green: GreenThing,&lt;br/&gt;  blue: BlueThing&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;App&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  const [selected, setSelected] = createSignal(&lt;span&gt;&quot;red&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;&amp;gt;&lt;br/&gt;      &amp;lt;select value={selected()} onInput={e =&amp;gt; setSelected(e.currentTarget.value)}&amp;gt;&lt;br/&gt;        &amp;lt;For each={Object.keys(options)}&amp;gt;{&lt;br/&gt;          color =&amp;gt; &amp;lt;option value={color}&amp;gt;{color}&amp;lt;/option&amp;gt;&lt;br/&gt;        }&amp;lt;/For&amp;gt;&lt;br/&gt;      &amp;lt;/select&amp;gt;&lt;br/&gt;      &amp;lt;!--&amp;lt;Switch fallback={&amp;lt;BlueThing /&amp;gt;}&amp;gt;--&amp;gt;&lt;br/&gt;      &amp;lt;!--  &amp;lt;Match when={selected() === &lt;span&gt;&quot;red&quot;&lt;/span&gt;} &amp;gt;&amp;lt;RedThing /&amp;gt;&amp;lt;/Match&amp;gt;--&amp;gt;&lt;br/&gt;      &amp;lt;!--  &amp;lt;Match when={selected() === &lt;span&gt;&quot;green&quot;&lt;/span&gt;}&amp;gt;&amp;lt;GreenThing /&amp;gt;&amp;lt;/Match&amp;gt;--&amp;gt;&lt;br/&gt;      &amp;lt;!--&amp;lt;/Switch&amp;gt;--&amp;gt;&lt;br/&gt;      &amp;lt;Dynamic component={options[selected()]} /&amp;gt;&lt;br/&gt;    &amp;lt;/&amp;gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;render(() =&amp;gt; &amp;lt;App /&amp;gt;, document.getElementById(&lt;span&gt;&quot;app&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;生命周期&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;onMount&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;挂载&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;solid有极少的生命周期，请求数据，以及一些逻辑都写到这个地方，这个函数只会被调用一次。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render } from &lt;span&gt;&quot;solid-js/web&quot;&lt;/span&gt;;&lt;br/&gt;import { createSignal, onMount, For } from &lt;span&gt;&quot;solid-js&quot;&lt;/span&gt;;&lt;br/&gt;import &lt;span&gt;&quot;./styles.css&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;App&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  const [photos, setPhotos] = createSignal([]);&lt;br/&gt;onMount(async () =&amp;gt; {&lt;br/&gt;  const res = await fetch(&lt;br/&gt;    `https://jsonplaceholder.typicode.com/photos?_limit=20`&lt;br/&gt;  );&lt;br/&gt;  setPhotos(await res.json());&lt;br/&gt;});&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;lt;&amp;gt;&lt;br/&gt;    &amp;lt;h1&amp;gt;Photo album&amp;lt;/h1&amp;gt;&lt;br/&gt;&lt;br/&gt;    &amp;lt;div class=&lt;span&gt;&quot;photos&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;      &amp;lt;For each={photos()} fallback={&amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;}&amp;gt;{ photo =&amp;gt;&lt;br/&gt;        &amp;lt;figure&amp;gt;&lt;br/&gt;          &amp;lt;img src={photo.thumbnailUrl} alt={photo.title} /&amp;gt;&lt;br/&gt;          &amp;lt;figcaption&amp;gt;{photo.title}&amp;lt;/figcaption&amp;gt;&lt;br/&gt;        &amp;lt;/figure&amp;gt;&lt;br/&gt;      }&amp;lt;/For&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  &amp;lt;/&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;render(() =&amp;gt; &amp;lt;App /&amp;gt;, document.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;onCleanup&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;卸载时&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { render } from &lt;span&gt;&quot;solid-js/web&quot;&lt;/span&gt;;&lt;br/&gt;import { createSignal, onCleanup } from &lt;span&gt;&quot;solid-js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;Counter&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  const [count, setCount] = createSignal(0);&lt;br/&gt;&lt;br/&gt;  const timer = setInterval(() =&amp;gt; setCount(count() + 1), 1000);&lt;br/&gt;    onCleanup(() =&amp;gt; clearInterval(timer));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;Count: {count()}&amp;lt;/div&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;render(() =&amp;gt; &amp;lt;Counter /&amp;gt;, document.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;没有虚拟DOM。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;响应式跟踪更新，指哪打哪。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持jsx&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写法类似react，上手容易&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0cd857d3dcfe4b3be45b56276bd8ac33</guid>
<title>Rust 太难？那是你没看到这套 Rust 语言学习总结（上）</title>
<link>https://toutiao.io/k/8w3ph2c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;cloud-blog-detail-content blog-content-block-0&quot; id=&quot;blogContent&quot;&gt;&amp;#13;
            &lt;h1&gt;&lt;b&gt;&lt;span&gt;一、&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;开发环境指南&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span&gt; 1.1 Rust&lt;/span&gt;&lt;span&gt;代码执行&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据编译原理知识，编译器不是直接将源语言翻译为目标语言，而是翻译为一种&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;中间语言&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，编译器从业人员称之为&lt;/span&gt;&lt;span&gt;“IR”--&lt;/span&gt;&lt;span&gt;指令集，之后再由中间语言，利用后端程序和设备翻译为目标平台的汇编语言。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;代码执行：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;代码经过分词和解析，生成&lt;/span&gt;&lt;span&gt;AST&lt;/span&gt;&lt;span&gt;（抽象语法树）。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2)&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;然后把&lt;/span&gt;&lt;span&gt;AST&lt;/span&gt;&lt;span&gt;进一步简化处理为&lt;/span&gt;&lt;span&gt;HIR&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;High-level IR&lt;/span&gt;&lt;span&gt;），目的是让编译器更方便的做类型检查。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3)&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;HIR&lt;/span&gt;&lt;span&gt;会进一步被编译为&lt;/span&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Middle IR&lt;/span&gt;&lt;span&gt;），这是一种中间表示，主要目的是：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;a)&lt;/span&gt;&lt;span/&gt;&lt;span&gt;缩短编译时间；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;b)&lt;/span&gt;&lt;span/&gt;&lt;span&gt;缩短执行时间；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;c)&lt;/span&gt;&lt;span/&gt;&lt;span&gt;更精确的类型检查。&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;4)&lt;/span&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;最终&lt;/span&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;会被翻译为&lt;/span&gt;&lt;span&gt;LLVM IR&lt;/span&gt;&lt;span&gt;，然后被&lt;/span&gt;&lt;span&gt;LLVM&lt;/span&gt;&lt;span&gt;的处理编译为能在各个平台上运行的目标机器码。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;IR&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：中间语言&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;HIR&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：高级中间语言&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：中级中间语言&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;LLVM &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;Low Level Virtual Machine&lt;/span&gt;&lt;span&gt;，底层虚拟机。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;LLVM&lt;/span&gt;&lt;span&gt;是构架&lt;/span&gt;&lt;u&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;span&gt;编译器&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/u&gt;&lt;span&gt;(compiler)&lt;/span&gt;&lt;span&gt;的框架系统，以&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;编写而成，用于优化以任意程序语言编写的程序的编译时间&lt;/span&gt;&lt;span&gt;(compile-time)&lt;/span&gt;&lt;span&gt;、链接时间&lt;/span&gt;&lt;span&gt;(link-time)&lt;/span&gt;&lt;span&gt;、运行时间&lt;/span&gt;&lt;span&gt;(run-time)&lt;/span&gt;&lt;span&gt;以及空闲时间&lt;/span&gt;&lt;span&gt;(idle-time)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无疑，不同编译器的中间语言&lt;/span&gt;&lt;span&gt;IR&lt;/span&gt;&lt;span&gt;是不一样的，而&lt;/span&gt;&lt;span&gt;IR&lt;/span&gt;&lt;span&gt;可以说是集中体现了这款编译器的特征：他的算法，优化方式，汇编流程等等，想要完全掌握某种编译器的工作和运行原理，分析和学习这款编译器的中间语言无疑是重要手段。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于中间语言相当于一款编译器前端和后端的&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;桥梁&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，如果我们想进行基于&lt;/span&gt;&lt;span&gt;LLVM&lt;/span&gt;&lt;span&gt;的后端移植，无疑需要开发出对应目标平台的编译器后端，想要顺利完成这一工作，透彻了解&lt;/span&gt;&lt;span&gt;LLVM&lt;/span&gt;&lt;span&gt;的中间语言无疑是非常必要的工作。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LLVM&lt;/span&gt;&lt;span&gt;相对于&lt;/span&gt;&lt;span&gt;gcc&lt;/span&gt;&lt;span&gt;的一大改进就是大大提高了中间语言的生成效率和可读性，&lt;/span&gt;&lt;span&gt; LLVM&lt;/span&gt;&lt;span&gt;的中间语言是一种介于&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;语言和汇编语言的格式，他既有高级语言的可读性，又能比较全面地反映计算机底层数据的运算和传输的情况，精炼而又高效。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;b&gt;&lt;span&gt;1.1.1&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;  &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;是基于控制流图（&lt;/span&gt;&lt;span&gt;Control Flow Graph&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;CFG&lt;/span&gt;&lt;span&gt;）的抽象数据结构，它用&lt;/span&gt;&lt;span&gt;有向图（&lt;/span&gt;&lt;span&gt;DAG&lt;/span&gt;&lt;span&gt;）形式包含了程序执行过程中所有可能的流程&lt;/span&gt;&lt;span&gt;。所以将基于&lt;/span&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;的借用检查称为非词法作用域的生命周期。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;由一下关键部分组成：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;基本块（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Basic block&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;，&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;bb&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，他是控制流图的基本单位，&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;语句（&lt;/span&gt;&lt;span&gt;statement&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;终止句（&lt;/span&gt;&lt;span&gt;Terminator&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;本地变量&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，占中内存的位置，比如函数参数、局部变量等。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;位置（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Place&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，在内存中标识未知的额表达式。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;右值（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;RValue&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，产生值的表达式。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的工作原理见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以在&lt;/span&gt;&lt;span&gt;play.runst-lang.org&lt;/span&gt;&lt;span&gt;中生成&lt;/span&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;代码。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;b&gt;&lt;span&gt;1.1&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;安装&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span&gt;Ø&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;方法一：见&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;官方的&lt;/span&gt;&lt;u&gt;&lt;span&gt;&lt;a rel=&quot;nofollow&quot;&gt;installation&lt;span&gt;章节&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/u&gt;&lt;span&gt;介绍。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上就是调用该命令来安装即可：&lt;/span&gt;&lt;b&gt;&lt;span&gt;curl https://sh.rustup.rs -sSf | sh&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;方法二：下载离线的安装包来安装，具体的可见&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;官方的&lt;/span&gt;&lt;u&gt;&lt;span&gt;&lt;a rel=&quot;nofollow&quot;&gt;Other Rust Installation Methods&lt;span&gt;章节&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/u&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;b&gt;&lt;span&gt;1.2 Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;编译&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;运行&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;1.2.1 Cargo&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;包管理&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中的包管理工具，第三方包叫做&lt;/span&gt;&lt;b&gt;&lt;span&gt;crate&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;/b&gt;&lt;span&gt;一共做了四件事：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;使用两个元数据（&lt;/span&gt;&lt;b&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;/b&gt;&lt;span&gt;）文件来记录各种项目信息&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;获取并构建项目的依赖关系&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;使用正确的参数调用&lt;/span&gt;&lt;b&gt;&lt;span&gt;rustc&lt;/span&gt;&lt;/b&gt;&lt;span&gt;或其他构建工具来构建项目&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;生态系统开发建议了统一标准的工作流&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;b&gt;&lt;span&gt;文件：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Cargo.lock&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：只记录依赖包的详细信息，不需要开发者维护，而是由&lt;/span&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;span&gt;自动维护&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Cargo.toml&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：描述项目所需要的各种信息，包括第三方包的依赖&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;cargo&lt;/span&gt;&lt;span&gt;编译默认为&lt;/span&gt;&lt;b&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;/b&gt;&lt;span&gt;模式，在该模式下编译器不会对代码进行任何优化。也可以使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;--release&lt;/span&gt;&lt;/b&gt;&lt;span&gt;参数来使用发布模式。&lt;/span&gt;&lt;b&gt;&lt;span&gt;release&lt;/span&gt;&lt;/b&gt;&lt;span&gt;模式，编译器会对代码进行优化，使得编译时间变慢，但是代码运行速度会变快。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官方编译器&lt;/span&gt;&lt;b&gt;&lt;span&gt;rustc&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，负责将&lt;/span&gt;&lt;span&gt;rust&lt;/span&gt;&lt;span&gt;源码编译为可执行的文件或其他文件（&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;.so&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;.lib&lt;/span&gt;&lt;span&gt;等）。例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt;rustc box.rs&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;还提供了包管理器&lt;/span&gt;&lt;b&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来管理整个工作流程。例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo new &lt;/span&gt;&lt;/b&gt;&lt;span&gt;first_pro_create&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建名为&lt;/span&gt;&lt;span&gt;first_pro_create&lt;/span&gt;&lt;span&gt;的项目&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo new --lib &lt;/span&gt;&lt;/b&gt;&lt;span&gt;first_lib_create&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建命令&lt;/span&gt;&lt;span&gt;first_lib_create&lt;/span&gt;&lt;span&gt;的库项目&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;cargo doc&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;l&lt;/span&gt;&lt;b&gt;&lt;span&gt;cargo doc --open&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo test&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo test -- --test-threads=1&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo build&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo build --release&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo run&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo install --path&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo uninstall &lt;/span&gt;&lt;/b&gt;&lt;span&gt;first_pro_create&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;cargo new –bin use_regex&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;&lt;img class=&quot;mce_image lazyload&quot; id=&quot;images_160915033098778&quot; src=&quot;https://res.hc-cdn.com/ecology/7.9.205/v2_resources/ydcomm/libs/images/loading.gif&quot; data-src=&quot;https://bbs-img.huaweicloud.com/blogs/img/1609150332903039875.png&quot; referrerpolicy=&quot;no-referrer&quot;/&gt;&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&lt;img class=&quot;mce_image lazyload&quot; id=&quot;images_160915034091142&quot; src=&quot;https://res.hc-cdn.com/ecology/7.9.205/v2_resources/ydcomm/libs/images/loading.gif&quot; data-src=&quot;https://bbs-img.huaweicloud.com/blogs/img/1609150341600035174.png&quot; referrerpolicy=&quot;no-referrer&quot;/&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;1.2.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;使用第三方包&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;可以在&lt;/span&gt;&lt;b&gt;&lt;span&gt;Cargo.toml&lt;/span&gt;&lt;/b&gt;&lt;span&gt;中的&lt;/span&gt;&lt;b&gt;&lt;span&gt;[dependencies]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;下添加想依赖的包来使用第三方包。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后在&lt;/span&gt;&lt;b&gt;&lt;span&gt;src/main.rs&lt;/span&gt;&lt;/b&gt;&lt;span&gt;或&lt;/span&gt;&lt;b&gt;&lt;span&gt;src/lib.rs&lt;/span&gt;&lt;/b&gt;&lt;span&gt;文件中，使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;extern crate&lt;/span&gt;&lt;/b&gt;&lt;span&gt;命令声明引入该包即可使用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;mce_image lazyload&quot; id=&quot;images_160915035931413&quot; src=&quot;https://res.hc-cdn.com/ecology/7.9.205/v2_resources/ydcomm/libs/images/loading.gif&quot; data-src=&quot;https://bbs-img.huaweicloud.com/blogs/img/1609150360012033321.png&quot; referrerpolicy=&quot;no-referrer&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;值得注意的是，使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;extern crate&lt;/span&gt;&lt;/b&gt;&lt;span&gt;声明包的名称是&lt;/span&gt;&lt;span&gt;linked_list&lt;/span&gt;&lt;span&gt;，用的是&lt;/span&gt;&lt;b&gt;&lt;span&gt;下划线&lt;/span&gt;&lt;/b&gt;&lt;span&gt;“&lt;/span&gt;&lt;b&gt;&lt;span&gt;_&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”，而在&lt;/span&gt;&lt;span&gt;Cargo.toml&lt;/span&gt;&lt;span&gt;中用的是&lt;/span&gt;&lt;b&gt;&lt;span&gt;连字符&lt;/span&gt;&lt;/b&gt;&lt;span&gt;“&lt;/span&gt;&lt;b&gt;&lt;span&gt;-&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”。其实&lt;/span&gt;&lt;b&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;默认会把&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;连字符&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;转换成&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;下划线&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;也不建议以“&lt;/span&gt;&lt;b&gt;&lt;span&gt;-rs&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”或“&lt;/span&gt;&lt;b&gt;&lt;span&gt;_rs&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”为后缀来命名包名，而且会强制性的将此后缀去掉。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;323&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;h1&gt;&lt;b&gt;&lt;span&gt;1.4 Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;常用命令&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;b&gt;&lt;span&gt;1.5 Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;命令规范&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;蛇形&lt;/span&gt;&lt;span&gt;命名法（&lt;/span&gt;&lt;span&gt;snake_case&lt;/span&gt;&lt;span&gt;），例如：&lt;/span&gt;&lt;span&gt;func_name()&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;文件名&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;蛇形&lt;/span&gt;&lt;span&gt;命名法（&lt;/span&gt;&lt;span&gt;snake_case&lt;/span&gt;&lt;span&gt;），例如&lt;/span&gt;&lt;span&gt;file_name.rs&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;main.rs&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;临时变量名&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;蛇形&lt;/span&gt;&lt;span&gt;命名法（&lt;/span&gt;&lt;span&gt;snake_case&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;全局变量名&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;结构体&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;大驼峰&lt;/span&gt;&lt;span&gt;命名法，例如：&lt;/span&gt;&lt;span&gt;struct FirstName { name: String}&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;enum&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;:  &lt;/span&gt;&lt;span&gt;大驼峰&lt;/span&gt;&lt;span&gt;命名法。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;关联常量&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：常量名必须全部大写。什么是关联常量见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;Cargo&lt;/span&gt;&lt;span&gt;默认会把&lt;/span&gt;&lt;b&gt;&lt;span&gt;连字符&lt;/span&gt;&lt;/b&gt;&lt;span&gt;“&lt;/span&gt;&lt;b&gt;&lt;span&gt;-&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”转换成&lt;/span&gt;&lt;b&gt;&lt;span&gt;下划线&lt;/span&gt;&lt;/b&gt;&lt;span&gt;“&lt;/span&gt;&lt;b&gt;&lt;span&gt;_&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;也不建议以“&lt;/span&gt;&lt;b&gt;&lt;span&gt;-rs&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”或“&lt;/span&gt;&lt;b&gt;&lt;span&gt;_rs&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”为后缀来命名包名，而且会强制性的将此后缀去掉。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;h1&gt;&lt;b&gt;&lt;span&gt;二、&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;语法&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;疑问&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.1.1 Copy&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;语义&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; &amp;amp;&amp;amp; Move&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;语义（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Move&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;语义必须转移所有权）&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;类型越来越丰富，值类型和引用类型难以描述全部情况，所以引入了：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;复制以后，两个数据对象拥有的存储空间是独立的，互不影响。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;基本的&lt;/span&gt;&lt;/b&gt;&lt;span&gt;原生类型&lt;/span&gt;&lt;b&gt;&lt;span&gt;都是&lt;/span&gt;&lt;/b&gt;&lt;span&gt;值语义&lt;/span&gt;&lt;span&gt;，这些类型也被称为&lt;/span&gt;&lt;span&gt;POD&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Plain old data&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span&gt;POD&lt;/span&gt;&lt;span&gt;类型都是值语义，但是值语义类型并不一定都是&lt;/span&gt;&lt;span&gt;POD&lt;/span&gt;&lt;span&gt;类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;具有值语义的原生类型，在其作为右值进行赋值操作时，编译器会对其进行按位复制&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;复制以后，两个数据对象互为别名。操作其中任意一个数据对象，则会影响另外一个。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;智能指针&lt;/span&gt;&lt;b&gt;&lt;span&gt;Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;封装了原生指针，是典型的引用类型。&lt;/span&gt;&lt;b&gt;&lt;span&gt;Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;无法实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;，意味着它被&lt;/span&gt;&lt;span&gt;rust&lt;/span&gt;&lt;span&gt;标记为了&lt;/span&gt;&lt;b&gt;&lt;span&gt;引用语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，禁止按位复制。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用语义类型不能实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;，但可以实现&lt;/span&gt;&lt;span&gt;Clone&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;clone&lt;/span&gt;&lt;span&gt;方法，以实现深复制。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中，可以通过&lt;/span&gt;&lt;span&gt;是否实现&lt;/span&gt;&lt;span&gt;Copy trait&lt;/span&gt;&lt;span&gt;来区分&lt;/span&gt;&lt;span&gt;数据类型的&lt;/span&gt;&lt;b&gt;&lt;span&gt;值语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;引用语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。但为了更加精准，&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;也引用了新的语义：&lt;/span&gt;&lt;b&gt;&lt;span&gt;复制（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;移动（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Move&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：对应值语义，即实现了&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;的类型在进行按位复制时是安全的。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Move&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：对应引用语义。在&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中不允许按位复制，&lt;/span&gt;&lt;b&gt;&lt;span&gt;只允许移动所有权&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.1.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;结构体&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：当成员都是复制语义类型时，不会自动实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;枚举体&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：当成员都是复制语义类型时，不会自动实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;结构体&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &amp;amp;&amp;amp; &lt;/span&gt;&lt;b&gt;&lt;span&gt;枚举体&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1)&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;所有成员都是复制语义类型时，需要添加属性&lt;/span&gt;&lt;b&gt;&lt;span&gt;#[derive(Debug,Copy,Clone)]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2)&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;如果有移动语义类型的成员，则无法实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;元组类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：本身实现了&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。如果元素均为复制语义类型，则默认是按位复制，否则执行移动语义。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;字符串字面量&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; &amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;支持按位复制。例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt;c = “hello”;&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;则&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;就是字符串字面量。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.1.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些未实现&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;字符串对象&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;String &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;b&gt;&lt;span&gt;to_string() &lt;/span&gt;&lt;/b&gt;&lt;span&gt;可以将字符串字面量转换为字符串对象。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.1.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Copy trait&lt;/span&gt;&lt;/b&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;对于实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;的类型，其&lt;/span&gt;&lt;span&gt;clone&lt;/span&gt;&lt;span&gt;方法只需要简单的实现按位复制即可。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.1.5 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些未实现&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Copy trait&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Copy trait&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;，有什么作用？&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;Copy trait&lt;/span&gt;&lt;span&gt;的类型同时拥有&lt;/span&gt;&lt;span&gt;复制语义&lt;/span&gt;&lt;span&gt;，在进行赋值或者传入函数等操作时，默认会进行&lt;/span&gt;&lt;span&gt;按位复制&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;对于默认可以安全的在栈上进行按位复制的类型，就只需要按位复制，也&lt;/span&gt;&lt;span&gt;方便管理内存&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;对于默认只可在堆上存储的数据，必须进行&lt;/span&gt;&lt;span&gt;深度复制&lt;/span&gt;&lt;span&gt;。深度复制需要&lt;/span&gt;&lt;span&gt;在堆内存中重新开辟空间，这会带来更多的性能开销&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.1.6 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些是在栈上的？哪些是在堆上的？&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.1.7 let&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;绑定&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;声明的&lt;/span&gt;&lt;b&gt;&lt;span&gt;绑定默认为不可变&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果需要修改，可以用&lt;/span&gt;&lt;b&gt;&lt;span&gt;mut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来声明绑定是可变的。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;数据类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;很多编程语言中的数据类型是分为两类：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一般是指可以将数据都保存在同一位置的类型。例如数值、布尔值、结构体等都是值类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;值类型有：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;引用类型&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;会存在一个指向实际存储区的指针。比如通常一些引用类型会将数据存储在堆中，而栈中只存放指向堆中数据的地址（指针）。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;引用类型有：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;基本数据类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;布尔类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;类型只有两个值：&lt;/span&gt;&lt;b&gt;&lt;span&gt;true&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;false&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;基本数字类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要关注取值范围，具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;字符类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;用&lt;/span&gt;&lt;b&gt;&lt;span&gt;单引号&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来定义字符（&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;）类型。字符类型代表一个&lt;/span&gt;&lt;b&gt;&lt;span&gt;Unicode&lt;/span&gt;&lt;/b&gt;&lt;span&gt;标量值，每个字节占&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;个字节。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;数组类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;数组的类型签名为&lt;/span&gt;&lt;b&gt;&lt;span&gt;[T; N]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;b&gt;&lt;span&gt;T&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是一个泛型标记，代表数组中元素的某个具体类型。&lt;/span&gt;&lt;b&gt;&lt;span&gt;N&lt;/span&gt;&lt;/b&gt;&lt;span&gt;代表数组长度，在编译时必须确定其值。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组特点：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;切片类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;切片（&lt;/span&gt;&lt;span&gt;Slice&lt;/span&gt;&lt;span&gt;）类型是对一个数组的引用片段。在底层，切片代表一个指向数组起始位置的指针和数组长度。用&lt;/span&gt;&lt;b&gt;&lt;span&gt;[T]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型表示连续序列，那么切片类型就是&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;[T]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;mut[T]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;str&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;字符串类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串类型&lt;/span&gt;&lt;b&gt;&lt;span&gt;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，通常是以&lt;/span&gt;&lt;span&gt;不可变借用&lt;/span&gt;&lt;span&gt;的形式存在，即&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;（字符串切片）。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;将字符串分为两种：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1)&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：固定长度字符串&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2)&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;String&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：可以随意改变其长度。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;字符串类型由两部分组成：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;指向字符串序列的指针；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;记录长度的值。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;存储于&lt;/span&gt;&lt;span&gt;栈&lt;/span&gt;&lt;span&gt;上，&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;字符串序列存储于程序的&lt;/span&gt;&lt;span&gt;静态只读数据段&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;堆内存&lt;/span&gt;&lt;span&gt;中。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是一种&lt;/span&gt;&lt;b&gt;&lt;span&gt;胖指针&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;never&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;never&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型，即&lt;/span&gt;&lt;b&gt;&lt;span&gt;!&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。该类型用于表示永远不可能有返回值的计算类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;其他（此部分不属于基本数据类型）&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此部分不属于基本数据类型，由于编排问题，暂时先放在此处。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;胖指针&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;胖指针&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：包含了动态&lt;/span&gt;&lt;span&gt;大小类型地址信息&lt;/span&gt;&lt;span&gt;和携带了&lt;/span&gt;&lt;span&gt;长度信息&lt;/span&gt;&lt;span&gt;的指针。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;零大小类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;零大小类型（&lt;/span&gt;&lt;span&gt;Zero sized Type&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;ZST&lt;/span&gt;&lt;span&gt;）的特点是：&lt;/span&gt;&lt;span&gt;它们的值就是其本身，运行时并不占用内存空间&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;单元类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;单元结构体&lt;/span&gt;&lt;/b&gt;&lt;span&gt;大小为零，由单元类型组成的数组大小也是零。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ZST&lt;/span&gt;&lt;span&gt;类型代表的意义是“&lt;/span&gt;&lt;b&gt;&lt;span&gt;空&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;底类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;底类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;其实是介绍过的&lt;/span&gt;&lt;b&gt;&lt;span&gt;never&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型，用&lt;/span&gt;&lt;b&gt;&lt;span&gt;叹号&lt;/span&gt;&lt;/b&gt;&lt;span&gt;（&lt;/span&gt;&lt;b&gt;&lt;span&gt;!&lt;/span&gt;&lt;/b&gt;&lt;span&gt;）表示。它的特点是：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果说&lt;/span&gt;&lt;span&gt;ZST&lt;/span&gt;&lt;span&gt;类型表示“&lt;/span&gt;&lt;b&gt;&lt;span&gt;空&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”的话，那么底类型就表示“&lt;/span&gt;&lt;b&gt;&lt;span&gt;无&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;底类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;无值，而且它可以&lt;/span&gt;&lt;span&gt;等价于任意类型&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;复合数据类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;元组&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;提供了&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;中复合数据类型：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;元组（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Tuple&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;结构体（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Struct&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;枚举体（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Enum&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;联合体（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Union&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;先来介绍元组。&lt;/span&gt;&lt;b&gt;&lt;span&gt;元组&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是一种&lt;/span&gt;&lt;span&gt;异构有限&lt;/span&gt;&lt;span&gt;序列，形如&lt;/span&gt;&lt;b&gt;&lt;span&gt;(T,U,M,N)&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。所谓异构，就是指元组内的元素&lt;/span&gt;&lt;span&gt;可以是不同类型&lt;/span&gt;&lt;span&gt;。所谓有限，是指元组有固定的长度。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;空元组&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;()&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;只有一个值时，需要加逗号：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;(0,)&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;结构体&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;提供了&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;中结构体：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;struct People {      &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    name: &amp;amp;’static str,&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;}                       &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;struct Color(i32, i32, i32);&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个元组结构体只有一个字段的时候，称为&lt;/span&gt;&lt;b&gt;&lt;span&gt;New Type&lt;/span&gt;&lt;/b&gt;&lt;span&gt;模式。例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;struct Integer(u32);&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;单元结构体&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：没有任何字段的结构体。单元结构体实例就是其本身。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;struct Empty;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;结构体更新语法&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;Struct&lt;/span&gt;&lt;span&gt;更新语法（&lt;/span&gt;&lt;b&gt;&lt;span&gt;..&lt;/span&gt;&lt;/b&gt;&lt;span&gt;）从其他实例创建新实例。当新实例使用旧实例的大部分值时，可以使用&lt;/span&gt;&lt;span&gt;struct update&lt;/span&gt;&lt;span&gt;语法。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td valign=&quot;top&quot;&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;#[derive(Debug,Copy,Clone)]&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;struct Book&amp;lt;’a&amp;gt; {&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;name: &amp;amp;’a str,&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;isbn:  i32,&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;version: i32,&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;}&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;let book = Book {&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;    name: “Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;编程之道&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;”,  isbn: 20181212, version: 1&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;};&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;let book2 = Book {version: 2, &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;..&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;book};&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt; &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;如果结构体使用了移动语义的成员字段，则不允许实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;不允许包含了&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;类型字段的结构体实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;更新语法会转移字段的所有权。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;枚举体&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;该类型包含了全部可能的情况，可以有效的&lt;/span&gt;&lt;span&gt;防止用户提供无效值&lt;/span&gt;&lt;span&gt;。例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;enum Number {&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    Zero,   &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    One,    &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;}             &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Rust&lt;/span&gt;&lt;span&gt;还支持携带类型参数的枚举体。这样的枚举值本质上属于函数类型，他可以通过显式的指定类型来转换为函数指针类型。例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;enum IpAddr {          &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    V4(u8, u8, u8, u8),&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    V6(String),         &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;}                        &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;枚举体在&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中属于非常重要的类型之一。例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt;Option&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;枚举&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;联合体&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;常用集合类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;线性序列：向量&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;标准库&lt;/span&gt;&lt;span&gt;std::collections&lt;/span&gt;&lt;span&gt;模块下有&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;中通用集合类型，分别如下：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;线性序列&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;b&gt;&lt;span&gt;向量（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Vec&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;双端队列（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;VecDeque&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;链表（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;LinkedList&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Key-Value&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;映射表&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;b&gt;&lt;span&gt;无序哈希表（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;有序映射表（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;BTreeMap&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;集合类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;b&gt;&lt;span&gt;无序集合（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;有序集合（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;BTreeSet&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;优先队列&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;b&gt;&lt;span&gt;二叉堆（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;BinaryHeap&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;&lt;span&gt;页和&lt;/span&gt;&lt;span&gt;271&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;向量也是一种数组，和基本数据类型中的数组的区别在于：&lt;/span&gt;&lt;b&gt;&lt;span&gt;向量可动态增长&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;let mut v1 = &lt;/span&gt;&lt;b&gt;&lt;span&gt;vec![];&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;let mut v2 = &lt;/span&gt;&lt;b&gt;&lt;span&gt;vec![0; 10];&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;let mut v3 = &lt;/span&gt;&lt;b&gt;&lt;span&gt;Vec::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;vec!&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是一个宏，用来创建向量字面量。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;线性序列：双端队列&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;双端队列（&lt;/span&gt;&lt;span&gt;Double-ended Queue&lt;/span&gt;&lt;span&gt;，缩写&lt;/span&gt;&lt;span&gt;Deque&lt;/span&gt;&lt;span&gt;）是一种同时具有队列（先进先出）和栈（后进先出）性质的数据结构。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;双端队列中的元素可以从两端弹出，插入和删除操作被限定在队列的两端进行。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;use std::collections::VecDeque;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;let mut buf = &lt;/span&gt;&lt;b&gt;&lt;span&gt;VecDeque::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;buf.push_front(1);             &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;buf.get(0);                    &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;buf.push_back(2);             &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;线性序列：链表&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Rust&lt;/span&gt;&lt;span&gt;提供的链表是双向链表，允许在任意一端插入或弹出元素。最好使用&lt;/span&gt;&lt;span&gt;Vec&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;VecDeque&lt;/span&gt;&lt;span&gt;类型，他们比链表更加快速，内存访问效率更高。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;use std::collections::LinkedList;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;let mut list = LinkedList::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;list.push_front(‘a’);             &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;list.append(&amp;amp;mut list2);         &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;list.push_back(‘b’);             &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Key-Value&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;映射表：&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;和&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;BTreeMap&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;     =&amp;gt; &lt;/span&gt;&lt;span&gt;无序&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;BTreeMap&amp;lt;K, V&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;   =&amp;gt; &lt;/span&gt;&lt;span&gt;有序&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;要求&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;是必须&lt;/span&gt;&lt;span&gt;可哈希&lt;/span&gt;&lt;span&gt;的类型，&lt;/span&gt;&lt;span&gt;BTreeMap&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;必须是&lt;/span&gt;&lt;span&gt;可排序&lt;/span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;必须是&lt;/span&gt;&lt;span&gt;在编译期已知大小&lt;/span&gt;&lt;span&gt;的类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;use std::collections::BTreeMap;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;use std::collections::HashMap;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;let mut hmap = HashMap::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;let mut bmap = BTreeMap::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;hmap.insert(1,”a”);           &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;bmap.insert(1,”a”);           &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;集合：&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;和&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;BTreeSet&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;HashSet&amp;lt;K&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;BTreeSet&amp;lt;K&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;其实就是&lt;/span&gt;&lt;b&gt;&lt;span&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;BTreeMap&amp;lt;K, V&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;把&lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;设置为&lt;/span&gt;&lt;b&gt;&lt;span&gt;空元组&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的特定类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;集合中的元素应该是&lt;/span&gt;&lt;span&gt;唯一&lt;/span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;/b&gt;&lt;span&gt;中的元素都是&lt;/span&gt;&lt;span&gt;可哈希&lt;/span&gt;&lt;span&gt;的类型，&lt;/span&gt;&lt;b&gt;&lt;span&gt;BTreeSet&lt;/span&gt;&lt;/b&gt;&lt;span&gt;中的元素必须是&lt;/span&gt;&lt;span&gt;可排序&lt;/span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;/b&gt;&lt;span&gt;应该是&lt;/span&gt;&lt;span&gt;无序&lt;/span&gt;&lt;span&gt;的，&lt;/span&gt;&lt;b&gt;&lt;span&gt;BTreeSet&lt;/span&gt;&lt;/b&gt;&lt;span&gt;应该是&lt;/span&gt;&lt;span&gt;有序&lt;/span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;use std::collections::BTreeSet;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;use std::collections::HashSet;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;let mut hset = HashSet::new();  &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;let mut bset = BTreeSet::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;hset.insert(”This is a hset.”);&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;bset.insert(”This is a bset”);&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;优先队列：&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;BinaryHeap&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;提供的优先队列是基于&lt;/span&gt;&lt;b&gt;&lt;span&gt;二叉最大堆（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Binary Heap&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;实现的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;use std::collections::BinaryHeap;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;let mut heap = BinaryHeap::new();&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;heap.peek();                           &lt;/span&gt;&lt;/b&gt;&lt;span&gt;=&amp;gt; peek&lt;/span&gt;&lt;span&gt;是取出堆中最大的元素&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;heap.push(98);                     &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;容量（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Capacity&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）和大小（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Size/Len&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无论是&lt;/span&gt;&lt;span&gt;Vec&lt;/span&gt;&lt;span&gt;还是&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;，使用这些集合容器类型，最重要的是理解&lt;/span&gt;&lt;b&gt;&lt;span&gt;容量（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Capacity&lt;/span&gt;&lt;/b&gt;&lt;span&gt;）和&lt;/span&gt;&lt;b&gt;&lt;span&gt;大小（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Size/Len&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;容量&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是指为集合容器分配的&lt;/span&gt;&lt;span&gt;内存容量&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;大小&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是指集合中包含的&lt;/span&gt;&lt;span&gt;元素数量&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;&lt;span&gt;2.2.4 Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;字符串&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;字符串分为以下几种类型：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示固定长度的字符串&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;String&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示可增长的字符串&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;CStr&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示由&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;分配而被&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;借用的字符串。这是为了兼容&lt;/span&gt;&lt;span&gt;windows&lt;/span&gt;&lt;span&gt;系统。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;CString&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示由&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;分配且可以传递给&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;函数使用的&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;字符串，同样用于和&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;语言交互。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;OsStr&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示和操作系统相关的字符串。这是为了兼容&lt;/span&gt;&lt;span&gt;windows&lt;/span&gt;&lt;span&gt;系统。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;OsString&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示&lt;/span&gt;&lt;span&gt;OsStr&lt;/span&gt;&lt;span&gt;的可变版本。与&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;字符串可以相互交换。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;Path&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示路径，定义于&lt;/span&gt;&lt;span&gt;std::path&lt;/span&gt;&lt;span&gt;模块中。&lt;/span&gt;&lt;span&gt;Path&lt;/span&gt;&lt;span&gt;包装了&lt;/span&gt;&lt;span&gt;OsStr&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;PathBuf&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：跟&lt;/span&gt;&lt;span&gt;Path&lt;/span&gt;&lt;span&gt;配对，是&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;的可变版本。&lt;/span&gt;&lt;span&gt;PathBuf&lt;/span&gt;&lt;span&gt;包装了&lt;/span&gt;&lt;span&gt;OsString&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;属于&lt;/span&gt;&lt;b&gt;&lt;span&gt;动态大小类型（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;DST&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;），&lt;/span&gt;&lt;/b&gt;&lt;span&gt;在编译期并不能确定其大小。所以在程序中最常见的是&lt;/span&gt;&lt;b&gt;&lt;span&gt;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的切片（&lt;/span&gt;&lt;span&gt;Slice&lt;/span&gt;&lt;span&gt;）类型&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;。&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;代表的是不可变的&lt;/span&gt;&lt;b&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;/b&gt;&lt;span&gt;字节序列，创建后无法再为其追加内容或更改其内容。&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型的字符串可以存储在任意地方：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;String&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型本质是一个成员变量为&lt;/span&gt;&lt;b&gt;&lt;span&gt;Vec&amp;lt;u8&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型的结构体，所以它是直接将字符内容存放于堆中的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;String&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型由三部分组成：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;执行堆中字节序列的指针（&lt;/span&gt;&lt;span&gt;as_ptr&lt;/span&gt;&lt;span&gt;方法）&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;记录堆中字节序列的字节长度（&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;方法）&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;堆分配的容量（&lt;/span&gt;&lt;span&gt;capacity&lt;/span&gt;&lt;span&gt;方法）&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.4.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;字符串处理方式&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中的字符串不能使用索引访问其中的字符，可以通过&lt;/span&gt;&lt;b&gt;&lt;span&gt;bytes&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;chars&lt;/span&gt;&lt;/b&gt;&lt;span&gt;两个方法来分别返回&lt;/span&gt;&lt;b&gt;&lt;span&gt;按字节&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;按字符&lt;/span&gt;&lt;/b&gt;&lt;span&gt;迭代的迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;提供了另外两种方法：&lt;/span&gt;&lt;b&gt;&lt;span&gt;get&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;get_mut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来通过指定索引范围来获取字符串切片。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.4.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;字符串修改&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;追加字符串：&lt;/span&gt;&lt;b&gt;&lt;span&gt;push&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;push_str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，以及&lt;/span&gt;&lt;b&gt;&lt;span&gt;extend&lt;/span&gt;&lt;/b&gt;&lt;span&gt;迭代器&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;插入字符串：&lt;/span&gt;&lt;b&gt;&lt;span&gt;insert&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;insert_str&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;连接字符串：&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;Add&amp;lt;&amp;amp;str&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;AddAssign&amp;lt;&amp;amp;str&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;两个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;，所以可以使用“&lt;/span&gt;&lt;b&gt;&lt;span&gt;+&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”和“&lt;/span&gt;&lt;b&gt;&lt;span&gt;+=&lt;/span&gt;&lt;/b&gt;&lt;span&gt;”来连接字符串&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;更新字符串：通过迭代器或者某些&lt;/span&gt;&lt;span&gt;unsafe&lt;/span&gt;&lt;span&gt;的方法&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;删除字符串：&lt;/span&gt;&lt;b&gt;&lt;span&gt;remove&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;pop&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;truncate&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;clear&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;drain&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.4.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;字符串的查找&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;总共提供了&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;个方法涵盖了以下几种字符串匹配操作：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;存在性判断&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;位置匹配&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;分割字符串&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;捕获匹配&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;删除匹配&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;替代匹配&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.4.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;类型转换&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;parse&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：将字符串转换为指定的类型&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;format!&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;宏&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：将其他类型转成成字符串&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.5 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;格式化规则&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;填充字符串宽度：&lt;/span&gt;&lt;b&gt;&lt;span&gt;{:&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;5&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;}&lt;/span&gt;&lt;/b&gt;&lt;span&gt;,5&lt;/span&gt;&lt;span&gt;是指宽度为&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;截取字符串：&lt;/span&gt;&lt;b&gt;&lt;span&gt;{:.&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;5&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;}&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;对齐字符串：&lt;/span&gt;&lt;b&gt;&lt;span&gt;{:&amp;gt;}&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;{:^}&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;{:&amp;lt;}&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，分别表示&lt;/span&gt;&lt;b&gt;&lt;span&gt;左对齐&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;位于中间&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;右对齐&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;{:*^&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;5&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;} &lt;/span&gt;&lt;/b&gt;&lt;span&gt;使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;*&lt;/span&gt;&lt;/b&gt;&lt;span&gt;替代默认&lt;/span&gt;&lt;b&gt;&lt;span&gt;空格&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来填充&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;符号&lt;/span&gt;&lt;b&gt;&lt;span&gt;+&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示强制输出整数的正负符号&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;符号&lt;/span&gt;&lt;b&gt;&lt;span&gt;#&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：用于显示进制的前缀。比如：十六进制&lt;/span&gt;&lt;span&gt;0x&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;数字&lt;/span&gt;&lt;b&gt;&lt;span&gt;0&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：用于把默认填充的空格替换成数字&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;{:x} &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：转换成&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;进制输出&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;{:b} &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：转换成二进制输出&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;{:.5}&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：指定小数点后有效位是&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;{:e}&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：科学计数法表示&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.6 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;原生字符串声明语法：&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;r”…”&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原生字符串声明语法（&lt;/span&gt;&lt;b&gt;&lt;span&gt;r”…”&lt;/span&gt;&lt;/b&gt;&lt;span&gt;）可以保留原来字符串中的特殊符号。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.2.7 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;全局类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;支持两种全局类型：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;普通常量（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Constant&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;静态变量（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Static&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;区别：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;都是在&lt;/span&gt;&lt;b&gt;&lt;span&gt;编译期&lt;/span&gt;&lt;/b&gt;&lt;span&gt;求值的，所以不能用于存储需要动态分配内存的类型&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;普通常量&lt;/span&gt;&lt;b&gt;&lt;span&gt;可以被内联&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的，它没有确定的内存地址，不可变&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;静态变量&lt;/span&gt;&lt;b&gt;&lt;span&gt;不能被内联&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，它有精确的内存地址，拥有静态生命周期&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;静态变量可以通过内部包含&lt;/span&gt;&lt;span&gt;UnsafeCell&lt;/span&gt;&lt;span&gt;等容器&lt;/span&gt;&lt;b&gt;&lt;span&gt;实现内部可变性&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;静态变量还有其他限制，具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;326&lt;/span&gt;&lt;span&gt;页&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;普通常量也不能引用静态变量&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;在存储的&lt;/span&gt;&lt;b&gt;&lt;span&gt;数据比较大&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，&lt;/span&gt;&lt;b&gt;&lt;span&gt;需要引用地址&lt;/span&gt;&lt;/b&gt;&lt;span&gt;或&lt;/span&gt;&lt;b&gt;&lt;span&gt;具有可变性&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的情况下使用静态变量。否则，应该优先使用普通常量。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但也有一些情况是这两种全局类型无法满足的，比如想要使用全局的&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;，在这种情况下，推荐使用&lt;/span&gt;&lt;span&gt;lazy_static&lt;/span&gt;&lt;span&gt;包。利用&lt;/span&gt;&lt;span&gt;lazy_static&lt;/span&gt;&lt;span&gt;包可以把&lt;/span&gt;&lt;b&gt;&lt;span&gt;定义全局静态变量延迟到运行&lt;/span&gt;&lt;/b&gt;&lt;span&gt;时，而&lt;/span&gt;&lt;b&gt;&lt;span&gt;非编译&lt;/span&gt;&lt;/b&gt;&lt;span&gt;时。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.3 trait&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;b&gt;&lt;span&gt;对类型行为的抽象&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;实现零成本抽象的基石，它有如下机制：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;唯一的接口抽象方式；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;可以静态分发，也可以动态分发；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;可以当做标记类型拥有某些特定行为的“标签”来使用。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;struct Duck;                &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;struct Pig;                 &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;trait &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Fly {                 &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    fn fly(&amp;amp;self) -&amp;gt; bool;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;}                            &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;impl Fly for Duck&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; {        &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    fn fly(&amp;amp;self) -&amp;gt; bool {&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;         return true;       &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    }                         &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;}                            &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;impl Fly for Pig&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; {         &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    fn fly(&amp;amp;self) -&amp;gt; bool {&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;         return false;      &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;    }                        &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;}                            &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;静态分发和动态分发的具体介绍可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;trait&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;限定&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下这些需要继续深入理解第三章并总结。待后续继续补充。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;trait&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;标签&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;trait&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Copy trait&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Deref&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;解引用&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;as&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;操作符&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;From&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;和&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Into&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;指针&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.3.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;引用&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp; mut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;操作符来创建。受&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;的安全检查规则的限制。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用是&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;提供的一种指针语义。引用是基于指针的实现，他与指针的区别是：&lt;/span&gt;&lt;span&gt;指针保存的是其指向内存的地址&lt;/span&gt;&lt;span&gt;，而&lt;/span&gt;&lt;span&gt;引用可以看做某块内存的别名（&lt;/span&gt;&lt;span&gt;Alias&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在所有权系统中，引用&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;x&lt;/span&gt;&lt;/b&gt;&lt;span&gt;也可以称为&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;的借用（&lt;/span&gt;&lt;span&gt;Borrowing&lt;/span&gt;&lt;span&gt;）。通过&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;操作符来完成&lt;/span&gt;&lt;b&gt;&lt;u&gt;&lt;span&gt;&lt;a href=&quot;http://3ms.huawei.com/km/groups/1501725/blogs/details/7729437#_1.2.3.2_%E6%89%80%E6%9C%89%E6%9D%83%E5%80%9F%E7%94%A8&quot;&gt;&lt;span&gt;所有权租借&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/u&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.3.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;原生指针（裸指针）&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;*const T&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;*mut T&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。可以在&lt;/span&gt;&lt;b&gt;&lt;span&gt;unsafe&lt;/span&gt;&lt;/b&gt;&lt;span&gt;块下任意使用，不受&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;的安全检查规则的限制。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.3.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;智能指针&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上是一种结构体，只是行为类似指针。智能指针是对指针的一层封装，提供了一些额外的功能，比如自动释放堆内存。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;智能指针区别于常规结构体的特性在于：它实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;Deref&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;Drop&lt;/span&gt;&lt;/b&gt;&lt;span&gt;这两个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Deref&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：提供了解引用能力&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Drop&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：提供了自动析构的能力&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.3.3.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;智能指针有哪些&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;智能指针&lt;/span&gt;&lt;b&gt;&lt;span&gt;拥有资源的所有权&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，而普通引用只是对&lt;/span&gt;&lt;b&gt;&lt;span&gt;所有权的借用&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;。&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中的值默认被分配到&lt;/span&gt;&lt;b&gt;&lt;span&gt;栈内存&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。可以通过&lt;/span&gt;&lt;span&gt;Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;将值装箱（在&lt;/span&gt;&lt;b&gt;&lt;span&gt;堆内存&lt;/span&gt;&lt;/b&gt;&lt;span&gt;中分配）。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;String&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型和&lt;/span&gt;&lt;b&gt;&lt;span&gt;Vec&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型的值都是被&lt;/span&gt;&lt;b&gt;&lt;span&gt;分配到堆内存&lt;/span&gt;&lt;/b&gt;&lt;span&gt;并&lt;/span&gt;&lt;b&gt;&lt;span&gt;返回指针&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的，通过将返回的指针封装来实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;Deref&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;Drop&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;是指向类型为&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;堆内存&lt;/span&gt;&lt;span&gt;分配值的&lt;/span&gt;&lt;span&gt;智能指针&lt;/span&gt;&lt;span&gt;。当&lt;/span&gt;&lt;span&gt;Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;超出作用域范围时，将调用其析构函数，销毁内部对象，并&lt;/span&gt;&lt;span&gt;自动释放堆中的内存&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;span&gt;单线程&lt;/span&gt;&lt;/b&gt;&lt;span&gt;引用计数指针，不是线程安全的类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以将多个所有权共享给多个变量，每当共享一个所有权时，计数就会增加一次。具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;是&lt;/span&gt;&lt;b&gt;&lt;span&gt;RC&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的另一个版本。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过&lt;span&gt;clone&lt;/span&gt;方法共享的引用所有权称为&lt;/span&gt;&lt;b&gt;&lt;span&gt;强引用&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，&lt;/span&gt;&lt;b&gt;&lt;span&gt;RC&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是强引用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Weak&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;共享的指针&lt;/span&gt;&lt;span&gt;没有所有权&lt;/span&gt;&lt;span&gt;，属于&lt;/span&gt;&lt;b&gt;&lt;span&gt;弱引用&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;实现字段级内部可变的情况。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;适合复制语义类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;适合移动语义类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cell&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;和&lt;span&gt;RefCell&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;b&gt;&lt;span&gt;本质上不属于智能指针&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，只是提供内不可变性的容器。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cell&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;和&lt;span&gt;RefCell&amp;lt;T&amp;gt;&lt;/span&gt;使用最多的场景就是配合只读引用来使用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的见&lt;/span&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Copy on write&lt;/span&gt;&lt;span&gt;：一种枚举体的智能指针。&lt;/span&gt;&lt;span&gt;Cow&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;表示的是所有权的“借用”和“拥有”。&lt;/span&gt;&lt;span&gt;Cow&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;的功能是：以不可变的方式访问借用内容，以及在需要可变借用或所有权的时候再克隆一份数据。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cow&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;旨在&lt;/span&gt;&lt;span&gt;减少复制操作，提高性能&lt;/span&gt;&lt;span&gt;，一般用于&lt;/span&gt;&lt;span&gt;读多写少&lt;/span&gt;&lt;span&gt;的场景。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cow&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;的另一个用处是统一实现规范。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.3.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;解引用&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;deref&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解引用会获得所有权。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解引用操作符：&lt;/span&gt;&lt;span&gt; *&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;哪些实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;deref&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：源码见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;Cow&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：意味着可以直接调用其包含数据的不可变方法。具体的要点可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;Box&amp;lt;T &amp;gt;&lt;/span&gt;&lt;span&gt;支持解引用移动，&lt;/span&gt;&lt;span&gt; Rc&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Arc&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;智能指针不支持解引用移动。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;所有权机制（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;ownership&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中分配的每块内存都有其所有者，所有者负责该内存的释放和读写权限，并且每次每个值只能有唯一的所有者。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在进行赋值操作时，对于可以&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;的复制语义类型，所有权并未改变&lt;/span&gt;&lt;span&gt;。对于复合类型来说，是复制还是移动，取决于其成员的类型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：如果数组的元素都是基本的数字类型，则该数组是复制语义，则会按位复制。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;词法作用域（生命周期）&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;match&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;for&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;loop&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;while&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;if let&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;while let&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;花括号&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/b&gt;&lt;span&gt;、&lt;/span&gt;&lt;b&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/b&gt;&lt;span&gt;都会创建新的作用域，相应绑定的所有权会被转移，具体的可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数体本身是独立的词法作用域：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;当复制语义类型作为函数参数时，会按位复制。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果是移动语义作为函数参数，则会转移所有权。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;非词法作用域声明周期&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;借用规则&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;借用方&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的生命周期不能长于&lt;/span&gt;&lt;b&gt;&lt;span&gt;出借方&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的生命周期。用例见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为以上的规则，经常导致实际开发不便，所以引入了&lt;/span&gt;&lt;b&gt;&lt;span&gt;非词法作用域生命周期（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Non-Lexical Lifetime&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;，&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;NLL&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来改善。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;是基于控制流图（&lt;/span&gt;&lt;span&gt;Control Flow Graph&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;CFG&lt;/span&gt;&lt;span&gt;）的抽象数据结构，它用&lt;/span&gt;&lt;span&gt;有向图（&lt;/span&gt;&lt;span&gt;DAG&lt;/span&gt;&lt;span&gt;）形式包含了程序执行过程中所有可能的流程&lt;/span&gt;&lt;span&gt;。所以将基于&lt;/span&gt;&lt;span&gt;MIR&lt;/span&gt;&lt;span&gt;的借用检查称为非词法作用域的生命周期。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;所有权借用&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用可变借用的前提是：出借所有权的绑定变量必须是一个可变绑定。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在所有权系统中，引用&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;x&lt;/span&gt;&lt;/b&gt;&lt;span&gt;也可以称为&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;的借用（&lt;/span&gt;&lt;span&gt;Borrowing&lt;/span&gt;&lt;span&gt;）。通过&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;操作符来完成&lt;/span&gt;&lt;b&gt;&lt;span&gt;所有权租借&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。所以引用并不会造成绑定变量所有权的转移。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用在离开作用域之时，就是其归还所有权之时。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;不可变借用（引用）不能再次出借为可变借用。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;不可变借用可以被出借多次。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;可变借用只能出借一次。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;不可变借用和可变借用不能同时存在，针对同一个绑定而言。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;借用的生命周期不能长于出借方的生命周期。具体的举例见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;核心原则：&lt;/span&gt;&lt;b&gt;&lt;span&gt;共享不可变，可变不共享&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为&lt;/span&gt;&lt;b&gt;&lt;span&gt;解引用操作会获得所有权&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，所以在需要对移动语义类型（如&lt;/span&gt;&lt;span&gt;&amp;amp;String&lt;/span&gt;&lt;span&gt;）进行解引用时需要特别注意。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编译器的借用检查机制无法对跨函数的借用进行检查，因为当前借用的有效性依赖于词法作用域。所以，需要开发者显式的对借用的生命周期参数进行标注。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;显式生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;生命周期参数必须是以&lt;/span&gt;&lt;b&gt;&lt;span&gt;单引号&lt;/span&gt;&lt;/b&gt;&lt;span&gt;开头；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;参数名通常都是&lt;/span&gt;&lt;b&gt;&lt;span&gt;小写字母&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt;；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;生命周期参数&lt;/span&gt;&lt;b&gt;&lt;span&gt;位于引用符号&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;后面&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，并使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;空格&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来分割生命周期参数和类型。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;标注生命周期参数是由于&lt;/span&gt;&lt;span&gt;borrowed pointers&lt;/span&gt;&lt;span&gt;导致的。因为有&lt;/span&gt;&lt;span&gt;borrowed pointers&lt;/span&gt;&lt;span&gt;，当函数返回&lt;/span&gt;&lt;span&gt;borrowed pointers&lt;/span&gt;&lt;span&gt;时，为了保证内存安全，需要关注被借用的内存的生命周期&lt;/span&gt;&lt;span&gt;(lifetime)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;标注生命周期参数并不能改变任何引用的生命周期长短，它&lt;/span&gt;&lt;b&gt;&lt;span&gt;只用于编译器的借用检查&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，来防止悬垂指针。即：生命周期参数的目的是&lt;/span&gt;&lt;b&gt;&lt;span&gt;帮助借用检查器验证合法的引用，消除悬垂指针&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;i32;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;  ==&amp;gt; &lt;/span&gt;&lt;span&gt;引用&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a i32;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;    ==&amp;gt; &lt;/span&gt;&lt;span&gt;标注生命周期参数的引用&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a mut i32;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;    ==&amp;gt; &lt;/span&gt;&lt;span&gt;标注生命周期参数的可变引用&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;允许使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a str;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的地方，使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;static str;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;也是合法的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;&lt;b&gt;&lt;span&gt;&#x27;static&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：当&lt;/span&gt;&lt;span&gt;borrowed pointers&lt;/span&gt;&lt;span&gt;指向&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;对象时需要声明&lt;/span&gt;&lt;span&gt;&#x27;static lifetime&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;static STRING: &amp;amp;&#x27;static str = &quot;bitstring&quot;;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;函数签名中的生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fn foo&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;lt;&#x27;a&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;(s: &lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt; str, t: &lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt; str) -&amp;gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt; str;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数名后的&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;lt;&#x27;a&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;为生命周期参数的声明。函数或方法参数的生命周期叫做&lt;/span&gt;&lt;b&gt;&lt;span&gt;输入生命周期（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;input lifetime&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，而返回值的生命周期被称为&lt;/span&gt;&lt;b&gt;&lt;span&gt;输出生命周期（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;output lifetime&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;规则：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;禁止在没有任何输入参数的情况下返回引用，因为会造成悬垂指针。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;从函数中返回（输出）一个引用，其生命周期参数必须与函数的参数（输入）相匹配，否则，标注生命周期参数也毫无意义。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;对于多个输入参数的情况，也可以标注不同的生命周期参数。具体的举例见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;结构体定义中的生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结构体在含有引用类型成员的时候也需要标注生命周期参数，否则编译失败。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td valign=&quot;top&quot;&gt; &lt;p&gt;struct Foo&lt;b&gt;&lt;span&gt;&amp;lt;&#x27;a&amp;gt;&lt;/span&gt;&lt;/b&gt; {&lt;/p&gt; &lt;p&gt;            part: &lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a str&lt;/span&gt;&lt;/b&gt;,&lt;/p&gt; &lt;p&gt;}&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt;
&lt;p&gt;&lt;span&gt;这里生命周期参数标记，实际上是和编译器约定了一个规则：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;结构体实例的生命周期应短于或等于任意一个成员的生命周期。&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;方法定义中的生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结构体中包含引用类型成员时，需要标注生命周期参数，则在&lt;/span&gt;&lt;span&gt;impl&lt;/span&gt;&lt;span&gt;关键字之后也需要声明生命周期参数，并在结构体名称之后使用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td valign=&quot;top&quot;&gt; &lt;p&gt;impl&lt;b&gt;&lt;span&gt;&amp;lt;&#x27;a&amp;gt;&lt;/span&gt;&lt;/b&gt; Foo&lt;b&gt;&lt;span&gt;&amp;lt;&#x27;a&amp;gt;&lt;/span&gt;&lt;/b&gt; {&lt;/p&gt; &lt;p&gt;         fn split_first(s: &lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a str&lt;/span&gt;&lt;/b&gt;) -&amp;gt; &lt;b&gt;&lt;span&gt;&amp;amp;&#x27;a str &lt;/span&gt;&lt;/b&gt;{&lt;/p&gt; &lt;p&gt;                   …&lt;/p&gt; &lt;p&gt;}&lt;/p&gt; &lt;p&gt;}&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt;
&lt;p&gt;&lt;span&gt;在添加生命周期参数&lt;/span&gt;&lt;b&gt;&lt;span&gt;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt;之后，结束了输入引用的生命周期长度要长于结构体&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;实例的生命周期长度。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/b&gt;&lt;span&gt;枚举体和结构体对生命周期参数的处理方式是一样的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.5 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;静态生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;静态生命周期&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; &#x27;static&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：是&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;内置的一种特殊的生命周期。&lt;/span&gt;&lt;b&gt;&lt;span&gt;&#x27;static&lt;/span&gt;&lt;/b&gt;&lt;span&gt;生命周期存活于整个程序运行期间。所有的字符串字面量都有生命周期，类型为&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp; &#x27;static str&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串字面量是全局静态类型，他的数据和程序代码一起存储在可执行文件的数据段中，其地址在编译期是已知的，并且是只读的，无法更改。&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.6 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;省略生命周期参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;满足以下三条规则时，可以省略生命周期参数。该场景下，是将其硬编码到&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编译器重，以便编译期可以自动补齐函数签名中的生命周期参数。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生命周期省略规则：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;每一个在输入位置省略的生命周期都将成为一个不同的生命周期参数。即对应一个唯一的生命周期参数。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果只有一个输入的生命周期位置（无论省略还是没省略），则该生命周期都将分配给输出生命周期。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果有多个输入生命周期位置，而其中包含着&lt;/span&gt;&lt;span&gt; &amp;amp;self &lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt; &amp;amp;mut self&lt;/span&gt;&lt;span&gt;，那么&lt;/span&gt;&lt;span&gt; self &lt;/span&gt;&lt;span&gt;的生命周期都将分配给输出生命周期。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;以上这部分规则还没理解透彻&lt;/span&gt;&lt;span&gt;，需要继续熟读《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.7 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;生命周期限定&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生命周期参数可以向&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;那样作为泛型的限定，有以下两种形式：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;T: &#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，表示&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;类型中的任何引用都要“获得”和&lt;/span&gt;&lt;b&gt;&lt;span&gt;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt;一样长。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;T: Trait + &#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，表示&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;类型必须实现&lt;/span&gt;&lt;span&gt;Trait&lt;/span&gt;&lt;span&gt;这个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;，并且&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;类型中任何引用都要“活的”和&lt;/span&gt;&lt;b&gt;&lt;span&gt;&#x27;a&lt;/span&gt;&lt;/b&gt;&lt;span&gt;一样长。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体的举例见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.8 trait&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;对象的生命周期&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的举例见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.4.3.9 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;高阶生命周期&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;还提供了&lt;/span&gt;&lt;b&gt;&lt;span&gt;高阶生命周期（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Higher-Ranked Lifetime&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;方案，该方案也叫&lt;/span&gt;&lt;b&gt;&lt;span&gt;高阶&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;trait&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;限定（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Higher-Ranked Trait Bound&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;，&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;HRTB&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。该方案提供了&lt;/span&gt;&lt;b&gt;&lt;span&gt;for&amp;lt;&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;语法。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;for&amp;lt;&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;语法整体表示此生命周期参数只针对其后面所跟着的“对象”。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.5 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;并发安全与所有权&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.5.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;标签&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;trait&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;：&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Send&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;和&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Sync&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;如果类型&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;Send&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;就是告诉编译器该类型的实例可以&lt;/span&gt;&lt;b&gt;&lt;span&gt;在线程间安全传递所有权&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果类型&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;Sync&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：就是向编译器表明该类型的实例&lt;/span&gt;&lt;b&gt;&lt;span&gt;在多线程并发中&lt;span&gt;不可能&lt;/span&gt;导致内存不安全&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，所以&lt;/span&gt;&lt;b&gt;&lt;span&gt;可以安全的跨线程共享&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.5.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些类型实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Send&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.5.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些类型实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Sync&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&amp;#13;
        &lt;/div&gt;&amp;#13;
        &amp;#13;
&amp;#13;
        &amp;#13;
        &amp;#13;
            &amp;#13;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>67237a30f36fd71f38d51cec88cb9a4a</guid>
<title>SOC 识别和检测威胁信息</title>
<link>https://toutiao.io/k/rjt9e0j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5MjgxNTQ1MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/lwEekEbzmGxGBnwuMt8Pl2JEDeIEZAQicLwfAsiak240e0dn14vAtj30QuZNZp0IMULxianDT9Yd40RXSrbdKQfWg/0?wx_fmt=png&quot; data-nickname=&quot;安全架构&quot; data-alias=&quot;&quot; data-signature=&quot;安全技术、架构技术、编码开发等技术的分享&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;       &lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;16985&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;序言&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
&lt;/section&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;序言&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;安全运营中心的主要功能就是检测安全威胁。安全工具，例如扩展检测和响应以及 SIEM，有助于识别可疑或恶意活动并向SOC分析师提出，然后由他们确定活动的有效性和严重性并定义适当的响应操作。这些任务的有效性决定了一个关键的安全指标：平均检测时间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;应对威胁是SOC 的次要功能。响应通常通过事件后修复所需的平均时间或MTTR来衡量。MTTD 和 MTTR 之间的联系很明确：越快识别威胁，就能越快对其做出响应。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;威胁检测和响应计划最初应侧重于检测受监控系统和网络中的威胁。对这一步提供了全面的可见性、高级分析和能够扩展大量数据并因此改进 MTTD 指标的分析引擎。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然而，成熟的威胁检测和响应计划不仅仅是简单地识别威胁，而是跟踪特定于威胁背后参与者的指标。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面谈谈 SOC 团队在跟踪威胁参与者时应考虑的一些因素。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;16985&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;如何理解威胁&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以下可被视为威胁：&lt;/p&gt;&lt;p&gt;漏洞利用：例如Log4Shell、SQL 注入和 CVE；&lt;/p&gt;&lt;p&gt;战术：例如侦察、横向移动和指挥与控制；&lt;/p&gt;&lt;p&gt;目标：即勒索软件、数据泄露和商业电子邮件泄露。&lt;/p&gt;&lt;p&gt;任何参与者都可以使用威胁，并且多个参与者依赖于相同的威胁。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SOC团队应触发对上述威胁的检测，因为它们可能会影响组织的运营，并且通常没有合法用途。一旦建立了触发检测，威胁检测程序就可以开始超越威胁，了解使用这些威胁的参与者的周围特征和行为。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8471910112359551&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lwEekEbzmGwmDE4PdIKmDsRh7gZ48nCen86wJsQX7x69EWBJYIxShcB5SJENBdAHe6Pq4yJz3dAOottCLHqP4g/640?wx_fmt=png&amp;amp;random=0.5465905852101993&amp;amp;random=0.6846165265628292&amp;amp;random=0.7814793972979193&amp;amp;random=0.18162165014619625&quot; data-type=&quot;png&quot; data-w=&quot;445&quot;/&gt;&lt;/p&gt;&lt;p&gt;网络安全专业人员使用入侵分析钻石模型来演示攻击者如何利用基础设施中的功能来瞄准受害者。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;16985&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;如何理解威胁参与者&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
&lt;/section&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;了解威胁参与者很复杂，但可以在威胁检测和响应方面产生巨大的回报。可以使用入侵分析的钻石模型跟踪和理解特定于参与者的指标。&lt;/p&gt;&lt;p&gt;它记录了四个不同的顶点：对手、能力、基础设施和受害者。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;对手&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;对手一词用于描述攻击者的独特特征。示例包括脚本和恶意软件中的加密钱包地址或商标。通过了解这些指标，安全响应者可以更有效地检测和响应威胁。指标需要适当加权，因为大多数是低保真度的调查触发器，不适合自动检测。然而，当智能应用时，它们可以帮助分析。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;能力&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;能力用于描述对手青睐的战术、技术和程序 (TTP)。通过了解受青睐的 TTP，SOC 知道下一步该去哪里进行检测以及攻击者的下一步行动可能是什么，从而使 SOC 能够使用有针对性的缓解或遏制响应行动来破坏攻击。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;能力顶点还着眼于对手的目标。通过了解妥协的预期最终目标，攻击者可以被击败——例如，通过关注勒索软件参与者的横向移动或如果数据泄露是目标，则审查数据库访问。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;全面的响应行动确保妥协得到整体解决，而不仅仅是被视为妥协的症状。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;基础设施&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;基础设施描述了用于传递 TTP 的内容，例如 IP 地址、电子邮件地址或域。通过了解基础设施，SOC 可以监控连接并捕获以前可能未知的零日漏洞或脚本。当执行威胁搜寻的分析师定期手动审查捕获的数据包时，监控基础设施已对零日漏洞和新兴漏洞提供早期预警。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;受害者&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;受害者是指目标对象或对象。通过了解攻击者所针对的组织或系统的类型，SOC 成员可以采取适当的预防措施为他们做好准备。&lt;/p&gt;&lt;p&gt;跟踪威胁背后的参与者是一项艰巨的工作，只能由希望增强其威胁检测和响应能力的成熟 SOC 执行。如果操作正确，SOC 可以显着降低关键的 MTTD 和 MTTR 指标，甚至可以从一开始就防止发生妥协。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;16980&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;结束&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;/section&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>