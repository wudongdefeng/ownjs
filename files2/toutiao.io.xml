<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b7dfc292ae7a965fcabd26f38df99b9b</guid>
<title>大文件上传时如何做到秒传？</title>
<link>https://toutiao.io/k/iyhuoxx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击&lt;strong&gt;&lt;span&gt;关注&lt;/span&gt;&lt;/strong&gt;公众号：&lt;/span&gt;&lt;/strong&gt;互联网架构师，后台回复&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot; 2T&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;2T&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;获取&lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2TB&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2TB&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;strong&gt;&lt;span&gt;学习资源！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上一篇：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523205&amp;amp;idx=1&amp;amp;sn=89b261f829ce6c3487ce8b2ccf3ed06b&amp;amp;chksm=ea5f56e3dd28dff5238989d3e07d775d34c04a4e80a166059e92e84379274819203d72d1dc1d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Alibaba开源内网高并发编程手册.pdf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;Alibaba开源内网高并发编程手册.pdf&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件上传是一个老生常谈的话题了，在文件相对比较小的情况下，可以直接把文件转化为字节流上传到服务器，但在文件比较大的情况下，用普通的方式进行上传，这可不是一个好的办法，毕竟很少有人会忍受，当文件上传到一半中断后，继续上传却只能重头开始上传，这种让人不爽的体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有没有比较好的上传体验呢，答案有的，就是下边要介绍的几种上传方式&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;秒传&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、什么是秒传&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通俗的说，你把要上传的东西上传，服务器会先做&lt;span&gt;MD5&lt;/span&gt;校验，如果服务器上有一样的东西，它就直接给你个新地址，其实你下载的都是服务器上的同一个文件，想要不秒传，其实只要让&lt;span&gt;MD5&lt;/span&gt;改变，就是对文件本身做一下修改（改名字不行），例如一个文本文件，你多加几个字，MD5就变了，就不会秒传了.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、本文实现的秒传核心逻辑&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;a&lt;/span&gt;、利用redis的set方法存放文件上传状态，其中key为文件上传的md5，value为是否上传完成的标志位，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;b&lt;/span&gt;、当标志位true为上传已经完成，此时如果有相同文件上传，则进入秒传逻辑。如果标志位为false，则说明还没上传完成，此时需要在调用set的方法，保存块号文件记录的路径，其中key为上传文件md5加一个固定前缀，value为块号文件记录路径&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;分片上传&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、什么是分片上传&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（我们称之为Part）来进行分别上传，上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、分片上传的场景&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.大文件上传&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.网络环境环境不好，存在需要重传风险的场景&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;断点续传&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、什么是断点续传&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断点续传是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传或者下载未完成的部分，而没有必要从头开始上传或者下载。本文的断点续传主要是针对断点上传场景。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2、应用场景&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断点续传可以看成是分片上传的一个衍生，因此可以使用分片上传的场景，都可以使用断点续传。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3、实现断点续传的核心逻辑&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分片上传的过程中，如果因为系统崩溃或者网络中断等异常因素导致上传中断，这时候客户端需要记录上传的进度。在之后支持再次上传时，可以继续从上次上传中断的地方进行继续上传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免客户端在上传之后的进度数据被删除而导致重新开始从头上传的问题，服务端也可以提供相应的接口便于客户端对已经上传的分片数据进行查询，从而使客户端知道已经上传的分片数据，从而从下一个分片数据开始继续上传。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4、实现流程步骤&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a、方案一，常规步骤&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化一个分片上传任务，返回本次分片上传唯一标识；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照一定的策略（串行或并行）发送各个分片数据块；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b、方案二、本文实现的步骤&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;前端（客户端）需要根据固定大小对文件进行分片，请求后端（服务端）时要带上分片序号和大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端创建conf文件用来记录分块位置，conf文件长度为总分片数，每上传一个分块即向conf文件中写入一个127，那么没上传的位置就是默认的0,已上传的就是Byte.MAX_VALUE 127（这步是实现断点续传和秒传的核心步骤）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器按照请求数据中给的分片序号和每片分块大小（分片大小是固定且一样的）算出开始位置，与读取到的文件片段数据，写入文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;5、分片上传/断点上传代码实现&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a、前端采用百度提供的webuploader的插件，进行分片。因本文主要介绍服务端代码实现，webuploader如何进行分片，具体实现可以查看如下链接:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;http://fex.baidu.com/webuploader/getting-started.html&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b、后端用两种方式实现文件写入，一种是用&lt;span&gt;RandomAccessFile&lt;/span&gt;，如果对&lt;span&gt;RandomAccessFile&lt;/span&gt;不熟悉的朋友，可以查看如下链接:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;https://blog.csdn.net/dimudan2015/article/details/81910690&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种是使用&lt;span&gt;MappedByteBuffer&lt;/span&gt;，对&lt;span&gt;MappedByteBuffer&lt;/span&gt;不熟悉的朋友，可以查看如下链接进行了解:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;https://www.jianshu.com/p/f90866dcbffc&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后端进行写入操作的核心代码&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、RandomAccessFile实现方式&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@UploadMode&lt;/span&gt;(mode = UploadModeEnum.RANDOM_ACCESS)  &lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RandomAccessUploadStrategy&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SliceUploadTemplate&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Autowired&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; FilePathUtil filePathUtil;  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${upload.chunkSize}&quot;&lt;/span&gt;)  &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; defaultChunkSize;  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;upload&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    RandomAccessFile accessTmpFile = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {  &lt;br/&gt;      String uploadDirPath = filePathUtil.getPath(param);  &lt;br/&gt;      File tmpFile = &lt;span&gt;super&lt;/span&gt;.createTmpFile(param);  &lt;br/&gt;      accessTmpFile = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(tmpFile, &lt;span&gt;&quot;rw&quot;&lt;/span&gt;);  &lt;br/&gt;      &lt;span&gt;//这个必须与前端设定的值一致  &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;long&lt;/span&gt; chunkSize = Objects.isNull(param.getChunkSize()) ? defaultChunkSize * &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;  &lt;br/&gt;          : param.getChunkSize();  &lt;br/&gt;      &lt;span&gt;long&lt;/span&gt; offset = chunkSize * param.getChunk();  &lt;br/&gt;      &lt;span&gt;//定位到该分片的偏移量  &lt;/span&gt;&lt;br/&gt;      accessTmpFile.seek(offset);  &lt;br/&gt;      &lt;span&gt;//写入该分片数据  &lt;/span&gt;&lt;br/&gt;      accessTmpFile.write(param.getFile().getBytes());  &lt;br/&gt;      &lt;span&gt;boolean&lt;/span&gt; isOk = &lt;span&gt;super&lt;/span&gt;.checkAndSetUploadProgress(param, uploadDirPath);  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; isOk;  &lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {  &lt;br/&gt;      log.error(e.getMessage(), e);  &lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {  &lt;br/&gt;      FileUtil.close(accessTmpFile);  &lt;br/&gt;    }  &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、MappedByteBuffer实现方式&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@UploadMode&lt;/span&gt;(mode = UploadModeEnum.MAPPED_BYTEBUFFER)  &lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MappedByteBufferUploadStrategy&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SliceUploadTemplate&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Autowired&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; FilePathUtil filePathUtil;  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${upload.chunkSize}&quot;&lt;/span&gt;)  &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; defaultChunkSize;  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;upload&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    RandomAccessFile tempRaf = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;    FileChannel fileChannel = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;    MappedByteBuffer mappedByteBuffer = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {  &lt;br/&gt;      String uploadDirPath = filePathUtil.getPath(param);  &lt;br/&gt;      File tmpFile = &lt;span&gt;super&lt;/span&gt;.createTmpFile(param);  &lt;br/&gt;      tempRaf = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(tmpFile, &lt;span&gt;&quot;rw&quot;&lt;/span&gt;);  &lt;br/&gt;      fileChannel = tempRaf.getChannel();  &lt;br/&gt;  &lt;br/&gt;      &lt;span&gt;long&lt;/span&gt; chunkSize = Objects.isNull(param.getChunkSize()) ? defaultChunkSize * &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;  &lt;br/&gt;          : param.getChunkSize();  &lt;br/&gt;      &lt;span&gt;//写入该分片数据  &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;long&lt;/span&gt; offset = chunkSize * param.getChunk();  &lt;br/&gt;      &lt;span&gt;byte&lt;/span&gt;[] fileData = param.getFile().getBytes();  &lt;br/&gt;      mappedByteBuffer = fileChannel  &lt;br/&gt;.map(FileChannel.MapMode.READ_WRITE, offset, fileData.length);  &lt;br/&gt;      mappedByteBuffer.put(fileData);  &lt;br/&gt;      &lt;span&gt;boolean&lt;/span&gt; isOk = &lt;span&gt;super&lt;/span&gt;.checkAndSetUploadProgress(param, uploadDirPath);  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; isOk;  &lt;br/&gt;  &lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {  &lt;br/&gt;      log.error(e.getMessage(), e);  &lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {  &lt;br/&gt;  &lt;br/&gt;      FileUtil.freedMappedByteBuffer(mappedByteBuffer);  &lt;br/&gt;      FileUtil.close(fileChannel);  &lt;br/&gt;      FileUtil.close(tempRaf);  &lt;br/&gt;  &lt;br/&gt;    }  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、文件操作核心模板类代码&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SliceUploadTemplate&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SliceUploadStrategy&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;upload&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param)&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; File &lt;span&gt;createTmpFile&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    FilePathUtil filePathUtil = SpringContextHolder.getBean(FilePathUtil&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;  &lt;br/&gt;    param.setPath(FileUtil.withoutHeadAndTailDiagonal(param.getPath()));  &lt;br/&gt;    String fileName = param.getFile().getOriginalFilename();  &lt;br/&gt;    String uploadDirPath = filePathUtil.getPath(param);  &lt;br/&gt;    String tempFileName = fileName + &lt;span&gt;&quot;_tmp&quot;&lt;/span&gt;;  &lt;br/&gt;    File tmpDir = &lt;span&gt;new&lt;/span&gt; File(uploadDirPath);  &lt;br/&gt;    File tmpFile = &lt;span&gt;new&lt;/span&gt; File(uploadDirPath, tempFileName);  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!tmpDir.exists()) {  &lt;br/&gt;      tmpDir.mkdirs();  &lt;br/&gt;    }  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; tmpFile;  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; FileUploadDTO &lt;span&gt;sliceUpload&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; isOk = &lt;span&gt;this&lt;/span&gt;.upload(param);  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isOk) {  &lt;br/&gt;      File tmpFile = &lt;span&gt;this&lt;/span&gt;.createTmpFile(param);  &lt;br/&gt;      FileUploadDTO fileUploadDTO = &lt;span&gt;this&lt;/span&gt;.saveAndFileUploadDTO(param.getFile().getOriginalFilename(), tmpFile);  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; fileUploadDTO;  &lt;br/&gt;    }  &lt;br/&gt;    String md5 = FileMD5Util.getFileMD5(param.getFile());  &lt;br/&gt;  &lt;br/&gt;    Map&amp;lt;Integer, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();  &lt;br/&gt;    map.put(param.getChunk(), md5);  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; FileUploadDTO.builder().chunkMd5Info(map).build();  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;/**  &lt;br/&gt;   * 检查并修改文件上传进度  &lt;br/&gt;   */&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;checkAndSetUploadProgress&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param, String uploadDirPath)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    String fileName = param.getFile().getOriginalFilename();  &lt;br/&gt;    File confFile = &lt;span&gt;new&lt;/span&gt; File(uploadDirPath, fileName + &lt;span&gt;&quot;.conf&quot;&lt;/span&gt;);  &lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt; isComplete = &lt;span&gt;0&lt;/span&gt;;  &lt;br/&gt;    RandomAccessFile accessConfFile = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {  &lt;br/&gt;      accessConfFile = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(confFile, &lt;span&gt;&quot;rw&quot;&lt;/span&gt;);  &lt;br/&gt;      &lt;span&gt;//把该分段标记为 true 表示完成  &lt;/span&gt;&lt;br/&gt;      System.out.println(&lt;span&gt;&quot;set part &quot;&lt;/span&gt; + param.getChunk() + &lt;span&gt;&quot; complete&quot;&lt;/span&gt;);  &lt;br/&gt;      &lt;span&gt;//创建conf文件文件长度为总分片数，每上传一个分块即向conf文件中写入一个127，那么没上传的位置就是默认0,已上传的就是Byte.MAX_VALUE 127  &lt;/span&gt;&lt;br/&gt;      accessConfFile.setLength(param.getChunks());  &lt;br/&gt;      accessConfFile.seek(param.getChunk());  &lt;br/&gt;      accessConfFile.write(Byte.MAX_VALUE);  &lt;br/&gt;  &lt;br/&gt;      &lt;span&gt;//completeList 检查是否全部完成,如果数组里是否全部都是127(全部分片都成功上传)  &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;byte&lt;/span&gt;[] completeList = FileUtils.readFileToByteArray(confFile);  &lt;br/&gt;      isComplete = Byte.MAX_VALUE;  &lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; completeList.length &amp;amp;&amp;amp; isComplete == Byte.MAX_VALUE; i++) {  &lt;br/&gt;        &lt;span&gt;//与运算, 如果有部分没有完成则 isComplete 不是 Byte.MAX_VALUE  &lt;/span&gt;&lt;br/&gt;        isComplete = (&lt;span&gt;byte&lt;/span&gt;) (isComplete &amp;amp; completeList[i]);  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;check part &quot;&lt;/span&gt; + i + &lt;span&gt;&quot; complete?:&quot;&lt;/span&gt; + completeList[i]);  &lt;br/&gt;      }  &lt;br/&gt;  &lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {  &lt;br/&gt;      log.error(e.getMessage(), e);  &lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {  &lt;br/&gt;      FileUtil.close(accessConfFile);  &lt;br/&gt;    }  &lt;br/&gt; &lt;span&gt;boolean&lt;/span&gt; isOk = setUploadProgress2Redis(param, uploadDirPath, fileName, confFile, isComplete);  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; isOk;  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;/**  &lt;br/&gt;   * 把上传进度信息存进redis  &lt;br/&gt;   */&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;setUploadProgress2Redis&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param, String uploadDirPath,  &lt;br/&gt;      String fileName, File confFile, &lt;span&gt;byte&lt;/span&gt; isComplete)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    RedisUtil redisUtil = SpringContextHolder.getBean(RedisUtil&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isComplete == Byte.MAX_VALUE) {  &lt;br/&gt;      redisUtil.hset(FileConstant.FILE_UPLOAD_STATUS, param.getMd5(), &lt;span&gt;&quot;true&quot;&lt;/span&gt;);  &lt;br/&gt;      redisUtil.del(FileConstant.FILE_MD5_KEY + param.getMd5());  &lt;br/&gt;      confFile.delete();  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;  &lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {  &lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!redisUtil.hHasKey(FileConstant.FILE_UPLOAD_STATUS, param.getMd5())) {  &lt;br/&gt;        redisUtil.hset(FileConstant.FILE_UPLOAD_STATUS, param.getMd5(), &lt;span&gt;&quot;false&quot;&lt;/span&gt;);  &lt;br/&gt;        redisUtil.set(FileConstant.FILE_MD5_KEY + param.getMd5(),  &lt;br/&gt;            uploadDirPath + FileConstant.FILE_SEPARATORCHAR + fileName + &lt;span&gt;&quot;.conf&quot;&lt;/span&gt;);  &lt;br/&gt;      }  &lt;br/&gt;  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;  &lt;br/&gt;    }  &lt;br/&gt;  }  &lt;br/&gt;&lt;span&gt;/**  &lt;br/&gt;   * 保存文件操作  &lt;br/&gt;   */&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; FileUploadDTO &lt;span&gt;saveAndFileUploadDTO&lt;/span&gt;&lt;span&gt;(String fileName, File tmpFile)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    FileUploadDTO fileUploadDTO = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {  &lt;br/&gt;  &lt;br/&gt;      fileUploadDTO = renameFile(tmpFile, fileName);  &lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (fileUploadDTO.isUploadComplete()) {  &lt;br/&gt;        System.out  &lt;br/&gt;            .println(&lt;span&gt;&quot;upload complete !!&quot;&lt;/span&gt; + fileUploadDTO.isUploadComplete() + &lt;span&gt;&quot; name=&quot;&lt;/span&gt; + fileName);  &lt;br/&gt;        &lt;span&gt;//TODO 保存文件信息到数据库  &lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;      }  &lt;br/&gt;  &lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {  &lt;br/&gt;      log.error(e.getMessage(), e);  &lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {  &lt;br/&gt;  &lt;br/&gt;    }  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fileUploadDTO;  &lt;br/&gt;  }  &lt;br/&gt;&lt;span&gt;/**  &lt;br/&gt;   * 文件重命名  &lt;br/&gt;   *  &lt;br/&gt;   * &lt;span&gt;@param&lt;/span&gt; toBeRenamed 将要修改名字的文件  &lt;br/&gt;   * &lt;span&gt;@param&lt;/span&gt; toFileNewName 新的名字  &lt;br/&gt;   */&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; FileUploadDTO &lt;span&gt;renameFile&lt;/span&gt;&lt;span&gt;(File toBeRenamed, String toFileNewName)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;//检查要重命名的文件是否存在，是否是文件  &lt;/span&gt;&lt;br/&gt;    FileUploadDTO fileUploadDTO = &lt;span&gt;new&lt;/span&gt; FileUploadDTO();  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!toBeRenamed.exists() || toBeRenamed.isDirectory()) {  &lt;br/&gt;      log.info(&lt;span&gt;&quot;File does not exist: {}&quot;&lt;/span&gt;, toBeRenamed.getName());  &lt;br/&gt;      fileUploadDTO.setUploadComplete(&lt;span&gt;false&lt;/span&gt;);  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; fileUploadDTO;  &lt;br/&gt;    }  &lt;br/&gt;    String ext = FileUtil.getExtension(toFileNewName);  &lt;br/&gt;    String p = toBeRenamed.getParent();  &lt;br/&gt;    String filePath = p + FileConstant.FILE_SEPARATORCHAR + toFileNewName;  &lt;br/&gt;    File newFile = &lt;span&gt;new&lt;/span&gt; File(filePath);  &lt;br/&gt;    &lt;span&gt;//修改文件名  &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; uploadFlag = toBeRenamed.renameTo(newFile);  &lt;br/&gt;  &lt;br/&gt;    fileUploadDTO.setMtime(DateUtil.getCurrentTimeStamp());  &lt;br/&gt;    fileUploadDTO.setUploadComplete(uploadFlag);  &lt;br/&gt;    fileUploadDTO.setPath(filePath);  &lt;br/&gt;    fileUploadDTO.setSize(newFile.length());  &lt;br/&gt;    fileUploadDTO.setFileExt(ext);  &lt;br/&gt;    fileUploadDTO.setFileId(toFileNewName);  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fileUploadDTO;  &lt;br/&gt;  }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实现分片上传的过程，需要前端和后端配合，比如前后端的上传块号的文件大小，前后端必须得要一致，否则上传就会有问题。其次文件相关操作正常都是要搭建一个文件服务器的，比如使用&lt;span&gt;fastdfs&lt;/span&gt;、&lt;span&gt;hdfs&lt;/span&gt;等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本示例代码在电脑配置为4核内存8G情况下，上传24G大小的文件，上传时间需要30多分钟，主要时间耗费在前端的&lt;span&gt;md5&lt;/span&gt;值计算，后端写入的速度还是比较快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果项目组觉得自建文件服务器太花费时间，且项目的需求仅仅只是上传下载，那么推荐使用阿里的oss服务器，其介绍可以查看官网:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;https://help.aliyun.com/product/31815.html&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里的oss它本质是一个对象存储服务器，而非文件服务器，因此如果有涉及到大量删除或者修改文件的需求，oss可能就不是一个好的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文末提供一个oss表单上传的链接demo，通过oss表单上传，可以直接从前端把文件上传到oss服务器，把上传的压力都推给oss服务器:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;https://www.cnblogs.com/ossteam/p/4942227.html&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;-End-&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template-id=&quot;527&quot; data-mpa-category=&quot;image&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template-id=&quot;1357582&quot; data-mpa-category=&quot;image&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;最后，关注公众号互联网架构师，在后台回复：2T，可以获取我整理的 Java 系列面试题和答案，非常齐全&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1423611111111112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRI2cbvKcYHPMKYlo4ibO3ZXG4kRnuC195QBJzMR0VLd7p08kYInDEEiasufnLsY7LhFwPIml2fPergw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;288&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;正文结束&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;推荐阅读 ↓↓↓&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;1.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247527958&amp;amp;idx=1&amp;amp;sn=6d407650c574b304b681aecbf5c1323b&amp;amp;chksm=ea5fa370dd282a66a8b6463fb60ad850d47cc35d727ac4b66fdf29f88ce30eef400287b1b746&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;全新 IDEA 2022.2 正式发布，新特性真香！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;全新 IDEA 2022.2 正式发布，新特性真香！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2&lt;span&gt;.&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247488035&amp;amp;idx=1&amp;amp;sn=5300893903094128bdc20ce2a5717a50&amp;amp;chksm=ea5cdf45dd2b56531ac0c3a8fb8b56b06bc546785f8772a4d02e2ca87c4e30f25b24bf21f784&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;从零开始搭建创业公司后台技术栈&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3&lt;span&gt;.&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247488928&amp;amp;idx=1&amp;amp;sn=4c56dd675e1b32a73b698df3d5e8609f&amp;amp;chksm=ea5cd8c6dd2b51d05e6d6d715418241f471ccb3002719263b2d0e092763f68f3691249970a08&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;程序员一般可以从什么平台接私活？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;4&lt;span&gt;.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247527535&amp;amp;idx=1&amp;amp;sn=6cb6c086057aebaedc47859518eb80da&amp;amp;chksm=ea5fa109dd28281f3a90a36ea1deb7e8d1658d221f718ea15023b0345b53fc496c137496d10d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Spring中毒太深，离开Spring我连最基本的CRUD都不会写了...&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring中毒太深，离开Spring我连最基本的CRUD都不会写了...&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;5.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247513283&amp;amp;idx=1&amp;amp;sn=3b3d8e893a1241cf5af2150370ae9d71&amp;amp;chksm=ea5f79a5dd28f0b3a7603b1fbdb306f77ac64223bd05c4b7f0dc0469f77a68359810c5de2a01&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;为什么国内 996 干不过国外的 955呢？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;为什么国内 996 干不过国外的 955呢？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;6&lt;span&gt;.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247528236&amp;amp;idx=1&amp;amp;sn=c675d5d3aede21b4b7ebbba21eadf96c&amp;amp;chksm=ea5fa24add282b5cfb13757cd534ec600fb910f9dcb7f3ee3dea5e7929e0fbbd22381625ff20&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;中国的铁路订票系统在世界上属于什么水平？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;中国的铁路订票系统在世界上属于什么水平？&lt;/a&gt;                        &lt;/span&gt;&lt;/p&gt;&lt;p&gt;7&lt;span&gt;.&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247488564&amp;amp;idx=1&amp;amp;sn=256862239b12a1313919ee3ea6ff0d1c&amp;amp;chksm=ea5cd952dd2b50443feec88eb893233d2f6cf33f89e2ce72192c98035fd26cb0eb797a86f8f0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;15张图看懂瞎忙和高效的区别！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100030073&quot; data-ratio=&quot;0.1328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3GQek52mKtWDXtSkfViaQ2FZ2ZfSyjBcSkArjQVCMH4a7uxg6Vkibiaiciaiae2uxvzia7yib04tleLiaqcFVGUf2vcMf4A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b102fb53d64a9d5b002ddf4b7c1a623f</guid>
<title>携程海外MySQL数据复制实践</title>
<link>https://toutiao.io/k/tlkmfx5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;oy，携程软件技术专家，负责MySQL双向同步DRC和数据库访问中间件DAL的开发演进，对分布式系统高可用设计、分布式存储，数据一致性领域感兴趣。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在携程国际化战略背景下，海外业务将成为新的发力点，为了保证用户高品质的服务体验，底层数据势必需要就近服务业务应用。一套标准且普适的数据复制解决方案能够提升业务决策效率，助力业务更快地触达目标用户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DRC (Data Replicate Center) 作为携程内部数据库上云标准解决方案，支撑了包括但不限于即时通讯、用户账号、IBU在内的核心基础服务和国际业务顺利上云。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、业务上云场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务上云前，要先要思考2个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 应用上云&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对用户延迟不敏感或者离线业务，可以采用只应用上云数据库不上云，请求回源国内。该方案下业务需要改造应用中读写数据库操作，根据应用部署地，决定流量是否需要转发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不建议海外应用直连国内数据库，网络层面专线距离远，成本太高，不现实；安全层面应禁止跨海访问，否则可能导致预期就近访问流量由于非预期错误，将海外流量写入国内数据库，从而引起国内数据错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4236111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEjY3SE0W4eXc9CGKgwc8FmlIVuibabQczpicqIZmIRXibKVCKwyIa8AUdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 数据库上云&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于在线用户延迟敏感应用，数据库必须跟随应用一同上云，将请求闭环在海外，从而就近提供服务响应。在确定数据库上云的前提下，根据不同业务特点，可再细分为海外只读和读写两种场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;只读场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于海外只读场景，国内数据只需要单向复制，该方案下业务海外账号默认无写权限或者业务改造写操作，避免出现由于误写导致国内海外数据不一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49226804123711343&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEoaib6gzW5aBSF0GYxx9X7BiayvEQyNvhFhXaBwp28w2dbNj9Gxxd7X0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;776&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;读写场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于海外读写场景，国内海外数据需要双向复制，业务代码无需改造。该方案下由于有2个Master可以写入，业务需要在应用层对流量进行切分，比如用户归属地维度，从而避免在两侧同时修改同一条数据，进而导致复制过程出现数据冲突。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.493573264781491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEibpKzBCU33Wt5tc9FgJYwEL37t9quHGUnD6iaGxbW8AnIeADV3ukZKcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3 上云成本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据距离用户越近，应用直接提供的服务功能越丰富，对应业务改造量越小，机器资源消耗量越大。携程海外应用部署在AWS公有云上，AWS入口流量不计费，只针对出口流量计费。应用上云数据库不上云场景，请求回源国内产生出口流量费用；只读业务单方向数据复制流入，不收费；读写业务数据复制回国内产生出口流量费用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table role=&quot;grid&quot; resolved=&quot;&quot;&gt;&lt;tbody aria-live=&quot;polite&quot; aria-relevant=&quot;all&quot;&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;上云场景&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;AWS出口流量&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;数据库成本&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;机器成本&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;业务改造&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr role=&quot;row&quot;&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;span&gt;应用上云&lt;/span&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;业务请求流量&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;无&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;span&gt;无&lt;/span&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;改造读写请求&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr role=&quot;row&quot;&gt;&lt;td colspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;数据库上云/只读&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;无&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;RDS费用&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt; 单向复制&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;改造写请求&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr role=&quot;row&quot;&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;数据库上云/读写&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;海外→国内复制流量&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;RDS费用&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt; 双向复制&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;span&gt;无&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;上云成本主要集中在流量和数据库费用。AWS出口Internet流量0.09$/GB，当流量大时，可通过数据压缩，损耗复制延迟降低出口流量；RDS根据核数计费，1004元/核/月，业务流量少时采用普通4C16G机型即可，流量增加后动态提升配置。核心业务RDS配置一主一从，非核心业务单主即可，并且多个DB可共用一个集群，进而降低成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.4 小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了提供高品质的用户体验，数据势必需要上云。在解决了是否上云的问题后，如何上云就成为新的疑问点。下面就详细分析携程内部上云过程中依赖的数据库复制组件DRC实现细节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、数据库上云方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DRC基于开源模式开发，公司内部生产版本和开源保持一致，开源地址&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/ctripcorp/drc&quot; textvalue=&quot;https://github.com/ctripcorp/drc&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;https://github.com/ctripcorp/drc&lt;/a&gt;，欢迎关注。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DRC孵化于异地多活项目，参见&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;amp;mid=2697269807&amp;amp;idx=1&amp;amp;sn=1d32b44d6108309309e93c4810b24b83&amp;amp;chksm=8376ed1bb401640d74f875189e75c085434e834de9ec8b8cdbf8083bdcfe0717e39e5723e49c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《携程异地多活-MySQL实时双向（多向）复制实践》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《携程异地多活-MySQL实时双向（多向）复制实践》&lt;/a&gt;，解决国内异地机房间数据库同步问题。当其中一个或多个机房位置转变为公有云时，伴随着物理距离的扩大，新的问题应运而生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就DRC自身架构实现而言：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41590214067278286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsE837xZ60R1cOAu7E9icUgseJrQ8CMa1EXKbu1ePXicxMCh3NNgoPVop7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1308&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;就业务接入而言：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于以上限制，DRC调整架构，引入代理模块解决网络联通性问题，借用事务表降低复制链路对权限的要求；为了适应业务的多样性，分别从库、表和行维度支持按需复制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1 架构改造挑战&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）架构升级&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;DRC中有2个核心功能需要跨公网传输数据：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数据复制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以单向复制为例，在Binlog拉取模块Replicator和解析应用模块Applier之间引入Proxy，负责在TCP层将内网/公网流量转发到公网/内网。Proxy绑定公网IP，采用TLS协议加密传输内网流量。鉴于公网质量不稳定特性，Proxy使用BBR拥塞控制算法，优化丢包引起的卡顿。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Proxy作为公网数据传输携程内部统一的解决方案，参见《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;amp;mid=2697267768&amp;amp;idx=1&amp;amp;sn=d8f38ab6e6e034ad36b9d1a47a792e45&amp;amp;chksm=8376f50cb4017c1a23ee0ac7ee7e4bd02599565598fdc57d7aaa48e130e4863fb6241a212f67&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;携程Redis海外机房数据同步实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;携程Redis海外机房数据同步实践&lt;/a&gt;》，开源地址：&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/ctripcorp/x-pipe&quot; textvalue=&quot;https://github.com/ctripcorp/x-pipe&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;https://github.com/ctripcorp/x-pipe&lt;/a&gt;，欢迎关注。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3314037626628075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEubMgzibgqcpkD4yuRJYc3pUO8kaGkgo3ZxpMiaRic3rQJiaJGdTFac2xtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1382&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;延迟监控&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;延迟监控探针从业务流量同侧机房的Console写入到业务数据库延迟监控表(初始化时新建)，经过双向复制链路，从异侧机房接收延迟探针，从而计算差值得到复制延迟。为了提升Proxy间隔离性，数据复制和延迟监控可以分别配置不同的Proxy实例实现数据传输。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47324414715719065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsExBW4B6O45KBNgMXWdoXUUmficSXiaqrbUFuaClwHIgCI8Hc30tCLd9Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1196&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Proxy Client&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于Applier和Console都需要对接Proxy，如何降低Proxy对DRC系统的侵入性就成为一个需要解决的问题。为此我们借助Java Agent技术，动态修改字节码，实现了可插拔的接入方式。接入方只需要引入proxy-client独立Jar包，业务层按需实现Proxy的注册和注销。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）网络优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;公网网络丢包和拥塞频发，为了在弱网环境下实现平稳复制，就需要快速地异常检测恢复机制。除了在系统层将Proxy拥塞控制算法优化为BBR外，DRC在应用层额外增加：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27167630057803466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEeicunCaZWPfNh6QXiajK59RnQiapfzw79fg4r27bdibYB5iaLjvYJSSNSJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;心跳检测&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Binlog生产方Replicator定时对下游消费方进行心跳检测，消费方接收到心跳检测需回复响应，Replicator根据最后一次接收时间检测并自动关闭长期没有响应的连接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里有一种场景需要特别处理，当下游消费方比较忙，主动关闭连接auto_read属性时，由于应用层无法读取暂存在缓冲区的心跳包，从而造成无法响应。这就需要消费方在auto_read改变时，主动上报生产方自身的auto_read状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;流量控制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;公网网络质量下降导致复制延迟变大，数据堆积在发送端Proxy，进而引起Replicator和Proxy触发流控；MySQL性能抖动，应用Binlog速度减缓，数据堆积在Applier，进而引起Applier触发流控并逐层反馈到Replicator。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;运营商线路&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对Proxy出口IP，分别配置移动和联通两条运营商线路，当Binlog消费方由于触发空闲检测出现超时重连时，Proxy会随机选择一个运营商出口IP，从而实现运营商线路的互备。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）事务表复制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;国内机房间数据复制时，DBA可以给予DRC拥有root权限的账号，以实现Applier模拟原生Slave节点set gtid_next工作方式应用Binlog，从而将一个事务变更从源机房复制到目标机房，并且在两端分配到同一个gtid下。但是公有云上RDS出于安全原因是无法开放root权限，直接从原理上否定了原有的复制方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了找到合理的替换方案，我们首先从MySQL服务端视角分析下set gtid_next的效果：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其根本性作用在于将DRC指定的gtid值保存到MySQL系统变量。既然无法利用MySQL系统变量，那么从业务层增加一个复制变量保存gtid信息即可实现同等效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其次，转换到DRC复制视角，set gtid_next起到如下作用：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;综上分析，新的替代方案需要引入持久化变量，记录复制位点并且能够提供循环阻断信息功效，为此DRC引入基于事务表的同步方案解决了海外复制难题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;位点记录&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;海外复制业务集群需要新增复制库drcmonitordb，其中新建事务表gtid_executed。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;`drcmonitordb`.`gtid_executed` (&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;`id` &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;(11) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;NOT&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;`server_uuid` &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;char&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;(36) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;NOT&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;`gno` &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;bigint&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;(20) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;NOT&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;`gtidset` longtext,&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;PRIMARY&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;KEY&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;(`id`,`server_uuid`)&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;) ENGINE=InnoDB &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;DEFAULT&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;CHARSET=utf8mb4;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当Applier应用SQL到目标数据库前，需要先更新事务表，记录gtid，然后再执行事务中变更语句，完整的复制流程如下图所示。事务表中gno=0行中gtidset等效MySQL系统变量gtid_executed，Applier执行过程中定时汇总非0行事务gno，从而达到记录位点功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42216358839050133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEsMZ2YC4oMyeOFKELDicnlV272HIq6HHOxdYxt26oWT5VaESnXv6xricg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1516&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;循环阻断&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对Binlog中第一个写事件是事务表gtid_executed操作的事务，Replicator将其判断为DRC复制数据，从而阻断循环复制，否则一条数据会在双向复制环内无限死循环。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 业务落地挑战&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至此DRC解决了理论上阻碍复制的已知技术问题，在实际业务落地过程中，出于数据安全、费用和改造成本的考虑，业务对数据复制提出了更精细化控制的需求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）数据隔离&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;出于合规的要求，业务上云后，需要完成国内和海外用户数据的隔离。业务上云前，国内和海外用户数据全部在国内数据库；上云时就需要将海外用户数据单独复制到公有云而过滤掉国内用户数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;库表映射&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;上云前国内和海外数据在同一张母表。为了上云，业务通过在国内数据库新增子表，实现国内数据的分离。海外由于只存在海外数据，所以物理上只需要一张母表即可，即国内子表与海外母表相对应，搭建DRC实现双向复制即可。由于母表和子表表名不同，复制时需要做库表映射，从而屏蔽应用层对不同表名的感知，降低业务改造量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2825788751714678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEYicoTNBLZqNYXMukMgHtH38yg5ESAjTuozquW7w2yHZyO0zJcs5cAvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1458&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;行过滤&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;库表映射不涉及数据过滤，经过DRC的流量都会进行复制，因此映射在Applier端处理，直接根据映射规则替换表名即可。为此业务需要进行2处改造：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了进一步降低业务改造量，DRC提供行过滤功能，用户无需进行业务改造，只需保证表中包含Uid字段即可，DRC根据Uid自动判断数据归属地，进行数据过滤。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2934472934472934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEJt4828Ap03HibXicxtEZHWNIo5e6YpfJJibFM6hJz4BHAMMWgtgjbicXxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1404&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;单向复制链路级别添加行过滤配置，其中包括：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（1）Uid过滤，业务层面一般通过Uid维度进行拆分，通过SPI动态加载Uid过滤实现，携程内部由于Uid无特殊标记，无法通过Uid名称判断出归属地，只能通过SOA远程调用实时判断Uid归属地获得过滤结果；如果Uid有规则可循，则可以通过正则表达式匹配即可&lt;/p&gt;&lt;p&gt;（2）Java正则表达式，支持针对单字段的Java正则表达式简单匹配计算，适合单一维度数值有规则的业务场景&lt;/p&gt;&lt;p&gt;（3）Aviator表达式，支持针对多字段的Aviator表达式复杂匹配计算，适合多维度数值相关联的业务场景&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;包含表到过滤字段的映射关系，以及与过滤类型对应的上下文，比如正则表达式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3460559796437659&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEvAWDs405YibU8LYg9v1en6uueySCO1ggaGlnu13KvE2riceTObrnK3XA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Applier Binlog请求中携带行过滤配置，Replicator根据过滤类型加载对应的过滤规则，从而计算出过滤结果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;行过滤在发送端Replicator实现，这样实现的好处是跨海发送数据量大大降低，但同时也带来了解析和重构Rows Event的复杂性和性能损耗，即先解析Rows Event并根据过滤后的行数据生成新的Rows Event。Rows Event的解析需要表结构信息，而表结构信息是保存在Binlog的头中，势必在Rows Event前保证能够获得对应的表结构；解析后就可以将每行过滤字段值应用到过滤规则上，若匹配出需要过滤的行，则需要根据过滤后的行构造新的Rows Event并发送，否则直接发送即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.171900826446281&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEFrWJZnDbRfJkibuXBbAx2qGiaDburLibEwAH3hFGsn5UUBz4kmibxRS07g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1210&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）数据库混部&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;核心业务随着数据量的膨胀，会采用分库来降低数据库压力，在公有云部署时，鉴于云上初始流量不多，并且可动态提升机器配置，DBA部署时会将所有分库部署在同一个RDS集群，此时复制从一对一变成一对多。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.650137741046832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEzKCtGxm87w5z5BpFkibNIicf2R4VkIDnicupdo4em2Fdl0RSLx5T4cb4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;表过滤&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;单向复制链路级别添加库表过滤配置，支持Aviator表达式。Replicator发送前，通过将从Binlog中解析的库表名作用于Aviator表达式从而得到过滤结果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1989795918367347&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEZpXQGq08IHDgNgzYdjJM4WE7lMia44UFSSzEw3qmrSd4ACcSFfLYMwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 数据库上云流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;完整的业务上云流程一般分为四步：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;数据库先上云，搭建国内海外数据库复制，验证海外数据可用性和完整性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在海外数据可用的前提下，应用上云，就近访问海外数据库，验证部署海外应用可行性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;流量路由层灰度业务流量，可根据Uid白名单、流量百分比在流量接入层进行灰度，验证业务逻辑正确性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;灰度完成，国内和海外流量完成切分，验证国内和海外业务隔离性，为此后下线底层数据复制做准备&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08717105263157894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEHXypqLovHiaUfnzfjzllaI9l1m7iaXOWJia9IdxJV9PbQnbRXianRImseA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1216&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据库上云在每一步都有所涉及，第一步通过DRC解决了数据的可用性问题，第二步通过数据库访问中间件解决了数据可达性问题，第三步业务通过流量准确切分保证数据一致性问题，第四步国内海外实现数据隔离后，即可下线DRC数据复制。在分析完DRC原理后，下面再分析下其他几步数据库相关问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）数据访问层&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Dal包含中心化配置管理服务端Dal Cluster和Dal客户端两部分。上云前同一个数据库物理上只有一个集群，上云后海外增加相同集群，服务端Dal Cluster就需要根据客户端环境下发正确的MySQL配置文件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEwc1J1zDaPjQFPU7hZ4WwtfStE6J3dg9fcVg04Sb5EHo47C9KgK6TBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Dal Cluster原理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Dal Cluster变更推送功能借由分布式配置中心完成，配置中心提供子环境功能，国内数据库配置默认放在父环境，海外数据库则会在上线流程中生成对应的子环境数据库配置。这样在Dal Client启动时，带有不同环境配置的客户端会拉取到不同的配置，从而实现数据库的就近访问，整个过程对业务透明，代码无需改造。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3423076923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEjHoWuZgS8LlzD09uZx6xlVdZ1O53KZQEBYMHpcNjcWgnmWMicEs9WKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）流量切分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;业务上云一般采用Uid归属地进行流量切分，当流量开始灰度后，两端数据库都开始接收写流量。如果流量灰度不干净，针对同一个Uid数据在两端同时被修改，则会导致底层DRC数据复制时出现数据冲突。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当冲突发生时，Applier默认根据时间戳进行冲突策处理，接入DRC的表都有一个精确到毫秒自动更新的时间戳，时间戳最新的数据会被采用，从而实现数据的一致。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）表结构变更&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过DRC复制的集群，在表结构变更流程中，会自动关联到公有云集群，在两端同时进行变更操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于变更完成时间有先后，假设一个增加字段的变更海外先完成，在国内完成变更前的时间范围内，针对该表海外到国内的复制将出现复制冲突，默认DRC会捕获该异常，并从异常信息中提取出列名，将多出的列从SQL中移除后再执行，从而自动处理掉冲突。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当国内集群完成表结构变更后，新增列的值在两端都为默认值，数据仍然一致。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3609341825902335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsETwn04kzcKt935L9LibXPQKaVGBufG7UmazLTc2FctanyiajzzLm7Q9uA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.4 业务落地成果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;海外数据库复制从2021年11月上线至今，接入公司90+复制集群；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上海↔新加坡AWS复制平均延迟90ms，上海↔法兰克福AWS复制平均延迟260ms；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;账号集群通过库表映射，常旅、收藏等通过行过滤实现用户数据隔离；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过一对多部署，公有云/国内机房MySQL集群比维持在1/5，DRC复制成本/MySQL集群成本维持在2/5；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、未来规划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;DRC开源地址：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ctripcorp/drc&quot; src=&quot;https://github.com/ctripcorp/drc&quot; data-linktype=&quot;2&quot;&gt;https://github.com/ctripcorp/drc&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【推荐阅读】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEzpVTCEmmvAb4IMEQpEpZT44P1k4cecduytGtvRjVjNTjwhMugwBlhA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6da6b77976d5ec6a0b64037c1e098041</guid>
<title>计算机极简公开课推荐</title>
<link>https://toutiao.io/k/3n242s7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;网上有很多推荐计算机公开课的帖子，但有的文章推荐了太多，反而容易收藏后吃灰。故针对计算机的基础知识，推荐几门我觉得不错的公开课给大家。&lt;/p&gt;&lt;p&gt;这些课大部分我都做过一些（惭愧，都没有完全做完），用打星的方式来标识下难度，五星最难，打分难免主观，欢迎拍砖。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;工具环境：MIT:The Missing Semester of Your CS Education&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难度级别：★★&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工欲善其事，必先利其器。操作系统、数据库这些计算机基础诚然重要，但是一个程序员实际工作中天天打交道的其实是这些工具。因此，这门课值得放在最前面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;The Missing Semester of Your CS Education：https:/missing.csail.mit.edu&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中文翻译：https://missing-semester-cn.github.io/&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5NTcxNzY2OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/jHMBqsHehTOuL8q0hDhPPF0wYIIkDAHic3Ks2NXSFsVVMGaiaZp9V0vXMdhibMiaI3Sicp57KjZdKic0zVOMgVGwhVnw/0?wx_fmt=png&quot; data-nickname=&quot;木鸟杂记&quot; data-alias=&quot;distributed-system&quot; data-signature=&quot;分布式系统、分布式存储、摄影分享、读书笔记&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编程思维：CS 61A&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难度级别：★★★&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本门课程以巫书（Wizard Book） SICP 为教材。涵盖了编程思维中非常重要的方面：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;抽象之——函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;抽象之——数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解构程序执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据处理范式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其有本关联的小书讲的尤其不错：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Composing Programs&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。另外，他用了 Python 这样一门很 handy 的语言作为授课和实验的辅助语言，于是，你还可以顺手学个这么火的 Python。这门课类似于各种编程世界中武功心法总纲，想必能苦苦思索计算机“为什么”的你十分受用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;操作系统：MIT 6.828&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难度级别：★★★&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用一个简单的 xv6 教学操作系统，通过实验实现一些操作系统中的关键算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Operating System Engineering&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据库开发：cmu15445&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难度级别：★★★★&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲义和资料都很翔实。四个实验，构成一个简单的数据库 DBMS。可以看之前 Andy 授课的版本，他讲课比较有激情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CMU 15-445/645 : Database Systems (Fall 2020)&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分布式系统：MIT 6.824&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难度级别：★★★★&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式系统作为当今工业界系统的基石，值得一门公开课。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该课程梳理了近年来工业界分布式系统各种广为应用系统后的论文，设置了分布式系统基石——分布式共识协议的实验，绝对值得一学。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.824 Distributed Systems: Spring 2020&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Composing Programs: &lt;em&gt;http://composingprograms.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Operating System Engineering: &lt;em&gt;https://pdos.csail.mit.edu/6.828/2018/schedule.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;CMU 15-445/645 : Database Systems (Fall 2020): &lt;em&gt;https://15445.courses.cs.cmu.edu/fall2020/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Distributed Systems: &lt;em&gt;http://nil.csail.mit.edu/6.824/2020&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;题图故事&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jHMBqsHehTNdtFIj5fDOd520Y5DvNbZLMFE2rQFnXicbJVmia0YOUNJ7r10nOwHHaicDFzz3MicsffmeEDxYaS3V8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;公司杭州办公室的窗外，最喜欢的大落地窗&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我是青藤木鸟，一个喜欢摄影的分布系统程序员，欢关注我的公众号：&lt;strong&gt;木鸟杂记&lt;/strong&gt;。如果觉得我的文章还不错，就点个在看支持一下吧，感谢。&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                  &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                    &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;/&gt;
                  &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                  &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                &lt;/div&gt;
                                              
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>efe7249ef39a4d59d8961c303dfb05f9</guid>
<title>一块GPU训练TB级推荐模型不是梦，OneEmbedding性能一骑绝尘</title>
<link>https://toutiao.io/k/7okrabr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lBhAE42wKWqicVc5BKxiaibMWLBLUesxaEvv3qOicCZNAZ8TFORK4U2vVrbjbicJ6sZotkam0xxCtPyvrUUxlXmwDYA/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;来源 | 机器之心&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;个性化推荐已成为人们获取信息的主要形式。以往，人们更多通过主动搜寻自己感兴趣的信息，而现在，基于算法推荐技术的信息分发平台会自动识别用户兴趣，快速筛选信息，推送用户所感兴趣的信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一方面，推荐系统大幅提升了用户体验，另一方面，个性化分发信息更精准、高效，可以帮助平台更准确地匹配用户和信息，大大提高流量变现效率，基于推荐技术的流量变现引擎甚至成就了万亿市值的庞大商业帝国。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从短视频信息流推荐、广告搜索到线上购物，这些应用都构筑于精准的推荐系统之上，背后的核心功臣就是深度学习模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，随着海量数据的积累以及更加频繁的用户数据迭代，底层系统可扩展性和训练速度面临严峻的挑战。人们发现，通用深度学习框架都不能直接满足工业级推荐系统的需求，而是必须基于通用深度学习框架做深度定制，甚至于要开发专门的系统才行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对现代推荐系统的种种痛点，&lt;strong&gt;OneFlow 团队推出了一款高性能、可扩展、灵活度高的推荐系统组件 OneEmbedding。它的使用方式和通用深度学习框架一样简单，性能却远超通用框架，甚至超过了 NVIDIA HugeCTR 这样为推荐场景定制开发的系统。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体而言，在 DCN、DeepFM 两个模型上，无论是 FP32 还是混合精度（automatic mixed-precision, AMP）训练，OneEmbedding 的性能大幅超过 HugeCTR，而在 HugeCTR 深度优化以至于有点 “过拟合” 的 DLRM 模型上，OneEmbedding 性能与 HugeCTR 基本持平。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fBMrT9IdibDmlicazoleyNRtggWHGza2icicZiafCD6BxvMhrT39YHbaTAfw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6flFDc6iawZHDGFibSRehQ0nLzp11c4nQTTHicRSl0zicUoicDnIIplp6nqEw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;em&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fGcTTMfHYbg5bMfbdicqxPY0ygXauRKmJA2ibQ9gGXT1quIc4clXc51jQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;（以上测试环境均为：CPU Intel(R) Xeon(R) Platinum 8336C CPU @ 2.30GHz * 2；CPU Memory 1920GB；GPU NVIDIA A100-SXM-80GB * 8；SSD Intel SSD D7P5510 Series 3.84TB * 4）&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当用户使用 OneFlow 搭建推荐模型时，只需使用以下数行代码对 Embedding 词表进行配置即可训练含有 TB 级别词表的推荐模型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot; mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;26&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;self.embedding&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;flow.one_embedding.MultiTableEmbedding(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;sparse_embedding&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     &lt;span class=&quot;code-snippet__attr&quot;&gt;embedding_dim&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;embedding_vec_size,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     &lt;span class=&quot;code-snippet__attr&quot;&gt;dtype&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;flow.float,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     &lt;span class=&quot;code-snippet__attr&quot;&gt;key_type&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;flow.int64,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     &lt;span class=&quot;code-snippet__attr&quot;&gt;tables&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;tables,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     &lt;span class=&quot;code-snippet__attr&quot;&gt;store_options&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;store_options,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 &lt;span class=&quot;code-snippet__attr&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于 OneEmbedding 搭建的常见搜索推荐广告模型案例地址：&lt;strong&gt;&lt;em&gt;https://github.com/Oneflow-Inc/models/tree/main/RecommenderSystems&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;大规模推荐系统的挑战&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般而言，推荐系统需要使用类似性别、年龄、行为等方面的离散特征（sparse feature），在一个 Embedding 词表中用特征 ID 进行查表（lookup），取得对应的 Embedding 向量并送到下游使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用的公开数据集 Criteo1T 中大概包含十亿个特征 ID，如果 embedding_dims 配置为 128，那总共需要 512 GB 空间来容纳 Embedding 参数，如果使用 Adam 优化器，由于需要保存额外的两个状态变量 m 和 v，所需存储容量就增加到 1536 GB。实际应用场景中，数据规模比 Criteo 还要高出几个数量级，模型的容量就更大了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;大规模推荐系统的核心问题就是，如何高效经济地支持大规模 Embedding 的查询和更新。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;权衡规模、成本和效率，出现了如下三种常见的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;335&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.5953125&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KmXPKA19gWicxHBce7eeII03bCd1u9o6fr0FOYzKBnAJK4khQLG6iafemGpd8goVPcLkuhDDcBuk33tqPuWWspkA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最常见也是最早出现的一种解决方案是将 Embedding 全部部署在 CPU 上，利用 CPU 内存容量大、成本低的特点扩展参数规模，优点是模型规模几乎可以无限大。不过，其缺点也很明显，无论是计算性能还是带宽，CPU 都远低于 GPU，导致 Embedding 部分成为显著瓶颈，往往需要数十乃至上百台 CPU 服务器才能支撑一个工业级的推荐系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;鉴于 GPU 在稠密计算中得天独厚的优势，也有人建议用 GPU 来训练大型 Embedding 模型。问题是，GPU 很贵且显存容量有限，如果使用显存容量为 40GB 的 A100 来基于 Criteo 数据训练 128 维嵌入向量，至少需要 13 张显卡才能放下 512GB 的 Embedding 词表。每张卡只有 40GB 显存容量，分布式 Embedding 需要使用所谓的模型并行技术，理想情况下，为了解决更大规模的模型只需要增加 GPU 的数量即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现实是，GPU 相对于 CPU 的成本非常高昂，并且推荐系统中模型主体计算部分不大，模型并行在扩展过程中只是解决了 Embedding 规模的问题，训练速度的收益比较有限，甚至会因为多设备之间引入通信导致训练速度下降，因此通常只适用于小规模集群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了缓解 GPU 之间传输带宽的问题，业界发展出比以太网带宽更高的 NVSwitch、Infiniband 网络等互联技术。一方面，这意味着额外的成本，另一方面，很多用户的基础设施不具备相应改造、升级的条件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，有没有鱼和熊掌兼得的方案？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上述方案存在的问题，OneFlow 团队设计了 OneEmbedding，&lt;strong&gt;通过分层存储让单卡也能支持 TB 级模型的训练，通过横向扩展让模型容量没有天花板，通过 OneFlow 的自动流水线机制、算子优化和通信量化压缩等技术实现极致性能，在用法像 PyTorch 一样简单的前提下， OneEmbedding 在 DLRM 模型上性能是 TorchRec 的 3 倍以上，开启 TorchRec 没有支持的混合精度后，OneEmbedding 的性能更是 TorchRec 的 7 倍以上。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（TorchRec 性能数据参考 8 卡 A100 测试结果：&lt;em&gt;https://github.com/facebookresearch/dlrm/tree/main/torchrec_dlrm/#preliminary-training-results &lt;/em&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;OneEmbedding 的核心优势&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层存储：单卡也能支持 TB 级模型训练&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;308&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.5487528344671202&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6f0PczIiaS7YxqIOkbrGpWfwueqibrTibibT3yT8vicfO2AtpubjVC9G6FIXQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用数据的空间局部性和时间局部性，多级缓存可以很好地实现性能和成本的折衷。OneEmbedding 也基于这个思想实现了多级缓存，即使用户只有一张 GPU 也可以训练 TB 级别的模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户既可以把 Embedding 部署到 GPU 显存上，也可以把 Embedding 部署到 CPU 内存甚至是 SSD 上。这种方案可以发挥 CPU 内存或者 SSD 更低的成本优势，以对 Embedding 参数规模进行扩展，还可以利用 GPU 显存作为高速缓存设备，以实现高性能效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OneEmbedding 会动态地将最近频繁访问的条目缓存到 GPU 显存上，同时将最近访问频率较低的条目逐出到 CPU 内存或者 SSD 等底层存储中。在数据遵循幂律分布这一前提下，基于有效的 Cache 管理算法，OneEmbedding 可以使 GPU 缓存的命中率始终维持在较高的水平。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;261&quot; data-backw=&quot;481&quot; data-ratio=&quot;0.5426195426195426&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6f5Ls2uwTSRBldPfD5a6icC7iarcGG09Gtqz8XBBPCzP20dvjO09tmG4zQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;值得强调的是，OneEmbedding 只是将 CPU 内存和 SSD 作为存储设备，所有计算都在 GPU 上执行。目前，OneEmbedding 提供三种预置存储方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;store_options&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;flow.one_embedding.make_cached_ssd_store_options(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__attr&quot;&gt;cache_budget_mb&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;cache_memory_budget_mb,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__attr&quot;&gt;persistent_path&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;persistent_path,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__attr&quot;&gt;capacity&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;vocab_size,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__attr&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户可以根据实际使用时的硬件设备情况，只需用短短数行代码进行配置，即可一箭三雕实现规模、效率、成本的最优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了掩盖 CPU 和 SSD 取数据的延迟，OneEmbedding 引入流水线、数据预取等技术手段，使得在以 CPU 内存 和 SSD 作为存储后端的同时，效率依然可以和使用纯 GPU 训练那样保持在同样的水平。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分别对三种存储方案进行测试。其中，测试用例与 MLPerf 的 DLRM 模型一致，参数规模约为 90GB。在使用 SSD 和 CPU 内存作为存储设备时，我们配置的 GPU 缓存大小为每个 GPU 12GB，相比于 90 GB 的总参数量，只能有一部分参数保持在 GPU 显存内，其他的参数则是保存在 CPU 内存或者 SSD 上，随着训练过程动态的换入到 GPU 缓存中来，测试结果如下图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;350&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.6221910112359551&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;712&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fz751fQxmr2jPQfibSsQICQbNVADUB4jsZzymcBwrAicjpLnLn0vkHTfw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;（测试环境：CPU Intel(R) Xeon(R) Silver 4214R CPU @ 2.40GHz * 2；CPU Memory 512GB；GPU NVIDIA A100-PCIE-40GB * 4；SSD Intel SSD D7P5510 Series 7.68TB * 4）&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;从测试结果中可以看到：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）纯 GPU 显存方案性能最佳，但由于 GPU 显存只有 4x40GB，理论上最大只能够训练 160 GB 模型；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）相比纯 GPU 显存方案，GPU 缓存 + CPU 存储的方案性能只有微小损失，但可以把参数规模的天花板扩展到 CPU 内存容量，往往是数百 GB～数 TB；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）更进一步，如果能接受更大的性能损失，GPU 缓存 + SSD 存储的方案能将参数规模的天花板扩展到 SSD 的容量，模型规模可达数十 TB，甚至更大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果我们想在只有一个 NVIDIA A30-24GB GPU 的服务器上进行上述 DLRM 模型的完整训练，24G 的显存显然无法直接训练 90GB 规模的模型。借助分层存储，使用 CPU 内存作为存储设备，GPU 显存作为高速缓存，就可以支持比 90GB 还大的模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;横向扩展：多卡线性加速，打破模型天花板&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用分层存储技术，OneEmbedding 提升了单卡情况下的 Embedding 参数规模极限，只要内存空间够大甚至能够训练 TB 级别大小的模型。如果模型的容量进一步扩大到甚至大大超过 CPU 内存的容量，用户还可以在多级存储的基础上借助 OneFlow 的并行能力轻松地横向拓展到多机多卡，以训练更大的模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在推荐系统中，模型主体参数相较 Embedding 则小的多。因此我们一般将 Embedding 部分设置为模型并行，模型主体设置为数据并行。通过使用多机多卡，可进一步提升 Embedding 大小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;341&quot; data-backw=&quot;422&quot; data-ratio=&quot;0.8080568720379147&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fYlvfCwodwhpFbzgqF8a0ROKRqxtb7iaefYXs6iaFltSbA5fYc3rWZia1g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体到实现细节，每个 Rank 各自负责一部分 Embedding 的存储，特征 ID 进入到各个 Rank，可能存在重复 ID 的情况，首先要进行去重（即下图的 ID Shuffle）；各个 Rank 拿着去重后的 ID 去查询 Embedding，得到对应的局部数据，所有 Rank 数据合并后各 Rank 得到完整的 Embedding 数据（即下图的 Embedding Shuffle）；最后，各 Rank 以数据并行的方式完成整个模型训练过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;454&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.8086538461538462&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fwuNa6DbCVUI6PufDnC2xNLGlQVZ7Lcgt5t2W61wXW9fWicpOjZJuCaw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图展示了 OneEmbedding 采取纯 GPU 显存的策略训练 DLRM 模型时，FP32 和 AMP 配置下，不同 GPU 个数下模型吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;356&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.6337209302325582&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fkeSFLbERYdQAESk08xDA8cZBj8AKBSvbKuS0yq6qDj8MDIF3EG5rHw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;（测试环境：CPU Intel(R) Xeon(R) Platinum 8336C CPU @ 2.30GHz * 2；CPU Memory 1920GB；GPU NVIDIA A100-SXM-80GB * 8；SSD Intel SSD D7P5510 Series 3.84TB * 4）&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，随着 GPU 设备数的增加，模型吞吐量均能显著增加，在混合精度情况下，单张 GPU 能有 600 万的吞吐量，当扩展到 8 张 GPU 时能有近 4000 万的吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;流水线机制：自动重叠计算和数据传输&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 DLRM 模型中，Embedding 中的 Dense Feature 会进入到 Bottom MLP 中，而 Sparse Feature 经过 Embedding 查询得到对应特征。两者进入 Interaction 进行特征交叉，最后进入到 Top MLP。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;497&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.8849104859335039&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fCwG6U9qDV7ODBszchy6iaicwJwuibO1htyvsLlKiclXrbHWxzdwSQibRPwA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Embedding 相关操作包含查表（Embedding Lookup）、更新（Embedding Update）。由于 OneEmbedding 使用的是分层存储的机制，可能会遇到特征 ID 没有命中高速缓存的情况，此时，数据拉取耗时较长，会影响训练速度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为避免这个不足，OneEmbedding 加入数据预取（Embedding Prefetch）操作，以保证查表和更新操作均能在 GPU 上执行。由于前后迭代之间的数据预取不存在依赖关系，在当前迭代计算的同时，可以预取下一个迭代需要的 Embedding 数据，实现计算和预取的重叠。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Embedding 数据查询交换的过程中，与 Embedding 操作无关的 Dense Feature 可以进入到 Bottom MLP 进行计算，在时间上进行重叠。完整的重叠执行时序如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;169&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.3&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fD1O1fTcgHSanuaDdHYO1Iia8gPg6PsuCdMRNuaL0GQQdUwRhMXIMKag/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如此复杂的数据流水线控制在传统深度学习框架里是一个很挑战的问题。不仅如此，在实际推荐场景中，用户的数据在不断变化，这要求流水线机制还要能应对动态数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而 OneFlow 的 Actor 机制让这一切问题变得很简单，每个 Actor 都通过自己内部的状态机和消息机制实现了分布式协同工作。通过为每个 Actor 赋予多份存储块，不同的 Actor 可以同时工作，重叠各自的工作时间，从而实现 Actor 之间的流水线。我们只需要将 Embedding 操作分配到单独的一个 stream 上，即可让系统自发地形成流水线。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;算子优化：逼近 GPU 极限性能&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OneFlow 团队不仅对通用算子进行了深度优化，还针对流行的推荐系统模型特点，增加了多个高性能 CUDA 算子实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于 DLRM、DCN 模型中的特征交叉部分，OneFlow 分别实现了 FusedDotFeatureInteraction 和 FusedCrossFeatureInteraction 算子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;274&quot; data-backw=&quot;507&quot; data-ratio=&quot;0.5404339250493096&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fIoJCkgPriaWasvB0icjYW1xB8PxyTUO5UWbAzk31Ob7LlwRQxDCT9pBQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;(FusedCrossFeatureInteraction 算子，图片出自 《Deep &amp;amp; Cross Network for Ad Click Predictions》)&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于模型中多个全连接层部分，OneFlow 基于 cublasLt 矩阵运算库实现了 FusedMLP 算子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;403&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.7171875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fswrWy53B4MwJG8L5TtlmlGInP0bn9xCPj0zBHSEAZUFOglr9Fopoqw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而对于带 Dropout 操作的全连接层，OneFlow 深度定制了其中的 ReluDropout 操作，使用 bitmask 形式存储前向产生的 mask，在反向传播中，通过设置 cublasLt 矩阵乘的参数 alpha=dropout_scale 以实现反向算子融合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;439&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.78125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6f5cdwnTAPOCIwFpTGCQZf8JBVN8oAg3XY7jiaOY2OxwuekwvcichdYSkA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;量化压缩：压榨通信效率&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在模型训练的通信过程中，近期也有不少工作对数据进行量化压缩以节省通信量，提高通信效率，OneEmbedding 也支持这个特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并行训练中，各个 Rank 之间需要通信以交换 Embedding 数据，我们先将浮点类型数据量化成 int8 类型，交换完后再反量化恢复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;246&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.4371754932502596&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fQEjjg8rsBvUuhXBVnmdUCYUUZHSLHa4zQIz2WnS5QhzicsWNW1XXUvw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图以 DLRM 模型为例展示了选择纯 GPU 显存存储配置，分别测试在 FP32 和混合精度条件下量化前后模型吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;440&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.7832699619771863&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fOBKhwOSzEPbMdIM5Gia6UEeNrZzrNHFjfFic56hCANauKicD6WFYnyicDw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;量化前后模型精度对比（AUC）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;193&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.3438538205980066&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxHBce7eeII03bCd1u9o6fBabLicfOhrjOAxLxnNSPRJFPcCmcvzNHssysK5lYVoK8aZ7RDJ8iacmA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;（测试环境：CPU Intel(R) Xeon(R) Silver 4214R CPU @ 2.40GHz * 2；CPU Memory 512GB；GPU NVIDIA A100-PCIE-40GB * 4；SSD Intel SSD D7P5510 Series 7.68TB * 4）&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;测试结果表明，在不影响模型精度的前提下， 量化通信在 FP32 的情况下相比默认通信模式有 64% 的提升， 在混合精度的情况下有 13% 的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;易用性：构建大规模推荐模型就像使用 PyTorch 一样简单&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OneEmbedding 作为 OneFlow 的一个内部扩展组件，意味着用户可以在使用 OneEmbedding 的高级特性同时，还能享受 OneFlow 通用框架的灵活性构建自己的推荐模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;DLRMModule&lt;/span&gt;(&lt;span class=&quot;code-snippet__title&quot;&gt;nn&lt;/span&gt;.&lt;span class=&quot;code-snippet__title&quot;&gt;Module&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;, args)&lt;/span&gt;&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;(DLRMModule, &lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;).__init_&lt;span class=&quot;code-snippet__number&quot;&gt;_&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;.bottom_mlp = FusedMLP(...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;.embedding = OneEmbedding(...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;.interaction = FusedDotInteraction(...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;.top_mlp = FusedMLP(...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;, sparse_feature, dense_feature)&lt;/span&gt;&lt;/span&gt;: &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        dense_fields = &lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;.bottom_mlp(dense_feature)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        embedding = &lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;.embedding(sparse_feature)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        features = &lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;.interaction(dense_fields, embedding)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;.top_mlp(features)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，值得一提的是，OneEmbedding 通过内置的编码机制对特征 ID 进行编码，支持动态插入新增数据。用户不需要提前规划 Embedding 容量，也无需对数据集中的特征 ID 进行特殊处理。这种动态机制天然地支持增量训练的场景，同时也减少使用负担。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前 OneFlow 的 models 仓库下提供了基于 OneEmbedding 搭建的一系列模型，如 DLRM, DeepFM, xDeepFM, DCN, PNN, MMoE，后续也会补充更多的推荐模型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://github.com/Oneflow-Inc/models/tree/main/RecommenderSystems&lt;/em&gt;&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OneEmbedding 是应训练大规模推荐系统模型需求而生的组件，灵活的分层存储、高度优化的数据流水线以及易于横向扩展的特性，能让用户轻松训练 TB 级别的推荐模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，OneFlow 框架提供了一些模型示例供你一键体验 OneEmbedding。后续，OneFlow 团队将推出覆盖业界主流模型的推荐系统模型库 Flow-Recommender ，它不仅支持分布式训练，还支持分布式推理。欢迎感兴趣的朋友关注。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OneEmbedding 地址：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://github.com/Oneflow-Inc/models/tree/main/RecommenderSystems&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OneEmbedding 文档&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://docs.oneflow.org/master/cookies/one_embedding.html&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OneEmbedding API 文档：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://oneflow.readthedocs.io/en/master/one_embedding.html&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;其他人都在看&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;strong&gt;&lt;span&gt;阅读原文&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，欢迎体验OneFlow v0.8.0&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;h2&gt;&lt;hr/&gt;&lt;/h2&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU5ODY2MTk3Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/lBhAE42wKWomZrXDbZnegyP5qVxvr0Bg52ibDia1lqPAPvhiboIbuDsvznywQcExLn2dq6mfaE2hVBQ8cgZh8meMA/0?wx_fmt=png&quot; data-nickname=&quot;OneFlow&quot; data-alias=&quot;OneFlowTechnology&quot; data-signature=&quot;不止于成为世界上最快的开源深度学习框架&quot; data-from=&quot;2&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;342&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5920529801324503&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lBhAE42wKWqMs1w4gByiaaU9WpaHh8lXhZYibicCXtxbLpohuxOJUvvVYuaBq3VGOBrOn7soGUPPnzCTCdibPvkAQA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>46f6b885c8b19ad9f410e315e67ff38c</guid>
<title>花三个小时，完全掌握分片渲染和虚拟列表</title>
<link>https://toutiao.io/k/0xhdw8v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小杜杜，有关&lt;strong&gt;高性能，大数据量&lt;/strong&gt;的列表渲染的示例已经非常常见，可以说是前端必须要了解的功能点，今天我们一起手写一下，看看如何去更好的实现～&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道有些场景下，接口会返回出大量的数据，渲染这种列表叫做&lt;code&gt;长列表&lt;/code&gt;,今天主要说下处理&lt;code&gt;长列表&lt;/code&gt;的两种方式：&lt;code&gt;分片渲染&lt;/code&gt;和&lt;code&gt;虚拟列表&lt;/code&gt;，请各位小伙伴多多支持～&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在正式开始前，希望各位小伙伴牢牢记住：&lt;strong&gt;js执行永远要比dom快的多&lt;/strong&gt;，所以对于执行大量的数据，一次性渲染，非常容易造成卡顿、卡死的情况&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;疑问点&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看看以下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; React,{ useState } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { Button } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;antd-mobile&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; img &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./img.jpeg&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 子组件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Item:React.FC&amp;lt;{id: &lt;span&gt;number&lt;/span&gt;, waitRender?: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;}&amp;gt;  = &lt;span&gt;(&lt;span&gt;{id, waitRender}&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;div style={{display: &#x27;flex&#x27;, alignItems: &#x27;center&#x27;, marginBottom: 5}}&amp;gt;&lt;br/&gt;      &amp;lt;img src={img} width={&lt;span&gt;80&lt;/span&gt;} height={&lt;span&gt;60&lt;/span&gt;} alt=&lt;span&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;列表{id}&lt;br/&gt;    &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const Index:React.FC&amp;lt;any&amp;gt; = (props)=&amp;gt; {&lt;br/&gt;&lt;br/&gt;  const [flag, setFalag] = useState&amp;lt;boolean&amp;gt;(false)&lt;br/&gt;  const [list, setList] = useState&amp;lt;Array&amp;lt;number&amp;gt;&amp;gt;([])&lt;br/&gt;  &lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div&amp;gt;&lt;br/&gt;    &amp;lt;Button onClick={async () =&amp;gt; {&lt;br/&gt;      setFalag(true)&lt;br/&gt;      let arr:number[] = []&lt;br/&gt;      console.time()&lt;br/&gt;      for(let i = 0; i &amp;lt; 5000; i++){&lt;br/&gt;        arr.push(i)&lt;br/&gt;      }&lt;br/&gt;      await setList(arr)&lt;br/&gt;      console.timeEnd()&lt;br/&gt;    }} &amp;gt;渲染&amp;lt;/&lt;/span&gt;Button&amp;gt;&lt;br/&gt;    {&lt;br/&gt;      flag &amp;amp;&amp;amp; list.map(&lt;span&gt;(&lt;span&gt;item&lt;/span&gt;) =&amp;gt;&lt;/span&gt;  &amp;lt;Item id={item} key={item} /&amp;gt;)&lt;br/&gt;    }&lt;br/&gt;  &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;export default Index;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;code&gt;Item&lt;/code&gt;是我们的子组件，也就是一行一行的数据，为了大家更好的看到事件，我特意做了个按钮来控制列表的长度，这里我们假设有五万条数据，通过&lt;code&gt;console.time()&lt;/code&gt;和 &lt;code&gt;console.timeEnd()&lt;/code&gt;计算一下加载这五万条数据需要多长时间？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.683046683046683&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmW7rekkzqWSsP8zbfwrOs2cRCwt77NVhC4L5EhbFe8EdLAM2OkVicgcfh1HcGyIsqnKY4uficezRaw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;814&quot;/&gt;&lt;figcaption&gt;img1.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到加载的时间大概为&lt;code&gt;2.7s&lt;/code&gt;，这样的速度明显达不到要求，而且在真实情况下很容易出现白屏，卡顿的情况，这明显不是我们想要的情况～&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分片渲染&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分片渲染&lt;/strong&gt;：简单的说就是一个执行完再执行下一个，其思想是&lt;strong&gt;建立一个队列，通过定时器来进行渲染&lt;/strong&gt;，比如说一共有3次，先把这三个放入到数组中，当第一个执行完成后，并剔除执行完成的，在执行第二个，直到全部执行完毕，渲染队列清空。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;利用定时器&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过设置定时器来进行渲染，通过设置一个&lt;code&gt;等待队列（waitList）&lt;/code&gt;和&lt;code&gt;是否渲染（isRender）&lt;/code&gt;的条件去做。(在这里我把定时器的时间设置为500，方便演示)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HOC&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { useEffect, useState } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { DotLoading } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;antd-mobile&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; waitList:&lt;span&gt;any&lt;/span&gt; = [] &lt;span&gt;//等待队列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; isRender:&lt;span&gt;boolean&lt;/span&gt; = &lt;span&gt;false&lt;/span&gt; &lt;span&gt;//控制渲染条件&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; waitRender = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; res = waitList.shift()&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(!res) &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    res()&lt;br/&gt;  }, &lt;span&gt;500&lt;/span&gt;) &lt;span&gt;//为演示效果加入一个延长时间&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; HOC = &lt;span&gt;(&lt;span&gt;Component:&lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (props:&lt;span&gt;any&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [show, setShow] = useState&amp;lt;&lt;span&gt;boolean&lt;/span&gt;&amp;gt;(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    waitList.push(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {setShow(&lt;span&gt;true&lt;/span&gt;)})&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!isRender){&lt;br/&gt;      waitRender()&lt;br/&gt;      isRender = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; show ? &amp;lt;Component waitRender={waitRender} {...props}/&amp;gt; : &amp;lt;div style={{margin: 25}}&amp;gt;&amp;lt;DotLoading color=&lt;span&gt;&#x27;primary&#x27;&lt;/span&gt; /&amp;gt;加载中&amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;export default HOC;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; React,{ useEffect, useState } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; img &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./img.jpeg&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { SlicingHoc } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/components&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 子组件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Item:React.FC&amp;lt;{id: &lt;span&gt;number&lt;/span&gt;, waitRender: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;}&amp;gt;  = &lt;span&gt;(&lt;span&gt;{id, waitRender}&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    waitRender()&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;div style={{display: &#x27;flex&#x27;, alignItems: &#x27;center&#x27;, padding: 5}}&amp;gt;&lt;br/&gt;      &amp;lt;img src={img} width={&lt;span&gt;80&lt;/span&gt;} height={&lt;span&gt;60&lt;/span&gt;} alt=&lt;span&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;列表{id}&lt;br/&gt;    &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const ItemHoc = SlicingHoc(Item)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;const Index:React.FC&amp;lt;any&amp;gt; = (props)=&amp;gt; {&lt;br/&gt;&lt;br/&gt;  const [list, setList] = useState&amp;lt;Array&amp;lt;number&amp;gt;&amp;gt;([])&lt;br/&gt;&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    let arr:number[] = []&lt;br/&gt;    for(let i = 0; i &amp;lt; 5000; i++){&lt;br/&gt;      arr.push(i)&lt;br/&gt;    }&lt;br/&gt;    setList(arr)&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div&amp;gt;&lt;br/&gt;      {&lt;br/&gt;        list.map((item) =&amp;gt;  &amp;lt;ItemHoc id={item} key={item} /&lt;/span&gt;&amp;gt;)&lt;br/&gt;      }&lt;br/&gt;  &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;export default Index;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.331764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmW7rekkzqWSsP8zbfwrOs2hv4LW0GmaKkwOQia35KIeVC4eAXwErI0xqvDK73XclicHHUyWyUJe8icA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;425&quot;/&gt;&lt;figcaption&gt;img2.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就能实现这样的效果，这个主要有以下两个缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在这个组件中，我们需要通过&lt;code&gt;HOC&lt;/code&gt;传递一个&lt;code&gt;waitRender()&lt;/code&gt;方法来记录整个队列，也就是说我们要用这个高阶组件，还必须要改变字组件的结构，这点并不是特别好&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们发现这种情况是进行一个一个渲染，上面的没有执行完，下面的是不会渲染的，也就会造成如下效果（定时器设置为0也一样）如：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.331764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmW7rekkzqWSsP8zbfwrOs20Ov2Tk7PHicGIhRpuzsRZtwHZnXvicm4GuNKY6QKTlNTELvzIvX9Kmsg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;425&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进行改造&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.针对上述的第一点，我们可以把里面的数组包装成一个整体，通过&lt;code&gt;HOC&lt;/code&gt;去循环 2.针对第二点，我们没有必要一个一个进行渲染，可以一次渲染100个，这样渲染的速度就会加快&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HOC：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import { useEffect, useState } from &#x27;react&#x27;;&lt;br/&gt;&lt;br/&gt;let waitList:any = [] //等待队列&lt;br/&gt;&lt;br/&gt;const HOC = (Component:any) =&amp;gt; ({list, ...props}:any) =&amp;gt; {&lt;br/&gt;&lt;br/&gt;  const [data, setData] = useState&amp;lt;any&amp;gt;([])&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    if(list.length !== 0){&lt;br/&gt;      sliceTime(list, 0)&lt;br/&gt;    }&lt;br/&gt;  }, [list])&lt;br/&gt;&lt;br/&gt;  const sliceTime = (list:any[], times = 0, number:number = 100) =&amp;gt; {&lt;br/&gt;    if(times === (Math.ceil(list.length / number) + 1)) return //判断条件&lt;br/&gt;    setTimeout(() =&amp;gt; {&lt;br/&gt;      const newList:any = list.slice(times * number, (times + 1) * number)&lt;br/&gt;      waitList = [...waitList, ...newList]&lt;br/&gt;      setData(waitList)&lt;br/&gt;      sliceTime(list, times + 1)&lt;br/&gt;    }, 500);&lt;br/&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  if(list.length === 0) return &amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;br/&gt;&lt;br/&gt;  return &amp;lt;&amp;gt;{&lt;br/&gt;    data.map((item:any) =&amp;gt;  &amp;lt;Component id={item} {...props} key={item} /&amp;gt;)&lt;br/&gt;  }&amp;lt;/&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;export default HOC;&lt;br/&gt;复制代码&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码展示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; React,{ useEffect, useState } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; img &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./img.jpeg&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { SlicingHoc } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/components&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 子组件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Item:React.FC&amp;lt;{id: &lt;span&gt;any&lt;/span&gt;}&amp;gt;  = &lt;span&gt;(&lt;span&gt;{id}&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;div style={{display: &#x27;flex&#x27;, alignItems: &#x27;center&#x27;, padding: 5}}&amp;gt;&lt;br/&gt;      &amp;lt;img src={img} width={&lt;span&gt;80&lt;/span&gt;} height={&lt;span&gt;60&lt;/span&gt;} alt=&lt;span&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;列表{id}&lt;br/&gt;    &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const ItemHoc = SlicingHoc(Item)&lt;br/&gt;&lt;br/&gt;const Index:React.FC&amp;lt;any&amp;gt; = (props)=&amp;gt; {&lt;br/&gt;&lt;br/&gt;  const [list, setList] = useState&amp;lt;Array&amp;lt;number&amp;gt;&amp;gt;([])&lt;br/&gt;&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    let arr:number[] = [] &lt;br/&gt;    for(let i = 0; i &amp;lt; 50000; i++){&lt;br/&gt;      arr.push(i)&lt;br/&gt;    }&lt;br/&gt;    setList(arr)&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div&amp;gt;&lt;br/&gt;      &amp;lt;ItemHoc list={list} /&lt;/span&gt;&amp;gt;&lt;br/&gt;   &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;export default Index;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.331764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmW7rekkzqWSsP8zbfwrOs2oNsic7YOyQXg1hTB2CZro6sU8EGiaIQFBXRMlH15acwibLzHRnr1FZLuQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;425&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，你就会发现渲染的速度会快很多，也没有太大的卡顿，效果而言还算不错～&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当然，你可以根据实际情况去设置一次渲染的次数，把&lt;code&gt;HOC&lt;/code&gt;定制为公共化，具体的操作可以参考一下这篇文章：&lt;span&gt;作为一名React，我是这样理解HOC的-定制为公用HOC&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虚拟列表&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们发现&lt;strong&gt;分片渲染&lt;/strong&gt;有一个根本问题，就是&lt;strong&gt;依次渲染&lt;/strong&gt;，将庞大的数据切分开，然后按顺序依次渲染&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但大多数人进入到列表页面，根本不会将整个列表全部看完，从某种角度上来说，像这种全部渲染的情况比较鸡肋，所以在大多数情况下，会采取&lt;strong&gt;虚拟列表&lt;/strong&gt;的形式&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;虚拟列表&lt;/strong&gt;：实际上是一种实现方案，只对&lt;code&gt;可视区域&lt;/code&gt;进行渲染，对&lt;code&gt;非可视区域&lt;/code&gt;中的区域不渲染或只渲染一部分（渲染的部分叫&lt;code&gt;缓冲区&lt;/code&gt;，不渲染的部分叫&lt;code&gt;虚拟区&lt;/code&gt;），从而达到极高的性能&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简单分析&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看一下下方的图（由于我的图画的实在难看，所以在网上找了一张比较符合的，还望勿喷～）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2716763005780347&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmW7rekkzqWSsP8zbfwrOs2gKtRz4e9G7rIOx5MUTPsVvD3jwcZn8xl2AIK0GFXiaGCrwpibno4IVyg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1038&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看出，我们可以将列表分为三个区域：&lt;strong&gt;可视区&lt;/strong&gt;、&lt;strong&gt;缓冲区&lt;/strong&gt;、&lt;strong&gt;虚拟区&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们主要针对&lt;code&gt;可视区&lt;/code&gt;和&lt;code&gt;缓冲取&lt;/code&gt;进行渲染，我们一步一步的实现，有不对的地方，希望在评论区指出～&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;页面布局&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个组件中，首先要做的事情就是布局，我们需要有两块区域：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;占位区域&lt;/code&gt;：聪明的小伙伴发现，在上述的&lt;code&gt;分片渲染&lt;/code&gt;中，滚动条也在变化，这是因为列表渲染的数据在增加，把内容组件撑开，造成高度上的变化，所以在虚拟列表中，专门提供一个div，用来占位，这样在一进来的时候滚动条就不会产生变化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;渲染区域&lt;/code&gt;：这块部分为真正用户看到的列表区域，实际上有&lt;strong&gt;可视区&lt;/strong&gt;和&lt;strong&gt;缓冲区&lt;/strong&gt;共同组成，&lt;strong&gt;缓冲区&lt;/strong&gt;的作用是&lt;code&gt;防止快速下滑或者上滑的过程中&lt;/code&gt;出现空白区域&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次我们需要一个整体的&lt;code&gt;div&lt;/code&gt;，通过监听&lt;code&gt;占位区域&lt;/code&gt;的滚动条，判断当前截取数组的区域，所以大体的结构是这样&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;div ref={allRef}&amp;gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;{scrollRef}&lt;/span&gt; &lt;br/&gt;    &amp;gt;&lt;/span&gt;&lt;br/&gt;      {/* 占位，列表的总高度，用于生成滚动条 */}&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;br/&gt;        {/* 内容区域 */}&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        {/* 渲染区域 */}&lt;br/&gt;        {&lt;br/&gt;          state.data.map((item:any) =&amp;gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;=&lt;span&gt;{item}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;             {/* 子组件 */}&lt;br/&gt;             &lt;span&gt;&amp;lt;&lt;span&gt;Component&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{item}&lt;/span&gt; {&lt;span&gt;...props&lt;/span&gt;}/&amp;gt;&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参数计算&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以将需要的元素进行总结，在这里，我会使用&lt;code&gt;useReactive&lt;/code&gt;来存取参数，是一种具备&lt;code&gt;响应式&lt;/code&gt;的&lt;code&gt;useState&lt;/code&gt;，关于这个的实现，可参考：&lt;span&gt;搞懂这12个Hooks，保证让你玩转React-useReactive&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相关容器的高度&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;设置为 list&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;容器的高度: 当前组件所占的位置（可通过传值控制）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;scrollAllHeight = allRef.current.offsetHeight&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;子列表高度：子组件的高度（这个如何获取，后续讲到，案例中为65）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;ItemHeight = 65&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;占位区域高度，也就是整个列表的高度，用于生成滚动条：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;占位区域高度 = 子列表高度 * 列表总数个数&lt;/p&gt;&lt;p&gt;listHeight = ItemHeight * list.length&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;渲染区域的计算点&lt;/strong&gt;：其实我们渲染的数据只是&lt;strong&gt;可视区&lt;/strong&gt;和&lt;strong&gt;缓冲区&lt;/strong&gt;，我们可以利用&lt;code&gt;slice&lt;/code&gt;对&lt;code&gt;list&lt;/code&gt;进行截取，所以在我们还需要知道：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;索引的起始位置：start&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引的结束位置：end&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓冲个数：bufferCount&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要渲染的节点数量（可视区能渲染几个节点）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;渲染节点的数量 = 容器的高度 / 子列表高度 (需要向上取整) + 缓冲个数&lt;/p&gt;&lt;p&gt;const renderCount = Math.ceil(scrollAllHeight / ItemHeight)+ state.bufferCount&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;滚动区域&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里我使用&lt;code&gt;useEventListener&lt;/code&gt;去监听滚动事件，是一个可以监听任何函数的自定义hooks，具体实现可参考：&lt;span&gt;搞懂这12个Hooks，保证让你玩转React-useEventListener&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要拿到滚动条距离顶部的高度，然后计算对应的索引&lt;code&gt;起始&lt;/code&gt;和&lt;code&gt;结束&lt;/code&gt;位置，再截取对应的数据给到&lt;code&gt;data&lt;/code&gt;就OK了，并且计算对应的&lt;code&gt;偏移量&lt;/code&gt;,也就是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  useEventListener(&lt;span&gt;&#x27;scroll&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;// 顶部高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { scrollTop } = scrollRef.current&lt;br/&gt;    state.start =  &lt;span&gt;Math&lt;/span&gt;.floor(scrollTop / state.itemHeight)&lt;br/&gt;    state.end  =  &lt;span&gt;Math&lt;/span&gt;.floor(scrollTop / state.itemHeight + state.renderCount + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    state.currentOffset = scrollTop - (scrollTop % state.itemHeight)&lt;br/&gt;    state.data = list.slice(state.start, state.end)&lt;br/&gt;  }, scrollRef)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;优化&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上面的讲解，我们可以发现，高阶组件渲染的数据实际上只有&lt;code&gt;state.data&lt;/code&gt;，数据的变化是由滚动事件所引起的，造成&lt;code&gt;start&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;的改变，所以在这里，我们可以使用&lt;code&gt;useCreation&lt;/code&gt;来进行优化，&lt;code&gt;useCreation&lt;/code&gt;相当于是升级版的&lt;code&gt;useMemo&lt;/code&gt;，具体实现，可以参考&lt;span&gt;搞懂这12个Hooks，保证让你玩转React-useCreation&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  useCreation(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    state.data = list.slice(state.start, state.end)&lt;br/&gt;  }, [state.start])&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，一个简易版的&lt;code&gt;虚拟列表&lt;/code&gt;就ok了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码展示&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HOC:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { useEffect, useRef } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; useReactive &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../useReactive&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; useEventListener &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../useEventListener&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; useCreation &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../useCreation&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; HOC = &lt;span&gt;(&lt;span&gt;Component:any&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;(&lt;span&gt;{list, ...props}:any&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; state = useReactive({&lt;br/&gt;    &lt;span&gt;data&lt;/span&gt;: [], &lt;span&gt;//渲染的数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;scrollAllHeight&lt;/span&gt;: &lt;span&gt;&#x27;100vh&#x27;&lt;/span&gt;, &lt;span&gt;// 容器的初始高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;listHeight&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;//列表高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;itemHeight&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 子组件的高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;renderCount&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 需要渲染的数量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;bufferCount&lt;/span&gt;: &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;// 缓冲的个数 &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;start&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 起始索引&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;end&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 终止索引&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;currentOffset&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 偏移量&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; allRef = useRef&amp;lt;any&amp;gt;(&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;// 容器的ref&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; scrollRef = useRef&amp;lt;any&amp;gt;(&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;// 检测滚动&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 子列表高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; ItemHeight = &lt;span&gt;65&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 容器的高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; scrollAllHeight = allRef.current.offsetHeight&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 列表高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; listHeight = ItemHeight * list.length;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//渲染节点的数量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; renderCount = &lt;span&gt;Math&lt;/span&gt;.ceil(scrollAllHeight / ItemHeight) + state.bufferCount&lt;br/&gt;&lt;br/&gt;    state.renderCount = renderCount&lt;br/&gt;    state.end = renderCount + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    state.listHeight = listHeight&lt;br/&gt;    state.itemHeight = ItemHeight&lt;br/&gt;    state.data = list.slice(state.start, state.end)&lt;br/&gt;  }, [allRef])&lt;br/&gt;&lt;br/&gt;  useCreation(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    state.data = list.slice(state.start, state.end)&lt;br/&gt;  }, [state.start])&lt;br/&gt;&lt;br/&gt;  useEventListener(&lt;span&gt;&#x27;scroll&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;// 顶部高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { scrollTop } = scrollRef.current&lt;br/&gt;    state.start =  &lt;span&gt;Math&lt;/span&gt;.floor(scrollTop / state.itemHeight)&lt;br/&gt;    state.end  =  &lt;span&gt;Math&lt;/span&gt;.floor(scrollTop / state.itemHeight + state.renderCount + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    state.currentOffset = scrollTop - (scrollTop % state.itemHeight)&lt;br/&gt;    &lt;span&gt;// state.data = list.slice(state.start, state.end)&lt;/span&gt;&lt;br/&gt;  }, scrollRef)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;{allRef}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{height:&lt;/span&gt; state.scrollAllHeight, overflow: &#x27;scroll&#x27;, position: &#x27;relative&#x27;}}&lt;br/&gt;      &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;{scrollRef}&lt;/span&gt; &lt;br/&gt;    &amp;gt;&lt;/span&gt;&lt;br/&gt;      {/* 占位，列表的总高度，用于生成滚动条 */}&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{&lt;/span&gt; height: state.listHeight, position: &#x27;absolute&#x27;, left: 0, top: 0, right: 0 }}&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;br/&gt;      {/* 内容区域 */}&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{&lt;/span&gt; transform: `translate3d(0, ${state.currentOffset}px, 0)`, position: &#x27;relative&#x27;, left: 0, top: 0, right: 0}}&amp;gt;&lt;/span&gt;&lt;br/&gt;        {/* 渲染区域 */}&lt;br/&gt;        {&lt;br/&gt;          state.data.map((item:any) =&amp;gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;  &lt;span&gt;key&lt;/span&gt;=&lt;span&gt;{item}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            {/* 子组件 */}&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;Component&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{item}&lt;/span&gt; {&lt;span&gt;...props&lt;/span&gt;} /&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; HOC;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页面代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; React,{ useEffect, useState } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; img &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./img.jpeg&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { HOC } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/components&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 子组件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Item:React.FC&amp;lt;{&lt;span&gt;id&lt;/span&gt;: any}&amp;gt; = &lt;span&gt;(&lt;span&gt;{id}&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{display:&lt;/span&gt; &#x27;flex&#x27;, alignItems: &#x27;center&#x27;, padding: 5}}&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;img&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;{img}&lt;/span&gt; &lt;span&gt;width&lt;/span&gt;=&lt;span&gt;{80}&lt;/span&gt; &lt;span&gt;height&lt;/span&gt;=&lt;span&gt;{60}&lt;/span&gt; &lt;span&gt;alt&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;列表{id}&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; ItemHoc = HOC(Item)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Index:React.FC&amp;lt;any&amp;gt; = &lt;span&gt;(&lt;span&gt;props&lt;/span&gt;)=&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [list, setList] = useState&amp;lt;&lt;span&gt;Array&lt;/span&gt;&amp;lt;number&amp;gt;&amp;gt;([])&lt;br/&gt;&lt;br/&gt;  useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; arr:number[] = [] &lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;500&lt;/span&gt;; i++){&lt;br/&gt;      arr.push(i)&lt;br/&gt;    }&lt;br/&gt;    setList(arr)&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(list.length === &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;ItemHoc&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;=&lt;span&gt;{list}&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; Index;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;效果&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5516569200779727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmW7rekkzqWSsP8zbfwrOs2k9m6nlfe6CF1WEnGqlsVHlaKOBS9ia7FuFuQeUicCicEYDyzInanUHyRw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1026&quot;/&gt;&lt;figcaption&gt;img5.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虚拟列表-可优化的方向&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下拉请求数据&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;海量的数据可能用户并不会看完，需要下拉到底部进行刷新，所以我们可以判断一个临界值：滚动条距离底部的距离为0时出发&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;临界值：距离底部的高度 = 滚动条的高度 - 默认的高度 - 距离顶部的高度&lt;/p&gt;&lt;p&gt;const button = scrollHeight - clientHeight - scrollTop&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们传递给外界一个方法，做请求事件即可：onRequest(请求完拼接到list即可)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  useEventListener(&lt;span&gt;&#x27;scroll&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 顶部高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { clientHeight, scrollHeight } = scrollRef.current&lt;br/&gt;    &lt;span&gt;// 滚动条距离的高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; button = scrollHeight - clientHeight - scrollTop&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(button === &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; onRequest){&lt;br/&gt;      onRequest()&lt;br/&gt;    }&lt;br/&gt;  }, scrollRef)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.6497584541062802&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmW7rekkzqWSsP8zbfwrOs2AkbvY7r8Nse66WiarC8lLV7WREYzVXibbeia8R94JPBqicicnhNewEUxLMg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;414&quot;/&gt;&lt;figcaption&gt;img7.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;子列表高度问题&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，其实有一个很重要的问题，就是子列表的高度，我在上述的过程中，实际上是写死的&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32786885245901637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmW7rekkzqWSsP8zbfwrOs2RxG7uWelh3l5vW3dQYicn7ppxqPKNJGoNtFHzKULn9uNfY9sB5LERyw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;488&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在实际的开发过程中，子列表的高度有两种情况：&lt;code&gt;定高&lt;/code&gt;和&lt;code&gt;不定高&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;定高&lt;/code&gt;很简单，我们只需要手动计算下列表的高度，将值传入就行，但&lt;code&gt;不定高&lt;/code&gt;就很麻烦了，因为你无法计算出每个高度的情况，导致&lt;code&gt;列表的整体高度&lt;/code&gt;、&lt;code&gt;偏移量&lt;/code&gt;都无法正常的计算&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里我用&lt;code&gt;mock&lt;/code&gt;来模拟些数据看看：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4557235421166306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmW7rekkzqWSsP8zbfwrOs2v21NhGvGR9TrjyibRvjrQ8hPKy2Wbq5WhicGaQf0RGpicRPXXiaQQQQC6Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;926&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;思考&lt;/span&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对于子列表的动态高度我们该如何处理？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.第一种，将&lt;code&gt;ItemHeight&lt;/code&gt;作为参数传递过来，我们可以根据传递&lt;code&gt;数组&lt;/code&gt;来控制，但这种情况需要我们提前将列表的高度算出来，算每个子列表的高度很麻烦，其次这个高度还要根据屏幕的大小去变化，这个方法明显不适合&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.第二种，&lt;code&gt;预算高度&lt;/code&gt;，我们可以假定子列表的高度也就是虚假高度（&lt;code&gt;initItemHeight&lt;/code&gt;）,当我们渲染的时候，在更新对应高度，这样就可以解决子列表高度的问题&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;预算高度该如何考虑&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对第二种方案，我们需要去维护一个公共的高度列表（&lt;code&gt;positions&lt;/code&gt;），这个数组将会记录真实的DOM高度&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么&lt;code&gt;positions&lt;/code&gt;需要记录那些信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;const&lt;/span&gt; state = useReactive&amp;lt;any&amp;gt;({&lt;br/&gt;    ...,&lt;br/&gt;    &lt;span&gt;positions&lt;/span&gt;: [ &lt;span&gt;//需要记录每一项的高度&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// index         // 当前pos对应的元素的下标&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// top;          // 顶部位置&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// bottom        // 底部位置&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// height        // 元素高度&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// dHeight        // 用于判断是否需要改变&lt;/span&gt;&lt;br/&gt;    ], &lt;br/&gt;    &lt;span&gt;initItemHeight&lt;/span&gt;: &lt;span&gt;50&lt;/span&gt;, &lt;span&gt;// 预计高度&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要记录&lt;code&gt;元素的高度&lt;/code&gt;，其次可以存入距离顶部和底部的高度，方便后面计算偏移量和列表的整体高度，在设定一个参数（&lt;code&gt;dHeight&lt;/code&gt;）判断新的高度与旧的高度是否一样，不一样的话就进行更新&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中最重要的就是&lt;strong&gt;index&lt;/strong&gt;，它用来记录子列表真实高度的下标，这个点极为重要，原因是：在之前的讲解中，我们发现&lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt;的差值实际上是&lt;strong&gt;不变的&lt;/strong&gt;，也就是说，最终渲染的数据，实际上是一个&lt;code&gt;固定值&lt;/code&gt;，但里面的子列表高度却是&lt;code&gt;变值&lt;/code&gt;,所以我们需要有一个变量来区分数据所对应的高度，所以这个&lt;code&gt;index&lt;/code&gt;就变的&lt;strong&gt;尤为重要&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在这里我们设置一个&lt;code&gt;ref&lt;/code&gt;用来监听子节点&lt;code&gt;node&lt;/code&gt;，来获取真实高度,这里我设置id来判断对应的索引&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// list：数据改变&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; arr:any[] = [] &lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++){&lt;br/&gt;      arr.push({&lt;br/&gt;        &lt;span&gt;id&lt;/span&gt;: i, &lt;span&gt;//设置唯一值&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;content&lt;/span&gt;: Mock.mock(&lt;span&gt;&#x27;@csentence(40, 100)&#x27;&lt;/span&gt;) &lt;span&gt;// 内容&lt;/span&gt;&lt;br/&gt;      })&lt;br/&gt;   }&lt;br/&gt;  setList(arr)  &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;span&gt;// 渲染数据&lt;/span&gt;&lt;br/&gt;  {&lt;span&gt;/* 内容区域 */&lt;/span&gt;}&lt;br/&gt;  &amp;lt;div ref={ref} style={{ transform: `translate3d(0, ${state.currentOffset}px, 0)`, position: &#x27;relative&#x27;, left: 0, top: 0, right: 0}}&amp;gt;&lt;br/&gt;    {&lt;span&gt;/* 渲染区域 */&lt;/span&gt;}&lt;br/&gt;    {&lt;br/&gt;      state.data.map(&lt;span&gt;(&lt;span&gt;item:any&lt;/span&gt;) =&amp;gt;&lt;/span&gt;  &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{String(item.id)}&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;=&lt;span&gt;{item.id}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        {/* 子组件 */}&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;Component&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{item.content}&lt;/span&gt; {&lt;span&gt;...props&lt;/span&gt;} &lt;span&gt;index&lt;/span&gt;=&lt;span&gt;{item.id}&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;  &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;  &lt;br/&gt;  //初始的positions&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    // 初始高度&lt;br/&gt;    initPositions()&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  const initPositions =  () =&amp;gt; {&lt;br/&gt;    const data = []&lt;br/&gt;    for (let i = 0; i &amp;lt; list.length; i++) {&lt;br/&gt;      data.push({&lt;br/&gt;        index: i,&lt;br/&gt;        height: state.initItemHeight,&lt;br/&gt;        top: i * state.initItemHeight,&lt;br/&gt;        bottom: (i + 1) * state.initItemHeight,&lt;br/&gt;        dHeight: 0&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;    state.positions = [...data]&lt;br/&gt;  }&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;初始计算&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要改变的是&lt;code&gt;子列表的高度&lt;/code&gt;和&lt;code&gt;列表的高度&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 子列表高度：为默认的预计高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; ItemHeight = state.initItemHeight&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// // 容器的高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; scrollAllHeight = allRef.current.offsetHeight&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 列表高度：positions最后一项的bottom&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; listHeight = state.positions[state.positions.length - &lt;span&gt;1&lt;/span&gt;].bottom;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//渲染节点的数量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; renderCount = &lt;span&gt;Math&lt;/span&gt;.ceil(scrollAllHeight / ItemHeight) &lt;br/&gt;&lt;br/&gt;    state.renderCount = renderCount&lt;br/&gt;    state.end = renderCount + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    state.listHeight = listHeight&lt;br/&gt;    state.itemHeight = ItemHeight&lt;br/&gt;    state.data = list.slice(state.start, state.end)&lt;br/&gt;  }, [allRef, list.length])&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要注意一点的是：&lt;strong&gt;预计高度&lt;/strong&gt;尽量要小点，可以多加载，但不能少，防止渲染不全&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更新具体的高度&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们第一遍把列表的数据渲染成功后，就更新&lt;code&gt;positions&lt;/code&gt;的高度，将真实的高度替换一开始的虚拟高度，并将整体的高度进行更新&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;   setPostition()&lt;br/&gt; }, [ref.current])&lt;br/&gt; &lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; setPostition = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; nodes = ref.current.childNodes&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(nodes.length === &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   nodes.forEach(&lt;span&gt;(&lt;span&gt;node: HTMLDivElement&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (!node) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;     &lt;span&gt;const&lt;/span&gt; rect = node.getBoundingClientRect(); &lt;span&gt;// 获取对应的元素信息&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;const&lt;/span&gt; index = +node.id; &lt;span&gt;// 可以通过id，来取到对应的索引&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;const&lt;/span&gt; oldHeight = state.positions[index].height &lt;span&gt;// 旧的高度&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;const&lt;/span&gt; dHeight = oldHeight - rect.height  &lt;span&gt;// 差值&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt;(dHeight){&lt;br/&gt;       state.positions[index].height = rect.height &lt;span&gt;//真实高度&lt;/span&gt;&lt;br/&gt;       state.positions[index].bottom = state.positions[index].bottom - dHeight&lt;br/&gt;       state.positions[index].dHeight = dHeight &lt;span&gt;//将差值保留&lt;/span&gt;&lt;br/&gt;     }&lt;br/&gt;   });&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//  重新计算整体的高度&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; startId = +nodes[&lt;span&gt;0&lt;/span&gt;].id&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; positionLength = state.positions.length;&lt;br/&gt;   &lt;span&gt;let&lt;/span&gt; startHeight = state.positions[startId].dHeight;&lt;br/&gt;   state.positions[startId].dHeight = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = startId + &lt;span&gt;1&lt;/span&gt;; i &amp;lt; positionLength; ++i) {&lt;br/&gt;     &lt;span&gt;const&lt;/span&gt; item = state.positions[i];&lt;br/&gt;     state.positions[i].top = state.positions[i - &lt;span&gt;1&lt;/span&gt;].bottom;&lt;br/&gt;     state.positions[i].bottom = state.positions[i].bottom - startHeight;&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (item.dHeight !== &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;       startHeight += item.dHeight;&lt;br/&gt;       item.dHeight = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;     }&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// 重新计算子列表的高度&lt;/span&gt;&lt;br/&gt;   state.itemHeight = state.positions[positionLength - &lt;span&gt;1&lt;/span&gt;].bottom;&lt;br/&gt; }&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进行下对比：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0697247706422017&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmW7rekkzqWSsP8zbfwrOs2xHZ2zODmMG0aX30GmndQiaKgxRVb22gEl6yLb79DNu9mqqW7xCKneRg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1090&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0538033395176252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmW7rekkzqWSsP8zbfwrOs22rrt6tiaIWCD81zfuvOJQa4Tzzrzl1dUrUqibZ6geP2GbTu9d3uY1FzQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1078&quot;/&gt; 这样就可以将&lt;code&gt;真实的高度&lt;/code&gt;替换&lt;code&gt;虚拟的高度&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了首次的渲染之外，还有就是在&lt;code&gt;start&lt;/code&gt;或&lt;code&gt;end&lt;/code&gt;改变时重新计算，也就是&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  useCreation(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    state.data = list.slice(state.start, state.end)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(ref.current){&lt;br/&gt;      setPostition()&lt;br/&gt;    }&lt;br/&gt;  }, [state.end])&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;计算偏移量&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在滚动的方法中，我们可以通过&lt;code&gt;二分查找&lt;/code&gt;去降低检索次数，同时我们每次的偏移量为&lt;code&gt;state.positions[state.start \- 1].bottom&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; useEventListener(&#x27;scroll&#x27;, () =&amp;gt; {&lt;br/&gt;&lt;br/&gt;    // 顶部高度&lt;br/&gt;    const { scrollTop, clientHeight, scrollHeight } = scrollRef.current&lt;br/&gt;    state.start =  binarySearch(state.positions, scrollTop);&lt;br/&gt;    state.end  =  state.start + state.renderCount + 1&lt;br/&gt;    &lt;br/&gt;    // 计算偏移量&lt;br/&gt;    state.currentOffset = state.start &amp;gt; 0 ? state.positions[state.start - 1].bottom : 0&lt;br/&gt;&lt;br/&gt;    // 滚动条距离的高度&lt;br/&gt;    const button = scrollHeight - clientHeight - scrollTop&lt;br/&gt;    if(button === 0 &amp;amp;&amp;amp; onRequest){&lt;br/&gt;      onRequest()&lt;br/&gt;    }&lt;br/&gt;  }, scrollRef)&lt;br/&gt;&lt;br/&gt;  // 二分查找&lt;br/&gt;  const binarySearch = (list:any[], value: any) =&amp;gt;{&lt;br/&gt;    let start:number = 0;&lt;br/&gt;    let end:number = list.length - 1;&lt;br/&gt;    let tempIndex = null;&lt;br/&gt;    while(start &amp;lt;= end){&lt;br/&gt;      let midIndex = parseInt(String( (start + end)/2));&lt;br/&gt;      let midValue = list[midIndex].bottom;&lt;br/&gt;      if(midValue === value){&lt;br/&gt;        return midIndex + 1;&lt;br/&gt;      }else if(midValue &amp;lt; value){&lt;br/&gt;        start = midIndex + 1;&lt;br/&gt;      }else if(midValue &amp;gt; value){&lt;br/&gt;        if(tempIndex === null || tempIndex &amp;gt; midIndex){&lt;br/&gt;          tempIndex = midIndex;&lt;br/&gt;        }&lt;br/&gt;        end = end - 1;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    return tempIndex;&lt;br/&gt;  }&lt;br/&gt;复制代码&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码展示&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HOC：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { useEffect, useRef } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; useReactive &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../useReactive&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; useEventListener &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../useEventListener&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; useCreation &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../useCreation&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; HOC = &lt;span&gt;(&lt;span&gt;Component:any&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;(&lt;span&gt;{list, onRequest, ...props}:any&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; state = useReactive&amp;lt;any&amp;gt;({&lt;br/&gt;    &lt;span&gt;data&lt;/span&gt;: [], &lt;span&gt;//渲染的数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;scrollAllHeight&lt;/span&gt;: &lt;span&gt;&#x27;100vh&#x27;&lt;/span&gt;, &lt;span&gt;// 容器的初始高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;listHeight&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;//列表高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;itemHeight&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 子组件的高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;renderCount&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 需要渲染的数量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;bufferCount&lt;/span&gt;: &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;// 缓冲的个数 &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;start&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 起始索引&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;end&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 终止索引&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;currentOffset&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 偏移量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;positions&lt;/span&gt;: [ &lt;span&gt;//需要记录每一项的高度&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// index         // 当前pos对应的元素的下标&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// top;          // 顶部位置&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// bottom        // 底部位置&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// height        // 元素高度&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// dHeight        // 用于判断是否需要改变&lt;/span&gt;&lt;br/&gt;    ], &lt;br/&gt;    &lt;span&gt;initItemHeight&lt;/span&gt;: &lt;span&gt;50&lt;/span&gt;, &lt;span&gt;// 预计高度&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; allRef = useRef&amp;lt;any&amp;gt;(&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;// 容器的ref&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; scrollRef = useRef&amp;lt;any&amp;gt;(&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;// 检测滚动&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ref = useRef&amp;lt;any&amp;gt;(&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;// 检测滚动&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 初始高度&lt;/span&gt;&lt;br/&gt;    initPositions()&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; initPositions =  &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; data = []&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.length; i++) {&lt;br/&gt;      data.push({&lt;br/&gt;        &lt;span&gt;index&lt;/span&gt;: i,&lt;br/&gt;        &lt;span&gt;height&lt;/span&gt;: state.initItemHeight,&lt;br/&gt;        &lt;span&gt;top&lt;/span&gt;: i * state.initItemHeight,&lt;br/&gt;        &lt;span&gt;bottom&lt;/span&gt;: (i + &lt;span&gt;1&lt;/span&gt;) * state.initItemHeight,&lt;br/&gt;        &lt;span&gt;dHeight&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;    state.positions = [...data]&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 子列表高度：为默认的预计高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; ItemHeight = state.initItemHeight&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// // 容器的高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; scrollAllHeight = allRef.current.offsetHeight&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 列表高度：positions最后一项的bottom&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; listHeight = state.positions[state.positions.length - &lt;span&gt;1&lt;/span&gt;].bottom;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//渲染节点的数量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; renderCount = &lt;span&gt;Math&lt;/span&gt;.ceil(scrollAllHeight / ItemHeight) &lt;br/&gt;&lt;br/&gt;    state.renderCount = renderCount&lt;br/&gt;    state.end = renderCount + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    state.listHeight = listHeight&lt;br/&gt;    state.itemHeight = ItemHeight&lt;br/&gt;    state.data = list.slice(state.start, state.end)&lt;br/&gt;  }, [allRef, list.length])&lt;br/&gt;&lt;br/&gt;  useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    setPostition()&lt;br/&gt;  }, [ref.current])&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; setPostition = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; nodes = ref.current.childNodes&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(nodes.length === &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    nodes.forEach(&lt;span&gt;(&lt;span&gt;node: HTMLDivElement&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!node) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; rect = node.getBoundingClientRect(); &lt;span&gt;// 获取对应的元素信息&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; index = +node.id; &lt;span&gt;// 可以通过id，来取到对应的索引&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; oldHeight = state.positions[index].height &lt;span&gt;// 旧的高度&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; dHeight = oldHeight - rect.height  &lt;span&gt;// 差值&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(dHeight){&lt;br/&gt;        state.positions[index].height = rect.height &lt;span&gt;//真实高度&lt;/span&gt;&lt;br/&gt;        state.positions[index].bottom = state.positions[index].bottom - dHeight&lt;br/&gt;        state.positions[index].dHeight = dHeight &lt;span&gt;//将差值保留&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//  重新计算整体的高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; startId = +nodes[&lt;span&gt;0&lt;/span&gt;].id&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; positionLength = state.positions.length;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; startHeight = state.positions[startId].dHeight;&lt;br/&gt;    state.positions[startId].dHeight = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = startId + &lt;span&gt;1&lt;/span&gt;; i &amp;lt; positionLength; ++i) {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; item = state.positions[i];&lt;br/&gt;      state.positions[i].top = state.positions[i - &lt;span&gt;1&lt;/span&gt;].bottom;&lt;br/&gt;      state.positions[i].bottom = state.positions[i].bottom - startHeight;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (item.dHeight !== &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        startHeight += item.dHeight;&lt;br/&gt;        item.dHeight = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 重新计算子列表的高度&lt;/span&gt;&lt;br/&gt;    state.itemHeight = state.positions[positionLength - &lt;span&gt;1&lt;/span&gt;].bottom;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  useCreation(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    state.data = list.slice(state.start, state.end)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(ref.current){&lt;br/&gt;      setPostition()&lt;br/&gt;    }&lt;br/&gt;  }, [state.end])&lt;br/&gt;&lt;br/&gt;  useEventListener(&lt;span&gt;&#x27;scroll&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 顶部高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { scrollTop, clientHeight, scrollHeight } = scrollRef.current&lt;br/&gt;    state.start =  binarySearch(state.positions, scrollTop);&lt;br/&gt;    state.end  =  state.start + state.renderCount + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 计算偏移量&lt;/span&gt;&lt;br/&gt;    state.currentOffset = state.start &amp;gt; &lt;span&gt;0&lt;/span&gt; ? state.positions[state.start - &lt;span&gt;1&lt;/span&gt;].bottom : &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 滚动条距离的高度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; button = scrollHeight - clientHeight - scrollTop&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(button === &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; onRequest){&lt;br/&gt;      onRequest()&lt;br/&gt;    }&lt;br/&gt;  }, scrollRef)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 二分查找&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; binarySearch = &lt;span&gt;(&lt;span&gt;list:any[], value: any&lt;/span&gt;) =&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; start:number = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; end:number = list.length - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; tempIndex = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(start &amp;lt;= end){&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; midIndex = &lt;span&gt;parseInt&lt;/span&gt;(&lt;span&gt;String&lt;/span&gt;( (start + end)/&lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; midValue = list[midIndex].bottom;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(midValue === value){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; midIndex + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;      }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(midValue &amp;lt; value){&lt;br/&gt;        start = midIndex + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;      }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(midValue &amp;gt; value){&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(tempIndex === &lt;span&gt;null&lt;/span&gt; || tempIndex &amp;gt; midIndex){&lt;br/&gt;          tempIndex = midIndex;&lt;br/&gt;        }&lt;br/&gt;        end = end - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; tempIndex;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;{allRef}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{height:&lt;/span&gt; state.scrollAllHeight, overflow: &#x27;scroll&#x27;, position: &#x27;relative&#x27;}}&lt;br/&gt;      &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;{scrollRef}&lt;/span&gt; &lt;br/&gt;    &amp;gt;&lt;/span&gt;&lt;br/&gt;      {/* 占位，列表的总高度，用于生成滚动条 */}&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{&lt;/span&gt; height: state.listHeight, position: &#x27;absolute&#x27;, left: 0, top: 0, right: 0 }}&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;br/&gt;      {/* 内容区域 */}&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;{ref}&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{&lt;/span&gt; transform: `translate3d(0, ${state.currentOffset}px, 0)`, position: &#x27;relative&#x27;, left: 0, top: 0, right: 0}}&amp;gt;&lt;/span&gt;&lt;br/&gt;        {/* 渲染区域 */}&lt;br/&gt;        {&lt;br/&gt;          state.data.map((item:any) =&amp;gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{String(item.id)}&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;=&lt;span&gt;{item.id}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            {/* 子组件 */}&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;Component&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{item.content}&lt;/span&gt; {&lt;span&gt;...props&lt;/span&gt;} &lt;span&gt;index&lt;/span&gt;=&lt;span&gt;{item.id}&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; HOC;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页面代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import React,{ useEffect, useState } from &#x27;react&#x27;;&lt;br/&gt;import { HOC } from &#x27;@/components&#x27;;&lt;br/&gt;import Mock from &#x27;mockjs&#x27;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;// 子组件&lt;br/&gt;const Item:React.FC&amp;lt;{id: any, index?:number}&amp;gt; = ({id, index}) =&amp;gt; {&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div style={{display: &#x27;flex&#x27;, alignItems: &#x27;center&#x27;, padding: 5, lineHeight: &#x27;24px&#x27;, border: &#x27;1px solid #ccc&#x27;}}&amp;gt;&lt;br/&gt;     列表{index}: {id}&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const ItemHoc = HOC(Item)&lt;br/&gt;&lt;br/&gt;const Index:React.FC&amp;lt;any&amp;gt; = (props)=&amp;gt; {&lt;br/&gt;&lt;br/&gt;  const [list, setList] = useState&amp;lt;any&amp;gt;([])&lt;br/&gt;&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    let arr:any[] = [] &lt;br/&gt;    for(let i = 0; i &amp;lt; 100; i++){&lt;br/&gt;      arr.push({&lt;br/&gt;        id: i,&lt;br/&gt;        content: Mock.mock(&#x27;@csentence(40, 100)&#x27;)&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    setList(arr)&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  if(list.length === 0) return &amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div&amp;gt;&lt;br/&gt;      &amp;lt;ItemHoc list={list} /&amp;gt;&lt;br/&gt;   &amp;lt;/div&amp;gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;export default Index;&lt;br/&gt;复制代码&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;效果&lt;/span&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6510962821734986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmW7rekkzqWSsP8zbfwrOs2rHcmS5Xp6G7ZkD1IIAfzetmibpbVNlmE93icgjCrqC0Z1teByaTOvL9A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1049&quot;/&gt;&lt;figcaption&gt;img8.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;存在的问题&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列表中可能存在由&lt;code&gt;图片&lt;/code&gt;撑起高度的情况，图片会发送网络请求，可能会造成计算不准确的问题，但这种情况比较少见，基本上可以忽略&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;End&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文是将两种常见的&lt;code&gt;分片渲染&lt;/code&gt;和&lt;code&gt;虚拟列表&lt;/code&gt;的功能封装成高阶组件的形式，与传统的懒加载还是有一定的区别，本质上有所不同&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文中考虑的可能并不是非常的全面，有任何好的建议，欢迎再评论区指出～&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;em/&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;关于本文&lt;/span&gt;&lt;/section&gt;&lt;h1 data-v-5e9178fa=&quot;&quot;&gt;&lt;span&gt;作者：小杜杜&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;https://juejin.cn/post/7121551701731409934&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-darkmode-color-16057140139831=&quot;rgb(162, 162, 162)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(68, 68, 68)&quot; data-style=&quot;padding-top: 7px; padding-bottom: 7px; color: rgb(68, 68, 68); font-size: 14px; line-height: 1.8; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Lucida Grande&amp;quot;, Arial, &amp;quot;Hiragino Sans GB&amp;quot;, 微软雅黑, &amp;quot;WenQuanYi Micro Hei&amp;quot;, STHeiti, SimSun, sans-serif; text-align: center;&quot;&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(63, 63, 63)&quot; data-style=&quot;color: rgb(63, 63, 63); font-family: monospace; font-size: 20px; letter-spacing: 0.544px; white-space: pre-wrap; widows: 1; caret-color: rgb(51, 51, 51);&quot;&gt;The End&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如果你觉得这篇内容对你挺有启发，我想请你帮我三个小忙：&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(0,0,0)&quot; data-style=&quot;padding-right: 10px; padding-left: 10px; font-size: 16px; color: black; line-height: 1.6; letter-spacing: 0px; word-break: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif;&quot;&gt;&lt;section&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot;&gt;1、点个 &lt;span data-darkmode-color-16057140139831=&quot;rgb(71, 193, 168)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(71, 193, 168)&quot;&gt;「在看」&lt;/span&gt;，让更多的人也能看到这篇内容&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot;&gt;2、关注官网 &lt;span data-darkmode-color-16057140139831=&quot;rgb(71, 193, 168)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(71, 193, 168)&quot;&gt;https://muyiy.cn&lt;/span&gt;，让我们成为长期关系&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot;&gt;3、关注公众号「高级前端进阶」，公众号后台回复 &lt;span data-darkmode-color-16057140139831=&quot;rgb(71, 193, 168)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(71, 193, 168)&quot;&gt;「加群」&lt;/span&gt; ，加入我们一起学习并送你精心整理的高级前端面试题。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile data-index=&quot;0&quot; data-id=&quot;MzA4Nzg0MDM5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/H8M5QJDxMHpg1ClH18gOQIicISIoSybyDNK203zFMpSM7jHdovb4elgdqNoy6Bylk7XicC6Rpj5QrCv3FkOpR6tw/0?wx_fmt=png&amp;amp;wx_head=1&quot; data-nickname=&quot;高级前端进阶&quot; data-alias=&quot;FrontendGaoji&quot; data-signature=&quot;网易 &amp;amp; 蚂蚁前端，专注前端进阶领域，已帮助无数前端跳槽涨薪。每日一题「Daily-Interview-Question」 Github 收获近 25000 颗小星星，各公司面试官都在使用。接下来带你走进高级前端的世界，在进阶的路上，共勉！&quot; data-origin_num=&quot;48&quot; data-is_biz_ban=&quot;0&quot; data-isban=&quot;0&quot; class=&quot;js_wx_tap_highlight&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: rgb(89, 89, 89);&quot;&gt;&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wx27c980b913cbfb08&quot; data-miniprogram-path=&quot;pages/index/index?_um_campaign=5ec14536978eea0825f4eb6f&amp;amp;_um_channel=5ec14536978eea0825f4eb70&quot; data-miniprogram-nickname=&quot;高级前端面试&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot; data-darkmode-bgcolor-15950741730771=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-15950741730771=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15950741730771=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-15950741730771=&quot;rgb(0,0,0)&quot; data-darkmode-color-15963792901125=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-15963792901125=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16018219266315=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16018219266315=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16018219266315=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16018219266315=&quot;rgb(58, 58, 58)&quot; data-darkmode-bgcolor-16020008769986=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16020008769986=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16020008769986=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16020008769986=&quot;rgb(58, 58, 58)&quot; data-darkmode-color-16021670869911=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(58, 58, 58)&quot; data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-bgcolor-16030305897056=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030305897056=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030305897056=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16030305897056=&quot;rgb(58, 58, 58)&quot; data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(58, 58, 58)&quot; wah-hotarea=&quot;click&quot; href=&quot;&quot;&gt;》》面试官都在用的题库，快来看看《&lt;/a&gt;《&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: rgb(89, 89, 89);&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-darkmode-color-16030305897056=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16030305897056=&quot;rgb(63, 63, 63)&quot; data-style=&quot;color: rgb(63, 63, 63); font-size: 16px; font-family: Avenir, -apple-system-font, 微软雅黑, sans-serif;&quot; data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(63, 63, 63)&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16030305897056=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16030305897056=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-right: 10px; padding-left: 10px; line-height: 1.6; word-break: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; font-size: 15px; letter-spacing: 0.05em; color: rgb(89, 89, 89);&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16030305897056=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16030305897056=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot;&gt;&lt;pre data-darkmode-bgcolor-15987645674728=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-15987645674728=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15987645674728=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-15987645674728=&quot;rgb(0, 0, 0)&quot; data-style=&quot;color: rgb(0, 0, 0); text-align: left; letter-spacing: 0.544px; word-spacing: 2px; font-size: 20px; font-weight: 700; background-color: rgb(255, 255, 255);&quot; data-original-code=&quot;&amp;lt;br&amp;gt;扩展阅读1、一篇文章上手Vue3中新增的API&amp;lt;br&amp;gt;2、Vue源码解析——异步组件是如何使用的&amp;lt;br&amp;gt;3、写好JavaScript条件语句的5条守则&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;The End如果你觉得这篇内容对你挺有启发，我想请你帮我三个小忙：点个「在看」，让更多的人也能看到这篇内容&amp;lt;br&amp;gt;关注官网 https://muyiy.cn，让我们成为长期关系&amp;lt;br&amp;gt;关注公众号「高级前端进阶」，公众号后台回复「加群」 加入我们一起学习并送你精心整理的高级前端面试题。&amp;lt;br&amp;gt;》》面试官都在用的题库，快来看看《《                        高级前端进阶 发起了一个读者讨论         写留言                                        &amp;lt;br&amp;gt;“在看”吗？在看就点一下吧&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot; data-snippet-id=&quot;ext.dfdc660f8db84bdd3e9d3d519ceaec46&quot; data-snippet-saved=&quot;false&quot; data-codota-status=&quot;done&quot; data-darkmode-color-16030305897056=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16030305897056=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot;&gt;&lt;section data-darkmode-bgcolor-15987645674728=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-15987645674728=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15987645674728=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-15987645674728=&quot;rgb(62, 62, 62)&quot; data-style=&quot;letter-spacing: 0px; white-space: normal; font-size: 16px; color: rgb(62, 62, 62); font-family: &#x27;Helvetica Neue&#x27;, Helvetica, &#x27;Hiragino Sans GB&#x27;, &#x27;Microsoft YaHei&#x27;, Arial, sans-serif; widows: 1; line-height: 1.6;&quot; data-darkmode-color-16030305897056=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16030305897056=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-bgcolor-15987645674728=&quot;rgba(112, 0, 0, 0.018750000000000003)&quot; data-darkmode-original-bgcolor-15987645674728=&quot;rgba(20, 0, 0, 0.018750000000000003)&quot; data-darkmode-color-15987645674728=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-15987645674728=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding: 10px; word-break: break-word; line-height: 1.75; color: rgb(89, 89, 89); font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;&quot; data-darkmode-color-16030305897056=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16030305897056=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot;&gt;&lt;pre data-original-code=&quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;The End如果你觉得这篇内容对你挺有启发，我想请你帮我三个小忙：点个「在看」，让更多的人也能看到这篇内容&amp;lt;br&amp;gt;关注官网 https://muyiy.cn，让我们成为长期关系&amp;lt;br&amp;gt;关注公众号「高级前端进阶」，公众号后台回复「加群」 加入我们一起学习并送你精心整理的高级前端面试题。&amp;lt;br&amp;gt;》》面试官都在用的题库，快来看看《《                        高级前端进阶 发起了一个读者讨论         参与讨论                                        &amp;lt;br&amp;gt;“在看”吗？在看就点一下吧&amp;lt;br&amp;gt;&quot; data-snippet-id=&quot;ext.89a96a6ef2d46757b2677de8206703d5&quot; data-snippet-saved=&quot;false&quot; data-codota-status=&quot;done&quot; data-darkmode-color-16030305897056=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16030305897056=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-bgcolor-16018219266315=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16018219266315=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16018219266315=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16018219266315=&quot;rgb(0,0,0)&quot; data-style=&quot;padding-right: 10px; padding-left: 10px; letter-spacing: 0px; background-color: rgb(255, 255, 255); line-height: 1.6; word-break: break-word;&quot; data-darkmode-bgcolor-16020008769986=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16020008769986=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16020008769986=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16020008769986=&quot;rgb(0,0,0)&quot; data-darkmode-color-16021670869911=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030305897056=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16030305897056=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot;&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;13777&quot; data-style-type=&quot;关注&quot; data-darkmode-color-16030305897056=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16030305897056=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot;&gt;&lt;section data-darkmode-color-16030305897056=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16030305897056=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot;&gt;&lt;section data-darkmode-color-16030305897056=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16030305897056=&quot;rgb(0, 0, 0)&quot; data-style=&quot;font-family: &amp;quot;PingFang SC&amp;quot;, 微软雅黑, mp-quote, -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 14px; color: rgb(0, 0, 0); letter-spacing: 1.56px; font-weight: 600; line-height: 20px;&quot; data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(0, 0, 0)&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: rgb(89, 89, 89);&quot;&gt;&lt;span&gt;最后不要忘了点赞呦！&lt;span&gt;&lt;img data-ratio=&quot;1.0076923076923077&quot; data-type=&quot;gif&quot; data-w=&quot;260&quot; data-fileid=&quot;100022933&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/H8M5QJDxMHo0BmF9r9Z5jmnjiaRjia63KdItrdfQPpQLTn685ib4pQK1j8wNibqXIQb5m7oLf2v7pke7SMTzCFVs3w/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: rgb(89, 89, 89);&quot;&gt;&lt;span&gt;祝 2022 年暴富！暴美！暴瘦！&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>