<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f7291ed7a22f2b3e13580eba722edf96</guid>
<title>现在做游戏还有未来吗？</title>
<link>https://toutiao.io/k/09yu28n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;markdown编辑器&quot; data-website=&quot;https://markdown.com.cn/editor&quot;&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;自18年开始停发版号，到21年抛出“精神鸦片论”，国内的游戏产业可以用哀鸿遍野来形容，几年内数万家游戏厂商倒闭。那么，游戏产业还有未来吗？&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;要回答这个问题，我们要考察人的需求，因为市场的经济活动是由人的需求推动的。我们还要考察监管者的需要，即政府的需要。考察完市场和政府，我们就能大致得出一个结论了。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;人的需求&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;要考察人的需求，必须了解马斯洛需求层次理论。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QdhQ7GiaOrDZGYcMm6nNgpnDg67r95u29f4qkdwzeQZSOL7NIqCbwe9RaB0myhlHumkemrMiamwUIobJpTia4tP2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;马斯洛将人的需求，分成了五个层次，像金字塔一样从低到高排列。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;最下面的两层是满足人生存和安全所必需，我们可以把它们统称为&lt;strong&gt;生存需求&lt;/strong&gt;。上面三层主要是为了满足人的&lt;strong&gt;心理需求&lt;/strong&gt;，比如建立社交连接，建立自尊和渴望被尊重，以及可以自由地追求兴趣，挑战自我极限。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;马斯洛认为人只有先满足了低级的需求后，才能去追求更高的需求。中国有一句俗语叫“饱暖思淫欲”，大致就是这个道理。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;现在我们来考察游戏满足了哪几层需求。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;游戏无法满足生存需求，在现代社会，这些需求主要由政府提供的公共产品来满足。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;游戏满足的是人的心理需求。毋庸置疑，网络游戏能给人提供紧密的社交连接，即满足了归属需求；即便是单机游戏也能给人提供归属需求，比如说养一只电子宠物。有了归属需求，自然就会产生尊重需求，比如在游戏里被人喷了，我们可能就会喷回去；在单机游戏里你闯关失败了，也会一样的不爽。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;我认为，游戏更多满足的是自我实现需求，因为现实世界的限制太强。我们无法突破重力限制来像鸟一样飞翔，但是在游戏里我们可以自由自在的飞翔。初中时读完三国后，我久久不能释怀，直到玩了光荣的三国志，体验到了调兵遣将，攻城略地的感觉，一玩就是十年，根本停不下来。为了玩GTA5，我还专门买了个PS4，因为我能在GTA里干一切我不敢也不能在现实世界里干的事情。总之，游戏能突破现实世界的限制，满足一切你没有条件在现实世界实现的愿望。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;总结一下，游戏主要满足人的心理需求，因为其虚拟的特性可以突破物理限制，画面音乐交互提供极强的沉浸感，能更好的满足人的自我实现需求。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;增长的秘密&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;现在我们来考察游戏的市场有多大。在此之前，我们需要先理解市场增长的秘密。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;有一句话叫“物以稀为贵”，蕴藏着很高的智慧。它表达的意思是&lt;strong&gt;人需要且稀有&lt;/strong&gt;的事物更珍贵。现在经常见有些人吹某某NFT很有价值，因为该NFT独一无二。这绝对是一种忽悠，我画的画也很稀有，几年也就画了一幅，它能卖出高价吗？显然不能，因为人们&lt;strong&gt;并不需要&lt;/strong&gt;我的画。什么时候等我成了名人了，我画的画才有价值，因为粉丝可能对我的画比较好奇，为了满足好奇心，他们可能会花钱来参观或者直接买下我的画，这才叫物以稀为贵。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;所以，增长的秘密到底是什么？&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;物以稀为贵。只要是人们确实有需要的，且当下供给较少的，其内生的高价值就会吸引大部分资本和劳动力进入，从而推动行业工资上涨，使得它蓬勃发展，直至它慢慢变得稀松平常，逐渐变成基础行业。简而言之，需求越大，供给越少，就越能增长。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;这个发展顺序是按照马斯洛需求层次的从低到高来发展的，农业满足了人的生存需求，首先得到发展，土地变成了稀缺资源；第一次工业革命主要满足了人的安全需求，钢铁使房子更牢固，纺织品蓬勃使穷人也能穿上像样的衣物，煤炭变成了稀缺资源；第二次工业革命催生了汽车和电话，人们可以方便地进行远距离交流和沟通，石油变成了稀缺资源；第三次工业革命催生了计算机和互联网，从此天涯若比邻，信息流通效率指数级上升，芯片变成了稀缺资源。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;本文所说的游戏行业，指的是电子游戏，是构建在计算机和互联网上的产物。从某种意义上来讲，还算一个新生行业，网游和3D游戏的发展也不过才30年，与我年纪相仿。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;那么游戏的需求旺不旺盛呢？我们可以从两个维度来考察，一个是游戏从业者的工资水平，一个是玩家数量。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7386363636363636&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QdhQ7GiaOrDZGYcMm6nNgpnDg67r95u29P4twJ4FwrOKSZJ9FoKRSNZ1CkTv21UX6rgSUU2E5TmUQPpg9ReiapNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;上图是智联招聘发布的2020年各行业平均工资排行榜，可以看出游戏业的平均工资是很高的，远高于传统行业。根据物以稀为贵，我们可以推演，未来会有越来越多的人才进入游戏行业，另外一方面也说明游戏吸引了越来越多的资本进入，推动薪酬水涨船高。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QdhQ7GiaOrDZGYcMm6nNgpnDg67r95u294eZXruZYS9942Sdnq7zqian4HnXXH8elSwC89FRuCqV3bnFOVSd8btA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;上图是Newzoo发布的全球游戏玩家数量报告，可以看出游戏玩家数量在逐年增长，2022年已达到30亿多人，这是一个巨大的市场。随着第三世界计算机和互联网的不断普及，这个市场只会变得越来越大。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;总结一下，在生产力高度发达的今天，基本的生存需求得到满足后，会有越来越多的人选择把时间投入到游戏中，来满足其心理需求。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;政府的需要&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;下面我们来考察政府是否需要游戏产业。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;我们要先了解政府的职能。用最简单的话来概况，政府通过向人民收税来制造公共产品，以满足人民的需要。比如说提供自来水和电力，建桥修路造医院学校等等。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;政府需要合法性来稳固其统治，如果人们普遍没有工作，又得不到救济，活不下去，肯定是要造反的。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;也就是说，失业率是一个非常重要的问题。失业率越高的社会，越不稳定，政府的执政根基就越弱，所以政府会千方百计的降低失业率。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;学过马克思原理的都知道，资本主义的核心矛盾在于有效需求不足。即，随着生产力的发展，生产会逐步扩大，产能开始过剩，导致商品供大于求，导致商品价格下降，导致企业利润下降，导致工资下降或裁员，导致失业率上升，导致打工人变穷，导致大部分人的消费需求减弱，从而使产能愈发过剩的恶性循环。这种不断重复的恶性循环，就是一次又一次的经济危机。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;这一幕又将上演了，贫富差距越拉越大，有钱的人控制的财富越来越多，但他们毕竟是少数，即便再穷奢极欲也不能平替广大人民群众的需求，总需求在萎缩，产能过剩的问题越发严重。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;第一次工业革命后，英国的解决办法是引入新的市场，把过剩的产能转移到新市场去卖，在清朝拒绝其进入的要求后，鸦片战争便爆发了。第一次世界大战的本质是工业革命催生的新兴资本主义强国（以德国为代表）和旧资本主义强国（以英国为代表）争夺市场的战争。由于一战没能彻底解决矛盾，于是20多年后又爆发了二战，彻底摧毁了除了美国以外的所有老牌强国。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;二战后，由于核武器的出现，构建了恐怖平衡，核大国之间再也没有爆发过热战。武力争夺市场的戏码在减少，却以金融战、网络战、生物战等超限战的方式进行着。其内在的本质还是因为过剩的产能需要转移。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;现在再闭塞的人也能了解到，AI技术正在突飞猛进，一日千里。未来，AI和机器人取代大部分人类的工作基本已成定局。失业率会越来越高，被迫灵活就业的人也会越来越多，从网约车司机和外卖小哥的数量增长便能窥探一二。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;随着奇点临近的脚步声越来越近，那些被替代的人该去干些什么呢？&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;生理需求在这个物质高度繁荣的社会，已经不构成问题，逐渐完善的福利体系已能让绝大部分人过上温饱的生活。失业后的心理需求得不到满足才是一个大问题。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;所以我们看到游戏和短视频乘着技术的东风呼啸而来，席卷了整个世界。其本质都是因为它们快捷且廉价的满足了人们的心理需求。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;相较于短视频，我认为游戏是一个未来更大的市场，因为它能创造另外一个世界，这个世界可以包含短视频在内的一切娱乐方式。在堡垒之夜，同时有一千万人上线游戏，只是为了听一场虚拟演唱会。人们沉浸其中，可以借此短暂的逃离现实世界。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;游戏也是廉价的奶头乐，人们可以尽情的在游戏里发泄自己的情绪和戾气，总体上会使现实社会更加安宁。也就是说，政府需要游戏的存在，需要其去安抚未来可能越来越广大的失业人群，来帮助其稳定社会。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;除了奶头乐对维护社会稳定的作用外，游戏也引领着科技创新的方向。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;GPU是由电子游戏推动的，你我在内的游戏玩家都曾为GPU买过单。万千玩家对游戏画质的需求推动着英伟达和AMD不断发展其GPU工艺，巨大的出货量也推动着其股价节节攀升。现在，GPU的贡献绝不仅限于游戏，其对推动科学计算和AI发展的也贡献巨大。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;游戏还可以提供一个完美的模拟环境。如果要做自动驾驶，可以先在游戏内去测试，这样可以极大地降低风险。有人就在GTA5里测试过自动驾驶的算法（见下图），可以随意模拟雨天，雾天等现实世界难以遇到的情况，结果工作的很好。飞行员在实际起飞前，要在一个飞行模拟器内进行培训和考核，为的就是降低真机操作失误的风险。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.66625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QdhQ7GiaOrDYJDZic6PVSYmkicV3S5v5L5e4VZzIKBeabX6bGeTVRzYic5EPcqUwxIKXiajHpbWWKdpXq8OMwJxDwJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;一切现实世界里有危险的，成本和代价比较高的活动，我们都可以先用游戏来模拟，这样既可以降低成本，也能够提高安全性。战争作为最危险的事物，也可以用游戏来模拟，进行兵棋和沙盘推演。随着数字化和机器人的不断发展，未来的热战，很有可能是电竞选手或AI之间的战争。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;科技是第一生产力，游戏推动着科技的发展，自然也推动着生产力的发展；另外一方面，生产力的不断进步，失业人群不断扩大，也需要游戏去承接住产能过剩后日益庞大的失业人群。所以，从正反两面来看，政府都需要游戏产业。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;打压和出路&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;有人可能会问了，既然这样的话，为什么会停发版号呢？&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;要分析事物的矛盾，首先要抓住主要矛盾和矛盾的主要方面。18年的主要矛盾是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;国内，游戏行业随着王者荣耀为代表的崛起，乱象也随之而来。舆论对游戏行业口诛笔伐，诸如篡改历史，青少年沉迷引发近视和成绩下降，“是兄弟就砍我一刀”的低俗烂梗广为流传等。只可惜，真正用心去做游戏的人势单力薄，社会的中坚力量也不怎么玩游戏，更别提做过游戏，负面的声音压过正面的，舆论形成一股很大的合力，推动着政府停发版号。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;国际上，18年中美贸易战爆发，中兴华为受到制裁，芯片供应被卡脖子，国内高端制造业遭受打压。彼时，由于热钱向移动互联网涌入，也分流到了游戏，高薪吸引了一批精英涌入这个偏软的行业。没有人愿意去干制造业，更没有人愿意去报考难找工作的基础行业。在决策者看来，高端制造业是中国脱离中等收入陷阱的必需，于是制造业人才流失变成了主要矛盾，虚拟经济变成了次要矛盾。中国制造2025计划推出，职业教育被国家大力推动，互联网和游戏暂时承压。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;现如今，国内游戏行业奄奄一息，社会上失业人口也越来越多，版号又开始恢复发放，这一股寒流已过，大家是时候抖擞起精神了！&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;手游是国内游戏市场的绝对主流。手机出货量已连续多年下跌，手游的竞争也越来越激烈，除非创新出一种新品类，否则已是一个存量竞争的市场，内卷越来越严重，出路到底在哪里？&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;手游厂商应该思考的是，还有没有价值洼地？即之前看不上的市场，看不上的用户，是不是竞争还比较小。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;另外就是要跳脱出手机的载体，去尝试多端的市场，比如网页，主机，Steam等PC游戏平台，目前成熟的引擎技术早就可以支持一套代码多平台发布，技术问题是小问题，更大的问题是对这些之前不重视市场的学习和理解。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;最后就是在保证生存的情况下，要分出一部分人力去投资未来，向前看。VR正在卷土重来，VR设备出货量在逐年上升，而VR游戏却没有一个像王者荣耀那样的杀手级游戏，甚至连当年的刀塔传奇也没有出现。如果能够提前去思考如何在VR设备上制造爆款这个问题，也许就能赢得未来一个巨大的市场机遇。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;结论&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;现在可以回答题目的问题了：做游戏还有未来吗？&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;我的回答是：未来大有可为！&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;就像是一切新生事物都要在螺旋中发展，在波折中前进一样，其前途是光明的，其道路是曲折的。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;游戏厂商在保证其生存的前提下，做任何事都要站在玩家的角度去思考，这是玩家需要的吗？同时也要站在监管者的角度去考虑，这是政府鼓励的吗？还要学会跳脱出来，去审视之前没有重视过的市场和技术。思考清楚了这几个问题，心里便大致有底了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e1b0c432f14d1b0990e592fc1a9dbd04</guid>
<title>10年研究积累，推动图像合成进入「PS」时代</title>
<link>https://toutiao.io/k/rhrapw9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;white-space: normal; max-width: 100%; letter-spacing: 0.544px; text-size-adjust: auto; background-color: rgb(255, 255, 255); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-top: 2em; padding-top: 0.5em; padding-bottom: 0.5em; max-width: 100%; border-style: solid none; text-decoration: inherit; border-top-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-top-width: 1px; border-bottom-width: 1px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;p&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;选自&lt;/span&gt;&lt;span&gt;zentralwerkstatt.org&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作者：&lt;strong&gt;&lt;span&gt;Fabian offer&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;机器之心编译&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;编辑：袁铭怿&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;17&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;今年大火的图像合成方向已走过十年。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;2022 年已经接近尾声。&lt;/span&gt;&lt;span&gt;深度学习模型在生成图像方面的表现愈发出色，显然，未来该模型还将继续发展。&lt;/span&gt;&lt;span&gt;今天的局面是如何一步步发展而来的呢？&lt;/span&gt;&lt;span&gt;这得追溯到十年前，也就是当今所说的 “AI 之夏” 的起源。&lt;/span&gt;&lt;span&gt;下文以时间轴的形式追溯了一些里程碑，从论文、架构、模型、数据集到实验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hacker News 评论中有人指出，Hinton 等人的深度信念网早在 2006 年就被用于生成合成 MNIST 数字，参见深度信念网的快速学习算法 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Durk Kingma 让我注意到变分自动编码器 (VAEs) 稍微先于 GANs，参见自动编码变分贝叶斯和这些早期结果在野外标记面部数据集。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Merzmensch 在推特上强调了 DeepDream 的重要性，它可以被视为一种原始生成方法，对于图像合成的艺术方面。参见 inception: 深入神经网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;起源 (2012-2015)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一旦知道深度神经网络将彻底改变图像分类，研究人员就开始朝着 “相反” 的方向探索：&lt;/span&gt;&lt;span&gt;如果可以使用一些能有效分类的技术 (例如卷积层) 来制作图像呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.996078431372549&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SrEA8uteZtDy2Dcs5la3tByuUkjrjwctZSictXH10F9fMCgZfRGRr1RA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;510&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Hello world！这是 GAN 生成的人脸样本，来自 Goodfellow 等人 2014 年的论文。该模型是在 Toronto Faces 数据集上训练的，该数据集已从网络上删除。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2012 年 12 月：&lt;/span&gt;&lt;span&gt;“AI 之夏” 的开始。&lt;/span&gt;&lt;span&gt;Hinton 等人撰写的《ImageNet Classification with Deep Convolutional Neural Networks》一文发布，他们第一次将深度卷积神经网络 (CNN)、GPU 和来自互联网的大型数据集 (ImageNet) 结合在一起。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36627282491944146&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SSBpOXjyL1GAErZhwMkFJN5CbMR4jYmW4v33XgW1m62TMwE6ib9TqM7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;931&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;论文链接：https://proceedings.neurips.cc/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2014 年 12 月：&lt;/span&gt;&lt;span&gt;Ian Goodfellow 等人发表了《Generative Adversarial Nets》。&lt;/span&gt;&lt;span&gt;GAN 是 2012 年之后第一个致力于图像合成而非分析的现代神经网络架构。&lt;/span&gt;&lt;span&gt;它引入了一种基于博弈论的独特学习方法，其中两个子网络 ——“生成器” 和 “鉴别器” 互相竞争。&lt;/span&gt;&lt;span&gt;最终，只有 “生成器” 从系统中保留下来，用于图像合成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3963083604777416&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SBb049gtTFQJGIIEke29CfhQKsicnpMMt4nByBQib9MruibQOe8ic8EwzUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;921&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;论文链接 https://proceedings.neurips.cc/paper/2014/file/5ca3e9b122f61f8f06494c97b1afccf3-Paper.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2015 年 11 月：&lt;/span&gt;&lt;span&gt;《Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks》发表，描述了第一个实际可用的 GAN 体系结构 (DCGAN)，并且首次提出了潜在空间操纵的问题 —— 概念是否映射到潜在空间方向？&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5554335894621295&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SkKChy8ocYX8qiaKkRaFDxfuINdqxcmr5ZNcOvMtcTm2TyeSwHfXbKUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;论文链接：https://arxiv.org/pdf/1511.06434.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;GAN 的五年（2015-2020）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.535031847133758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7ShBg35A1Z7tN160yqbte6gLCvriasu9MibQ47pHSrckKxq070NnLCvX3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;Mario Klingenmann 所作《路人回忆 I》，2018 年。培根式的脸是这一领域 AI 艺术的典型，生成模型的非摄影现实主义是艺术探索的焦点。&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;GAN 可以应用于各种图像处理任务，如风格迁移，图像修复，去噪和超分辨率。&lt;/span&gt;&lt;span&gt;与此同时，GAN 的艺术实验开始兴起，Mike Tyka、Mario Klingenmann、Anna Ridler、Helena Sarin 等人的第一批作品相继出现。&lt;/span&gt;&lt;span&gt;2018 年发生了第一桩 “人工智能艺术” 丑闻 —— 三名法国学生借用一位美国 19 岁高中毕业学生开源的 AI 算法创作的画作在佳士得拍卖行拍得 43 万美元。&lt;/span&gt;&lt;span&gt;与此同时， transformer 架构彻底改变了 NLP，并且在不久的将来对图像合成产生了重大影响。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2017 年 6 月：&lt;/span&gt;&lt;span&gt;文章《Attention is all you need》发表。&lt;/span&gt;&lt;span&gt;transformer 架构 (以 BERT 等预训练模型的形式) 彻底改变了自然语言处理 (NLP) 领域。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5545851528384279&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SGcHuWfexwQtzuJZuibOyYJiaeDCAS60d90QIla6BY2et8e8boXLAUHbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;916&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;论文链接：https://arxiv.org/pdf/1706.03762.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2018 年 7 月：&lt;/span&gt;&lt;span&gt;文章《Conceptual Captions: A Cleaned, Hypernymed, Image Alt-text Dataset For Automatic Image Captioning》发表。&lt;/span&gt;&lt;span&gt;对于后来的 CLIP 和 DALL-E 这样的模型来说，这篇文章和其他多模态数据集将变得至关重要。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3258785942492013&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SHicWk3WVT1TwO4jstxib7qXZT7nn8SOWLbwua8AM1vmb9fQmrvrag7vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;939&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;论文链接：https://aclanthology.org/P18-1238.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0118110236220472&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SicSfe7JkrpoHicibZ9pibTQoKhKBlUv4zqzULvxsqDBX8vJ812wT4hj8FA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;508&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;该面孔来自 thispersondoesnotexist.com 网站。2010 年代后期 GAN 架构的质量主要是在对齐的人脸图像上进行评估，而对于更异构的数据集，其成功程度有限。因此，在学术 / 工业和艺术实验中，人物面孔仍是重要参照依据。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2018 年 - 2020 年：&lt;/span&gt;&lt;span&gt;NVIDIA 研究人员对 GAN 架构进行了一系列重要改进。&lt;/span&gt;&lt;span&gt;GAN 生成的图像第一次做到与自然图像高度相似，至少对于像 Flickr-Faces-HQ (FFHQ) 这样高度优化的数据集来说是如此。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.22380467955239064&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SjZnOJAcxpAavc3X5p9oibrytteu9awY0LDPcXaaiba84Sq9FHsp0PRMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;983&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;论文链接：https://arxiv.org/pdf/1812.04948.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2020 年 12 月：&lt;/span&gt;&lt;span&gt;文章《Taming Transformers for High-Resolution Image Synthesis》发布。&lt;/span&gt;&lt;span&gt;Vision transformer (ViT) 表明，transformer 架构可以用于图像。&lt;/span&gt;&lt;span&gt;本文中提出的方法 ——VQGAN 取得了 SOTA 结果。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5750708215297451&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SGgaE1GvJb00CGM6yPyrqXUaSNouWClvmIic1F7mrYdekjDyQGhUoNeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1059&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;论文链接：https://arxiv.org/pdf/2012.09841.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Transformer 时代（2020-2022）&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Transformer 架构彻底变革了图像合成的方式，GAN 的使用也逐渐开始减少。&lt;/span&gt;&lt;span&gt;「多模态」深度学习巩固了来自 NLP 和计算机视觉的技术，「prompt 工程」取代了模型训练和微调，成为图像合成的新兴方法。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;论文《Learning&lt;/span&gt;&lt;span&gt; transferable visual models from natural language supervision》提出了 CLIP 架构，引入了多模态功能，推动了当前图像合成的热潮。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.221875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SK93588w30br3CoJzuutwjVyCTqzPC8V8ic5ziapYXhU9Pz4MFH4sdpNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;CLIP 是一种结合了视觉 transformer 和正则化 transformer 的多模态模型，学习图像和文本描述的「共享潜在空间」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SIB10uIySIcF4e3hhGMXSibJcoBlibZHkMBiad15fM1ozTN027Zkibuicc2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;论文链接：https://arxiv.org/pdf/2103.00020.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2021 年 1 月，论文《Zero-shot text-to-image generation》发布，其中提出了 DALL-E 的第一个版本。&lt;/span&gt;&lt;span&gt;该模型的原理是在单个数据流中组合文本和图像（被 VAE 压缩为「token」），模型只是简单地「续写句子」。&lt;/span&gt;&lt;span&gt;训练数据（250M 图像）包括来自 Wikipedia、Conceptual Captions 和 YFCM100M (http://projects.dfki.uni-kl.de/yfcc100m/) 的文本 - 图像对。&lt;/span&gt;&lt;span&gt;CLIP 为图像合成的「多模态」方法奠定了基础。&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.21875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SwSn8bicllojp9R60pADcXVhHHtSmb5ice8XqI6o3X0vhgRHAmGCEQZwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;论文链接：https://arxiv.org/pdf/2102.12092.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图是 DALL-E 2 模型的一个生成例子，文本描述是「一个金发女人的肖像照片，用单反相机拍摄，中性背景，高分辨率」。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0196850393700787&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7Sz7pibXVFyHnBpSay6zSmPG5zQG88tT7vIZpK90zHqLuBaNicdYwe4OoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;508&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2021 年 6 月，论文《Diffusion models beat GANs on image synthesis》发表。&lt;/span&gt;&lt;span&gt;扩散模型引入了一种不同于 GAN 的图像合成方法，从噪声中重建图像。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3302752293577982&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7S8zjLwBU1mvrCHY0EaXgpYpU8qyGR0N8GXN2VWekqZrf7Tkx1ReYg3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;论文链接：https://arxiv.org/abs/2105.05233&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2021 年 7 月，DALL-E mini (https://huggingface.co/spaces/dalle-mini/dalle-mini) 发布，它是 DALL-E 的复制版本（比 DALL-E 更小，但对架构和数据的调整很少）。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0096463022508038&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SE9QFb6bUZTrw0hrcAmoicO0HeHTe93DAVXWvLLlbRvY5WtpXVzfEfxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;622&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2022 年 4 月，论文《Hierarchical text-conditional image generation with CLIP latents》提出了以 GLIDE 为基础的 DALL-E 2。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5257352941176471&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SFdVWL1XICHZiberm0TMgmUPCMdGKKvOuc1K15VjME2PRf1yZzXY0eBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1088&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;论文链接：https://arxiv.org/pdf/2204.06125.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2022 年 5 月，论文《Photorealistic text-to-image diffusion models with deep language understanding (https://arxiv.org/pdf/2205.11487.pdf)》提出了 Imagegen 和 Parti，这是谷歌对标 DALL-E 2 的两个模型。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;论文链接：https://arxiv.org/pdf/2206.10789.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Photoshop 一般的人工智能 (2022 至今)&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然 DALL-E 2 为图像模型设置了一个新的标准，但它的商业化限制了模型的创造性。&lt;/span&gt;&lt;span&gt;虽然 DALL-E 2 已经发布，但大部分用户仍在继续使用 DALL-E mini。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而这一切随着 Stable Diffusion 的发布发生了改变，Stable Diffusion 标志着图像合成进入「Photoshop 时代」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2022 年 8 月，Stability.ai 发布了 Stable Diffusion，这个模型可以实现与 DALL-E 2 相同的照片真实感，最重要的是该模型公开可用，并且可以在 CoLab 和 Huggingface 平台上运行。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图是 Stable Diffusion 生成的巴洛克风格的艺术画作：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SvOjvs16Sj77SsKU6wKUGibabCDHuoU6InAibYHls3DZG8uzurxFjwEsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;谷歌也不甘落后，也是在 2022 年 8 月，谷歌发布了一种「个性化」的文本到图像扩散模型 ——DreamBooth。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9Qxp7GYfLAar1N0KFP3S7SkpCkFYFLoN17UMxiamX0ibHaN0o8HRaDEf5YKyhBZtIJ8lKCkfnQAaRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;论文地址：https://arxiv.org/pdf/2208.12242.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2022 年 10 月，全球最大图片交易商 Shutterstock 宣布与 OpenAI 合作，提供 / 授权生成图像，预计图片市场将受到 Stable Diffusion 等生成模型的严重影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;原文链接：https://zentralwerkstatt.org/blog/ten-years-of-image-synthesis&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1234&quot; data-ratio=&quot;2.05078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KmXPKA19gWicnv6pzWGx3l8EdKOGwgXv8JFWPuY5tvqh2s0ibCGVnmwvFljzolEx94Vk7YOWQyQDlw0HMPCphuvQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19.200000762939453&quot;&gt;© THE END &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19.200000762939453&quot;&gt;转载请联系本公众号获得授权&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19.200000762939453&quot;&gt;投稿或寻求报道：content@jiqizhixin.com&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>57a74ed923c419dd2c47800402d48116</guid>
<title>【分布式技术专题】「OSS中间件系列」Minio的Server端服务的架构和实战搭建_洛神灬殇的博客-CSDN博客</title>
<link>https://toutiao.io/k/w6nh4ef</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h3&gt;&lt;a id=&quot;Minio_0&quot;/&gt;Minio的介绍说明&lt;/h3&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;Minio是目前githug上star最多的Object Storage框架，这里Object Storage我目前的理解就是数据存储，minio可以用来搭建分布式存储服务&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;Minio是Apache License v2.0下发布的对象存储服务器。它与Amazon S3云存储服务兼容。它最适合存储非结构化数据，如照片，视频，日志文件，备份和容器/ VM映像。对象的大小可以从几KB到最大5TB。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;Minio服务器足够轻，可以与应用程序堆栈捆绑在一起，类似于NodeJS，Redis和MySQL。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;h3&gt;&lt;a id=&quot;_8&quot;/&gt;注意点：&lt;/h3&gt; 
&lt;p&gt;分布式Minio单租户存在最少4个盘最多16个盘的限制(受限于纠删码)。这种限制确保了Minio的简洁，同时仍拥有伸缩性。如果你需要搭建一个多租户环境，你可以轻松的使用编排工具(Kubernetes)来管理多个Minio实例。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Minio_12&quot;/&gt;Minio的安装指南&lt;/h3&gt; 
&lt;h4&gt;&lt;a id=&quot;Linuxminio_server_14&quot;/&gt;Linux操作系统进行minio server端安装&lt;/h4&gt; 
&lt;h5&gt;&lt;a id=&quot;Minio_16&quot;/&gt;下载Minio的安装包（二进制版本）&lt;/h5&gt; 
&lt;p&gt;先建立个存放minion的文件夹。并进入用wget下载wget https://dl.minio.io/server/minio/release/linux-amd64/minio&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;wget https://dl.min.io/server/minio/release/linux-ppc64le/minio&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;若是以上的下载链接速度较慢，可使用国内的下载链接：http://dl.minio.org.cn/server/minio/release/linux-amd64/minio&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;Minio_24&quot;/&gt;进行授权Minio安装包&lt;/h5&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;接着为下载的minion添加执行权限： chmod +x minio&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h5&gt;&lt;a id=&quot;minion_28&quot;/&gt;启动minion&lt;/h5&gt; 
&lt;pre&gt;&lt;code&gt;./minio server /data/bucket &amp;amp; 
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;(此路径/data/bucket 为存储路径请自行修改)&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;_36&quot;/&gt;用户名和密码（默认）&lt;/h5&gt; 
&lt;p&gt;注意启动显示的 appkey secretkey是默认登录账户，密码&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;AccessKey: minioadmin
SecretKey: minioadmin
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;&lt;a id=&quot;Docker_45&quot;/&gt;Docker版本:&lt;/h4&gt; 
&lt;h5&gt;&lt;a id=&quot;_47&quot;/&gt;拉取官方镜像&lt;/h5&gt; 
&lt;pre&gt;&lt;code&gt;docker pull minio/minio
&lt;/code&gt;&lt;/pre&gt; 
&lt;h5&gt;&lt;a id=&quot;_53&quot;/&gt;运行官方镜像&lt;/h5&gt; 
&lt;pre&gt;&lt;code&gt;docker run -p 9000:9000 -e MINIO_ACCESS_KEY=admin -e MINIO_SECRET_KEY=123123123 -v /data:/data minio/minio server /data
&lt;/code&gt;&lt;/pre&gt; 
&lt;h5&gt;&lt;a id=&quot;_59&quot;/&gt;较为完整命令&lt;/h5&gt; 
&lt;pre&gt;&lt;code&gt;docker run -p 9000:9000 -p 9001:9001 --name minio -d --restart=always -e &quot;MINIO_ACCESS_KEY=用户名&quot; -e &quot;MINIO_SECRET_KEY=密码&quot; -v /data/minio/data:/data -v /data/minio/config:/root/.minio minio/minio server /data --console-address &quot;:9001&quot;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;&lt;a id=&quot;MinIO__65&quot;/&gt;MinIO 分布式集群搭建&lt;/h3&gt; 
 
&lt;h4&gt;&lt;a id=&quot;_71&quot;/&gt;数据保护&lt;/h4&gt; 
 
&lt;p&gt;纠删码是一种恢复丢失和损坏数据的数学算法， Minio 采用 Reed-Solomon code 将对象拆分成 N/2 数据和 N/2 奇偶校验块。 这就意味着如果是 12 块盘，一个对象会被分成 6 个数据块、6 个奇偶校验块，你可以丢失任意 6 块盘（不管其是存放的数据块还是奇偶校验块），你仍可以从剩下的盘中的数据进行恢复。&lt;/p&gt; 
&lt;p&gt;纠删码的工作原理和 RAID 或者复制不同，像 RAID6 可以在损失两块盘的情况下不丢数据，而 Minio 纠删码可以在丢失一半的盘的情况下，仍可以保证数据安全。 而且 Minio 纠删码是作用在对象级别，可以一次恢复一个对象，而RAID 是作用在卷级别，数据恢复时间很长。 Minio 对每个对象单独编码，存储服务一经部署，通常情况下是不需要更换硬盘或者修复。Minio 纠删码的设计目标是为了性能和尽可能的使用硬件加速。&lt;/p&gt; 
&lt;p&gt;位衰减又被称为数据腐化 Data Rot、无声数据损坏 Silent Data Corruption ，是目前硬盘数据的一种严重数据丢失问题。硬盘上的数据可能会神不知鬼不觉就损坏了，也没有什么错误日志。正所谓明枪易躲，暗箭难防，这种背地里犯的错比硬盘直接故障还危险。 所以 Minio 纠删码采用了高速 HighwayHash 基于哈希的校验和来防范位衰减。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;_83&quot;/&gt;高可用&lt;/h4&gt; 
&lt;p&gt;单机 Minio 服务存在单点故障，相反，如果是一个 N 节点的分布式 Minio ,只要有 N/2 节点在线，你的数据就是安全的。不过你需要至少有 N/2+1 个节点来创建新的对象。&lt;/p&gt; 
&lt;p&gt;例如，一个 8 节点的 Minio 集群，每个节点一块盘，就算 4 个节点宕机，这个集群仍然是可读的，不过你需要 5 个节点才能写数据。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;_89&quot;/&gt;限制&lt;/h4&gt; 
&lt;p&gt;分布式 Minio 单租户存在最少 4 个盘最多 16 个盘的限制（受限于纠删码）。这种限制确保了 Minio 的简洁，同时仍拥有伸缩性。如果你需要搭建一个多租户环境，你可以轻松的使用编排工具（Kubernetes）来管理多个Minio实例。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;注意，只要遵守分布式 Minio 的限制，你可以组合不同的节点和每个节点几块盘。比如，你可以使用 2 个节点，每个节点 4 块盘，也可以使用 4 个节点，每个节点两块盘，诸如此类。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;a id=&quot;_95&quot;/&gt;一致性&lt;/h4&gt; 
&lt;p&gt;Minio 在分布式和单机模式下，所有读写操作都严格遵守 read-after-write 一致性模型。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Minio_console_98&quot;/&gt;Minio console控制台登录浏览器&lt;/h3&gt; 
&lt;pre&gt;&lt;code&gt;浏览器输入： http://ip:9001
例如： http://127.0.0.1:9001
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;&lt;a id=&quot;_105&quot;/&gt;忘记密码&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;二进制安装配置文件位置&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;/data/.minio.sys/config&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;docker_111&quot;/&gt;docker安装配置文件位置&lt;/h4&gt; 
&lt;p&gt;看运行容器时是否指定映射文件 –v列：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;-v data:data
/data/.minio.sys/config
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;没有则默认&lt;/p&gt; 
&lt;p&gt;/var/lib/docker/vfs/dir/5d244e01a8e8144cd10cb1db0df559dfce6c3dd70a8ca376b1d5bc7138a62865/.minio.sys/config/ config.json&lt;/p&gt; 
&lt;p&gt;直接修改配置文件中 accessKey secretKey&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;credential&quot;: {
&quot;accessKey&quot;: &quot;wzs&quot;,
&quot;secretKey&quot;: &quot;123123123&quot;,
&quot;expiration&quot;: &quot;1970-01-01T00:00:00Z&quot;,
&quot;status&quot;: &quot;enabled&quot;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;再重新启动便可&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;2_137&quot;/&gt;方案2&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;export MINIO_ACCESS_KEY=accesskey(自行设置)
export MINIO_SECRET_KEY=secretkey(自行设置)
./minio server /data/bucket &amp;amp;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;启动成功之后账号密码就变成您设置的了&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;minio_147&quot;/&gt;下载minio客户端&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;wget https://dl.min.io/client/mc/release/linux-amd64/mc
chmod +x mc
./mc config host add minio http://192.168.8.50:9000 accesskey
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;此命令可以直接复制minio服务启动之后给出的命令。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_158&quot;/&gt;参考资料&lt;/h3&gt; 
&lt;ul&gt;&lt;li&gt;https://docs.min.io/docs/minio-docker-quickstart-guide.html&lt;/li&gt;&lt;li&gt;https://hub.docker.com/r/bitnami/minio&lt;/li&gt;&lt;li&gt;https://zhuanlan.zhihu.com/p/378191644&lt;/li&gt;&lt;/ul&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5f36fca7e73861e22c73f06c5b65824f</guid>
<title>谈谈JS二进制：File、Blob、FileReader、ArrayBuffer、Base64</title>
<link>https://toutiao.io/k/sife4k1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 CUGGZ。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JavaScript 提供了一些 API 来处理文件或原始文件数据，例如：File、Blob、FileReader、ArrayBuffer、base64 等。下面就来看看它们都是如何使用的，它们之间又有何区别和联系！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7078651685393258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBcQECI5aicL7byicfumiaGXWLSFCfHPkalFiccSHWWKOOSFHPpaJ88ic4K2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1958&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Blob&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Blob 全称为 binary large object ，即二进制大对象，它是 JavaScript 中的一个对象，表示原始的类似文件的数据。下面是 MDN 中对 Blob 的解释：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Blob 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream 来用于数据操作。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，Blob 对象是包含有只读原始数据的类文件对象。简单来说，Blob 对象就是一个不可修改的二进制文件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（1）Blob 创建&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用 Blob() 构造函数来创建一个 Blob：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; Blob(array, options);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其有两个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;array&lt;/code&gt;：由 &lt;code&gt;ArrayBuffer&lt;/code&gt;、&lt;code&gt;ArrayBufferView&lt;/code&gt;、&lt;code&gt;Blob&lt;/code&gt;、&lt;code&gt;DOMString&lt;/code&gt; 等对象构成的，将会被放进 &lt;code&gt;Blob&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;options&lt;/code&gt;：可选的 &lt;code&gt;BlobPropertyBag&lt;/code&gt; 字典，它可能会指定如下两个属性&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;type&lt;/code&gt;：默认值为 &quot;&quot;，表示将会被放入到 &lt;code&gt;blob&lt;/code&gt; 中的数组内容的 MIME 类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;endings&lt;/code&gt;：默认值为&quot;&lt;code&gt;transparent&lt;/code&gt;&quot;，用于指定包含行结束符&lt;code&gt;\n&lt;/code&gt;的字符串如何被写入，不常用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的 MIME 类型如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.121593291404612&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjB9DibsGicIP99Q90ric28KNxfRsG6yV4bzia5Lpiclq7Ja3eriaFrdnwMpZsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;954&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看一个简单的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; blob = &lt;span&gt;new&lt;/span&gt; Blob([&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;], {&lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;text/plain&quot;&lt;/span&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里可以成为动态文件创建，其正在创建一个类似文件的对象。这个 blob 对象上有两个属性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;size&lt;/code&gt;：Blob对象中所包含数据的大小（字节）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;type&lt;/code&gt;：字符串，认为该Blob对象所包含的 MIME 类型。如果类型未知，则为空字符串。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看打印结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; blob = &lt;span&gt;new&lt;/span&gt; Blob([&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;], {&lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;text/plain&quot;&lt;/span&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(blob.size); &lt;span&gt;// 11&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(blob.type); &lt;span&gt;// &quot;text/plain&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，字符串&quot;Hello World&quot;是 UTF-8 编码的，因此它的每个字符占用 1 个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到现在，Blob 对象看起来似乎我们还是没有啥用。那该如何使用 Blob 对象呢？可以使用 URL.createObjectURL() 方法将将其转化为一个 URL，并在 Iframe 中加载：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&amp;lt;&lt;span&gt;/iframe&amp;gt;&lt;br/&gt;&lt;br/&gt;const iframe = document.getElementsByTagName(&quot;iframe&quot;)[0];&lt;br/&gt;&lt;br/&gt;const blob = new Blob([&quot;Hello World&quot;], {type: &quot;text/&lt;/span&gt;plain&lt;span&gt;&quot;});&lt;br/&gt;&lt;br/&gt;iframe.src = URL.createObjectURL(blob);&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（2）Blob 分片&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了使用&lt;code&gt;Blob()&lt;/code&gt;构造函数来创建blob 对象之外，还可以从 blob 对象中创建blob，也就是将 blob 对象切片。Blob 对象内置了 slice() 方法用来将 blob 对象分片，其语法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; blob = instanceOfBlob.slice([start [, end [, contentType]]]};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其有三个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;start&lt;/code&gt;：设置切片的起点，即切片开始位置。默认值为 0，这意味着切片应该从第一个字节开始；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;end&lt;/code&gt;：设置切片的结束点，会对该位置之前的数据进行切片。默认值为&lt;code&gt;blob.size&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;contentType&lt;/code&gt;：设置新 blob 的 MIME 类型。如果省略 type，则默认为 blob 的原始值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; iframe = &lt;span&gt;document&lt;/span&gt;.getElementsByTagName(&lt;span&gt;&quot;iframe&quot;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; blob = &lt;span&gt;new&lt;/span&gt; Blob([&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;], {&lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;text/plain&quot;&lt;/span&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; subBlob = blob.slice(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;iframe.src = URL.createObjectURL(subBlob);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时页面会显示&quot;Hello&quot;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. File&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件（File）接口提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。实际上，File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中。Blob 的属性和方法都可以用于 File 对象。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：File 对象中只存在于浏览器环境中，在 Node.js 环境中不存在。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 JavaScript 中，主要有两种方法来获取 File 对象：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 元素上选择文件后返回的 FileList 对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文件拖放操作生成的 &lt;code&gt;DataTransfer&lt;/code&gt; 对象；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（1）input&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先定义一个输入类型为 file 的 &lt;code&gt;input&lt;/code&gt; 标签：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;input type=&lt;span&gt;&quot;file&quot;&lt;/span&gt; id=&lt;span&gt;&quot;fileInput&quot;&lt;/span&gt; multiple=&lt;span&gt;&quot;multiple&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给 &lt;code&gt;input&lt;/code&gt; 标签添加了三个属性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;type=&quot;file&quot;&lt;/code&gt;：指定 &lt;code&gt;input&lt;/code&gt; 的输入类型为文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;id=&quot;fileInput&quot;&lt;/code&gt;：指定 &lt;code&gt;input&lt;/code&gt; 的唯一 id；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;multiple=&quot;multiple&quot;&lt;/code&gt;：指定 &lt;code&gt;input&lt;/code&gt; 可以同时上传多个文件；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来给 &lt;code&gt;input&lt;/code&gt; 标签添加 &lt;code&gt;onchange&lt;/code&gt; 事件，当选择文件并上传之后触发：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileInput = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;fileInput&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;fileInput.onchange = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(e.target.files);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当点击上传文件时，控制台就会输出一个 FileList 数组，这个数组的每个元素都是一个 File 对象，一个上传的文件就对应一个 File 对象：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23852573018080667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBx2B7dlBnCJm4hLulndbtFJV7ksEmxZ8LqgoPoYnTkVzSVbiaHicLXksQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2876&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 &lt;code&gt;File&lt;/code&gt; 对象都包含文件的一些属性，这些属性都继承自 Blob 对象：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;lastModified&lt;/code&gt;：引用文件最后修改日期，为自1970年1月1日0:00以来的毫秒数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;lastModifiedDate&lt;/code&gt;：引用文件的最后修改日期；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;name&lt;/code&gt;：引用文件的文件名；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;size&lt;/code&gt;：引用文件的文件大小；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;type&lt;/code&gt;：文件的媒体类型（MIME）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;webkitRelativePath&lt;/code&gt;：文件的路径或 URL。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，我们在上传文件时，可以通过对比 size 属性来限制文件大小，通过对比 type 来限制上传文件的格式等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（2）文件拖放&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种获取 File 对象的方式就是拖放 API，这个 API 很简单，就是将浏览器之外的文件拖到浏览器窗口中，并将它放在一个成为拖放区域的特殊区域中。拖放区域用于响应放置操作并从放置的项目中提取信息。这些是通过 &lt;code&gt;ondrop&lt;/code&gt; 和 &lt;code&gt;ondragover&lt;/code&gt; 两个 API 实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看一个简单的例子，首先定义一个拖放区域：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;div id=&lt;span&gt;&quot;drop-zone&quot;&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后给这个元素添加 &lt;code&gt;ondragover&lt;/code&gt; 和 &lt;code&gt;ondrop&lt;/code&gt; 事件处理程序：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; dropZone = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;drop-zone&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;dropZone.ondragover = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    e.preventDefault();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;dropZone.ondrop = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    e.preventDefault();&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; files = e.dataTransfer.files;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(files)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里给两个 API 都添加了 &lt;code&gt;e.preventDefault()&lt;/code&gt;，用来阻止默认事件。它是非常重要的，可以用来阻止浏览器的一些默认行为，比如放置文件将显示在浏览器窗口中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当拖放文件到拖放区域时，控制台就会输出一个  FileList 数组，该数组的每一个元素都是一个 &lt;code&gt;File&lt;/code&gt; 对象。这个 FileList 数组是从事件参数的 &lt;code&gt;dataTransfer&lt;/code&gt; 属性的 &lt;code&gt;files&lt;/code&gt; 获取的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46774193548387094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBMZVVUgo40UaMyPKFZOrrHLqgTSMHYFssib4YFLFXzIia8ztEofPetcdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2356&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，这里得到的 &lt;code&gt;File&lt;/code&gt; 对象和通过 &lt;code&gt;input&lt;/code&gt; 标签获得的 &lt;code&gt;File&lt;/code&gt; 对象是完全一样的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. FileReader&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FileReader 是一个异步 API，用于读取文件并提取其内容以供进一步使用。FileReader 可以将 Blob 读取为不同的格式。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：FileReader 仅用于以安全的方式从用户（远程）系统读取文件内容，不能用于从文件系统中按路径名简单地读取文件。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（1）基本使用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用 FileReader 构造函数来创建一个 FileReader 对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个对象常用属性如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;error&lt;/code&gt;：表示在读取文件时发生的错误；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;result&lt;/code&gt;：文件内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;readyState&lt;/code&gt;：表示&lt;code&gt;FileReader&lt;/code&gt;状态的数字。取值如下：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2994652406417112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBDaAbKMiaCHcNOgsLR6entjQHDFPy5jcpJBKaicu0AYFncCKmPicVRQXsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1122&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FileReader 对象提供了以下方法来加载文件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;readAsArrayBuffer()&lt;/code&gt;：读取指定 Blob 中的内容，完成之后，&lt;code&gt;result&lt;/code&gt; 属性中保存的将是被读取文件的 &lt;code&gt;ArrayBuffer&lt;/code&gt; 数据对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;FileReader.readAsBinaryString()&lt;/code&gt;：读取指定 Blob 中的内容，完成之后，&lt;code&gt;result&lt;/code&gt; 属性中将包含所读取文件的原始二进制数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;FileReader.readAsDataURL()&lt;/code&gt;：读取指定 Blob 中的内容，完成之后，&lt;code&gt;result&lt;/code&gt; 属性中将包含一个&lt;code&gt;data: URL&lt;/code&gt; 格式的 Base64 字符串以表示所读取文件的内容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;FileReader.readAsText()&lt;/code&gt;：读取指定 Blob 中的内容，完成之后，&lt;code&gt;result&lt;/code&gt; 属性中将包含一个字符串以表示所读取的文件内容。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，上面这些方法都接受一个要读取的 blob 对象作为参数，读取完之后会将读取的结果放入对象的 &lt;code&gt;result&lt;/code&gt; 属性中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（2）事件处理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FileReader 对象常用的事件如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;abort&lt;/code&gt;：该事件在读取操作被中断时触发；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;error&lt;/code&gt;：该事件在读取操作发生错误时触发；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;load&lt;/code&gt;：该事件在读取操作完成时触发；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;progress&lt;/code&gt;：该事件在读取 Blob 时触发。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这些方法可以加上前置 on 后在HTML元素上使用，比如&lt;code&gt;onload&lt;/code&gt;、&lt;code&gt;onerror&lt;/code&gt;、&lt;code&gt;onabort&lt;/code&gt;、&lt;code&gt;onprogress&lt;/code&gt;。除此之外，由于&lt;code&gt;FileReader&lt;/code&gt;对象继承自&lt;code&gt;EventTarget&lt;/code&gt;，因此还可以使用 &lt;code&gt;addEventListener()&lt;/code&gt; 监听上述事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看一个简单的例子，首先定义一个 &lt;code&gt;input&lt;/code&gt; 输入框用于上传文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;input type=&lt;span&gt;&quot;file&quot;&lt;/span&gt; id=&lt;span&gt;&quot;fileInput&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来定义 &lt;code&gt;input&lt;/code&gt; 标签的 &lt;code&gt;onchange&lt;/code&gt; 事件处理函数和&lt;code&gt;FileReader&lt;/code&gt;对象的&lt;code&gt;onload&lt;/code&gt;事件处理函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileInput = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;fileInput&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;br/&gt;fileInput.onchange = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    reader.readAsText(e.target.files[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;reader.onload = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(e.target.result);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，首先创建了一个 &lt;code&gt;FileReader&lt;/code&gt; 对象，当文件上传成功时，使用 &lt;code&gt;readAsText()&lt;/code&gt; 方法读取 &lt;code&gt;File&lt;/code&gt; 对象，当读取操作完成时打印读取结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用上述例子读取文本文件时，就是比较正常的。如果读取二进制文件，比如png格式的图片，往往会产生乱码，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5066109951287404&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBiaE2mnicVvcib36FADoJuqbgE4rWd7KNnAkU90XIKKyw1kyxVw6VibojHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2874&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那该如何处理这种二进制数据呢？&lt;code&gt;readAsDataURL()&lt;/code&gt; 是一个不错的选择，它可以将读取的文件的内容转换为 base64 数据的 URL 表示。这样，就可以直接将 URL 用在需要源链接的地方，比如 img 标签的 src 属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于上述例子，将 readAsText 方法改为 &lt;code&gt;readAsDataURL()&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileInput = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;fileInput&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;br/&gt;fileInput.onchange = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    reader.readAsDataURL(e.target.files[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;reader.onload = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(e.target.result);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，再次上传二进制图片时，就会在控制台打印一个 base64 编码的 URL，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5152990264255911&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBwp075sRvcDbUEBARehWia3XFevFtrrYyMI7NrVVag4cCv9Ex7B0ibVZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2876&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来修改一下这个例子，将上传的图片通过以上方式显示在页面上：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;input type=&lt;span&gt;&quot;file&quot;&lt;/span&gt; id=&lt;span&gt;&quot;fileInput&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;img&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;preview&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileInput = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;fileInput&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; preview = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;preview&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;br/&gt;fileInput.onchange = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  reader.readAsDataURL(e.target.files[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;reader.onload = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  preview.src = e.target.result;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(e.target.result);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5169014084507042&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBpibytqWcTodGCHmMamLOiaoZFwibZEfUPp2XGVbS2WRC8aOgP7bqK7aAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2840&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当上传大文件时，可以通过 &lt;code&gt;progress&lt;/code&gt; 事件来监控文件的读取进度：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;br/&gt;reader.onprogress = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (e.loaded &amp;amp;&amp;amp; e.total) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; percent = (event.loaded / event.total) * &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`上传进度: &lt;span&gt;${&lt;span&gt;Math&lt;/span&gt;.round(percent)}&lt;/span&gt; %`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;progress&lt;/code&gt; 事件提供了两个属性：&lt;code&gt;loaded&lt;/code&gt;（已读取量）和&lt;code&gt;total&lt;/code&gt;（需读取总量）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. ArrayBuffer&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（1）ArrayBuffer&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ArrayBuffer 对象用来表示通用的、固定长度的&lt;strong&gt;原始二进制数据缓冲区&lt;/strong&gt;。ArrayBuffer 的内容不能直接操作，只能通过 DataView 对象或 TypedArrray 对象来访问。这些对象用于读取和写入缓冲区内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ArrayBuffer 本身就是一个黑盒，不能直接读写所存储的数据，需要借助以下视图对象来读写：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TypedArray&lt;/strong&gt;：用来生成内存的视图，通过9个构造函数，可以生成9种数据格式的视图。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;DataViews&lt;/strong&gt;：用来生成内存的视图，可以自定义格式和字节序。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7084548104956269&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBBT93872GFpMId0yL0wkERib8DQJjZICRn3ljrib8ObXao2ibOVPVtTxibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1029&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypedArray视图和 DataView视图的区别主要是&lt;strong&gt;字节序&lt;/strong&gt;，前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那 ArrayBuffer 与 Blob 有啥区别呢？根据 ArrayBuffer 和 Blob 的特性，Blob 作为一个整体文件，适合用于传输；当需要对二进制数据进行操作时（比如要修改某一段数据时），就可以使用 ArrayBuffer。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看看 ArrayBuffer 有哪些常用的方法和属性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;① new ArrayBuffer()&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ArrayBuffer 可以通过以下方式生成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayBuffer&lt;/span&gt;(bytelength)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ArrayBuffer()&lt;/code&gt;构造函数可以分配指定字节数量的缓冲区，其参数和返回值如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;参数&lt;/strong&gt;：它接受一个参数，即 bytelength，表示要创建数组缓冲区的大小（以字节为单位。）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;返回值&lt;/strong&gt;：返回一个新的指定大小的ArrayBuffer对象，内容初始化为0。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;② ArrayBuffer.prototype.byteLength&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ArrayBuffer 实例上有一个 byteLength 属性，它是一个只读属性，表示 ArrayBuffer 的 byte 的大小，在 ArrayBuffer 构造完成时生成，不可改变。来看例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayBuffer&lt;/span&gt;(&lt;span&gt;16&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(buffer.byteLength);  &lt;span&gt;// 16&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;③ ArrayBuffer.prototype.slice()&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ArrayBuffer 实例上还有一个 slice 方法，该方法可以用来截取 ArrayBuffer 实例，它返回一个新的 ArrayBuffer ，它的内容是这个 ArrayBuffer 的字节副本，从 begin（包括），到 end（不包括）。来看例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayBuffer&lt;/span&gt;(&lt;span&gt;16&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(buffer.slice(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;));  &lt;span&gt;// 16&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里会从 buffer 对象上将前8个字节生成一个新的ArrayBuffer对象。这个方法实际上有两步操作，首先会分配一段指定长度的内存，然后拷贝原来ArrayBuffer对象的置顶部分。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;④ ArrayBuffer.isView()&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ArrayBuffer 上有一个 isView()方法，它的返回值是一个布尔值，如果参数是 ArrayBuffer 的视图实例则返回 true，例如类型数组对象或 DataView 对象；否则返回 false。简单来说，这个方法就是用来判断参数是否是 TypedArray 实例或者 DataView 实例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayBuffer&lt;/span&gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;ArrayBuffer&lt;/span&gt;.isView(buffer)   &lt;span&gt;// false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; view = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Uint32Array&lt;/span&gt;(buffer);&lt;br/&gt;&lt;span&gt;ArrayBuffer&lt;/span&gt;.isView(view)     &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（2）TypedArray&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypedArray 对象一共提供 9 种类型的视图，每一种视图都是一种构造函数。如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;元素&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;类型化数组&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;字节&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Int8&lt;/td&gt;&lt;td&gt;Int8Array&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;8 位有符号整数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Uint8&lt;/td&gt;&lt;td&gt;Uint8Array&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;8 位无符号整数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Uint8C&lt;/td&gt;&lt;td&gt;Uint8ClampedArray&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;8 位无符号整数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Int16&lt;/td&gt;&lt;td&gt;Int16Array&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;16 位有符号整数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Uint16&lt;/td&gt;&lt;td&gt;Uint16Array&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;16 位无符号整数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Int32&lt;/td&gt;&lt;td&gt;Int32Array&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;32 位有符号整数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Uint32&lt;/td&gt;&lt;td&gt;Uint32Array&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;32 位无符号整数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Float32&lt;/td&gt;&lt;td&gt;Float32Array&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;32 位浮点&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Float64&lt;/td&gt;&lt;td&gt;Float64Array&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;64 位浮点&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看看这些都是什么意思：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Uint8Array：&lt;/strong&gt; 将 ArrayBuffer 中的每个字节视为一个整数，可能的值从 0 到 255 （一个字节等于 8 位）。 这样的值称为“8 位无符号整数”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Uint16Array&lt;/strong&gt;：将 ArrayBuffer 中任意两个字节视为一个整数，可能的值从 0 到 65535。 这样的值称为“16 位无符号整数”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Uint32Array：&lt;/strong&gt;将 ArrayBuffer 中任何四个字节视为一个整数，可能值从 0 到 4294967295，这样的值称为“32 位无符号整数”。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些构造函数生成的对象统称为 TypedArray 对象。它们和正常的数组很类似，都有&lt;code&gt;length&lt;/code&gt; 属性，都能用索引获取数组元素，所有数组的方法都可以在类型化数组上面使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那类型化数组和数组有什么区别呢？&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;类型化数组的元素都是连续的，不会为空；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类型化数组的所有成员的类型和格式相同；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类型化数组元素默认值为 0；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类型化数组本质上只是一个视图层，不会存储数据，数据都存储在更底层的 ArrayBuffer 对象中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看看 TypedArray 都有哪些常用的方法和属性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;① new TypedArray()&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypedArray 的语法如下（TypedArray只是一个概念，实际使用的是那9个对象）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Int8Array&lt;/span&gt;(length);&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Int8Array&lt;/span&gt;(typedArray);&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Int8Array&lt;/span&gt;(object);&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Int8Array&lt;/span&gt;(buffer [, byteOffset [, length]]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，TypedArray 有多种用法，下面来分别看一下。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TypedArray(length)&lt;/strong&gt; ：通过分配指定长度内容进行分配&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; view = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Int8Array&lt;/span&gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;view[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;view[&lt;span&gt;10&lt;/span&gt;] = &lt;span&gt;6&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(view);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7779578606158833&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBjvbhdePuMQRqP6Utd6LC6GvSotoErhqtkjYKkzdkP5DXafIHqUkc1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1234&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就生成了一个 16个元素的 Int8Array 数组，除了手动赋值的元素，其他元素的初始值都是 0。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TypedArray(typeArray)&lt;/strong&gt; ：接收一个视图实例作为参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; view = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Int8Array&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Uint8Array&lt;/span&gt;(&lt;span&gt;6&lt;/span&gt;));&lt;br/&gt;view[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;view[&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;6&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(view);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49512987012987014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBTJ7n72mWia8vicclFrDlG5h1iccSNElNkRfdiaJvaic5FrVA1dMpZhJk4Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1232&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TypedArray(object)&lt;/strong&gt; ：参数可以是一个普通数组&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; view = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Int8Array&lt;/span&gt;([&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;]);&lt;br/&gt;view[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;view[&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;6&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(view);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4595879556259905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBQvwyeSQtbOzJpoQr7wr1buJUflke5QOMV87mVgEmtLGhS6KY6g4XEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1262&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意，TypedArray视图会开辟一段新的内存，不会在原数组上建立内存。当然，这里创建的类型化数组也能转换回普通数组：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Array&lt;/span&gt;.prototype.slice.call(view); &lt;span&gt;// [10, 2, 3, 6, 5]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TypeArray(buffer [, byteOffset [, length]])&lt;/strong&gt; ：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式有三个参数，其中第一个参数是一个ArrayBuffer对象；第二个参数是视图开始的字节序号，默认从0开始，可选；第三个参数是视图包含的数据个数，默认直到本段内存区域结束。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayBuffer&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; view1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Int32Array&lt;/span&gt;(buffer); &lt;br/&gt;&lt;span&gt;const&lt;/span&gt; view2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Int32Array&lt;/span&gt;(buffer, &lt;span&gt;4&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(view1, view2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6239737274220033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjB7p2VKK6MNIZAsDsRtFX8v4VdWydZic3locxHRzohOhqbgzMZm36p8sQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;② BYTES_PER_ELEMENT&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每种视图的构造函数都有一个 &lt;code&gt;BYTES_PER_ELEMENT&lt;/code&gt; 属性，表示这种数据类型占据的字节数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Int8Array&lt;/span&gt;.BYTES_PER_ELEMENT &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Uint8Array&lt;/span&gt;.BYTES_PER_ELEMENT &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Int16Array&lt;/span&gt;.BYTES_PER_ELEMENT &lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Uint16Array&lt;/span&gt;.BYTES_PER_ELEMENT &lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Int32Array&lt;/span&gt;.BYTES_PER_ELEMENT &lt;span&gt;// 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Uint32Array&lt;/span&gt;.BYTES_PER_ELEMENT &lt;span&gt;// 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Float32Array&lt;/span&gt;.BYTES_PER_ELEMENT &lt;span&gt;// 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Float64Array&lt;/span&gt;.BYTES_PER_ELEMENT &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;BYTES_PER_ELEMENT&lt;/code&gt; 属性也可以在类型化数组的实例上获取：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayBuffer&lt;/span&gt;(&lt;span&gt;16&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;const&lt;/span&gt; view = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Uint32Array&lt;/span&gt;(buffer); &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;Uint32Array&lt;/span&gt;.BYTES_PER_ELEMENT); &lt;span&gt;// 4&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;③ &lt;strong&gt;TypedArray.prototype.buffer&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypedArray 实例的 buffer 属性会返回内存中对应的 ArrayBuffer对象，只读属性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Uint32Array&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; b = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Int32Array&lt;/span&gt;(a.buffer); &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a, b);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9174603174603174&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBcQ1icc88FA4sRfCAeKjP6khiaqWufjw3mRFTibKcpb6fyOwZsGyhaA7lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;④ TypedArray.prototype.slice()&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypeArray 实例的 slice方法可以返回一个指定位置的新的 TypedArray实例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; view = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Int16Array&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(view.slice(&lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;5&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4174603174603175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBl8pv1icHKibWF5hxKS6a9RecUo0qqu2BuF8n3juwtWRTk3TPKKdjQic0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;⑤ byteLength 和 length&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;byteLength&lt;/code&gt;：返回 TypedArray 占据的内存长度，单位为字节；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;length&lt;/code&gt;：返回 TypedArray 元素个数；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; view = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Int16Array&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;view.length;      &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;view.byteLength;  &lt;span&gt;// 16&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（3）DataView&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完 ArrayBuffer，下面来看看另一种操作 ArrayBuffer 的方式：DataView。&lt;strong&gt;DataView&lt;/strong&gt; 视图是一个可以从 二进制 ArrayBuffer 对象中读写多种数值类型的底层接口，使用它时，不用考虑不同平台的字节序问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;① new DataView()&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DataView视图可以通过构造函数来创建，它的参数是一个ArrayBuffer对象，生成视图。其语法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;DataView&lt;/span&gt;(buffer [, byteOffset [, byteLength]])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其有三个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;buffer&lt;/code&gt;：一个已经存在的 ArrayBuffer 对象，DataView 对象的数据源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;byteOffset&lt;/code&gt;：可选，此 DataView 对象的第一个字节在 buffer 中的字节偏移。如果未指定，则默认从第一个字节开始。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;byteLength&lt;/code&gt;：可选，此 DataView 对象的字节长度。如果未指定，这个视图的长度将匹配 buffer 的长度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayBuffer&lt;/span&gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; view = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;DataView&lt;/span&gt;(buffer);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(view);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8766233766233766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBAQgcSIZ83CaQVmnFC5jj8P2B9bLdnsvd9ic24IAecF01pD8UdnLqHGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;② buffer、byteLength、byteOffset&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DataView 实例有以下常用属性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;buffer&lt;/code&gt;：返回对应的ArrayBuffer对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;byteLength&lt;/code&gt;：返回占据的内存字节长度；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;byteOffset&lt;/code&gt;：返回当前视图从对应的ArrayBuffer对象的哪个字节开始。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayBuffer&lt;/span&gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; view = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;DataView&lt;/span&gt;(buffer);&lt;br/&gt;view.buffer;&lt;br/&gt;view.byteLength;&lt;br/&gt;view.byteOffset;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40836012861736337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBmbzW69HZianteiafuia1gEico1cNj5Iib4TTwF8dJswWW7k5EIF23VcxldQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;③ 读取内存&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DataView 实例提供了以下方法来读取内存，它们的参数都是一个字节序号，表示开始读取的字节位置：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;getInt8：读取1个字节，返回一个8位整数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getUint8：读取1个字节，返回一个无符号的8位整数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getInt16：读取2个字节，返回一个16位整数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getUint16：读取2个字节，返回一个无符号的16位整数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getInt32：读取4个字节，返回一个32位整数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getUint32：读取4个字节，返回一个无符号的32位整数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getFloat32：读取4个字节，返回一个32位浮点数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getFloat64：读取8个字节，返回一个64位浮点数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayBuffer&lt;/span&gt;(&lt;span&gt;24&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; view = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;DataView&lt;/span&gt;(buffer);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 从第1个字节读取一个8位无符号整数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; view1 = view.getUint8(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 从第2个字节读取一个16位无符号整数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; view2 = view.getUint16(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 从第4个字节读取一个16位无符号整数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; view3 = view.getUint16(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;④ 写入内存&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DataView 实例提供了以下方法来写入内存，它们都接受两个参数，第一个参数表示开始写入数据的字节序号，第二个参数为写入的数据：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;setInt8：写入1个字节的8位整数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;setUint8：写入1个字节的8位无符号整数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;setInt16：写入2个字节的16位整数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;setUint16：写入2个字节的16位无符号整数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;setInt32：写入4个字节的32位整数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;setUint32：写入4个字节的32位无符号整数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;setFloat32：写入4个字节的32位浮点数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;setFloat64：写入8个字节的64位浮点数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. Object URL&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Object URL（MDN定义名称）又称Blob URL（W3C定义名称），是HTML5中的新标准。它是一个用来表示File Object 或Blob Object 的URL。在网页中，我们可能会看到过这种形式的 Blob URL：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35768261964735515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjBmvaNyW9DO3dpELEDT9LNKJSPvC6OeakDWv6s8fI7Cfhn3QkxX93TKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 Blob URL/Object URL 是一种伪协议，允许将 Blob 和 File 对象用作图像、二进制数据下载链接等的 URL 源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Blob/File 对象，可以使用 URL构造函数的 &lt;code&gt;createObjectURL()&lt;/code&gt; 方法创建将给出的对象的 URL。这个 URL 对象表示指定的 File 对象或 Blob 对象。我们可以在&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签中或者 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; 标签的 &lt;code&gt;href&lt;/code&gt; 属性中使用这个 URL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看一个简单的例子，首先定义一个文件上传的 input 和一个 图片预览的 img：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;input type=&lt;span&gt;&quot;file&quot;&lt;/span&gt; id=&lt;span&gt;&quot;fileInput&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;img&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;preview&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来使用 &lt;code&gt;URL.createObjectURL()&lt;/code&gt; 将File 对象转化为一个 URL：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileInput = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;fileInput&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; preview = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;preview&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;fileInput.onchange = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  preview.src = URL.createObjectURL(e.target.files[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(preview.src);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，上传的图片转化成了一个 URL，并显示在了屏幕上：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1996370235934664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjB9qia0MSzEmPwaTnQQ7vavMiaPckOBib2F85CDIHJGXoLIbgXx0n2ugtdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2204&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那这个 API 有什么意义呢？可以将Blob/File对象转化为URL，通过这个URL 就可以实现文件下载或者图片显示等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们使用&lt;code&gt;createObjectURL()&lt;/code&gt;方法创建一个data URL 时，就需要使用&lt;code&gt;revokeObjectURL()&lt;/code&gt;方法从内存中清除它来释放内存。虽然浏览器会在文档卸载时自动释放 Data URL，但为了提高性能，我们应该使用&lt;code&gt;revokeObjectURL()&lt;/code&gt;来手动释放它。&lt;code&gt;revokeObjectURL()&lt;/code&gt;方法接受一个Data URL 作为其参数，返回&lt;code&gt;undefined&lt;/code&gt;。下面来看一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; objUrl = URL.createObjectURL(&lt;span&gt;new&lt;/span&gt; File([&lt;span&gt;&quot;&quot;&lt;/span&gt;], &lt;span&gt;&quot;filename&quot;&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(objUrl);&lt;br/&gt;URL.revokeObjectURL(objUrl);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. Base64&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Base64 是一种基于64个可打印字符来表示二进制数据的表示方法。Base64 编码普遍应用于需要通过被设计为处理文本数据的媒介上储存和传输二进制数据而需要编码该二进制数据的场景。这样是为了保证数据的完整并且不用在传输过程中修改这些数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 JavaScript 中，有两个函数被分别用来处理解码和编码 &lt;em&gt;base64&lt;/em&gt; 字符串：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;atob()&lt;/code&gt;：解码，解码一个 Base64 字符串；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;btoa()&lt;/code&gt;：编码，从一个字符串或者二进制数据编码一个 Base64 字符串。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;btoa(&lt;span&gt;&quot;JavaScript&quot;&lt;/span&gt;)       &lt;span&gt;// &#x27;SmF2YVNjcmlwdA==&#x27;&lt;/span&gt;&lt;br/&gt;atob(&lt;span&gt;&#x27;SmF2YVNjcmlwdA==&#x27;&lt;/span&gt;) &lt;span&gt;// &#x27;JavaScript&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那 base64 的实际应用场景有哪些呢？其实多数场景就是基于Data URL的。比如，使用&lt;code&gt;toDataURL()&lt;/code&gt;方法把 canvas 画布内容生成 base64 编码格式的图片：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; canvas = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;canvas&#x27;&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;const&lt;/span&gt; ctx = canvas.getContext(&lt;span&gt;&quot;2d&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; dataUrl = canvas.toDataURL();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还可以使用&lt;code&gt;readAsDataURL()&lt;/code&gt;方法把上传的文件转为base64格式的data URI，比如上传头像展示或者编辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;input type=&lt;span&gt;&quot;file&quot;&lt;/span&gt; id=&lt;span&gt;&quot;fileInput&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;img&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;preview&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileInput = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;fileInput&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; preview = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;preview&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;br/&gt;fileInput.onchange = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  reader.readAsDataURL(e.target.files[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;reader.onload = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  preview.src = e.target.result;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(e.target.result);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效果如下，将图片（二进制数据）转化为可打印的字符，也便于数据的传输：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOaLRWgbtfiafOM84RoleicjB79D4jerx6hW3q3EeWR2lC79s1XqRmdfxwutzkv2V3upd9dGRGFtvMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，一些小的图片都可以使用 base64 格式进行展示，&lt;code&gt;img&lt;/code&gt;标签和&lt;code&gt;background&lt;/code&gt;的 &lt;code&gt;url&lt;/code&gt; 属性都支持使用base64 格式的图片，这样做也可以减少 HTTP 请求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 格式转化&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完这些基本的概念，下面就来看看常用格式之间是如何转换的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（1）ArrayBuffer → blob&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; blob = &lt;span&gt;new&lt;/span&gt; Blob([&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Uint8Array&lt;/span&gt;(buffer, byteOffset, length)]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（2）ArrayBuffer → base64&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; base64 = btoa(&lt;span&gt;String&lt;/span&gt;.fromCharCode.apply(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Uint8Array&lt;/span&gt;(arrayBuffer)));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（3）base64 → blob&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; base64toBlob = &lt;span&gt;(&lt;span&gt;base64Data, contentType, sliceSize&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; byteCharacters = atob(base64Data);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; byteArrays = [];&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; offset = &lt;span&gt;0&lt;/span&gt;; offset &amp;lt; byteCharacters.length; offset += sliceSize) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; slice = byteCharacters.slice(offset, offset + sliceSize);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; byteNumbers = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(slice.length);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; slice.length; i++) {&lt;br/&gt;      byteNumbers[i] = slice.charCodeAt(i);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; byteArray = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Uint8Array&lt;/span&gt;(byteNumbers);&lt;br/&gt;    byteArrays.push(byteArray);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; blob = &lt;span&gt;new&lt;/span&gt; Blob(byteArrays, {&lt;span&gt;type&lt;/span&gt;: contentType});&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; blob;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（4）blob → ArrayBuffer&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;blobToArrayBuffer&lt;/span&gt;(&lt;span&gt;blob&lt;/span&gt;) &lt;/span&gt;{ &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;      reader.onload = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; resolve(reader.result);&lt;br/&gt;      reader.onerror = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; reject;&lt;br/&gt;      reader.readAsArrayBuffer(blob);&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（5）blob → base64&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;blobToBase64&lt;/span&gt;(&lt;span&gt;blob&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;    reader.onloadend = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; resolve(reader.result);&lt;br/&gt;    reader.readAsDataURL(blob);&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;（6）blob → Object URL&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; objectUrl = URL.createObjectURL(blob);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8183d6e09652bc9d5669cce798ae070b</guid>
<title>搜索业务基于Elasticsearch的优化实践</title>
<link>https://toutiao.io/k/evu2xz5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;fieldset&gt;&lt;section data-brushtype=&quot;text&quot;&gt;架构师（JiaGouX）&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;我们都是架构师！&lt;br/&gt;架构未来，你来不来？&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/fieldset&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzAwNjQwNzU2NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RCNb3RYsCgx02T4J55ia2SnemY7uJHsDChxq6jAibbATlIKDgzLxz0zekXWjblzCDcL86AjbMNp02Tg/0?wx_fmt=png&quot; data-nickname=&quot;架构师&quot; data-alias=&quot;JiaGouX&quot; data-signature=&quot;专业架构师，专注高质量架构干货分享。三高架构（高可用、高性能、高稳定）、大数据、机器学习、Java架构、系统架构、分布式架构、人工智能等的架构讨论交流，以及结合互联网技术的架构调整，大规模架构实战分享。欢迎有想法、乐于分享的架构师交流学习。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;186&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;美团外卖搜索工程团队在Elasticsearch的优化实践中，基于Location-Based Service（LBS）业务场景对Elasticsearch的查询性能进行优化。该优化基于Run-Length Encoding（RLE）设计了一款高效的倒排索引结构，使检索耗时（TP99）降低了84%。本文从问题分析、技术选型、优化方案等方面进行阐述，并给出最终灰度验证的结论。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 前言&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 背景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 挑战及问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 技术探索与实践&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.1 倒排链查询优化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.2 倒排链合并&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.3 基于 RLE 的倒排格式设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.4 功能集成&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5. 性能收益&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6. 总结与展望&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7. 作者简介&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8. 参考文献&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 前言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;最近十年，Elasticsearch 已经成为了最受欢迎的开源检索引擎，其作为离线数仓、近线检索、B端检索的经典基建，已沉淀了大量的实践案例及优化总结。然而在高并发、高可用、大数据量的 C 端场景，目前可参考的资料并不多。因此，我们希望通过分享在外卖搜索场景下的优化实践，能为大家提供 Elasticsearch 优化思路上的一些借鉴。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团在外卖搜索业务场景中大规模地使用了 Elasticsearch 作为底层检索引擎。其在过去几年很好地支持了外卖每天十亿以上的检索流量。然而随着供给与数据量的急剧增长，业务检索耗时与 CPU 负载也随之上涨。通过分析我们发现，当前检索的性能热点主要集中在倒排链的检索与合并流程中。针对这个问题，我们基于 Run-length Encoding（&lt;span&gt;RLE&lt;/span&gt;）&lt;sup&gt;[1]&lt;/sup&gt; 技术设计实现了一套高效的倒排索引，使倒排链合并时间（&lt;span&gt;TP99&lt;/span&gt;）降低了 96%。我们将这一索引能力开发成了一款通用插件集成到 Elasticsearch 中，使得 Elasticsearch 的检索链路时延（&lt;/span&gt;&lt;span&gt;TP99&lt;/span&gt;&lt;span&gt;）降低了 84%。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 背景&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;当前，外卖搜索业务检索引擎主要为 Elasticsearch，其业务特点是具有较强的 Location Based Service（&lt;/span&gt;&lt;span&gt;LBS&lt;/span&gt;&lt;span&gt;） 依赖，即用户所能点餐的商家，是由商家配送范围决定的。对于每一个商家的配送范围，大多采用多组电子围栏进行配送距离的圈定，一个商家存在多组电子围栏，并且随着业务的变化会动态选择不同的配送范围，电子围栏示意图如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.559375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUUbRV1cVqTqicZlOle4Eia62LsicdBHKPHDaU80G8t05oZu5OZMibyaFyskj7CPUnAa0kTNtViafib2VnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;span&gt;图1 电子围栏示意图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;考虑到商家配送区域动态变更带来的问题，我们没有使用 Geo Polygon&lt;sup&gt;[2]&lt;/sup&gt; 的方式进行检索，而是通过上游一组 R-tree 服务判定可配送的商家列表来进行外卖搜索。因此，LBS 场景下的一次商品检索，可以转化为如下的一次 Elasticsearch 搜索请求：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;POST food/_search&lt;br/&gt;{&lt;br/&gt;   &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;bool&quot;&lt;/span&gt;: {&lt;br/&gt;         &lt;span&gt;&quot;must&quot;&lt;/span&gt;:{&lt;br/&gt;            &lt;span&gt;&quot;term&quot;&lt;/span&gt;: { &lt;span&gt;&quot;spu_name&quot;&lt;/span&gt;: { &lt;span&gt;&quot;value&quot;&lt;/span&gt;: &lt;span&gt;&quot;烤鸭&quot;&lt;/span&gt;} }&lt;br/&gt;           &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;         },&lt;br/&gt;         &lt;span&gt;&quot;filter&quot;&lt;/span&gt;:{&lt;br/&gt;           &lt;span&gt;&quot;terms&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;wm_poi_id&quot;&lt;/span&gt;: [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;27&lt;/span&gt;,&lt;span&gt;28&lt;/span&gt;,&lt;span&gt;29&lt;/span&gt;,...,&lt;span&gt;37465542&lt;/span&gt;] &lt;span&gt;// 上万&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;         }&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;对于一个通用的检索引擎而言，Terms 检索非常高效，平均到每个 Term 检索不到 0.001 ms。因此在早期时，这一套架构和检索 DSL 可以很好地支持美团的搜索业务——耗时和资源开销尚在接受范围内。然而随着数据和供给的增长，一些供给丰富区域的附近可配送门店可以达到 20000~30000 家，这导致性能与资源问题逐渐凸显。这种万级别的 Terms 检索的性能与耗时已然无法忽略，仅仅这一句检索就需要 5~10 ms。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 挑战及问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;由于 Elasticsearch 在设计上针对海量的索引数据进行优化，在过去的 10 年间，逐步去除了内存支持索引的功能（&lt;/span&gt;&lt;span&gt;例如 RAMDirectory 的删除&lt;/span&gt;&lt;span&gt;）。为了能够实现超大规模候选集的检索，Elasticsearch/Lucene 对 Term 倒排链的查询流程设计了一套内存与磁盘共同处理的方案。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;一次 Terms 检索的流程分为两步：分别检索单个 Term 的倒排链，多个 Term 的倒排链进行合并。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 倒排链查询流程&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从内存中的 Term Index 中获取该 Term 所在的 Block 在磁盘上的位置。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从磁盘中将该 Block 的 TermDictionary 读取进内存。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对倒排链存储格式的进行 Decode，生成可用于合并的倒排链。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;可以看到，这一查询流程非常复杂且耗时，且各个阶段的复杂度都不容忽视。所有的 Term 在索引中有序存储，通过二分查找找到目标 Term。这个有序的 Term 列表就是 TermDictionary ，二分查找 Term 的时间复杂度为 O(logN) ，其中 N 是 Term 的总数量 。Lucene 采用 Finite State Transducer&lt;sup&gt;[3]&lt;/sup&gt;（&lt;/span&gt;&lt;span&gt;FST&lt;/span&gt;&lt;span&gt;）对 TermDictionary 进行编码构建 Term Index。FST 可对 Term 的公共前缀、公共后缀进行拆分保存，大大压缩了 TermDictionary 的体积，提高了内存效率，FST 的检索速度是 O(len(term))，其对于 M 个 Term 的检索复杂度为 O(M * len(term))。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 倒排链合并流程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在经过上述的查询，检索出所有目标 Term 的 Posting List 后，需要对这些 Posting List 求并集（&lt;/span&gt;&lt;span&gt;OR 操作&lt;/span&gt;&lt;span&gt;）。在 Lucene 的开源实现中，其采用 Bitset 作为倒排链合并的容器，然后遍历所有倒排链中的每一个文档，将其加入 DocIdSet 中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;伪代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;Input:  termsEnum: 倒排表；termIterator：候选的term&lt;br/&gt;Output: docIdSet : &lt;span&gt;final&lt;/span&gt; docs set&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; term in termIterator:&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; termsEnum.seekExact(term) != &lt;span&gt;null&lt;/span&gt;:&lt;br/&gt;     docs = read_disk()  &lt;span&gt;// 磁盘读取&lt;/span&gt;&lt;br/&gt;     docs = decode(docs) &lt;span&gt;// 倒排链的decode流程&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;for&lt;/span&gt; doc in docs:&lt;br/&gt;        docIdSet.or(doc) &lt;span&gt;//代码实现为DocIdSetBuilder.add。&lt;/span&gt;&lt;br/&gt;end &lt;span&gt;for&lt;/span&gt;&lt;br/&gt;docIdSet.build()&lt;span&gt;//合并，排序，最终生成DocIdSetBuilder，对应火焰图最后一段。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;假设我们有 M 个 Term，每个 Term 对应倒排链的平均长度为 K，那么合并这 M 个倒排链的时间复杂度为：O(K * M + log(K * M))。可以看出倒排链合并的时间复杂度与 Terms 的数量 M 呈线性相关。在我们的场景下，假设一个商家平均有一千个商品，一次搜索请求需要对一万个商家进行检索，那么最终需要合并一千万个商品，即循环执行一千万次，导致这一问题被放大至无法被忽略的程度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们也针对当前的系统做了大量的调研及分析，通过美团内部的 JVM Profile 系统得到 CPU 的火焰图，可以看到这一流程在 CPU 热点图中的反映也是如此：无论是查询倒排链、还是读取、合并倒排链都相当消耗资源，并且可以预见的是，在供给越来越多的情况下，这三个阶段的耗时还会持续增长。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;158&quot; data-ratio=&quot;0.2825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUUbRV1cVqTqicZlOle4Eia62qLr8ayEc3C6wCx9trAokDkgEp7wyp6ldfRWZcmQvmUNCqs05nFaTlw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2 profile 火焰图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;可以明确，我们需要针对倒排链查询、倒排链合并这两个问题予以优化。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 技术探索与实践&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 倒排链查询优化&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;通常情况下，使用 FST 作为 Term 检索的数据结构，可以在内存开销和计算开销上取得一个很好的平衡，同时支持前缀检索、正则检索等多种多样的检索 Query，然而在我们的场景之下，FST 带来的计算开销无法被忽视。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;考虑到在外卖搜索场景有以下几个特性：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Term 的数据类型为 long 类型。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无范围检索，均为完全匹配。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无前缀匹配、模糊查找的需求，不需要使用前缀树相关的特性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;候选数量可控，每个商家的商品数量较多，即 Term 规模可预期，内存可以承载这个数量级的数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因此在我们的应用场景中使用空间换取时间是值得的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于 Term 查询的热点：可替换 FST 的实现以减少 CPU 开销，常见的查找数据结构中，哈希表有 O(1) 的查询复杂度，将 Term 查找转变为对哈希表的一次查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于哈希表的选取，我们主要选择了常见的 HashMap 和 LongObjectHashMap。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们主要对比了 FST、HashMap 和 LongObjectHashMap（&lt;/span&gt;&lt;span&gt;哈希表的一种高性能实现&lt;/span&gt;&lt;span&gt;）的空间和时间效率。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;在内存占用上&lt;/strong&gt;：FST 的内存效率极佳。而 HashMap/LongObjectHashMap 都有明显的劣势；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;在查询时间上&lt;/strong&gt;：FST 的查询复杂度在 O (len(term))，而 Hash/LongObjectHashMap 有着 O(1) 的查询性能；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;注：检索类型虽然为 Long，但是我们将底层存储格式进行了调整，没有使用开源的 BKD Tree 实现，使用 FST 结构，仅与 FST 进行对比。BKD Tree 在大批量整数 terms 的场景下劣势更为明显。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;我们使用十万个 &amp;lt;Long, Long&amp;gt; 的键值对来构造数据，对其空间及性能进行了对比，结果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3412969283276451&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUUbRV1cVqTqicZlOle4Eia62ZBx7wKxEpUgQKcW37b8trmdhKZJ7m5LfrNNAu1uRcYc3ibLCApBWgEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1172&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到， 在内存占用上 FST 要远优于 LongO&lt;/span&gt;&lt;span&gt;bjectHashMap 和 HashMap。&lt;/span&gt;&lt;span&gt;而在查询速度上 LongObjectHashMap 最优。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们最终选择了 LongObjectHashMap 作为倒排链查询的数据结构。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 倒排链合并&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;基于上述问题，我们需要解决两个明显的 CPU 热点问题：倒排链读取 &amp;amp; 倒排链合并。我们需要选择合适的数据结构缓存倒排链，不再执行磁盘 /page cache 的 IO。数据结构需要必须满足以下条件：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;支持批量 Merge，减少倒排链 Merge 耗时。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;内存占用少，需要处理千万数量级的倒排链。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在给出具体的解决方案之前，先介绍一下 Lucene 对于倒排合并的原生实现、RoaringBitMap、Index Sorting。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.1 原生实现&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;Lucene在不同场景上使用了不同的倒排格式，提高整体的效率（&lt;/span&gt;&lt;span&gt;空间/时间&lt;/span&gt;&lt;span&gt;），通过火焰图可以发现，在我们的场景上，TermInSetQuery 的倒排合并逻辑开销最大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TermInSetQuery 的倒排链合并操作分为两个步骤：倒排链读取和合并。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1. &lt;span&gt;倒排链读取：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Lucene 倒排链压缩存储在索引文件中，倒排链读取需要实时解析，其对外暴露的 API 为迭代器结构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;2. 倒排链合并：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;倒排链合并主要由 DocIdSetBuilder 合并生成倒排链，先使用稀疏结构存储 Doc ID，当  Doc ID 个数超过一定阈值时，升级到稠密结构（&lt;/span&gt;&lt;span&gt;FixedBitSet&lt;/span&gt;&lt;span&gt;）存储，实现方式如下（&lt;/span&gt;&lt;span&gt;对应代码 IntArrayDocIdSet/BitDocIdSet&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;/&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;稀疏数据：存储采用 List&amp;lt;int[]&amp;gt; array 方式存储 Doc ID，最终经过 Merge 和排序形成一个有序数组 int[]，耗时主要集中在数组申请和排序。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;稠密数据：基于 long[] 实现的 bitmap 结构（&lt;/span&gt;&lt;span&gt;FixedBitSet&lt;/span&gt;&lt;span&gt;），耗时主要集中在 FixedBitSet 的插入过程，由于倒排链需要实时 Decode 以及 FixedBitSet 的底层实现，无法实现批量 Merge，只能循环单个 Doc ID 插入，数据量大的情况下，耗时明显。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;我们采用线上流量和数据压测发现该部分平均耗时约 7 ms。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.2 RoaringBitmap&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;当前 Elasticsearch 选择 RoaringBitMap 做为 Query Cache 的底层数据结构缓存倒排链，加快查询速率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RoaringBitmap 是一种压缩的位图，相较于常规的压缩位图能提供更好的压缩，在稀疏数据的场景下空间更有优势。以存放 Integer 为例，Roaring Bitmap 会对存入的数据进行分桶，每个桶都有自己对应的 Container。在存入一个32位的整数时，它会把整数划分为高 16 位和低 16 位，其中高 16 位决定该数据需要被分至哪个桶，我们只需要存储这个数据剩余的低 16 位，将低 16 位存储到 Container 中，若当前桶不存在数据，直接存储 null 节省空间。RoaringBitmap有不同的实现方式，下面以 Lucene 实现（&lt;/span&gt;&lt;span&gt;RoaringDocIdSet&lt;/span&gt;&lt;span&gt;）进行详细讲解：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如原理图中所示，RoaringBitmap 中存在两种不同的 Container：Bitmap Container 和 Array Container。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.40078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUUbRV1cVqTqicZlOle4Eia62OBbAsNoTicRFa81LjWYaoUV1QwQULQdQJmiahtSCxtHbwibnRwxXg07MA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;span&gt;图3 Elasticsearch中Roaringbitmap的示意图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这两种 Container 分别对应不同的数据场景——若一个 Container 中的数据量小于 4096 个时，使用 Array Container 来存储。当 Array Container 中存放的数据量大于 4096 时，Roaring Bitmap 会将 Array Container 转为 Bitmap Container。即 Array Container 用于存放稀疏数据，而 Bitmap Container 用于存放稠密数据，这样做是为了充分利用空间。下图给出了随着容量增长 Array Container 和 Bitmap Container 的空间占用对比图，当元素个数达到 4096 后（&lt;/span&gt;&lt;span&gt;每个元素占用 16 bit &lt;/span&gt;&lt;span&gt;），Array Container 的空间要大于 Bitmap Container。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;备注：Roaring Bitmap 可参考官方博客&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.3 Index Sorting&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;Elasticsearch 从 6.0 版本开始支持 Index Sorting&lt;sup&gt;[5]&lt;/sup&gt; 功能，在索引阶段可以配置多个字段进行排序，调整索引数据组织方式，可以调整文档所对应的 Doc ID。以 city_id，poi_id 为例：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;145&quot; data-ratio=&quot;0.25&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUUbRV1cVqTqicZlOle4Eia62snxWJ3Y90A38eEnBkribZtbW96ycWBbepV5FTkbo70EFVib2RS5fIOZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;span&gt;图4 Index Sorting 示意图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如上示例所示：Index Sorting 会将给定的排序字段（&lt;/span&gt;&lt;span&gt;如上图的 city_id 字段&lt;/span&gt;&lt;span&gt;）的文档排序在一起，相同排序值的文档的 Doc ID 严格自增，对该字段建立倒排，那么其倒排链为自增数列。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3 基于 RLE 的倒排格式设计&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;基于以上的背景知识以及当前 Elasticsearch/Lucene 的解决方案，可以明确目前有 2 个改造点需要考虑。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;合适的倒排结构，用于存储每个 Term 的倒排链。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;合适的中间结构，用于存储多个 Term 合并后的倒排链。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;对于索引倒排格式 PostingsEnum，支持接口为：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DocIdSetIterator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;docID&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;nextDoc&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;advance&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; target)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;倒排仅支持单文档循环调用，不支持批量读取，因此需要为倒排增加批量顺序读取的功能。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;对于多倒排链的合并，由于原结构 DocIdSetBuilder 的实现也不支持批量对数据进行合并，我们探索了评估了 Elasticsearch 用于缓存 Query Cache 的数据结构 RoaringBitMap，然而其实现 RoaringDocIdSet 也无法满足我们对缓存数据结构特性需求，主要问题：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;原生 RoaringDocIdSet 在构建时，只能支持递增的添加 Doc ID。而在实际生产中每一个商家的商品的 Doc ID 都是离散的。这就限制了其使用范围。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;原生 RoaringDocIdSet 的底层存储结构 Bitmap Container 和 Array Container 均不支持批量合并，这就无法满足我们对倒排链合并进行优化的需求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在明确这个问题的场景下，我们可以考虑最简单的改造，支持索引倒排格式 PostingsEnum 的批量读取。并考虑了如下几种场景：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在支持批量读取倒排的情况下，直接使用原结构 DocIdSetBuilder 进行批量的合并。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在支持批量读取倒排的情况下，使用 RoaringBitMap 进行批量合并。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;然而我们发现即使对 bitset 进行分段合并，直接对数据成段进行 OR 操作，整体开销下降并不明显。其原因主要在于：对于读取的批量结果，均为稀疏分布的 Doc ID，仅减少倒排的循环调用无法解决性能开销问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么问题需要转化为如何解决 Doc ID 分布稀疏的问题。在上文提及的 Index Sorting 即一个绝佳的解决方案。并且由于业务 LBS 的特点，一次检索的全部结果集均集中在某个地理位置附近，以及我们检索仅针对门店列表 ID 的特殊场景，我们最终选择对城市 ID、 Geohash、门店 ID 进行排序，从而让稀疏分布的 Doc ID 形成连续分布。在这样的排序规则应用之后，我们得到了一组绝佳的特性：每一个商家所对应的商品，其 Doc ID 完全连续。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3.1 Run-Length Encoding&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;Run-Length Encoding&lt;sup&gt;[3]&lt;/sup&gt;（&lt;/span&gt;&lt;span&gt;RLE&lt;/span&gt;&lt;span&gt;）技术诞生于50年前，最早应用于连续的文本压缩及图像压缩。在 2014 年，第一个开源在 GitHub 的 RoaringBitmap 诞生&lt;sup&gt;[6]&lt;/sup&gt;，2016年，在 RoaringBitMap 的基础上增加了对于自增序列的 RLE 实现&lt;sup&gt;[7]&lt;/sup&gt;，并应用在 bitmap 这一场景上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 bitmap 这一场景之下，主要通过压缩连续区间的稠密数据，节省内存开销。以数组 [1, 2, 3, ..., 59, 60, 89, 90, 91, ..., 99, 100] 为例（&lt;/span&gt;&lt;span&gt;如下图上半部分&lt;/span&gt;&lt;span&gt;）：使用 RLE 编码之后就变为 [1, 60, 89, 12]——形如 [start1, length1, start2, length2, ...] 的形式，其中第一位为连续数字的起始值，第二位为其长度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在数组完全连续场景下中，对 32768 个 id (short) 进行存储，数组存储需要 64 kB，Bitmap 存储需要使用 4 kB，而 RLE 编码后直接存储仅需要 4 byte。在这一特性下，如果商家倒排链完全有序，那么商家的倒排链，可被压缩到最低仅需要两个整数即可表示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然 RLE 并不适用所有情况，在目标序列完全不连续的场景下，如 [1, 3, 5, 7, ... , M]，RLE 编码存储需要使用 2 * M byte的空间，比数组直接存储的空间效率差一倍。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;为了和 Elasticsearch 的实现保持一致，我们决定使用 RoaringBitMap 作为倒排存储的结构，以及中间结果合并的数据结构。针对 RoaringDocIdSet 我们进行了如下改造。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31365313653136534&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUUbRV1cVqTqicZlOle4Eia62yB1ibiaC2CUS9BCapId5ic0GXd9qz5ujW8ERjP8yxS44NDj6V4xcDJUBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;span&gt;图5 倒排链Merge方式的演进&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3.2 RLE Container 的实现&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在对商家 ID 字段开启 Index Sorting 之后，同商家的商品 ID 已经连续分布。那么对于商家字段的倒排链就是严格自增且无空洞的整数序列。我们采用RLE编码对倒排链进行编码存储。由于将倒排链编码为 [start1, length1, start2, length2, ...]，更特殊的，在我们场景下，一个倒排链的表示为  [start, length]，RLE编码做到了对倒排链的极致压缩，假设倒排链为 [1, 2, ...., 1000]， 用 ArrayContainer 存储，内存空间占用为 16 bit * 100 = 200 Byte, RLE 编码存储只需要 16 bit * 2 = 4 Byte。考虑到具体的场景分布，以及其他场景可能存在多段有序倒排的情况，我们最终选择了 [start1, length1, start2, length2, ...] 这样的存储格式，且 [start,  start + length] 之间两两互不重叠。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;对于多个商家的倒排合并流程，对于该格式的合并，我们并不需要对 M 个倒排链长度为 K 进行循环处理，这个问题转变为：如何对多组分段 [start, length] 进行排序，并将排序后的结果合并为一个数组。那么我们将原时间复杂度为 &lt;span&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 10570.3 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4B&quot; d=&quot;M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2263.2, 0)&quot;&gt;&lt;path data-c=&quot;2217&quot; d=&quot;M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2985.4, 0)&quot;&gt;&lt;path data-c=&quot;4D&quot; d=&quot;M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4258.7, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(5258.9, 0)&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(5556.9, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(6041.9, 0)&quot;&gt;&lt;path data-c=&quot;67&quot; d=&quot;M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(6518.9, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(6907.9, 0)&quot;&gt;&lt;path data-c=&quot;4B&quot; d=&quot;M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(8019.1, 0)&quot;&gt;&lt;path data-c=&quot;2217&quot; d=&quot;M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(8741.3, 0)&quot;&gt;&lt;path data-c=&quot;4D&quot; d=&quot;M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(9792.3, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(10181.3, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt; 的合并流程，改造为复杂度为 O(M * logM) 的合并流程，大大降低了合并的计算耗时，减少了 CPU 的消耗。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3.3 SparseRoaringDocIdSet 实现&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;我们在 RoaringDocIdSet 的基础上增加了 RLE Container 后，性能已经得到了明显的提升，加速了 50%，然而依然不符合我们的预期。我们通过对倒排链的数据分析发现：倒排链的平均长度不大，基本在十万内。但是其取值范围广 [ 0, Integer.MAX-1 ]。这些特征说明，如果以 RoaringDocIdSet 按高 16 位进行分桶的话，大部分数据将集中在其中连续的几个桶中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Elasticsearch 场景上，由于无法预估数据分布，RoaringDocIdSet 在申请 bucket 容器的数组时，会根据当前 Segment 中的最大 Doc ID 来申请，计算公式为：(maxDoc + (1 &amp;lt;&amp;lt; 16) -  1) &amp;gt;&amp;gt;&amp;gt; 16。这种方式可以避免每次均按照 Integer.MAX-1 来创建容器带来的无谓开销。然而，当倒排链数量偏少且分布集中时，这种方式依然无法避免大量 bucket 被空置的空间浪费；另一方面，在对倒排链进行合并时，这些空置的 bucket 也会参与到遍历中，即使它被置为了空。这就又造成了性能上的浪费。我们通过压测评估证实了这一推理，即空置的 bucket 在合并时也会占用大量的 CPU 资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这一问题，我们设计了一套用于稀疏数据的方案，实现了 SparseRoaringDocIdSet，同时保持接口与 RoaringDocIdSet 一致，可在各场景下进行复用，其结构如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SparseRoaringDocIdSet&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt;[] index;       &lt;span&gt;// 记录有 container 的 bucket Index&lt;/span&gt;&lt;br/&gt;   Container[] denseSets;  &lt;span&gt;// 记录紧密排列的倒排链&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;保存倒排链的过程与 RoaringDocIDSet 保持一致，在确认具体的 Container 的分桶时，我们额外使用一组索引记录所有有值的 bucket 的 location。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图是一组分别使用 RLE based RoaringDocIdSet 和 SparseRoaringDocIdSet 对 [846710, 100, 936858, 110] 倒排链（&lt;/span&gt;&lt;span&gt;RLE 编码&lt;/span&gt;&lt;span&gt;）进行存储的示意图：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;371&quot; data-ratio=&quot;0.6409001956947162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUUbRV1cVqTqicZlOle4Eia621wtPzNYRAxICycRiaLDOsdllTDPWtoLErNWgvaSR4OS5lzoiaDIU4k9w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1022&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图6 SparseRoaringDocIdSet 编排&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;可以看到：在 SparseRoaringDocIdSet 实现下，所有不为空的 bucket 被紧密的排列在了一起，并在 index [] 中记录了其原始 bucket 的索引，这就避免了大量 bucket 被空置的情况。另外，在进行倒排链的合并时，就可以直接对紧密排列的 denseSet 进行遍历，并从 index [] 获得其对应的原始 bucket location，这就避免了大量的空置 bucket 在合并时带来的性能浪费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们分别对以下4个场景进行了压测：原生的 TermInSetQuery 对倒排链的合并逻辑、基于 FixedBitSet 的批量合并、RLE based  RoaringBitmap、RLE based Dense RoaringBitmap。对 10000 个平均长度为 100 的倒排链进行合并压测，压测结果如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUUbRV1cVqTqicZlOle4Eia62sDsh75RiaqpOjYvLcAhic5j6KYWA2JsJfNDjQuBl43zhWqiaO4jpTbeSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;span&gt;图7 倒排链Merge性能比对&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们实现的 RLE based Dense RoaringBitmap，相比官方的基准实现耗时降低了 96%（&lt;/span&gt;&lt;span&gt;TP99 13 ms 下降至 0.5 ms&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.4 功能集成&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;至此，核心的倒排索引问题已经解决，后续主要为工程问题：如何在 Elasticsearch 系统中集成基于 RLE 的倒排格式。对于高吞吐高并发的C端在线场景，我们希望尽可能保障线上的稳定，对开源数据格式的兼容，保障前向的兼容，做到随时可降级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;工程部分主要分为两部分：倒排索引的集成和在线检索链路。以下主要介绍全量索引部分的链路设计。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.4.1 倒排索引集成&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;倒排索引格式的改造，一般情况下，需要实现一套 PostingsFormat，并实现对应的 Reader、Writer。为了保证对原有检索语句的兼容，支持多种场景的检索，以及为了未来能够无缝的配合 Elasticsearch 的版本升级，我们并没有选择直接实现一组新的 PostingsFormat，避免出现不兼容的情况导致无法升级版本。我们选择了基于现有的倒排格式，在服务加载前后初始化 RLE 倒排，并考虑到业务场景，我们决定将 RLE 倒排全量放入内存中，以达到极致的性能。具体的解决方案为：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;索引加载过程中增加一组 Hook，用于获取现有的 InternalEngine（ &lt;/span&gt;&lt;span&gt;Elasticsearch中负责索引增删改查的主要对象&lt;/span&gt;&lt;span&gt; ）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对所有的 semgents 遍历读取数据，解析倒排数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对所有配置了 RLE 倒排优化的字段，生成 RLE 倒排表。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将 RLE 倒排表与 segment 做关联，保证后续的检索链路中能获取到倒排表。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;为了避免内存泄漏，我们也将索引删除，segment 变更的场景进行了相应的处理。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.4.2 在线检索链路&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在线检索链路也采用了无侵入兼容的实现，我们实现了一套新的检索语句，并且在索引无 RLE 倒排的情况下，可以降级回原生的检索类型，更加安全。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们基于 Elasticsearch 的插件机制，生成一组新的 Query，实现了其 AbstractQueryBuilder，实现对 Query 的解析与改写，并将 Query 与 RLE 倒排进行关联，我们通过改写具体的检索实现，将整个链路集成到 Elasticsearch 中。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 性能收益&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;对于 Elasticsearch 而言，一次检索分为这么几个阶段，可参考下图&lt;sup&gt;[8]&lt;/sup&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUUbRV1cVqTqicZlOle4Eia62J8qqJ06WzMicBIOWdcsmLSVWY7WLX7dbRdrULmWkqtJORMLWIia2OraA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;span&gt;图8 Elasticsearch的检索过程&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;由协调节点进行请求的分发，发送到各个检索节点上。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每个数据节点的各自进行检索，并返回检索结果给协调节点，这一段各个数据节点的耗时即“数据节点查询耗时”。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;协调节点等待所有数据节点的返回，协调节点选取 Top K 后进行 fetch 操作。1～3 步的完整耗时为“完整链路查询耗时”。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;我们将上述改动（&lt;/span&gt;&lt;span&gt;Index Sorting + Dense Roaring Bitmap + RLE&lt;/span&gt;&lt;span&gt;）上线到生产环境的商品索引后，性能如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUUbRV1cVqTqicZlOle4Eia62TocrcljQGkAyDhT73VI5WR1TdMtWaA1wtppJMiad1997LhF3KvTqabQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;span&gt;图9 数据节点查询耗时&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;421&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUUbRV1cVqTqicZlOle4Eia62nUI4zzFvVYI5SeRzDNGvsPhzP1J1XqjXnU8oWVibSkHM4cTmtGp0rUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图10 完整链路查询耗时&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;至此，我们成功将全链路的检索时延（&lt;/span&gt;&lt;span&gt;TP99&lt;/span&gt;&lt;span&gt;）降低了 84%（&lt;/span&gt;&lt;span&gt;100 ms 下降至 16 ms&lt;/span&gt;&lt;span&gt;），解决了外卖搜索的检索耗时问题，并且线上服务的 CPU 也大大降低。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. 总结与展望&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;本文主要针对搜索业务场景中遇到的问题，进行问题分析、技术选型、压测、选择合适的解决方案、集成、灰度验证。我们最终实现了一套基于 RLE 倒排格式，作为一种新型的倒排格式，彻底解决了这个场景上的性能瓶颈，从分析至上线的流程长达数月。本文希望能提供一个思路，让其他同学在遇到 Elasticsearch 相关的性能问题时，也能遵循相同的路径，解决业务上的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般的，我们分析问题可以遵循这样的路径：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;明确性能问题后，首先通过流量录制，获得一个用于后续基准压测的测试集合。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过相关的性能分析工具，先明确是否存在 CPU 的热点或 IO 问题，对于 Java 技术栈，有很多常见的可用于分析性能的工具，美团内部有 Scaple 分析工具，外部可以使用 JProfiler、Java Flight Recorder、Async Profiler、Arthas、perf 这些工具。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对分析火焰图进行分析，配合源代码，进行数据分析和验证。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;此外在 Elasticsearch 中还可以通过 Kibana 的 Search Profiler 用于协助定位问题。在录制大量的流量，抽样分析后，以我们的场景为例，进行 Profiler 后可以明确 TermInSetQuery 占用了一半以上的耗时。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;明确问题后从索引、检索链路两侧进行分析，评估问题，进行多种解决方案的设计与尝试，通过 Java Microbenchmark Harness（&lt;/span&gt;&lt;span&gt;JMH&lt;/span&gt;&lt;span&gt;）代码基准测试工具，验证解决方案的有效性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;集成验证最终效果。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;79&quot; data-ratio=&quot;0.13565022421524664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUUbRV1cVqTqicZlOle4Eia62jmEZxaSZ6eqUyV8yfdxe8R23VjADKU583ZLOLnwuAotbAKjntFZTcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1784&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图11 Kibana中的Search Profiler示例&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们最终实现的关键点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用哈希表来实现索引 Term 的精确查找，以此减少倒排链的查询与读取的时间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;选取 RoaringBitmap 作为存储倒排链的数据结构，并与 RLE Container 相结合，实现对倒排链的压缩存储。当然，最重要的是，RLE 编码将倒排链的合并问题转换成了排序问题，实现了批量合并，从而大幅度减少了合并的性能消耗。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;当然，我们的方案也还具有一些可以继续探索优化的地方。我们进行具体方案开发的时候，主要考虑解决我们特定场景的问题，做了一些定制化，以取得最大的性能收益。在一些更通用的场景上，也可以通过 RLE 倒排获得收益，例如根据数据的分布，自动选择 bitmap/array/RLE 容器，支持倒排链重叠的情况下的数据合并。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在发现也有论文与我们的想法不谋而合，有兴趣了解可以参考具体论文&lt;sup&gt;[9]&lt;/sup&gt;。另外，在增量索引场景下，如果增量索引的变更量非常大，那么势必会遇到频繁更新内存 RLE 倒排的情况，这对内存和性能的消耗都不小，基于性能的考量，也可以直接将 RLE 倒排索引的结构固化到文件中，即在写索引时就完成对倒排链的编码，这样就能避免这一问题。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7. 作者简介&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;泽钰、张聪、晓鹏等，均来自美团到家事业群/搜索推荐技术部-搜索工程团队。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8. 参考文献&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;[1] https://en.wikipedia.org/wiki/Run-length_encoding&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2] https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-geo-polygon-query.html&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;[3] https://en.wikipedia.org/wiki/Finite-state_transducer&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;[4] Frame of Reference and Roaring Bitmaps&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[5] https://www.elastic.co/cn/blog/index-sorting-elasticsearch-6-0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[6] Chambi S, Lemire D, Kaser O, et al. Better bitmap performance with roaring bitmaps[J]. Software: practice and experience, 2016, 46(5): 709-719.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[7] Lemire D, Ssi‐Yan‐Kai G, Kaser O. Consistently faster and smaller compressed bitmaps with roaring[J]. Software: Practice and Experience, 2016, 46(11): 1547-1569.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[8] 检索两阶段流程：https://www.elastic.co/guide/cn/elasticsearch/guide/current/_fetch_phase.html#_fetch_phase&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;[9] Arroyuelo D, González S, Oyarzún M, et al. Document identifier reassignment and run-length-compressed inverted indexes for improved search performance[C]//Proceedings of the 36th international ACM SIGIR conference on Research and development in information retrieval. 2013: 173-182.&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如喜欢本文，请点击右上角，把文章分享到朋友圈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如有想了解学习的技术点，请留言给若飞安排分享&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;因公众号更改推送规则，请点“在看”并加“星标”&lt;span&gt;第一时间获取精彩技术分享&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;·END·&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;/pre&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;23409&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者：泽钰 张聪 晓鹏&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：美团技术团队&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;版权申明：&lt;/span&gt;&lt;span&gt;内容来源网络，仅供分享学习，版权归原创者所有。&lt;/span&gt;&lt;span&gt;除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。&lt;/span&gt;&lt;span&gt;谢谢!&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;article ng-controller=&quot;EntryCtrl&quot; ui-lightbox=&quot;&quot;&gt;&lt;section ng-bind-html=&quot;postContentTrustedHtml&quot;&gt;&lt;section data-id=&quot;702&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;架构师&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;我们都是架构师！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RB58TtkIHwhn4lpsqLnZgian9d5tr1BibP7XpibGTFFib1nq9YuYq209XZUEfCOqMzepDOBbN9KD9wMSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-width=&quot;200px&quot; height=&quot;&quot; opacity=&quot;&quot; title=&quot;&quot; vspace=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;关注&lt;/strong&gt;架构师(JiaGouX)，添加“星标”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;获取每天技术干货，一起成为牛逼架构师&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;技术群请&lt;/strong&gt;&lt;strong&gt;加若飞：&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;1321113940 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;进架构师群&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿、合作、版权等邮箱：&lt;strong&gt;&lt;span&gt;admin@137x.com&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/article&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>