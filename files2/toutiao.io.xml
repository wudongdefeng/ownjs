<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>69cc48b87241ddb3f7ca1ab63f4c0242</guid>
<title>数据驱动测试：从方法探研到最佳实践</title>
<link>https://toutiao.io/k/5m6wicj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;作者：刘红妍&lt;/h2&gt;

&lt;h2&gt;导读&lt;/h2&gt;

&lt;p&gt;在自动化测试实践中，测试数据是制造测试场景的必要条件，本文主要讲述了在沟通自动化框架如何分层，数据如何存储，以及基于单元测试pytest下如何执行。并通过实践案例分享，提供数据驱动测试的具体落地方案。&lt;/p&gt;

&lt;h2&gt;基本概念&lt;/h2&gt;

&lt;p&gt;数据驱动测试（DDT）是一种方法，其中在数据源的帮助下重复执行相同顺序的测试步骤，以便在验证步骤进行时驱动那些步骤的输入值和/或期望值。在数据驱动测试的情况下，环境设置和控制不是硬编码的。换句话说，数据驱动的测试是在框架中构建要与所有相关数据集一起执行的测试脚本，该脚本利用了可重用的测试逻辑。数据驱动的测试提供了可重复性，将测试逻辑与测试数据分离以及减少测试用例数量等优势。&lt;/p&gt;

&lt;h2&gt;设计思路&lt;/h2&gt;

&lt;h3&gt;2.1 测试数据&lt;/h3&gt;

&lt;p&gt;在测试过程中往往需要更加充分地测试场景，而创建数据测试。测试数据包括输入输出，对输出的自动化验证等。创建测试数据，可以通过手动拼装，生产环境拷贝，或通过自动化工具生成。&lt;/p&gt;

&lt;h3&gt;2.2 数据存储&lt;/h3&gt;

&lt;p&gt;数据驱动测试中使用的数据源可以是Excel文件，CSV文件，Yaml文件，数据池，ADO对象或ODBC源。&lt;/p&gt;

&lt;h3&gt;2.3 数据驱动优势&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果应用程序开发还在进行当中，测试者仍然可以进行脚本的编写工作。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;减少了冗余和不必要的测试脚本。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用较少的代码生成测试脚本。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有信息，如输入、输出和预期结果，都以适当的文本记录形式进行存储。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为应用程序的维护提供利了灵活性条件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果功能发生了变化，只需要调整特定的函数脚本。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;实践分享&lt;/h2&gt;

&lt;p&gt;基于Laputa框架现有测试脚本，抽离测试数据与测试逻辑，实现数据驱动测试。&lt;/p&gt;

&lt;p&gt;Laputa框架简介：Laputa框架基于 Pytest 集成了对API接口自动化, 以及对 Web应用, 移动端应用和 Windows 桌面应用 UI 等自动化的能力。具有可视化的Web界面工具, 便于配置执行规则，关联执行脚本， 触发用例执行，查看执行结果。提供CI集成服务，调用Jenkins API跟踪持续集成结果，开放接口，实现流水线自动化测试。&lt;/p&gt;

&lt;h3&gt;3.1 环境依赖&lt;/h3&gt;

&lt;h4&gt;3.2.1 参数化配置方式&lt;/h4&gt;

&lt;p&gt;pytest参数化有两种方式：&lt;/p&gt;

&lt;p&gt;@pytest.fixture(params=[])&lt;/p&gt;

&lt;p&gt;@pytest.mark.parametrize()&lt;/p&gt;

&lt;p&gt;两者都会多次执行使用它的测试函数，但@pytest.mark.parametrize()使用方法更丰富一些，laputa更建议使用后者。&lt;/p&gt;

&lt;h4&gt;3.2.2 用 parametrize 实现参数化&lt;/h4&gt;

&lt;p&gt;parametrize( ) 方法源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【python】
def parametrize(self,argnames, argvalues, indirect=False, ids=None, scope=None):
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;主要参数说明&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（1）argsnames ：参数名，是个字符串，如中间用逗号分隔则表示为多个参数名。&lt;/p&gt;

&lt;p&gt;（2）argsvalues ：参数值，参数组成的列表，列表中有几个元素，就会生成几条用例。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（1）使用 @pytest.mark.paramtrize() 装饰测试方法；&lt;/p&gt;

&lt;p&gt;（2）parametrize(&#x27;data&#x27;, param) 中的 “data” 是自定义的参数名，param 是引入的参数列表；&lt;/p&gt;

&lt;p&gt;（3）将自定义的参数名 data 作为参数传给测试用例 test_func；&lt;/p&gt;

&lt;p&gt;（4）在测试用例内部使用 data 的参数。&lt;/p&gt;

&lt;p&gt;创建测试用例，传入三组参数，每组两个元素，判断每组参数里面表达式和值是否相等，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【python】
@pytest.mark.parametrize(&quot;test_input,expected&quot;,[(&quot;3+5&quot;,8),(&quot;2+5&quot;,7),(&quot;7*5&quot;,30)])
def test_eval(test_input,expected):
    # eval 将字符串str当成有效的表达式来求值，并返回结果
    assert eval(test_input) == expected
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【python】

test_mark_paramize.py::test_eval[3+5-8]test_mark_paramize.py::test_eval[2+5-7] 

test_mark_paramize.py::test_eval[7*5-35]




============================== 3 passed in 0.02s ===============================
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个执行过程中，pytest 将参数列表 (&quot;3+5&quot;,8),(&quot;2+5&quot;,7),(&quot;7*5&quot;,30) 中的三组数据取出来，每组数据生成一条测试用例，并且将每组数据中的两个元素分别赋值到方法中，作为测试方法的参数由测试用例使用。&lt;/p&gt;

&lt;h4&gt;3.2.3 多次使用 parametrize&lt;/h4&gt;

&lt;p&gt;同一个测试用例还可以同时添加多个 @pytest.mark.parametrize 装饰器, 多个 parametrize 的所有元素互相组合（类似笛卡儿乘积），生成大量测试用例。&lt;/p&gt;

&lt;p&gt;场景：比如登录场景，用户名输入情况有 n 种，密码的输入情况有 m 种，希望验证用户名和密码，就会涉及到 n*m 种组合的测试用例，如果把这些数据一一的列出来，工作量也是非常大的。pytest 提供了一种参数化的方式，将多组测试数据自动组合，生成大量的测试用例。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【python】

@pytest.mark.parametrize(&quot;x&quot;,[1,2])@pytest.mark.parametrize(&quot;y&quot;,[8,10,11])

def test_foo(x,y):print(f&quot;测试数据组合x: {x} , y:{y}&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【python】
test_mark_paramize.py::test_foo[8-1] 
test_mark_paramize.py::test_foo[8-2] 
test_mark_paramize.py::test_foo[10-1] 
test_mark_paramize.py::test_foo[10-2] 
test_mark_paramize.py::test_foo[11-1] 
test_mark_paramize.py::test_foo[11-2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析如上运行结果，测试方法 test_foo( ) 添加了两个 @pytest.mark.parametrize() 装饰器，两个装饰器分别提供两个参数值的列表，2 * 3 = 6 种结合，pytest 便会生成 6 条测试用例。在测试中通常使用这种方法是所有变量、所有取值的完全组合，可以实现全面的测试。&lt;/p&gt;

&lt;h4&gt;3.2.4 @pytest.fixture 与 @pytest.mark.parametrize 结合&lt;/h4&gt;

&lt;p&gt;下面讲讲结合 @pytest.fixture 与 @pytest.mark.parametrize 实现参数化。&lt;/p&gt;

&lt;p&gt;如果测试数据需要在 fixture 方法中使用，同时也需要在测试用例中使用，可以在使用 parametrize 的时候添加一个参数 indirect=True，pytest 可以实现将参数传入到 fixture 方法中，也可以在当前的测试用例中使用。&lt;/p&gt;

&lt;p&gt;parametrize 源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【python】
def parametrize(self,argnames, argvalues, indirect=False, ids=None, scope=None):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;indirect 参数设置为 True，pytest 会把 argnames 当作函数去执行，将 argvalues 作为参数传入到 argnames 这个函数里。创建“test_param.py”文件，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【python】
# 方法名作为参数
test_user_data = [&#x27;Tome&#x27;, &#x27;Jerry&#x27;]
@pytest.fixture(scope=&quot;module&quot;)
def login_r(request):
    # 通过request.param获取参数
    user = request.param
    print(f&quot;\n 登录用户：{user}&quot;)return user


@pytest.mark.parametrize(&quot;login_r&quot;, test_user_data,indirect=True)
def test_login(login_r):
    a = login_r
    print(f&quot;测试用例中login的返回值; {a}&quot;)
    assert a != &quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【plain】
登录用户：Tome PASSED            [50%]测试用例中login的返回值; Tome
登录用户：Jerry PASSED           [100%]测试用例中login的返回值; Jerry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的结果可以看出，当 indirect=True 时，会将 login_r 作为参数，test_user_data 被当作参数传入到 login_r 方法中，生成多条测试用例。通过 return 将结果返回，当调用 login_r 可以获取到 login_r 这个方法返回数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afb83b01d9464b2ca44c9629c0498dac%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图1 @pytest.fixture 与 @pytest.mark.parametrize 结合读取数据图例&lt;/p&gt;

&lt;h4&gt;3.2.5 conftest作用域&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;其作用范围是当前目录包括子目录里的测试模块。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（1）如果在测试框架的根目录创建conftest.py文件，文件中的Fixture的作用范围是所有测试模块。&lt;/p&gt;

&lt;p&gt;（2）如果在某个单独的测试文件夹里创建conftest.py文件，文件中Fixture的作用范围，就仅局限于该测试文件夹里的测试模块。&lt;/p&gt;

&lt;p&gt;（3）该测试文件夹外的测试模块，或者该测试文件夹外的测试文件夹，是无法调用到该conftest.py文件中的Fixture。&lt;/p&gt;

&lt;p&gt;（4）如果测试框架的根目录和子包中都有conftest.py文件，并且这两个conftest.py文件中都有一个同名的Fixture，实际生效的是测试框架中子包目录下的conftest.py文件中配置的Fixture。&lt;/p&gt;

&lt;h3&gt;3.3 代码Demo&lt;/h3&gt;

&lt;p&gt;测试数据存储yaml文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【YAML】
测试流程:[
    {&quot;name&quot;:&quot;B2B普货运输三方司机流程&quot;,&quot;senior&quot;:{&quot;createTransJobResource&quot;:&quot;B2B&quot;,&quot;createType&quot;:&quot;三方&quot;,&quot;platformType&quot;:2}},
    {&quot;name&quot;:&quot;B2B普货运输三方司机逆向流程&quot;,&quot;senior&quot;:{&quot;isback&quot;:&quot;True&quot;,&quot;createTransJobResource&quot;:&quot;B2B&quot;,&quot;createType&quot;:&quot;三方&quot;,&quot;platformType&quot;:2}},
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试数据准备，定义统一读取测试数据方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【python】
def dataBuilder(key):dires = path.join(dires, &quot;test_data.yaml&quot;)
    parameters = laputa_util.read_yaml(dires)[key]
    name = []
    senior = []
    for item in parameters:
        name.append(item[&#x27;name&#x27;] if &#x27;name&#x27; in item else &#x27;&#x27;)
        senior.append(item[&#x27;senior&#x27;] if &#x27;senior&#x27; in item else &#x27;&#x27;)
    return name, senior
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试用例标识，通过@pytest.mark.parametrize方法驱动用例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【python】
class TestRegression:
    case, param = dataBuilder(&#x27;测试流程&#x27;)


    @pytest.mark.parametrize(&quot;param&quot;, param, ids=case)
    def test_regression_case(self, param):
        # 调度
        res = create_trans_bill(params)
        trans_job_code = res[&#x27;data&#x27;][&#x27;jobcode&#x27;]
        carrier_type = params[&#x27;createType&#x27;] if params[&#x27;createType&#x27;] in (&#x27;自营&#x27;, &#x27;三方&#x27;) else &#x27;个体&#x27;


        # 执行
        work_info = select_trans_work_info_new(trans_job_code)
        trans_work_code = work_info[&#x27;trans_work_code&#x27;]
        if &#x27;isback&#x27; in params and params[&#x27;isback&#x27;]:
            execute_param.update(isBack=params[&#x27;isback&#x27;])
        execute_bill_core(**execute_param)


        # 结算
        if carrier_type != &#x27;自营&#x27;:
            trans_fee_code = CreateTransFeeBillBase.checkTF(trans_job_code)
    receive_trans_bill_core(**bill_param）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;日常测试过程中，无论是通过手动执行或者脚本执行，都需要利用数据驱动设计思路，这有助于提高测试场景覆盖率，测试用例的健壮性和复用性，及需求测试效率。通过数据驱动测试不仅可以得到更好的投资回报率，还可以达到质效合一的测试流程。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>632d2b3bbec1531a4bb590485b4ee5ca</guid>
<title>Kafka 的消息 key 有啥特殊的？</title>
<link>https://toutiao.io/k/78z6qt4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content post__content clearfix&quot;&gt;
&lt;p&gt;今天看到一篇优质的kafka分享&lt;a href=&quot;https://mp.weixin.qq.com/s/uNq0RSOsTBWxpMYNpsm9gg&quot;&gt;《Kafka 万亿级消息实践之资源组流量掉零故障排查分析
》&lt;/a&gt;，里面有个比较有意思的场景：producer在生产端的消息指定了key属性，在broker节点磁盘故障之后，某topic数据无法正常发送。不仔细深究，第一印象肯定会疑问，不是应该故障后转移吗？咋会一直受影响呢？&lt;/p&gt;
&lt;p&gt;带着这个疑问我们先来看下kafka源码&lt;a href=&quot;https://github.com/a0x8o/kafka/blob/master/clients/src/main/java/org/apache/kafka/clients/producer/ProducerRecord.java#L26&quot;&gt;ProducerRecord.java类的注解&lt;/a&gt;对消息key的作用说明：&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;A key/value pair to be sent to Kafka. This consists of a topic name to which the record is being sent, an optional partition number, and an optional key and value.&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;要发送到 Kafka 的键/值对。这包括被发送记录的&lt;code&gt;主题名称&lt;/code&gt;，&lt;code&gt;可选的分区号&lt;/code&gt;以及&lt;code&gt;可选的k/v&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;If a valid partition number is specified that partition will be used when sending the record. If no partition is specified but a key is present a partition will be chosen using a hash of the key. If neither key nor partition is present a partition will be assigned in a round-robin fashion.&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;如果指定了有效的分区（partition）号，则在发送记录时将使用该分区。如果没有指定分区但存在key属性声明，那么将使用 key 的 hash 值选择分区。如果 key 和 partition 都没有被声明，那么将以轮巡的方式分配分区（partition）。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;The record also has an associated timestamp. If the user did not provide a timestamp, the producer will stamp the record with its current time. The timestamp eventually used by Kafka depends on the timestamp type configured for the topic.&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;记录（record）还有一个关联的时间戳属性。如果用户未提供时间戳，生产者将使用当前时间戳标记该记录。 也就是说，时间戳最终会被kafka应用，其依赖时间戳类型来配置主题（topic）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If the topic is configured to use {@link org.apache.kafka.common.record.TimestampType#CREATE_TIME CreateTime}, the timestamp in the producer record will be used by the broker.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果主题配置为使用 &lt;code&gt;CREATE_TIME&lt;/code&gt;，producer 记录中的时间戳将会被broker应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the topic is configured to use {@link org.apache.kafka.common.record.TimestampType#LOG_APPEND_TIME LogAppendTime}, the timestamp in the producer record will be overwritten by the broker with the broker local time when it appends the message to its log.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果主题配置为使用 &lt;code&gt;LOG_APPEND_TIME&lt;/code&gt;，producer记录中的时间戳将会被broker本地时间覆盖掉，覆盖成以broker本地的时间为准。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;mark&gt;In either of the cases above, the timestamp that has actually been used will be returned to user in {@link RecordMetadata}&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;对于以上两种情况之一，确实已被应用的时间戳将会在&lt;code&gt;RecordMetadata&lt;/code&gt;中返回给用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题到这里基本上清晰了，如果producer消息指定了key，key的hash值将与topic的分区数进行模运算，得出消息路由的分区号。因为该分区所处磁盘故障，消息发送持续等待超时，当批次消息等待超时后，下次进行消息路由时依然会出现路由到故障节点上的情况，且每次等待超时时间后才释放占用的资源。所以若非必要发送消息时不要指定key，否则可能会出现topic所有分区雪崩效应。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里我们提供几种Python版本的send功能实现方式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python3&quot; data-lang=&quot;python3&quot;&gt;&lt;span&gt;from&lt;/span&gt; kafka &lt;span&gt;import&lt;/span&gt; KafkaProducer
&lt;span&gt;from&lt;/span&gt; kafka.errors &lt;span&gt;import&lt;/span&gt; KafkaError

producer &lt;span&gt;=&lt;/span&gt; KafkaProducer(bootstrap_servers&lt;span&gt;=&lt;/span&gt;[&lt;span&gt;&#x27;broker1:9091&#x27;&lt;/span&gt;])

producer&lt;span&gt;.&lt;/span&gt;send(&lt;span&gt;&#x27;my-topic&#x27;&lt;/span&gt;, &lt;span&gt;b&lt;/span&gt;&lt;span&gt;&#x27;raw_bytes&#x27;&lt;/span&gt;)
producer&lt;span&gt;.&lt;/span&gt;send(&lt;span&gt;&#x27;my-topic&#x27;&lt;/span&gt;, key&lt;span&gt;=&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&#x27;foo&#x27;&lt;/span&gt;, value&lt;span&gt;=&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&#x27;bar&#x27;&lt;/span&gt;)
producer&lt;span&gt;.&lt;/span&gt;send(&lt;span&gt;&#x27;my-topic&#x27;&lt;/span&gt;, value&lt;span&gt;=&lt;/span&gt;data, partition&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, timestamp_ms&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&#x27;&#x27;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;最后还有一个疑问什么时候需要设定这个消息key呢&quot;&gt;最后还有一个疑问：什么时候需要设定这个消息key呢？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在一些特殊场景下发送消息的时候指定 key，我们可以用来确定消息写入哪一个分区。你可以使用有明确业务含义的字段作为key，比如用户号，这样就可以保证同一个用户号进入同一个分区。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;/div&gt;



&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>19b5e8c6d73e6a13e7e878653b454325</guid>
<title>理解开源安全中的林纳斯定律</title>
<link>https://toutiao.io/k/n52b4dz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;ruby&gt;林纳斯定律&lt;rt&gt;(Linus&#x27;s Law)&lt;/rt&gt;&lt;/ruby&gt;即“&lt;ruby&gt;只要有足够多的眼睛关注，任何漏洞都无处隐藏&lt;rt&gt;(given enough eyeballs, all bugs are shallow)&lt;/rt&gt;&lt;/ruby&gt;”。那么林纳斯定律是如何应用于开源软件安全的呢？&lt;/p&gt;&lt;p&gt;这篇文章讨论 Linux 对开源软件安全的影响。&lt;/p&gt;&lt;p&gt;开源软件的一个常被赞扬的优点是它的代码能够被任何人审查（安全专家通常称之为“代码审计”）。然而，如果你真的去问很多开源软件用户他们上一次检查代码是什么时候。你大概只能收获他们茫然的眼神或者是喃喃的低语。此外，对于一些相当大型的开源应用，有效地审查每一行代码也是困难的。&lt;/p&gt;&lt;p&gt;根据上述这些稍显不安的事实，我们不得不思考：如果没有人察看这些代码，它是开源还是闭源真的有关系吗？&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1gQMf7FMaP2Hza30Q3xsF6Sz7FVnpc3AYvr5aLIn2KZ3b9onhQmeZnLVcpcbr1m51DeoETmFK59b9R433XJP8MD/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;你应该相信开源吗？&lt;/p&gt;&lt;p&gt;计算机爱好者倾向于作出认为开源软件比其他软件更加安全的传统假设。我们通常不会讨论这意味者什么：比较的基础是什么（比什么“更”安全？），或者上述结论是如何得到的。这是一个危险的陈述，因为它表明只要你将一些东西称之为“开源”，它就自动如魔法般地继承了更高的安全性。这不是开源，事实上，这正是开源安全非常反对的。&lt;/p&gt;&lt;p&gt;除非你已经亲自审计并理解了软件代码，否则就不应该假定一个应用程序是安全的。一但你做到了这一点，就可以给予它 &lt;ruby&gt;终极信任&lt;rt&gt;(ultimate trust)&lt;/rt&gt;&lt;/ruby&gt;。&lt;span&gt;终极信任&lt;/span&gt; 不是对计算机而言的，而是对你本人而言的，至少在这一应用程序被渗透攻击之前，你信任它是因为你选择了相信它是安全的。&lt;/p&gt;&lt;p&gt;使用者本人是唯一可以对软件代码给予终极信任的人，因此任何人想要获得这样的享受都必须亲自审查代码。相信其他人的话是不管用的。&lt;/p&gt;&lt;p&gt;在你已经亲自审计并理解了软件代码之前，你对一个应用程序给予的最大信任度是一个范围，可以是从 &lt;span&gt;根本不信任&lt;/span&gt; 到 &lt;span&gt;相当信任&lt;/span&gt; 之间。然而我们并没有一个关于信任程度的标准对照表，这是一个你必须亲自做出的个人选择。如果你已经从非常信任的人那里听说了一款应用程序是安全的，那么你可能会更信任这个软件，而不是信任那些你没有得到信任建议的东西。&lt;/p&gt;&lt;p&gt;然而，因为无法审计专有（闭源）软件代码，你不可能给予它 &lt;span&gt;终极信任&lt;/span&gt;。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1gQMf7FMaP2Hza30Q3xsF6Sz7FVnpc3AYvr5aLIn2KZ3b9onhQmeZnLVcpcbr1m51DeoETmFK59b9R433XJP8MD/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;林纳斯定律&lt;/p&gt;&lt;p&gt;现实很骨感，并不是每个人都是程序员，同时也不是每个程序员都有时间检查数以万计的代码行。因此如果你没有亲自审查代码，你就只能选择（一定程度上）相信那些 &lt;span&gt;亲自&lt;/span&gt; 审查了代码的人。&lt;/p&gt;&lt;p&gt;那么，有哪些人会审查代码呢？&lt;/p&gt;&lt;p&gt;林纳斯定律声称 &lt;span&gt;只要有足够的眼睛关注，任何漏洞都无处隐藏&lt;/span&gt;，然而我们并不知道多少双眼睛是“足够”的。请不要低估这一数量，应用程序往往经过了远超你想象数量的人员审查。原始开发人员以及后续开发人员显然清楚他们自己写下的代码，不过开源软件往往都是团队成果，开源时间越长，阅读了代码的开发人员越多。新加入的开发人员也必须回顾项目代码的核心部分，因为他们必须学习基础代码以加入新的功能。&lt;/p&gt;&lt;p&gt;同时，为了使开源软件能够在 Linux 发行版上可用，负责开源软件打包分发的开发人员会加入多个项目。有时一个应用程序可能会在不熟悉项目代码的情况下打包，但是大多数时候，开源软件打包人员都是熟悉所打包的项目代码的。这不仅仅是因为他们不想在他们不信任的软件上签名，还由于他们可能不得不修改代码来使得程序能够正确编译。漏洞报告人员和漏洞修复人员一般也是熟悉代码库的，因为他们需要尝试解决小到运行异常，大到程序崩溃的问题。当然，一些漏洞报告人员不是通过亲自审查项目代码，而是通过关注明显未按预期工作的现象，无意中揭示了代码漏洞。系统管理员通常都是通晓用户依赖的重要应用软件的代码的。最后，还有一些安全研究人员，他们专门深入代码内部以揭露潜在的漏洞。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1gQMf7FMaP2Hza30Q3xsF6Sz7FVnpc3AYvr5aLIn2KZ3b9onhQmeZnLVcpcbr1m51DeoETmFK59b9R433XJP8MD/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;信任与透明&lt;/p&gt;&lt;p&gt;很多人先入为主的认为大型软件的审计是基本不可能的，因为它由数以万计的代码行组成。不要被软件运行所需的代码量欺骗了。我们不需要真的阅读数以万计的代码行。代码是高度结构化的，可被利用的代码漏洞仅仅只是其中的一行，不过它通常影响软件的全部功能。&lt;/p&gt;&lt;p&gt;当然，也有例外。有时仅仅一个系统调用或者链接一个有缺陷的库文件就可能引入一系列漏洞。幸运的是，多亏安全研究人员以及漏洞数据库所扮演的积极角色，这些错误相对而言是容易发现的。&lt;/p&gt;&lt;p&gt;一些人指着错误追踪系统，比如 &lt;ruby&gt;&lt;ruby&gt;&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fcve.mitre.org&amp;amp;title=%E9%80%9A%E7%94%A8%E6%BC%8F%E6%B4%9E%E6%8A%AB%E9%9C%B2&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;通用漏洞披露&lt;/a&gt;&lt;rt&gt;🔗 cve.mitre.org&lt;/rt&gt;&lt;/ruby&gt;&lt;rt&gt;(Common Vulnerabilities and Exposures)&lt;/rt&gt;&lt;/ruby&gt;（CVE）网站，并推断开源软件显而易见是不安全的。毕竟已经向公众公开了大量的安全风险，涉及许多开源项目。但是不要被数据欺骗了。只是因为我们看不到现闭源软件的漏洞，并不意味着闭源软件中不存在漏洞。事实上，已经有很多针对闭源软件的漏洞攻击提出了，闭源软件也是存在漏洞的。区别在于开发者（以及用户）可以查看开源软件的 &lt;span&gt;所有的漏洞&lt;/span&gt; 从而降低漏洞的影响。这是扩大对开源软件信任的系统机制的一部分，却正是闭源软件软件所缺少的。&lt;/p&gt;&lt;p&gt;对于任何代码而言，可能永远没有“足够的眼睛”来发现漏洞，但是开发社区越壮大、越多样化，越有机会发现和修复代码中的缺陷。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1gQMf7FMaP2Hza30Q3xsF6Sz7FVnpc3AYvr5aLIn2KZ3b9onhQmeZnLVcpcbr1m51DeoETmFK59b9R433XJP8MD/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;信任与人&lt;/p&gt;&lt;p&gt;在开源社区中，参与同一项目的众多开发者已经发现“不安全”的漏洞，却保持沉默的的可能性是微乎其微的，因为人们很少同意以这样的方式合谋。我们已经看到了在应对 COVID-19 的过程中，人类的行为是如何不一致了，在这里也一样：&lt;/p&gt;&lt;section&gt;&lt;section&gt;◈ 我们都发现了漏洞（病毒）。&lt;/section&gt;&lt;section&gt;◈ 我们知晓如何避免它传播（待在家里）。&lt;/section&gt;&lt;section&gt;◈ 然而病毒还是在持续传播，因为总是有一个或者多个人偏离了消减疫情的计划。&lt;/section&gt;&lt;/section&gt;&lt;p&gt;开源软件中的漏洞也一样，如果有人发现了漏洞总会公之于众（当然，我们说的是“假如”能够发现）。&lt;/p&gt;&lt;p&gt;然而就专有软件而言，有很大可能参与项目的众多开发者即使注意到不安全的漏洞却仍然保持沉默，因为专有模式依赖于薪水。如果一个开发者将漏洞泄漏出来，他可能只是伤害了该专有软件的声誉，进而降低软件的销售额；或者，在更糟糕的情况下，他可能因此而丢了工作。开发人员拿着薪水秘密地研究软件，往往不会谈论其缺陷。如果你曾经是一名开发者，你可能曾经签署过 NDA （LCTT 译注：&lt;ruby&gt;保密协议&lt;rt&gt;(Non-Disclosure Agreement)&lt;/rt&gt;&lt;/ruby&gt;），也被培训过商业秘密的重要性，等等不一而足。专有软件鼓励在面对严重的秘密缺陷时保持沉默，更多时候甚至是强制要求沉默。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1gQMf7FMaP2Hza30Q3xsF6Sz7FVnpc3AYvr5aLIn2KZ3b9onhQmeZnLVcpcbr1m51DeoETmFK59b9R433XJP8MD/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;信任与软件&lt;/p&gt;&lt;p&gt;不要信任未经你审计的软件。&lt;/p&gt;&lt;p&gt;如果你必须相信未经你审计的软件，那么选择相信已经面向那些更有可能将软件缺陷公之于众的开发者公开代码的软件。&lt;/p&gt;&lt;p&gt;开源软件并没有比专有软件继承更高的安全性，但是修复它的系统得到了更好的规划、实施和人员配置。&lt;/p&gt;&lt;section&gt;&lt;hr/&gt;&lt;p&gt;via: &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fopensource.com%2Farticle%2F21%2F2%2Fopen-source-security&amp;amp;title=https%3A%2F%2Fopensource.com%2Farticle%2F21%2F2%2Fopen-source-security&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;https://opensource.com/article/21/2/open-source-security&lt;/a&gt;&lt;/p&gt;&lt;p&gt;作者：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fopensource.com%2Fusers%2Fseth&amp;amp;title=Seth%20Kenlon&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;Seth Kenlon&lt;/a&gt; 选题：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2Flujun9972&amp;amp;title=lujun9972&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;lujun9972&lt;/a&gt; 译者：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2FCanYellow&amp;amp;title=CanYellow&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;CanYellow&lt;/a&gt; 校对：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2Fwxy&amp;amp;title=wxy&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;wxy&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本文由 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2FLCTT%2FTranslateProject&amp;amp;title=LCTT&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Flinux.cn%2F&amp;amp;title=Linux%E4%B8%AD%E5%9B%BD&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1gQMf7FMaP2Hza30Q3xsF6SkKxBoAicqF8icvyVzAcM4uAUYniagXESXrRWRZ7XPokcL72sDGkHpkWtDjiaBanS0DT2/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;512&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;LCTT 译者 ：CanYellow&lt;/section&gt;&lt;section&gt;🌟&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc6icaDzEJGia0mgFI5IyByWbG9X9v7aeYVHvwICNyz4cFxRLRutGWCKEa2QiayIynpdTgibH7iaeem8DP9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;420&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;翻译： &lt;span&gt;1.0&lt;/span&gt; 篇&lt;/section&gt;|&lt;section&gt;贡献： &lt;span&gt;5&lt;/span&gt; 天&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;2022-12-07&lt;/section&gt;&lt;section&gt;→&lt;/section&gt;&lt;section&gt;2022-12-12&lt;/section&gt;&lt;/section&gt;&lt;section&gt;https://linux.cn/lctt/CanYellow&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;欢迎遵照 CC-BY-SA 协议规定转载，&lt;/section&gt;&lt;section&gt;如需转载，请在文章下留言 “&lt;span&gt;转载：公众号名称&lt;/span&gt;”，&lt;/section&gt;&lt;section&gt;我们将为您添加白名单，授权“&lt;span&gt;转载文章时可以修改&lt;/span&gt;”。&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ee1ac56790778d1badd4d47e643c76f</guid>
<title>分布式事务的 6 种解决方案</title>
<link>https://toutiao.io/k/85vwh8y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统、微服务架构大行其道的今天，服务间互相调用出现失败已经成为常态。如何处理异常，如何保证数据一致性，成为微服务设计过程中，绕不开的一个难题。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不同的业务场景下，解决方案会有所差异，常见的方式有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;阻塞式重试；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2PC、3PC 传统事务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用队列，后台异步处理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TCC 补偿事务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地消息表（异步确保）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ 事务。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文侧重于其他几项，关于 2PC、3PC 传统事务，网上资料已经非常多了，这里不多做重复。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;阻塞式重试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务架构中，阻塞式重试是比较常见的一种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;伪代码示例：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;m := db.Insert(sql)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;err := request(B-Service,m)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func request(url string,body interface{}){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for i:=0; i&amp;lt;3; i ++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    result, err = request.POST(url,body)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if err == nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        break &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      log.Print()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上，当请求 B 服务的 API 失败后，发起最多三次重试。如果三次还是失败，就打印日志，继续执行下或向上层抛出错误。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式会带来以下问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;调用 B 服务成功，但由于网络超时原因，当前服务认为其失败了，继续重试，这样 B 服务会产生 2 条一样的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 B 服务失败，由于 B 服务不可用，重试 3 次依然失败，当前服务在前面代码中插入到 DB 的一条记录，就变成了脏数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重试会增加上游对本次调用的延迟，如果下游负载较大，重试会放大下游服务的压力。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个问题：通过让 B 服务的 API 支持幂等性来解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个问题：可以通过后台定时脚步去修正数据，但这并不是一个很好的办法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三个问题：这是通过阻塞式重试提高一致性、可用性，必不可少的牺牲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阻塞式重试适用于业务对一致性要求不敏感的场景下。如果对数据一致性有要求的话，就必须要引入额外的机制来解决。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;异步队列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在解决方案演化的过程中，引入队列是个比较常见也较好的方式。如下示例：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;m := db.Insert(sql)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;err := mq.Publish(&quot;B-Service-topic&quot;,m)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在当前服务将数据写入 DB 后，推送一条消息给 MQ，由独立的服务去消费 MQ 处理业务逻辑。和阻塞式重试相比，虽然 MQ 在稳定性上远高于普通的业务服务，但在推送消息到 MQ 中的调用，还是会有失败的可能性，比如网络问题、当前服务宕机等。这样还是会遇到阻塞式重试相同的问题，即 DB 写入成功了，但推送失败了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理论上来讲，分布式系统下，涉及多个服务调用的代码都存在这样的情况，在长期运行中，调用失败的情况一定会出现。这也是分布式系统设计的难点之一。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC 补偿事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在对事务有要求，且不方便解耦的情况下，TCC 补偿式事务是个较好的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 把调用每个服务都分成 2 个阶段、 3 个操作：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;阶段一、Try 操作：对业务资源做检测、资源预留，比如对库存的检查、预扣。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阶段二、Confirm 操作：提交确认 Try 操作的资源预留。比如把库存预扣更新为扣除。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阶段二、Cancel 操作：Try 操作失败后，释放其预扣的资源。比如把库存预扣的加回去。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 要求每个服务都实现上面 3 个操作的 API，服务接入 TCC 事务前一次调用就完成的操作，现在需要分 2 阶段完成、三次操作来完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如一个商城应用需要调用 A 库存服务、B 金额服务、C 积分服务，如下伪代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;m := db.Insert(sql)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aResult, aErr := A.Try(m)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;bResult, bErr := B.Try(m)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cResult, cErr := C.Try(m)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;if cErr != nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A.Cancel()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    B.Cancel()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; C.Cancel()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A.Confirm()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    B.Confirm()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    C.Confirm()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中分别调用 A、B、C 服务 API 检查并保留资源，都返回成功了再提交确认（Confirm）操作；如果 C 服务 Try 操作失败后，则分别调用 A、B、C 的 Cancel API 释放其保留的资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 在业务上解决了分布式系统下，跨多个服务、跨多个数据库的数据一致性问题。但 TCC 方式依然存在一些问题，实际使用中需要注意，包括上面章节提到的调用失败的情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;空释放&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面代码中如果 C.Try() 是真正调用失败，那下面多余的 C.Cancel() 调用会出现释放并没有锁定资源的行为。这是因为当前服务无法判断调用失败是不是真的锁定 C 资源了。如果不调用，实际上成功了，但由于网络原因返回失败了，这会导致 C 的资源被锁定，一直得不到释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空释放在生产环境经常出现，服务在实现 TCC 事务 API 时，应支持空释放的执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;时序&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面代码中如果 C.Try() 失败，接着调用 C.Cancel() 操作。因为网络原因，有可能会出现 C.Cancel() 请求会先到 C 服务，C.Try() 请求后到，这会导致空释放问题，同时引起 C 的资源被锁定，一直得不到释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 C 服务应拒绝释放资源之后的 Try() 操作。具体实现上，可以用唯一事务ID来区分第一次 Try() 还是释放后的 Try()。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;调用失败&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cancel 、Confirm 在调用过程中，还是会存在失败的情况，比如常见的网络原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cancel() 或 Confirm() 操作失败都会导致资源被锁定，一直得不到释放。这种情况常见解决方案有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;阻塞式重试。但有同样的问题，比如宕机、一直失败的情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写入日志、队列，然后有单独的异步服务自动或人工介入处理。但一样会有问题，写日志或队列时，会存在失败的情况。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理论上来讲非原子性、事务性的二段代码，都会存在中间态，有中间态就会有失败的可能性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本地消息表&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地消息表最初是 ebay 提出的，它让本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来满足事务特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体做法是在本地事务中插入业务数据时，也插入一条消息数据。然后在做后续操作，如果其他操作成功，则删除该消息；如果失败则不删除，异步监听这个消息，不断重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地消息表是一个很好的思路，可以有多种使用方式：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配合MQ&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;示例伪代码：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;messageTx := tc.NewTransaction(&quot;order&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;messageTxSql := tx.TryPlan(&quot;content&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;m,err := db.InsertTx(sql,messageTxSql)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;if err!=nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; return err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aErr := mq.Publish(&quot;B-Service-topic&quot;,m)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;if aErr!=nil { // 推送到 MQ 失败&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; messageTx.Confirm() // 更新消息的状态为 confirm&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; messageTx.Cancel() // 删除消息&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 异步处理 confirm 的消息，继续推送&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func OnMessage(task *Task){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   err := mq.Publish(&quot;B-Service-topic&quot;, task.Value())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   if err==nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     messageTx.Cancel()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面代码中其 messageTxSql 是插入本地消息表的一段 SQL ：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;insert into `tcc_async_task` (`uid`,`name`,`value`,`status`) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;values (&#x27;?&#x27;,&#x27;?&#x27;,&#x27;?&#x27;,&#x27;?&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它和业务 SQL 在同一个事务中去执行，要么成功，要么失败。&lt;/span&gt;&lt;span&gt;这是本地消息表 + 调用其他服务的例子，没有 MQ 的引入。这种使用异步重试，并用本地消息表保障消息的可靠性，解决了阻塞式重试带来的问题，在日常开发中比较常见。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果本地没有要写 DB 的操作，可以只写入本地消息表，同样在&lt;code&gt;OnMessage&lt;/code&gt;中处理：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;messageTx := tc.NewTransaction(&quot;order&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;messageTx := tx.Try(&quot;content&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aErr := request.POST(&quot;B-Service&quot;,body)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// ....&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消息过期&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置本地消息表的&lt;code&gt;Try&lt;/code&gt;和&lt;code&gt;Confirm&lt;/code&gt;消息的处理器：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;TCC.SetTryHandler(OnTryMessage())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;TCC.SetConfirmHandler(OnConfirmMessage())&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在消息处理函数中要判断当前消息任务是否存在过久，比如一直重试了一小时，还是失败，就考虑发邮件、短信、日志告警等方式，让人工介入。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func OnConfirmMessage(task *tcc.Task) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;if time.Now().Sub(task.CreatedAt) &amp;gt; time.Hour {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    err := task.Cancel()  // 删除该消息，停止重试。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   // doSomeThing() 告警，人工介入&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Try&lt;/code&gt;处理函数中，还要单独判断当前消息任务是否存在过短，因为&lt;code&gt;Try&lt;/code&gt;状态的消息，可能才刚刚创建，还没被确认提交或删除。这会和正常业务逻辑的执行重复，意味着成功的调用，也会被重试；为尽量避免这种情况，可以检测消息的创建时间是否很短，短的话可以跳过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重试机制必然依赖下游 API 在业务逻辑上的幂等性，虽然不处理也可行，但设计上还是要尽量避免干扰正常的请求。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;独立消息服务&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;独立消息服务是本地消息表的升级版，把本地消息表抽离成一个独立的服务。所有操作之前先在消息服务添加个消息，后续操作成功则删除消息，失败则提交确认消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后用异步逻辑去监听消息，做对应的处理，和本地消息表的处理逻辑基本一致。但由于向消息服务添加消息，无法和本地操作放到一个事务里，所以会存在添加消息成功，后续失败，则此时的消息就是个无用消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下示例场景：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;err := request.POST(&quot;Message-Service&quot;,body)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;if err!=nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  return err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aErr := request.POST(&quot;B-Service&quot;,body)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;if aErr!=nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  return aErr&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个无用的消息，需要消息服务去确认这个消息是否执行成功，没有则删除，有继续执行后续逻辑。相比本地事务表&lt;code&gt;try&lt;/code&gt;和&lt;code&gt;confirm&lt;/code&gt;，消息服务在前面多了一种状态&lt;code&gt;prepare&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MQ 事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些 MQ 的实现支持事务，比如 RocketMQ 。MQ 的事务可以看作独立消息服务的一种具体实现，逻辑完全一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有操作之前先在 MQ 投递个消息，后续操作成功则&lt;code&gt;Confirm&lt;/code&gt;确认提交消息，失败则&lt;code&gt;Cancel&lt;/code&gt;删除消息。MQ 事务也会存在&lt;code&gt;prepare&lt;/code&gt;状态，需要 MQ 的消费处理逻辑来确认业务是否成功。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从分布式系统实践中来看，要保障数据一致性的场景，必然要引入额外的机制处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 的优点是作用于业务服务层，不依赖某个具体数据库、不与具体框架耦合、资源锁的粒度比较灵活，非常适用于微服务场景下。缺点是每个服务都要实现 3 个 API，对于业务侵入和改动较大，要处理各种失败异常。开发者很难完整处理各种情况，找个成熟的框架可以大大降低成本，比如阿里的 Fescar。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地消息表的优点是简单、不依赖其他服务的改造、可以很好的配合服务调用和 MQ 一起使用，在大多业务场景下都比较实用。缺点是本地数据库多了消息表，和业务表耦合在一起。文中本地消息表方式的示例，来源于作者写的一个库，有兴趣的同学可以参考下 https://github.com/mushroomsir/tcc&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MQ 事务和独立消息服务的优点是抽离出一个公共的服务来解决事务问题，避免每个服务都有消息表和服务耦合在一起，增加服务自身的处理复杂性。缺点是支持事务的 MQ 很少；且每次操作前都先调用 API 添加个消息，会增加整体调用的延迟，在绝大多数正常响应的业务场景下，是一种多余的开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC 参考：https://www.sofastack.tech/blog/seata-tcc-theory-design-realization/&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MQ 事务参考：https://www.jianshu.com/p/eb571e4065ec&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如喜欢本文，请点击右上角，把文章分享到朋友圈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如有想了解学习的技术点，请留言给若飞安排分享&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;·END·&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;/pre&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;23409&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;作者：蘑菇先生&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：www.cnblogs.com/mushroom/p/13788039.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;版权申明：内容来源网络，仅供分享学习，版权归原创者所有。除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。谢谢!&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;article ng-controller=&quot;EntryCtrl&quot; ui-lightbox=&quot;&quot;&gt;&lt;section ng-bind-html=&quot;postContentTrustedHtml&quot;&gt;&lt;section data-id=&quot;702&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;架构师&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;我们都是架构师！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RB58TtkIHwhn4lpsqLnZgian9d5tr1BibP7XpibGTFFib1nq9YuYq209XZUEfCOqMzepDOBbN9KD9wMSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-width=&quot;200px&quot; height=&quot;&quot; opacity=&quot;&quot; title=&quot;&quot; vspace=&quot;0&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;关注&lt;/strong&gt;架构师(JiaGouX)，添加“星标”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;获取每天技术干货，一起成为牛逼架构师&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;技术群请&lt;/strong&gt;&lt;strong&gt;加若飞：&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;1321113940 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;进架构师群&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿、合作、版权等邮箱：&lt;strong&gt;&lt;span&gt;admin@137x.com&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/article&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7ac631114323deafa4106966d6916abc</guid>
<title>ViewBinding 视图绑定</title>
<link>https://toutiao.io/k/14mw8xf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/34joMPibYLIVykibIE7XPOKaMibTYLZoF3FLibayUNZXOxxrMh2fzcIyFgibrBCF2OxFD7ebD9LFsxH38xLWvoUjt5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;凡所有相，皆是虚妄；&lt;/span&gt;&lt;span&gt;若见诸相非相，即见如来。&lt;span&gt;《金刚经》&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;ViewBinding&lt;/strong&gt; &lt;/span&gt;是和 Android Studio 3.6 一起发布的，Gradle 要求 3.6.0+，&lt;strong&gt;&lt;span&gt;ViewBinding&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 可以轻松编写可与视图交互的代码，在模块中启用 &lt;strong&gt;&lt;span&gt;ViewBinding&lt;/span&gt;&lt;/strong&gt; 后，系统会该模块中的每个 XML 布局文件生成一个绑定类。绑定类中会为所有具有 ID 视图生成对应的引用。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;视图绑定功能可以按模块启用。在模块的&lt;span&gt; &lt;strong&gt;build.gradle&lt;/strong&gt; &lt;/span&gt;文件中添加如下配置。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;buildFeatures {viewBinding true}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果需要将某个布局文件禁用 ViewBinding 功能，可以在布局文件根视图添加如下配置：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;LinearLayout &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  tools:viewBindingIgnore=&quot;true&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &amp;lt;/LinearLayout&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为模块启用视图绑定功能后，我们创建的 XML 布局文件会生成一个绑定类。命名规则采用骆驼峰式大小写命名，并在名称末尾添加 &quot;&lt;span&gt;Binding&lt;/span&gt;&quot; 后缀。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如，布局名称假设为 &lt;span&gt;result_profile.xml:&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;LinearLayout ... &amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;TextView android:id=&quot;@+id/name&quot; /&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;ImageView android:cropToPadding=&quot;true&quot; /&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;Button android:id=&quot;@+id/button&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;android:background=&quot;@drawable/rounded_button&quot; /&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/LinearLayout&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;生成的绑定类名为 &lt;span&gt;ResultProfileBinding&lt;/span&gt;。该类具有两个字段：一个是名为name的 TextView，另一个是名为 button 的 Button。该布局中的 ImageView 没有 ID，因此绑定类中不存在对它的引用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每个 Binding类都实现 &lt;span&gt;ViewBinding &lt;/span&gt;接口，并包含一个 &lt;span&gt;getRoot()&lt;/span&gt; 方法，&lt;span&gt;ViewBinding&lt;/span&gt;接口的定义如下：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/** A type which binds the views in a layout XML to fields. */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public interface ViewBinding {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * Returns the outermost {@link View} in the associated layout file. If this binding is for a&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * {@code &amp;lt;merge&amp;gt;} layout, this will return the first view inside of the merge tag.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@NonNull&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;View getRoot();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;getRoot() &lt;/span&gt;方法返回XML的根视图，上述例子 &lt;/span&gt;&lt;span&gt;getRoot()&lt;/span&gt;&lt;span&gt; 方法返回 &lt;/span&gt;&lt;span&gt;LinnerLayout &lt;/span&gt;&lt;span&gt;根视图。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 &lt;strong&gt;Activity &lt;/strong&gt;中使用视图绑定&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 Activity使用，需要在&lt;/span&gt;&lt;span&gt; onCreate()&lt;/span&gt;&lt;span&gt; 方法中执行如下步骤：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 调用绑定类的 &lt;/span&gt;&lt;span&gt;inflate()&lt;/span&gt;&lt;span&gt; 方法。该方法会生成该绑定类的实例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 通过调用上述步骤生成的 Binding类实例的&lt;/span&gt;&lt;span&gt; getRoot() &lt;/span&gt;&lt;span&gt;方法获取根视图的引用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 调用 &lt;/span&gt;&lt;span&gt;setContentView() &lt;/span&gt;&lt;span&gt;方法，将根视图与Activity 绑定。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private ResultProfileBinding binding;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;protected void onCreate(Bundle savedInstanceState) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;super.onCreate(savedInstanceState);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        binding = ResultProfileBinding.inflate(getLayoutInflater());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        View view = binding.getRoot();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        setContentView(view);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在，使用 binding 变量可以直接获取 TextView 类型的 name 视图。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; binding.getName().setText(viewModel.getName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    binding.button.setOnClickListener(new View.OnClickListener() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        viewModel.userClicked()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 &lt;/span&gt;&lt;strong&gt;Fragment &lt;/strong&gt;&lt;span&gt;中使用视图绑定&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在 Fragment 中使用，需要在 &lt;/span&gt;&lt;span&gt;onCreateView() &lt;/span&gt;&lt;span&gt;方法中执行如下步骤：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 调用绑定类的 &lt;/span&gt;&lt;span&gt;inflate()&lt;/span&gt;&lt;span&gt; 方法。该方法会生成该绑定类的实例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 通过调用上述步骤生成的 Binding类实例的&lt;/span&gt;&lt;span&gt; getRoot() &lt;/span&gt;&lt;span&gt;方法获取根视图的引用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 从&lt;/span&gt;&lt;span&gt; onCreateView() &lt;/span&gt;&lt;span&gt;方法返回根视图，以供 Fragment 使用。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; private ResultProfileBinding binding;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public View onCreateView (LayoutInflater inflater,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                              ViewGroup container,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                              Bundle savedInstanceState) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        binding = ResultProfileBinding.inflate(inflater, container, false);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        View view = binding.getRoot();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return view;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void onDestroyView() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onDestroyView();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        binding = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>