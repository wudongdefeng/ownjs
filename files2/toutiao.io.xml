<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f65145ee9b85a0db7d73dcd1e1ba48a5</guid>
<title>软件架构可视化及 C4 模型：架构设计不仅仅是 UML</title>
<link>https://toutiao.io/k/6fx50ha</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;软件系统架构设计的目标不在于设计本身，而在于&lt;strong&gt;架构设计意图的传达&lt;/strong&gt;。图形化有助于在团队间进行高效的信息同步，但不同的图形化方式需要&lt;strong&gt;语义一致性和效率间实现平衡&lt;/strong&gt;。C4模型通过不同的抽象层级来表达系统的静态结构，并提供了最小集的抽象建模元素，为设计人员提供了一种低认知负载、易于学习和使用的高效建模方式。&lt;/p&gt;

&lt;hr/&gt;

&lt;h1&gt;&lt;strong&gt;1 为什么要进行架构可视化？&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;软件系统架构设计的目标不在于设计本身，而在于架构设计意图的传达。如果不能清晰、一致的在干系人间进行设计意图的同步，即使再好的设计也只是空中楼阁。软件架构设计本质上也是一种抽象和建模的过程（对模型和抽象的本质参考文章《 &lt;a href=&quot;http://jagile.jd.com/shendeng/article/detail/4239?forumId=79&amp;amp;jdme_router=jdme%3A%2F%2Fweb%2F202206081297%3Furl%3Dhttps%3A%2F%2Fshendengh5.jd.com%2FarticleDetail%3Fid%3D4239&quot;&gt;领域驱动设计开篇&lt;/a&gt;  》），软件架构设计模型的表达有多种方式：图形化、语言和文字。绝大部分场景下，&lt;strong&gt;图形化在架构设计的表现力层面效果更佳&lt;/strong&gt;。因此，对于软件系统架构进行可视化表达是有价值，且是必要的。&lt;/p&gt;

&lt;p&gt;软件架构可视化的方式有多种，不同的团队有不同的实践方式，最为常见的由如下几种：&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;线框图&lt;/strong&gt;：通过线框图和连线表达架构元素及之间的关系&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;UML&lt;/strong&gt;：统一建模语言，表达系统的静态结构和动态行为&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;草图&lt;/strong&gt;：非正式的图形&lt;/p&gt;

&lt;p&gt;不同的可视化方式各有优劣，以下部分将对不同的表现形式进行说明&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;1.1 可视化方式-线框图&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;线框图是最为通用的可视化表达方式之一，架构师或设计人员大量的架构图，比如技术架构、功能架构、数据架构、逻辑架构等等都通过线框图的形式表达。该种可视化方式的优势是：&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;建模工具多样化&lt;/strong&gt;：你可以基于Viso、Drawio、PPT等任何一款支持线框图的软件进行建模工作&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;学习成本低&lt;/strong&gt;：设计人员几乎不需要进行专门的建模语言以及建模工具的学习，门槛较低&lt;/p&gt;

&lt;p&gt;但，基于线框图表达软件系统架构存在的问题也非常明显：&lt;strong&gt;语义的一致性问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你可能自己画过很多软件系统架构图，也可能参与评审过其他团队的架构图，我相信，对你而言并不是的所有的图都是“&lt;strong&gt;清晰且易于理解的&lt;/strong&gt;”。举个简单的场景，如果我们在百度搜索 “架构图” ，你可能得到以下结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-056cpO10cLGjYc79tl.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;各式各样的 “架构图”&lt;/strong&gt;：不同形状和颜色的图形元素、不同形状和颜色的连线、不同的意图。&lt;/p&gt;

&lt;p&gt;我们可以看出：&lt;strong&gt;线框图虽然简单，但其其图形化的语义一致性是大问题&lt;/strong&gt;。虽然都是通过线框表达软件系统架构，但不同的人可能使用不同的元素、不同的颜色、不同的连线和分层等等，线框自由表达的灵活性和图形化语义的一致性存在潜在冲突，最终都会阻碍架构设计意图传达。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;1.2 可视化方式-UML&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;UML是统一建模语言，相比于线框图而言，其优势是在软件建模层面&lt;strong&gt;提供了一致性的建模元语言&lt;/strong&gt;。简单来说，UML提供了大家达成一致的（UML支持扩展的场景除外）建模元素。如果团队成员比较熟悉UML，那么通过UML表达的系统架构图天然具有认知一致性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;丰富灵活的建模元语言在提升语义一致性的同时，也必然会导致复杂性的上升&lt;/strong&gt;。掌握UML具有一定的学习成本，而熟练的应用对研发人员也提出了更高的要求。基于 Simon Brown给出的数据，实际情况只有少数团队真正使用UML。不论是UML的复杂度和学习成本原因，还是敏捷化下对UML的排斥，很多团队都放弃了UML。&lt;/p&gt;

&lt;p&gt;我们不能否认UML的价值，基于统一建模语言能够更有效的进行架构设计的信息传递和沟通，也能基于UML提供的详细的模型图元素进行充分的设计表达。团队中是否要基于UML进行沟通需要权衡，虽然UML不能表达你所要传达的全部的架构信息，但其在某些维度的表达相对比较适合。&lt;/p&gt;

&lt;p&gt;• 表达流程和工作流可以采用UML活动图&lt;/p&gt;

&lt;p&gt;• 表达运行时的交互可以采用UML时序图&lt;/p&gt;

&lt;p&gt;• 表达领域模型或者设计模式可以采用UML类图&lt;/p&gt;

&lt;p&gt;• 表达状态转换可以采用UML状态机&lt;/p&gt;

&lt;p&gt;• 表达系统的部署结构可以使用UML部署图&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;1.3 可视化方式-草图&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;架构可视化另一个非常常见的方式是：&lt;strong&gt;草图&lt;/strong&gt;。草图是一种&lt;strong&gt;非正式的、易于快速沟通&lt;/strong&gt;的图形化方式。团队基于特定的场景，可以通过草图的形式进行快速的沟通，以便高效的在干系人间拉齐关键信息。&lt;/p&gt;

&lt;p&gt;但，草图的劣势与线框图一样：&lt;strong&gt;语义一致性低&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们可以在白板上 “&lt;strong&gt;随心所欲&lt;/strong&gt;” 的画各式各样的草图，草图上的元素、连线，又或者布局都可能是&lt;strong&gt;涌现式的、临时性的&lt;/strong&gt;，这些&lt;strong&gt;草图的价值在于 “会话周期内的高效沟通”&lt;/strong&gt;。如果干系人没有完全参与到草图的讨论，又或是后置查看，大概也很难精准捕获这些草图所要表达的设计意图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-17nXf17YCXOv7wS0kg.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;2 C4 模型&lt;/strong&gt;&lt;/h1&gt;

&lt;h2&gt;&lt;strong&gt;2.1 C4模型的统一抽象&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;团队需要统一语言进行高效沟通 !!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C4模型在不同的级别提供了统一的抽象以表达软件系统的静态结构&lt;/strong&gt;。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-18JZt8LYi9ONkRXa8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;软件系统&lt;/strong&gt;：最顶层的抽象，其对用户提供价值。包含待构建的系统以及外部依赖的系统&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;容器&lt;/strong&gt;：表示一个应用或者数据存储，容器需要运行以支持系统的正常运转。&lt;strong&gt;每个容器都是独立部署或运行的单元，容器间的通信一般式跨进程交互&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;组件&lt;/strong&gt;：提供一定能力封装的单元。&lt;strong&gt;在C4模型上下文中，组件不是独立部署的单元，一般情况下运行于容器之中&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;代码&lt;/strong&gt;：系统的实现细节相关&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;人&lt;/strong&gt;：系统的使用用户&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2.2 上下文图：System Context Diagram&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;我们要构建的系统不会孤立存在，都会依赖现有的IT设施。要明确我们构建的系统是什么，宏观上需要回答：&lt;strong&gt;我们的系统如何融入到现有的IT设施&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;系统上下文图正是从高层视角表述待构建系统与当前IT设施的交互及边界。通过上下文图：&lt;/p&gt;

&lt;p&gt;• 展示&lt;strong&gt;与软件系统交互的各方及相互关系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;• 展示&lt;strong&gt;软件系统与外部环境的边界&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;• 作为了解系统架构的切入点&lt;/p&gt;

&lt;p&gt;• 确保所有人都理解、认可系统的工作范围&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-19yiRWG7nNed8GiUe.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2.3 容器图：Container Diargram&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;更进一步的剖析核心系统，回答：&lt;strong&gt;系统由哪些容器组成？容器的职责是什么？以及相关的高层的技术选型是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与Docker的容器概念不同，C4模型的容器是在 “系统” 作用域之下，其表达的是组成系统的可独立可部署的物理单元。以下图为例：单个容器元素重包含了名称、职责描述、技术选型，同时，容器间的连线及标注标识了其高层的交互协议及交互形式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-19sRqfOJv7gIeEchg.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2.4 组件图：Component Diagram&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;进一步的剖析容器，回答：容器由哪些组件组成？这些组件的职责及组件间的交互形式是什么？&lt;/p&gt;

&lt;p&gt;具体到每个容器内部，通过多个组件及组件间的关系表达容器的组成。“组件” 本身是一个泛化的概念，C4模型的组件是在 “容器” 的作用域之下，其表现形式可能是独立的Jar包，或者是应用内独立的包，也可能是类级别，但逻辑上都能够表达一个组件的概念。对于组件图关键的是要表示清楚组件的实现选型、组件职责以及组件间的交互关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-22jdDUiguwySLfEou.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2.5 代码&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;代码处于C4模型的最低层，且是可选的，其关注的是实现相关。C4模型并没有对实现层面的可视化进行统一抽象，开发人员可以选择UML类图、E-R图等进行可视化。是否需要提现代码层面研发人员基于具体情况具体分析，&lt;strong&gt;一般情况下，如果系统中需要重点关注的部分可以考虑一些代码级别的图支持&lt;/strong&gt;，比如，我们非常关注系统设计的可扩展性，则关键部分可能需要一些类图表达；又或者非常关注底层数据模型，则E-R图可以纳入考虑范围。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-09-08-10-22P8Fj7lkKBA8AjFM.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;3 C4模型实践中的决策和问题&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;连线表达依赖关系还是数据流向 ？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;都可以，C4模型中的连线既可以表达依赖方向，也可以表达数据流向。原则上，&lt;strong&gt;设计人员需要保证其清晰且无歧义&lt;/strong&gt;。实践中一般通过合理的文字说明来明确的表达元素间的关系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jar或类库应该建模为“容器”？ “组件” ？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jar包或类库一般是链接到调用方的进程中，作为进程中的一部分存在，这种依赖一般不表示为容器，而是组件。当然，是否要将Jar，比如SDK表示为组件并体现在组件图上需要设计人员具体情况具体分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据存储系统应该建模为 “软件系统” 还是 “容器” ？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据存储系统，比如MySQL、DFS等一般是作为独立的外部存储集群存在，集群的运维可能归属于公司的运维团队。以OSS为例，但从应用角度而言，即使集群的运维不归属当前开发团队，团队也会申请租户隔离的专属空间，因此，在C4模型中这种情况应该表述为 “容器”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;消息系统应该如何建模 ？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;消息系统一般作为两个容器间的交互媒介，因此在C4模型中消息系统的建模存在两种方式：&lt;/p&gt;

&lt;p&gt;• 依赖消息系统的容器都显示与消息系统交互，明确的表达各自与消息系统的依赖关系或数据流向&lt;/p&gt;

&lt;p&gt;• 屏蔽消息系统，只提现容器间的依赖关系，并对依赖进行明确说明&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图形化的过期问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C4模型本身也是一种文档化机制，同样也存在过期问题。只不过&lt;strong&gt;C4模型通过对系统在不同的层级进行抽象，每个抽象层级的过期频率不同&lt;/strong&gt;，由上到下逐渐增大，上下文图的变化频率最小，而代码级则变化最大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么C4不涉及业务流、状态机、数据模型等建模&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C4模型仅对系统的静态结构进行建模，并不试图囊括或替代其它建模方式，C4模型并不适合所有维度的可视化表达。对于业务流可以基于BPML、UML活动图进行表达，状态机可以基于UML状态机图进行表达，而数据模型可以通过E-R图表达，不同建模语言相互补充。&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;4 系统架构设计关注不同维度&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;作为架构师或系统设计人员，在进行系统架构设计时一般会关注不同维度，一般情况下，对于业务系统建设而言，会关注以下维度。在架构设计（架构和设计）过程中，基于C4模型、UML及BPML等多种建模方式相互补充，不同表现维度下可以采用不同的建模方式&lt;/p&gt;

&lt;p&gt;• 业务流程：泳道图或UML活动图，表达核心的业务流&lt;/p&gt;

&lt;p&gt;• 业务用例、系统用例：UML用例图&lt;/p&gt;

&lt;p&gt;• 领域模型：UML类图&lt;/p&gt;

&lt;p&gt;• 系统边界：C1，系统上下文图&lt;/p&gt;

&lt;p&gt;• 高层技术选型：C2，容器图&lt;/p&gt;

&lt;p&gt;• 系统职责分配：用线框图表示功能架构&lt;/p&gt;

&lt;p&gt;• 关键部分的实现：C3，组件图&lt;/p&gt;

&lt;p&gt;• 系统关键的交互逻辑：UML时序图&lt;/p&gt;

&lt;p&gt;• 数据模型：E-R图&lt;/p&gt;

&lt;p&gt;• 关键实体的状态机：UML状态机图&lt;/p&gt;

&lt;p&gt;• 不同的高优先级架构属性的设计：比如，缓存方案、幂等性设计方案、定时任务补偿策略、降级限流策略等等，这些都与具体的需求所关注的高优先级的架构属性相关。&lt;/p&gt;

&lt;p&gt;• 部署架构：UML部署图&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;5 总结&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;软件架构设计的终极目标不在于设计本身，而在于架构设计意图的传达。图形化有助于在团队间进行高效的信息同步，但&lt;strong&gt;不同的图形化方式在语义一致性和效率间存在平衡&lt;/strong&gt;。C4模型通过不同的抽象层级来表达系统的静态结构，并提供了最小及的抽象建模元素，为设计人员提供了一种&lt;strong&gt;低认知负载、易于学习和使用&lt;/strong&gt;的高效的建模方式。在实际项目落地过程中，结合C4模型以及UML、线框图等组合方式对架构设计进行可视化表达，一定程度上能够提升团队对架构设计认知的一致性以及建模效率。&lt;/p&gt;

&lt;p&gt;作者：倪新明&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>781996f545ebe661d55f3f7948b54284</guid>
<title>如何快速打造一个高性能数据库原型</title>
<link>https://toutiao.io/k/tkvf7rp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;col-md-10 col-sm-12&quot;&gt;
            &lt;h1&gt; 如何快速打造一个高性能数据库原型&lt;/h1&gt;
            &lt;hr/&gt;
            &lt;p&gt;作者: 康凯森&lt;/p&gt;
            &lt;p&gt;日期: 2022-11-06&lt;/p&gt;
            &lt;p&gt;分类: &lt;a href=&quot;../tag/OLAP.html&quot; target=&quot;_blank&quot;&gt;OLAP&lt;/a&gt;&lt;/p&gt;
            &lt;hr/&gt;
            


&lt;h1 id=&quot;如何快速打造一个高性能数据库原型&quot;&gt;如何快速打造一个高性能数据库原型&lt;/h1&gt;
&lt;p&gt;在上篇博客 &lt;a href=&quot;https://blog.bcmeng.com/post/dpa.html&quot;&gt;Data-Parallel Actors：千行代码构建高性能 OLAP 数据库 &lt;/a&gt; 中，我提出开源数据库会越来越模块化，打造一个高性能的数据库原型会越来越简单，下图是一个利用 DPA 和 一些开源系统打造的数据库架构示意，可能只需要 1 个或者几个人月，就可以打造出这个原型，并且在 SSB，TPC-H,TPC-DS 等标准测试集上取得不错的性能。下面会对图中的一些系统进行介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/Scratch%20Performance%20Database%20With%20Open%20Source.png&quot; alt=&quot;Scratch Performance Database With Open Source&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;查询优化-apache-calcite&quot;&gt;查询优化 Apache Calcite&lt;/h2&gt;
&lt;p&gt;Apache Calcite 网上相关的资料已经很多了，这里就不过多介绍了。 Calcite 相比 StarRocks 的优化器扩展性会更好，但是性能不及 StarRocks 的优化器。&lt;/p&gt;
&lt;h3 id=&quot;架构&quot;&gt;架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/calcite%20architecture%20and%20interaction.png&quot; alt=&quot;calcite architecture and interaction&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Calcite 的核心是优化器，同时支持 RBO 和 CBO，包括 Catalog, SQL parser, SQL validator, Query Optimizer，JDBC Server 和 内置的执行器&lt;/p&gt;
&lt;h3 id=&quot;可扩展性&quot;&gt;可扩展性&lt;/h3&gt;
&lt;p&gt;Calcite 的目标是成为一个通用的查询优化器，可以被各种系统使用，所以在扩展性上做的比较好，开发者在使用 Calcite 时对以下部分都可以进行扩展：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;relational operators&lt;/li&gt;
&lt;li&gt;planner rules&lt;/li&gt;
&lt;li&gt;cost model&lt;/li&gt;
&lt;li&gt;statistics&lt;/li&gt;
&lt;li&gt;元数据：支持 行数，基数，选择度，唯一性等很多元数据都可以定义&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;built-in-sql-implementation&quot;&gt;Built-in SQL implementation&lt;/h3&gt;
&lt;p&gt;Calcite 也内置了一套 执行器，可以执行所有的算子和表达式。Calcite 会生成 java 代码，然后编译，并在 JVM 中执行。Calcite 就利用了 Janino 库来将优化后的方案编译成 JVM Bytecode 来执行，虽然性能比较低下，但是可以作为默认的保底和 fall-back 的方式。&lt;/p&gt;
&lt;h3 id=&quot;流行度&quot;&gt;流行度&lt;/h3&gt;
&lt;p&gt;Calcite 在工业界已经被大量采用，许多项目都使用 Apache Calcite 实现 SQL parsing， 查询优化，数据联邦，物化视图重写，知名的项目有 Apache Hive, Apache Drill, Apache Flink, Apache Kylin, Apache Druid, Dremio 等。&lt;/p&gt;
&lt;h2 id=&quot;查询执行-velox&quot;&gt;查询执行 Velox&lt;/h2&gt;
&lt;p&gt;Velox 是由 Mate 开源的执行引擎，目标是想打造一个统一的高性能 C++ 执行引擎，整体实现和 StarRocks 的执行引擎很类型，亮点不多。 可以参考 Velox 的论文，也可以参考之前我对 StarRocks 执行引擎的介绍：&lt;/p&gt;

&lt;p&gt;Velox 的执行引擎，和 StarRocks 主要包括下面几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type&lt;/li&gt;
&lt;li&gt;兼容 Arrow 的列式布局&lt;/li&gt;
&lt;li&gt;向量化的表达式计算&lt;/li&gt;
&lt;li&gt;标量和聚合函数&lt;/li&gt;
&lt;li&gt;向量化算子&lt;/li&gt;
&lt;li&gt;序列化&lt;/li&gt;
&lt;li&gt;资源管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;流行度&quot;&gt;流行度&lt;/h3&gt;
&lt;p&gt;Velox 开源不久，还没有完全成熟，目前主要和是 Presto 和 Spark 项目合作，一起在搞。&lt;/p&gt;
&lt;h2 id=&quot;内存存储-apache-arrow&quot;&gt;内存存储 Apache Arrow&lt;/h2&gt;
&lt;p&gt;Apache Arrow 项目的目标是成为一个跨平台，跨语言的列式内存格式和磁盘格式 （Apache Parquet），并以此基础，实现了基于内存的查询引擎，最终成为一个内存数据处理的标准。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/arrow.jpg&quot; alt=&quot;Arrow format&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是 Arrow 的列式内存布局。&lt;/p&gt;
&lt;h3 id=&quot;网络传输-apache-arrow-flight&quot;&gt;网络传输 Apache Arrow Flight&lt;/h3&gt;
&lt;p&gt;基于 grpc 和 arrow 列式格式的网络传输框架, 下面两个图是个简单示意，具体可以参考：&lt;a href=&quot;https://www.dremio.com/subsurface/an-introduction-to-apache-arrow-flight-sql/&quot;&gt;https://www.dremio.com/subsurface/an-introduction-to-apache-arrow-flight-sql/&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/apache%20arrow%20flight%201.png&quot; alt=&quot;apache arrow flight 1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/apache%20arrow%20flight%202.png&quot; alt=&quot;apache arrow flight 2&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;datafusion&quot;&gt;DataFusion&lt;/h3&gt;
&lt;p&gt;基于 apache arrow 实现的 可扩展的查询引擎，包括查询优化和查询执行框架。&lt;/p&gt;
&lt;p&gt;下图是 Arrow 和 DataFusion 逐步向 DataBase 演化的路径：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/arrow%20-%20datafusion.png&quot; alt=&quot;arrow - datafusion&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图是 DataFusion 的框架，核心是可扩展：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16620835915011/16677265297142.png&quot; alt=&quot;arrow - datafusion 2&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;流行度&quot;&gt;流行度&lt;/h3&gt;
&lt;p&gt;Apache Arrow 已经被很多业界项目广泛采用，比如 Velox，Spark, StarRocks, Snowflake 等系统都使用了 Apache Arrow。&lt;/p&gt;
&lt;h2 id=&quot;分布式框架-dpa&quot;&gt;分布式框架 DPA&lt;/h2&gt;
&lt;p&gt;对分布式查询的相关功能进行了统一和抽象：数据复制，更新一致性，容错，查询负载均衡，弹性，持久化等。 可以参考之前的文章：&lt;a href=&quot;https://blog.bcmeng.com/post/dpa.html&quot;&gt;Data-Parallel Actors：千行代码构建高性能 OLAP 数据库 &lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;rocksdb&quot;&gt;RocksDB&lt;/h2&gt;
&lt;p&gt;一个基于 LSM tree 的 KV store，被大量用来打造分布式 KV 存储或者存储元数据。&lt;/p&gt;
&lt;h2 id=&quot;序列化&quot;&gt;序列化&lt;/h2&gt;
&lt;p&gt;常量有 json，Protobuf 等协议，业内已经有大量的成熟框架。&lt;/p&gt;
&lt;h2 id=&quot;打造一个成熟的数据库的难点有哪些&quot;&gt;打造一个成熟的数据库的难点有哪些&lt;/h2&gt;
&lt;p&gt;有人会问，打造一个数据库原型如此简单的话，那么数据库公司花费数十人年，数百人年，甚至数千人年都是在做什么。 下面文章我会回答这个问题，为什么打造一个成熟数据库如此困难，为什么数据库是一个如此复杂的工程。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;


            &lt;hr/&gt;
            &lt;h3&gt;欢迎来知识星球和我交流&lt;/h3&gt;
            
        &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>49a8b1669d5bb6157b52003b5c75505e</guid>
<title>跟着这 12 张图，重新复习 Redis</title>
<link>https://toutiao.io/k/25u7bi6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7620370370370371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapfQQZJOKziaehj1pZzNHTicFkDKBMhTBzjZjys2GHM2nWd3LWt5SA7y0A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;八股文网站：&lt;/span&gt;&lt;span&gt;xiaolincoding.com&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小林。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网上看到一篇很不错的 Redis  文章，内容很精炼，而且图画的非常棒，所以分享给大家一起拜读拜读，主要说了「Redis 介绍、Redis 架构、Redis 持久化」这三个方面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这篇文章也不是把所有 Redis 功能都介绍了，如果你想了解更多 Redis 其他知识，可以看我之前写的这篇：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247516196&amp;amp;idx=1&amp;amp;sn=bf62f4349a10d2516b9b1e1ba9a4bde7&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3 万字 + 40 张图 | 攻破 Redis 常见面试题&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，话不多说了，发车！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3043478260869565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf4wic9AG3NR0ereDEnem0Ky2M27wYE8K45ribaxAOoAwxFykhwRYUG3ial4BR0OmXV4rjU2qDibGq48Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;736&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是 Redis？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis（REmote DIctionary Service）是一个开源的键值对数据库服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 更准确的描述是一个数据结构服务器。Redis 的这种特殊性质让它在开发人员中很受欢迎。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7074074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6tibgyywkfL76yJF7r0hLAb3GvmKFmphibicEwzASMibbsU1Fb3xZgFlDDg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis不是通过迭代或者排序方式处理数据，而是一开始就按照数据结构方式组织。早期，它的使用很像 Memcached，但随着 Redis 的改进，它在许多其他用例中变得可行，包括发布-订阅机制、流（streaming）和队列。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.326851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6ichZ8Wb4qk3ojlLu48SUicHoBA34oQDKU8IoqJBFVMLd2dUaIGuMcSOw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要来说，Redis 是一个内存数据库，用作另一个“真实”数据库（如 MySQL 或 PostgreSQL）前面的缓存，以帮助提高应用程序性能。它通过利用内存的高速访问速度，从而减轻核心应用程序数据库的负载，例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不经常更改且经常被请求的数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任务关键性较低且经常变动的数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述数据的示例可以包括会话或数据缓存以及仪表板的排行榜或汇总分析。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5518518518518518&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6HSKdEfwI0niaazf1SpMNYAA320WXEKKMokQSibicZ7jm2d3aT5gqTASSQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，对于许多用例场景，Redis 都可以提供足够的保证，可以将其用作成熟的主数据库。再加上 Redis 插件及其各种高可用性（HA）设置，Redis 作为数据库对于某些场景和工作负载变得非常有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个重要方面是 Redis 模糊了缓存和数据存储之间的界限。这里要理解的重要一点是，相比于使用 SSD 或 HDD 作为存储的传统数据库，读取和操作内存中数据的速度要快得多。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4462962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6NDX3tjrUj97ju6ouO6JmoqYt8bVxDlyIibDfBrUFXT4e0riaJMTDtRdA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最初，Redis 最常被比作 Memcached，后者当时缺乏任何非易失性持久化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是当前两个缓存之间的功能细分。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Memcached&lt;/th&gt;&lt;th&gt;Redis&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;亚毫秒延迟&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;开发者易用性&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据分区&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;支持广泛的编程语言&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;高级数据结构&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;多线程架构&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;快照&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;复制（Replication）&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;事务&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;发布/订阅&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Lua脚本&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;地理空间支持&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然现在拥有多种配置方式将数据持久化到磁盘，但当时首次引入持久化时，Redis 是使用快照方式，通过异步拷贝内存中的数据方式来做持久化。不幸的是，这种机制的缺点是可能会在快照之间丢失数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 自 2009 年成立到现在已经变的很成熟。我们将介绍它的大部分架构和拓扑，以便你可以将 Redis 添加到你的数据存储系统库中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 架构&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始讨论 Redis 内部结构之前，让我们先讨论一下各种 Redis 部署及其权衡取舍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将主要关注以下这些设置：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;单个 Redis 实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 高可用性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 哨兵&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 集群&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据你的用例和规模，决定使用哪一种设置。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单个 Redis 实例&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5581127733026467&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6FWRDgwxWLQ2WyJDOjpZ48wjXYcQyJquXgicatticY2l3GnuWg0tbe2bQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;869&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单个 Redis 实例是最直接的 Redis 部署方式。它允许用户设置和运行小型实例，从而帮助他们快速发展和加速服务。但是，这种部署并非没有缺点。例如，如果此实例失败或不可用，则所有客户端对 Redis 的调用都将失败，从而降低系统的整体性能和速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有足够的内存和服务器资源，这个实例可以很强大。主要用于缓存的场景可能会以最少的设置获得显著的性能提升。给定足够的系统资源，你可以在应用程序运行的同一机器上部署此 Redis 服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在管理系统内的数据方面，了解一些 Redis 概念是必不可少的。发送到 Redis 的命令首先在内存中处理。然后，如果在这些实例上设置了持久性，则在某个时间间隔上会有一个fork进程，来生成数据持久化 RDB（Redis 数据的非常紧凑的时间点表示）快照或 AOF（仅附加文件）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个流程可以让 Redis 拥有长期存储，支持各种复制策略，并启用更复杂的拓扑。如果 Redis 未设置为持久化数据，则在重新启动或故障转移时数据会丢失。如果在重启时启用了持久化，它会将 RDB 快照或 AOF 中的所有数据加载回内存，然后实例可以支持新的客户端请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话虽如此，让我们看看你可能会用到的更多分布式 Redis 设置。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 高可用性&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5509259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6e8nH2hqyVlFXmia4DOnKRibFwicEC6wC8bVKsfWq7nLVY759iayYjXIXMg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;864&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 的另一个流行设置是主从部署方式，从部署保持与主部署之间数据同步。当数据写入主实例时，它会将这些命令的副本发送到从部署客户端输出缓冲区，从而达到数据同步的效果。从部署可以有一个或多个实例。这些实例可以帮助扩展 Redis 的读取操作或提供故障转移，以防 main 丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在已经进入了一个分布式系统，因此需要在此拓扑中考虑许多新事物。以前简单的事情现在变得复杂了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 复制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 的每个主实例都有一个复制 ID 和一个偏移量。这两条数据对于确定副本可以继续其复制过程的时间点或确定它是否需要进行完整同步至关重要。对于主 Redis 部署上发生的每个操作，此偏移量都会增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更明确地说，当 Redis 副本实例仅落后于主实例几个偏移量时，它会从主实例接收剩余的命令，然后在其数据集上重放，直到同步完成。如果两个实例无法就复制 ID 达成一致，或者主实例不知道偏移量，则副本将请求全量同步。这时主实例会创建一个新的 RDB 快照并将其发送到副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此传输之间，主实例会缓冲快照截止和当前偏移之间的所有中间更新指令，这样在快照同步完后，再将这些指令发送到副本实例。这样完成后，复制就可以正常继续。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个实例具有相同的复制 ID 和偏移量，则它们具有完全相同的数据。现在你可能想知道为什么需要复制 ID。当 Redis 实例被提升为主实例或作为主实例从头开始重新启动时，它会被赋予一个新的复制 ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这用于推断此新提升的副本实例是从先前哪个主实例复制出来的。这允许它能够执行部分同步（与其他副本节点），因为新的主实例会记住其旧的复制 ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，两个实例（主实例和从实例）具有相同的复制 ID，但偏移量相差几百个命令，这意味着如果在实例上重放这些偏移量后面的命令，它们将具有相同的数据集。现在，如果复制 ID 完全不同，并且我们不知道新降级（或重新加入）从节点的先前复制 ID（没有共同祖先）。我们将需要执行昂贵的全量同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相反，如果我们知道以前的复制 ID，我们就可以推断如何使数据同步，因为我们能够推断出它们共享的共同祖先，并且偏移量对于部分同步再次有意义。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 哨兵&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1123809523809525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6VnBEz4GFovzpicVBF7IymGyI6hwdE8v3xvKvNbl1D2sHib18ju9f6oZQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1050&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel 是一个分布式系统。与所有分布式系统一样，Sentinel 有几个优点和缺点。Sentinel 的设计方式是，一组哨兵进程协同工作以协调状态，从而为 Redis 提供高可用性。毕竟，你不希望保护你免受故障影响的系统有自己的单点故障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel 负责一些事情。首先，它确保当前的主实例和从实例正常运行并做出响应。这是必要的，因为哨兵（与其他哨兵进程）可以在主节点和/或从节点丢失的情况下发出警报并采取行动。其次，它在服务发现中发挥作用，就像其他系统中的 Zookeeper 和 Consul 一样。所以当一个新的客户端尝试向 Redis 写东西时，Sentinel 会告诉客户端当前的主实例是什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，哨兵不断监控可用性并将该信息发送给客户端，以便他们能够在他们确实进行故障转移时对其做出反应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是它的职责：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;监控——确保主从实例按预期工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通知——通知系统管理员 Redis 实例中的事件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;故障转移管理——如果主实例不可用并且足够多的（法定数量）节点同意这是真的，Sentinel 节点可以启动故障转移。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置管理——Sentinel 节点还充当当前主 Redis 实例的发现服务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以这种方式使用 Redis Sentinel 可以进行故障检测。此检测涉及多个哨兵进程同意当前主实例不再可用。这个协议过程称为 Quorum。这可以提高鲁棒性并防止一台机器行为异常导致无法访问主 Redis 节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此设置并非没有缺点，因此我们将在使用 Redis Sentinel 时介绍一些建议和最佳实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以通过多种方式部署 Redis Sentinel。老实说，要提出任何明智的建议，我需要有关你的系统的更多背景信息。作为一般指导，我建议在每个应用程序服务器旁边运行一个哨兵节点（如果可能的话），这样你也不需要考虑哨兵节点和实际使用 Redis 的客户端之间的网络可达性差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以将 Sentinel 与 Redis 实例一起运行，甚至可以在独立节点上运行，只不过它会按照别的方式处理，从而会让事情变得更复杂。我建议至少运行三个节点，并且至少具有两个法定人数（quorum）。这是一个简单的图表，分解了集群中的服务器数量以及相关的法定人数和可容忍的可持续故障。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Number of Servers&lt;/th&gt;&lt;th&gt;Quorum&lt;/th&gt;&lt;th&gt;Number Of Tolerated Failures&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这会因系统而异，但总体思路是不变的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们花点时间思考一下这样的设置会出现什么问题。如果你运行这个系统足够长的时间，你会遇到所有这些。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果哨兵节点超出法定人数怎么办？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果网络分裂将旧的主实例置于少数群体中怎么办？这些写入会发生什么？（剧透：当系统完全恢复时它们会丢失）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果哨兵节点和客户端节点（应用程序节点）的网络拓扑错位会发生什么？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有持久性保证，特别是持久化到磁盘的操作（见下文）是异步的。还有一个麻烦的问题，当客户发现新的 primary 时，我们失去了多少写给一个不知道的 primary？Redis 建议在建立新连接时查询新的主节点。根据系统配置，这可能意味着大量数据丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你强制主实例将写入复制到至少一个副本实例，有几种方法可以减轻损失程度。请记住，所有 Redis 复制都是异步的，这是有其权衡的考虑。因此，它需要独立跟踪确认，如果至少有一个副本实例没有确认它们，主实例将停止接受写入。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 集群&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6064814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6AXgmiawOvoop0N7GLq5SEKFIdTcbIcyE68xseAFGvSm2hucK3uhLfzg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信很多人都想过当你无法将所有数据存储在一台机器上的内存中时会发生什么。目前，单个服务器中可用的最大 RAM 为 24TIB，这是目前 AWS 线上列出来的。当然，这很多，但对于某些系统来说，这还不够，即使对于缓存层也是如此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster 允许 Redis 的水平扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，让我们摆脱一些术语约束；一旦我们决定使用 Redis 集群，我们就决定将我们存储的数据分散到多台机器上，这称为分片。所以集群中的每个 Redis 实例都被认为是整个数据的一个分片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这带来了一个新的问题。如果我们向集群推送一个key，我们如何知道哪个 Redis 实例（分片）保存了该数据？有几种方法可以做到这一点，但 Redis Cluster 使用算法分片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了找到给定 key 的分片，我们对 key 进行哈希处理，并通过对总分片数量取模。然后，使用确定性哈希函数，这意味着给定的 key 将始终映射到同一个分片，我们可以推断将来读取特定 key 的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们之后想在系统中添加一个新的分片时会发生什么？这个过程称为重新分片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设键 &#x27;foo&#x27; 之前映射到分片 0， 在引入新分片后它可能会映射到分片 5。但是，如果我们需要快速扩展系统，移动数据来达到新的分片映射，这将是缓慢且不切实际的。它还对 Redis 集群的可用性产生不利影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster 为这个问题设计了一种解决方案，称为 Hashslot，所有数据都映射到它。有 16K 哈希槽。这为我们提供了一种在集群中传播数据的合理方式，当我们添加新的分片时，我们只需在系统之间移动哈希槽。通过这样做，我们只需要将 hashlot 从一个分片移动到另一个分片，并简化将新的主实例添加到集群中的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可以在没有任何停机时间和最小的性能影响的情况下实现。让我们通过一个例子来谈谈。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;M1 包含从 0 到 8191 的哈希槽。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;M2 包含从 8192 到 16383 的哈希槽。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，为了映射 “foo”，我们采用一个确定性的键（foo）散列，并通过散列槽的数量（16K）对其进行修改，从而得到 M2 的映射。现在假设我们添加了一个新实例 M3。新的映射将是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;M1 包含从 0 到 5460 的哈希槽。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;M2 包含从 5461 到 10922 的哈希槽。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;M3 包含从 10923 到 16383 的哈希槽。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在映射到 M2 的 M1 中映射哈希槽的所有键都需要移动。但是散列槽的各个键的散列不需要移动，因为它们已经被划分到散列槽中。因此，这一级别的误导（misdirection）解决了算法分片的重新分片问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Gossiping 协议&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster 使用 gossiping 来确定整个集群的健康状况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6064814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6AXgmiawOvoop0N7GLq5SEKFIdTcbIcyE68xseAFGvSm2hucK3uhLfzg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，我们有 3 个 M 个节点和 3 个 S 节点。所有这些节点不断地进行通信以了解哪些分片可用并准备好为请求提供服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果足够多的分片同意 M1 没有响应，他们可以决定将 M1 的副本 S1 提升为主节点以保持集群健康。触发此操作所需的节点数量是可配置的，并且必须正确执行此操作。如果操作不当并且在分区的两边相等时无法打破平局，则可能会导致集群被拆分。这种现象称为裂脑。作为一般规则，必须拥有奇数个主节点和两个副本，以实现最稳健的设置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 持久化模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们要使用 Redis 存储任何类型的数据同时要求安全保存，了解 Redis 是如何做到这一点很重要。在许多用例中，如果你丢失了 Redis 存储的数据，这并不是世界末日。将其用作缓存或在其支持实时分析的情况下，如果发生数据丢失，则并非世界末日。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在其他场景中，我们希望围绕数据持久性和恢复有一些保证。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2074074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6UaUtnz2cI6dZThd6Z7tmr4qBz6EZSEe8eIq1zd7DxtxibuC7wt41lPA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;无持久化&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无持久化：如果你愿意，可以完全禁用持久化。这是运行 Redis 的最快方式，并且没有持久性保证。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RDB文件&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDB（Redis 数据库）：RDB 持久化以指定的时间间隔执行数据集的时间点快照。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种机制的主要缺点是快照之间的数据会丢失。此外，这种存储机制还依赖于主进程的 fork，在更大的数据集中，这可能会导致服务请求的瞬间延迟。话虽如此，RDB 文件在内存中的加载速度要比 AOF 快得多。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AOF&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOF（Append Only File）：AOF 持久化记录服务器接收到的每个写入操作，这些操作将在服务器启动时再次被执行，重建原始数据集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种持久性的方法能够确保比 RDB 快照更持久，因为它是一个仅附加文件。随着操作的发生，我们将它们缓冲到日志中，但它们还没有被持久化。该日志与我们运行的实际命令一致，以便在需要时进行重放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，如果可能，我们使用 fsync 将其刷新到磁盘（当此运行可配置时），它将被持久化。缺点是格式不紧凑，并且比 RDB 文件使用更多的磁盘。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么不兼得？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDB + AOF：可以将 AOF 和 RDB 组合在同一个 Redis 实例中。如果你愿意的话，可以以速度换取持久化是一种折衷方法。我认为这是设置 Redis 的一种可接受的方式。在重启的情况下，请记住如果两者都启用，Redis 将使用 AOF 来重建数据，因为它是最完整的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Forking&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们了解了持久化的类型，让我们讨论一下我们如何在像 Redis 这样的单线程应用程序中实际执行它。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7481481481481481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDvnB9IGfNt4pM80rK9CAC6aah7Vj54CbruBa4mFFryHicTiaTaZjtf9atiaARIbv9zAZhibia42zsjwcw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我看来，Redis 最酷的部分是它如何利用 forking 和写时复制来高效地促进数据持久化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Forking 是操作系统通过创建自身副本来创建新进程的一种方式。这样，你将获得一个新的进程 ID 和一些其他信息和句柄，因此新 forking 的进程（子进程）可以与原始进程父进程通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在事情变得有趣了。Redis 是一个分配了大量内存的进程，那么它如何在不耗尽内存的情况下进行复制呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你 fork 一个进程时，父进程和子进程共享内存，并且在该子进程中 Redis 开始快照（Redis）进程。这是通过一种称为写时复制的内存共享技术实现的——该技术在创建分叉时传递对内存的引用。如果在子进程持久化到磁盘时没有发生任何更改，则不会进行新的分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发生更改的情况下，内核会跟踪对每个页面的引用，如果某个页面有多个更改，则将更改写入新页面。子进程完全不知道更改以及具有一致的内存快照的事情。因此，在只使用了一小部分内存的情况下，我们能够非常快速有效地获得潜在千兆字节内存的时间点快照！&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20b840c905c18cc70b9c45a2ffbcac28</guid>
<title>ThreadLocal 夺命 11 连问</title>
<link>https://toutiao.io/k/dtj3btq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前一段时间，有同事使用&lt;code&gt;ThreadLocal&lt;/code&gt;踩坑了，正好引起了我的兴趣。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以近期，我抽空把ThreadLocal的源码再研究了一下，越看越有意思，发现里面的东西还真不少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把精华浓缩了一下，汇集成了下面11个问题，看看你能顶住第几个？&lt;img data-ratio=&quot;0.8727810650887574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPwOE8aUPLISj0JWBM96Uhcfib0xSBpBPteS3icH0sPsicEoLBwoLmqc2Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1352&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 为什么要用ThreadLocal?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发编程是一项非常重要的技术，它让我们的程序变得更加高效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在并发的场景中，如果有多个线程同时修改公共变量，可能会出现线程安全问题，即该变量最终结果可能出现异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决线程安全问题，&lt;code&gt;JDK&lt;/code&gt;出现了很多技术手段，比如：使用&lt;code&gt;synchronized&lt;/code&gt;或&lt;code&gt;Lock&lt;/code&gt;，给访问公共资源的代码上锁，保证了代码的&lt;code&gt;原子性&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在高并发的场景中，如果多个线程同时竞争一把锁，这时会存在大量的锁等待，可能会浪费很多时间，让系统的响应时间一下子变慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，&lt;code&gt;JDK&lt;/code&gt;还提供了另外一种用空间换时间的新思路：&lt;code&gt;ThreadLocal&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的核心思想是：共享变量在每个&lt;code&gt;线程&lt;/code&gt;都有一个&lt;code&gt;副本&lt;/code&gt;，每个线程操作的都是自己的副本，对另外的线程没有影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        threadLocal.set(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        doSamething();&lt;br/&gt;        Integer integer = threadLocal.get();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. ThreadLocal的原理是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了搞清楚ThreadLocal的底层实现原理，我们不得不扒一下源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;的内部有一个静态的内部类叫：&lt;code&gt;ThreadLocalMap&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;     ...&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取当前线程&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;//获取当前线程的成员变量ThreadLocalMap对象&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//根据threadLocal对象从map中获取Entry对象&lt;/span&gt;&lt;br/&gt;            ThreadLocalMap.Entry e = map.getEntry(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;//获取保存的数据&lt;/span&gt;&lt;br/&gt;                T result = (T)e.value;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//初始化数据&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; setInitialValue();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; T &lt;span&gt;setInitialValue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取要初始化的数据&lt;/span&gt;&lt;br/&gt;        T value = initialValue();&lt;br/&gt;        &lt;span&gt;//获取当前线程&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;//获取当前线程的成员变量ThreadLocalMap对象&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;//如果map不为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;//将初始值设置到map中，key是this，即threadLocal对象，value是初始值&lt;/span&gt;&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;//如果map为空，则需要创建新的map对象&lt;/span&gt;&lt;br/&gt;            createMap(t, value);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(T value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取当前线程&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;//获取当前线程的成员变量ThreadLocalMap对象&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;//如果map不为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;//将值设置到map中，key是this，即threadLocal对象，value是传入的value值&lt;/span&gt;&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;//如果map为空，则需要创建新的map对象&lt;/span&gt;&lt;br/&gt;            createMap(t, value);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ...&lt;br/&gt;     }&lt;br/&gt;     ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;方法、&lt;code&gt;set&lt;/code&gt;方法和&lt;code&gt;setInitialValue&lt;/code&gt;方法，其实最终操作的都是&lt;code&gt;ThreadLocalMap&lt;/code&gt;类中的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中&lt;code&gt;ThreadLocalMap&lt;/code&gt;类的内部如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&amp;lt;&lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        Object value;&lt;br/&gt;&lt;br/&gt;        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;(k);&lt;br/&gt;            value = v;&lt;br/&gt;        }&lt;br/&gt;   }&lt;br/&gt;   ...&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; Entry[] table;&lt;br/&gt;   ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;里面包含一个静态的内部类&lt;code&gt;Entry&lt;/code&gt;，该类继承于&lt;code&gt;WeakReference&lt;/code&gt;类，说明&lt;code&gt;Entry&lt;/code&gt;是一个弱引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;内部还包含了一个&lt;code&gt;Entry&lt;/code&gt;数组，其中：&lt;code&gt;Entry&lt;/code&gt; = &lt;code&gt;ThreadLocal&lt;/code&gt; + &lt;code&gt;value&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;ThreadLocalMap&lt;/code&gt;被定义成了&lt;code&gt;Thread&lt;/code&gt;类的成员变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图从宏观上，认识一下ThreadLocal的整体结构：&lt;img data-ratio=&quot;0.6101398601398601&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPibvIt0m0xgZ5xPBg9icLaYJ2tpewlXIia04nCgAWicuVolVEdb6CJ469PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;从上图中看出，在每个&lt;code&gt;Thread&lt;/code&gt;类中，都有一个&lt;code&gt;ThreadLocalMap&lt;/code&gt;的成员变量，该变量包含了一个&lt;code&gt;Entry数组&lt;/code&gt;，该数组真正保存了ThreadLocal类set的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;是由threadLocal和value组成，其中threadLocal对象是弱引用，在&lt;code&gt;GC&lt;/code&gt;的时候，会被自动回收。而value就是ThreadLocal类set的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图总结一下引用关系：&lt;img data-ratio=&quot;0.3882646691635456&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPDV2MbZtHgetjCIm03QW2iasXjia96wr8RKictVUgIJ5y8WLWQNia09H72w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1602&quot;/&gt;上图中除了Entry的key对ThreadLocal对象是&lt;code&gt;弱引用&lt;/code&gt;，其他的引用都是&lt;code&gt;强引用&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要特别说明的是，上图中ThreadLocal对象我画到了堆上，其实在实际的业务场景中不一定在堆上。因为如果ThreadLocal被定义成了static的，ThreadLocal的对象是类共用的，可能出现在方法区。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 为什么用ThreadLocal做key？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有思考过这样一个问题：&lt;code&gt;ThreadLocalMap&lt;/code&gt;为什么要用&lt;code&gt;ThreadLocal&lt;/code&gt;做key，而不是用&lt;code&gt;Thread&lt;/code&gt;做key？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在你的应用中，一个线程中只使用了一个&lt;code&gt;ThreadLocal&lt;/code&gt;对象，那么使用&lt;code&gt;Thread&lt;/code&gt;做key也未尝不可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;}    &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但实际情况中，你的应用，一个线程中很有可能不只使用了一个ThreadLocal对象。这时使用&lt;code&gt;Thread&lt;/code&gt;做key不就出有问题？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal1 = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal2 = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal3 = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;}    &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如使用&lt;code&gt;Thread&lt;/code&gt;做key时，你的代码中定义了3个ThreadLocal对象，那么，通过Thread对象，它怎么知道要获取哪个ThreadLocal对象呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img data-ratio=&quot;0.5417298937784522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPRNiaWw5iamw6OhpvhSHTtjf8z69UhmVxTOKhAm1ykGAARfXNqjBgicEng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1318&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，不能使用&lt;code&gt;Thread&lt;/code&gt;做key，而应该改成用&lt;code&gt;ThreadLocal&lt;/code&gt;对象做key，这样才能通过具体ThreadLocal对象的&lt;code&gt;get&lt;/code&gt;方法，轻松获取到你想要的ThreadLocal对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPddzQJKggvqA7bjyPYUBbnoBMROAlJ7SxlicJTNFREJHzia6ACV1r8saQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Entry的key为什么设计成弱引用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说过，Entry的key，传入的是ThreadLocal对象，使用了&lt;code&gt;WeakReference&lt;/code&gt;对象，即被设计成了弱引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，为什么要这样设计呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如key对ThreadLocal对象的弱引用，改为强引用。&lt;img data-ratio=&quot;0.39420654911838793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPT8KKEnrticic4sSRcDpOH51tzibCiadrlKGvUxndul4zGe613FRhG6icbkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1588&quot;/&gt;我们都知道ThreadLocal变量对ThreadLocal对象是有强引用存在的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使ThreadLocal变量生命周期完了，设置成null了，但由于key对ThreadLocal还是强引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果执行该代码的&lt;code&gt;线程&lt;/code&gt;使用了&lt;code&gt;线程池&lt;/code&gt;，一直长期存在，不会被销毁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就会存在这样的&lt;code&gt;强引用链&lt;/code&gt;：Thread变量 -&amp;gt; Thread对象 -&amp;gt; ThreadLocalMap -&amp;gt; Entry -&amp;gt; key -&amp;gt; ThreadLocal对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，ThreadLocal对象和ThreadLocalMap都将不会被&lt;code&gt;GC&lt;/code&gt;回收，于是产生了&lt;code&gt;内存泄露&lt;/code&gt;问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，JDK的开发者们把Entry的key设计成了&lt;code&gt;弱引用&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;弱引用&lt;/code&gt;的对象，在GC做垃圾清理的时候，就会被自动回收了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果key是弱引用，当ThreadLocal变量指向null之后，在GC做垃圾清理的时候，key会被自动回收，其值也被设置成null。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img data-ratio=&quot;0.40960809102402024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPuibZibcVKRd0ZNPpa1U6YYSvgfYa31EILjkpyKibq3NDibtuVBv4lZbs3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;&lt;strong&gt;接下来，最关键的地方来了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于当前的ThreadLocal变量已经被指向&lt;code&gt;null&lt;/code&gt;了，但如果直接调用它的&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;方法，很显然会出现&lt;code&gt;空指针异常&lt;/code&gt;。因为它的生命已经结束了，再调用它的方法也没啥意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果系统中还定义了另外一个ThreadLocal变量b，调用了它的&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;，三个方法中的任何一个方法，都会自动触发清理机制，将key为null的value值清空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果key和value都是null，那么Entry对象会被GC回收。如果所有的Entry对象都被回收了，ThreadLocalMap也会被回收了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能最大程度的解决&lt;code&gt;内存泄露&lt;/code&gt;问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要特别注意的地方是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;key为null的条件是，ThreadLocal变量指向&lt;code&gt;null&lt;/code&gt;，并且key是弱引用。如果ThreadLocal变量没有断开对ThreadLocal的强引用，即ThreadLocal变量没有指向null，GC就贸然的把弱引用的key回收了，不就会影响正常用户的使用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果当前ThreadLocal变量指向&lt;code&gt;null&lt;/code&gt;了，并且key也为null了，但如果没有其他ThreadLocal变量触发&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;方法，也会造成内存泄露。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看看弱引用的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    WeakReference&amp;lt;Object&amp;gt; weakReference0 = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; Object());&lt;br/&gt;    System.out.println(weakReference0.get());&lt;br/&gt;    System.gc();&lt;br/&gt;    System.out.println(weakReference0.get());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.Object@&lt;span&gt;1&lt;/span&gt;ef7fe8e&lt;br/&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传入WeakReference构造方法的是直接new处理的对象，没有其他引用，在调用gc方法后，弱引用对象会被自动回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果出现下面这种情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Object object = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;    WeakReference&amp;lt;Object&amp;gt; weakReference1 = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(object);&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;    System.gc();&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.Object@&lt;span&gt;1&lt;/span&gt;ef7fe8e&lt;br/&gt;java.lang.Object@&lt;span&gt;1&lt;/span&gt;ef7fe8e&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先定义了一个强引用object对象，在WeakReference构造方法中将object对象的引用作为参数传入。这时，调用gc后，弱引用对象不会被自动回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的Entry对象中的key不就是第二种情况吗？在Entry构造方法中传入的是ThreadLocal对象的引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将object强引用设置为null：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Object object = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;    WeakReference&amp;lt;Object&amp;gt; weakReference1 = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(object);&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;    System.gc();&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;&lt;br/&gt;    object=&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    System.gc();&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.Object@&lt;span&gt;6f&lt;/span&gt;496d9f&lt;br/&gt;java.lang.Object@&lt;span&gt;6f&lt;/span&gt;496d9f&lt;br/&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二次gc之后，弱引用能够被正常回收。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由此可见，如果强引用和弱引用同时关联一个对象，那么这个对象是不会被GC回收。也就是说这种情况下Entry的key，一直都不会为null，除非强引用主动断开关联。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，你可能还会问这样一个问题：&lt;strong&gt;Entry的value为什么不设计成弱引用？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：Entry的value假如只是被Entry引用，有可能没被业务系统中的其他地方引用。如果将value改成了弱引用，被GC贸然回收了（数据突然没了），可能会导致业务系统出现异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而相比之下，Entry的key，管理的地方就非常明确了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是Entry的key被设计成弱引用，而value没被设计成弱引用的原因。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. ThreadLocal真的会导致内存泄露？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的Entry对象中的key设置成弱引用，并且使用&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;方法清理key为null的value值，就能彻底解决内存泄露问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40960809102402024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPuibZibcVKRd0ZNPpa1U6YYSvgfYa31EILjkpyKibq3NDibtuVBv4lZbs3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;假如ThreadLocalMap中存在很多key为null的Entry，但后面的程序，一直都没有调用过有效的ThreadLocal的&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，Entry的value值一直都没被清空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以会存在这样一条&lt;code&gt;强引用链&lt;/code&gt;：Thread变量 -&amp;gt; Thread对象 -&amp;gt; ThreadLocalMap -&amp;gt; Entry -&amp;gt; value -&amp;gt; Object。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其结果就是：Entry和ThreadLocalMap将会长期存在下去，会导致&lt;code&gt;内存泄露&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 如何解决内存泄露问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说过的ThreadLocal还是会导致内存泄露的问题，我们有没有解决办法呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：有办法，调用ThreadLocal对象的&lt;code&gt;remove&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不是在一开始就调用remove方法，而是在使用完ThreadLocal对象之后。列如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先创建一个CurrentUser类，其中包含了ThreadLocal的逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CurrentUser&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;UserInfo&amp;gt; THREA_LOCAL = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(UserInfo userInfo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        THREA_LOCAL.set(userInfo);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UserInfo &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.get();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.remove();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在业务代码中调用相关方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;     CurrentUser.set(userInfo);&lt;br/&gt;     ...&lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;     UserInfo userInfo = CurrentUser.get();&lt;br/&gt;     ...&lt;br/&gt;   } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;      CurrentUser.remove();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要我们特别注意的地方是：一定要在&lt;code&gt;finally&lt;/code&gt;代码块中，调用&lt;code&gt;remove&lt;/code&gt;方法清理没用的数据。如果业务代码出现异常，也能及时清理没用的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;remove&lt;/code&gt;方法中会把Entry中的key和value都设置成null，这样就能被GC及时回收，无需触发额外的清理机制，所以它能解决内存泄露问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. ThreadLocal是如何定位数据的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说过ThreadLocalMap对象底层是用Entry数组保存数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，ThreadLocal是如何定位Entry数组数据的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ThreadLocal的get、set、remove方法中都有这样一行代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过key的hashCode值，&lt;code&gt;与&lt;/code&gt;数组的长度减1。其中key就是ThreadLocal对象，&lt;code&gt;与&lt;/code&gt;数组的长度减1，相当于除以数组的长度减1，然后&lt;code&gt;取模&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一种hash算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来给大家举个例子：假设len=16，key.threadLocalHashCode=31，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是： int i = 31 &amp;amp; 15 = 15&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相当于：int i = 31 % 16 = 15&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算的结果是一样的，但是使用&lt;code&gt;与运算&lt;/code&gt;效率跟高一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么与运算效率更高？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：因为ThreadLocal的初始大小是&lt;code&gt;16&lt;/code&gt;，每次都是按&lt;code&gt;2&lt;/code&gt;倍扩容，数组的大小其实一直都是2的n次方。这种数据有个规律就是高位是0，低位都是1。在做与运算时，可以不用考虑高位，因为与运算的结果必定是0。只需考虑低位的与运算，所以效率更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用hash算法定位具体位置的话，就可能会出现&lt;code&gt;hash冲突&lt;/code&gt;的情况，即两个不同的hashCode取模后的值相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal是如何解决hash冲突的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看看&lt;code&gt;getEntry&lt;/code&gt;是怎么做的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Entry &lt;span&gt;getEntry&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//通过hash算法获取下标值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (table.length - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    Entry e = table[i];&lt;br/&gt;    &lt;span&gt;//如果下标位置上的key正好是我们所需要寻找的key&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == key)&lt;br/&gt;        &lt;span&gt;//说明找到数据了，直接返回&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; e;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//说明出现hash冲突了，继续往后找&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; getEntryAfterMiss(key, i, e);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再看看&lt;code&gt;getEntryAfterMiss&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Entry &lt;span&gt;getEntryAfterMiss&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, &lt;span&gt;int&lt;/span&gt; i, Entry e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//判断Entry对象如果不为空，则一直循环&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;        &lt;span&gt;//如果当前Entry的key正好是我们所需要寻找的key&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == key)&lt;br/&gt;            &lt;span&gt;//说明这次真的找到数据了&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; e;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;//如果key为空，则清理脏数据&lt;/span&gt;&lt;br/&gt;            expungeStaleEntry(i);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//如果还是没找到数据，则继续往后找&lt;/span&gt;&lt;br/&gt;            i = nextIndex(i, len);&lt;br/&gt;        e = tab[i];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键看看&lt;code&gt;nextIndex&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;nextIndex&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ((i + &lt;span&gt;1&lt;/span&gt; &amp;lt; len) ? i + &lt;span&gt;1&lt;/span&gt; : &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当通过hash算法计算出的下标小于数组大小，则将下标值加1。否则，即下标大于等于数组大小，下标变成0了。下标变成0之后，则循环一次，下标又变成1。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;寻找的大致过程如下图所示：&lt;img data-ratio=&quot;0.4837758112094395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPhoM9mFH5eXkorCiaiagK2mtxd4iaLxyQBRPwqBSu9t7j6WU1icbqXJwcrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;678&quot;/&gt;如果找到最后一个，还是没有找到，则再从头开始找。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4214876033057851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPxsTqeQ2lAVj4Hp8pqodHZtRenJne946HaFFY5xaDciaLibyafFyevIicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;不知道你有没有发现，它构成了一个：&lt;code&gt;环形&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal从数组中找数据的过程大致是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通过key的hashCode取余计算出一个下标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过下标，在数组中定位具体Entry，如果key正好是我们所需要的key，说明找到了，则直接返回数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果第2步没有找到我们想要的数据，则从数组的下标位置，继续往后面找。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果第3步中找key的正好是我们所需要的key，说明找到了，则直接返回数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果还是没有找到数据，再继续往后面找。如果找到最后一个位置，还是没有找到数据，则再从头，即下标为0的位置，继续从前往后找数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直到找到第一个Entry为空为止。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. ThreadLocal是如何扩容的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面得知，ThreadLocal的初始大小是&lt;code&gt;16&lt;/code&gt;。那么问题来了，ThreadLocal是如何扩容的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;set&lt;/code&gt;方法中会调用&lt;code&gt;rehash&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, Object value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Entry e = tab[i];&lt;br/&gt;         e != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;         e = tab[i = nextIndex(i, len)]) {&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == key) {&lt;br/&gt;            e.value = value;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            replaceStaleEntry(key, value, i);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    tab[i] = &lt;span&gt;new&lt;/span&gt; Entry(key, value);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; sz = ++size;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)&lt;br/&gt;        rehash();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意一下，其中有个判断条件是：sz(之前的size+1)如果大于或等于threshold的话，则调用rehash方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;threshold默认是0，在创建ThreadLocalMap时，调用它的构造方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ThreadLocalMap(ThreadLocal&amp;lt;?&amp;gt; firstKey, Object firstValue) {&lt;br/&gt;    table = &lt;span&gt;new&lt;/span&gt; Entry[INITIAL_CAPACITY];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = firstKey.threadLocalHashCode &amp;amp; (INITIAL_CAPACITY - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    table[i] = &lt;span&gt;new&lt;/span&gt; Entry(firstKey, firstValue);&lt;br/&gt;    size = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    setThreshold(INITIAL_CAPACITY);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用setThreshold方法给threshold设置一个值，而这个值INITIAL_CAPACITY是默认的大小16。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setThreshold&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    threshold = len * &lt;span&gt;2&lt;/span&gt; / &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是第一次设置的threshold = 16 * 2 / 3， 取整后的值是：10。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说当sz大于等于10时，就可以考虑扩容了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rehash代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//先尝试回收一次key为null的值，腾出一些空间&lt;/span&gt;&lt;br/&gt;    expungeStaleEntries();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (size &amp;gt;= threshold - threshold / &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;        resize();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真正扩容之前，先尝试回收一次key为null的值，腾出一些空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果回收之后的size大于等于threshold的3/4时，才需要真正的扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算公式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;16&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt; * &lt;span&gt;4&lt;/span&gt; / &lt;span&gt;3&lt;/span&gt; * &lt;span&gt;4&lt;/span&gt; - &lt;span&gt;16&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt; / &lt;span&gt;3&lt;/span&gt; * &lt;span&gt;4&lt;/span&gt; = &lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说添加数据后，新的size大于等于老size的&lt;code&gt;1/2&lt;/code&gt;时，才需要扩容。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;resize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] oldTab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; oldLen = oldTab.length;&lt;br/&gt;    &lt;span&gt;//按2倍的大小扩容&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; newLen = oldLen * &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    Entry[] newTab = &lt;span&gt;new&lt;/span&gt; Entry[newLen];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; oldLen; ++j) {&lt;br/&gt;        Entry e = oldTab[j];&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                e.value = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// Help the GC&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (newLen - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (newTab[h] != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    h = nextIndex(h, newLen);&lt;br/&gt;                newTab[h] = e;&lt;br/&gt;                count++;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    setThreshold(newLen);&lt;br/&gt;    size = count;&lt;br/&gt;    table = newTab;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;resize中每次都是按2倍的大小扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩容的过程如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9527272727272726&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgP6HufRYWSy9DqCibKtibW5pPkaVhVGibyvbt6tUssr9ZCdKAWzChxC83mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;扩容的关键步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;老size + 1 = 新size&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果新size大于等于老size的2/3时，需要考虑扩容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩容前先尝试回收一次key为null的值，腾出一些空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果回收之后发现size还是大于等于老size的1/2时，才需要真正的扩容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每次都是按2倍的大小扩容。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 父子线程如何共享数据？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍的ThreadLocal都是在&lt;code&gt;一个线程&lt;/code&gt;中保存和获取数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在实际工作中，有可能是在父子线程中共享数据的。即在父线程中往ThreadLocal设置了值，在子线程中能够获取到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;        threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;子线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;子线程获取数据：&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会发现，在这种情况下使用ThreadLocal是行不通的。main方法是在主线程中执行的，相当于父线程。在main方法中开启了另外一个线程，相当于子线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然通过ThreadLocal，无法在父子线程中共享数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;InheritableThreadLocal&lt;/code&gt;，它是JDK自带的类，继承了ThreadLocal类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改代码之后：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        InheritableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;        threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;子线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;子线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;果然，在换成InheritableThreadLocal之后，在子线程中能够正常获取父线程中设置的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在Thread类中除了成员变量threadLocals之外，还有另一个成员变量：inheritableThreadLocals。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Thread类的部分代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;ThreadLocal.ThreadLocalMap inheritableThreadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最关键的一点是，在它的&lt;code&gt;init&lt;/code&gt;方法中会将父线程中往ThreadLocal设置的值，拷贝一份到子线程中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感兴趣的小伙伴，可以找我私聊。或者看看我后面的文章，后面还会有专栏。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. 线程池中如何共享数据？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真实的业务场景中，一般很少用&lt;code&gt;单独的线程&lt;/code&gt;，绝大多数，都是用的&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，在线程池中如何共享ThreadLocal对象生成的数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为涉及到不同的线程，如果直接使用ThreadLocal，显然是不合适的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们应该使用InheritableThreadLocal，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    InheritableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;    ExecutorService executorService = Executors.newSingleThreadExecutor();&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第一次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第二次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第一次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第二次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这个例子中使用了单例线程池，固定线程数是1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次submit任务的时候，该线程池会自动创建一个线程。因为使用了InheritableThreadLocal，所以创建线程时，会调用它的init方法，将父线程中的inheritableThreadLocals数据复制到子线程中。所以我们看到，在主线程中将数据设置成6，第一次从线程池中获取了正确的数据6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，在主线程中又将数据改成7，但在第二次从线程池中获取数据却依然是6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为第二次submit任务的时候，线程池中已经有一个线程了，就直接拿过来复用，不会再重新创建线程了。所以不会再调用线程的init方法，所以第二次其实没有获取到最新的数据7，还是获取的老数据6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;，它并非JDK自带的类，而是阿里巴巴开源jar包中的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下pom文件引入该jar包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;transmittable-thread-local&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.11.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;compile&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码调整如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    TransmittableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; TransmittableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;    ExecutorService ttlExecutorService = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    ttlExecutorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第一次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;    ttlExecutorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第二次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第一次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第二次从线程池中获取数据：&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到，使用了TransmittableThreadLocal之后，第二次从线程中也能正确获取最新的数据7了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nice。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你仔细观察这个例子，你可能会发现，代码中除了使用&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;类之外，还使用了&lt;code&gt;TtlExecutors.getTtlExecutorService&lt;/code&gt;方法，去创建&lt;code&gt;ExecutorService&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是非常重要的地方，如果没有这一步，&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;在线程池中共享数据将不会起作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;code&gt;ExecutorService&lt;/code&gt;对象，底层的submit方法会&lt;code&gt;TtlRunnable&lt;/code&gt;或&lt;code&gt;TtlCallable&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以TtlRunnable类为例，它实现了&lt;code&gt;Runnable&lt;/code&gt;接口，同时还实现了它的run方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Map&amp;lt;TransmittableThreadLocal&amp;lt;?&amp;gt;, Object&amp;gt; copied = (Map)&lt;span&gt;this&lt;/span&gt;.copiedRef.get();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (copied != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (!&lt;span&gt;this&lt;/span&gt;.releaseTtlValueReferenceAfterRun || &lt;span&gt;this&lt;/span&gt;.copiedRef.compareAndSet(copied, (Object)&lt;span&gt;null&lt;/span&gt;))) {&lt;br/&gt;        Map backup = TransmittableThreadLocal.backupAndSetToCopied(copied);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.runnable.run();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            TransmittableThreadLocal.restoreBackup(backup);&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;TTL value reference is released after run!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的主要逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;把当时的ThreadLocal做个备份，然后将父类的ThreadLocal拷贝过来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行真正的run方法，可以获取到父类最新的ThreadLocal数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从备份的数据中，恢复当时的ThreadLocal数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11. ThreadLocal有哪些用途？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，一起聊聊ThreadLocal有哪些用途？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老实说，使用ThreadLocal的场景挺多的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面列举几个常见的场景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在spring事务中，保证一个线程下，一个事务的多个操作拿到的是一个Connection。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在hiberate中管理session。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在JDK8之前，为了解决SimpleDateFormat的线程安全问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取当前登录用户上下文。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;临时保存权限数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用MDC保存日志信息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等等，还有很多业务场景，这里就不一一列举了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于篇幅有限，今天的内容先分享到这里。希望你看了这篇文章，会有所收获。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来留几个问题给大家思考一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ThreadLocal变量为什么建议要定义成static的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Entry数组为什么要通过hash算法计算下标，即直线寻址法，而不直接使用下标值？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强引用和弱引用有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Entry数组大小，为什么是2的N次方？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用InheritableThreadLocal时，如果父线程中重新set值，在子线程中能够正确的获取修改后的新值吗？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;敬请期待我的下一篇文章，谢谢。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6e4dc15e0459b246c8ed540ee4a90b7a</guid>
<title>Vue3 + Vant 开发微信公众号网页爬坑不完全指北</title>
<link>https://toutiao.io/k/2p8b4vg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxNzk1MjQ0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YBFV3Da0Nwvv72YkFO0qPibDKicOCsfltiaE9070DOu4iahXnicYwRIHcxe9VBicAy45MkPqy8nZzLTVibugOtV0ORFcg/0?wx_fmt=png&quot; data-nickname=&quot;程序员成长指北&quot; data-alias=&quot;coder_growth&quot; data-signature=&quot;专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot; data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(0, 0, 0)&quot; data-style=&quot;outline: 0px; letter-spacing: 0.544px; white-space: normal; color: rgb(0, 0, 0); font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; caret-color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); text-align: center; visibility: visible;&quot;&gt;&lt;span data-darkmode-bgcolor-166718259710710=&quot;rgb(198, 188, 180)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)|rgb(255, 242, 232)&quot; data-darkmode-color-166718259710710=&quot;rgb(212, 56, 13)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(0, 0, 0)|rgb(212, 56, 13)&quot; data-style=&quot;padding: 4px 7px; outline: 0px; letter-spacing: 0.544px; font-size: 12px; text-align: left; border-radius: 2px; line-height: 20px; font-weight: bold; color: rgb(212, 56, 13); background: rgb(255, 242, 232); border-color: rgb(255, 187, 150); visibility: visible;&quot;&gt;大厂技术&lt;/span&gt;&lt;span data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(0, 0, 0)&quot;&gt;  &lt;/span&gt;&lt;span data-darkmode-bgcolor-166718259710710=&quot;rgb(186, 190, 198)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)|rgb(240, 245, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(29, 57, 196)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(0, 0, 0)|rgb(29, 57, 196)&quot; data-style=&quot;padding: 4px 7px; outline: 0px; letter-spacing: 0.544px; font-size: 12px; text-align: left; border-radius: 2px; line-height: 20px; font-weight: bold; color: rgb(29, 57, 196); background: rgb(240, 245, 255); border-color: rgb(173, 198, 255); visibility: visible;&quot;&gt;高级前端&lt;/span&gt;&lt;span data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(0, 0, 0)&quot;&gt;  &lt;/span&gt;&lt;span data-darkmode-bgcolor-166718259710710=&quot;rgb(34, 34, 34)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)|rgb(246, 255, 237)&quot; data-darkmode-color-166718259710710=&quot;rgb(56, 158, 13)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(0, 0, 0)|rgb(56, 158, 13)&quot; data-style=&quot;padding: 4px 7px; outline: 0px; letter-spacing: 0.544px; font-size: 12px; text-align: left; border-radius: 2px; line-height: 20px; font-weight: bold; color: rgb(56, 158, 13); background: rgb(246, 255, 237); border-color: rgb(183, 235, 143); visibility: visible;&quot;&gt;Node进阶&lt;/span&gt;&lt;br data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(0, 0, 0)&quot;/&gt;&lt;/h1&gt;&lt;p data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(62, 62, 62)&quot; data-style=&quot;margin-bottom: 0px; padding-right: 0.5em; padding-left: 0.5em; outline: 0px; white-space: normal; font-size: 16px; color: rgb(62, 62, 62); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 2px; background-color: rgb(255, 255, 255); caret-color: rgb(51, 51, 51); word-spacing: 0.8px; text-align: center; visibility: visible;&quot;&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(62, 62, 62)|rgb(136, 136, 136)&quot;&gt;点击上方 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(62, 62, 62)|rgb(0, 128, 255)&quot;&gt;程序员成长指北&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(62, 62, 62)|rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;br data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(62, 62, 62)&quot;/&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(0, 0, 0)&quot; data-style=&quot;margin-bottom: 0px; outline: 0px; white-space: normal; color: rgb(0, 0, 0); font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; font-size: 16px; letter-spacing: 2px; background-color: rgb(255, 255, 255); caret-color: rgb(51, 51, 51); word-spacing: 0.8px; text-align: center; visibility: visible;&quot;&gt;&lt;span data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(0, 0, 0)|rgb(136, 136, 136)&quot;&gt;回复&lt;/span&gt;&lt;span data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(0, 0, 0)&quot;&gt;&lt;span data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(0, 0, 0)|rgb(0, 128, 255)&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span data-darkmode-bgcolor-166718259710710=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-166718259710710=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-166718259710710=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-166718259710710=&quot;#fff|rgb(0, 0, 0)|rgb(136, 136, 136)&quot;&gt;，加入高级Node交流群&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;8月底的时候接到了一个微信公众号网页开发的任务, 在此之前我从没开发过微信公众号网页的项目, 心想这回又能学到新东西了, 然后又是移动端项目, 可以放心地使用框架和&lt;code&gt;es6+&lt;/code&gt;的语法提升开发体验了, 因为平时的项目很多都是&lt;code&gt;jQuery&lt;/code&gt;, 并且需要兼容低版本&lt;code&gt;ie&lt;/code&gt;浏览器.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来就是技术选型, 结合我擅长的&lt;code&gt;react&lt;/code&gt;考虑, 移动端UI组件首先我就想到了&lt;span&gt;ant design mobile&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;, 然后看看&lt;span&gt;微信网页开发#网页授权&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;的文档, 就可以上手开发了, 紧接着就是兵来将挡水来土掩了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但想到我对&lt;code&gt;react&lt;/code&gt;已经相对比较熟悉, 而且公司前端开发团队里的其他人用的都是&lt;code&gt;vue&lt;/code&gt;, 如果我也掌握了&lt;code&gt;vue&lt;/code&gt;, 那么后续如果有一些紧急的项目, 比如之前有其他小伙伴做过的项目, 那么我拿到代码之后就能快速了解对方的代码逻辑, 从而能够借鉴已有的代码, 达到敏捷开发的目的, 既能学习一项新的框架, 同时还能有助于后续的开发, 而这仅仅只是多花点时间就能获得的, 何乐而不为呢&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;vue&lt;/code&gt;目前最新的版本是&lt;code&gt;vue3&lt;/code&gt;, 之前用过一下&lt;code&gt;vue3&lt;/code&gt;, 但并没有用&lt;code&gt;vue3&lt;/code&gt;中的&lt;code&gt;&amp;lt;script setup&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt; &lt;code&gt;语法糖&lt;/code&gt;, 而是用的&lt;code&gt;setup()&lt;/code&gt;方法, 然后整个文件的写法感觉就有些不伦不类, 看着像&lt;code&gt;vue2&lt;/code&gt;的&lt;code&gt;对象&lt;/code&gt;的写法, 又像&lt;code&gt;vue3&lt;/code&gt;的&lt;code&gt;组合式API&lt;/code&gt;的写法, 当然了, 也可能是我的姿势不对, 而这次我打算直接使用&lt;code&gt;vue3&lt;/code&gt;的&lt;code&gt;&amp;lt;script setup&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt; &lt;code&gt;语法糖&lt;/code&gt;以及&lt;code&gt;组合式API&lt;/code&gt;, &lt;code&gt;vue3&lt;/code&gt;的&lt;code&gt;组合式API&lt;/code&gt;看起来和&lt;code&gt;react&lt;/code&gt;的&lt;code&gt;hooks&lt;/code&gt;的写法非常相似, 上手应该没有太大的难度&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而说起&lt;code&gt;vue&lt;/code&gt;的移动端UI解决方案, 那就不得不提大名鼎鼎的&lt;span&gt;vant&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;了, 我之前也没用过&lt;code&gt;vant&lt;/code&gt;, 但见招拆招, 兵来将挡水来土掩, 至此, 技术选型就完成了, 剩下的就是踩(开)坑(发)了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说踩(干)就踩(干)&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;环境信息&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;os&lt;/code&gt;: &lt;code&gt;win10&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;node&lt;/code&gt;: &lt;code&gt;v16.17.0&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;yarn&lt;/code&gt;: &lt;code&gt;1.22.18&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;编辑器&lt;/code&gt;: &lt;code&gt;VS Code&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;package.json&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先贴一下我的&lt;code&gt;package.json&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;vue-project&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;version&quot;&lt;/span&gt;: &lt;span&gt;&quot;0.0.0&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;scripts&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;dev&quot;&lt;/span&gt;: &lt;span&gt;&quot;vite&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;build&quot;&lt;/span&gt;: &lt;span&gt;&quot;vite build --base=/path1/&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;build:test&quot;&lt;/span&gt;: &lt;span&gt;&quot;vite build --mode=test --base=/path1/path2/&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;preview&quot;&lt;/span&gt;: &lt;span&gt;&quot;vite preview --port 4173&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;lint&quot;&lt;/span&gt;: &lt;span&gt;&quot;eslint . --ext .vue,.js,.jsx,.cjs,.mjs --fix --ignore-path .gitignore&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;dependencies&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;axios&quot;&lt;/span&gt;: &lt;span&gt;&quot;^0.27.2&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;vant&quot;&lt;/span&gt;: &lt;span&gt;&quot;^3.5.4&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;vconsole&quot;&lt;/span&gt;: &lt;span&gt;&quot;^3.14.6&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;vue&quot;&lt;/span&gt;: &lt;span&gt;&quot;^3.2.37&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;vue-router&quot;&lt;/span&gt;: &lt;span&gt;&quot;^4.1.3&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;weixin-js-sdk&quot;&lt;/span&gt;: &lt;span&gt;&quot;^1.6.0&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;devDependencies&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;@rushstack/eslint-patch&quot;&lt;/span&gt;: &lt;span&gt;&quot;^1.1.4&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;@vitejs/plugin-vue&quot;&lt;/span&gt;: &lt;span&gt;&quot;^3.0.1&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;@vue/eslint-config-prettier&quot;&lt;/span&gt;: &lt;span&gt;&quot;^7.0.0&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;@xianzhengquan/postcss-px-2-vw&quot;&lt;/span&gt;: &lt;span&gt;&quot;^0.0.1&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;eslint&quot;&lt;/span&gt;: &lt;span&gt;&quot;^8.21.0&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;eslint-plugin-vue&quot;&lt;/span&gt;: &lt;span&gt;&quot;^9.3.0&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;object-assign&quot;&lt;/span&gt;: &lt;span&gt;&quot;^4.1.1&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;prettier&quot;&lt;/span&gt;: &lt;span&gt;&quot;^2.7.1&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;sass&quot;&lt;/span&gt;: &lt;span&gt;&quot;^1.54.4&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;unplugin-vue-components&quot;&lt;/span&gt;: &lt;span&gt;&quot;^0.22.4&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;vite&quot;&lt;/span&gt;: &lt;span&gt;&quot;^3.0.4&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;peerDependencies&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;postcss&quot;&lt;/span&gt;: &lt;span&gt;&quot;^8.4.16&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目是按照&lt;span&gt;Vue3官方文档&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;上的步骤来创建的, 这个文档上写的很详细, 这里就不再熬述了&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;VS Code扩展&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我使用的是官方推荐的&lt;span&gt;Vue Language Features \(Volar\)&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;, 它提供了&lt;code&gt;vue3&lt;/code&gt;的语法高亮功能, 以及它和著名的&lt;span&gt;Vetur&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;有些冲突, 于是我就把&lt;code&gt;Vetur&lt;/code&gt;卸载了, 但官方推荐的&lt;code&gt;Volar&lt;/code&gt;并没有提供代码块, 而就在我苦恼之际, 我阅读&lt;code&gt;Volar&lt;/code&gt;的文档后发现里面提到了一个&lt;span&gt;Vue VSCode Snippets&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;的扩展, 于是我就安装了, 一开始不是太习惯, 后来就适应了, 我使用的是&lt;code&gt;vbase-3-setup&lt;/code&gt;, 但一般为了方便, 我就只敲&lt;code&gt;v3&lt;/code&gt;, 然后鼠标选择&lt;code&gt;vbase-3-setup&lt;/code&gt;, 这样就会有一个&lt;code&gt;vue3&lt;/code&gt;的&lt;code&gt;&amp;lt;script setup&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt; &lt;code&gt;语法糖&lt;/code&gt;的基础代码块了&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;css预处理器&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;code&gt;css预处理器&lt;/code&gt;我选择的是&lt;code&gt;scss&lt;/code&gt;, 文档是&lt;span&gt;sass&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;, 这里之所以用的是&lt;code&gt;scss&lt;/code&gt;而不是我所熟悉的&lt;code&gt;less&lt;/code&gt;, 主要是因为想借此机会学一学&lt;code&gt;scss&lt;/code&gt;, 还有就是上面提到的&lt;code&gt;Vue VSCode Snippets&lt;/code&gt;所提供的模板中的&lt;code&gt;css预处理器&lt;/code&gt;用的也是&lt;code&gt;scss&lt;/code&gt;, 于是我就直接使用&lt;code&gt;scss&lt;/code&gt;了, 它的语法和&lt;code&gt;less&lt;/code&gt;有些类似, &lt;code&gt;嵌套&lt;/code&gt;的写法类似, &lt;code&gt;继承&lt;/code&gt;有些不同, 有差异, 但就我目前使用的程度上来说还好, 其他的文档上解释得也比较详细, 这里就不展开了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;scss&lt;/code&gt;而不是&lt;code&gt;sass&lt;/code&gt;做文件扩展名是因为&lt;code&gt;scss&lt;/code&gt;是&lt;code&gt;css&lt;/code&gt;的&lt;code&gt;超集&lt;/code&gt;, &lt;code&gt;css&lt;/code&gt;能用的语法在&lt;code&gt;scss&lt;/code&gt;中也能用, 同时由于它和&lt;code&gt;css&lt;/code&gt;的相似性, 使得它更容易上手&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;vite.config.js&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;vite&lt;/code&gt;的配置如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { fileURLToPath, URL } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;node:url&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { defineConfig } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vite&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; vue &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@vitejs/plugin-vue&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Components &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;unplugin-vue-components/vite&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { VantResolver } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;unplugin-vue-components/resolvers&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// https://cn.vitejs.dev/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; defineConfig({&lt;br/&gt;  &lt;span&gt;plugins&lt;/span&gt;: [&lt;br/&gt;    vue(),&lt;br/&gt;    Components({&lt;br/&gt;      &lt;span&gt;resolvers&lt;/span&gt;: [VantResolver()]&lt;br/&gt;    })&lt;br/&gt;  ],&lt;br/&gt;  &lt;span&gt;resolve&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;alias&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&#x27;@&#x27;&lt;/span&gt;: fileURLToPath(&lt;span&gt;new&lt;/span&gt; URL(&lt;span&gt;&#x27;./src&#x27;&lt;/span&gt;, &lt;span&gt;import&lt;/span&gt;.meta.url))&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是做了&lt;code&gt;vant&lt;/code&gt; &lt;code&gt;按需引入&lt;/code&gt;的配置, 这同样也是&lt;code&gt;vant&lt;/code&gt;文档中提到的一个方法: &lt;span&gt;vant#按需引入组件样式&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;lint&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;lint&lt;/code&gt;的配置每个人都有每个人的习惯, 在这之前我一直用的是&lt;code&gt;eslint&lt;/code&gt;, &lt;code&gt;eslint-plugin-react&lt;/code&gt;以及&lt;code&gt;react/recommended&lt;/code&gt;, 同时也配置了保存时候对代码进行&lt;code&gt;lint&lt;/code&gt;格式化的操作:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;editor.codeActionsOnSave&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;source.fixAll.eslint&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这里还是想和大家聊一聊&lt;code&gt;vue3&lt;/code&gt;默认的&lt;code&gt;lint&lt;/code&gt;配置, 不是因为它用的是&lt;code&gt;prettier&lt;/code&gt;, 而是因为它默认的&lt;code&gt;lint&lt;/code&gt;规则背后作者的一些想法, 由于和我以前的习惯相悖, 一开始我还是有些排斥的, 但最后慢慢理解了, 就接受了, 同时觉得挺了不起的, 不愧行业中顶尖的人, 首先贴一下我的配置:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.eslintrc.cjs&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/* eslint-env node */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;@rushstack/eslint-patch/modern-module-resolution&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;root&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;extends&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&#x27;plugin:vue/vue3-essential&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&#x27;eslint:recommended&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&#x27;@vue/eslint-config-prettier&#x27;&lt;/span&gt;&lt;br/&gt;  ],&lt;br/&gt;  &lt;span&gt;parserOptions&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;ecmaVersion&lt;/span&gt;: &lt;span&gt;&#x27;latest&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;rules&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&#x27;prettier/prettier&#x27;&lt;/span&gt;: [&lt;br/&gt;      &lt;span&gt;&#x27;error&#x27;&lt;/span&gt;,&lt;br/&gt;      {&lt;br/&gt;        &lt;span&gt;endOfLine&lt;/span&gt;: &lt;span&gt;&#x27;auto&#x27;&lt;/span&gt;, &lt;span&gt;//行末换行符: auto表示保持当前的换行符&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;singleQuote&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//是否使用单引号替代双引号: 使用&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;bracketSpacing&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//是否在对象字面量中括号之间使用空格: 使用&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;trailingComma&lt;/span&gt;: &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;, &lt;span&gt;//在多行逗号分隔的句法结构中尽可能打印尾部逗号: 从不&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;vueIndentScriptAndStyle&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; &lt;span&gt;//是否在vue script和style标签中缩进: 使用&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Delete CR错误&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这个问题, 掘金上有大佬做了详细的解释, 详情可以看这篇文章: &lt;span&gt;Delete `␍`eslint\(prettier/prettier\) 错误的解决方案&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;, 我司开发人员用的电脑都是&lt;code&gt;windows&lt;/code&gt;系统, 于是我就直接将其配置成了&lt;code&gt;auto&lt;/code&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;vue script和style标签的缩进问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;vueIndentScriptAndStyle&lt;/code&gt;是否在&lt;code&gt;vue&lt;/code&gt; &lt;code&gt;script&lt;/code&gt;和&lt;code&gt;style&lt;/code&gt;标签中缩进, 尤大的习惯是不缩进, 而我个人的习惯是缩进, 这个因人而异, 没有好坏对错之分, &lt;code&gt;prettier&lt;/code&gt;官网 &lt;span&gt;Vue files script and style tags indentation&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;中有尤大的一个解释: &lt;span&gt;Indent script and style tags content in \*.vue files#a comment from the creator of vue&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;, &lt;code&gt;prettire&lt;/code&gt;增加了一个选项来让用户使用, 我个人很喜欢这个选项&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;arrowParens(箭头函数圆括号)&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来是箭头函数圆括号的问题, 一直以来我都是尽可能的省略圆括号, 比如只有一个参数的时候我会省略它的圆括号:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; foo = &lt;span&gt;&lt;span&gt;a&lt;/span&gt; =&amp;gt;&lt;/span&gt; {};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多个参数的时候才写:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; foo = &lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在做这个项目之前, 一直都是这个写法, 而这个项目默认的配置却是: 无论有多少参数都不省略圆括号. 我觉得这样比较地影响观感, 一个参数写什么括号嘛, 看着多难看, 又不报错, 多个参数才需要写括号, 不写就会报错了, 当然在用&lt;code&gt;ts&lt;/code&gt;的时候, 一个参数也要写括号的, 这样才能声明该参数的类型, 比如:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; foo = (a: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;&lt;span&gt;void&lt;/span&gt; =&amp;gt;&lt;/span&gt; {};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可我还是不理解为何它要采用无论有多少参数都不省略圆括号的策略, 于是我就去&lt;code&gt;prettier&lt;/code&gt;的官网上看了看, 文档&lt;span&gt;Arrow Function Parentheses&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;中关于箭头函数圆括号的解释给了我答案:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;At first glance, avoiding parentheses may look like a better choice because of less visual noise. However, when Prettier removes parentheses, it becomes harder to add type annotations, extra arguments or default values as well as making other changes. Consistent use of parentheses provides a better developer experience when editing real codebases, which justifies the default value for the option.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;乍一看，避免使用小括号可能是一个更好的选择，因为可以减少视觉噪音。然而，当Prettier删除小括号时，就很难添加类型注释、额外的参数或默认值以及进行其他修改。在编辑真正的代码库时，小括号的一致使用为开发者提供了更好的体验，这证明了该选项的默认值是合理的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完这段话, 瞬间醍醐灌顶, 是啊, 有了小括号, 才使得&lt;code&gt;ts&lt;/code&gt;的类型注释成为了可能, 以及也方便设置默认值, 所有参数都使用括号使得我们的代码具有了高度的一致性, 易读也易用, 于是我就将这个用法保留了下来&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;vant相关问题&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;postcss.config.js&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;vite.config.js&lt;/code&gt;中对&lt;code&gt;vant&lt;/code&gt;进行了配置之后, 就不需要再次在&lt;code&gt;main.js&lt;/code&gt;中进行注册了, 直接在我们的&lt;code&gt;vue&lt;/code&gt;文件中使用即可&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这个&lt;code&gt;按需引入&lt;/code&gt;之外, 还有移动端适配, 这里我使用的是&lt;code&gt;vw&lt;/code&gt;的方案, &lt;code&gt;rem&lt;/code&gt;方案考虑到要监听浏览器缩放事件, 频繁修改根字号, 而且配置要比这个繁琐, 再加上&lt;code&gt;vw&lt;/code&gt;移动端的兼容性已经很好了, 而且我也想在实际项目中用一用, 之前只用过&lt;code&gt;rem&lt;/code&gt;, &lt;code&gt;vw&lt;/code&gt;还没有特别完整的项目使用, 于是就采用了&lt;code&gt;vw&lt;/code&gt;的方案&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;vant官方文档#浏览器适配&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;里面推荐了一个&lt;code&gt;px2vw&lt;/code&gt;的解决方案: &lt;span&gt;postcss-px-to-viewport&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;, 这个方案倒不是说不好, 只是照文档上来使用的时候&lt;code&gt;postcss&lt;/code&gt;给我报了个&lt;code&gt;warning&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;postcss-px-to-viewport: postcss.plugin was deprecated. Migration guide:&lt;br/&gt;https://evilmartians.com/chronicles/postcss-8-plugin-migration&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这个警告, 我最终在插件的&lt;code&gt;issue&lt;/code&gt;中找到了解决方案: &lt;span&gt;支持 postcss-8&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt;, 改用评论中提到的这个插件: &lt;span&gt;\@xianzhengquan/postcss-px-2-vw&lt;/span&gt;&lt;sup&gt;[17]&lt;/sup&gt;就没有这个迁移的警告了, 同时还要安一下&lt;span&gt;object-assign&lt;/span&gt;&lt;sup&gt;[18]&lt;/sup&gt;, 不然会报错&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我参照警告的链接文章里所说的对&lt;code&gt;postcss&lt;/code&gt;做了优化, &lt;code&gt;package.json&lt;/code&gt;最终改为了上面贴出来那样, 具体的配置和由来参考&lt;code&gt;postcss.config.js&lt;/code&gt;文件:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//https://github.com/evrone/postcss-px-to-viewport&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//https://github.com/evrone/postcss-px-to-viewport/issues/83&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;plugins&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&#x27;@xianzhengquan/postcss-px-2-vw&#x27;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;viewportWidth&lt;/span&gt;: &lt;span&gt;750&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及在一开始的时候我打算看看&lt;code&gt;postcss&lt;/code&gt;是如何配置&lt;code&gt;rem&lt;/code&gt;的, 因为之前使用&lt;code&gt;rem&lt;/code&gt;方案都是加载的&lt;code&gt;js&lt;/code&gt;文件, 比如页面中直接加载&lt;code&gt;rem.js&lt;/code&gt;这样的, 并没有使用&lt;code&gt;postcss&lt;/code&gt;, 而这个尝试花了我3个小时, 最后就一句话: &lt;code&gt;Tips: 在配置 postcss-pxtorem 时，同样应避免 ignore node_modules 目录，否则会导致 Vant 样式无法被编译。&lt;/code&gt;, 这也是我对&lt;code&gt;postcss&lt;/code&gt;不熟导致的, 为了避免坑到其他人, 我也给&lt;code&gt;vant&lt;/code&gt;提了一个&lt;code&gt;pr&lt;/code&gt;: &lt;span&gt;docs: add tips in advanced-usage.zh-CN.md&lt;/span&gt;&lt;sup&gt;[19]&lt;/sup&gt;, 同时这里也附上一些配置的解释, &lt;code&gt;postcss-px-to-viewport&lt;/code&gt;同样适用:&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置释义&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//详细配置请查看: https://github.com/cuth/postcss-pxtorem#readme&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * rootValue:&lt;br/&gt; * 最终元素值 = 设计稿上的值 / rootValue;&lt;br/&gt; * 比如设计稿上某元素某属性是40px, rootValue为100, 那么最终那个元素的那个属性会被转换为0.4rem;&lt;br/&gt; * 可是这个时候会发现, 字号还是小了, 因为默认根字号是16px, 而不是我们设置的100px, 因此需要修改真正的根字号,&lt;br/&gt; * 也就是html标签的font-size值&lt;br/&gt; *&lt;br/&gt; * replace (Boolean) Replaces rules containing rems instead of adding fallbacks.&lt;br/&gt; * 替换包含rem的规则, 而不是增加回退规则&lt;br/&gt; * 默认为true, 表示直接将px转换为rem&lt;br/&gt; * 若为false, 除了转换px为rem外, 还会保留原来的px单位&lt;br/&gt; * 例如:&lt;br/&gt; * div{&lt;br/&gt; *  width: xx px;&lt;br/&gt; * }&lt;br/&gt; * replace: true, 转换结果为:&lt;br/&gt; * div{&lt;br/&gt; *  width: xx / rootValue rem;&lt;br/&gt; * }&lt;br/&gt; * replace: false, 转换结果为:&lt;br/&gt; * div{&lt;br/&gt; *  width: xx px;&lt;br/&gt; *  width: xx / rootValue rem;&lt;br/&gt; * }&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;plugins&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&#x27;postcss-pxtorem&#x27;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;rootValue&lt;/span&gt;: &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;//根元素字号(单位px)&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;unitPrecision&lt;/span&gt;: &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;//转换成rem后, 小数点后保留几位&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;propList&lt;/span&gt;: [&lt;span&gt;&#x27;*&#x27;&lt;/span&gt;], &lt;span&gt;//需要转成rem单位的属性&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;selectorBlackList&lt;/span&gt;: [], &lt;span&gt;//选择器黑名单(哪些不用转成rem)&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;replace&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//是否替换包含rem的规则, 而不是增加回退规则&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;mediaQuery&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//是否转换媒体查询中的px为rem&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;minPixelValue&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;//需要转换的最小px值&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;exclude&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt; &lt;span&gt;//排除项, 即不需要转换的目录或文件&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;样式定制/覆盖&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个需求比较频繁, 毕竟有设计稿, 不太可能完完全全按照UI组件库的默认样式来开发, 于是我就对它的样式进行了一些配置, 详细内容请查阅&lt;span&gt;ConfigProvider 全局配置&lt;/span&gt;&lt;sup&gt;[20]&lt;/sup&gt;, 我这里使用的是修改基础变量的方式: &lt;span&gt;基础变量&lt;/span&gt;&lt;sup&gt;[21]&lt;/sup&gt;, 同时文档&lt;span&gt;示例工程&lt;/span&gt;&lt;sup&gt;[22]&lt;/sup&gt;中提到的示例仓库: &lt;span&gt;Vant Demo&lt;/span&gt;&lt;sup&gt;[23]&lt;/sup&gt;中提供了另一种配置方式, 具体可以查看代码: &lt;span&gt;theme config&lt;/span&gt;&lt;sup&gt;[24]&lt;/sup&gt;, 只是这个方式我并没有尝试过, 有用过的小伙伴欢迎在评论区留言讨论&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;List组件bug&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用&lt;code&gt;vant&lt;/code&gt;的过程中我发现&lt;code&gt;List&lt;/code&gt;会额外触发一次&lt;code&gt;load&lt;/code&gt;事件, 这个问题可查看&lt;span&gt;\[Bug Report\] vant-list 监听的scroll事件 和 vue-router的push后维持scroll冲突&lt;/span&gt;&lt;sup&gt;[25]&lt;/sup&gt;, 该&lt;code&gt;issue&lt;/code&gt;中是路由切换导致额外触发一次&lt;code&gt;load&lt;/code&gt;, 本项目中数据多了, 导致触发了&lt;code&gt;scroll&lt;/code&gt;事件, 因此&lt;code&gt;List&lt;/code&gt;会多触发一次&lt;code&gt;load&lt;/code&gt;事件, 解决方法参考了上面提到的那个&lt;code&gt;issue&lt;/code&gt;, 同时这里贴一下关键代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;state.isRender&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;van-list&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;van-list&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt;&amp;gt;&lt;br/&gt;  &lt;span&gt;import&lt;/span&gt; { reactive } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;import&lt;/span&gt; api &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/api&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; state = reactive({&lt;br/&gt;    &lt;span&gt;data&lt;/span&gt;: [],&lt;br/&gt;    &lt;span&gt;isRender&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; fetchData = &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;    state.isRender = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; res = &lt;span&gt;await&lt;/span&gt; api.getData();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(res.code === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      state.data = res.data;&lt;br/&gt;      state.isRender = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次都初始化&lt;code&gt;List&lt;/code&gt;, 这样就不会多触发一次&lt;code&gt;load&lt;/code&gt;事件了, 具体可以查阅上面提到的那个&lt;code&gt;issue&lt;/code&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;调试工具&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我用的调试工具是&lt;span&gt;vConsole&lt;/span&gt;&lt;sup&gt;[26]&lt;/sup&gt;, 使用起来非常方便, 同时功能强大, 它在手机端页面给我们提供了类似&lt;code&gt;chrome&lt;/code&gt;中的&lt;code&gt;控制台&lt;/code&gt;, 是手机端页面调试的利器&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;组合式函数/组合式API&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要是我个人使用&lt;code&gt;vue3&lt;/code&gt;的一些记录, 不敢说写得多么好, 就只是我个人的一些方法, 由于业务逻辑并不是特别的复杂, 具体的&lt;code&gt;vue&lt;/code&gt;的使用就不展开了, 这里主要用了一些&lt;code&gt;组合式函数&lt;/code&gt;, 个人觉得它和&lt;code&gt;react&lt;/code&gt;中的&lt;code&gt;自定义hooks&lt;/code&gt;有些像, 同时文档中推荐以&lt;code&gt;use&lt;/code&gt;开头, 比如我这里用到的&lt;code&gt;useHtmlBgc.js&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { onMounted } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * @param {string} type 操作类型 set | remove&lt;br/&gt; * @param {string} color 颜色值&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; useHtmlBgc = &lt;span&gt;(&lt;span&gt;type, color = &lt;span&gt;&#x27;#f2f2f7&#x27;&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; htmlNode = &lt;span&gt;document&lt;/span&gt;.documentElement;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;set&#x27;&lt;/span&gt;) {&lt;br/&gt;    onMounted(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      htmlNode.style = &lt;span&gt;`background-color: &lt;span&gt;${color}&lt;/span&gt;;`&lt;/span&gt;;&lt;br/&gt;    });&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    htmlNode.removeAttribute(&lt;span&gt;&#x27;style&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置&lt;code&gt;html&lt;/code&gt;的背景色. 有的页面背景色和其他页面不一样, 这个时候需要单独处理一下, 然后离开那个页面的时候移除一下, 因为下一个页面的背景色和它不一样, 还是贴一下关键代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { onBeforeRouteLeave } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue-router&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { useHtmlBgc } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/utils/useHtmlBgc&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;useHtmlBgc(&lt;span&gt;&#x27;set&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;onBeforeRouteLeave(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  useHtmlBgc(&lt;span&gt;&#x27;remove&#x27;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;vue3&lt;/code&gt;官网对于&lt;code&gt;组合式函数&lt;/code&gt;有更详细的介绍, 详情可移步官方文档: &lt;span&gt;组合式函数&lt;/span&gt;&lt;sup&gt;[27]&lt;/sup&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;微信公众号网页开发&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来就是微信公众号网页开发的主要内容了, 都是我个人遇到的坑, 在此和大家分享一下, 如果能帮到大家就再好不过了&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;太长不看版&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;路由推荐使用&lt;code&gt;history&lt;/code&gt;形式的, &lt;code&gt;hash&lt;/code&gt;形式的路由最主要的影响是&lt;code&gt;url&lt;/code&gt;参数, 因为&lt;code&gt;#&lt;/code&gt;及其后面内容无法以查询字符串参数的形式传递(可使用&lt;code&gt;encodeURIComponent&lt;/code&gt;处理一下, 但&lt;code&gt;history&lt;/code&gt;形式的路由就没有这个烦恼了, 详情可查阅这个贴子: &lt;span&gt;A sharp in URL parameter&lt;/span&gt;&lt;sup&gt;[28]&lt;/sup&gt;), 如果实在是要用&lt;code&gt;hash&lt;/code&gt;形式的, 注意获取到的&lt;code&gt;code&lt;/code&gt;会在&lt;code&gt;#&lt;/code&gt;前面, 同时如果有其他参数的时候也要留意&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;签名&lt;code&gt;url&lt;/code&gt;传&lt;code&gt;window.location.href.split(&#x27;#&#x27;)[0]&lt;/code&gt;, 这也是官方文档推荐的写法, 并且留意前端传递的&lt;code&gt;url&lt;/code&gt;, 实际发起请求的&lt;code&gt;url&lt;/code&gt;, 后端用于签名的&lt;code&gt;url&lt;/code&gt;三者要一致&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;苹果手机权限验证配置的时候会以第一次进入页面的&lt;code&gt;url&lt;/code&gt;为准, 同时&lt;code&gt;jsApiList&lt;/code&gt;也会以第一次的为准, 要么提前配置所有可能用到的接口, 要么只在每次用户产生交互的时候配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取本地图片&lt;code&gt;wx.getLocalImgData&lt;/code&gt;返回的&lt;code&gt;base64&lt;/code&gt;数据需要处理一下才可用于&lt;code&gt;img&lt;/code&gt;标签显示&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网页授权流程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方文档: &lt;span&gt;微信网页开发#网页授权&lt;/span&gt;&lt;sup&gt;[29]&lt;/sup&gt;, 我这个项目的后端之前做过一个微信公众号网页开发的项目, 因此他保留了之前的代码, 而之前的项目中, 网页授权获取&lt;code&gt;code&lt;/code&gt;是后端来做, 因此我这里也就沿用了之前的做法, 即后端来做, 大致流程如下:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问&lt;code&gt;https://open.weixin.qq.com/connect/oauth2/authorize&lt;/code&gt;获取&lt;code&gt;code&lt;/code&gt;可以前端来做(前端拼地址, 官网文档上的做法), 也可以后端来做, 后端的处理方式是接收一个&lt;code&gt;url&lt;/code&gt;, 也就是文档中提到的&lt;code&gt;redirect_uri&lt;/code&gt;, 然后&lt;code&gt;302&lt;/code&gt;到&lt;code&gt;https://open.weixin.qq.com/connect/oauth2/authorize&lt;/code&gt;(后端帮忙拼), 这里需要注意&lt;code&gt;redirect_uri&lt;/code&gt;要用&lt;code&gt;encodeURIComponent&lt;/code&gt;处理一下(当使用&lt;code&gt;hash&lt;/code&gt;路由的时候尤其需要, 不然&lt;code&gt;#&lt;/code&gt;以及后面的字符将无法传递过去), 要让浏览器不把它当一个地址, 而是一个回调地址参数, 微信做跳转的时候会做解码的操作; 后端拼的话注意后端的接口不能以&lt;code&gt;ajax&lt;/code&gt;的形式调用, 而应该以&lt;code&gt;window.location.href={后端接口}&lt;/code&gt;的形式使用, 只有地址栏中的链接返回&lt;code&gt;302&lt;/code&gt;, 浏览器才会去找&lt;code&gt;响应头&lt;/code&gt;中的&lt;code&gt;Location&lt;/code&gt;做重定向, &lt;code&gt;ajax&lt;/code&gt;请求则不会&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后是获取&lt;code&gt;openid&lt;/code&gt;, 以及用户信息, 这部分操作也可以后端来做, 比如我这个项目就是后端来做的, 我获取到&lt;code&gt;code&lt;/code&gt;之后再次调后端的接口, 然后后端给我返回用户信息以及&lt;code&gt;openid&lt;/code&gt;, 具体操作文档上也比较详细, 就不再熬述了, 接下来和大家分享一下我遇到的坑&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;坑一: 登录和重定向(回调页面redirect_uri)&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;涉及到微信的&lt;code&gt;网页授权&lt;/code&gt;, 那自然是需要登录了, 我们在登录页做登录的操作, 登录成功了再走后续的逻辑&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于之前有运维小伙伴&lt;code&gt;nginx&lt;/code&gt;配&lt;code&gt;history&lt;/code&gt;路由配置了很久很久最后耽误上线的先例, 于是我把脚手架初始化的项目时候默认的&lt;code&gt;history&lt;/code&gt;路由改成了&lt;code&gt;hash&lt;/code&gt;形式的路由, 以及我从入行开始接触的前端路由的形式就一直都是&lt;code&gt;history&lt;/code&gt;形式的, 对&lt;code&gt;hash&lt;/code&gt;形式的不熟, 只知道&lt;code&gt;#&lt;/code&gt;后面的部分服务端不认, 只是浏览器认, 以为这个问题不影响, 然而这其实就是问题的答案了: &lt;code&gt;#&lt;/code&gt;及其后面的内容无法发送到服务端.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;#&lt;/code&gt;在浏览器端主要是起一个分隔定位的作用, 比如我们最常见的&lt;code&gt;页面锚点&lt;/code&gt;, 但请求后端的时候&lt;code&gt;#&lt;/code&gt;及其后面的部分是无法发送到后端的. 详情可以看看阮一峰老师的这篇文章: &lt;span&gt;URL的井号&lt;/span&gt;&lt;sup&gt;[30]&lt;/sup&gt;. 简而言之就是我传递的&lt;code&gt;#&lt;/code&gt;及其之后的参数丢失了, 目前解决方案是后端来帮我拼&lt;code&gt;#/login&lt;/code&gt;(后端&lt;code&gt;302&lt;/code&gt; &lt;code&gt;响应头&lt;/code&gt;中的&lt;code&gt;Location&lt;/code&gt;字段中是可以使用&lt;code&gt;#&lt;/code&gt;的), 不然我传过去的就成&lt;code&gt;/&lt;/code&gt;了, 就不对了, 就进不到登录页而会去到首页了. 其实最好的方式是我这边将&lt;code&gt;#&lt;/code&gt;做一个转义即可, 就是用上面提到的&lt;code&gt;encodeURIComponent&lt;/code&gt;, 但当时我并没能想到这个方法, 和项目经理(后端)聊了聊我遇到的问题之后他说他协助我来解决, 于是最终就由他那边来处理了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那具体情况是怎样的呢? 我们一起来看一下吧:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;我们在登录页: &lt;code&gt;http://xxx/#/login&lt;/code&gt;进行登录的操作, 也就是获取&lt;code&gt;code&lt;/code&gt;再获取&lt;code&gt;openid&lt;/code&gt;去进行登录的操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;登录页给后端提供的获取&lt;code&gt;code&lt;/code&gt;的接口传当前页面的&lt;code&gt;url&lt;/code&gt;, 然后去&lt;code&gt;网页授权&lt;/code&gt;获取&lt;code&gt;code&lt;/code&gt; &lt;code&gt;openid&lt;/code&gt;登录, 获取&lt;code&gt;code&lt;/code&gt;的过程会进行多次跳转, 获取到&lt;code&gt;code&lt;/code&gt;之后会带着&lt;code&gt;code&lt;/code&gt;跳转回登录页: &lt;code&gt;http://xxx/#/login?code={code}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后问题就出现了: 获取到&lt;code&gt;code&lt;/code&gt;之后不是带着&lt;code&gt;code&lt;/code&gt;跳转到登录页, 而是带着&lt;code&gt;code&lt;/code&gt;跳到了首页. 这就很奇怪了啊, 回调页面参数我明明是在登录页传的当前页面的&lt;code&gt;url&lt;/code&gt;, 也就是登录页的&lt;code&gt;url&lt;/code&gt;, 怎么会是带着&lt;code&gt;code&lt;/code&gt;跳到首页呢? 多方调试之后我才发现, 是因为&lt;code&gt;#/login&lt;/code&gt;没有传过去导致的, 也就是说, 我传递的是&lt;code&gt;http://xxx/#/login&lt;/code&gt;, 但后端收到的却是&lt;code&gt;http://xxx/&lt;/code&gt;, 因此获取到&lt;code&gt;code&lt;/code&gt;之后的跳转地址从&lt;code&gt;http://xxx/#/login&lt;/code&gt;变成了&lt;code&gt;http://xxx/&lt;/code&gt;, 也就是获取到&lt;code&gt;code&lt;/code&gt;之后带着&lt;code&gt;code&lt;/code&gt;跳转到了首页而非登录页&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;坑二: 权限验证配置(wx.config)&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题是我这个项目中遇到的最蛋疼的的问题, 我想也有不少人遇到, 因为网上各种问这个的, 也有各种解答这个的, 然后各种方式都有各种方式的道理, 但是似乎都不对, 而这正是这个问题的&quot;奇妙&quot;之处...&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;invalid signature&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我遇到的最多次的问题, 网上搜了之后发现很多人也遇到过这个问题, 遇到配置错误可参照官方文档上进行排查: &lt;span&gt;附录5-常见错误及解决方法&lt;/span&gt;&lt;sup&gt;[31]&lt;/sup&gt;, 这个问题我调了好久, 总结一下大概需要注意那么几点:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不要使用&lt;code&gt;hash&lt;/code&gt;形式的路由, &lt;code&gt;#&lt;/code&gt;和它后面部分会传不过去, 以及&lt;code&gt;网页授权&lt;/code&gt;获取&lt;code&gt;code&lt;/code&gt;的时候, 获取成功回调回来的时候&lt;code&gt;code&lt;/code&gt;参数会在&lt;code&gt;#&lt;/code&gt;之前, 这可能会对签名造成影响, 需要考虑进去&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调后端签名接口的时候传的&lt;code&gt;url&lt;/code&gt;用这个: &lt;code&gt;window.location.href.split(&#x27;#&#x27;)[0]&lt;/code&gt;(这也是官方文档中推荐的做法)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;参照&lt;span&gt;附录5-常见错误及解决方法&lt;/span&gt;&lt;sup&gt;[32]&lt;/sup&gt;中&lt;code&gt;invalid signature&lt;/code&gt;的排错步骤逐一排查&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确保传给后端的&lt;code&gt;url&lt;/code&gt;和实际发起请求的&lt;code&gt;url&lt;/code&gt;, 以及后端拿去签名的&lt;code&gt;url&lt;/code&gt;三者一致&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;苹果手机权限验证配置的时候会以第一次进入页面的&lt;code&gt;url&lt;/code&gt;为准(后面会提供可用的&lt;code&gt;js&lt;/code&gt;代码)&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传给后端的&lt;code&gt;url&lt;/code&gt;和实际发起请求的&lt;code&gt;url&lt;/code&gt;一致这个问题都比较好调试, 关键是后端拿到我们传的&lt;code&gt;url&lt;/code&gt;去签名的时候是不是就是我们传过去的&lt;code&gt;url&lt;/code&gt;, 他们有没有再加其他的参数, 我这里遇到过一次报错是因为后端之前做微信公众号网页项目的时候苹果手机需要多加一个&lt;code&gt;state=&lt;/code&gt;这样的参数才行, 然后我这个项目的时候也加了这个参数, 从而导致的报错&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及苹果手机需要特别处理一下, 下面&lt;code&gt;代码封装&lt;/code&gt;部分会详细阐述&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;the permission value is offline verifying&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我遇到另一个问题, 只是这个错是在苹果手机上遇到的, 安卓手机上并没遇到, 造成这个问题的原因是: 苹果手机权限验证配置的时候不但会以第一次进入页面的&lt;code&gt;url&lt;/code&gt;为准, &lt;code&gt;jsApiList&lt;/code&gt;也会以第一次的为准. 解决方式是: 要么提前配置所有可能用到的接口, 要么只在每次用户产生交互的时候配置&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的处理方式是前者: 提前配置所有可能用到的接口&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里需要禁用分享&lt;code&gt;hideMenuItems&lt;/code&gt;, 以及选择图片&lt;code&gt;chooseImage&lt;/code&gt;, 苹果手机提前配置二者, 然后在点击的时候就不再单独配置选择图片了, 不然就会报错: &lt;code&gt;chooseImage: the permission value is offline verifying&lt;/code&gt;, 具体的代码下面会提供&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;坑三: 获取本地图片(wx.getLocalImgData)无法显示问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择图片之后将图片转为&lt;code&gt;base64&lt;/code&gt;, 但遇到一个问题: 得到的&lt;code&gt;base64&lt;/code&gt;无法显示, 这个问题我推测是差个类型, 为什么是推测呢, 因为这个问题最终是后端解决的, 本来是我这边来处理的, 但我在调微信权限验证配置的问题, 后端刚好有空, 就他处理了. &lt;code&gt;base64&lt;/code&gt;无法转成图片, 一般就是差个类型: &lt;code&gt;data:image/jpeg;base64,&lt;/code&gt;, 这个问题需要留意&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;处理微信相关逻辑的参考代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里也贴一下我自己的代码, 欢迎小伙伴们在评论区跟我留言讨论&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;获取程序的运行平台的方法&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;getPlatform.js&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; getPlatform = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; platform = &lt;span&gt;&#x27;android&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (navigator.userAgent.includes(&lt;span&gt;&#x27;iPhone&#x27;&lt;/span&gt;)) {&lt;br/&gt;    platform = &lt;span&gt;&#x27;ios&#x27;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; platform;&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;签名的时候需要传平台参数, 因此需要判断一下当前运行平台是安卓还是&lt;code&gt;iOS&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;根据运行平台处理签名url的方法&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;handleSignatureUrlByPlatform.js&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@param &lt;span&gt;{string}&lt;/span&gt; &lt;/span&gt;type get | set&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { getPlatform } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/utils/getPlatform&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; handleSignatureUrlByPlatform = &lt;span&gt;(&lt;span&gt;type&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; url = &lt;span&gt;window&lt;/span&gt;.location.href.split(&lt;span&gt;&#x27;#&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (getPlatform() === &lt;span&gt;&#x27;ios&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;set&#x27;&lt;/span&gt;) {&lt;br/&gt;      sessionStorage.setItem(&lt;span&gt;&#x27;ios-1st-entry-url&#x27;&lt;/span&gt;, url);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      url = sessionStorage.getItem(&lt;span&gt;&#x27;ios-1st-entry-url&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; url;&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安卓手机每次路由变更都重新获取&lt;code&gt;url&lt;/code&gt;, 苹果手机使用第一次进入的&lt;code&gt;url&lt;/code&gt;, 也就是说苹果手机需要记录第一次进入程序时候的&lt;code&gt;url&lt;/code&gt;, 后续使用的时候要从&lt;code&gt;sessionStorage&lt;/code&gt;当中取, &lt;code&gt;sessionStorage&lt;/code&gt;的键名可以根据实际情况来修改, 比如在&lt;code&gt;App.vue&lt;/code&gt;中调用一下这个方法, 然后就会根据当前的环境和操作类型做处理了:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;App.vue&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { handleSignatureUrlByPlatform } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/utils/handleSignatureUrlByPlatform&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;handleSignatureUrlByPlatform(&lt;span&gt;&#x27;set&#x27;&lt;/span&gt;);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续在需要获取&lt;code&gt;url&lt;/code&gt;的代码中直接调&lt;code&gt;handleSignatureUrlByPlatform()&lt;/code&gt;或者&lt;code&gt;handleSignatureUrlByPlatform(&#x27;get&#x27;)&lt;/code&gt;使用即可&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;权限验证配置方法(wx.config)&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;handleWxConfig.js&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; wx &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;weixin-js-sdk&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; api &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/api&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { getPlatform } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/utils/getPlatform&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { handleSignatureUrlByPlatform } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/utils/handleSignatureUrlByPlatform&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; handleWxConfig = &lt;span&gt;(&lt;span&gt;jsApiList&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    api&lt;br/&gt;      .retrieveWxJsSdkConfig({&lt;br/&gt;        &lt;span&gt;platform&lt;/span&gt;: getPlatform(),&lt;br/&gt;        &lt;span&gt;url&lt;/span&gt;: handleSignatureUrlByPlatform()&lt;br/&gt;      })&lt;br/&gt;      .then(&lt;span&gt;(&lt;span&gt;res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (res.code === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;          wx.config({&lt;br/&gt;            &lt;span&gt;// 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;debug&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;appId&lt;/span&gt;: res.data.appId, &lt;span&gt;// 必填，公众号的唯一标识&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;timestamp&lt;/span&gt;: res.data.timestamp, &lt;span&gt;// 必填，生成签名的时间戳&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;nonceStr&lt;/span&gt;: res.data.nonceStr, &lt;span&gt;// 必填，生成签名的随机串&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;signature&lt;/span&gt;: res.data.signature, &lt;span&gt;// 必填，签名&lt;/span&gt;&lt;br/&gt;            jsApiList &lt;span&gt;// 必填，需要使用的 JS 接口列表&lt;/span&gt;&lt;br/&gt;          });&lt;br/&gt;          wx.ready(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; () &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;// config信息验证后会执行 ready 方法，所有接口调用都必须在 config 接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在 ready 函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在 ready 函数中。&lt;/span&gt;&lt;br/&gt;            resolve(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;          });&lt;br/&gt;          wx.error(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;res&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;// config信息验证失败会执行 error 函数，如签名过期导致验证失败，具体错误信息可以打开 config 的debug模式查看，也可以在返回的 res 参数中查看，对于 SPA 可以在这里更新签名。&lt;/span&gt;&lt;br/&gt;            reject(res);&lt;br/&gt;          });&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;          reject(res.msg);&lt;br/&gt;        }&lt;br/&gt;      });&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法只接收一个参数&lt;code&gt;jsApiList&lt;/code&gt;, 哪里需要配置哪里就调用这个方法, 同时传需要的&lt;code&gt;jsApiList&lt;/code&gt;即可. 方法内部获取签名数据的&lt;code&gt;api&lt;/code&gt;名称可以修改为自己的, 我这里是&lt;code&gt;api.retrieveWxJsSdkConfig()&lt;/code&gt;, 参数如果不一样也可以修改, 但一般都是平台参数和&lt;code&gt;url&lt;/code&gt;参数, 返回的结构一般也一样. 整个方法封装成了&lt;code&gt;Promise&lt;/code&gt;, 外部使用的时候方便以同步的形式来处理异步逻辑&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;选择图片(chooseImage)和获取本地图片(getLocalImgData)的方法&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要是将它们封装成了&lt;code&gt;Promise&lt;/code&gt;, 便于使用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;handleWxChooseImg.js&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; wx &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;weixin-js-sdk&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; handleWxChooseImg = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    wx.chooseImage({&lt;br/&gt;      &lt;span&gt;count&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;// 默认9&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;sizeType&lt;/span&gt;: [&lt;span&gt;&#x27;original&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;compressed&#x27;&lt;/span&gt;], &lt;span&gt;// 可以指定是原图还是压缩图，默认二者都有&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;sourceType&lt;/span&gt;: [&lt;span&gt;&#x27;album&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;camera&#x27;&lt;/span&gt;], &lt;span&gt;// 可以指定来源是相册还是相机，默认二者都有&lt;/span&gt;&lt;br/&gt;      success(res) {&lt;br/&gt;        resolve(res);&lt;br/&gt;        &lt;span&gt;// 返回选定照片的本地 ID 列表，localId可以作为 img 标签的 src 属性显示图片&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// var localIds = res.localIds;&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;      fail(error) {&lt;br/&gt;        reject(error);&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;handleWxGetLocalImgData.js&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; wx &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;weixin-js-sdk&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; handleWxGetLocalImgData = &lt;span&gt;(&lt;span&gt;localId&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;//获取本地图片&lt;/span&gt;&lt;br/&gt;    wx.getLocalImgData({&lt;br/&gt;      localId, &lt;span&gt;// 图片的localID&lt;/span&gt;&lt;br/&gt;      success(res) {&lt;br/&gt;        &lt;span&gt;// res.localData是图片的base64数据，可以用 img 标签显示&lt;/span&gt;&lt;br/&gt;        resolve(res);&lt;br/&gt;      },&lt;br/&gt;      error(error) {&lt;br/&gt;        reject(error);&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;人脸认证方法(选择图片之后将图片转为base64)&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里由于业务方的缘故, 因此并没有真正的做人脸认证, 只是简单得选一张图片或者拍个照传给后端&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;handleFaceAuth.js&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { handleWxChooseImg } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/utils/handleWxChooseImg&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { handleWxGetLocalImgData } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/utils/handleWxGetLocalImgData&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//选择图片(拍照/相册), 接着转为本地图片数据, 然后将本地图片数据返回出去&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; handleFaceAuth = &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; res1 = &lt;span&gt;await&lt;/span&gt; handleWxChooseImg();&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; res2 = &lt;span&gt;await&lt;/span&gt; handleWxGetLocalImgData(res1.localIds[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res2;&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.reject(error);&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果前端来处理&lt;code&gt;base64&lt;/code&gt;无法显示的问题, 那么这里的&lt;code&gt;res2.localData&lt;/code&gt;就需要处理一下了, 这里写一下伪代码, 仅供参考:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; res1 = &lt;span&gt;await&lt;/span&gt; handleWxChooseImg();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; res2 = &lt;span&gt;await&lt;/span&gt; handleWxGetLocalImgData(res1.localIds[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (res2.localData.indexOf(&lt;span&gt;&#x27;data:image&#x27;&lt;/span&gt;) === &lt;span&gt;-1&lt;/span&gt;) {&lt;br/&gt;    res2.localData = &lt;span&gt;`data:image/jpeg;base64,&lt;span&gt;${res2.localData}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; res2;&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.reject(error);&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时这里需要注意的是&lt;code&gt;try...catch...&lt;/code&gt;语句中的&lt;code&gt;catch&lt;/code&gt;捕获到的&lt;code&gt;error&lt;/code&gt;是&lt;code&gt;try&lt;/code&gt;代码块中抛出的第一个错误, 而这里具体指的是&lt;code&gt;Promise&lt;/code&gt; &lt;code&gt;reject&lt;/code&gt;的结果, 也就是&lt;code&gt;Promise&lt;/code&gt;构造函数中&lt;code&gt;reject&lt;/code&gt;方法中接收的参数, 但如果&lt;code&gt;async&lt;/code&gt;函数中直接&lt;code&gt;return&lt;/code&gt;这个&lt;code&gt;error&lt;/code&gt;的话得到的将是&lt;code&gt;resolve&lt;/code&gt;的结果, 而不是&lt;code&gt;reject&lt;/code&gt;结果, 也就是说这么做会导致&lt;code&gt;async&lt;/code&gt;函数返回的&lt;code&gt;Promise&lt;/code&gt;的状态是&lt;code&gt;fulfilled&lt;/code&gt;, 要想得到&lt;code&gt;rejected&lt;/code&gt;的结果, 必须使用&lt;code&gt;Promise.reject&lt;/code&gt;方法处理一下: &lt;code&gt;return Promise.reject(error)&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而具体使用自然是应该先进行配置&lt;code&gt;wx.config&lt;/code&gt;, 然后再使用, 例如:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; handleClick = &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; handleWxConfig([&lt;span&gt;&#x27;chooseImage&#x27;&lt;/span&gt;]);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; res = &lt;span&gt;await&lt;/span&gt; handleFaceAuth();&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;async&lt;/code&gt;方法里面的&lt;code&gt;await&lt;/code&gt;会依次执行, 当且仅当第一个&lt;code&gt;await&lt;/code&gt;之后的&lt;code&gt;Promise&lt;/code&gt; &lt;code&gt;resolve&lt;/code&gt;了, 确切的说是状态变成了&lt;code&gt;fulfilled&lt;/code&gt;之后, 第一个&lt;code&gt;await&lt;/code&gt;之后的代码才会执行, 也就是说当这个&lt;code&gt;Promise&lt;/code&gt;的状态是&lt;code&gt;pending&lt;/code&gt;或者&lt;code&gt;rejected&lt;/code&gt;的时候, 它后面的代码一定不会执行. &lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;fulfilled&lt;/code&gt;则后续代码正常执行, &lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;rejected&lt;/code&gt;则后续代码不执行, 且会抛出错误, 这个错误可以由&lt;code&gt;try...catch...&lt;/code&gt;语句中的&lt;code&gt;catch&lt;/code&gt;捕获, 因此上面的写法和下面这个写法是等价的:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; handleClick = &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; isSuccess = &lt;span&gt;await&lt;/span&gt; handleWxConfig([&lt;span&gt;&#x27;chooseImage&#x27;&lt;/span&gt;]);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(isSuccess) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; res = &lt;span&gt;await&lt;/span&gt; handleFaceAuth();&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;全局导航守卫(afterEach)处理微信权限验证配置(wx.config)设置微信分享&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于所有页面都需禁止分享&lt;code&gt;hideMenuItems&lt;/code&gt;, 因此可以考虑在&lt;code&gt;全局导航守卫&lt;/code&gt;中处理, 然后选择图片&lt;code&gt;chooseImage&lt;/code&gt;的话用户每次点击的时候再进行配置, 当然了, 需要区分一下安卓和苹果手机, 具体代码如下:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路由配置文件中, 关键代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { getPlatform } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/utils/getPlatform&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { handleWxConfig } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/utils/handleWxConfig&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;router.afterEach(&lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;//所有页面都要隐藏分享相关按钮&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; finalJsApiList =&lt;br/&gt;    getPlatform() === &lt;span&gt;&#x27;ios&#x27;&lt;/span&gt;&lt;br/&gt;      ? [&lt;span&gt;&#x27;hideMenuItems&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;chooseImage&#x27;&lt;/span&gt;]&lt;br/&gt;      : [&lt;span&gt;&#x27;hideMenuItems&#x27;&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; handleWxConfig(finalJsApiList);&lt;br/&gt;  wx.hideMenuItems({&lt;br/&gt;    &lt;span&gt;menuList&lt;/span&gt;: [&lt;br/&gt;      &lt;span&gt;&#x27;menuItem:share:appMessage&#x27;&lt;/span&gt;, &lt;span&gt;//发送给朋友&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&#x27;menuItem:share:timeline&#x27;&lt;/span&gt;, &lt;span&gt;//分享到朋友圈&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&#x27;menuItem:share:qq&#x27;&lt;/span&gt;, &lt;span&gt;//分享到QQ&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&#x27;menuItem:share:weiboApp&#x27;&lt;/span&gt;, &lt;span&gt;//分享到Weibo&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&#x27;menuItem:share:facebook&#x27;&lt;/span&gt;, &lt;span&gt;//分享到FB&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&#x27;menuItem:share:QZone&#x27;&lt;/span&gt; &lt;span&gt;//分享到 QQ 空间&lt;/span&gt;&lt;br/&gt;    ]&lt;br/&gt;  });&lt;br/&gt;});&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;苹果手机提前配置; 安卓手机只配置禁止分享&lt;code&gt;hideMenuItems&lt;/code&gt;, 后续用户点击的时候再单独配置选择图片&lt;code&gt;chooseImage&lt;/code&gt;即可&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要留意一下, 微信分享需要每个页面都配置, 比如只在&lt;code&gt;A&lt;/code&gt;页面配置, 那么在&lt;code&gt;A&lt;/code&gt;页面分享是正常的, 但换到&lt;code&gt;B&lt;/code&gt;页面, 然后在&lt;code&gt;B&lt;/code&gt;页面分享的话分享就不正常了, 就没法获取描述和&lt;code&gt;logo&lt;/code&gt;图片了, 但是每个页面都配置代码就比较冗余, 此时也可以在&lt;code&gt;全局导航守卫&lt;/code&gt;中处理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里也贴一下关键代码:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;handleWxShare.js&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; wx &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;weixin-js-sdk&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//需要在微信签名配置成功之后调用, 这个分享包括分享给朋友和分享到朋友圈, 以及签名的时候记得配置分享相关的jsApiList&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; handleWxShare = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; title = &lt;span&gt;&#x27;分享的标题&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; desc = &lt;span&gt;&#x27;分享的描述&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; link = &lt;span&gt;import&lt;/span&gt;.meta.env.VITE_WXSHARE_LINK;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; imgUrl = &lt;span&gt;import&lt;/span&gt;.meta.env.VITE_WXSHARE_IMG_URL;&lt;br/&gt;  wx.updateAppMessageShareData({&lt;br/&gt;    title, &lt;span&gt;// 分享标题&lt;/span&gt;&lt;br/&gt;    desc, &lt;span&gt;// 分享描述&lt;/span&gt;&lt;br/&gt;    link, &lt;span&gt;// 分享链接，该链接域名或路径必须与当前页面对应的公众号 JS 安全域名一致&lt;/span&gt;&lt;br/&gt;    imgUrl, &lt;span&gt;// 分享图标&lt;/span&gt;&lt;br/&gt;    success() {&lt;br/&gt;      &lt;span&gt;// 设置成功&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;“分享给朋友”及“分享到QQ”按钮的分享内容设置成功&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;  wx.updateTimelineShareData({&lt;br/&gt;    title, &lt;span&gt;// 分享标题&lt;/span&gt;&lt;br/&gt;    link, &lt;span&gt;// 分享链接，该链接域名或路径必须与当前页面对应的公众号 JS 安全域名一致&lt;/span&gt;&lt;br/&gt;    imgUrl, &lt;span&gt;// 分享图标&lt;/span&gt;&lt;br/&gt;    success() {&lt;br/&gt;      &lt;span&gt;// 设置成功&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;“分享到朋友圈”及“分享到 QQ 空间”按钮的分享内容设置成功&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;title&lt;/code&gt;和&lt;code&gt;desc&lt;/code&gt;一般是固定的, &lt;code&gt;link&lt;/code&gt;和&lt;code&gt;imgUrl&lt;/code&gt;可能会因为发布的环境不同而不同, 比如生产环境和测试环境, 因此我把这两个参数写成了环境变量, 具体的使用也是要在配置之后进行:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;router.afterEach(&lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; handleWxConfig([&lt;br/&gt;    &lt;span&gt;&#x27;updateAppMessageShareData&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&#x27;updateTimelineShareData&#x27;&lt;/span&gt;&lt;br/&gt;  ]);&lt;br/&gt;  handleWxShare();&lt;br/&gt;});&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的, 这就是这篇文章的全部内容了, 欢迎大家在评论区和我一起交流探讨, 最后, 如果你觉得这篇文章写得还不错, 别忘了给我点个赞, 如果你觉得对你有帮助, 可以点个收藏, 以备不时之需&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>