<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>af7778062c07d071b10cb4bb566deca3</guid>
<title>Ghost 解决 jsdelivr 资源加载慢的问题</title>
<link>https://toutiao.io/k/x82yflm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;toc-content post tag-ghost-tag tag-network no-image&quot;&gt;
      &lt;h2 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;用了很久的自建 Ghost 博客系统不知道从哪个版本开始，页面加载速度忽然变慢了很多。看了下加载的资源，发现多了很多走 jsdelivr cdn 的资源，加载速度竟然长达半分钟。。。&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2023/01/image-10.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;本来选择自建博客系统的重要目的之一就是为了页面加载速度可控，尽量避免加载不可靠、容易被墙的第三方资源。结果没想到 Ghost 官方又在核心模块里引用了第三方的 CDN。&lt;/p&gt;&lt;p&gt;不过还好 Ghost 项目本身的配置化做的还是不错的，大年初六上班摸个鱼的时间解决了一下。&lt;/p&gt;&lt;h2 id=&quot;%E8%A7%A3%E5%86%B3&quot;&gt;解决&lt;/h2&gt;&lt;p&gt;仔细看了下，新加入的走 CDN 的资源主要是 会员系统（portal）+评论系统（comments）+页面搜索 （sodo-search），因此在某次支持这些系统的更新前都是没问题的。不过考虑到目前的主题已经集成了这些系统，所以这些功能也不能禁用掉。&lt;/p&gt;&lt;p&gt;参考 &lt;a href=&quot;https://forum.ghost.org/t/is-it-possible-to-disable-jsdelivr-cdn/31761&quot;&gt;Ghost Forum&lt;/a&gt; 的这篇讨论，可以通过在 config.[env].json 中修改配置，将 url 等替换成 self-hosted 的版本。不过这里的讨论中提到的配置来源并不清晰，在源码中搜索了一番发现了端倪（这里的 /var/lib/ghost 目录是我这 docker 里的 ghost 安装目录）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@1f7b379a87f4:/var/lib/ghost/current# grep -r &#x27;cdn.jsdelivr.net/ghost&#x27; *
core/shared/config/defaults.json:        &quot;url&quot;: &quot;https://cdn.jsdelivr.net/ghost/portal@~{version}/umd/portal.min.js&quot;,
core/shared/config/defaults.json:        &quot;url&quot;: &quot;https://cdn.jsdelivr.net/ghost/sodo-search@~{version}/umd/sodo-search.min.js&quot;,
core/shared/config/defaults.json:        &quot;styles&quot;: &quot;https://cdn.jsdelivr.net/ghost/sodo-search@~{version}/umd/main.css&quot;,
core/shared/config/defaults.json:        &quot;url&quot;: &quot;https://cdn.jsdelivr.net/ghost/comments-ui@~{version}/umd/comments-ui.min.js&quot;,
core/shared/config/defaults.json:        &quot;styles&quot;: &quot;https://cdn.jsdelivr.net/ghost/comments-ui@~{version}/umd/main.css&quot;,&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可见这些配置都来源于 &lt;code&gt;core/shared/config/defaults.json&lt;/code&gt; 这个文件，涉及到 CDN 的相关配置如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{

    ...

    &quot;portal&quot;: {
        &quot;url&quot;: &quot;https://cdn.jsdelivr.net/ghost/portal@~{version}/umd/portal.min.js&quot;,
        &quot;version&quot;: &quot;2.23&quot;
    },
    &quot;sodoSearch&quot;: {
        &quot;url&quot;: &quot;https://cdn.jsdelivr.net/ghost/sodo-search@~{version}/umd/sodo-search.min.js&quot;,
        &quot;styles&quot;: &quot;https://cdn.jsdelivr.net/ghost/sodo-search@~{version}/umd/main.css&quot;,
        &quot;version&quot;: &quot;1.1&quot;
    },
    &quot;comments&quot;: {
        &quot;url&quot;: &quot;https://cdn.jsdelivr.net/ghost/comments-ui@~{version}/umd/comments-ui.min.js&quot;,
        &quot;styles&quot;: &quot;https://cdn.jsdelivr.net/ghost/comments-ui@~{version}/umd/main.css&quot;,
        &quot;version&quot;: &quot;0.12&quot;
    },
    
    ...

 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了自托管这些文件，我们首先将这些文件下载到静态文件夹下，然后在想办法将 config.[env].json 配置好即可。&lt;/p&gt;&lt;p&gt;不过问题来了，静态文件夹有哪些？如果想当然的放在 &lt;code&gt;/var/lib/ghost/content/public&lt;/code&gt; 下，肯定是要吃瘪的。正解应该是要看下 &lt;code&gt;/var/lib/ghost/current/core/frontend/web/site.js&lt;/code&gt; 这里启动 express 的地方：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;module.exports = function setupSiteApp(routerConfig) {
    debug(&#x27;Site setup start&#x27;, routerConfig);

    const siteApp = express(&#x27;site&#x27;);

    //...
    
    // Serve sitemap.xsl file
    siteApp.use(mw.servePublicFile(&#x27;static&#x27;, &#x27;sitemap.xsl&#x27;, &#x27;text/xsl&#x27;, config.get(&#x27;caching:sitemapXSL:maxAge&#x27;)));

    // Serve stylesheets for default templates
    siteApp.use(mw.servePublicFile(&#x27;static&#x27;, &#x27;public/ghost.css&#x27;, &#x27;text/css&#x27;, config.get(&#x27;caching:publicAssets:maxAge&#x27;)));
    siteApp.use(mw.servePublicFile(&#x27;static&#x27;, &#x27;public/ghost.min.css&#x27;, &#x27;text/css&#x27;, config.get(&#x27;caching:publicAssets:maxAge&#x27;)));

    // Card assets
    siteApp.use(mw.servePublicFile(&#x27;built&#x27;, &#x27;public/cards.min.css&#x27;, &#x27;text/css&#x27;, config.get(&#x27;caching:publicAssets:maxAge&#x27;)));
    siteApp.use(mw.servePublicFile(&#x27;built&#x27;, &#x27;public/cards.min.js&#x27;, &#x27;application/javascript&#x27;, config.get(&#x27;caching:publicAssets:maxAge&#x27;)));

    // Comment counts
    siteApp.use(mw.servePublicFile(&#x27;built&#x27;, &#x27;public/comment-counts.min.js&#x27;, &#x27;application/javascript&#x27;, config.get(&#x27;caching:publicAssets:maxAge&#x27;)));

    // Member attribution
    siteApp.use(mw.servePublicFile(&#x27;built&#x27;, &#x27;public/member-attribution.min.js&#x27;, &#x27;application/javascript&#x27;, config.get(&#x27;caching:publicAssets:maxAge&#x27;)));

    // Serve site images using the storage adapter
    siteApp.use(STATIC_IMAGE_URL_PREFIX, mw.handleImageSizes, storage.getStorage(&#x27;images&#x27;).serve());
    // Serve site media using the storage adapter
    siteApp.use(STATIC_MEDIA_URL_PREFIX, storage.getStorage(&#x27;media&#x27;).serve());
    // Serve site files using the storage adapter
    siteApp.use(STATIC_FILES_URL_PREFIX, storage.getStorage(&#x27;files&#x27;).serve());
    
    //...
};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然，这里 public 文件夹下的文件都是单独配置绑定的，不是整个文件夹的绑定。额外添加文件的话是不会映射到外部路径上的。这样一来，我们只能绑定在 images , media , files 这些路径下。再 check 下这些具体的变量，就会得知这些路径映射到的外部路径：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@1f7b379a87f4:/var/lib/ghost/current# grep -r &#x27;STATIC_.*_URL_PREFIX&#x27; *
...
node_modules/@tryghost/constants/index.js:    STATIC_IMAGES_URL_PREFIX: &#x27;content/images&#x27;,
node_modules/@tryghost/constants/index.js:    STATIC_MEDIA_URL_PREFIX: &#x27;content/media&#x27;,
node_modules/@tryghost/constants/index.js:    STATIC_FILES_URL_PREFIX: &#x27;content/files&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我这里就选择放在  files 文件夹下，这里新建一个 self-host 文件夹：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@1f7b379a87f4:/var/lib/ghost/content/files/self-host# ls
comments-ui-0.12.css  comments-ui-0.12.min.js  portal-2.23.min.js  sodo-search-1.1.css  sodo-search-1.1.min.js&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于我是通过 docker-compose 部署，相比于修改 config 文件，直接通过环境变量配置更为方便，变量名跟 config 中的 json 格式一一对应，这里不得不夸奖下 Ghost 的配置自动映射做的挺方便：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;version: &quot;3.8&quot;
services:
  ghost:
  image: ghost:5.27
  container_name: &quot;ghost&quot;
  environment:
    ...
    portal__url: /content/files/self-host/portal-2.23.min.js
    sodoSearch__url: /content/files/self-host/sodo-search-1.1.min.js
    sodoSearch__styles: /content/files/self-host/sodo-search-1.1.css
    comments__url: /content/files/self-host/comments-ui-0.12.min.js
    comments__styles: /content/files/self-host/comments-ui-0.12.css
  ...&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;%E6%95%88%E6%9E%9C&quot;&gt;效果&lt;/h2&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2023/01/image-11.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首次加载速度直接从 30s 优化到了 300ms ，优化效果十分感人。。。&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ab4658c033d1ce0081581c4ef66a4ab</guid>
<title>12款开源的低代码开发平台，建议收藏</title>
<link>https://toutiao.io/k/ulwrd25</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>386ae107e1f6fed7529c0069419a03d4</guid>
<title>12 个非常实用的 JavaScript 函数</title>
<link>https://toutiao.io/k/ucrol6p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;生成随机颜色&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的网站是否需要生成随机颜色？下面一行代码就可以实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; generateRandomHexColor = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;`#&lt;span&gt;${&lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;0xffffff&lt;/span&gt;).toString(&lt;span&gt;16&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(generateRandomHexColor())&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数组重排序&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对数组的元素进行重新排序是一项非常重要的技巧，但是原生 Array 中并没有这项功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; shuffle = &lt;span&gt;(&lt;span&gt;arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; arr.sort(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.random() - &lt;span&gt;0.5&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(shuffle(arr))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;复制到剪切板&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复制到剪切板是一项非常实用且能够提高用户便利性的功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; copyToClipboard = &lt;span&gt;(&lt;span&gt;text&lt;/span&gt;) =&amp;gt;&lt;/span&gt; navigator.clipboard &amp;amp;&amp;amp; navigator.clipboard.writeText &amp;amp;&amp;amp; navigator.clipboard.writeText(text)&lt;br/&gt;&lt;br/&gt;copyToClipboard(&lt;span&gt;&quot;Hello World!&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检测暗色主题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;暗色主题日益普及，很多用的都会在设备中启用案模式，我们将应用程序切换到暗色主题可以提高用户体验度。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; isDarkMode = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;window&lt;/span&gt;.matchMedia &amp;amp;&amp;amp; &lt;span&gt;window&lt;/span&gt;.matchMedia(&lt;span&gt;&quot;(prefers-color-scheme: dark)&quot;&lt;/span&gt;).matches;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(isDarkMode())&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;滚动到顶部&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将元素滚动到顶部最简单的方法是使用&lt;code&gt;scrollIntoView&lt;/code&gt;。设置&lt;code&gt;block&lt;/code&gt;为&lt;code&gt;start&lt;/code&gt;可以滚动到顶部；设置&lt;code&gt;behavior&lt;/code&gt;为&lt;code&gt;smooth&lt;/code&gt;可以开启平滑滚动。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; scrollToTop = &lt;span&gt;(&lt;span&gt;element&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;br/&gt;  element.scrollIntoView({ &lt;span&gt;behavior&lt;/span&gt;: &lt;span&gt;&quot;smooth&quot;&lt;/span&gt;, &lt;span&gt;block&lt;/span&gt;: &lt;span&gt;&quot;start&quot;&lt;/span&gt; });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;滚动到底部&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与滚动到顶部一样，滚动到底部只需要设置&lt;code&gt;block&lt;/code&gt;为&lt;code&gt;end&lt;/code&gt;即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; scrollToBottom = &lt;span&gt;(&lt;span&gt;element&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;br/&gt;  element.scrollIntoView({ &lt;span&gt;behavior&lt;/span&gt;: &lt;span&gt;&quot;smooth&quot;&lt;/span&gt;, &lt;span&gt;block&lt;/span&gt;: &lt;span&gt;&quot;end&quot;&lt;/span&gt; });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检测元素是否在屏幕中&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;检查元素是否在窗口中最好的方法是使用&lt;code&gt;IntersectionObserver&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; callback = &lt;span&gt;(&lt;span&gt;entries&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  entries.forEach(&lt;span&gt;(&lt;span&gt;entry&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (entry.isIntersecting) {&lt;br/&gt;      &lt;span&gt;// `entry.target` is the dom element&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`&lt;span&gt;${entry.target.id}&lt;/span&gt; is visible`&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; options = {&lt;br/&gt;  &lt;span&gt;threshold&lt;/span&gt;: &lt;span&gt;1.0&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; observer = &lt;span&gt;new&lt;/span&gt; IntersectionObserver(callback, options);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; btn = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;btn&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bottomBtn = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&quot;bottom-btn&quot;&lt;/span&gt;);&lt;br/&gt;observer.observe(btn);&lt;br/&gt;observer.observe(bottomBtn);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检测设备&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;navigator.userAgent&lt;/code&gt;来检测网站运行在哪种平台设备上。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; detectDeviceType = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i&lt;/span&gt;.test(&lt;br/&gt;    navigator.userAgent&lt;br/&gt;  ) ? &lt;span&gt;&quot;Mobile&quot;&lt;/span&gt; : &lt;span&gt;&quot;Desktop&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(detectDeviceType());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;隐藏元素&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以将元素的&lt;code&gt;style.visibility&lt;/code&gt;设置为&lt;code&gt;hidden&lt;/code&gt;，隐藏元素的可见性，但元素的空间仍然会被占用。如果设置元素的&lt;code&gt;style.display&lt;/code&gt;为&lt;code&gt;none&lt;/code&gt;，会将元素从渲染流中删除。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; hideElement = &lt;span&gt;(&lt;span&gt;el, removeFromFlow = &lt;span&gt;false&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  removeFromFlow ? (el.style.display = &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;)&lt;br/&gt;  : (el.style.visibility = &lt;span&gt;&#x27;hidden&#x27;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;从 URL 中获取参数&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JavaScript 中有一个 URL 对象，通过它可以非常方便的获取 URL 中的参数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; getParamByUrl = &lt;span&gt;(&lt;span&gt;key&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; url = &lt;span&gt;new&lt;/span&gt; URL(location.href)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; url.searchParams.get(key)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;深拷贝对象&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;深拷贝对象非常简单，先将对象转换为字符串，再转换成对象即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deepCopy = &lt;span&gt;&lt;span&gt;obj&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;JSON&lt;/span&gt;.parse(&lt;span&gt;JSON&lt;/span&gt;.stringify(obj))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了利用 JSON 的 API，还有更新的深拷贝对象的 structuredClone API，但并不是在所有的浏览器中都支持。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;structuredClone(obj)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;等待函数&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JavaScript 提供了&lt;code&gt;setTimeout&lt;/code&gt;函数，但是它并不返回 Promise 对象，所以我们没办法使用 &lt;code&gt;async&lt;/code&gt; 作用在这个函数上，但是我们可以封装等待函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; wait = &lt;span&gt;(&lt;span&gt;ms&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve&lt;/span&gt;)=&amp;gt;&lt;/span&gt; setTimeout(resolve, ms))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; asyncFn = &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; wait(&lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;等待异步函数执行结束&#x27;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;asyncFn()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感谢你的阅读，如果本文对你有所帮助，不妨点个赞吧。&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;51&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;作者 | 代码与野兽&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://juejin.cn/post/7127278574033174542&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>febb4944956a7278c27840ebc17ec182</guid>
<title>gRPC 初体验</title>
<link>https://toutiao.io/k/3yau4u1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;strong&gt;&lt;span&gt;一、简单介绍RPC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;RPC（Remote Procedure Call）&lt;/span&gt;&lt;span&gt;远程过程调用&lt;/span&gt;&lt;span&gt;，它允许在一台服务器程序中调用另一台服务器上的子程序。RPC采用了&lt;/span&gt;&lt;span&gt;代理模式&lt;/span&gt;&lt;span&gt;从而屏蔽了网络之间的调用细节，使得调用远程函数就像调用本地程序一样简单。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RPC它包含了&lt;/span&gt;&lt;span&gt;接口规范&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;传输协议&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;数据序列化反序列化&lt;/span&gt;&lt;span&gt;规范。它可以基于HTTP或TCP协议之上来构建RPC协议，其各自都有优缺点。Google选择将GRPC定义在HTTP/2通信协议之上。GRPC的优势由HTTP/2和Protobuf继承而来。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Dubbo 国内最早的RPC框架、偏向服务治理、阿里巴巴开源支持java语言&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Motan 微博内部使用的RPC框架、2016年开源仅支持java语言&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Tars 腾讯内部使用的RPC框架、2017年开源仅支持C++语言&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Spring Cloud 国外Pivotal公司于2014年开源、仅支持java语言&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;span&gt; Google于2015年开源的跨语言RPC框架、支持多种语言&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Thrift Apache开源项目之一（原Facebook）、支持多种语言&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、什么是gRPC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gRPC 是由Google开发的一个高性能、开源、跨语言使用的RPC框架。主要基于&lt;/span&gt;&lt;span&gt;HTTP/2&lt;/span&gt;&lt;span&gt;通信协议标准设计，基于&lt;/span&gt;&lt;span&gt;Protobuf&lt;/span&gt;&lt;span&gt;（Protocol Buffers ）序列化协议开发，采用&lt;/span&gt;&lt;span&gt;IDL文件定义&lt;/span&gt;&lt;span&gt;服务而设计，同时支持大多数主流的编程语言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IDL接口描述语言&lt;/span&gt;&lt;span&gt;(Internal Define Language) 使用的是protobuf，通过proto3工具生成指定语言的数据结构、服务端接口以及客户端接口的存根(Stub)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Protobuf 作为轻量级的结构化数据存储格式，可以用于结构化、数据序列化、即时通讯、数据存储等领域。它是与语言无关、平台无关、可扩展的序列化结构数据格式，其功能类似于json、xml。但是Protobuf 比它们更小、更快、更简单，所以Protobuf 更适合RPC作为数据交换格式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Protobuf的核心内容&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;定义接口：接口路径和参数，以service标识&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;定义消息：消息的结构体，以message标识&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;通过Protobuf提供的机制，服务端与服务端之间只需要关注接口方法名（service）和参数（message）即可通信，而不需关注繁琐的链路协议和字段解析，极大降低了服务端的设计开发成本。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;通信协议&lt;/span&gt;&lt;span&gt;使用的是HTTP/2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，其特点如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;HTTP/2采用的是&lt;/span&gt;&lt;span&gt;二进制&lt;/span&gt;&lt;span&gt;格式的&lt;/span&gt;&lt;span&gt;传输协议&lt;/span&gt;&lt;span&gt;，而不是HTTP/1.x的文本格式，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持多路&lt;/span&gt;&lt;span&gt;复用&lt;/span&gt;&lt;span&gt;，即通过一个连接发送多个并发的请求。而HTTP/1.x虽然可以通过pipeline实现并发请求，但是多个请求之间的响应仍会被阻塞。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持&lt;/span&gt;&lt;span&gt;服务端推送&lt;/span&gt;&lt;span&gt;，即客户端发送一个请求，服务器可以对客户端发送多个响应。而不像HTTP/1.x只能通过客户端发起请求，服务端才响应。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持&lt;/span&gt;&lt;span&gt;头部压缩&lt;/span&gt;&lt;span&gt;，HTTP/2对传输的消息头进行了压缩传输，节省了头部在网络传输过程所占用的网络流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;gRPC基于HTTP/2对流传输提供了如下几种支持，在后面的案例也是基于这几种流式体验的。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Unary RP，一元RPC&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Server-side streaming RPC，服务端流式RPC&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Client-side streaming RPC，客户端流式RPC&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Bidirectional streaming RP，双向流式RPC&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;gRPC的调用模型：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;275&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWX77NKmYzyXRM94NQ4r9f5LQuOC8tTj0NMbrgvlXFF1YO0DXDBRbZlBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大致介绍一下流转的流程：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;客户端（gRPC Stub）调用 A 方法，发起 RPC 调用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对请求信息使用 Protobuf 进行对象序列化压缩（IDL）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务端（gRPC Server）接收到请求后，解码请求体，进行业务逻辑处理并返回&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对响应结果使用 Protobuf 进行对象序列化压缩（IDL）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;客户端接受到服务端响应，解码请求体。回调被调用的 A 方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、准备Protobuf环境&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）安装Protobuf的编译器protoc&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;brew search protobuf&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;brew install protobuf&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;protoc --versio&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;467&quot; data-backw=&quot;561&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8315617334423548&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWXRRtgaBxL8pVSVuRL3DbGQP2AkkaK4lUl0NxWKbrLlSboRd46LZEj4g/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1223&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2) 安装go语言的protobuf插件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：从google.golang.org官网下载 网上很多资源是旧版本的地址github上，目前已经被google收录管辖。其生成的.proto文件也跟之前的不同，甚至会报错。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;go&lt;/span&gt; install google.golang.org/grpc/cmd/protoc-gen-&lt;span&gt;go&lt;/span&gt;-grpc@v1&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;go&lt;/span&gt; install google.golang.org/protobuf/cmd/protoc-gen-&lt;span&gt;go&lt;/span&gt;@v1&lt;span&gt;.28&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;297&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5132575757575758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWXBrA3IFN5MiaVG8uC8Wpr5zBiaJ0MarPZVozbBYQuALAFK5mP7dWggtqQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;插件的安装路径在go/bin目录下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;311&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5383177570093458&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWX5t6MucN9jib86byt6hgvwRuibpF6s5MMJicJ5PreDiaYOYJeXDPWIAGSkQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1070&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）修改环境变量使得全局可用&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;vi .zshrc&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;export GO_PATH=~/&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;export PATH=$PATH:/$GO_PATH/bin&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;source ~/.zshrc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;四、gRPC初体验&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1）创建一个项目目录，其结构如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;314&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5428082191780822&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWX3thCkW3Cn7kianS8AZaQ5Nr0ic7QLfWBOjCDTmfqkspibzy60LnEXfNWQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）在protolist.proto文件中定义gRPC服务、方法请求、响应类型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先指定proto的版本，默认是proto2版本，我们需要手动指定版本为proto3类型（可以了解一下proto2 和 proto3的区别）且需要写在第一行。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;syntax = &lt;span&gt;&quot;proto3&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;然后指定生成的go文件在哪个目录中，已经包的命名空间是什么，使用分号分割。（.）表示当前目录，其包名为（proto）可随意取，&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;option go_package = &lt;span&gt;&quot;.;proto&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面也说过Protobuf的核心内容有两个：&lt;/span&gt;&lt;span&gt;service 和 message&lt;/span&gt;&lt;span&gt;，即&lt;/span&gt;&lt;span&gt;定义服务接口和消息&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定义服务和服务的方法&lt;/span&gt;&lt;span&gt;，gRPC支持四种服务：一元RPC、服务端流式RPC、客户端流式RPC、双向流式RPC。那就先体验双向流式PRC吧。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;service Greeter {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;//双向流式RPC&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    rpc SayRoute(stream HelloRequest) returns (stream HelloReply) {}&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面的代码定义了一个名字为Greeter的服务，里面包含了一个双向流式的RPC方法。其意味着，双方可以使用读写流发送一系列消息。注意，这两个流独立运行，在客户端和服务端可以按照任意的顺序读取和写入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定义消息类型&lt;/span&gt;&lt;span&gt;，请求的消息类型以及请求响应的消息类型&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;message HelloRequest {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;string&lt;/span&gt; name = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;}&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;message HelloReply {&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;    &lt;span&gt;string&lt;/span&gt; message = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这段代码看着就很眼熟呀，有点像结构体。不过人家叫消息体，消息体内的类型支持多种，这里就不列举了，可以自行查阅。其中 name=1 也不是为了赋值，它表示此变量在消息体内的位置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后在当前目录下执行如下命令：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;protoc --go_out=. --go_opt=paths=source_relative --&lt;span&gt;go&lt;/span&gt;-grpc_out=. --&lt;span&gt;go&lt;/span&gt;-grpc_opt=paths=source_relative .&lt;span&gt;/*.proto&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;此时，会在当前目录下生成以下go文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;431&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7452229299363057&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWXxfxJrUn3OQdn4AFbIvtyqy2A3vxeTmvpxshpzAYD4ZoYxI0s3llofA/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;protolist.pb.go&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;protolist_grpc.pb.go&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;p&gt;&lt;/p&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3）服务端实现，注册服务&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在server目录下的server.go文件中注册一个结构体为GreeterServers的服务。并监听一个端口号，在服务端运行着&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    server := grpc.NewServer()&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    proto.RegisterGreeterServer(server, &amp;amp;GreeterServers{})&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;    lis, _ := net.Listen(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;:8090&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;    server.Serve(lis)&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在protolist_grpc.pb.go文件中有一个GreeterServer的接口，里面包含了两个方法，我们在server.go文件中就需要按照协议接口来实现所有的方法。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;// GreeterServer is the server API for Greeter service.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;// All implementations must embed UnimplementedGreeterServer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;// for forward compatibility&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;type&lt;/span&gt; GreeterServer &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;    SayRoute(Greeter_SayRouteServer) error&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;    mustEmbedUnimplementedGreeterServer()&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在server.go中声明一个GreeterServers结构体中里面继承了一个结构体。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;type&lt;/span&gt; GreeterServers &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    proto.UnimplementedGreeterServer&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这里直接继承proto（proto就是生成的grpc.pb.go文件的引用）下面的结构体即可，mustEmbedUnimplementedGreeterServer这个方法在协议中已经被这个UnimplementedGreeterServer结构体实现了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面实现SayRoute方法&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *GreeterServers)&lt;/span&gt; &lt;span&gt;SayRoute&lt;/span&gt;&lt;span&gt;(stream proto.Greeter_SayRouteServer)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;        _ = stream.Send(&amp;amp;proto.HelloReply{Message: &lt;span&gt;&quot;ha ha ha ha&quot;&lt;/span&gt;})&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;        resp, err := stream.Recv()&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; err == io.EOF {&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;        log.Printf(&lt;span&gt;&quot;resp:%v&quot;&lt;/span&gt;, resp)&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其中Send和Recv都是&lt;/span&gt;&lt;span&gt;Greeter_SayRouteServer接口中的方法，用于发送消息和接收消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时运行go run server.go 文件，然后TCP端口号为8090服务跑起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）客户端实现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端连接上服务端的端口:8090，然后调用服务端的SayRoute()方法，在通过Send()方法发送消息，使用Recv()方法接收消息。整个流程就像调用本地方法一样。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    conn, _ := grpc.Dial(&lt;span&gt;&quot;:8090&quot;&lt;/span&gt;, grpc.WithInsecure())&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;defer&lt;/span&gt; conn.Close()&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;    client := proto.NewGreeterClient(conn)&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;    _ = SayRoute(client, &amp;amp;proto.HelloRequest{Name: &lt;span&gt;&quot;cici&quot;&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SayRoute&lt;/span&gt;&lt;span&gt;(client proto.GreeterClient, r *proto.HelloRequest)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    stream, _ := client.SayRoute(context.Background())&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; &lt;span&gt;6&lt;/span&gt;; n++ {&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;        _ = stream.Send(r)&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        resp, err := stream.Recv()&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; err == io.EOF {&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;            &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;        log.Printf(&lt;span&gt;&quot;resp err: %v&quot;&lt;/span&gt;, resp)&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;    _ = stream.CloseSend()&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下面运行一下，如下是输出内容：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;148&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25688073394495414&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWX5EJTJ0ya9r99AZMzbAnl2lfdV7oEssEK6mKlGdAicu5qRucyqKgugjQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1308&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;145&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25158227848101267&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uOAEIB7ic9hLiaccVgnqrcgWXoDzW3wWp1EQNCeBnP9q3icR0Dx2IIKAGDEb4mLicwniaOrJaAvjGIXhQA/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1264&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，双向流式RPC就是指两端可以同时使用读写流发送消息。这两个流可以独立运行，可以根据业务需求完善流中消息的交互顺序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结这次gRPC案例初体验，我们简单的了解到什么是RPC以及gRPC的设计理念，什么是Protobuf以及它的核心内容是什么。最后实践了&lt;span&gt;双向流的简单demo。线下在学习的过程中对安装Protobuf插件的确走了一点弯路，好在最后走出来了。&lt;/span&gt;然后呢~特别感谢《&lt;span&gt;Go语言编程之旅&lt;/span&gt;》的作者让我这个小🐟儿有幸在gRPC的世界里稍微扑腾了一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、参考来源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;《Go语言编程之旅》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://blog.csdn.net/weixin_42905141/article/details/125272803&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://developers.google.com/protocol-buffers/docs/reference/go-generated?hl=zh-cn&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://blog.csdn.net/i_19970916/article/details/125733894&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;578&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z33JZWhn1uNE2jbQicbpwrWbzt4yCuXsolw0UEM7wZRXB1Rl8vvAJzbNsaQc7llGM2RQmT0TEJD94GARMRFUQvQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;157&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.271585557299843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z33JZWhn1uOnC8YBW9UGogSXeaGKoIibSDV6rg2FnuL671lPX6ibOEBOcNuvPqxyhqxlWicyf8dcraK579G8FWzrg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fbefb364ecd0de9b1b3f1d321622be61</guid>
<title>杭州程序员从互联网跳央企，晒一天工作和收入，网友：待一年就废</title>
<link>https://toutiao.io/k/19z441x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-v-b51c2330=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;p&gt;&lt;span&gt;说到互联网，有些人兴奋有些人恐惧，这几年相信不少人都听说过，很多互联网行业的人都挣到了人生第1桶金，可是现在不少的互联网行业人纷纷都跳槽，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就比如接下一位男子，从互联网跳槽到了央企，而他分享的央企一天工作日常，更是让网友吐槽，到底怎么回事？请往下看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/t09VbpQYMctTibloAelvU8lRL9NCdadjKd9ibb2W4K5WXEYvomEU28iaUKgP49UP9MIC03ib7IzIxwR9Mr9OPoyDUg/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;471.69550173010384&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;369.8269896193772&quot; data-ratio=&quot;0.7855626326963907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jNmCBexQlC4ibIB7ggCKac5x5icDhx510T0DOqdibBBgWkI6DkLSkvf47rE6icqctMibalNJmtaPyvpOiadiapxgoAR1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;471&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原来是一位程序员，分享了自己从互联网跳槽到央企之后的工作流程，男子说自己是211本科外硕士，有3年工作经验，而从这个表格可以看出了，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他9:15到公司露面，就直接去公司食堂吃早餐，然后9:30~11:00一个半小时查看公司邮件，和处理各种邮件，而11:00~11:30划水刷手机，11:30就开始吃午餐，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而且是六菜一汤加甜品，而下午就更轻松，先做上级汇报的PPT，和技术演讲稿，然后就去公司食堂买杯咖啡，再去开会一小时，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后5:00~5:30就是到了吃晚餐的时候，还可以顺便看一下漂亮妹子就下班，下班之后顺便用手机邮件给外包公司发一封感谢信，而主要内容就是感谢他们996让项目能顺利上线，以后会有更多的项目跟他们合作，今晚还要继续奋斗加油！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/t09VbpQYMctTibloAelvU8lRL9NCdadjKT7e7je5fmOsm8uJuurQZtbIWdlHNCovy1LCic05dP45vwpGaolRwibKg/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;355&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;404&quot; data-ratio=&quot;1.1380281690140845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jNmCBexQlC4ibIB7ggCKac5x5icDhx510Thy00uic5OW76240Tc6VBHserxg0lzXonHrVmBia1Efv4CvQiad1A8EDgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;355&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相信这样的工作，不管换谁也非常羡慕，不仅吃的好，而且还待遇非常不错，最主要不用加班，5:30就可以下班了，工作可以说非常轻松，怪不得网友会吐槽说待个一年差不多就废了，不过在央企确实很稳定，不像在互联网公司少不了加班，而且工作还不能稳定，这是互联网不能比的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/t09VbpQYMctTibloAelvU8lRL9NCdadjK3UBlUdH5zf4z9ujwqiaFWZNEXjXI4f1YjKYfRZ53FbnE8JveSxxL5kg/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;525&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;391&quot; data-ratio=&quot;0.7428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jNmCBexQlC4ibIB7ggCKac5x5icDhx510TD8UtexypoXajcC0rMPNeS3IfA0jibux8EVabvGsta9xIOuq2Ud67AWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;525&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对此网友纷纷说出了自己的看法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有网友说：国企都这样呀，我也一样。所谓的废掉是神马……我没事儿就在办公室写代码看书，自我学习的那种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后没事看看股票、楼市。看看理财产品。所谓的废掉，根本不存在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/t09VbpQYMctTibloAelvU8lRL9NCdadjKbgVClH7UribnT7b1VvSg6MQCvmMnMtsqfWqXz9qsiaYPhtsvrYbI98Dw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;456&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;333&quot; data-ratio=&quot;0.7302631578947368&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jNmCBexQlC4ibIB7ggCKac5x5icDhx510TMR2pPZL71WBRictGBicjfZSkibwOqKholNhIGUMkhykp4K0MFGToRSZbw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;456&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也有网友说：食物链越靠上，越负有责任。如果仅仅满足于吃几餐好吃的饭，刷手机，看漂亮妹子，说几句浮夸的大话，这个境界真的太低了。你记住一点：国企领导都不是瞎子，他们肩负的社会责任需要有人分担。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有网友说不错，我之前在某大型国企呆了一年，一年本非技术35w现在为了成长平薪去了互联网公司发现一样闲，怀疑很多人说的加班都是骗人的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，我们再看一个从央企离职当程序员的真实故事，希望对大家有启发：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020年3月，我离开了工作两年多的大型央企单位，转行去了IT公司当程序员，目前在新单位工作已三个月。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本硕非985/211，2016年秋招时签了前东家，作为国内该行业的龙头企业，产业好、国家政策又支持，所以当初对他的期望很高。单位在沿海城市，父母也想让我出去看看，见见世面，自己也考虑该公司平台大、起点高，后期发展也会好些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公司属于制造业，为了能多挣钱，签工作的时候选择的岗位是技术支持，需要国内到处出差，出差补助加工资，每个月到手还可以。不过出差地点不固定，可能在这个城市一两年左右，那个城市一两年。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当初签的时候因为家附近城市有办事点，所以想着以后能申请在家附近上班。那会打听到在家附近城市上班可能调动比较困难，但我还是选择自己骗自己。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2017年毕业后进入公司，公司对于新员工的培养与关照很到位，相关福利与制度也很完善，感觉一切都很新鲜，入职培训比较密集且对业务的掌握要求比较高，由于上学期间接触该行业较少，培训期间对理论的掌握比较困难，压力也挺大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2017年12月，培训结束后新员工前往全国各地的项目点工作，我去的北京，刚去租着最廉价的房子，恰巧赶上大兴着火，相关政策说是要把底层人员赶出北京，清理危险房源，房子租金涨价、房源不好找，经过几次搬家后慢慢稳定下来了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当时新产品刚上线，工作强度很大，每天平均工作至少十五、六个小时。那年冬天，雪很大，而下雪天气对产品的性能危害很大，故障频发，同事们也都是硬着头皮干。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2018年春天，因为其他地方的项目慢慢展开了，我被派往长沙工作。如果说之前的工作是熟悉工作性质，接下来的工作是正儿八经的干活。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为是新项目、新团队，很多设计人员对产品也不是很清楚，只能靠我们现场的人慢慢摸索，平时既要室外作业，还要应对大量文件报告，任何一个环节出错，可能会遭到客户的投诉或者公司的考核，每天高强度工作12个小时，连续工作了小半年才修了一次假。这段时期对工作流程有了大体的认识，但技能水平提升很少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2018年9月，因为广州开展新项目，我离开了那个团队。在广州又是全新的客户、全新的团队。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广州领导的管理比长沙领导的管理相对宽松，自己也有时间研究技术、提升业务能力与技能水平，真正以自己的思路去做一些工作，所以在此期间自己的技术、信心都提升了不少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从开始工作就对工作内容与性质不是特别感兴趣，日常需要应付大量报表，室外作业，工作地点不固定，同时还偶尔需要上夜班，每次上完夜班都极度不舒服，有时感觉快要猝死。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在广州的时候技术遇到瓶颈，提不起兴趣再进一步提升了。工作地点不固定，没有归属感，隔段时间非常焦虑、抑郁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2019年12月份左右，在极度抑郁的情况下，跟领导申请前往家附近城市工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到离家近的城市后，心情好了很多，但工作性质依然不满意，刚回来时计划要调我去另一个岗位，因为其他原因没去成。后面每天的工作跟广州一样，只是由于不熟悉新项目，提不起兴趣学习，每天的成就感不高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2019年最后几天，有IT公司联系我，新公司在业内的知名度很高，但与自己工作两年多做的项目不相关，研究生学的知识也忘的差不多了，所以就以试试的态度去了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面试的时候面试官问了我好多专业知识，基本一个都没答出来，只能说个基本印象，后面简单的聊了一下我离职的原因与以前的工作情况，我没报希望，结果回来的时候在地铁上收到了offer，待遇跟我现在工作差不多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;离职的选择很纠结，毕竟我现在的工作除了工作地点不固定，其他都还能接受，而IT公司是私企，可能存在35岁辞退情况。在网上查该公司，负面信息很多，但是托朋友打听，反映还好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终想着马上30岁的人了，趁房、车、媳妇都没有，压力不大，折腾一次，干自己想干的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020年2月，给领导打电话申请离职，领导跟同事很惊讶，当天晚上不断劝我，而我心意已决坚持要走。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020年3月，回公司总部所在城市自我隔离，隔离结束后前往公司开始办理离职。由于疫情期间上班人员不全，离职流程审查签字人员较多，所以办理比较慢，但是整体过程同事、领导还是相对照顾。2020年3月底办理完成，结束了我毕业后的第一份工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前跟新单位处于熟悉期。当下唯一的目标就是好好工作，深耕一个行业。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>