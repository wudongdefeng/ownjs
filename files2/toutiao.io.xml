<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>07e78cf1f6d96c3c1efccb4d5a6f8ffe</guid>
<title>优质网站同好者周刊（第 080 期） | 倾城博客</title>
<link>https://toutiao.io/k/15ogjat</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/PPT&quot;&gt;&lt;code&gt;PPT&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B9%BB%E7%81%AF%E7%89%87&quot;&gt;&lt;code&gt;幻灯片&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E9%AB%98%E6%95%88&quot;&gt;&lt;code&gt;高效&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The fast alternative to slides. Gamma is an alternative to slide decks - a fast, simple way to share and present your work. Create engaging presentations, memos, briefs, and docs that are easy to discuss live or share async. All in your browser, nothing to download or install.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/gamma.app.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Gamma ｜ Write like a doc, present like a deck&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://gamma.app/&quot;&gt;Gamma&lt;/a&gt;（伽马）， 是幻灯片（&lt;a href=&quot;https://nicelinks.site/tags/PPT&quot;&gt;PPT&lt;/a&gt;）的替代品，支持以一种快速、简单的方式来分享和展示您的作品。他创建易于现场讨论或异步共享的引人入胜的演示文稿、备忘录、简报和文档。全部在您的浏览器中，无需下载或安装。它具有以下功能特征：&lt;/p&gt;&lt;h3 id=&quot;专注于内容而不是格式&quot;&gt;&lt;a href=&quot;#%E4%B8%93%E6%B3%A8%E4%BA%8E%E5%86%85%E5%AE%B9%E8%80%8C%E4%B8%8D%E6%98%AF%E6%A0%BC%E5%BC%8F&quot; aria-label=&quot;专注于内容而不是格式 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;专注于内容，而不是格式&lt;/h3&gt;&lt;p&gt;Gamma &lt;strong&gt;使用灵活的卡片&lt;/strong&gt;和&lt;strong&gt;流畅的布局&lt;/strong&gt;（随着您添加新块而扩展），节省格式化框以适应幻灯片的时间。&lt;/p&gt;&lt;h3 id=&quot;一键完成抛光polished和准备&quot;&gt;&lt;a href=&quot;#%E4%B8%80%E9%94%AE%E5%AE%8C%E6%88%90%E6%8A%9B%E5%85%89polished%E5%92%8C%E5%87%86%E5%A4%87&quot; aria-label=&quot;一键完成抛光polished和准备 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;一键完成抛光（Polished）和准备&lt;/h3&gt;&lt;p&gt;创建精美的幻灯片真的很乏味，尤其是对齐盒子和保持品牌上的东西。使用 Gamma，可以&lt;strong&gt;更快&lt;/strong&gt;地完成工作。不再有幻灯片母版或模板，Gamma 支持一键重新设计你的整个甲板（deck）。&lt;/p&gt;&lt;h3 id=&quot;便于呈现利于分享&quot;&gt;&lt;a href=&quot;#%E4%BE%BF%E4%BA%8E%E5%91%88%E7%8E%B0%E5%88%A9%E4%BA%8E%E5%88%86%E4%BA%AB&quot; aria-label=&quot;便于呈现利于分享 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;便于呈现，利于分享&lt;/h3&gt;&lt;p&gt;Gamma 便于表达你的观点；它使用嵌套卡片的方式，以便听众深入了解细节；&lt;strong&gt;使用脚注&lt;/strong&gt;，使得排版保持简洁。&lt;/p&gt;&lt;h3 id=&quot;将您的想法变为现实&quot;&gt;&lt;a href=&quot;#%E5%B0%86%E6%82%A8%E7%9A%84%E6%83%B3%E6%B3%95%E5%8F%98%E4%B8%BA%E7%8E%B0%E5%AE%9E&quot; aria-label=&quot;将您的想法变为现实 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;将您的想法变为现实&lt;/h3&gt;&lt;p&gt;基于 Gamma 可以方便做到：&lt;strong&gt;简洁、直观、互动&lt;/strong&gt;。除了文字和无聊的剪贴画，嵌入任何东西：🎆动图、🎥视频、📈图表、💻网站。此外，您的听众可以在会议结束后，进行&lt;strong&gt;现场直播&lt;/strong&gt;并继续探索。&lt;/p&gt;&lt;h3 id=&quot;随时随地分享获得更多反馈&quot;&gt;&lt;a href=&quot;#%E9%9A%8F%E6%97%B6%E9%9A%8F%E5%9C%B0%E5%88%86%E4%BA%AB%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A4%9A%E5%8F%8D%E9%A6%88&quot; aria-label=&quot;随时随地分享获得更多反馈 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;随时随地分享，获得更多反馈&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;📊 &lt;strong&gt;使用内置分析&lt;/strong&gt;衡量参与度；&lt;/li&gt;&lt;li&gt;😁 &lt;strong&gt;通过快速反应&lt;/strong&gt;获得更多反馈；&lt;/li&gt;&lt;li&gt;💬 &lt;strong&gt;评论&lt;/strong&gt;使协作变得简单；&lt;/li&gt;&lt;li&gt;📱 &lt;strong&gt;在任何设备&lt;/strong&gt;上共享——笔记本电脑、平板电脑或手机；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在 &lt;a href=&quot;https://nicelinks.site/post/5f40d0bf15435e0906a0a26f&quot;&gt;Product Hunt&lt;/a&gt;，Gamma 创始人之一 Grant 分享道：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;每年，有十数亿人在 Google 幻灯片或 Powerpoint 中创建演示文稿。30 多年来，幻灯片一直是商务沟通的语言。 虽然生产力套件的其余部分多年来都出现了显著升级，但幻灯片作为一种格式基本保持不变：它们的尺寸是固定的（向 35 毫米天致敬），它们是为线性、单向演示而构建的，并且设计它们仍然很痛苦。&lt;/p&gt;&lt;p&gt;在过去的一年里，我们一直在研究一种全新的方法来处理私人测试版中的演示文稿和套牌。虽然我们还处于早期阶段，但我们很高兴今天能够开放，并希望 PH 社区成为第一批试用该产品的人。&lt;/p&gt;&lt;p&gt;免费使用。没有试用期。只需创建您的账户并开始构建。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Gamma，就像带你去一个新的宇宙的一扇门，它比文档更直观。比&lt;a href=&quot;https://nicelinks.site/tags/PPT&quot;&gt;幻灯片（PPT）&lt;/a&gt;更具协作性。比视频更具互动性。值得一提的是，它免费可用。如果您厌倦了 Powerpoint 那种原始的笨拙方式，并且「条件允许的话」，不妨大胆尝试下类似 Gamma 这种新的分享方式。同类型产品还有：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://sli.dev/&quot;&gt;SliDev&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/5d64acd1d95e0a5c61b4b84e&quot;&gt;Beautiful.ai&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/redirect?url=https://ludus.one/&quot;&gt;Ludus&lt;/a&gt; 等。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6307638fd3028e784afedaef&quot;&gt;倾城之链 - Gamma ｜ Write like a doc, present like a deck&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%88%AA%E5%9B%BE&quot;&gt;&lt;code&gt;截图&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AF%E4%BB%B6&quot;&gt;&lt;code&gt;软件&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Mac&quot;&gt;&lt;code&gt;Mac&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Native macOS app. One click to take a beautiful and ready-to-share screenshot.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/xnapper.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Xnapper – Take beautiful screenshots instantly&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://xnapper.com/&quot;&gt;Xnapper&lt;/a&gt; ，一款原生的 macOS 应用程序，立刻就能拍出漂亮的、可供分享的屏幕截图（抓拍→预览→分享）。它具有非常多值得称赞的优点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使用极其方便、快捷；&lt;strong&gt;2 秒&lt;/strong&gt;，即可获得精美截图；&lt;/li&gt;&lt;li&gt;自动的平衡，使得截图的主体内容完美居中（C 位）；&lt;/li&gt;&lt;li&gt;自动填充背景颜色，使得您专注于您的内容；&lt;/li&gt;&lt;li&gt;自动的屏蔽敏感的信息，单击一下，即可隐藏；&lt;/li&gt;&lt;li&gt;容易地选择和&lt;strong&gt;复制文本&lt;/strong&gt;（内置 macOS 视觉引擎提供支持）；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除此之外，截图应用程序应该具备的，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://xnapper.com/&quot;&gt;Xnapper&lt;/a&gt; 同样拥有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;自定义全局快捷方式；&lt;/li&gt;&lt;li&gt;自定义背景渐变/图像；&lt;/li&gt;&lt;li&gt;窗口捕获（按空格键）；&lt;/li&gt;&lt;li&gt;保存截图历史；&lt;/li&gt;&lt;li&gt;从文件和剪贴板打开；&lt;/li&gt;&lt;li&gt;社交媒体规模和比例；&lt;/li&gt;&lt;li&gt;预设、自定义设置；&lt;/li&gt;&lt;li&gt;压缩输出图像；&lt;/li&gt;&lt;li&gt;快速的设备文本识别；&lt;/li&gt;&lt;li&gt;美丽而快速的原生 macOS 应用程序；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其他诸如像「上传到云端」等功能，将在后续版本提供。值得一提的是， Xnapper 支持 iPhone/iPad，无论您走到哪里，都可以看到精美的屏幕截图。&lt;a href=&quot;https://nicelinks.site/redirect?url=https://xnapper.com/&quot;&gt;Xnapper&lt;/a&gt; 在 &lt;a href=&quot;https://nicelinks.site/post/5f40d0bf15435e0906a0a26f&quot;&gt;Product Hunt&lt;/a&gt; 一经发布，便得到千余 UPVOTE（赞成），其被欢迎程度，可见一斑。有下载亲测，确实比之前所用的截图软件要好用（尤其是自动平衡等功能）。只不过，它虽然免费可用；但需要付费购买，才能去除品牌水印。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63060e34d3028e784afedaed&quot;&gt;倾城之链 - Xnapper – Take beautiful screenshots instantly&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Tailwind&quot;&gt;&lt;code&gt;Tailwind&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/CSS&quot;&gt;&lt;code&gt;CSS&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BB%84%E4%BB%B6&quot;&gt;&lt;code&gt;组件&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Completely unstyled, fully accessible UI components, designed to integrate beautifully with Tailwind CSS.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/headlessui.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Headless UI - Unstyled, fully accessible UI components&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://headlessui.com/&quot;&gt;Headless UI&lt;/a&gt;，是一组完全无样式、完全可访问的 UI 组件，旨在与 &lt;a href=&quot;https://nicelinks.site/tags/Tailwind&quot;&gt;Tailwind&lt;/a&gt; CSS 完美集成。该项目开源（16K+ Star）、免费可用，支持 &lt;a href=&quot;https://nicelinks.site/post/5b1a221c0526c920d6dfaada&quot;&gt;Vue&lt;/a&gt; 和 &lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot;&gt;React&lt;/a&gt; 框架；截止目前，提供有下拉菜单、列表框（选择）、组合框（自动完成）、开关（Switch 切换）、对话框（模态）、弹出框、标签等十个组件，非常漂亮，且易于使用。如果您喜欢基于 Tailwind CSS 为前端项目编写样式，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://headlessui.com/&quot;&gt;Headless UI&lt;/a&gt; 是非常值得学习和使用的项目。如果您想了解更多，可移步至 &lt;a href=&quot;https://github.com/tailwindlabs&quot;&gt;Tailwind Labs&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6304b2d3d3028e784afedaeb&quot;&gt;倾城之链 - Headless UI - Unstyled, fully accessible UI components&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E8%A1%A8%E6%A0%BC&quot;&gt;&lt;code&gt;表格&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/JavaScript&quot;&gt;&lt;code&gt;JavaScript&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BB%84%E4%BB%B6&quot;&gt;&lt;code&gt;组件&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Grid.js is a Free and open-source JavaScript table plugin. It works with most JavaScript frameworks, including React, Angular, Vue and VanillaJs.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/gridjs.io.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Grid.js - Advanced JavaScript table plugin&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：Grid.js，是一个免费的开源 JavaScript 表格插件。它适用于大多数 JavaScript 框架，包括 &lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot;&gt;React&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/5b2b7f663bd7ef3847a3fadf&quot;&gt;Angular&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/5b1a221c0526c920d6dfaada&quot;&gt;Vue&lt;/a&gt; 和 VanillaJs。通过几个简单的步骤，即可安装 Grid.js。Grid.js 由两个主要文件组成，JavaScript 部分和 CSS 部分，它们可以很好地呈现元素。它具有以下功能特征：&lt;/p&gt;&lt;h3 id=&quot;便于使用&quot;&gt;&lt;a href=&quot;#%E4%BE%BF%E4%BA%8E%E4%BD%BF%E7%94%A8&quot; aria-label=&quot;便于使用 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;便于使用&lt;/h3&gt;&lt;p&gt;Grid.js API 的简单性将帮助您通过几个简单直接的步骤开发高级 JavaScript 表格。&lt;/p&gt;&lt;h3 id=&quot;可扩展&quot;&gt;&lt;a href=&quot;#%E5%8F%AF%E6%89%A9%E5%B1%95&quot; aria-label=&quot;可扩展 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;可扩展&lt;/h3&gt;&lt;p&gt;Grid.js 利用先进的管道来处理数据。管道很容易扩展和改进。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;new Grid({ 
  columns: [&#x27;Name&#x27;, &#x27;WebSite&#x27;],
  data: [
    [&#x27;倾城之链&#x27;, &#x27;nicelinks.site&#x27;],
    [&#x27;曼妙句子&#x27;, &#x27;read.lovejade.cn&#x27;]
  ] 
}).render(document.getElementById(&#x27;table&#x27;));
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;免费和开源&quot;&gt;&lt;a href=&quot;#%E5%85%8D%E8%B4%B9%E5%92%8C%E5%BC%80%E6%BA%90&quot; aria-label=&quot;免费和开源 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;免费和开源&lt;/h3&gt;&lt;p&gt;Grid.js 是免费和开源的，在 MIT 许可下发布。&lt;/p&gt;&lt;p&gt;此外，Grid.js 还有些其他特性，诸如：简单轻量级的实现（所有插件只有 12kb）、基于 &lt;a href=&quot;https://nicelinks.site/post/6278fdeaac00ce3f9b11a8ef&quot;&gt;TypeScript&lt;/a&gt; 编写、支持所有现代浏览器和 IE11+ 等等；如果您有基于表格（table）来完成的需求，Grid.js 是很棒的选择之一。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6303652fd3028e784afedae9&quot;&gt;倾城之链 - Grid.js - Advanced JavaScript table plugin&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;知识只有应用到实践上，才能够发挥它真正的价值和作用&lt;/strong&gt;。教科书上的知识都是那些一生致力于研究学问的老先生们埋头编写出来的，虽然有一定的参考价值和理论依据，但是很难直接帮你解决现实生活中遇到的问题。所以，我希望你&lt;strong&gt;不要过分依赖于现有的理论知识和学问去解决问题，这才是你能走好以后人生路的关键&lt;/strong&gt;。── 《洛克菲勒写给儿子的 38 封信 · 其一》&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8adf54aab61db4c43245509b4a58a861</guid>
<title>如何在 Gin 框架中使用泛型构建完全解耦的请求验证层</title>
<link>https://toutiao.io/k/29lc1e5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;请求验证可能是任何 Web 框架中最无聊但最关键的中间层。今天，我将展示在 golang 中的 &lt;span&gt;gin 框架&lt;/span&gt; 中（使用泛型）的正确实践。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1. 目标&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Gin&lt;/span&gt; 与 &lt;span&gt;validator&lt;/span&gt; 库集成以进行请求验证，即 &lt;span&gt;模型绑定与验证&lt;/span&gt;。我们将在很大程度上依靠这一点来实现我们的目标。&lt;/p&gt;&lt;p&gt;我们的目标是：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;构建一个抽象，通过这个抽象使得请求验证与请求处理程序完全解耦，例如，在您的常规 gin 的 handler 函数中，你只需从路径参数/query 字符串 / json body 中获取值并开始使用它们。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2. 如何实现&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;让我们从一个简单的 json body 开始：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; CreateUserHttpBody struct {&lt;br/&gt;    Birthday string `json:&lt;span&gt;&quot;birthday&quot;&lt;/span&gt; binding:&lt;span&gt;&quot;required,datetime=01/02&quot;&lt;/span&gt;`&lt;br/&gt;    Timezone string `json:&lt;span&gt;&quot;timezone&quot;&lt;/span&gt; binding:&lt;span&gt;&quot;omitempty,timezone&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func CreateUser(c *gin.Context) {&lt;br/&gt;    var httpBody HttpBody&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err := c.ShouldBindJSON(&amp;amp;httpBody); err != nil {&lt;br/&gt;        c.JSON(http.StatusBadRequest, gin.H{&lt;span&gt;&quot;error&quot;&lt;/span&gt;: err.Error()})&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // from here we can use the httpBody as it must has the correct&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;对于上面的示例，请求 body 中任何有问题的请求都会导致错误响应。这种简单的情况很好处理，但如果你有几十个类似的端点要处理，那就是一个很重复冗余的工作了。这种 &lt;code&gt;validate-and-400-if-invalid 模式将一遍又一遍地重复&lt;/code&gt;。还有更好的处理办法么？&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3. 什么是更好的抽象&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;对于不同的用例，上述逻辑是相同的，唯一会改变的是 http body 的类型。那么，我们可以使用一个泛型中间件来处理这个逻辑，那样我们就可以只关心 handler 函数中的值。如下：&lt;/p&gt;&lt;p&gt;假设我们想使用上述 &lt;code&gt;CreateUserHttpBody&lt;/code&gt; 结构体验证 json body。&lt;/p&gt;&lt;p&gt;我们可以在注册 handler 函数时对其进行验证。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;router.POST(&lt;span&gt;&quot;/user&quot;&lt;/span&gt;,&lt;br/&gt;    ValidateJsonBody[CreateUserHttpBody](),&lt;br/&gt;    rs.CreateUser,&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;请注意，我们只对这个 &lt;code&gt;/user POST&lt;/code&gt; 端点应用验证，gin 支持路由级中间件。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;然后在你的函数中，你可以像这样使用它：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func CreateUser(c *gin.Context) {&lt;br/&gt;    httpBody := GetJsonBody[CreateUserHttpBody]()&lt;br/&gt;&lt;br/&gt;    // the below statement will &lt;span&gt;print&lt;/span&gt; the birthday and timezone when receives valid request&lt;br/&gt;    fmt.Println(httpBody.Birthday, httpBody.Timezone)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;看上面的代码，有趣的是，当运行到 &lt;code&gt;fmt.Println(httpBody.Birthday, httpBody.Timezone)&lt;/code&gt; 这行时，意味着请求是有效的，并且 &lt;code&gt;httpBody.Birthday&lt;/code&gt; 和 &lt;code&gt;httpBody.Timezone&lt;/code&gt; 必须是合法且可供使用的。&lt;/section&gt;&lt;p&gt;如果请求无效，它将被 &lt;code&gt;ValidateJsonBody[CreateUserHttpBody]()&lt;/code&gt; 拦截并返回，客户端将收到 http code 400 响应。&lt;/p&gt;&lt;p&gt;它几乎就像“声明式验证”，我们只需在 &lt;code&gt;CreateUserHttpBody&lt;/code&gt; 结构中描述需要的验证要求，而不再需要更多别的操作！&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;4. 简单的 3 个步骤的回顾：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;我们在 &lt;code&gt;CreateUserHttpBody&lt;/code&gt; 结构体中声明请求验证&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我们在 &lt;code&gt;router.POST&lt;/code&gt; 中增加了一个 &lt;code&gt;ValidateJsonBody[CreateUserHttpBody]()&lt;/code&gt; 中间件，在实际处理业务函数之前进行验证。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在 handler 函数中，我们只是从 &lt;code&gt;httpBody := GetJsonBody[CreateUserHttpBody]()&lt;/code&gt; 中获取通过验证的请求body&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;5. 如何实现&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;我们先创建 &lt;code&gt;ValidateJsonBody&lt;/code&gt; 方法，怎么实现？还记得我们在第 2 节中说过，这种 &lt;code&gt;validate-and-400-if-invalid 模式将一遍又一遍地重复&lt;/code&gt;。唯一不变的是类型，这就把我们引向了泛型的概念。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func ValidateJsonBody[BodyType any]() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; func(c *gin.Context) {&lt;br/&gt;        var body BodyType&lt;br/&gt;&lt;br/&gt;        err := c.ShouldBindJSON(&amp;amp;body)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;            c.JSON(http.StatusBadRequest, gin.H{&lt;span&gt;&quot;error&quot;&lt;/span&gt;: err.Error()})&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        c.Set(&lt;span&gt;&quot;jsonBody&quot;&lt;/span&gt;, value)&lt;br/&gt;&lt;br/&gt;        c.Next()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;我们创建了 &lt;code&gt;ValidateJsonBody&lt;/code&gt; 方法，它接收 &lt;code&gt;BodyType&lt;/code&gt;，它可以是你传递给它的任意类型。在正文中，我们只是编写了一个普通的 gin 中间件，我们声明了变量，并进行了验证，如果请求无效，我们返回 400。否则，我们将解析后的值设置为 gin 上下文，key 为 &lt;code&gt;jsonBody&lt;/code&gt;。&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;在我们的示例中，&lt;code&gt;ValidateJsonBody[CreateUserHttpBody]()&lt;/code&gt;，&lt;code&gt;CreateUserHttpBody&lt;/code&gt; 是将被接收的泛型类型。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;现在我们来实现 &lt;code&gt;GetJsonBody&lt;/code&gt; 方法，这是最简单的部分。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func GetJsonBody[BodyType any](c *gin.Context) BodyType {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c.MustGet(&lt;span&gt;&quot;jsonBody&quot;&lt;/span&gt;).(BodyType)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;我们使用 gin 中的 &lt;code&gt;c.MustGet&lt;/code&gt; 从 gin context 中检索值，并将其类型转换为泛型类型。如果没有值，这个 &lt;code&gt;MustGet&lt;/code&gt; 将发生 &lt;code&gt;panic&lt;/code&gt;，但在我们的例子中，它不会发生，因为我们已经在 &lt;code&gt;ValidateJsonBody&lt;/code&gt; 中间件中设置了它。&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;在我们的示例中，&lt;code&gt;httpBody := GetJsonBody[CreateUserHttpBody]()&lt;/code&gt;，&lt;code&gt;CreateUserHttpBody&lt;/code&gt; 是将被接收的泛型类型。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;6. 还能再优化么？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;如上所述，我们实现了一个完全解耦的请求验证层。但我们可以做得更好吗？是的！我们还能做什么呢？&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;7. 结语&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;希望这个文章对你有所启发，感谢阅读:)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;----&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;相关链接：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;gin框架&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;em&gt;https://github.com/gin-gonic/gin&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Gin&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;em&gt;https://github.com/gin-gonic/gin&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;validator&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;https://github.com/go-playground/validator&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;模型绑定与验证&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;https://github.com/gin-gonic/gin#model-binding-and-validation&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;----&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原文地址：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://albertgao.xyz/2022/07/22/how-to-have-a-completely-decoupled-request-validation-layer-in-gin-framework/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原文作者：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;albertgao&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;本文永久链接：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/gocn/translator/blob/master/2022/w23_How_to_build_a_completely_decoupled_request_validation_layer_with_generic_in_Gin_framework.md&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;译者&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Jancd&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;校对&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：pseudoyu&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;2022 GopherChina大会报名火热进行中！&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;扫描下方二维码即可报名参与&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDCLS8Vr7c7diaN7Lbs4t65j1OholtjANMjsLNzGLvMMHNIr8jGR8MPm6fsNlXFxTrzW5MPSIXSibUw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大会合作、现场招聘及企业购票等事宜请联系&lt;strong&gt;微信：18516100522&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5763688760806917&quot; data-type=&quot;png&quot; data-w=&quot;694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDCLS8Vr7c7diaN7Lbs4t65jATUXW8iaYW0CNXcWKuNXoicw2PM7KErS0icKI8CEW63qjrteMkPKibEy0g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;戳这里上车！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>04c15f283ce50465668bf6a46d85d7b5</guid>
<title>Replication（下）：事务，一致性与共识</title>
<link>https://toutiao.io/k/oqmu6ls</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;58&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU2zk0q52HtKQjubeUEyZHBVHPgeBXgTUj0ib1Kwfosl82xO1Aw7x6gccLuuYs1dbxI7REI7OcjbGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第531&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2022年 第048篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;103&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;103&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU2zk0q52HtKQjubeUEyZHBic5ADGrKxgSd0tibyMiasOHXjb46qFBw7PTfuWAxXzWq32lDkL05icwkMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;section&gt;&lt;span&gt;本文主要介绍事务、一致性以及共识，首先会介绍它们怎么在分布式系统中起作用，然后将尝试描述它们之间的内在联系，让大家了解，在设计分布式系统时也是有一定的“套路”可寻。最后，会介绍业界验证分布式算法的一些工具和框架，希望能够对大家有所帮助或者启发。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 前文回顾&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 本文简介&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 事务&amp;amp;外部一致性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.1 事务的产生&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.2 不厌其烦——ACID特性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.3 事务按操作对象的划分&amp;amp;&amp;amp;安全的提交重试&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.4 弱隔离级别&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.5 本章小结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 内部一致性与共识&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.1 复制滞后性的问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.2 内部一致性概述&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.3 举一反三：分布式系统中的内部一致性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.4 我们口中的“强一致性”——线性一致性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.5 什么时候需要依赖线性化？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.6 实现线性化系统&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.7 共识&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.8 本章小结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5. 再谈分布式系统&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6. 士别三日，当刮目相看——再看Kafka&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7. 分布式系统验证框架&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 前文回顾&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;在上一篇中，我们主要介绍了分布式系统中常见的复制模型，并描述了每一种模型的优缺点以及使用场景，同时阐述了分布式系统中特有的一些技术挑战。首先，常见的分布式系统复制模型有3种，分别是主从模型、多主模型以及无主模型。此外，复制从客户端的时效性来说分为同步复制&amp;amp;&amp;amp;异步复制，异步复制具有滞后性，可能会造成数据不一致，因为这个不一致，会带来各种各样的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外，第一篇文章用了“老板安排人干活”的例子比喻了分布式系统中特有的挑战，即&lt;strong&gt;部分失效&lt;/strong&gt;以及&lt;strong&gt;不可靠的时钟&lt;/strong&gt;问题。这给分布式系统设计带来了很大的困扰。似乎在没有机制做保证的情况下，一个朴素的分布式系统什么事情都做不了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上一篇的最后，我们对分布式系统系统模型做了一些假设，这些假设对给出后面的解决方案其实是非常重要的。首先针对部分失效，是我们需要对系统的超时进行假设，一般我们假设为半同步模型，也就是说一般情况下延迟都非常正常，一旦发生故障，延迟会变得偏差非常大。另外，对于节点失效，我们通常在设计系统时假设为崩溃-恢复模型。最后，面对分布式系统的两个保证Safty和Liveness，我们优先保证系统是Safety，也就是安全；而Liveness（&lt;/span&gt;&lt;span&gt;活性&lt;/span&gt;&lt;span&gt;）通常在某些前提下才可以满足。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 本文简介&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;通过第一篇文章，我们知道了留待我们解决的问题有哪些。那么这篇文章中，将分别根据我们的假设去解决上述的挑战。这些保证措施包括事务、一致性以及共识。接下来讲介绍它们的作用以及内在联系，然后我们再回过头来审视一下Kafka复制部分的设计，看看一个实际的系统在设计上是否真的可以直接使用那些套路，最后介绍业界验证分布式算法的一些工具和框架。接下来，继续我们的数据复制之旅吧！&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 事务&amp;amp;外部一致性&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;说到事务，相信大家都能简单说出个一二来，首先能本能做出反应出的，应该就是所谓的“ACID”特性了，还有各种各样的隔离级别。是的，它们确实都是事务需要解决的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这一章中，我们会更加有条理地理解下它们之间的内在联系，详细看一看事务究竟要解决什么问题。在《DDIA》一书中有非常多关于数据库事务的具体实现细节，但本文中会弱化它们，毕竟本文不想详细介绍如何设计一款数据库，我们只需探究问题的本身，等真正寻找解决方案时再去详细看设计，效果可能会更好。下面我们正式开始介绍事务。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 事务的产生&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;系统中可能会面临下面的问题：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;程序依托的操作系统层，硬件层可能随时都会发生故障（&lt;/span&gt;&lt;span&gt;包括一个操作执行到一半时&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应用程序可能会随时发生故障（&lt;/span&gt;&lt;span&gt;包括操作执行到一半时&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网络中断可能随时会发生，它会切断客户端与服务端的链接或数据库之间的链接。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多个客户端可能会同时访问服务端，并且更新统一批数据，导致数据互相覆盖（&lt;/span&gt;&lt;span&gt;临界区&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;客户端可能会读到过期的数据，因为上面说的，可能操作执行一半应用程序就挂了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;假设上述问题都会出现在我们对于存储系统（&lt;/span&gt;&lt;span&gt;或者数据库&lt;/span&gt;&lt;span&gt;）的访问中，这样我们在开发自己应用程序的同时，还需要额外付出很大代价处理这些问题。事务的核心使命就是尝试帮我们解决这些问题，提供了从它自己层面所看到的安全性保证，让我们在访问存储系统时只专注我们本身的写入和查询逻辑，而非这些额外复杂的异常处理。而说起解决方式，正是通过它那大名鼎鼎的&lt;strong&gt;ACID&lt;/strong&gt;特性来进行保证的。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 不厌其烦——ACID特性&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;这四个缩写所组成的特性相信大家已形成本能反应，不过《DDIA》一书中给出的定义确实更加有利于我们更加清晰地理解它们间的关系，下面将分别进行说明：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;A：原子性（Atomicity）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：原子性实际描述的是同一个客户端对于多个操作之间的限制，这里的原子表示的是不可分割，原子性的效果是，假设有操作集合{A,B,C,D,E}，执行后的结果应该和单个客户端执行一个操作的效果相同。从这个限制我们可以知道：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于操作本身，就算发生任何故障，我们也不能看到任何这个操作集中间的结果，比如操作执行到C时发生了故障，但是事务应该重试，直到我们需要等到执行完之后，要么我们应该恢复到执行A之前的结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于操作作用的服务端而言，出现任何故障，我们的操作不应该对服务端产生任何的副作用，只有这样客户端才能安全的重试，否则，如果每次重试都会对服务端产生副作用，客户端是不敢一直安全的重试的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;因此，对于原子性而言，书中描述说的是能在执行发生异常时丢弃，可以直接终止，且不会对服务端产生任何副作用，可以安全的重试，原子性也成为“可终止性”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;C：一致性（Consistency）&lt;/strong&gt;：这个名词有太多的重载，也就是说它在不同语境中含义会截然不同，但可能又有联系，这就可能让我们陷入混乱，比如：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据复制时，副本间具有一致性，这个一致性应该指上一章中提到的不同副本状态的一致。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一致性Hash，这是一种分区算法，个人理解是为了能够在各种情况下这个Hash算法都可以以一致的方式发挥作用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CAP定理中的一致性指的是后面要介绍的一个特殊的内部一致性，称为“线性一致性”。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;我们稍后要介绍ACID中的一致性，指的是程序的某些“不变式”，或“良好状态”。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;我们需要区分不同语境中一致性所表达含义的区别，也希望大家看完今天的分享，能更好地帮助大家记住这些区别。话说回来，这里的一致性指的是对于数据一组特定陈述必须成立，即“不变式”，这里有点类似于算法中的“循环不变式”，即当外界环境发生变化时，这个不变式一定需要成立。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;书中强调，这个里面的一致性更多需要用户的应用程序来保证，因为只有用户知道所谓的不变式是什么。这里举一个简单的小例子，例如我们往Kafka中append消息，其中有两条消息内容都是2，如果没有额外的信息时，我们也不知道到底是客户端因为故障重试发了两次，还是真的就有两条一模一样的数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果想进行区分，可以在用户程序消费后走自定义的去重逻辑，也可以从Kafka自身出发，客户端发送时增加一个“发号”环节标明消息的唯一性（&lt;/span&gt;&lt;span&gt;高版本中Kafka事务的实现大致思路&lt;/span&gt;&lt;span&gt;）这样引擎本身就具备了一定的自己设置“不变式”的能力。不过如果是更复杂的情况，还是需要用户程序和调用服务本身共同维护。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;I：隔离性（Isolation）&lt;/strong&gt;：隔离性实际上是事务的重头戏，也是门道最多的一环，因为隔离性解决的问题是多个事务作用于同一个或者同一批数据时的并发问题。一提到并发问题，我们就知道这一定不是个简单的问题，因为并发的本质是时序的不确定性，当这些不确定时序的作用域有一定冲突（&lt;/span&gt;&lt;span&gt;Race&lt;/span&gt;&lt;span&gt;）时就可能会引发各种各样的问题，这一点和多线程编程是类似的，但这里面的操作远比一条计算机指令时间长得多，所以问题会更严重而且更多样。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里给一个具体的实例来直观感受下，如下图展示了两个客户端并发的修改DB中的一个counter，由于User2的get counter发生的时刻在User1更新的过程中，因此读到的counter是个旧值，同样User2更新也类似，所以最后应该预期counter值为44，结果两个人看到的counter都是43（&lt;/span&gt;&lt;span&gt;类似两个线程同时做value++&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个完美的事务隔离，在每个事务看来，整个系统只有自己在工作，对于整个系统而言这些并发的事务一个接一个的执行，也仿佛只有一个事务，这样的隔离成为“可序列化（&lt;/span&gt;&lt;span&gt;Serializability&lt;/span&gt;&lt;span&gt;）”。当然，这样的隔离级别会带来巨大的开销，因此出现了各种各样的隔离级别，进而满足不同场景的需要。后文会详细介绍不同的隔离级别所解决的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;197&quot; data-ratio=&quot;0.35233160621761656&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVaBRhqMCgial9lwWadacmIgCWmOCwWk7v3CIv9wQ2O2YF4JfW61FjDR7A/640?wx_fmt=png&quot; data-w=&quot;1158&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图1 隔离性问题导致更新丢失&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;D：持久性（Durability）&lt;/strong&gt;: 这个特性看似比较好理解，就一点，只要事务完成，不管发生任何问题，都不应该发生数据丢失。从理论上讲，如果是单机数据库，起码数据已被写入非易失性存储（&lt;/span&gt;&lt;span&gt;至少已落WAL&lt;/span&gt;&lt;span&gt;），分布式系统中数据被复制到了各个副本上，并受到副本Ack。但实际情况下，也未必就一定能保证100%的持久性。这里面的情况书中有详细的介绍，这里就不做重复的Copy工作了，也就是说事务所保证的持久性一般都是某种权衡下的结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面四个特性中，实际上对于隔离性的问题，可能是问题最多样的，也是最为复杂的。因为一味强调“序列化”可能会带来不可接受的性能开销。因此，下文将重点介绍一些比可序列化更弱的隔离级别。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 事务按操作对象的划分&amp;amp;&amp;amp;安全的提交重试&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;在介绍后面内容前，有两件事需要事先做下强调，分别是事务操作的对象以及事务的提交与重试，分为单对象&amp;amp;&amp;amp;多对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;单对象写入&lt;/strong&gt;：这种书中给出了两种案例。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 第一个是单个事物执行一个长时间的写入，例如写入一个20KB的JSON对象，假设写到10KB时断掉会发生什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;    a. 数据库是否会存在10KB没法解析的脏数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    b. 如果恢复之后数是否能接着继续写入。 &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;    c. 另一个客户端读取这个文档，是否能够看到恢复后的最新值，还是读到一堆乱码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 另一种则是类似上图中counter做自增的功能。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这种事务的解决方法一般是通过日志回放（&lt;/span&gt;&lt;span&gt;原子性&lt;/span&gt;&lt;span&gt;）、锁（&lt;/span&gt;&lt;span&gt;隔离性&lt;/span&gt;&lt;span&gt;）、CAS（&lt;/span&gt;&lt;span&gt;隔离性&lt;/span&gt;&lt;span&gt;）等方式来进行保证。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;多对象事务&lt;/strong&gt;：这类事务实际上是比较复杂的，比如可能在某些分布式系统中，操作的对象可能会跨线程、跨进程、跨分区，甚至跨系统。这就意味着，我们面临的问题多于上一篇文章提到的那些分布式系统特有的问题，处理那些问题显然要更复杂。有些系统干脆把这种“锅”甩给用户，让应用程序自己来处理问题，也就是说，我们可能需要自己处理因没有原子性带来的中间结果问题，因为没有隔离性带来的并发问题。当然，也有些系统实现了这些所谓的分布式事务，后文中会介绍具体的实现手段。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另一个需要特别强调的点是重试，事务的一个核心特性就是当发生错误时，客户端可以安全的进行重试，并且不会对服务端有任何副作用，对于传统的真的实现ACID的数据库系统，就应该遵循这样的设计语义。但在实际实践时，如何保证上面说的能够“安全的重试”呢？书中给出了一些可能发生的问题和解决手段：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;假设事务提交成功了，但服务端Ack的时候发生了网络故障，此时如果客户端发起重试，如果没有额外的手段，就会发生数据重复，这就需要服务端或应用程序自己提供能够区分消息唯一性的额外属性（&lt;/span&gt;&lt;span&gt;服务端内置的事务ID或者业务自身的属性字段&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于负载太大导致了事务提交失败，这是贸然重试会加重系统的负担，这时可在客户端进行一些限制，例如采用指数退避的方式，或限制一些重试次数，放入客户端自己系统所属的队列等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在重试前进行判断，尽在发生临时性错误时重试，如果应用已经违反了某些定义好的约束，那这样的重试就毫无意义。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果事务是多对象操作，并且可能在系统中发生副作用，那就需要类似“两阶段提交”这样的机制来实现事务提交。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 弱隔离级别&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;事务隔离要解决的是并发问题，并发问题需要讨论两个问题时序与竞争，往往由于事物之间的操作对象有竞争关系，并且又因为并发事务之间不确定的时序关系，会导致这些所操作的有竞争关系的对象会出现各种奇怪的结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所谓不同的隔离级别，就是试图去用不同的开销来满足不同场景下对于时序要求的严格程度。我们可能不一定知道具体怎么实现这些事务隔离级别，但每个隔离级别解决的问题本身我们应该非常清晰，这样才不会在各种隔离级别和开销中比较轻松的做权衡。这里，我们不直接像书中一样列举隔离级别，我们首先阐述并发事务可能产生的问题，然后再去介绍每种隔离级别分别能够解决那些问题。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;脏读&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;所谓脏读，指的就是用户能不能看到一个还没有提交事务的结果，如果是，就是脏读。下图展示了没有脏读应该满足什么样的承诺，User1的一个事务分别设置x=3、y=3，但在这个事务提交之前，User2在调用get x时，需要返回2，因为此时User1并没有提交事务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;213&quot; data-ratio=&quot;0.3808695652173913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVax6YVVr0AVG51mrcgoicK7oYUAoiaBtVMCGFxkoXNjlbHthfhLl1bhedA/640?wx_fmt=png&quot; data-w=&quot;1150&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2 脏读&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;防止脏读的意义：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果是单对象事务，客户端会看到一个一会即将可能被回滚的值，如果我需要依据这个值做决策，就很有可能会出现决策错误。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果是多对象事务，可能客户端对于不同系统做访问时一部分数据更新，一部分未更新，那样用户可能会不知所措。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;脏写&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;如果一个客户端覆盖了另一个客户端尚未提交的写入，我们就称这样的现象为脏写。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里同样给个实例，对于一个二手车的交易，需要更新两次数据库实现，但有两个用户并发的进行交易，如果像图中一样不禁止脏写，就可能存在销售列表显示交易属于Bob但发票却发给了Alice，因为两个事务对于两个数据的相同记录互相覆盖。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;301&quot; data-ratio=&quot;0.5387323943661971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVaIpm9oAeByNB6icIiaRV5rprMwoXgLdRL5I4uH2pTKCUCvKIW0tvwA89Q/640?wx_fmt=png&quot; data-w=&quot;1136&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3 脏写&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;读偏差（不可重复读）&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;直接上例子，Alice在两个银行账户总共有1000块，每个账户500，现在她想从一个账户向另一个账户转账100，并且她想一直盯着自己的两个账户看看钱是否转成功了。不巧的是，他第一次看账户的时候转账还没发生，而成功后只查了一个账户的值，正好少了100，所以最后加起来会觉得自己少了100元。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果只是这种场景，其实只是个临时性的现象，后面再查询就会得到正确的值，但是如果基于这样的查询去做别的事情，那可能就会出现问题了，比如将这个记录Select出来进行备份，以防DB崩溃。但不巧如果后面真的崩溃，如果基于这次查询到的数据做备份，那这100元可能真的永久的丢失了。如果是这样的场景，不可重复读是不能被接受的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;293&quot; data-ratio=&quot;0.5061728395061729&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVaadkYRDicmjqEI8uF9des5bW7antwadgOQhXF0cMtibtk3wx6TqiaBE7jQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图4 读偏差&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更新丢失&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;这里直接把之前那个两个用户同时根据旧值更新计数器的例子搬过来，这是个典型的更新丢失问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;204&quot; data-ratio=&quot;0.35233160621761656&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVaBRhqMCgial9lwWadacmIgCWmOCwWk7v3CIv9wQ2O2YF4JfW61FjDR7A/640?wx_fmt=png&quot; data-w=&quot;1158&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图5 隔离性问题导致更新丢失&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;写偏差 &amp;amp;&amp;amp; 幻读&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;这种问题描述的是，事务的写入需要依赖于之前判断的结果，而这个结果可能会被其他并发事务修改。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;429&quot; data-ratio=&quot;0.7422303473491774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVafvqnniav5q6HEblocXLBsET9AWpj8YkejFD5wf81ZCGUxNfzvctI7gQ/640?wx_fmt=png&quot; data-w=&quot;1094&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图6 幻读&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实例中有两个人Alice和Bob决定是否可以休班，做这个决定的前提是判断当前是否有两个以上的医生正在值班，如果是则自己可以安全的休班，然后修改值班医生信息。但由于使用了快照隔离（&lt;/span&gt;&lt;span&gt;后面会介绍&lt;/span&gt;&lt;span&gt;）机制，两个事务返回的结果全都是2，进入了修改阶段，但最终的结果其实是违背了两名医生值班的前提。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;造成这个问题的根本原因是一种成为“幻读”的现象，也就是说两个并发的事务，其中一个事务更改了另一个事物的查询结果，这种查询一般都是查询一个聚合结果，例如上文中的count或者max、min等，这种问题会在下面场景中出现问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面我们列举了事务并发可能产生的问题，下面我们介绍各种隔离级别所能解决的问题。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.22109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVaiaibhAkicasiaDFXunb7FoogtTWyfyDF1yheDj98n7BwBf5tdC9nqMBPng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.5 本章小结&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;事务用它的ACID特性，为用户屏蔽了一些错误的处理。首先，原子性为用户提供了一个可安全重试的环境，并且不会对相应的系统产生副作用。一致性能够在一定程度上让程序满足所谓的不变式，隔离性通过不同的隔离级别解决不同场景下由于事务并发导致的不同现象，不同的隔离性解决的问题不同，开销也不同，需要用户按需决策，最后持久性让用户安心的把数据写进我们设计的系统。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总体而言，事务保证的是不同操作之间的一致性，一个极度完美的事务实现，让用户看上去就只有一个事务在工作，每次只执行了一个原子操作。因此，我们称事务所解决的是操作的一致性。这一章中，我们更多谈论的还是单机范围的事务。接下来，我们会把问题阈扩大，实际上分布式系统也有这样的问题，并且分布式系统还有类似的复制滞后问题，导致就算看似是操作的是一个对象，也存在不同的副本，这会使得我们所面对的问题更加复杂。下一章，我们重点介绍另一种一致性问题以及解决。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 内部一致性与共识&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 复制滞后性的问题&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;这里我们首先回到上一篇中讲的复制的滞后性，滞后性所带来的的一个最直观的问题就是，如果在复制期间客户端发起读请求，可能不同的客户端读到的数据是不一样的。这里面书中给了三种不同类型的一致性问题。我们分别来看这些事例：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;277&quot; data-ratio=&quot;0.4793814432989691&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVa7ZkTRhrArhibfq5fuR3Gferjvjy682iamWocrgIOfcjc8Gg1IHtcfvag/640?wx_fmt=png&quot; data-w=&quot;1164&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图7 复制滞后问题&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一张图给出的是一个用户先更新，然后查看更新结果的事例，比如用户对某一条博客下做出了自己的评论，该服务中的DB采用纯的异步复制，数据写到主节点就返回评论成功，然后用户想刷新下页面看看自己的评论能引发多大的共鸣或跟帖，这是由于查询到了从节点上，所以发现刚才写的评论“不翼而飞”了，如果系统能够避免出现上面这种情况，我们称实现了“写后读一致性”（&lt;/span&gt;&lt;span&gt;读写一致性&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面是用户更新后查看的例子，下一张图则展示了另一种情况。用户同样是在系统中写入了一条评论，该模块依旧采用了纯异步复制的方法实现，此时有另一位用户来看，首先刷新页面时看到了User1234的评论，但下一次刷新，则这条评论又消失了，好像时钟出现了回拨，如果系统能够保证不会让这种情况出现，说明系统实现了“单调读”一致性（&lt;/span&gt;&lt;span&gt;比如腾讯体育的比分和详情页&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;347&quot; data-ratio=&quot;0.6&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVae5ytANbHYBoS7M0f8Bs6qQ6oNapPUwqTEm7EDPNFrwY0xia3GlS1ZdA/640?wx_fmt=png&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图8 复制滞后问题&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除了这两种情况外还有一种情况，如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;403&quot; data-ratio=&quot;0.71875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVa7LohicftibUPWDbaAzPicJZlhNicSDPo72DBA8gU73qmpces18PDY2oyng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1152&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图9 复制滞后问题&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个问题会比前面的例子看上去更荒唐，这里有两个写入客户端，其中Poons问了个问题，然后Cake做出了回答。从顺序上，MrsCake是看到Poons的问题之后才进行的回答，但是问题与回答恰好被划分到了数据库的两个分区（&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;）上，对于下面的Observer而言，Partition1的Leader延迟要远大于Partition2的延迟，因此从Observer上看到的是现有答案后有的问题，这显然是一个违反自然规律的事情，如果能避免这种问题出现，那么可称为系统实现了“前缀读一致性”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上一篇中，我们介绍了一可以检测类似这种因果的方式，但综上，我们可以看到，由于复制的滞后性，带来的一个后果就是系统只是具备了最终一致性，由于这种最终一致性，会大大的影响用户的一些使用体验。上面三个例子虽然代表了不同的一致性，但都有一个共性，就是由于复制的滞后性带来的问题。所谓复制，那就是多个客户端甚至是一个客户端读写多个副本时所发生的的问题。这里我们将这类一致性问题称为“内部一致性（&lt;/span&gt;&lt;span&gt;内存一致性&lt;/span&gt;&lt;span&gt;）”，即表征由于多个副本读写的时序存在的数据不一致问题。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 内部一致性概述&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;实际上，内部一致性并不是分布式系统特有的问题，在多核领域又称内存一致性，是为了约定多处理器之间协作。如果多处理器间能够满足特定的一致性，那么就能对多处理器所处理的数据，操作顺序做出一定的承诺，应用开发人员可以根据这些承诺对自己的系统做出假设。如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;257&quot; data-ratio=&quot;0.4444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVaE8C1fbKfOjT7nEcEjEiaZRjJa7HgRETYZ164nibs6GMcUHvGVm580j1Q/640?wx_fmt=png&quot; data-w=&quot;990&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图10 CPU结构&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每个CPU逻辑核心都有自己的一套独立的寄存器和L1、L2Cache，这就导致如果我们在并发编程时，每个线程如果对某个主存地址中变量进行修改，可能都是优先修改自己的缓存，并且读取变量时同样是会先读缓存。这实际上和我们在分布式中多个客户端读写多个副本的现象是类似的，只不过分布式系统中是操作粒度，而处理器则是指令粒度。在多处理器的内存一致性中，有下面几种常见的模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;257&quot; data-ratio=&quot;0.4444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVaE8C1fbKfOjT7nEcEjEiaZRjJa7HgRETYZ164nibs6GMcUHvGVm580j1Q/640?wx_fmt=png&quot; data-w=&quot;990&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图11 内存一致性——百度百科&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到，这些一致性约束的核心区分点就是在产生并发时对顺序的约束，而用更专业一点的词来说，线性一致性需要的是定义“全序”，而其他一致性则是某种“偏序”，也就是说允许一些并发操作间不比较顺序，按所有可能的排列组合执行。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3 举一反三：分布式系统中的内部一致性&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;512&quot; data-ratio=&quot;0.8861386138613861&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVaX20czv2TZv4vbE7MPNPk5xDe4GsUk370aVKOn72pcWzgTibjicc7hvdQ/640?wx_fmt=png&quot; data-w=&quot;808&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图12 内存一致性&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分布式中的内部一致性主要分为4大类：线性一致性--&amp;gt;顺序一致性--&amp;gt;因果一致性--&amp;gt;处理器一致性，而从偏序与全序来划分，则划分为强一致性（&lt;/span&gt;&lt;span&gt;线性一致性&lt;/span&gt;&lt;span&gt;）与最终一致性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但需要注意的是，只要不是强一致的内部一致性，但最终一致性没有任何的偏序保障。图中的这些一致性实际都是做了一些偏序的限制，比朴素的最终一致性有更强的保证，这里其他一致性性的具体实例详见《大数据日知录》第二章，那里面有比较明确对于这些一致性的讲解，本章我们重点关注强一致。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.4 我们口中的“强一致性”——线性一致性&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;满足线性一致性的系统给我们这样一种感觉，这系统看着只有一个副本，这样我就可以放心地读取任何一个副本上的数据来继续我们的应用程序。这里还是用一个例子来具体说明线性一致性的约束，如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;219&quot; data-ratio=&quot;0.3796680497925311&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVanII9n3U7vdN9syWImHgoDibRxdgU9zf0hETKyyCic50JmU2HGaB0qhag/640?wx_fmt=png&quot; data-w=&quot;964&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图13 线性一致性&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里有三个客户端同时操作主键x，这个主键在书中被称为寄存器（&lt;/span&gt;&lt;span&gt;Register&lt;/span&gt;&lt;span&gt;），对该寄存器存在如下几种操作：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;write(x，v) =&amp;gt;r表示尝试更新x的值为v，返回更新结果r。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;read(x) =&amp;gt; v表示读取x的值，返回x的值为v。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;如图中所示，在C更新x的值时，A和B反复查询x的最新值，比较明确的结果是由于ClientA在ClientC更新x之前读取，所以第一次read(x)一定会为0，而ClientA的最后一次读取是在ClientC成功更新x的值后，因此一定会返回1。而剩下的读取，由于不确定与write(x,1)的顺序（&lt;/span&gt;&lt;span&gt;并发&lt;/span&gt;&lt;span&gt;），因此可能会返回0也可能返回1。对于线性一致性，我们做了下面的规定：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;220&quot; data-ratio=&quot;0.3810483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVaYvm52R5b4UDHRPTjDCm32PribSt0Dcxk1Gg4QT53T1u8Pn9LzCpoHCw/640?wx_fmt=png&quot; data-w=&quot;992&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图14 线性一致性&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在一个线性一致性系统中，在写操作调用到返回之前，一定有一个时间点，客户端调用read能读到新值，在读到新值之后，后续的所有读操作都应该返回新值。（&lt;/span&gt;&lt;span&gt;将上面图中的操作做了严格的顺序，及ClientA read-&amp;gt;ClientB read-&amp;gt;ClientC write-ClientA read-&amp;gt;clientB read-&amp;gt;clientAread&lt;/span&gt;&lt;span&gt;）这里为了清晰，书中做了进一步细化。在下面的例子中，又增加了一种操作：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;cas(x, v_old, v_new)=&amp;gt;r  及如果此时的值时v_old则更新x的值为v_new，返回更新结果。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;如图：每条数显代表具体事件发生的时点，线性一致性要求：如果连接上述的竖线，要求必须按照时间顺序向前推移，不能向后回拨（&lt;/span&gt;&lt;span&gt;图中的read(x)=2就不满足线性化的要求，因为x=2在x=4的左侧&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;332&quot; data-ratio=&quot;0.5742971887550201&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVak5KVQ3Wh7zR65PcV58lDzC2QtNE1mbW8Q4rfe1JvTzxFmMic7OicDm4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;996&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图15 线性一致性&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.5 什么时候需要依赖线性化？&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;如果只是类似论坛中评论的先后顺序，或者是体育比赛页面刷新页面时的来回跳变，看上去并不会有什么致命的危害。但在某些场景中，如果系统不是线性的可能会造成更严重的后果。&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;加锁&amp;amp;&amp;amp;选主：在主从复制模型下，需要有一个明确的主节点去接收所有写请求，这种选主操作一般会采用加锁实现，如果我们依赖的锁服务不支持线性化的存储，那就可能出现跳变导致“脑裂”现象的发生，这种现象是绝对不能接受的。因此针对选主场景所依赖的分布式锁服务的存储模块一定需要满足线性一致性（&lt;/span&gt;&lt;span&gt;一般而言，元数据的存储也需要线性化存储&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;约束与唯一性保证：这种场景也是显而易见的，比如唯一ID、主键、名称等等，如果没有这种线性化存储承诺的严格的顺序，就很容易打破唯一性约束导致很多奇怪的现象和后果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;跨通道（&lt;/span&gt;&lt;span&gt;系统&lt;/span&gt;&lt;span&gt;）的时间依赖：除了同一系统中，可能服务横跨不同系统，对于某个操作对于不同系统间的时序也需要有限制，书中举了这样一个例子。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;241&quot; data-ratio=&quot;0.41767068273092367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVaUo8nVCW75SbMC804ByG9OGrFnkkEVgiaqadtibcjWCbF6SibAB9y1xC5g/640?wx_fmt=png&quot; data-w=&quot;996&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图16 跨通道线性一致性&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如用户上传图片，类似后端存储服务可能会根据全尺寸图片生成低像素图片，以便增加用户服务体验，但由于MQ不适合发送图片这种大的字节流，因此全尺寸图片是直接发给后端存储服务的，而截取图片则是通过MQ在后台异步执行的，这就需要2中上传的文件存储服务是个可线性化的存储。如果不是，在生成低分辨率图像时可能会找不到，或读取到半张图片，这肯定不是我们希望看到的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;线性化不是避免竞争的唯一方法，与事务隔离级别一样，对并发顺序的要求，可能会根据场景不同有不同的严格程度。这也就诞生了不同级别的内部一致性级别，不同的级别也同样对应着不同的开销，需要用户自行决策。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.6 实现线性化系统&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;说明了线性化系统的用处，下面我们来考虑如何实现这样的线性化系统。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据上文对线性化的定义可知，这样系统对外看起来就像只有一个副本，那么最容易想到的方式就是，干脆就用一个副本。但这又不是分布式系统的初衷，很大一部分用多副本是为了做容错的，多副本的实现方式是复制，那么我们来看看，上一篇分享中那些常见的复制方式是否可以实现线性系统：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主从复制（&lt;/span&gt;&lt;span&gt;部分能实现&lt;/span&gt;&lt;span&gt;）：如果使用同步复制，那样系统确实是线性化的，但有一些极端情况可能会违反线性化，比如由于成员变更过程中的“脑裂”问题导致消费异常，或者如果我们使用异步复制故障切换时会同时违反事务特性中的持久化和内部一致性中的线性化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;共识算法（&lt;/span&gt;&lt;span&gt;线性化&lt;/span&gt;&lt;span&gt;）：共识算法在后文会重点介绍，它与主从复制类似，但通过更严格的协商机制实现，可以在主从复制的基础上避免一些可能出现的“脑裂”等问题，可以比较安全的实现线性化存储。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多主复制（&lt;/span&gt;&lt;span&gt;不能线性化&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无主复制（&lt;/span&gt;&lt;span&gt;可能不能线性化&lt;/span&gt;&lt;span&gt;）：主要取决于具体Quorum的配置，对强一致的定义，下图给了一种虽然满足严格的Quorum，但依然无法满足线性化的例子。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;0.6052631578947368&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVagq2ibZCLKVgKfX82icUwj3sVvFrHBuvBaqU43ydYj30qEicRDW38d2cXw/640?wx_fmt=png&quot; data-w=&quot;912&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图17 Quorum无法实现线性一致&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实现线性化的代价——是时候登场了，CAP理论&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在上一次分享中，我们讲过，分布式系统中网络的不可靠性，而一旦网络断开（&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;），副本间一定会导致状态无法达到线性一致，这时候到底是继续提供服务但可能得到旧值（&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;），还是死等网络恢复保证状态的线性一致呢（&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;），这就是著名的CAP了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是其实CAP理论的定义面还是比较窄的，其中C只是线性一致性，P只代表网络分区（&lt;/span&gt;&lt;span&gt;彻底断开，而不是延迟&lt;/span&gt;&lt;span&gt;），这里面实际有相当多的折中，就可以完全满足我们系统的需求了，所以不要迷信这个理论，还是需要根据具体的实际情况去做分析。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;层层递进——实现线性化系统&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;从对线性一致性的定义我们可以知道，顺序的检测是实现线性化系统的关键，这里我们跟着书中的思路一步步地来看：我们怎么能对这些并发的事务定义出它们的顺序。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;a. 捕捉因果关系&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;与上一次分享的内容类似，并发操作间有两种类型，可能有些操作间具有天然逻辑上的因果关系，还有些则没法确定，这里我们首先先尝试捕获那些有因果关系的操作，实现个因果一致性。这里的捕获我们实际需要存储数据库（&lt;/span&gt;&lt;span&gt;系统&lt;/span&gt;&lt;span&gt;）操作中的所有因果关系，我们可以使用类似版本向量的方式（&lt;/span&gt;&lt;span&gt;忘记的同学，可以回看上一篇中两个人并发操作购物车的示例&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;b. 化被动为主动——主动定义&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;上面被动地不加任何限制的捕捉因果，会带来巨大的运行开销（&lt;/span&gt;&lt;span&gt;内存，磁盘&lt;/span&gt;&lt;span&gt;），这种关系虽然可以持久化到磁盘，但分析时依然需要被载入内存，这就让我们有了另一个想法，我们是否能在操作上做个标记，直接定义这样的因果关系？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最最简单的方式就是构建一个全局发号器，产生一些序列号来定义操作间的因果关系，比如需要保证A在B之前发生，那就确保A的全序ID在B之前即可，其他的并发操作顺序不做硬限制，但操作间在处理器的相对顺序不变，这样我们不但实现了因果一致性，还对这个限制进行了增强。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;c. Lamport时间戳&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;上面的设想虽然比较理想，但现实永远超乎我们的想象的复杂，上面的方式在主从复制模式下很容易实现，但如果是多主或者无主的复制模型，我们很难设计这种全局的序列号发号器，书中给出了一些可能的解决方案，目的是生成唯一的序列号，比如：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每个节点各自产生序列号。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每个操作上带上时间戳。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;预先分配每个分区负责产生的序列号。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;但实际上上面的方法都可能破坏因果关系的偏序承诺，原因就是不同节点间负载不同、时钟不同、参照系不同。这里我们的并发大神Lamport登场了，他老人家自创了一个Lamport逻辑时间戳，完美地解决了上面的所有问题。如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;275&quot; data-ratio=&quot;0.47578947368421054&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVa77L5pibyx7ofYPgL8NscxEicouGhXXkaXUsJw3q4RE5kSt0kLqJFqRPw/640?wx_fmt=png&quot; data-w=&quot;950&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;图18 Lamport时间戳&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;初识Lamport时间戳，还是研究生分布式系统课上，当时听得云里雾里，完全不知道在说啥。今天再次拿过来看，有了上下文，稍微懂了一点点。简单来说定义的就是使用逻辑变量定义了依赖关系，它给定了一个二元组&amp;lt;Counter, NodeId&amp;gt;，然后给定了一个比较方式：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先比较Counter，Counter大的后发生（&lt;/span&gt;&lt;span&gt;会承诺严格的偏序关系&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果Counter相同，直接比较NodeId，大的定义为后发生（&lt;/span&gt;&lt;span&gt;并发关系&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;如果只有这两个比较，还不能解决上面的因果偏序被打破的问题，但是这个算法不同的是，它会把这个Node的Counter值内嵌到请求的响应体中，比如图中的A，在第二次向Node2发送更新max请求时，会返回当前的c=5，这样Client会把本地的Counter更新成5，下一次会增1这样使用Node上的Counter就维护了各个副本上变量的偏序关系，如果并发往两个Node里写就直接定义为并发行为，用NodeId定义顺序了。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;d. 我们可以实现线性化了吗——全序广播&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;到此我们可以确认，有了Lamport时间戳，我们可以实现因果一致性了，但仍然无法实现线性化，因为我们还需要让这个全序通知到所有节点，否则可能就会无法做决策。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;举个例子，针对唯一用户名这样的场景，假设ABC同时向系统尝试注册相同的用户名，使用Lamport时间戳的做法是，在这三个并发请求中最先提交的返回成功，其他返回失败，但这里面我们因为有“上帝视角”，知道ABC，但实际请求本身在发送时不知道有其他请求存在（&lt;/span&gt;&lt;span&gt;不同请求可能被发送到了不同的节点上&lt;/span&gt;&lt;span&gt;）这样就需要系统做这个收集工作，这就需要有个类似协调者来不断询问各个节点是否有这样的请求，如果其中一个节点在询问过程中发生故障，那系统无法放心决定每个请求具体的RSP结果。所以最好是系统将这个顺序广播到各个节点，让各个节点真的知道这个顺序，这样可以直接做决策。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;假设只有单核CPU，那么天然就是全序的，但是现在我们需要的是在多核、多机、分布式的情况下实现这个全序的广播，就存在这一些挑战。主要挑战个人认为是两个：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于多机，实际上实现全序广播最简单的实现方式使用主从模式的复制，让所有的操作顺序让主节点定义，然后按相同的顺序广播到各个从节点。对于分布式环境，需要处理部分失效问题，也就是如果主节点故障需要处理主成员变更。下面我们就来看看书中是怎么解决这个问题的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;这里所谓的全序一般指的是分区内部的全序，而如果需要跨分区的全序，需要有额外的工作&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于全序广播，书中给了两条不变式：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可靠发送：需要保证消息做到all-or-nothing的发送（&lt;/span&gt;&lt;span&gt;想想上一章&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;严格有序：消息需要按完全相同的顺序发给各个节点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;实现层面&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们对着上面的不变式来谈谈简单的实现思路，首先要做到可靠发送，这里有两层含义：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消息不能丢&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消息不能发一部分&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;其中消息不能丢意味着如果某些节点出现故障后需要重试，如果需要安全的重试，那么广播操作本身失败后就不能对系统本身有副作用，否则就会导致消息发送到部分节点上的问题。上一章的事务的原子性恰好就解决的是这个问题，这里也就衍射出我们需要采用事务的一些思路，但与上面不同，这个场景是分布式系统，会发到多个节点，所以一定是分布式事务（&lt;/span&gt;&lt;span&gt;耳熟能详的2PC一定少不了&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外一条是严格有序，实际上我们就是需要一个能保证顺序的数据结构，因为操作是按时间序的一个Append-only结构，恰好Log能解决这个问题，这里引出了另一个常会被提到的技术，复制状态机，这个概念是我在Raft的论文中看到的，假设初始值为a，如果按照相同的顺序执行操作ABCDE最后得到的一定是相同的结果。因此可以想象，全序广播最后的实现一定会用到Log这种数据结构。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;e. 线性系统的实现&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;现在假设我们已经有了全序广播，那么我们继续像我们的目标--线性化存储迈进，首先需要明确一个问题，线性化并不等价于全序广播，因为在分布式系统模型中我们通常采用异步模型或者半同步模型，这种模型对于全序关系何时成功发送到其他节点并没有明确的承诺，因此还需要再全序广播上做点什么才真正能实现线性化系统。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;书中仍然举了唯一用户名的例子：可以采用线性化的CAS操作来实现，当用户创建用户名时当且仅当old值为空。实现这样的线性化CAS，直接采用全序广播+Log的方式。&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在日志中写入一条消息，表明想要注册的用户名。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;读取日志，将其广播到所有节点并等待回复 （&lt;/span&gt;&lt;span&gt;同步复制&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果表名第一次注册的回复来自当前节点，提交这条日志，并返回成功，否则如果这条回复来自其他节点，直接向客户端返回失败。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;而这些日志条目会以相同的顺序广播到所有节点，如果出现并发写入，就需要所有节点做决策，是否同意，以及同意哪一个节点对这个用户名的占用。以上我们就成功实现了一个对线性CAS的写入的线性一致性。然而对于读请求，由于采用异步更新日志的机制，客户端的读取可能会读到旧值，这可能需要一些额外的工作保证读取的线性化。&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线性化的方式获取当前最新消息的位置，即确保该位置之前的所有消息都已经读取到，然后再进行读取（&lt;/span&gt;&lt;span&gt;ZK中的sync()&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在日志中加入一条消息，收到回复时真正进行读取，这样消息在日志中的位置可以确定读取发生的时间点。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从保持同步更新的副本上读取数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.7 共识&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;上面我们在实现线性化系统时，实际上就有了一点点共识的苗头了，即需要多个节点对某个提议达成一致，并且一旦达成，不能被撤销。在现实中很多场景的问题都可以等价为共识问题：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可线性化的CAS&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;原子事务提交&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;全序广播&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分布式锁与租约&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;成员协调&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;唯一性约束&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;实际上，为以上任何一个问题找到解决方案，都相当于实现了共识。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;两阶段提交&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;a. 实现&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;书中直接以原子提交为切入点来聊共识。这里不过多说明，直接介绍两阶段提交，根据书中的描述，两阶段提交也算是一种共识算法，但实际上在现实中，我们更愿意把它当做实现更好共识算法的一个手段以及分布式事务的核心实现方法（&lt;/span&gt;&lt;span&gt;Raft之类的共识算法实际上都有两阶段提交这个类似的语义&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3992467043314501&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVadqyicaq4xeQb9LJawSRUhicvRib3aQ2bQkoPeFkfTueBEFCP0Wkq9uic5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;图19 两阶段提交&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个算法实际上比较朴素，就是两个阶段，有一个用于收集信息和做决策的协调者，然后经过朴素的两个阶段：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;协调者向参与者发送准备请求询问它们是否可以提交，如果参与者回答“是”则代表这个参与者一定会承诺提交这个消息或者事务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果协调者收到所有参与者的区确认信息，则第二阶段提交这个事务，否则如果有任意一方回答“否”则终止事务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;这里一个看似非常简单的算法，平平无奇，无外乎比正常的提交多了个准备阶段，为什么说它就可以实现原子提交呢？这源于这个算法中的约定承诺，让我们继续拆细这个流程：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当启动一个分布式事务时，会向协调者请求一个事务ID。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应用程序在每个参与节点上执行单节点事务，并将这个ID附加到操作上，这是读写操作都是单节点完成，如果发生问题，可以安全的终止（&lt;/span&gt;&lt;span&gt;单节点事务保证&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当应用准备提交时，协调者向所有参与者发送Prepare，如果这是有任何一个请求发生错误或超时，都会终止事务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参与者收到请求后，将事务数据写入持久化存储，并检查是否有违规等，&lt;strong&gt;此时出现了第一个承诺：如果参与者向协调者发送了“是”意味着该参与者一定不会再撤回事务&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当协调者收到所有参与者的回复后，根据这些恢复做决策，如果收到全部赞成票，则将“提交”这个决议写入到自己本地的持久化存储，&lt;strong&gt;这里会出现第二个承诺：协调者一定会提交这个事务，直到成功&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;假设提交过程出现异常，协调者需要不停重试，直到重试成功。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;正是由于上面的两个承诺保证了2PC能达成原子性，也是这个范式存在的意义所在。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;b. 局限性&lt;/span&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;协调者要保存状态，因为协调者在决定提交之后需要担保一定要提交事务，因此它的决策一定需要持久化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;协调者是单点，那么如果协调者发生问题，并且无法恢复，系统此时完全不知道应该提交还是要回滚，就必须交由管理员来处理。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;两阶段提交的准备阶段需要所有参与者都投赞成票才能继续提交，这样如果参与者过多，会导致事务失败概率很大。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更为朴素的共识算法定义&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;看完了一个特例，书中总结了共识算法的几个特性：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;协商一致性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：所有节点都接受相同的提议。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;诚实性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：所有节点一旦做出决定，不能反悔，不能对一项提议不能有两次不同的决议。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;合法性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：如果决定了值v，这个v一定是从某个提议中得来的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;可终止性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：节点如果不崩溃一定能达成决议。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;如果我们用这几个特性对比2PC，实际上却是可以认为它算是个共识算法，不过这些并不太重要，我们重点还是看这些特性会对我们有什么样的启发。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前三个特性规定了安全性（&lt;/span&gt;&lt;span&gt;Safety&lt;/span&gt;&lt;span&gt;），如果没有容错的限制，直接人为指定个Strong Leader，由它来充当协调者，但就像2PC中的局限性一样，协调者出问题会导致系统无法继续向后执行，因此需要有额外的机制来处理这种变更（&lt;/span&gt;&lt;span&gt;又要依赖共识&lt;/span&gt;&lt;span&gt;），第四个特性则决定了活性（&lt;/span&gt;&lt;span&gt;Liveness&lt;/span&gt;&lt;span&gt;）之前的分型中说过，安全性需要优先保证，而活性的保证需要前提。这里书中直接给出结论，想让可终止性满足的前提是大多数节点正确运行。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;共识算法与全序广播&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;实际在最终设计算法并落地时，并不是让每一条消息去按照上面4条特性来一次共识，而是直接采用全序广播的方式，全序广播承诺消息会按相同的顺序发送给各个节点，且有且仅有一次，这就相当于在做多轮共识，每一轮，节点提出他们下面要发送的消息，然后决定下一个消息的全序。使用全序广播实现共识的好处是能提供比单轮共识更高的效率（&lt;/span&gt;&lt;span&gt;ZAB, Raft，Multi-paxos&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;讨论&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;这里面还有一些事情可以拿出来做一些讨论。首先，从实现的角度看，主从复制的模式特别适用于共识算法，但在之前介绍主从复制时，但光有主从复制模型对解决共识问题是不够的，主要有两点：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主节点挂了如何确定新主&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如何防止脑裂&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;这两个问题实际上是再次用了共识解决。在共识算法中，实际上使用到了epoch来标识逻辑时间，例如Raft中的Term，Paxos中的Balletnumber，如果在选举后，有两个节点同时声称自己是主，那么拥有更新Epoch的节点当选。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同样的，在主节点做决策之前，也需要判断有没有更高Epoch的节点同时在进行决策，如果有，则代表可能发生冲突（&lt;/span&gt;&lt;span&gt;Kafka中低版本只有Controller有这个标识，在后面的版本中，数据分区同样带上了类似的标识&lt;/span&gt;&lt;span&gt;）。此时，节点不能仅根据自己的信息来决定任何事情，它需要收集Quorum节点中收集投票，主节点将提议发给所有节点，并等待Quorum节点的返回，并且需要确认没后更高Epoch的主节点存在时，节点才会对当前提议做投票。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;详细看这里面涉及两轮投票，使用Quorum又是在使用所谓的重合，如果某个提议获得通过，那么投票的节点中一定参加过最近一轮主节点的选举。这可以得出，此时主节点并没有发生变化，可以安全的给这个主节点的提议投票。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，乍一看共识算法全都是好处，但看似好的东西背后一定有需要付出的代价：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在达成一致性决议前，节点的投票是个同步复制，这会使得共识有丢消息的风险，需要在性能和线性一直间权衡（&lt;/span&gt;&lt;span&gt;CAP&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多数共识架设了一组固定的节点集，这意味着不能随意的动态变更成员，需要深入理解系统后才能做动态成员变更（&lt;/span&gt;&lt;span&gt;可能有的系统就把成员变更外包了&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;共识对网络极度敏感，并且一般采用超时来做故障检测，可能会由于网络的抖动导致莫名的无效选主操作，甚至会让系统进入不可用状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;外包共识&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;虽然可以根据上面的描述自己来实现共识算法，但成本可能是巨大的，最好的方式可能是将这个功能外包出去，用成熟的系统来实现共识，如果实在需要自己实现，也最好是用经过验证的算法来实现，不要自己天马行空。ZK和etcd等系统就提供了这样的服务，它们不仅自己通过共识实现了线性化存储，而且还对外提供共识的语义，我们可以依托这些系统来实现各种需求：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线性化CAS&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;操作全序&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;故障检测&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;配置变更&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.8 本章小结&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;本章花费了巨大力气讲解了分布式系统中的另一种一致性问题，内部一致性，这种问题主要是因为复制的滞后性产生，首先我们介绍了这种问题的起源，然后映射到分布式系统中，对不同一致性进行分类。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于里面的强一致性，我们进行了详细的探讨，包括定义、使用场景以及实现等方面，并从中引出了像全序与偏序、因果关系的捕捉与定义（&lt;/span&gt;&lt;span&gt;Lamport时间戳&lt;/span&gt;&lt;span&gt;）、全序广播、2PC最后到共识，足以见得这种一致性解决起来的复杂性。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 再谈分布式系统&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;至此，我们从复制这一主题出发，讨论了分布式系统复制模型、挑战、事务以及共识等问题，这里结合两篇文章的内容，我尝试对分布式系统给出更细节的描述，首先描述特性和问题，然后给出特定的解决。&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;与单机系统一样，分布式系统同样会有多个客户端同时对系统产生各种操作。每个操作所涉及的对象可能是一个，也可能是多个，这些客户端并发的操作可能会产生正确性问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;为了实现容错，分布式系统的数据一般会有多个备份，不同副本之间通过复制实现。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;常见复制模型包括：&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;而从时效性和线性一致性出发，可分为：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;异步复制可能存在滞后问题，会引发各种内部一致性问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;分布式系统相比单机系统，具有两个独有的特点。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;面对这么多问题，如果一个理想的分布式数据系统，如果不考虑任何性能和其他的开销，我们期望实现的系统应该是这样的：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;整个系统的数据对外看起来只有一个副本，这样用户并不用担心更改某个状态时出现任何的不一致（&lt;/span&gt;&lt;span&gt;线性一致性&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;整个系统好像只有一个客户端在操作，这样就不用担心和其他客户端并发操作时的各种冲突问题（&lt;/span&gt;&lt;span&gt;串行化&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;所以我们知道，线性一致性和串行化是两个正交的分支，分别表示外部一致性中的最高级别以及内部一致性的最高级别。如果真的实现这个，那么用户操作这个系统会非常轻松。但很遗憾，达成这两方面的最高级别都有非常大的代价，因此由着这两个分支衍生出各种的内部一致性和外部一致性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;用Jepsen官网对这两种一致性的定义来说，内部一致性约束的是单操作对单对象可能不同副本的操作需要满足时间全序，而外部一致性则约束了多操作对于多对象的操作。这类比于Java的并发编程，内部一致性类似于volatile变量或Atomic的变量用来约束实现多线程对同一个变量的操作，而外部一致性则是类似于synchronize或者AQS中的各种锁来保证多线程对于一个代码块（&lt;/span&gt;&lt;span&gt;多个操作，多个对象&lt;/span&gt;&lt;span&gt;）的访问符合程序员的预期。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6679611650485436&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVaZ9wKKmibyQZJpL6icB2EFqo6YRkiagkxBr9fHSzMYdByKGJNbHibDdEQuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1030&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;span&gt;图20 一致性&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是需要注意的是，在分布式系统中，这两种一致性也并非完全孤立，我们一般采用共识算法来实现线性一致，而在实现共识算法的过程中，同样可能涉及单个操作涉及多个对象的问题，因为分布式系统的操作，往往可能是作用在多个副本上的。也就是说，类似2PC这样的分布式事务同样会被用来解决共识问题（&lt;/span&gt;&lt;span&gt;虽然书中把它也成为共识，但其实还是提供了一种类似事务原子性的操作&lt;/span&gt;&lt;span&gt;），就像Java并发编程中，我们在synchronize方法中也可能会使用一些volatile变量一样。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而2PC不是分布式事务的全部，可能某些跨分区的事务同样需要用基于线性一致性的操作来满足对某个对象操作的一致性。也就是说想完整的实现分布式的系统，这两种一致性互相依赖，彼此互补，只有我们充分了解它们的核心作用，才能游刃有余地在实战中应用这些看似枯燥的名词。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. 士别三日，当刮目相看--再看Kafka&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;了解完上面这些一致性，我们再回过头来看看Kafka的实复制，我们大致从复制模型、内部一致性、外部一致性等角度来看。Kafka中与复制模式相关的配置大致有下面几个：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;复制因子（&lt;/span&gt;&lt;span&gt;副本数&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;min.insync.replicas&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;acks&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;用户首先通过配置acks先大体知道复制模式，如果ack=1或者0，则表示完全的异步复制；如果acks=all则代表完全的同步复制。而如果配置了异步复制，那么单分区实际上并不能保证线性一致性，因为异步复制的滞后性会导致一旦发生Leader变更可能丢失已经提交的消息，导致打破线性一致性的要求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而如果选择ack=-1，则代表纯的同步复制，而此时如果没有min.insync.replicas的限制，那样会牺牲容错，多副本本来是用来做容错，结果则是有一个副本出问题系统就会牺牲掉Liveness。而min.insync.replicas参数给了用户做权衡的可能，一般如果我们要保证单分区线性一致性，需要满足多数节点正常工作，因此我们需要配置min.insync.replicas为majority。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而针对部分失效的处理，在实现复制时，kafka将成员变更进行了外包，对于数据节点而言，托管给Controller，直接由其指定一个新的主副本。而对于Controller节点本身，则将这个职责托管给了外部的线性存储ZK，利用ZK提供的锁于租约服务帮助实现共识以达成主节点选举，而在高版本中，Kafka去掉了外部的共识服务，而转而自己用共识算法实现Controller选主，同时元数据也由原来依赖ZK变为自主的Kraft实现的线性化存储进行自治。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而在外部一致性范畴，目前低版本Kafka并没有类似事务的功能，所以无法支持多对象的事务，而高版本中，增加了事务的实现（&lt;/span&gt;&lt;span&gt;详见&lt;/span&gt;&lt;a href=&quot;http://matt33.com/2018/11/04/kafka-transaction/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;blog&lt;/span&gt;&lt;/a&gt;）&lt;span&gt;。由于对象跨越多机，因此需要实现2PC，引入了TransactionCoordinator来承担协调者，参考上面2PC的基本流程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个大致的实现流程基本如下：首先向协调者获取事务ID（&lt;/span&gt;&lt;span&gt;后文统称TID&lt;/span&gt;&lt;span&gt;），然后向参与者发送请求准备提交，带上这个TID，参与者现在本地做append，如果成功返回，协调者持久化决策的内容，然后执行决策，参与者将消息真正写到Log中（&lt;/span&gt;&lt;span&gt;更新LSO，与HW高水位区分&lt;/span&gt;&lt;span&gt;）。但是上文也讲了2PC实际上是有一些问题的，首先2PC协调者的单点问题，Kafka的解决方法也比较简单，直接利用自己单分区同步复制保证线性一致性的特性，将协调者的状态存储在内部Topic中，然后当协调者崩溃时可以立刻做转移然后根据Topic做恢复，因为Topic本身就单分区而言就是个线性存储。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，就是2PC的协调者本质是个主从复制的过程，由于TransactionCoordinator本来就挂靠在Broker上，所以这个选举依然会委托给Controller，这样就解决了2PC中的比较棘手的问题。而对于事务的隔离级别，Kafka仅实现到了“读已提交（&lt;/span&gt;&lt;span&gt;RC&lt;/span&gt;&lt;span&gt;）”级别。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7. 分布式系统验证框架&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;在分布式领域有两把验证分布式算法的神器，其中一款是用于白盒建模的工具TLA+&lt;/span&gt;&lt;a href=&quot;https://lamport.azurewebsites.net/tla/tla.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;TLA Homepage&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，对于TLA+，个人强烈推荐看一看Lamport老人家的视频教程&lt;/span&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV15a411A7k1/?spm_id_from=333.788.recommend_more_video.1&amp;amp;vd_source=efafd41e8d4e8300dd4a3482b964cb9c&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;视频教程（带翻译）&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，或去看一看《Specifing Systems》。我们会知道，这个语言不光能定义分布式算法，应该说是可以定义整个计算机系统，如果掌握了使用数学定义系统的能力，可以让我们从代码细节中走出来，以状态机的思维来看待系统本身，我们可能会有不一样的感悟。TLA+的核心是通过数学中的集合论，数理逻辑和状态搜索来定义系统的行为。我们需要正确的对我们的系统或算法做抽象，给出形式化的规约，然后使用TLA+进行验证。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另一款则是黑盒&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://jepsen.io/&quot; textvalue=&quot;Jepsen Homepage&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Jepsen Homepage&lt;/a&gt;&lt;/span&gt;&lt;span&gt;，其核心原理则是生成多个客户端对一个存储系统进行正常的读写操作并记录每次操作的结果，在测试中间引入故障，最后根据检测这些操作历史是否符合各种一致性所满足的规定。我们简单看下它的架构，然后本文将大致演示它的使用方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;491&quot; data-ratio=&quot;0.8493827160493828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVboL0PYL0ZTicsMU8qhtfVapFWwWRcz27LVyOOKcCm9ibYMWTqcicIhqQfRF4OQmVbtJCmWaxV4z2iaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图21 Jepsen&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Jepsen主要有下面几个模块构成：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DB Node（&lt;/span&gt;&lt;span&gt;引擎本身的节点，存储节点&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Control Node 控制节点，负责生成客户端，生成操作，生成故障等，其与DB Node通常是SSH免密的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Client 客户端用于进行正常读写操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Generator 用来生成计划。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Nemesis 故障制造者。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Checker 用来进行最后的一致性校验。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;我们团队使用Jepsen测试了Kafka系统的一致性，其中Kafka客户端与服务端的配置分别为：同步复制（&lt;/span&gt;&lt;span&gt;ack=-1&lt;/span&gt;&lt;span&gt;），3复制因子（&lt;/span&gt;&lt;span&gt;副本数&lt;/span&gt;&lt;span&gt;），最小可用副本为2（&lt;/span&gt;&lt;span&gt;min.insync.isr&lt;/span&gt;&lt;span&gt;）。在该配置下，Jepsen内置的故障注入最后均通过了验证。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8. 小结&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;我们的数据之旅到这里就要告一段落了，希望大家通过我的文章了解常见分布式系统的核心问题，以及面对这些问题所谓的事务，一致性和共识所能解决的问题和内在联系，能够在适当的时候合理的使用校验工具或框架对我们的系统的正确性和活性进行校验，这样就达到两篇系列文章的目的了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分布式系统是个“大家伙”，希望今后能够跟大家一起继续努力，先将其“庖丁解牛”，然后再“逐个击破”，真正能够掌控一些比较复杂的分布式系统的设计。最后感谢团队中的小伙伴们，能将这样的思考系统化的产出，离不开组内良好的技术分享文化和浓厚的技术氛围，也欢迎大家加入美团技术团队。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9. 作者简介&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;仕禄，美团基础研发平台/数据科学与平台部工程师。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  | &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651770296&amp;amp;idx=1&amp;amp;sn=058448855d5ce0a9af2e495903fc0d05&amp;amp;chksm=bd1214f58a659de30c3974f7658ebbc54cbb3bf4371beb13ea1efd7868f556fd3d423eab27a7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka在美团数据平台的实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651770296&amp;amp;idx=1&amp;amp;sn=058448855d5ce0a9af2e495903fc0d05&amp;amp;chksm=bd1214f58a659de30c3974f7658ebbc54cbb3bf4371beb13ea1efd7868f556fd3d423eab27a7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka在美团数据平台的实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Kafka在美团数据平台的实践&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt;&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651756933&amp;amp;idx=1&amp;amp;sn=a23c294fe1873d6b2c50730e47eda608&amp;amp;chksm=bd1240c88a65c9de720b8568bf7cf90a365c1df45732a36493eb58cc1ff8cf8461cb4829f102&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于SSD的Kafka应用层缓存架构设计与实现&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基于SSD的Kafka应用层缓存架构设计与实现&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=203083582&amp;amp;idx=1&amp;amp;sn=701022c664d42b54b55d43e6bc46056b&amp;amp;chksm=2f06167318719f65e90a8154a48e875f474c56e47b66aa6607f27c9ba6779ae062195720e6f6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团技术团队博客：Kafka文件存储机制那些事&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Kafka文件存储机制那些事&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765958&amp;amp;idx=1&amp;amp;sn=8201546812e5a95a2bee9dffc6d12f00&amp;amp;chksm=bd12658b8a65ec9de2f5be1e96796dfb3c8f1a374d4b7bd91266072f557caf8118d4ddb72b07&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;前端&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765981&amp;amp;idx=1&amp;amp;sn=c2dd86f15dee2cbbc89e27677d985060&amp;amp;chksm=bd1265908a65ec86d4d08f7600d1518b61c90f6453074f9b308c96861c045712280a73751c73&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;算‍法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;算法&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765982&amp;amp;idx=1&amp;amp;sn=231b41f653ac7959f3e3b8213dcec2b0&amp;amp;chksm=bd1265938a65ec85630c546169444d56377bc2f11401d251da7ca50e5d07e353aa01580c7216&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;后端&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765964&amp;amp;idx=1&amp;amp;sn=ab6d8db147234fe57f27dd46eec40fef&amp;amp;chksm=bd1265818a65ec9749246dd1a2eb3bf7798772cc4d5b4283b15eae2f80bc6db63a1471a9e61e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数‍据&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数据&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765965&amp;amp;idx=1&amp;amp;sn=37e0c56c8b080146ce5249243bfd84d8&amp;amp;chksm=bd1265808a65ec96d3a2b2c87c6e27c910d49cb6b149970fb2db8bf88045a0a85fed2e6a0b84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;安‍全&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;安全&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765972&amp;amp;idx=1&amp;amp;sn=afe02ec92762c1ce18740d03324c4ac3&amp;amp;chksm=bd1265998a65ec8f10d5f58d0f3681ddfc5325137218e568e1cda3a50e427749edb5c6a7dcf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;And‍roid&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Android&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765973&amp;amp;idx=1&amp;amp;sn=32a23bf1d278dda0398f993ab60a697e&amp;amp;chksm=bd1265988a65ec8e630ef4d24b4946ab6bd7e66702c1d712481cf3c471468a059c470a14c30d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;iO‍S&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;iOS&lt;/span&gt;&lt;/a&gt;&lt;span&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765963&amp;amp;idx=1&amp;amp;sn=a3de9ef267d07d94118c1611776a4b28&amp;amp;chksm=bd1265868a65ec906592d25ad65f2a8516338d07ec3217059e6975fc131fc0107d66a8cd2612&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运‍维&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;运维&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765974&amp;amp;idx=1&amp;amp;sn=763c1e37d04acffd0142a2852ecfb000&amp;amp;chksm=bd12659b8a65ec8dfcfeb2028ef287fae7c38f134a665375ba420556ce5d2e4cf398147bd12e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;测‍试&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ5MTI5OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVGibnsaEib3aNlqF0tOrA2RGEmNSbia2nnohE4Tpf95UyTiaSjDVbHRfY8WNBeTuLLTaVdSckkNyEx1Q/0?wx_fmt=png&quot; data-nickname=&quot;美团技术团队&quot; data-alias=&quot;meituantech&quot; data-signature=&quot;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5656e8060a2f321d82cdc78dea51ce59</guid>
<title>Spring Boot 实现通用 Auth 认证的 4 种方式</title>
<link>https://toutiao.io/k/fcb6qrq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;点击下方“&lt;/span&gt;&lt;span&gt;IT牧场&lt;/span&gt;&lt;span&gt;”，选择“设为星标”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile data-index=&quot;0&quot; data-id=&quot;MzI4ODQ3NjE2OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/C93dCHmGrWzo3r2IwZzjK44WxQwhDAlhygicTbLH8Xv5wYClRpZJvoMxJIH9oPnRcGuKneSYicF3SOvJOaB34OibQ/0?wx_fmt=png&amp;amp;wx_head=1&quot; data-nickname=&quot;程序员大目&quot; data-alias=&quot;itmuch_com&quot; data-signature=&quot;BAT 技术专家分享开发、架构、运维相关干货！&quot; data-origin_num=&quot;159&quot; data-is_biz_ban=&quot;0&quot; data-isban=&quot;0&quot; class=&quot;js_wx_tap_highlight&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;133786180813611008&quot; data-gallerysupplier=&quot;5&quot; data-ratio=&quot;0.6539589442815249&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/C93dCHmGrWwwia5P4lkawZG2lybkibKmO4MulZiaKQLuYmNgzefVMVDQGicX9EReTuUvRIZibn8O1QJBR1XKuibwXPXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1023&quot;/&gt;&lt;/p&gt;&lt;section&gt;文章介绍了spring-boot中实现通用auth的四种方式，包括 传统AOP、拦截器、参数解析器和过滤器，并提供了对应的实例代码，最后简单总结了下他们的执行顺序。&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;| 前言&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;最近一直被无尽的业务需求淹没，没时间喘息，终于接到一个能让我突破代码舒适区的活儿，解决它的过程非常曲折，一度让我怀疑人生，不过收获也很大，代码方面不明显，但感觉自己抹掉了 java、Tomcat、Spring 一直挡在我眼前的一层纱。对它们的理解上了一个新的层次。&lt;/section&gt;&lt;section&gt;好久没输出了，于是挑一个方面总结一下，希望在梳理过程中再了解一些其他的东西。由于 Java 繁荣的生态，下面每一个模块都有大量的文章专门讲述。所以我选了另外一个角度，从实际问题出发，将这些分散的知识串联起来，各位可以作为一个综述来看。各个模块的极致详细介绍，大家可以去翻官方文档或看网络上的其他博客。&lt;/section&gt;&lt;section&gt;需求很简单清晰，跟产品们提的妖艳需求一点也不一样：在我们的 web 框架里添加一个&lt;code&gt;通用&lt;/code&gt;的 appkey 白名单校验功能，希望它的扩展性更好一些。&lt;/section&gt;&lt;section&gt;这个 web 框架是部门前驱者基于 spring-boot 实现的，介于业务和 Spring 框架之间，做一些偏向于业务的通用性功能，如 日志输出、功能开关、通用参数解析等。平常是对业务透明的，最近一直忙于把需求做好，代码写好，甚至从没注意过它的存在。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;| 传统AOP&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;对于这种需求，首先想到的当然是&lt;span&gt;Spring-boot&lt;/span&gt;提供的 AOP 接口，只需要在 Controller 方法前添加切点，然后再对切点进行处理即可。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;其使用步骤如下：&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;@Aspect&lt;/code&gt; 声明一下切面类 &lt;code&gt;WhitelistAspect&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在切面类内添加一个切点 &lt;code&gt;whitelistPointcut()&lt;/code&gt;，为了实现此切点灵活可装配的能力，这里不使用 &lt;code&gt;execution&lt;/code&gt; 全部拦截，而是添加一个注解 &lt;code&gt;@Whitelist&lt;/code&gt;，被注解的方法才会校验白名单。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在切面类中使用 spring 的 AOP 注解 &lt;code&gt;@Before&lt;/code&gt; 声明一个通知方法 &lt;code&gt;checkWhitelist()&lt;/code&gt; 在 Controller 方法被执行之前校验白名单。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;切面类伪代码如下&lt;/span&gt;：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;WhitelistAspect&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__meta&quot;&gt;@Before&lt;/span&gt;(value = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;whitelistPointcut() &amp;amp;&amp;amp; @annotation(whitelist)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;checkAppkeyWhitelist&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(JoinPoint joinPoint, Whitelist whitelist)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     checkWhitelist();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__meta&quot;&gt;@Pointcut&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;@annotation(com.zhenbianshu.Whitelist)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;whitelistPointCut&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;在Controller方法上添加 &lt;code&gt;@Whitelist&lt;/code&gt; 注解实现功能。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;本例中使用了 注解 来声明切点，并且我实现了通过注解参数来声明要校验的白名单，如果之后还需要添加其他白名单的话，如通过 UID 来校验，则可以为此注解添加 &lt;code&gt;uid()&lt;/code&gt; 等方法，实现自定义校验。&lt;/section&gt;&lt;section&gt;此外，spring 的 AOP 还支持 &lt;code&gt;execution（执行方法） 、bean（匹配特定名称的 Bean 对象的执行方法）&lt;/code&gt;等切点声明方法和 &lt;code&gt;@Around（在目标函数执行中执行） 、@After（方法执行后）&lt;/code&gt; 等通知方法。&lt;/section&gt;&lt;section&gt;如此，功能已经实现了，但领导并不满意=_=，原因是项目中 AOP 用得太多了，都用滥了，建议我换一种方式。嗯，只好搞起。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;| Interceptor&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Spring&lt;/span&gt;的 拦截器(Interceptor) 实现这个功能也非常合适。顾名思义，拦截器用于在 Controller 内 Action 被执行前通过一些参数判断是否要执行此方法，要实现一个拦截器，可以实现 Spring 的 &lt;code&gt;HandlerInterceptor&lt;/code&gt; 接口。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;实现步骤如下：&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定义拦截器类 &lt;code&gt;AppkeyInterceptor&lt;/code&gt; 类并实现 HandlerInterceptor 接口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现其 &lt;code&gt;preHandle()&lt;/code&gt; 方法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 preHandle 方法内通过注解和参数判断是否需要拦截请求，拦截请求时接口返回 &lt;code&gt;false&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在自定义的 &lt;code&gt;WebMvcConfigurerAdapter&lt;/code&gt; 类内注册此拦截器；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;code&gt;AppkeyInterceptor&lt;/code&gt; 类如下：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;WhitelistInterceptor&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;HandlerInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(HttpServletRequest request, HttpServletResponse response, Object handler)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Whitelist whitelist = ((HandlerMethod) handler).getMethodAnnotation(Whitelist.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;postHandle&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;afterCompletion&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;要启用 拦截器还要显式配置它启用，这里我们使用 &lt;code&gt;WebMvcConfigurerAdapter&lt;/code&gt; 对它进行配置。需要注意，继承它的的 &lt;code&gt;MvcConfiguration&lt;/code&gt; 需要在 ComponentScan 路径下。&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MvcConfiguration&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;WebMvcConfigurerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;addInterceptors&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(InterceptorRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        registry.addInterceptor(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; WhitelistInterceptor()).addPathPatterns(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/*&quot;&lt;/span&gt;).order(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;还需要注意，拦截器执行成功后响应码为 &lt;code&gt;200&lt;/code&gt;，但响应数据为空。&lt;/section&gt;&lt;section&gt;当使用拦截器实现功能后，领导终于祭出大招了：我们已经有一个 Auth 参数了，appkey 可以从 Auth 参数里取到，可以把在不在白名单作为 Auth 的一种方式，为什么不在 Auth 时校验？emmm… 吐血中。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;| ArgumentResolver&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;参数解析器是 Spring 提供的用于解析自定义参数的工具，我们常用的 &lt;code&gt;@RequestParam&lt;/code&gt; 注解就有它的影子，使用它，我们可以将参数在进入Controller Action之前就组合成我们想要的样子。&lt;/section&gt;&lt;section&gt;Spring 会维护一个 &lt;code&gt;ResolverList&lt;/code&gt;， 在请求到达时，Spring 发现有自定义类型参数（非基本类型）， 会依次尝试这些 Resolver，直到有一个 Resolver 能解析需要的参数。要实现一个参数解析器，需要实现 &lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt; 接口。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;定义自定义参数类型 &lt;code&gt;AuthParam&lt;/code&gt;，类内有 appkey 相关字段；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;定义 &lt;code&gt;AuthParamResolver&lt;/code&gt; 并实现 HandlerMethodArgumentResolver 接口；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;实现 &lt;code&gt;supportsParameter()&lt;/code&gt; 接口方法将 AuthParam 与 AuthParamResolver 适配起来；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;实现 &lt;code&gt;resolveArgument()&lt;/code&gt; 接口方法解析 reqest 对象生成 AuthParam 对象，并在此校验 AuthParam ，确认 appkey 是否在白名单内；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在 Controller Action 方法上签名内添加 AuthParam 参数以启用此 Resolver;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;实现的 AuthParamResolver 类如下：&lt;strong/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AuthParamResolver&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;HandlerMethodArgumentResolver&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;supportsParameter&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(MethodParameter parameter)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; parameter.getParameterType().equals(AuthParam.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;code-snippet__title&quot;&gt;resolveArgument&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Whitelist whitelist = parameter.getMethodAnnotation(Whitelist.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; AuthParam();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;当然，使用参数解析器也需要单独配置，我们同样在 &lt;code&gt;WebMvcConfigurerAdapter&lt;/code&gt;内配置：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MvcConfiguration&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;WebMvcConfigurerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;addArgumentResolvers&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(List&amp;lt;HandlerMethodArgumentResolver&amp;gt; argumentResolvers)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        argumentResolvers.add(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; AuthParamResolver());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;这次实现完了，我还有些不放心，于是在网上查找是否还有其他方式可以实现此功能，发现常见的还有 &lt;code&gt;Filter&lt;/code&gt;。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;| Filter&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;Filter 并不是 Spring 提供的，它是在 Servlet 规范中定义的，是 Servlet 容器支持的。被 Filter 过滤的请求，不会派发到 Spring 容器中。它的实现也比较简单，实现 &lt;code&gt;javax.servlet.Filter&lt;/code&gt;接口即可。&lt;/section&gt;&lt;section&gt;由于不在 Spring 容器中，Filter 获取不到 Spring 容器的资源，只能使用原生 Java 的 ServletRequest 和 ServletResponse 来获取请求参数。&lt;/section&gt;&lt;section&gt;另外，在一个 Filter 中要显示调用 FilterChain 的 doFilter 方法，不然认为请求被拦截。实现类似：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;WhitelistFilter&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;javax&lt;/span&gt;.&lt;span class=&quot;code-snippet__title&quot;&gt;servlet&lt;/span&gt;.&lt;span class=&quot;code-snippet__title&quot;&gt;Filter&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(FilterConfig filterConfig)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; ServletException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;doFilter&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ServletRequest request, ServletResponse response, FilterChain chain)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       chain.doFilter(request, response); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;destroy&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Filter 也需要显示配置：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;FilterConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; FilterRegistrationBean &lt;span class=&quot;code-snippet__title&quot;&gt;someFilterRegistration&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        FilterRegistrationBean registration = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; FilterRegistrationBean();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        registration.setFilter(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; WhitelistFilter());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        registration.addUrlPatterns(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/*&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        registration.setName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;whitelistFilter&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        registration.setOrder(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; registration;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;| 小结&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;四种实现方式都有其适合的场&lt;span/&gt;景，那么它们之间的调用顺序如何呢？&lt;/section&gt;&lt;section&gt;Filter 是 Servlet 实现的，自然是最先被调用，后续被调用的是 Interceptor 被拦截了自然不需要后续再进行处理，然后是 参数解析器，最后才是切面的切点。&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如喜欢本文，请点击右上角，把文章分享到朋友圈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如有想了解学习的技术点，请留言给若飞安排分享&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;·END·&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者：枕边书&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：https://zhenbianshu.github.io/2018/06/spring_boot_generic_auth.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;版权申明：&lt;/span&gt;&lt;span&gt;内容来源网络，仅供分享学习，版权归原创者所有。&lt;/span&gt;&lt;span&gt;除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。&lt;/span&gt;&lt;span&gt;谢谢!&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;h2&gt;加个关注不迷路&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile data-index=&quot;1&quot; data-id=&quot;MzI4ODQ3NjE2OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/C93dCHmGrWzo3r2IwZzjK44WxQwhDAlhygicTbLH8Xv5wYClRpZJvoMxJIH9oPnRcGuKneSYicF3SOvJOaB34OibQ/0?wx_fmt=png&amp;amp;wx_head=1&quot; data-nickname=&quot;程序员大目&quot; data-alias=&quot;itmuch_com&quot; data-signature=&quot;BAT 技术专家分享开发、架构、运维相关干货！&quot; data-origin_num=&quot;159&quot; data-is_biz_ban=&quot;0&quot; data-isban=&quot;0&quot; class=&quot;js_wx_tap_highlight&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;small&gt;喜欢就点个&quot;在看&quot;呗^_^&lt;span/&gt;&lt;/small&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1698198130523e3c7a37d7172cf80875</guid>
<title>Maven依赖解析之倍增提速！eBay Velocity实践的开源新算法</title>
<link>https://toutiao.io/k/16gmrqr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;1&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缘  起&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/I1OPdTuWhEicbFdhmnKibIjooSsgjVWZfzFfPlQDBOPoicEfZLMsicyKqCljdQd5OzicTiaWib46gTib5pMfYrvW4neZAzVClBozx9hH/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Maven&lt;/strong&gt;&lt;/span&gt;作为程序员所熟悉的构建工具，在eBay内部同样被广泛使用。maven-resolver 是Maven的核心组件。它将项目声明的所有依赖 (dependency) 予以解析，算得依赖图 (dependency graph) 并调解冲突，最终整合成项目编译和部署所需的classpath，这个过程叫依赖解析 (dependency resolution)。在eBay开展的&lt;strong&gt;&lt;span&gt;Build Velocity&lt;/span&gt;&lt;/strong&gt;项目实践中，通过对Maven Build数据进行分解和可视化分析，我们惊讶地发现maven-resolver在解析复杂依赖时存在严重的性能瓶颈。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为突破瓶颈并加速Maven Build，我们对maven-resolver的依赖解析算法作了大幅改造，并实现了一个全新的算法：&lt;span&gt;BF (广度优先遍历) + Skipper&lt;/span&gt;。&lt;/strong&gt;其意义是Maven可以无视依赖图的复杂度，甚至有大量循环依赖的情况下，可通过最小运算量计算出项目所需的最终依赖项。经测试，该算法可以让依赖比较复杂的项目的纯build时间缩短&lt;span&gt;30-70%&lt;/span&gt;！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前该算法已被Apache Maven社区正式接受并纳入maven-resolver v1.8.0 (该组件将随Maven 3.9.0发布)。以下使用说明来自 Maven官方文档:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMGVLCChkJiaUXJPB0ic53nQbRbr9ym5POHYj5EibicF82erky3b6rxLaS0uSl9ciaDpzY2ADRok1oA9eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;新算法甫一亮相，来自阿里的开发人员便试用并给出了以下反馈：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0204082&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/I1OPdTuWhEicbFdhmnKibIjooSsgjVWZfz1v1LdusEBf0IcdibXT30Lvm43XJIeTAnUTxrG1w1C99lUib6YtpQZv7EicjhAL5WMOv/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;147&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;目前我们已经应用到5 - 6个需要花长时间build的工程，build时间可以缩短一半，后续我们会把这个算法应用到更多的工程并及时反馈。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个算法的诞生可谓历经艰辛。从发现问题、解决问题到贡献回社区，每一步都倾注了eBay Applciation Framework 团队的心血。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;本文将以算法的起源和演进为轴线，为大家重温个中细节。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：本文提及的测试数据均基于纯build，指本地Maven repository有full cache并跳过全部测试的情况下跑的Maven Build (mvn clean install -DskipTests)，故不涉及任何Maven artifacts下载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;2&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;发  现&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/I1OPdTuWhEicbFdhmnKibIjooSsgjVWZfzFfPlQDBOPoicEfZLMsicyKqCljdQd5OzicTiaWib46gTib5pMfYrvW4neZAzVClBozx9hH/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2021年3月，eBay启动Velocity项目，旨在加速开发迭代。&lt;/span&gt;其子项目Build Velocity的设立旨在加速开发周期的重要一环：Maven Build。其前期共60+ pilot 项目参与。eBay Application Framework Team负责技术攻关。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;摆在我们面前的问题有两点：一是缺乏数据，二是不清楚Maven Build具体慢在哪里。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;工欲善其事，必先利其器。我们首先打造了&lt;span&gt;&lt;strong&gt;Zeus产品&lt;/strong&gt;&lt;/span&gt;。该产品以一个Maven Extension为核心，实时参与用户build，收集数据并汇总成报表。通过分析报表、诊断热点（hotspot）、开发特性（feature）以解决热点、Extension自我升级并启用特性、再用新收集的数据体现优化效果，至此形成一个可持续运行的调优闭环。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每条数据量化了Maven Build的各个步骤，并统计以下指标：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3638889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMGVLCChkJiaUXJPB0ic53nQb6fo2RTpUIPVoorIxFKhg9ZQRyJCZxSAhqicQQTLLvia8J3maoJGNy34w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Zeus应用到上述pilot项目后，我们发现有一个项目跑一次纯build竟然需要&lt;span&gt;30+&lt;/span&gt;分钟才能完成。内存配置甚至需要&lt;span&gt;20G&lt;/span&gt;，否则Maven Build会因内存溢出而终止。我们通过分析收集到的build数据，发现上述依赖解析部分时间（相当于跑一次mvn dependency:tree）几乎&lt;span&gt;等同于纯build时间&lt;/span&gt;。&lt;strong&gt;通过Zeus报表发现，有不少项目在依赖解析上花了不少时间 (&lt;span&gt;5～10分钟&lt;/span&gt;)，虽然没有上述项目严重，但至少说明Maven依赖解析慢是个共同的问题！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;3&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;探  究&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/I1OPdTuWhEicbFdhmnKibIjooSsgjVWZfzFfPlQDBOPoicEfZLMsicyKqCljdQd5OzicTiaWib46gTib5pMfYrvW4neZAzVClBozx9hH/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Maven 依赖解析过程简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Maven 依赖的声明使用大家都很熟悉了，这里只作简单介绍，以便理解后续介绍的性能问题。详情可参见Maven官方文档。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Maven 依赖缺省为compile scope，默认传递所有子依赖，而其子依赖又会传递自己的子依赖，Maven称之为传递性依赖。&lt;strong&gt;随着业务逻辑的增长，依赖会声明越来越多，间接依赖也呈几何级增长，&lt;span&gt;最终项目的依赖图变得非常复杂，并带来大量的冲突&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMGVLCChkJiaUXJPB0ic53nQboJcRjcgj9Lp4vgMDbxrh4PlsMWoCX7YaSUothLXJ1gHDCmg9EUmEOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上图显示了X依赖及其间接依赖。Maven解析步骤如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;X -&amp;gt; Y -&amp;gt; Z 2.0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;X -&amp;gt; G -&amp;gt; J -&amp;gt; Z 1.0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;X -&amp;gt; H -&amp;gt; Z2.0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;X -&amp;gt; Z 2.0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;X -&amp;gt; D -&amp;gt; Z 2.0&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过跑mvn dependency:tree -Dverbose, 你可以看到Maven标记的两种冲突：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2985294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMGVLCChkJiaUXJPB0ic53nQbUva6Ttl6E3dTCdcFkTcHA2WQCaTQFokPvXVkLQeicic5Qviaq97xwEIPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个冲突选择的算法是固定的，但最终选择的依赖有可能不是你想要的。比如你实际需要Z1.0， 但Maven选择了Z2.0，结果导致了各类运行时异常。为了解决此类问题，Maven一般允许以以下方式来改变其抉择:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Maven推荐前者，但实际后者更容易被用户理解，故使用更广泛。这就可能导致下面要说的性能问题。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;约7500万内存节点 VS 1500+ 最终依赖项&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用JProfiler，我们发现Maven在构建该项目的dependency tree时，内存里创建了约&lt;span&gt;7500万&lt;/span&gt; Node节点，可见依赖图非常之复杂；然而dependency tree里最后只剩&lt;span&gt;1500+&lt;/span&gt;依赖项 (参与编译和部署)，可见这&lt;span&gt;7500万&lt;/span&gt;节点大多数是上述的重复冲突或版本冲突节点。所以说dependency tree显示的只是调解冲突后的结果，往往只是冰山一角 (大量的冲突节点已被剪除), 但诸多节点的计算缺一不可，故导致严重性能问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2009259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMGVLCChkJiaUXJPB0ic53nQblVqJabrf7g26BLWLHDFKN3GmGKmNYkS8nKVvaicFYbzsBm9nGrMtskg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了分析具体原因，我们用mvnDebug命令起了上述项目的Maven Build，在IDE里导入Maven源代码进行远程调试。在调试过程中，我们了解到7500万节点多是因为：&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;一些基础的类库依赖数个heavy dependencies (特指会带来几百上千间接依赖的Maven dependency)，而这些基础的类库又被上层业务类库广泛依赖。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一些类库基于过时的技术栈构建，其间接依赖无法被新技术栈的parent pom管理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;存在一些循环依赖（同一pattern累计达&lt;span&gt;10次&lt;/span&gt;后续才会跳过）。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么问题来了，虽然Maven是全路径遍历，难道Maven没有cache机制吗？如某依赖被解析过一次，就可以cache解析结果（即全部子依赖），下次再遇到GAV (GroupId + ArtifactId + Version) 相同的依赖就不必再计算了。Maven设计精湛，这个cache肯定是考虑到了，推测这里&lt;span&gt;存在&lt;/span&gt;&lt;strong&gt;&lt;span&gt;cache失效&lt;/span&gt;&lt;/strong&gt;的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;经过深入调试，仔细分析后定位到了问题所在：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;原来Maven在cache依赖的解析结果时采用的key非常复杂，由Artifact及继承自所有双亲节点的（Repositories定义、DependencySelector、DependencyManager、DependencyTraverser、VersionFilter）共六部分组成。其中&lt;span&gt;ExclusionsDependencySelector&lt;/span&gt;就是根据exclusions来过滤相关依赖的。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0838608&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMGVLCChkJiaUXJPB0ic53nQby8dBpALoXwdCjIRh0sT088lMkDhGDtME06SAHf5GIBtthZG9of5xzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;632&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这个key的设计会让Maven在exclusions不同的情况下，无法命中cache反复解析同一依赖，此谓&lt;span&gt;Maven依赖解析的&lt;/span&gt;&lt;span&gt;阿喀琉斯之踵&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Maven依赖解析的阿喀琉斯之踵&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;——决定性的Exclusions&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMGVLCChkJiaUXJPB0ic53nQb4LiaWQQgUblnIkmaKoricBJT19IMdPjWpCxtth3TwEarjqibayrXB27BA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从上图可知:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可见&lt;strong&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;/strong&gt;在cache的命中与否上起到了决定性作用，因为key的其他部分往往是一致的，但从根节点一路继承下来的exclusions 很难相同，故而大量的子节点也被重算。随之而来的便是：&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;回到上述项目，由于依赖图过于复杂，开发人员为解决各类运行时异常广泛使用了exclusions排除冲突, 从而导致cache频频未被命中，Maven不得不反复计算，疲于奔命。&lt;span&gt;&lt;strong&gt;这个问题既不可归咎于开发人员，谁能想到依赖传递和exclusions会带来这么大的性能问题？也不可归咎于Maven，谁又能想到企业级应用里的依赖图会如此复杂？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;4&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;诞  生&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/I1OPdTuWhEicbFdhmnKibIjooSsgjVWZfzFfPlQDBOPoicEfZLMsicyKqCljdQd5OzicTiaWib46gTib5pMfYrvW4neZAzVClBozx9hH/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;发现以上性能问题后,  我们调优了上述项目以及同样比较慢的6，7个pilot应用,  并给用户发PR。为达最大投入产出比，我们采取的多是&lt;span&gt;&lt;strong&gt;调整heavy dependencies&lt;/strong&gt;&lt;/span&gt;，&lt;strong&gt;&lt;span&gt;核心是避免不必要计算&lt;/span&gt;&lt;/strong&gt;:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这些PR对build性能提升显著，但PR对依赖改动太多，需大量测试，耗时耗力；且调优仅针对heavy dependencies，无法达到最大收益。如果后面几千个应用都参与Velocity项目，一一调优显然难以为继。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;算法前瞻：机会&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;回到上述项目，我们做了一个实验，即&lt;strong&gt;直接去修改maven-resolver，只要是同一节点（GAV相同）就直接重用cache&lt;/strong&gt;，最终的build花费时间从&lt;span&gt;30+&lt;/span&gt;来到了&lt;span&gt;2-3&lt;span&gt;分钟&lt;/span&gt;&lt;/span&gt;左右，内存占用降至正常水平。当然这种简单粗暴的改法最终导致项目build失败，但足以证明实现一个新算法意义之大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;算法前瞻：风险&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前述maven-resolver 作为Maven的核心组件，负责计算项目编译和部署所需的最终依赖项。对其修改可谓充满风险，稍有不慎，就会导致项目编译不通过或部署失败，&lt;span&gt;甚至引起极端情况下才会出现的运行时异常从而引发site issue&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;细读maven-resolver的代码，其算法在Maven 3.0.x 系列就成型了，后面十几年几乎没有改动核心逻辑。并且:&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽然困难重重，但&lt;strong&gt;&lt;span&gt;要想一劳永逸地解决Maven在依赖解析方面的性能问题，唯有华山一条路—— 修改maven-resolver的核心算法&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;算法实现：BF + Skipper&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;新算法的需求，首先是100%兼容，其次才是快&lt;/span&gt;&lt;/strong&gt;。一切为了加速导致用户编译和部署出现问题的所谓改进都是站不住脚的。实现这样的兼容算法并非一蹴而就，而是反复摸索出来的。限于篇幅，本文只介绍最终实现：&lt;strong&gt;&lt;span&gt; BF + Skipper&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8203704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMGVLCChkJiaUXJPB0ic53nQbILvMxNBdEds40qlcAZkLATX77njH3yMrI5KrOwnY0uwa3QACTv30icw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如图所示，为了100%兼容，新算法并未改变Maven冲突调解部分的逻辑。为了加速，把原算法中的全路径遍历改造成了&lt;strong&gt;&lt;span&gt;预判式的选择性遍历&lt;/span&gt;&lt;/strong&gt;。通过合理规避冲突节点，最大限度节省不必要计算，而原先复杂的依赖图可大幅精简并且不会影响最终的Maven输出结果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;算法的主要流程如下:&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;① &lt;/span&gt;如果节点属于版本冲突，直接跳过解析。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;② &lt;/span&gt;如果该节点属于重复类冲突，则判断冲突路径是否需要保留以便兼容冲突调解算法&lt;/span&gt;&lt;span&gt;，如是则强制重算，反之跳过解析。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为便于理解，将我们的算法和Maven原有的深度优先（DF）算法做以下对比:&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2152318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMGVLCChkJiaUXJPB0ic53nQbkh7zMKlVicwlv3eK6DvGxWibnPBV1rCAnjaVcm4s6HblsQRb8UiblMzJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;604&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;BF - 预判冲突&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前述Maven解决冲突的方式就是基于深度优先算法遍历全部节点后，再来根据离根节点的远近原则来排除冲突，而广度优先算法正是按照离根节点远近的顺序从上往下从左到右遍历节点的。也就是说，&lt;strong&gt;在广度优先算法里，对于相同GA (GroupId + ArtifactId) 的依赖，第一个解析的肯定是winner，后面遇到的一定是冲突的loser&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们只需把&lt;strong&gt;节点遍历从深度优先改成广度优先&lt;/strong&gt;，那么在计算一个节点时，只要相同GA的节点已被计算过，就可以断定当前节点或者是重复冲突，或者是版本冲突，从而可以选择性跳过。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Skipper - 规避冲突节点的重复解析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了规避冲突节点的无谓计算，我们创建了一个&lt;span&gt;&lt;strong&gt;Skipper&lt;/strong&gt;&lt;/span&gt;。Skipper可以根据以下原则在当前已经解析完成的节点集合中匹配，来判断当前节点是否可以规避：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;版本冲突节点的规避&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMGVLCChkJiaUXJPB0ic53nQbxB3xHKoPG9hhfic2z84Wxdppe1icBsbcjYGq2xicQf4943xhekmxJszyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;从上图可以得知:&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;D:1 (D的版本为1, #4) 在树的第二层解析, 在广度优先的算法下D:1已经是winner.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当解析到D:2 (D的版本为2, #5)时, 我们知道D:2的版本与D:1不同，属于版本冲突的loser，所以D:2及其所有子节点都是不必计算的。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;重复性冲突节点的规避与强制重算&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMGVLCChkJiaUXJPB0ic53nQbyDskgVVacOpD8x8fkkMfSXuibHfzAT2CwiaXemicJnGWh7BkJvyd5RGicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于涉及到节点的位置比较，节点的坐标信息不可或缺，所以我们需要在解析当前节点时实时计算其坐标。图中坐标(2,2)代表 (第二层, 第二层第2顺位)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图可以得知：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;紫色&lt;span&gt;R#3节点&lt;/span&gt;&lt;/span&gt;是在树的第2层解析的,在广度优先算法里即最终winner。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;蓝色&lt;/span&gt;&lt;span&gt;R#5不&lt;/span&gt;是winner,  但R#5位于 (3,1)， R#3位于(2,2) 。R#5 在R#3的左侧，即R#5 的双亲节点（追溯至根节点的直接子节点，即第二层的B节点）在pom里先于R#3声明。这种情况下需要强制重算R#5，原因后表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;由于R#3早就确定是winner，&lt;span&gt;褐色&lt;span&gt;R#8&lt;/span&gt;&lt;/span&gt;和R#11均属于冲突loser，且均在上次重算的蓝色R#5右侧故不必再解析了，其子节点（虚线S节点）也同样跳过。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;强制重算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该方案最开始的实现并没有上述强制重算的逻辑，测试&lt;span&gt;500+&lt;/span&gt;eBay应用正确率已达&lt;span&gt;99%&lt;/span&gt;，最后1%的failure cases情况多样，如依赖作用域 (scope) 选择错误等，细节不再赘述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;兼容最后的1%恰恰是最艰难的最后一公里&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。解决这类不兼容问题需要对Maven的冲突调解算法深入理解，而前面提到这块逻辑复杂，无文档且无注释。摆在我们面前的选择有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案一每个failure case分别作特殊处理。这种方案无疑会让最终的算法逻辑过于生&lt;/span&gt;&lt;span&gt;硬。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案二比较两种算法下调解冲突的不同，作一定的适配。这种方案更为直接、安全。即便出现一些Maven的单元测试、集成测试或者eBay的几千个应用无法覆盖到的case也能兼容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我们选择的是后者&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;。经过深入调试Maven源码，反复研读冲突调解部分的算法，比较两种模式下逻辑的不同，最后定位到：原算法用于调解冲突的重复性冲突节点的路径更多。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这点正是因为我们规避了大量的节点计算，从而缺失了一些关键的冲突路径，而这些路径也是Maven需要用来辅助冲突裁决的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;让我们看看如何通过保留冲突路径的方式来兼容原算法的计算结果。以下为图解：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5296296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMGVLCChkJiaUXJPB0ic53nQbJLS0Na1BqbCpOBdLuMiawowLoPblhulzunuLAvjXuSrqZwtZcok9HQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;左图为Maven深度优先的算法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Maven按图中标记的数字依次解析节点。对于R节点，其解析顺序为：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这个解析过程中，胜负关系总共更替了三次。凡是改变了胜负方的节点路径都是Maven最终需要参考的冲突路径，所以最终参与调解的冲突路径是：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;A -&amp;gt; B -&amp;gt; D -&amp;gt; R&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A -&amp;gt; B -&amp;gt; R&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A -&amp;gt; R&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;右图为我们的算法，BF + Skipper&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最先解析的是R#3，即最终的winner，后面所有R节点通通被规避掉，这意味着最后用于调解冲突的只有一条 A -&amp;gt; R。&lt;/span&gt;&lt;span&gt;冲突路径的减少影响了Maven的冲突调解结果。&lt;/span&gt;&lt;span&gt;我们来看看引入以下重算逻辑后Maven会怎么解析这些节点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种方式下的冲突路径按顺序依次为：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;A -&amp;gt; R&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A -&amp;gt; B -&amp;gt; R&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A -&amp;gt; B -&amp;gt; D -&amp;gt; R&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可见这些路径和原算法下的冲突路径完全相同。我们通过上述保留冲突路径的方法彻底解决了最后1%的不兼容case。不必担心的是，这种重算并不会太多。即使重算，其大部分子节点仍然可以基于上述原则大量规避。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;算法测试与发布&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;eBay几千个应用提供了各种复杂的依赖使用场景，使用团队现有的快捷测试工具，我们可以基于大量真实项目跑兼容性测试：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;做一个精简版的Maven Extension，替换maven-resolver的实现类。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;批量Fork用户项目，自动添加maven-exec-plugin配置, 在启用或不启用extension (-Dmaven.ext=xxx.jar) 的模式下分别跑以下命令：&lt;/p&gt;&lt;p&gt;mvn dependency:tree（决定编译结果）&lt;/p&gt;&lt;p&gt;mvn dependency:list（决定部署结果）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;比较两种模式dependency tree 和dependency list输出结果的不同。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;经过数轮测试，这个算法已趋稳定。在正式交付前我们测试了eBay几千应用。这个算法同样通过了Maven所有的单元测试，集成测试，达到了我们最初的需求设定：即&lt;strong&gt;&lt;span&gt;新算法不仅大大加快了Maven依赖解析的速度而且100%兼容原算法&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数月之前，我们已经将上述算法包装成Zeus的一个feature，通过Zeus的自我升级发布到大量eBay项目中。我们惊喜地看到，这个算法对于一些复杂项目的纯build有&lt;span&gt;30% ~ 70%&lt;/span&gt;性能提升，而且对于上述人工调优后的项目，build性能仍然有不小的提升。这佐证了前面的人工调优方式不光费时费力，而且达不到最大收益，当然这是后话了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;5&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;结  语&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/I1OPdTuWhEicbFdhmnKibIjooSsgjVWZfzFfPlQDBOPoicEfZLMsicyKqCljdQd5OzicTiaWib46gTib5pMfYrvW4neZAzVClBozx9hH/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;BF (广度优先遍历) + Skipper&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;算法在eBay已经得到广泛应用，我们第一时间决定将上述算法贡献回Apache Maven社区。&lt;/strong&gt;这个过程也非易事，我们和社区紧密协作，反复重构，不断完善各种测试用例，最终社区欣然接受。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;该算法起源于eBay Build Velocity的大量调优实践，我们通过打造Zeus系统收集数据，识别Maven Build的性能痛点，不断探索去解决用户问题，再到改造算法，不断测试，最后应用到eBay几千个项目并贡献回社区。&lt;/strong&gt;&lt;/span&gt;其中艰辛，唯有自知，所幸天道酬勤，终有收获，也不枉我们这一路的跋山涉水。回首整个历程，我们可以自豪的说，这种实践完美诠释了eBay人取之于社区，再回馈于社区的开源精神。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;与此同时，我们正在开源回去的还有同样源于eBay Build Velocity实践的feature: Maven 元描述文件（Descriptors，包括pom, metadata.xml等）预判式并发下载，目前社区正在review我们的PR。eBay在大量开发实践中诞生了很多优秀产品，这些产品需要解决的问题不仅仅是eBay需要面对的问题，期待有更多的产品加以提炼，拥抱开源，共勉之！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;谨以此文由衷感谢团队成员 (Simon Wang, Eric Cai,Caddie Song, Rocky Shang, Gary Zhang, Rick Leng) 在Build Velocity项目中的辛勤付出。也特别感谢eBay平台，大量积极开发中的eBay项目为我们提供了丰富多样的Maven依赖使用场景，可以让我们放心去探索、实践、改变与贡献！&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>