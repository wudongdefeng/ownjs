<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>26c22eea2f3f46d46211b459e63263fb</guid>
<title>微服务治理热门技术揭秘：动态读写分离</title>
<link>https://toutiao.io/k/bu7lntc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;82&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.14106583072100312&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/qdzZBE73hWvNG9VjIS9sOow1MoYQgibicAhyLCiagyqhMVMBR5LiaLDIwVjiayNbjG4682icRrJOrll5bkJu9kebAQHA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们从应用的视角出发整理抽象了我们在访问、使用数据库时场景的一些稳定性治理、性能优化、提效等方面的实战经验，对于每一个后端应用来说，数据库无疑是重中之重，我们希望通过我们的数据库治理能力，可以帮助到大家更好地使用数据库服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;250&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4322033898305085&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjcfZiamC5UIRqkAq2ib4fOrscKoB8tgJibvPjIQogyeicnwG3aBc74eibNVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1888&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MSE 数据库治理完整解决方案&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;本文将详细介绍 MSE 数据库治理的热点功能，动态读写分离的设计与实现。&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;读写分离的概述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;数据库动态读写分离的常见场景：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一个大客户的请求过来，查询数据库返回上万条几百 M 的数据，数据库的 CPU 直接打满。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;微服务应用的某些业务并不是那么重要，却存在大量查询数据库的逻辑，影响数据库实例稳定性，从而导致整体服务质量的下降。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在业务处理过程中，如果对数据库的读操作远多于写操作，那么在做系统性能优化时就可以考虑引入读写分离的方案，一方面只读库可以承担主库的压力，另一方面能够有效的避免由数据更新导致的锁等待，提升微服务应用的性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;随着业务的增长，我们在一定时机下需要对数据库实例进行扩容。根据经验大多数应用的读写比都在 5:1 以上，有些场景甚至大量的高于 10:1，在对数据库有少量写请求，但有大量读请求的应用场景下，单个实例可能无法承受读取压力，甚至对业务产生影响。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;可以了解到的是数据库读写分离方案可以满足阿里云上大多数公司的稳定性治理、性能提升以及数据库扩容的需求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;299&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5168018539976825&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjp5sqmozDD2oialpHmQfL7YlSdP9cp2LPXzJPNpB3ic40IYDkTqZrbfRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1726&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果了解读写分离实现的同学一定会关注以下这些问题：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MSE 是如何解决读写分离对业务的侵入性？如何做到业务无需改动一行代码，即可具备读写分离能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MSE 如何做到精细化动态的读写分离控制？即使我们不知道这个业务接口真实的 SQL 是什么，但我们已经可以控制这个接口的读 SQL 访问只读实例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MSE 是如何解决读写分离带来的一致性问题？对于一致性敏感的业务，如何实现一致性的保障，满足业务在不同场景下对一致性级别的要求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;MSE 读写分离技术揭秘&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读写分离也就是将数据库拆分为主库和从库，即主库负责处理事务性的增删改操作，从库负责处理查询操作的数据库架构。单单看读写分离的概念，第一感觉就是对业务的侵入性一定不小，那么 MSE 是如何做到无侵入的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;无侵入性：无需修改一行代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;MSE 数据库治理能力通过 JavaAgent 技术，动态增加用户的数据源，注入动态读写分离能力，支持运行时动态将弱读请求路由至只读实例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;251&quot; data-backw=&quot;530&quot; data-ratio=&quot;0.47358490566037736&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHj4TYfLRfoxPdVv7bG3UA39FjmLw8mTCUyyoXoiaY0KmruEfY7x9nM1sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MSE 在数据源层面实现了抽象，其中 DynamicConnection、DynamicStatement 会根据具体规则从而实现 Master/Slaver 的切换，做到根据 SQL 的读写类型、事务的状态以及用户的业务规则来做 SQL 的路由，将符合条件的读 SQL 请求转发至 RDS 只读实例中。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5631901840490797&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjdicBvNsLch4lrd6vb4lkQS1Etaibxxejob6AqxFQibdDiaUZjpkicUsY1icw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1630&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;精细化路由：按照请求条件、接口、SQL 多层次多条件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多时候我们通过编写 DAO 访问数据库，那么在一些复杂应用的场景下，我们很可能只知道 DAO 接口，在一些复杂场景下我们只知道微服务的接口，内部甚至搞不清楚到底调用的哪个 DAO 接口、SQL 语句，甚至如果是运维角色参与设计，我们很可能不知道哪个微服务接口导致的读请求导致数据库抖动，我们只知道入口应用的某个 uid。那么我们如何做到对业务接口内的读请求路由至只读实例呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;MSE 数据库治理提供了应用层面完整的 callStack 信息，可以让我们站在应用的视角上清晰地看到哪些接口内部执行了哪些 SQL。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;398&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6890862944162437&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjNxwskwVcTrWUSrcV19iaTiaylPaCrx2iawPoeF6qTFxZA0Q4OnuicPrGGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;MSE 通过链路传递技术，支持在入口微服务、微服务接口、DAO 层面标记弱读请求的标记，支持标记的当前线程内的 SQL 调用、当前微服务内的 SQL 调用、符合流量条件的请求链路级别的所有 SQL 调用等多个层面的弱读标记传递，最终传递给读写分离组件的路由引擎进行  SQL 的路由依据的判断。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;204&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.362555720653789&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjdypKTgjcJlQenVC4tmFrxOhfsfbFKEjPmrHIMSFS7pekIka2CdgcoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;强一致性模式：指定接口、事务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当数据库负载很高时，例如对大表执行 DDL（如加字段）操作或大批量插入数据的时候，延迟会非常严重，从而导致无法从只读实例中读取最新数据。MSE 提供了一些策略解决如上问题，某些接口或者某些业务对一致性比较非常高，我们可以通过规则配置告诉 MSE 在特定场景下，某些读接口标记为强读请求。&lt;/span&gt;&lt;span&gt;MSE 内部会通过一些机制保证读写分离的强一致性效果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;白屏化能力：通过 AccessLog 实时感知读写分离情况&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;有读写分离能力，那么我们如何知道读写分离的执行情况，到底哪些应用，哪些请求被分离至了只读实例？MSE 白屏化能力提供了一套完整的 AccessLog。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;263&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4551422319474836&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjFTib4qHiaEcf0eJaUtmh6ryiagn6449dYOPoz8XlCbRUReWub4AuombyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1828&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;229&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3950749464668094&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjnTQWcf3QZa2zxAbXpn6V5JGQlgfU3ZibbY7GtgrtwPQlJYic2oVrg7Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1868&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;MSE 从应用的视角出发，结合微服务治理通用的技术，MSE 推出的是完整的数据库治理解决方案，从 SQL 洞察、SQL 流控降级与容错、连接池治理到数据库灰度、动态读写分离。我们希望通过数据库治理能力可以帮助用户的微服务可以更好地使用数据库，降低数据库使用的成本，提升数据库访问的稳定性。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;MSE 的数据库治理能力也需要更多更加深入的客户场景与落地实践，如果您对 MSE 的数据库治理能力感兴趣，欢迎联系我们，只有经过客户打磨的产品才会愈发历久弥新。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在建设数据库治理能力的同时，我们也通过 OpenSergo 在与社区共同建设数据库治理的标准。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;294&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.509090909090909&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjzLGAQicC2ibX0fYEh6FM0Vtic1HvuekwTaELjF1Rwa0V4c2azwMW1TJRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1210&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;OpenSergo 在联合各个社区进行进一步的合作，希望通过社区来一起讨论与定义统一的服务治理标准。当前社区也在联合 bilibili、字节跳动等企业一起共建标准，也欢迎感兴趣的开发者、社区与企业一起加入到 OpenSergo 服务治理标准共建中。欢迎大家加入 OpenSergo 社区交流群（钉钉群）进行讨论：34826335&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>205183ead10ba0291329d190f339001b</guid>
<title>彻底理解 WireGuard 的路由策略</title>
<link>https://toutiao.io/k/rcso5pk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5248929336188437&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qFG6mghhA4aZ05icGic1SQCCULJqExAOCIZX24Y1HrutkVOZtVeBMdjmQlukTKrB9yRnIYUibPLxyJ5DEAJDdzrNQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3736&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;原文链接🔗：&lt;strong&gt;https://icloudnative.io/posts/linux-routing-of-wireguard/&lt;/strong&gt;&lt;br/&gt;或者点击左下角的 &lt;strong&gt;阅读原&lt;/strong&gt;&lt;strong&gt;文 &lt;/strong&gt;直接查看原文👇&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很久以前，我们只需要在 Linux 终端中输入 &lt;code&gt;route -n&lt;/code&gt;（后来演变出了 &lt;code&gt;ip route&lt;/code&gt;，也就是 iproute2 提供的命令），就可以知晓系统中所有数据包的走向，但是，&lt;strong&gt;大人，时代变了！&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qFG6mghhA4aZ05icGic1SQCCULJqExAOCIdGOtNajfYYDAxsLsiad40qNyhfJeHtmlZ9n1Jkn25sXaODoyyuIAfibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;225&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是 WireGuard 玩家，并且所有的流量都通过 WireGuard 路由出去，但你却无法通过 &lt;code&gt;ip route&lt;/code&gt; 命令的输出中看出任何的蛛丝马迹：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;default via 192.168.100.254 dev eth0 proto dhcp src 192.168.100.63 metric 100 &lt;br/&gt;192.168.100.0/24 dev eth0 proto kernel scope link src 192.168.100.63 &lt;br/&gt;192.168.100.254 dev eth0 proto dhcp scope link src 192.168.100.63 metric 100&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路由表告诉我们，所有的流量都是通过物理网卡出去的，并没有通过 WireGuard 虚拟网络接口。这是为什么呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;路由表&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上 Linux 从 2.2 版本左右的内核开始，便包含了多个路由表，而不是一个！同时，还有一套规则，&lt;strong&gt;这套规则会告诉内核如何为每个数据包选择正确的路由表。&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1MzY4NzQ1OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/qFG6mghhA4Z1KpQSa8IH6icHMlcG2hq5AhMX1DJzRibTSdRsIFapMfnAGhdr6GF4e0PnAkPiaEk7HrDrndoWjxiciaA/0?wx_fmt=png&quot; data-nickname=&quot;云原生实验室&quot; data-alias=&quot;cloud_native_yang&quot; data-signature=&quot;战略上藐视云原生，战术上重视云原生&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你执行 &lt;code&gt;ip route&lt;/code&gt; 时，你看到的是一个特定的路由表 &lt;code&gt;main&lt;/code&gt;，除了 main 之外还有其他的路由表存在。路由表一般用整数来标识，也可以通过文本对其命名，这些命名都保存在文件 &lt;code&gt;/etc/iproute2/rt_tables&lt;/code&gt; 中。默认内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ cat /etc/iproute2/rt_tables&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# reserved values&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;255     &lt;span&gt;local&lt;/span&gt;&lt;br/&gt;254     main&lt;br/&gt;253     default&lt;br/&gt;0       unspec&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# local&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#1      inr.ruhep&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 系统中，可以自定义从 &lt;code&gt;1－252&lt;/code&gt; 个路由表。Linux 系统默认维护了 4 个路由表：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;：系统保留表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;253&lt;/strong&gt;：defulte table。没特别指定的默认路由都放在该表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;254&lt;/strong&gt;：main table。没指明路由表的所有路由放在该表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;255&lt;/strong&gt;：locale table。保存本地接口地址，广播地址、NAT 地址，由系统维护，用户不得更改。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有一个很奇怪的单词：&lt;code&gt;inr.ruhep&lt;/code&gt;，这可能是 Alexey Kuznetsov 添加的，他负责服务质量（QoS）在Linux内核中的实现，iproute2 也是他在负责，这个单词表示“核研究/俄罗斯高能物理研究所”，是 Alexey 当时工作的地方，可能指的是他们的内部网络。当然，还有另外一种可能，有一个老式的俄罗斯计算机网络/ISP 叫做 &lt;span&gt;RUHEP/Radio-MSU&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路由表的查看可有以下二种方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ip route show table table_number&lt;br/&gt; &lt;br/&gt;$ ip route show table table_name&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;不要把路由表和 iptables 混淆，路由表决定&lt;strong&gt;如何传输数据包&lt;/strong&gt;，而 iptables 决定&lt;strong&gt;是否传输数据包&lt;/strong&gt;，他俩的职责不一样。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;路由策略&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核是如何知道哪个数据包应该使用哪个路由表的呢？答案已经在前文给出来了，系统中有一套规则会告诉内核如何为每个数据包选择正确的路由表，这套规则就是&lt;strong&gt;路由策略数据库&lt;/strong&gt;。这个数据库由 &lt;code&gt;ip rule&lt;/code&gt; 命令来管理，如果不加任何参数，将会打印所有的路由规则：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;0:      from all lookup &lt;span&gt;local&lt;/span&gt;&lt;br/&gt;32766:  from all lookup main&lt;br/&gt;32767:  from all lookup default&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;左边的数字（0, 32764, ......）表示规则的优先级：&lt;strong&gt;数值越小的规则，优先级越高&lt;/strong&gt;。也就是说，数值较小的规则会被优先处理。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;路由规则的数值范围：1 ~ &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;2^{23}-1&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -833.9 2979.6 915.9&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(500, 363) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;path data-c=&quot;33&quot; d=&quot;M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1479.3, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2479.6, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了优先级之外，每个规则还有一个&lt;strong&gt;选择器&lt;/strong&gt;（selector）和对应的&lt;strong&gt;执行策略&lt;/strong&gt;（action）。选择器会判断该规则是否适用于当前的数据包，如果适用，就执行对应的策略。最常见的执行策略就是查询一个特定的路由表（参考上一节内容）。如果该路由表包含了当前数据包的路由，那么就执行该路由；否则就会跳过当前路由表，继续匹配下一个路由规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 系统启动时，内核会为路由策略数据库配置三条缺省的规则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;：匹配任何条件，查询路由表 &lt;strong&gt;local&lt;/strong&gt; (ID 255)，该表 local 是一个特殊的路由表，包含对于本地和广播地址的优先级控制路由。rule 0 非常特殊，不能被删除或者覆盖。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;32766&lt;/strong&gt;：匹配任何条件，查询路由表 &lt;strong&gt;main&lt;/strong&gt; (ID 254)，该表是一个常规的表，包含所有的无策略路由。系统管理员可以删除或者使用另外的规则覆盖这条规则。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;32767&lt;/strong&gt;：匹配任何条件，查询路由表 &lt;strong&gt;default&lt;/strong&gt; (ID 253)，该表是一个空表，它是后续处理保留。对于前面的策略没有匹配到的数据包，系统使用这个策略进行处理，这个规则也可以删除。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认情况下进行路由时，首先会根据规则 &lt;strong&gt;0&lt;/strong&gt; 在本地路由表里寻找路由，如果目的地址是本网络，或是广播地址的话，在这里就可以找到合适的路由；如果路由失败，就会匹配下一个不空的规则，在这里只有 &lt;strong&gt;32766&lt;/strong&gt; 规则，在这里将会在主路由表里寻找路由；如果失败，就会匹配 &lt;strong&gt;32767&lt;/strong&gt; 规则，即寻找默认路由表。如果失败，路由将失败。从这里可以看出，&lt;strong&gt;策略性路由是往前兼容的&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;WireGuard 全局路由策略&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在回到 WireGuard，很多 WireGuard 用户会选择将本机的所有流量通过 WireGuard 对端路由，原因嘛大家都懂得😁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1226415094339623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qFG6mghhA4aZ05icGic1SQCCULJqExAOCIicDAQtGNa8hnaibApDCVwomhfK6qUXbmlFQ6xezE2vY9Kn3ZFSicUBbwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;212&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置嘛也很简单，只需将 &lt;code&gt;0.0.0.0/0&lt;/code&gt; 添加到 &lt;code&gt;AllowedIPs&lt;/code&gt; 里即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# /etc/wireguard/wg0.conf&lt;br/&gt;&lt;br/&gt;[Interface]&lt;br/&gt;PrivateKey = xxxxxxxxxxxxxxxxxxxxxxxxxxxxx &lt;br/&gt;Address = 10.0.0.2/32&lt;br/&gt;# PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&lt;br/&gt;# PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE&lt;br/&gt;# ListenPort = 51820&lt;br/&gt;&lt;br/&gt;[Peer]&lt;br/&gt;PublicKey = xxxxxxxxxxxxxxxxxxxxxxxxxxxxx&lt;br/&gt;Endpoint = 192.168.100.251:51820&lt;br/&gt;AllowedIPs = 0.0.0.0/0&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理论上这样就可以让所有的流量都通过对端路由了，但是如果你用的 wg-quick 版本比较旧，一顿操作猛如虎（&lt;code&gt;wg-quick up wg0&lt;/code&gt;）之后，你会发现事情并不是你想象的那样，甚至可能连 WireGuard 对端都连不上了。主要还是因为 WireGuard 自身的流量也通过虚拟网络接口进行路由了，这肯定是不行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新版本的 &lt;code&gt;wg-quick&lt;/code&gt; 通过路由策略巧妙地解决了这个问题，我们来看看它妙在何处！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9198813056379822&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qFG6mghhA4aZ05icGic1SQCCULJqExAOCIibZS5ibYibbfFbM1z8RoZCNccOtJkCqzWTUvIjxj6UKqtIa95nXibhsHdg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;674&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，使用 wg-quick 启动 &lt;code&gt;wg0&lt;/code&gt; 网卡：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; wg-quick up wg0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] ip link add wg0 &lt;span&gt;type&lt;/span&gt; wireguard&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] wg setconf wg0 /dev/fd/63&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] ip -4 address add 10.0.0.2/32 dev wg0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] ip link &lt;span&gt;set&lt;/span&gt; mtu 1420 up dev wg0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] wg &lt;span&gt;set&lt;/span&gt; wg0 fwmark 51820&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] ip -4 route add 0.0.0.0/0 dev wg0 table 51820&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] ip -4 rule add not fwmark 51820 table 51820&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] ip -4 rule add table main suppress_prefixlength 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] sysctl -q net.ipv4.conf.all.src_valid_mark=1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] iptables-restore -n&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嘻嘻，看到了熟悉的路由策略，这就打印所有的路由规则看看：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ip rule&lt;br/&gt;0:      from all lookup &lt;span&gt;local&lt;/span&gt;&lt;br/&gt;32764:  from all lookup main suppress_prefixlength 0&lt;br/&gt;32765:  not from all fwmark 0xca6c lookup 51820&lt;br/&gt;32766:  from all lookup main&lt;br/&gt;32767:  from all lookup default&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好家伙，多了两条规则：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;32764:  from all lookup main suppress_prefixlength 0&lt;br/&gt;32765:  not from all fwmark 0xca6c lookup 51820&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来扒扒他们的底裤，揭开神秘面纱。先来灵魂三问：&lt;code&gt;suppress_prefixlength&lt;/code&gt; 是啥？&lt;code&gt;0xca6c&lt;/code&gt; 又是啥？数据包怎么可能 &lt;code&gt;not from all&lt;/code&gt;？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Rule 32764&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先从规则 &lt;code&gt;32764&lt;/code&gt; 开始分析，因为它的数值比较小，会被优先匹配：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;32764:  from all lookup main suppress_prefixlength 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这条规则没有使用选择器，也就是说，内核会为每一个数据包去查询 &lt;code&gt;main&lt;/code&gt; 路由表。我们来看看 main 路由表内容是啥：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ip route&lt;br/&gt;default via 192.168.100.254 dev eth0 proto dhcp src 192.168.100.63 metric 100 &lt;br/&gt;192.168.100.0/24 dev eth0 proto kernel scope link src 192.168.100.63 &lt;br/&gt;192.168.100.254 dev eth0 proto dhcp scope link src 192.168.100.63 metric 100&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果真的是这样，那所有的数据包都会通过 main 路由表路由，永远不会到达 wg0。你别忘了，这条规则末尾还有一个参数：&lt;code&gt;suppress_prefixlength 0&lt;/code&gt;，这是啥意思呢？参考  &lt;code&gt;ip-rule(8)&lt;/code&gt; man page：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;suppress_prefixlength NUMBER&lt;br/&gt;    reject routing decisions that have a prefix length of NUMBER or less.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 &lt;code&gt;prefix&lt;/code&gt; 也就是&lt;strong&gt;前缀&lt;/strong&gt;，表示路由表中匹配的地址范围的&lt;strong&gt;掩码&lt;/strong&gt;。因此，如果路由表中包含 &lt;code&gt;10.2.3.4&lt;/code&gt; 的路由，前缀长度就是 32；如果是 &lt;code&gt;10.0.0.0/8&lt;/code&gt;，前缀长度就是 8。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;suppress&lt;/code&gt; 的意思是抑制，所以 &lt;code&gt;suppress_prefixlength 0&lt;/code&gt; 的意思是：&lt;strong&gt;拒绝前缀长度小于或等于 0 的路由策略&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么什么样的地址范围前缀长度才会小于等于 0？只有一种可能：&lt;code&gt;0.0.0.0/0&lt;/code&gt;，也就是默认路由。以我的机器为例，默认路由就是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;default via 192.168.100.254 dev eth0 proto dhcp src 192.168.100.63 metric 100&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果数据包匹配到了默认路由，就拒绝转发；如果是其他路由，就正常转发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这条规则的目的很简单，&lt;strong&gt;管理员手动添加到 main 路由表中的路由都会正常转发，而默认路由会被忽略，继续匹配下一条规则&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Rule 32765&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下一条规则就是 &lt;code&gt;32765&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;32765:  not from all fwmark 0xca6c lookup 51820&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 &lt;code&gt;not from all&lt;/code&gt; 是 ip rule 格式化的问题，有点反人类，人类更容易理解的顺序应该是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;32765:  from all not fwmark 0xca6c lookup 51820&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从前面 &lt;code&gt;wg-quick up wg0&lt;/code&gt; 的输出来看，规则的选择器是没有添加 from 前缀（地址或者地址范围）的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ip -4 rule add not fwmark 51820 table 51820&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果规则选择器没有 from 前缀，&lt;code&gt;ip rule&lt;/code&gt; 就会打印出 &lt;code&gt;from all&lt;/code&gt;，所以这条规则才会是这个样子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;51820 是一个路由表，也是由 wg-quick 创建的，只包含一条路由：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ip route show table 51820&lt;br/&gt;default dev wg0 scope link&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这条规则的效果是：&lt;strong&gt;匹配到该规则的所有数据包都通过 WireGuard 对端进行路由&lt;/strong&gt;，除了 &lt;code&gt;not fwmark 0xca6c&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;0xca6c 只是一个防火墙标记，wg-quick 会让 wg 标记它发出的所有数据包（&lt;strong&gt;wg set wg0 fwmark 51820&lt;/strong&gt;），这些数据包已经封装了其他数据包，如果这些数据包也通过 WireGuard 进行路由，就会形成一个无限路由环路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 &lt;code&gt;not from all fwmark 0xca6c lookup 51820&lt;/code&gt; 意思是说，满足条件 &lt;code&gt;from all fwmark 0xca6c&lt;/code&gt;（WireGuard 发出的都带 fwmark 0xca6c）请忽略本条规则，继续往下走。否则，请使用 51820 路由表，通过 wg0 隧道出去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 wg0 接口发包自带的 0xca6c，继续走下一条规则，也就是匹配默认的 main 路由表：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;32766:  from all lookup main&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时已经没有抑制器了，所有的数据包都可以自由使用 main 路由表，因此 WireGuard 对端的 Endpoint 地址会通过 eth0 接口发送出去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完美！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;wg-quick 创建的路由表和 fwmark 使用的是同一个数字：51820。0xca6c 是 51820 的十六进制表示。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;wg-quick 这种做法的巧妙之处在于，它不会扰乱你的主路由表，而是通过规则匹配新创建的路由表。断开连接时只需删除这两条路由规则，默认路由就会被重新激活。&lt;strong&gt;你学废了吗？&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引用链接&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;RUHEP/Radio-MSU: &lt;em&gt;http://www.radio-msu.net/about.htm&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7853433e2012c29131f43e62ec9e14df</guid>
<title>ping 命令还能这么玩？</title>
<link>https://toutiao.io/k/j0k9n5i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;点击下方“&lt;/span&gt;&lt;span&gt;IT牧场&lt;/span&gt;&lt;span&gt;”，选择“设为星标”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile data-index=&quot;0&quot; data-id=&quot;MzI4ODQ3NjE2OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/C93dCHmGrWzo3r2IwZzjK44WxQwhDAlhygicTbLH8Xv5wYClRpZJvoMxJIH9oPnRcGuKneSYicF3SOvJOaB34OibQ/0?wx_fmt=png&quot; data-nickname=&quot;程序员大目&quot; data-alias=&quot;itmuch_com&quot; data-signature=&quot;BAT 技术专家分享开发、架构、运维相关干货！&quot; data-origin_num=&quot;159&quot; data-is_biz_ban=&quot;0&quot; data-isban=&quot;0&quot; class=&quot;js_wx_tap_highlight&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;138861685132836864&quot; data-gallerysupplier=&quot;5&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/C93dCHmGrWxicPiam0hFIldlAq5aJliaV2OMnNJpcZsxA5JhicIS1picorszesol6cJ4ovDZkiaZeicpy2KWRg6vicpMHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1023&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;p&gt;&lt;span&gt;说实话，我以为ping就仅仅用来判断网络通不通，哈哈哈哈~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;作者：Pheenet菲尼特&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.toutiao.com/a6783191796659782148&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有朋友反映，能不能讲下 ping 命令的使用，其实对于命令的使用我们之前提到过一些，但对 ping 命令没有过多讲解，一般我们用的都是它的基本功能，今天我们来详细看下 ping 命令详细使用。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;一、ping 基本使用详解&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在网络中 ping 是一个十分强大的 TCP/IP 工具。它的作用主要为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、用来检测网络的连通情况和分析网络速度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、根据域名得到服务器 IP&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、根据 ping 返回的 TTL 值来判断对方所使用的操作系统及数据包经过路由器数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们通常会用它来直接 ping ip 地址，来测试网络的连通情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43243243243243246&quot; data-type=&quot;jpeg&quot; data-w=&quot;592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq41GQibqQicJyEibDibRTuGqvO8w8mzicDfNjOP8kljqlM2jU1ib66HHgxsc7Bw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类如这种，直接 ping ip 地址或网关，ping 通会显示出以上数据，有朋友可能会问，bytes=32；time&amp;lt;1ms；TTL=128 这些是什么意思。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;bytes 值：&lt;/strong&gt;数据包大小，也就是字节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;time 值：&lt;/strong&gt;响应时间，这个时间越小，说明你连接这个地址速度越快。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;TTL 值：&lt;/strong&gt;Time To Live, 表示 DNS 记录在 DNS 服务器上存在的时间，它是 IP 协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过 Ping 返回的 TTL 值大小，粗略地判断目标系统类型是 Windows 系列还是 UNIX/Linux 系列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;默认情况下，Linux 系统的 TTL 值为 64 或 255，WindowsNT/2000/XP 系统的 TTL 值为 128，Windows98 系统的 TTL 值为 32，UNIX 主机的 TTL 值为 255。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此一般 TTL 值：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;100~130ms 之间，Windows 系统 ；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;240~255ms 之间，UNIX/Linux 系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，我们今天主要了解并不是这些，而是 ping 的其它参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ping 命令除了直接 ping 网络的 ip 地址，验证网络畅通和速度之外，它还有这些用法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.99375&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq415Ir8rS0kz8Zmrhsa9YKpo1eEaE56h6cAUZZZ84gWJWKLMmatgJksfg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;二、ping -t 的使用&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;不间断地 Ping 指定计算机，直到管理员中断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7328125&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq41JlbCcskia5sSrGiben3f7dAOyibjU9HRcURQQkm0ckG4hiaFlZKKX4dYdg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就说明电脑连接路由器是通的，网络效果很好。下面按按住键盘的 Ctrl+c 终止它继续 ping 下去，就会停止了，会总结出运行的数据包有多少，通断的有多少了。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;三、ping -a 的使用&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;ping-a 解析计算机名与 NetBios 名。就是可以通过 ping 它的 ip 地址，可以解析出主机名。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3075980392156863&quot; data-type=&quot;jpeg&quot; data-w=&quot;816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq41o515kclyQA0qPcJq47XROiasdfGdjBfUADQkrqwq5KNLGBAUbPs4qXQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;四、ping -n 的使用&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在默认情况下，一般都只发送四个数据包，通过这个命令可以自己定义发送的个数，对衡量网络速度很有帮助，比如我想测试发送 10 个数据包的返回的平均时间为多少，最快时间为多少，最慢时间为多少就可以通过以下获知：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5234375&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq41Sd8hvpnuR1YE4nNQN80hic1aHGUcf3neiaT2UiaU5sAcgqrMQ20b2FRjg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从以上我就可以知道在给 47.93.187.142 发送 10 个数据包的过程当中，返回了 10 个，没有丢失，这 10 个数据包当中返回速度最快为 32ms，最慢为 55ms，平均速度为 37ms。说明我的网络良好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果对于一些不好的网络，比如监控系统中非常卡顿，这样测试，返回的结果可能会显示出丢失出一部分，如果丢失的比较多的话，那么就说明网络不好，可以很直观的判断出网络的情况。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;五、ping -l size 的使用&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;-l size：发送 size 指定大小的到目标主机的数据包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在默认的情况下 Windows 的 ping 发送的数据包大小为 32byt，最大能发送 65500byt。当一次发送的数据包大于或等于 65500byt 时，将可能导致接收方计算机宕机。所以微软限制了这一数值；这个参数配合其它参数以后危害非常强大，比如攻击者可以结合 - t 参数实施 DOS 攻击。（所以它具有危险性，不要轻易向别人计算机使用）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;例如：ping -l 65500 -t 211.84.7.46&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;会连续对 IP 地址执行 ping 命令，直到被用户以 Ctrl+C 中断.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.853125&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq412EJUGiaK8YHKT7qSsvGGToD6Rdv4W8aqoQRaW0DwtwOR42WX18ZFPRQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样它就会不停的向 211.84.7.46 计算机发送大小为 65500byt 的数据包，如果你只有一台计算机也许没有什么效果，但如果有很多计算机那么就可以使对方完全瘫痪，网络严重堵塞，由此可见威力非同小可。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;六、ping -r count 的使用&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在 “记录路由” 字段中记录传出和返回数据包的路由，探测经过的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;路由个数，但最多只能跟踪到 9 个路由。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ping -n 1 -r 9 202.102.224.25 （发送一个数据包，最多记录 9 个路由）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6375&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq41SzPiaV1KdmXd7QQnHkMpQPSymjQAGx1ib6RicD8saT8xlgeKy92ougzpw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将经过 9 个路由都显示出来了，可以看上图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ping 命令用的较多的就这 6 类的，大家有可能在项目中会用到的。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;七、批量 Ping 网段&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;对于一个网段 ip 地址众多，如果单个检测实在麻烦，那么我们可以直接批量 ping 网段检测，那个 ip 地址出了问题，一目了然。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先看代码，直接在命令行窗口输入：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;for /L %D in (1,1,255) do ping 10.168.1.%D&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IP 地址段修改成你要检查的 IP 地址段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9953125&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq41oXFHLbWDvCniaZRWdSiazZauicUMX8yLouV9MgX474cK1jUgxRbwZGFng/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当输入批量命令后，那么它就自动把网段内所有的 ip 地址都 ping 完为止。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么这段 “for /L %D in(1,1,255) do ping 10.168.1.%D” 代码是什么意思呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码中的这个 &lt;strong&gt;(1,1,255)&lt;/strong&gt; 就是网段起与始，就是检测网段 192.168.1.1 到 192.168.1.255 之间的所有的 ip 地址，每次逐增 1，直接到 1 到 255 这 255 个 ip 检测完为止。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;h2&gt;干货分享&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;最近将个人学习笔记整理成册，使用PDF分享。关注我，回复如下代码，即可获得百度盘地址，无套路领取！&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;001：《Java并发与高并发解决方案》学习笔记；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;002：《深入JVM内核——原理、诊断与优化》学习笔记；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;003：《Java面试宝典》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;004：《Docker开源书》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;005：《Kubernetes开源书》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;006：《DDD速成（领域驱动设计速成）》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;007：&lt;strong&gt;全部&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;008：&lt;strong&gt;加技术群讨论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;加个关注不迷路&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile data-index=&quot;1&quot; data-id=&quot;MzI4ODQ3NjE2OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/C93dCHmGrWzo3r2IwZzjK44WxQwhDAlhygicTbLH8Xv5wYClRpZJvoMxJIH9oPnRcGuKneSYicF3SOvJOaB34OibQ/0?wx_fmt=png&quot; data-nickname=&quot;程序员大目&quot; data-alias=&quot;itmuch_com&quot; data-signature=&quot;BAT 技术专家分享开发、架构、运维相关干货！&quot; data-origin_num=&quot;159&quot; data-is_biz_ban=&quot;0&quot; data-isban=&quot;0&quot; class=&quot;js_wx_tap_highlight&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;small&gt;喜欢就点个&quot;在看&quot;呗^_^&lt;/small&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>97bf8f2fec0346246a236418b275b650</guid>
<title>基于AI算法的数据库异常监测系统的设计与实现</title>
<link>https://toutiao.io/k/gqlclap</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;58&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU2zk0q52HtKQjubeUEyZHBVHPgeBXgTUj0ib1Kwfosl82xO1Aw7x6gccLuuYs1dbxI7REI7OcjbGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第532&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2022年 第049篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;103&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;103&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU2zk0q52HtKQjubeUEyZHBic5ADGrKxgSd0tibyMiasOHXjb46qFBw7PTfuWAxXzWq32lDkL05icwkMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;section&gt;&lt;span&gt;美团数据库平台研发组，面临日益急迫的数据库异常发现需求，为了更加快速、智能地发现、定位和止损，我们开发了基于AI算法的数据库异常检测服务。本文从特征分析、算法选型、模型训练与实时检测等维度介绍了我们的一些实践和思考，希望为从事相关工作的同学带来一些启发或者帮助。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 背景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 特征分析&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 算法选型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 模型训练与实时检测&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5. 产品运营&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6. 未来展望&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7. 附录&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 背景&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;数据库被广泛用于美团的核心业务场景上，对稳定性要求较高，对异常容忍度非常低。因此，快速的数据库异常发现、定位和止损就变得越来越重要。针对异常监测的问题，传统的固定阈值告警方式，需要依赖专家经验进行规则配置，不能根据不同业务场景灵活动态调整阈值，容易让小问题演变成大故障。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而基于AI的数据库异常发现能力，可以基于数据库历史表现情况，对关键指标进行7*24小时巡检，能够在异常萌芽状态就发现风险，更早地将异常暴露，辅助研发人员在问题恶化前进行定位和止损。基于以上这些因素的考量，美团数据库平台研发组决定开发一套数据库异常检测服务系统。接下来，本文将会从特征分析、算法选型、模型训练与实时检测等几个维度阐述我们的一些思考和实践。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 特征分析&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 找出数据的变化规律&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;在具体进行开发编码前，有一项非常重要的工作，就是从已有的历史监控指标中，发现时序数据的变化规律，从而根据数据分布的特点选取合适的算法。以下是我们从历史数据中选取的一些具有代表性的指标分布图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;217&quot; data-ratio=&quot;0.3875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofpXlWfoRO0Z25yIJ9fjKCFMvWibcAWXTP9cZRnSq9XEUnuuyJ9zscLQxw/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图1 数据库指标形态&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从上图我们可以看出，数据的规律主要呈现三种状态：周期、漂移和平稳&lt;sup&gt;[1]&lt;/sup&gt;。因此，我们前期可以针对这些普遍特征的样本进行建模，即可覆盖大部分场景。接下来，我们分别从周期性、漂移性和平稳性这三个角度进行分析，并讨论算法设计的过程。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.1 周期性变化&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在很多业务场景中，指标会由于早晚高峰或是一些定时任务引起规律性波动。我们认为这属于数据的内在规律性波动，模型应该具备识别出周期性成分，检测上下文异常的能力。对于不存在长期趋势成分的时序指标而言，当指标存在周期性成分的情况下，&lt;span&gt;&lt;embed src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/3a3QxMHZ8YyicHoJgRl1VavX6SEdiaqLGUTGbt8vYggCN6L4ruQJBuibicVWk9OKwx0A0roA8xib2kEOb01evaJVFKKTOh5JDkZhA/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/span&gt;，其中T代表的是时序的周期跨度。可通过计算自相关图，即计算出t取不同值时&lt;span&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -805.5 7252.1 1111&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;222B&quot; d=&quot;M113 -244Q113 -246 119 -251T139 -263T167 -269Q186 -269 199 -260Q220 -247 232 -218T251 -133T262 -15T276 155T297 367Q300 390 305 438T314 512T325 580T340 647T361 703T390 751T428 784T479 804Q481 804 488 804T501 805Q552 802 581 769T610 695Q610 669 594 657T561 645Q542 645 527 658T512 694Q512 705 516 714T526 729T538 737T548 742L552 743Q552 745 545 751T525 762T498 768Q475 768 460 756T434 716T418 652T407 559T398 444T387 300T369 133Q349 -38 337 -102T303 -207Q256 -306 169 -306Q119 -306 87 -272T55 -196Q55 -170 71 -158T104 -146Q123 -146 138 -159T153 -195Q153 -206 149 -215T139 -230T127 -238T117 -242L113 -244Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(776.7, 0)&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1326.7, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1715.7, 0)&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2287.7, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2676.7, 0)&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3226.7, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3615.7, 0)&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4409.9, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(5410.1, 0)&quot;&gt;&lt;path data-c=&quot;74&quot; d=&quot;M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5771.1, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(6160.1, 0)&quot;&gt;&lt;path data-c=&quot;64&quot; d=&quot;M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(6680.1, 0)&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt; 的值，然后通过分析自相关峰的间隔来确定周期性，主要的流程包括以下几个步骤：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提取趋势成分，分离出残差序列。使用移动平均法提取出长期趋势项，跟原序列作差得到残差序列（&lt;/span&gt;&lt;span&gt;此处周期性分析与趋势无关，若不分离趋势成分，自相关将显著受到影响，难以识别周期&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;计算残差的循环自相关（&lt;/span&gt;&lt;span&gt;Rolling Correlation&lt;/span&gt;&lt;span&gt;）序列。通过循环移动残差序列后，与残差序列进行向量点乘运算来计算自相关序列（&lt;/span&gt;&lt;span&gt;循环自相关可以避免延迟衰减&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;根据自相关序列的峰值坐标来确定周期T。提取自相关序列的一系列局部最高峰，取横坐标的间隔为周期（&lt;/span&gt;&lt;span&gt;如果该周期点对应的自相关值小于给定阈值，则认为无显著周期性&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;具体过程如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;344&quot; data-ratio=&quot;0.6158008658008658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofp0uqFKnxsZ8kvFA83edc940PbeO28gIe4NVd0MwCCetSSVZ1F8AeibVw/640?wx_fmt=jpeg&quot; data-w=&quot;924&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2 周期提取流程示意&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.2 漂移性变化&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;对于待建模的序列，通常要求它不存在明显的长期趋势或是存在全局漂移的现象，否则生成的模型通常无法很好地适应指标的最新走势&lt;sup&gt;[2]&lt;/sup&gt;。我们将时间序列随着时间的变化出现均值的显著变化或是存在全局突变点的情况，统称为漂移的场景。为了能够准确地捕捉时间序列的最新走势，我们需要在建模前期判断历史数据中是否存在漂移的现象。全局漂移和周期性序列均值漂移，如下示例所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;473&quot; data-ratio=&quot;0.8471933471933472&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofpJRib5y8FrG6GvoFwmE19LHDEz3XrR8acln2Q82TRiaIAHq4I0iaKWz0ibA/640?wx_fmt=jpeg&quot; data-w=&quot;962&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3 数据漂移示意&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据库指标受业务活动等复杂因素影响，很多数据会有非周期性的变化，而建模需要容忍这些变化。因此，区别于经典的变点检测问题，在异常检测场景下，我们只需要检测出历史上很平稳，之后出现数据漂移的情况。综合算法性能和实际表现，我们使用了基于中位数滤波的漂移检测方法，主要的流程包含以下几个环节：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1. 中位数平滑&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; a. 根据给定窗口的大小，提取窗口内的中位数来获取时序的趋势成分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; b. 窗口需要足够大，以避免周期因素影响，并进行滤波延迟矫正。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; c. 使用中位数而非均值平滑的原因在于为了规避异常样本的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2. 判断平滑序列是否递增或是递减&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; a. 中位数平滑后的序列数据，若每个点都大于（&lt;/span&gt;&lt;span&gt;小于&lt;/span&gt;&lt;span&gt;）前一个点，则序列为递增（&lt;/span&gt;&lt;span&gt;递减&lt;/span&gt;&lt;span&gt;）序列。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; b. 如果序列存在严格递增或是严格递减的性质，则指标明显存在长期趋势，此时可提前终止。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 遍历平滑序列，利用如下两个规则来判断是否存在漂移的现象&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt; a. 当前样本点左边序列的最大值小于当前样本点右边序列的最小值，则存在突增漂移（&lt;/span&gt;&lt;span&gt;上涨趋势&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; b. 当前样本点左边序列的最小值大于当前样本点右边序列的最大值，则存在突降漂移（&lt;/span&gt;&lt;span&gt;下跌趋势&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.3 平稳性变化&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;对于一个时序指标，如果其在任意时刻，它的性质不随观测时间的变化而变化，我们认为这条时序是具备平稳性的。因此，对于具有长期趋势成分亦或是周期性成分的时间序列而言，它们都是不平稳的。具体示例如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;525&quot; data-ratio=&quot;0.9084041548630784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofpjwMb6EzXRfPDqzLQ2lpNoQYFt4ufyBpCxMUqVLp2vYYzOtOpGww87w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1059&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图4 数据平稳示意&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对这种情况，我们可以通过单位根检验（&lt;/span&gt;&lt;span&gt;Augmented Dickey-Fuller Test&lt;/span&gt;&lt;span&gt;）&lt;sup&gt;[3]&lt;/sup&gt;来判断给定的时间序列是否平稳。具体地说，对于一条给定时间范围指标的历史数据而言，我们认为在同时满足如下条件的情况下，时序是平稳的：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最近1天的时序数据通过adfuller检验获得的p值小于0.05。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最近7天的时序数据通过adfuller检验获得的p值小于0.05。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 算法选型&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 分布规律与算法选择&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;通过了解业界的一些知名公司在时序数据异常检测上公布的产品介绍，加上我们历史积累的经验，以及对部分线上实际指标的抽样分析，它们的概率密度函数符合如下情况的分布：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;209&quot; data-ratio=&quot;0.3612791702679343&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofpmzKTgKbicQZx1kBG6LrSsBUTHmPEhGqpr4edVKRfvO6iaeDRCkZ7z3cA/640?wx_fmt=jpeg&quot; data-w=&quot;1157&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图5 分布偏斜示意&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对上述的分布，我们调研了一些常见的算法，并确定了箱形图、绝对中位差和极值理论作为最终异常检测算法。以下是对常见时序数据检测的算法对比表：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.28594771241830064&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUPL5RG514O9PotCLowpofpUibe9sBCKut4a5UBZs6s96UohvVpFalMaTkE51Cm10ES2cn0Cge8WTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1224&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们没有选择3Sigma的主要原因是它对异常容忍度较低，而绝对中位差从理论上而言具有更好的异常容忍度，所以在数据呈现高对称分布时，通过绝对中位差（&lt;/span&gt;&lt;span&gt;MAD&lt;/span&gt;&lt;span&gt;）替代3Sigma进行检测。我们对不同数据的分布分别采用了不同的检测算法（&lt;/span&gt;&lt;span&gt;关于不同算法的原理可以参考文末附录的部分，这里不做过多的阐述&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;低偏态高对称分布&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：绝对中位差（&lt;/span&gt;&lt;span&gt;MAD&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;中等偏态分布&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：箱形图（&lt;/span&gt;&lt;span&gt;Boxplot&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;高偏态分布&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：极值理论（&lt;/span&gt;&lt;span&gt;EVT&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;有了如上的分析，我们可以得出具体的根据样本输出模型的流程：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;453&quot; data-ratio=&quot;0.7829232995658466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofpjmaztl3iasbiarY1EtdX57XYZdSFyhXxpQeR68alHlqVmPObXENjP3VA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;691&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图6 算法建模流程&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;算法的整体建模流程如上图所示，主要涵盖以下几个分支环节：时序漂移检测、时序平稳性分析、时序周期性分析和偏度计算。下面分别进行介绍：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时序漂移检测&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。如果检测存在漂移的场景，则需要根据检测获得的漂移点t来切割输入时序，使用漂移点后的时序样本作为后续建模流程的输入，记为S={Si}，其中i&amp;gt;t。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时序平稳性分析&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。如果输入时序S满足平稳性检验，则直接通过箱形图（&lt;/span&gt;&lt;span&gt;默认&lt;/span&gt;&lt;span&gt;）或是绝对中位差的方式来进行建模。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;时序周期性分析&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。存在周期性的情况下，将周期跨度记为T，将输入时序S根据跨度T进行切割，针对各个时间索引j∈{0,1,⋯,T−1}所组成的数据桶进行建模流程。不存在周期性的情况下，针对全部输入时序S作为数据桶进行建模流程。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;案例&lt;/strong&gt;：给定一条时间序列ts={t&lt;sub&gt;0&lt;/sub&gt;,t&lt;sub&gt;1&lt;/sub&gt;,⋯,t&lt;sub&gt;n&lt;/sub&gt;}，假定其存在周期性且周期跨度为T，对于时间索引j而言，其中j∈{0,1,⋯,T−1}，对其建模所需要的样本点由区间[t&lt;sub&gt;j−kT−m&lt;/sub&gt;, t&lt;sub&gt;j−kT+m&lt;/sub&gt;]构成，其中m为参数，代表窗口大小，k为整数，满足j−kT−m≥0, j−kT+m≤n。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;举例来说，假设给定时序自2022/03/01 00:00:00至2022/03/08 00:00:00止，给定窗口大小为5，周期跨度为一天，那么对于时间索引30而言，对其建模所需要的样本点将来自于如下时间段：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[03/01 00:25:00, 03/01 00:35:00]&lt;br/&gt;[03/02 00:25:00, 03/02 00:35:00]&lt;br/&gt;...&lt;br/&gt;[03/07 00:25:00, 03/07 00:35:00]&lt;/span&gt;&lt;/section&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;偏度计算&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。时序指标转化为概率分布图，计算分布的偏度，若偏度的绝对值超过阈值，则通过极值理论进行建模输出阈值。若偏度的绝对值小于阈值，则通过箱形图或是绝对中位差的方式进行建模输出阈值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 案例样本建模&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;这里选取了一个案例，展示数据分析及建模过程，便于更清晰的理解上述过程。其中图(a)为原始序列，图(b)为按照天的跨度进行折叠的序列，图(c)为图(b)中某时间索引区间内的样本经过放大后的趋势表现，图(d)中黑色曲线为图(c)中时间索引所对应的下阈值。如下是针对某时序的历史样本进行建模的案例：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;475&quot; data-ratio=&quot;0.821875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofpHBLAKqBR1EMvZiaqtnCmxPx0wvicsQkHyLhzVKqp1rdbJXe0T8jUiahjg/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图7 建模案例&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图(c)区域内的样本分布直方图以及阈值（&lt;/span&gt;&lt;span&gt;已剔除其中部分异常样本&lt;/span&gt;&lt;span&gt;），可以看到，在该高偏分布的场景中，EVT算法计算的阈值更为合理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofpHTrRicN7jtbWT6tL8xFQm3VGyUzue0jZKYlqwqjMRXniaFibmdiaR8NPmQ/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;88.58131487889274&quot; data-cropy2=&quot;901.3148788927336&quot; data-ratio=&quot;0.6361111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofpfNdcArmGNbOxtUlib4n0UicF7LFqh7MMugWrUrCo7QibuHsoVsuJvjWGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;span&gt;图8 偏斜分布阈值对比&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 模型训练与实时检测&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 数据流转过程&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;为了实时检测规模庞大的秒级数据，我们以基于Flink进行实时流处理为出发点，设计了如下的技术方案：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;实时检测部分&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：基于Flink实时流处理，消费Mafka（&lt;/span&gt;&lt;span&gt;美团内部的消息队列组件&lt;/span&gt;&lt;span&gt;）消息进行在线检测，结果存储于Elasticsearch（&lt;/span&gt;&lt;span&gt;以下简称ES&lt;/span&gt;&lt;span&gt;）中，并产生异常记录。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;离线训练部分&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：以Squirrel（&lt;/span&gt;&lt;span&gt;美团内部的KV数据库&lt;/span&gt;&lt;span&gt;）作为任务队列，从MOD（&lt;/span&gt;&lt;span&gt;美团内部运维数据仓库&lt;/span&gt;&lt;span&gt;）读取训练数据，从配置表读取参数，训练模型，保存于ES，支持自动和手动触发训练，通过定时读取模型库的方式，进行模型加载和更新。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;以下是具体的离线训练和在线检测技术设计：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;1&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;241&quot; data-ratio=&quot;0.42908117752007136&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofpicKiavA5hepAJnlVV6qickkAaFzCVbMqkOibNH3IUyjVh7MPzcPK7KwQ2A/640?wx_fmt=jpeg&quot; data-w=&quot;1121&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图9 离线训练和在线检测技术设计&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 异常检测过程&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;异常检测算法整体采用分治思想，在模型训练阶段，根据历史数据识别提取特征，选定合适的检测算法。这里分为离线训练和在线检测两部分，离线主要根据历史情况进行数据预处理、时序分类和时序建模。在线主要加载运用离线训练的模型进行在线实时异常检测。具体设计如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0163934426229508&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofpibSibYvFib5iar1fia9urF4lN3EISsTW6WuSZYiaBVvpXLDBmPXqF0FfcdvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;671&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图10 异常检测过程&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 产品运营&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;为了提高优化迭代算法的效率，持续运营以提高精准率和召回率，我们借助Horae（&lt;/span&gt;&lt;span&gt;美团内部可扩展的&lt;/span&gt;&lt;a href=&quot;https://tech.meituan.com/2020/10/15/mt-aiops-horae.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;时序数据异常检测系统&lt;/span&gt;&lt;/a&gt;&lt;span&gt;）的案例回溯能力，实现在线检测、案例保存、分析优化、结果评估、发布上线的闭环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5395284327323162&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofpm1FXKMXpzRLcrp5XvmIov77V9t8SBdyW7va3ibJicpu3ibupGC1upVhsw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;721&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图11 运营流程&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;目前，异常检测算法指标如下：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. 未来展望&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;目前，美团数据库异常监测能力已基本构建完成，后续我们将对产品继续进行优化和拓展，具体方向包括：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;具有异常类型识别能力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。可以检测出异常的类型，如均值变化、波动变化、尖刺等，支持按异常类型进行告警订阅，并作为特征输入后续诊断系统，&lt;/span&gt;&lt;span&gt;&lt;span&gt;完善数据库自治生态&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;构建Human-in-Loop环境&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。支持根据反馈标注自动学习，&lt;/span&gt;&lt;span&gt;&lt;span&gt;保障模型持续优化&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;多种数据库场景的支持&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。异常检测能力平台化以支持更多数据库场景，如DB端到端报错、节点网络监测等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7. 附录&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.1 绝对中位差&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;绝对中位差，即Median Absolute Deviation(&lt;/span&gt;&lt;span&gt;MAD&lt;/span&gt;&lt;span&gt;)，是对单变量数值型数据的样本偏差的一种鲁棒性测量&lt;sup&gt;[6]&lt;/sup&gt;，通常由下式计算而得：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;MAD=C \times \operatorname{median}\left|X_{i}-\operatorname{median}(X)\right|&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/3a3QxMHZ8YyicHoJgRl1VavX6SEdiaqLGUUVvlUicWicvZMx8gySujicPHGAxjjvUbFIibUkJ6vBHG5SKMiacbNZQDQ4b4zukxRxkdo/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;Upper=median+k \times MAD&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/3a3QxMHZ8YyicHoJgRl1VavX6SEdiaqLGUIMZzAuKXPQKiaia5aZIdfcib0vIfjqCNO2ndzq4owLhBhBE6qLrH1icMRPzFgOibQ92tg/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;Lower=median-k \times MAD&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/3a3QxMHZ8YyicHoJgRl1VavX6SEdiaqLGUqHhw2PmxWm5CF9eHZsIM5RT4tc2RAYJxgCnTkVCQZ2PaGibiaCXEYZY6vhk5KGc2QQ/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其中在先验为正态分布的情况下，一般C选择1.4826，k选择3。MAD假定样本中间的50%区域均为正常样本，而异常样本落在两侧的50%区域内。当样本服从正态分布的情况下，MAD指标相较于标准差更能适应数据集中的异常值。对于标准差，使用的是数据到均值的距离平方，较大的偏差权重较大，异常值对结果影响不能忽视，而对MAD而言少量的异常值不会影响实验的结果，MAD算法对于数据的正态性有较高要求。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.2 箱形图&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;箱形图主要通过几个统计量来描述样本分布的离散程度以及对称性，包括：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Q0：最小值（&lt;/span&gt;&lt;span&gt;Minimum&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Q1：下四分位数（&lt;/span&gt;&lt;span&gt;Lower Quartile&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Q2：中位数（&lt;/span&gt;&lt;span&gt;Median&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Q3：上四分位数（&lt;/span&gt;&lt;span&gt;Upper Quartile&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Q4：最大值（&lt;/span&gt;&lt;span&gt;Maximum&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUPL5RG514O9PotCLowpofprxsm51erAiaCA7dnoicsMurwplic1FsiaKgJfkTmxJibGZ3XhBBFmKWdRAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图12 箱线图&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;将Q&lt;/span&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;span&gt;与Q&lt;/span&gt;&lt;sub&gt;3&lt;/sub&gt;&lt;span&gt;之间的间距称为IQR，当样本偏离上四分位1.5倍的IQR（&lt;/span&gt;&lt;span&gt;或是偏离下四分位数1.5倍的IQR&lt;/span&gt;&lt;span&gt;）的情况下，将样本视为是一个离群点。不同于基于正态假设的三倍标准差，通常情况下，箱形图对于样本的潜在数据分布没有任何假定，能够描述出样本的离散情况，且对样本中包含的潜在异常样本有较高的容忍度。对于有偏数据，Boxplot进行校准后建模更加符合数据分布&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.3 极值理论&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;真实世界的数据很难用一种已知的分布来概括，例如对于某些极端事件（&lt;/span&gt;&lt;span&gt;异常&lt;/span&gt;&lt;span&gt;），概率模型（&lt;/span&gt;&lt;span&gt;例如高斯分布&lt;/span&gt;&lt;span&gt;）往往会给出其概率为0。极值理论&lt;sup&gt;[8]&lt;/sup&gt;是在不基于原始数据的任何分布假设下，通过推断我们可能会观察到的极端事件的分布，这就是极值分布（&lt;/span&gt;&lt;span&gt;EVD&lt;/span&gt;&lt;span&gt;）。其数学表达式如下（&lt;/span&gt;&lt;span&gt;互补累积分布函数公式&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;P(X-t&amp;gt;x \mid X&amp;gt;t) \sim\left(1+\frac{\gamma x}{\delta(t)}\right)^{-\frac{1}{\gamma}}&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/3a3QxMHZ8YyicHoJgRl1VavX6SEdiaqLGUI02iaIXT41bG9dfP91DQQp2jiaTRFmIHHcSianyjVZvjh2BRBhMHQ5WicOmx8N7ylicnJ/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中t代表样本的经验阈值，对于不同场景可以设置不同取值，&lt;span&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -441 543 657&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;3B3&quot; d=&quot;M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;,&lt;span&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -717 444 727&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;3B4&quot; d=&quot;M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;分别是广义帕累托分布中的形状参数与尺度参数，在给定样本超过人为设定的经验阈值t的情况下，随机变量X-t是服从广义帕累托分布的。通过极大似然估计方法我们可以计算获得参数估计值&lt;span&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -764 543 980&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mover&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;3B3&quot; d=&quot;M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(40.3, -30)&quot;&gt;&lt;path data-c=&quot;5E&quot; d=&quot;M112 560L249 694L257 686Q387 562 387 560L361 531Q359 532 303 581L250 627L195 580Q182 569 169 557T148 538L140 532Q138 530 125 546L112 560Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;与&lt;span&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -1040 555.6 1050&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mover&quot;&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(28, 0)&quot;&gt;&lt;path data-c=&quot;3B4&quot; d=&quot;M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(55.6, 246)&quot;&gt;&lt;path data-c=&quot;5E&quot; d=&quot;M112 560L249 694L257 686Q387 562 387 560L361 531Q359 532 303 581L250 627L195 580Q182 569 169 557T148 538L140 532Q138 530 125 546L112 560Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt; ，并且通过如下公式来求取模型阈值：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;z_{q} \simeq t \pm \frac{\hat{\delta}}{\hat{\gamma}}\left(\left(\frac{q n}{N_{t}}\right)^{-\hat{\gamma}}-1\right)&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -1749.5 12063.7 2999&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msub&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;7A&quot; d=&quot;M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(465, -150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;71&quot; d=&quot;M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1118, 0)&quot;&gt;&lt;path data-c=&quot;2243&quot; d=&quot;M55 283Q55 356 103 409T217 463Q262 463 297 447T395 382Q431 355 446 344T493 320T554 307H558Q613 307 652 344T694 433Q694 464 708 464T722 432Q722 356 673 304T564 251H554Q510 251 465 275T387 329T310 382T223 407H219Q164 407 122 367Q91 333 85 295T76 253T69 250Q55 250 55 283ZM56 56Q56 71 72 76H706Q722 70 722 56Q722 44 707 36H70Q56 43 56 56Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2173.8, 0)&quot;&gt;&lt;path data-c=&quot;74&quot; d=&quot;M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2757, 0)&quot;&gt;&lt;path data-c=&quot;B1&quot; d=&quot;M56 320T56 333T70 353H369V502Q369 651 371 655Q376 666 388 666Q402 666 405 654T409 596V500V353H707Q722 345 722 333Q722 320 707 313H409V40H707Q722 32 722 20T707 0H70Q56 7 56 20T70 40H369V313H70Q56 320 56 333Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mfrac&quot; transform=&quot;translate(3757.3, 0)&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot; transform=&quot;translate(220, 676)&quot;&gt;&lt;g data-mml-node=&quot;mover&quot;&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(28, 0)&quot;&gt;&lt;path data-c=&quot;3B4&quot; d=&quot;M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(55.6, 246)&quot;&gt;&lt;path data-c=&quot;5E&quot; d=&quot;M112 560L249 694L257 686Q387 562 387 560L361 531Q359 532 303 581L250 627L195 580Q182 569 169 557T148 538L140 532Q138 530 125 546L112 560Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot; transform=&quot;translate(226.3, -724)&quot;&gt;&lt;g data-mml-node=&quot;mover&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;3B3&quot; d=&quot;M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(40.3, -30)&quot;&gt;&lt;path data-c=&quot;5E&quot; d=&quot;M112 560L249 694L257 686Q387 562 387 560L361 531Q359 532 303 581L250 627L195 580Q182 569 169 557T148 538L140 532Q138 530 125 546L112 560Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;rect x=&quot;120&quot; y=&quot;220&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mrow&quot; transform=&quot;translate(4752.9, 0)&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M758 -1237T758 -1240T752 -1249H736Q718 -1249 717 -1248Q711 -1245 672 -1199Q237 -706 237 251T672 1700Q697 1730 716 1749Q718 1750 735 1750H752Q758 1744 758 1741Q758 1737 740 1713T689 1644T619 1537T540 1380T463 1176Q348 802 348 251Q348 -242 441 -599T744 -1218Q758 -1237 758 -1240Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msup&quot; transform=&quot;translate(792, 0)&quot;&gt;&lt;g data-mml-node=&quot;mrow&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M701 -940Q701 -943 695 -949H664Q662 -947 636 -922T591 -879T537 -818T475 -737T412 -636T350 -511T295 -362T250 -186T221 17T209 251Q209 962 573 1361Q596 1386 616 1405T649 1437T664 1450H695Q701 1444 701 1441Q701 1436 681 1415T629 1356T557 1261T476 1118T400 927T340 675T308 359Q306 321 306 250Q306 -139 400 -430T690 -924Q701 -936 701 -940Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mfrac&quot; transform=&quot;translate(736, 0)&quot;&gt;&lt;g data-mml-node=&quot;mrow&quot; transform=&quot;translate(244.1, 676)&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;71&quot; d=&quot;M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(460, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(220, -686)&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(803, -150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;74&quot; d=&quot;M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;rect x=&quot;120&quot; y=&quot;220&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2284.3, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M34 1438Q34 1446 37 1448T50 1450H56H71Q73 1448 99 1423T144 1380T198 1319T260 1238T323 1137T385 1013T440 864T485 688T514 485T526 251Q526 134 519 53Q472 -519 162 -860Q139 -885 119 -904T86 -936T71 -949H56Q43 -949 39 -947T34 -937Q88 -883 140 -813Q428 -430 428 251Q428 453 402 628T338 922T245 1146T145 1309T46 1425Q44 1427 42 1429T39 1433T36 1436L34 1438Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(3020.3, 1176.6) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot; transform=&quot;translate(778, 0)&quot;&gt;&lt;g data-mml-node=&quot;mover&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;3B3&quot; d=&quot;M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(40.3, -30)&quot;&gt;&lt;path data-c=&quot;5E&quot; d=&quot;M112 560L249 694L257 686Q387 562 387 560L361 531Q359 532 303 581L250 627L195 580Q182 569 169 557T148 538L140 532Q138 530 125 546L112 560Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5018.6, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(6018.8, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(6518.8, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M33 1741Q33 1750 51 1750H60H65Q73 1750 81 1743T119 1700Q554 1207 554 251Q554 -707 119 -1199Q76 -1250 66 -1250Q65 -1250 62 -1250T56 -1249Q55 -1249 53 -1249T49 -1250Q33 -1250 33 -1239Q33 -1236 50 -1214T98 -1150T163 -1052T238 -910T311 -727Q443 -335 443 251Q443 402 436 532T405 831T339 1142T224 1438T50 1716Q33 1737 33 1741Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上述公式中q代表风险参数，n是所有样本数量，Nt是满足x-t&amp;gt;0的样本数量。由于通常情况下对于经验阈值t的估计没有先验的信息，因此可以使用样本经验分位数来替代数值t，这里经验分位数的取值可以根据实际情况来选择。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8. 参考资料&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;[1] Ren, H., Xu, B., Wang, Y., Yi, C., Huang, C., Kou, X., ... &amp;amp; Zhang, Q. (2019, July). Time-series anomaly detection service at microsoft. In Proceedings of the 25th ACM SIGKDD international conference on knowledge discovery &amp;amp; data mining (pp. 3009-3017).&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2] Lu, J., Liu, A., Dong, F., Gu, F., Gama, J., &amp;amp; Zhang, G. (2018). Learning under concept drift: A review. IEEE Transactions on Knowledge and Data Engineering, 31(12), 2346-2363.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[3] Mushtaq, R. (2011). Augmented dickey fuller test.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[4] Ma, M., Yin, Z., Zhang, S., Wang, S., Zheng, C., Jiang, X., ... &amp;amp; Pei, D. (2020). Diagnosing root causes of intermittent slow queries in cloud databases. Proceedings of the VLDB Endowment, 13(8), 1176-1189.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[5] Holzinger, A. (2016). Interactive machine learning for health informatics: when do we need the human-in-the-loop?. Brain Informatics, 3(2), 119-131.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[6] Leys, C., Ley, C., Klein, O., Bernard, P., &amp;amp; Licata, L. (2013). Detecting outliers: Do not use standard deviation around the mean, use absolute deviation around the median. Journal of experimental social psychology, 49(4), 764-766.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[7] Hubert, M., &amp;amp; Vandervieren, E. (2008). An adjusted boxplot for skewed distributions. Computational statistics &amp;amp; data analysis, 52(12), 5186-5201.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[8] Siffer, A., Fouque, P. A., Termier, A., &amp;amp; Largouet, C. (2017, August). Anomaly detection in streams with extreme value theory. In Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 1067-1075).&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;团队简介&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-source=&quot;bj.96weixin.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;美团基础技术部/数据库研发中心/数据库平台研发组，负责为美团各个业务线提供高效便捷的数据库使用入口，帮助美团DBA稳定快捷地维护数据库，同时提供分析诊断平台，实现数据库自治。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  | &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651768225&amp;amp;idx=1&amp;amp;sn=9d31b08486cef404013972ebc809de3c&amp;amp;chksm=bd121cec8a6595fa2062a4e129cdf216711ef39e12535d67cd8dfe990ed09f9fe95a3e312245&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数据库异常智能分析与诊断&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651768225&amp;amp;idx=1&amp;amp;sn=9d31b08486cef404013972ebc809de3c&amp;amp;chksm=bd121cec8a6595fa2062a4e129cdf216711ef39e12535d67cd8dfe990ed09f9fe95a3e312245&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数据库异常智能分析与诊断&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;数据库异常智能分析与诊断&lt;/a&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651768225&amp;amp;idx=1&amp;amp;sn=9d31b08486cef404013972ebc809de3c&amp;amp;chksm=bd121cec8a6595fa2062a4e129cdf216711ef39e12535d67cd8dfe990ed09f9fe95a3e312245&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数据库异常智能分析与诊断&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt;&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651769043&amp;amp;idx=1&amp;amp;sn=06214b6b59b894cf504a50ed4aacc02a&amp;amp;chksm=bd12119e8a6598885762f40ace12ef0bdf78c90a588a794c4363db79a3b8e45c14ac227e828b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数据库全量SQL分析与审计系统性能优化之旅&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;数据库全量SQL分析与审计系统性能优化之旅&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651751923&amp;amp;idx=1&amp;amp;sn=3908b323818b299c13cb19da24d2eb91&amp;amp;chksm=bd125cbe8a65d5a89a72e9b39e04da8ad78a609ed886c7f70dfcaebfb78aebd63f5701cc7787&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团MySQL数据库巡检系统的设计与应用&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团MySQL数据库巡检系统的设计与应用&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765958&amp;amp;idx=1&amp;amp;sn=8201546812e5a95a2bee9dffc6d12f00&amp;amp;chksm=bd12658b8a65ec9de2f5be1e96796dfb3c8f1a374d4b7bd91266072f557caf8118d4ddb72b07&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;前端&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765981&amp;amp;idx=1&amp;amp;sn=c2dd86f15dee2cbbc89e27677d985060&amp;amp;chksm=bd1265908a65ec86d4d08f7600d1518b61c90f6453074f9b308c96861c045712280a73751c73&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;算‍法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;算法&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765982&amp;amp;idx=1&amp;amp;sn=231b41f653ac7959f3e3b8213dcec2b0&amp;amp;chksm=bd1265938a65ec85630c546169444d56377bc2f11401d251da7ca50e5d07e353aa01580c7216&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;后端&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765964&amp;amp;idx=1&amp;amp;sn=ab6d8db147234fe57f27dd46eec40fef&amp;amp;chksm=bd1265818a65ec9749246dd1a2eb3bf7798772cc4d5b4283b15eae2f80bc6db63a1471a9e61e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数‍据&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数据&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765965&amp;amp;idx=1&amp;amp;sn=37e0c56c8b080146ce5249243bfd84d8&amp;amp;chksm=bd1265808a65ec96d3a2b2c87c6e27c910d49cb6b149970fb2db8bf88045a0a85fed2e6a0b84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;安‍全&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;安全&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765972&amp;amp;idx=1&amp;amp;sn=afe02ec92762c1ce18740d03324c4ac3&amp;amp;chksm=bd1265998a65ec8f10d5f58d0f3681ddfc5325137218e568e1cda3a50e427749edb5c6a7dcf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;And‍roid&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Android&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765973&amp;amp;idx=1&amp;amp;sn=32a23bf1d278dda0398f993ab60a697e&amp;amp;chksm=bd1265988a65ec8e630ef4d24b4946ab6bd7e66702c1d712481cf3c471468a059c470a14c30d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;iO‍S&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;iOS&lt;/span&gt;&lt;/a&gt;&lt;span&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765963&amp;amp;idx=1&amp;amp;sn=a3de9ef267d07d94118c1611776a4b28&amp;amp;chksm=bd1265868a65ec906592d25ad65f2a8516338d07ec3217059e6975fc131fc0107d66a8cd2612&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运‍维&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;运维&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765974&amp;amp;idx=1&amp;amp;sn=763c1e37d04acffd0142a2852ecfb000&amp;amp;chksm=bd12659b8a65ec8dfcfeb2028ef287fae7c38f134a665375ba420556ce5d2e4cf398147bd12e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;测‍试&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ5MTI5OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVGibnsaEib3aNlqF0tOrA2RGEmNSbia2nnohE4Tpf95UyTiaSjDVbHRfY8WNBeTuLLTaVdSckkNyEx1Q/0?wx_fmt=png&quot; data-nickname=&quot;美团技术团队&quot; data-alias=&quot;meituantech&quot; data-signature=&quot;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>10466ac7cc9d30ca7acb2189addac4c7</guid>
<title>Redis 6 中的多线程是如何实现的！？</title>
<link>https://toutiao.io/k/c3kqthc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;Redis 是一个高性能服务端的典范。它通过多路复用 epoll 来管理海量的用户连接，只使用一个线程来通过事件循环来处理所有用户请求，就可以达到每秒数万 QPS 的处理能力。下图是单线程版本 Redis 工作的核心原理图（参见：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNDUxOTQ5MQ==&amp;amp;mid=2247522300&amp;amp;idx=2&amp;amp;sn=620d863280a0fffc76a15f6ac7451dc8&amp;amp;chksm=9b2874d0ac5ffdc671a34c0c294c8231b5768d8ae73701b91a8fb90b843766aa692b56a7b258&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;单线程 Redis 如何做到每秒‍数万 QPS 的超高处理能力！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;单线程 Redis 如何做到每秒数万 QPS 的超高处理能力！&lt;/strong&gt;&lt;/a&gt;）。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9217221135029354&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYpDx3n42FppzUPVz6qqv9LpojMsfVic1ogesNzKaGw0jybVsgapXxbxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;511&quot;/&gt;&lt;/p&gt;&lt;section&gt;单线程的 Redis 虽然性能很高，但是却有两个问题。一个问题是没有办法充分发挥现代 CPU 的多核处理能力，一个实例只能使用一个核的能力。二是如果某个用户请求的处理过程卡住一段时间，会导致其它所有的请求都会出现超时的情况。所以，在线上的 redis 使用过程时是明确禁止使用 keys * 等长耗时的操作的。&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何改进呢，思路和方向其实很明确。那就是和其它的主流程序一样引入多线程，用更多的线程来分担这些可能耗时的操作。事实上 Redis 也确实这么干了，在 6.0 以后的版本里，开始支持了多线程。我们今天就来领略一下 Redis 的多线程是如何实现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、多线程 Redis 服务启动&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先获取多线程版本 Redis 的源码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; git &lt;span&gt;clone&lt;/span&gt; https://github.com/redis/redis&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &lt;span&gt;cd&lt;/span&gt; redis&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; git checkout -b 6.2.0 6.2.0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下多线程是默认关闭的。如果想要启动多线程，需要在配置文件中做适当的修改。相关的配置项是 io-threads 和 io-threads-do-reads 两个。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;vi /usr/&lt;span&gt;local&lt;/span&gt;/soft/redis6/conf/redis.conf &lt;/span&gt;&lt;br/&gt;io-threads 4 #启用的 io 线程数量&lt;br/&gt;io-threads-do-reads yes #读请求也使用io线程&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 io-threads 表示要启动的 io 线程的数量。io-threads-do-reads 表示是否在读阶段也使用 io 线程，默认是只在写阶段使用 io 线程的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在假设我们已经打开了如上两项多线程配置。带着这个假设，让我们进入到 Redis 的 main 入口函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1.1 主线程初始化&lt;/span&gt;&lt;br/&gt;    initServer();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1.2 启动 io 线程&lt;/span&gt;&lt;br/&gt;    InitServerLast();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 进入事件循环&lt;/span&gt;&lt;br/&gt;    aeMain(server.el);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 主线程初始化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 initServer 这个函数内，Redis 主线程做了这么几件重要的事情。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6492890995260664&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYic6MVguOxd0U1biaRkIsXddUgLXiaAib0lg3hrcQFlsQAH7V9zLJkZbBNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;422&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;初始化读任务队列、写任务队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建一个 epoll 对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对配置的监听端口进行 listen&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把 listen socket 让 epoll 给管理起来&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;initServer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1 初始化 server 对象&lt;/span&gt;&lt;br/&gt;    server.clients_pending_write = listCreate();&lt;br/&gt;    server.clients_pending_read = listCreate();&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 2 初始化回调 events，创建 epoll&lt;/span&gt;&lt;br/&gt;    server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 3 绑定监听服务端口&lt;/span&gt;&lt;br/&gt;    listenToPort(server.port,server.ipfd,&amp;amp;server.ipfd_count);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 4 注册 accept 事件处理器&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; server.ipfd_count; j++) {&lt;br/&gt;        aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,&lt;br/&gt;            acceptTcpHandler,&lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们分别来看。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化 server 对象&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 initServer 的一开头，先是对 server 的各种成员变量进行初始化。值得注意的是 clients_pending_write 和 clients_pending_read 这两个成员，它们分别是写任务队列和读任务队列。将来主线程产生的任务都会放在放在这两个任务队列里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主线程会根据这两个任务队列来进行任务哈希散列，以将任务分配到多个线程中进行处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;aeCreateEventLoop 处理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 aeCreateEventLoop 详细逻辑。它会初始化事件回调 event，并且创建了一个 epoll 对象出来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/ae.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;aeEventLoop *&lt;span&gt;aeCreateEventLoop&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; setsize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    aeEventLoop *eventLoop;&lt;br/&gt;    eventLoop = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(*eventLoop);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//将来的各种回调事件就都会存在这里&lt;/span&gt;&lt;br/&gt;    eventLoop-&amp;gt;events = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(aeFileEvent)*setsize);&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    aeApiCreate(eventLoop);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; eventLoop;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们注意一下 eventLoop-&amp;gt;events，将来在各种事件注册的时候都会保存到这个数组里。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/ae.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;aeEventLoop&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    ......&lt;br/&gt;    aeFileEvent *events; &lt;span&gt;/* Registered events */&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体创建 epoll 的过程在 ae_epoll.c 文件下的 aeApiCreate 中。在这里，真正调用了 epoll_create&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/ae_epoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;aeApiCreate&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    aeApiState *state = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(aeApiState));&lt;br/&gt;    state-&amp;gt;epfd = epoll_create(&lt;span&gt;1024&lt;/span&gt;); &lt;br/&gt;    eventLoop-&amp;gt;apidata = state;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;绑定监听服务端口&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看 Redis 中的 listen 过程，它在 listenToPort 函数中。调用链条很长，依次是 listenToPort =&amp;gt; anetTcpServer =&amp;gt; _anetTcpServer =&amp;gt; anetListen。在 anetListen 中，就是简单的 bind 和 listen 的调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/anet.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;anetListen&lt;/span&gt;&lt;span&gt;(......)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    bind(s,sa,len);&lt;br/&gt;    listen(s, backlog);&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;注册事件回调函数&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们调用 aeCreateEventLoop 创建了 epoll，调用 listenToPort 进行了服务端口的 bind 和 listen。接着就调用的 aeCreateFileEvent 就是来注册一个 accept 事件处理器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 aeCreateFileEvent 具体代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/ae.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;aeCreateFileEvent&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop, &lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;int&lt;/span&gt; mask,&lt;br/&gt;        aeFileProc *proc, &lt;span&gt;void&lt;/span&gt; *clientData)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 取出一个文件事件结构&lt;/span&gt;&lt;br/&gt;    aeFileEvent *fe = &amp;amp;eventLoop-&amp;gt;events[fd];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 监听指定 fd 的指定事件&lt;/span&gt;&lt;br/&gt;    aeApiAddEvent(eventLoop, fd, mask);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 设置文件事件类型，以及事件的处理器&lt;/span&gt;&lt;br/&gt;    fe-&amp;gt;mask |= mask;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (mask &amp;amp; AE_READABLE) fe-&amp;gt;rfileProc = proc;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (mask &amp;amp; AE_WRITABLE) fe-&amp;gt;wfileProc = proc;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 私有数据&lt;/span&gt;&lt;br/&gt;    fe-&amp;gt;clientData = clientData;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数 aeCreateFileEvent 一开始，从 eventLoop-&amp;gt;events 获取了一个 aeFileEvent 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来调用 aeApiAddEvent。这个函数其实就是对 epoll_ctl 的一个封装。主要就是实际执行 epoll_ctl EPOLL_CTL_ADD。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/ae_epoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;aeApiAddEvent&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop, &lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;int&lt;/span&gt; mask)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// add or mod&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; op = eventLoop-&amp;gt;events[fd].mask == AE_NONE ?&lt;br/&gt;            EPOLL_CTL_ADD : EPOLL_CTL_MOD;&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// epoll_ctl 添加事件&lt;/span&gt;&lt;br/&gt;    epoll_ctl(state-&amp;gt;epfd,op,fd,&amp;amp;ee);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个 eventLoop-&amp;gt;events 元素都指向一个 aeFileEvent 对象。在这个对象上，设置了三个关键东西&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;rfileProc：读事件回调&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;wfileProc：写事件回调&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;clientData：一些额外的扩展数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将来 当 epoll_wait 发现某个 fd 上有事件发生的时候，这样 redis 首先根据 fd 到 eventLoop-&amp;gt;events 中查找 aeFileEvent 对象，然后再看 rfileProc、wfileProc 就可以找到读、写回调处理函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回头看 initServer 调用 aeCreateFileEvent 时传参来看。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;initServer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; server.ipfd_count; j++) {&lt;br/&gt;        aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,&lt;br/&gt;            acceptTcpHandler,&lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;listen fd 对应的读回调函数 rfileProc 事实上就被设置成了 acceptTcpHandler，写回调没有设置，私有数据 client_data 也为 null。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 io 线程启动&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主线程启动以后，会调用 InitServerLast =&amp;gt; initThreadedIO 来创建多个 io 线程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47379454926624737&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyY5o3bxXR5YavuN1pmH0EHb63DFXwtpUYgV8KhJAPY4TLKHudicPcbwLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;477&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将来这些 IO 线程会配合主线程一起共同来处理所有的 read 和 write 任务。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9035639412997903&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYU4OgVsrMzW6HibFTfvcXbPhZb9Fe5KxFYJMnXPOfleDE20dUGciaicaCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;477&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 InitServerLast 创建 IO 线程的过程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;InitServerLast&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    initThreadedIO();&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;initThreadedIO&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//如果没开启多 io 线程配置就不创建了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.io_threads_num == &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//开始 io 线程的创建&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; server.io_threads_num; i++) {&lt;br/&gt;        &lt;span&gt;pthread_t&lt;/span&gt; tid;&lt;br/&gt;        pthread_create(&amp;amp;tid,&lt;span&gt;NULL&lt;/span&gt;,IOThreadMain,(&lt;span&gt;void&lt;/span&gt;*)(&lt;span&gt;long&lt;/span&gt;)i)&lt;br/&gt;        io_threads[i] = tid;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 initThreadedIO 中调用 pthread_create 库函数创建线程，并且注册线程回调函数 IOThreadMain。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;IOThreadMain&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *myid)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; id = (&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)myid;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;//循环等待任务&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;1000000&lt;/span&gt;; j++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (getIOPendingCount(id) != &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//允许主线程来关闭自己&lt;/span&gt;&lt;br/&gt;        ......&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//遍历当前线程等待队列里的请求 client&lt;/span&gt;&lt;br/&gt;        listIter li;&lt;br/&gt;        listNode *ln;&lt;br/&gt;        listRewind(io_threads_list[id],&amp;amp;li);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;            client *c = listNodeValue(ln);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_WRITE) {&lt;br/&gt;                writeToClient(c,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_READ) {&lt;br/&gt;                readQueryFromClient(c-&amp;gt;conn);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                serverPanic(&lt;span&gt;&quot;io_threads_op value is unknown&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        listEmpty(io_threads_list[id]);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是将当前线程等待队列 io_threads_list[id] 里所有的请求 client，依次取出处理。其中读操作通过 readQueryFromClient 处理， 写操作通过 writeToClient 处理。其中 io_threads_list[id] 中的任务是主线程分配过来的，后面我们将会看到。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、主线程事件循环&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们进入到 Redis 最重要的 aeMain，这个函数就是一个死循环（Redis 不退出的话），不停地执行 aeProcessEvents 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;aeMain&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    eventLoop-&amp;gt;stop = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (!eventLoop-&amp;gt;stop) {&lt;br/&gt;        aeProcessEvents(eventLoop, AE_ALL_EVENTS|&lt;br/&gt;                                   AE_CALL_BEFORE_SLEEP|&lt;br/&gt;                                   AE_CALL_AFTER_SLEEP);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 aeProcessEvents 就是所谓的事件分发器。它通过调用 epoll_wait 来发现所发生的各种事件，然后调用事先注册好的处理函数进行处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8891352549889135&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;451&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYKEicFkic3mjhF3S2Y8iabUBN5ib3BP40X20ova2QAayur30ElOfJKEUbIg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看 aeProcessEvents 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/ae.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;aeProcessEvents&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop, &lt;span&gt;int&lt;/span&gt; flags)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 2.3 事件循环处理3：epoll_wait 前进行读写任务队列处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (eventLoop-&amp;gt;beforesleep != &lt;span&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; flags &amp;amp; AE_CALL_BEFORE_SLEEP)&lt;br/&gt;            eventLoop-&amp;gt;beforesleep(eventLoop);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//epoll_wait发现事件并进行处理&lt;/span&gt;&lt;br/&gt;    numevents = aeApiPoll(eventLoop, tvp);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 从已就绪数组中获取事件&lt;/span&gt;&lt;br/&gt;    aeFileEvent *fe = &amp;amp;eventLoop-&amp;gt;events[eventLoop-&amp;gt;fired[j].fd];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//如果是读事件，并且有读回调函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//2.1 如果是 listen socket 读事件，则处理新连接请求&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//2.2 如果是客户连接socket 读事件，处理客户连接上的读请求&lt;/span&gt;&lt;br/&gt;    fe-&amp;gt;rfileProc()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//如果是写事件，并且有写回调函数&lt;/span&gt;&lt;br/&gt;    fe-&amp;gt;wfileProc()&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 aeApiPoll 就是对 epoll_wait 的一个封装而已。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/ae_epoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;aeApiPoll&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop, struct timeval *tvp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 等待事件&lt;/span&gt;&lt;br/&gt;    aeApiState *state = eventLoop-&amp;gt;apidata;&lt;br/&gt;    epoll_wait(state-&amp;gt;epfd,state-&amp;gt;events,eventLoop-&amp;gt;setsize,&lt;br/&gt;            tvp ? (tvp-&amp;gt;tv_sec*&lt;span&gt;1000&lt;/span&gt; + tvp-&amp;gt;tv_usec/&lt;span&gt;1000&lt;/span&gt;) : &lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;aeProcessEvents 就是调用 epoll_wait 来发现事件。当发现有某个 fd 上事件发生以后，则调为其事先注册的事件处理器函数 rfileProc 和 wfileProc。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 事件循环处理1：新连接到达&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 1.1 节中我们看到，主线程初始化的时候，将 listen socket 上的读事件处理函数注册成了 acceptTcpHandler。也就是说如果有新连接到达的时候，acceptTcpHandler 将会被执行到。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7018255578093306&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYe5icxVGhKl5JpCPq00o1EialahwSEPTtaF5aFu8Fs0pibBCj7RCbhvLsg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个函数内，主要完成如下几件事情。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;调用 accept 接收连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建一个 redisClient对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加到 epoll&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注册读事件处理函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来让我们进入 acceptTcpHandler 源码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;acceptTcpHandler&lt;/span&gt;&lt;span&gt;(aeEventLoop *el, &lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;void&lt;/span&gt; *privdata, &lt;span&gt;int&lt;/span&gt; mask)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;    cfd = anetTcpAccept(server.neterr, fd, cip, &lt;span&gt;sizeof&lt;/span&gt;(cip), &amp;amp;cport);&lt;br/&gt;    acceptCommonHandler(connCreateAcceptedSocket(cfd),&lt;span&gt;0&lt;/span&gt;,cip);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 netTcpAccept 调用 accept 系统调用获取连接，就不展开了。我们看 acceptCommonHandler。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acceptCommonHandler&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;int&lt;/span&gt; flags)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 创建客户端&lt;/span&gt;&lt;br/&gt;    redisClient *c;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((c = createClient(fd)) == &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;client *&lt;span&gt;createClient&lt;/span&gt;&lt;span&gt;(connection *conn)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    client *c = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(client));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 为用户连接注册读事件处理器&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (conn) {&lt;br/&gt;        ...&lt;br/&gt;        connSetReadHandler(conn, readQueryFromClient);&lt;br/&gt;        connSetPrivateData(conn, c);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    selectDb(c,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    c-&amp;gt;id = client_id;&lt;br/&gt;    c-&amp;gt;resp = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    c-&amp;gt;conn = conn;&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，我们重点关注 &lt;code&gt;connSetReadHandler(conn, readQueryFromClient)&lt;/code&gt;, 这一行是将这个新连接的读事件处理函数设置成了 readQueryFromClient。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 事件循环处理2：用户命令请求到达&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面我们看到了， Redis 把用户连接上的读请求处理函数设置成了 readQueryFromClient，这意味着当用户连接上有命令发送过来的时候，会进入 readQueryFromClient 开始执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多线程版本的 readQueryFromClient 中，处理逻辑非常简单，仅仅只是将发生读时间的 client 放到了任务队列里而已。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7990762124711316&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;433&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYxycicB3JUTMCNW0cZEKMSZB1xxD4oCQE8SWDiauPq5CNcT7YPAibXzpAw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来详细看 readQueryFromClient 代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;readQueryFromClient&lt;/span&gt;&lt;span&gt;(connection *conn)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    client *c = connGetPrivateData(conn);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//如果启动 threaded I/O 的话，直接入队&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (postponeClientRead(c)) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//处理用户连接读请求&lt;/span&gt;&lt;br/&gt;    ......&lt;br/&gt;    c-&amp;gt;querybuf = sdsMakeRoomFor(c-&amp;gt;querybuf, readlen);&lt;br/&gt;    nread = connRead(c-&amp;gt;conn, c-&amp;gt;querybuf+qblen, readlen);&lt;br/&gt;    processInputBuffer(c);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 postponeClientRead 中判断，是不是开启了多 io 线程，如果开启了的话，那就将有请求数据到达的 client 直接放到读任务队列（server.clients_pending_read）中就算是完事。我们看下 postponeClientRead。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;postponeClientRead&lt;/span&gt;&lt;span&gt;(client *c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.io_threads_active &amp;amp;&amp;amp;&lt;br/&gt;        server.io_threads_do_reads &amp;amp;&amp;amp;&lt;br/&gt;        !ProcessingEventsWhileBlocked &amp;amp;&amp;amp;&lt;br/&gt;        !(c-&amp;gt;flags &amp;amp; (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ)))&lt;br/&gt;    {&lt;br/&gt;        c-&amp;gt;flags |= CLIENT_PENDING_READ;&lt;br/&gt;        listAddNodeHead(server.clients_pending_read,c);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;listAddNodeHead 就是把这个 client 对象添加到 server.clients_pending_read 而已。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 事件循环处理3：epoll_wait 前进行任务处理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 aeProcessEvents 中假如 aeApiPoll(epoll_wait)中的事件都处理完了以后，则会进入下一次的循环再次进入 aeProcessEvents。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这一次中 beforesleep 将会处理前面读事件处理函数添加的读任务队列了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/ae.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;aeProcessEvents&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop, &lt;span&gt;int&lt;/span&gt; flags)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 参见 2.4 事件循环处理3：epoll_wait 前进行任务处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (eventLoop-&amp;gt;beforesleep != &lt;span&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; flags &amp;amp; AE_CALL_BEFORE_SLEEP)&lt;br/&gt;            eventLoop-&amp;gt;beforesleep(eventLoop);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//epoll_wait发现事件并进行处理&lt;/span&gt;&lt;br/&gt;    numevents = aeApiPoll(eventLoop, tvp);&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 beforeSleep 里会依次处理两个任务队列。先处理读任务队列，解析其中的请求，并处理之。然后将处理结果写到缓存中，同时写到写任务队列中。紧接着 beforeSleep 会进入写任务队列处理，会将处理结果写到 socket 里，进行真正的数据发送。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9842829076620825&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyY90TEFqnft5F47nVzrd1my12nMCacwicYvnr9iaSg3TkYJHKu8rG3yf4g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 beforeSleep 的代码，这个函数中最重要的两个调用是 handleClientsWithPendingReadsUsingThreads（处理读任务队列），handleClientsWithPendingWritesUsingThreads（处理写任务队列）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;beforeSleep&lt;/span&gt;&lt;span&gt;(struct aeEventLoop *eventLoop)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//处理读任务队列&lt;/span&gt;&lt;br/&gt;    handleClientsWithPendingReadsUsingThreads();&lt;br/&gt;    &lt;span&gt;//处理写任务队列&lt;/span&gt;&lt;br/&gt;    handleClientsWithPendingWritesUsingThreads();&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，如果开启了多 io 线程的话，handleClientsWithPendingReadsUsingThreads 和 handleClientsWithPendingWritesUsingThreads 中将会是主线程、io 线程一起配合来处理的。所以我们单独分两个小节来阐述。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、主线程 &amp;amp;&amp;amp; io 线程处理读请求&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 handleClientsWithPendingReadsUsingThreads 中，主线程会遍历读任务队列 server.clients_pending_read，把其中的请求分配到每个 io 线程的处理队列 io_threads_list[target_id] 中。然后通知各个 io 线程开始处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2057026476578412&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYrX6zgbzGrUpx6EFficfDTHicjmeM9ibgrYU00ecRPgLP2bbx1AqefP0icQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 主线程分配任务&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 handleClientsWithPendingReadsUsingThreads 详细代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//当开启了 reading + parsing 多线程 I/O &lt;/span&gt;&lt;br/&gt;&lt;span&gt;//read handler 仅仅只是把 clients 推到读队列里&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//而这个函数开始处理该任务队列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;handleClientsWithPendingReadsUsingThreads&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//访问读任务队列 server.clients_pending_read&lt;/span&gt;&lt;br/&gt;    listRewind(server.clients_pending_read,&amp;amp;li);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//把每一个任务取出来&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//添加到指定线程的任务队列里 io_threads_list[target_id]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; target_id = item_id % server.io_threads_num;&lt;br/&gt;        listAddNodeTail(io_threads_list[target_id],c);&lt;br/&gt;        item_id++;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//启动Worker线程，处理读请求&lt;/span&gt;&lt;br/&gt;    io_threads_op = IO_THREADS_OP_READ;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; server.io_threads_num; j++) {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = listLength(io_threads_list[j]);&lt;br/&gt;        setIOPendingCount(j, count);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//主线程处理 0 号任务队列&lt;/span&gt;&lt;br/&gt;    listRewind(io_threads_list[&lt;span&gt;0&lt;/span&gt;],&amp;amp;li);&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        &lt;span&gt;//需要先干掉 CLIENT_PENDING_READ 标志&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//否则 readQueryFromClient 并不处理，而是入队&lt;/span&gt;&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        readQueryFromClient(c-&amp;gt;conn);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//主线程等待其它线程处理完毕&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pending = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; server.io_threads_num; j++)&lt;br/&gt;            pending += getIOPendingCount(j);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pending == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//再跑一遍任务队列，目的是处理输入&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(listLength(server.clients_pending_read)) {&lt;br/&gt;        ......&lt;br/&gt;        processInputBuffer(c);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!(c-&amp;gt;flags &amp;amp; CLIENT_PENDING_WRITE) &amp;amp;&amp;amp; clientHasPendingReplies(c))&lt;br/&gt;            clientInstallWriteHandler(c);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主线程中将任务分别放到了 io_threads_list 的第 0 到第 N 个元素里。并对 1 : N 号线程通过 setIOPendingCount 发消息，告诉他们起来处理。这时候 io 线程将会在 IOThreadMain 中收到消息并开始处理读任务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;IOThreadMain&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *myid)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;//遍历当前线程等待队列里的请求 client&lt;/span&gt;&lt;br/&gt;        listRewind(io_threads_list[id],&amp;amp;li);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;            client *c = listNodeValue(ln);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_WRITE) {&lt;br/&gt;                writeToClient(c,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_READ) {&lt;br/&gt;                readQueryFromClient(c-&amp;gt;conn);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                serverPanic(&lt;span&gt;&quot;io_threads_op value is unknown&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 io 线程中，从自己的 io_threads_list[id] 中遍历获取待处理的 client。如果发现是读请求处理，则进入 readQueryFromClient 开始处理特定的 client。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而主线程在分配完 1 ：N 任务队列让其它 io 线程处理后，自己则开始处理第 0 号任务池。同样是会进入到 readQueryFromClient 中来执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;handleClientsWithPendingReadsUsingThreads&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;    &lt;span&gt;//主线程处理 0 号任务队列&lt;/span&gt;&lt;br/&gt;    listRewind(io_threads_list[&lt;span&gt;0&lt;/span&gt;],&amp;amp;li);&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        &lt;span&gt;//需要先干掉 CLIENT_PENDING_READ 标志&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//否则 readQueryFromClient 并不处理，而是入队&lt;/span&gt;&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        readQueryFromClient(c-&amp;gt;conn);&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以无论是主线程还是 io 线程，处理客户端的读事件都是会进入 readQueryFromClient。我们来看其源码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 读请求处理&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;readQueryFromClient&lt;/span&gt;&lt;span&gt;(connection *conn)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//读取请求&lt;/span&gt;&lt;br/&gt;    nread = connRead(c-&amp;gt;conn, c-&amp;gt;querybuf+qblen, readlen);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//处理请求&lt;/span&gt;&lt;br/&gt;    processInputBuffer(c);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 connRead 中就是调用 read 将 socket 中的命令读取出来，就不展开看了。接着在 processInputBuffer 中将输入缓冲区中的数据解析成对应的命令。解析完命令后真正开始处理它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;processInputBuffer&lt;/span&gt;&lt;span&gt;(client *c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(c-&amp;gt;qb_pos &amp;lt; sdslen(c-&amp;gt;querybuf)) {&lt;br/&gt;        &lt;span&gt;//解析命令&lt;/span&gt;&lt;br/&gt;        ......&lt;br/&gt;        &lt;span&gt;//真正开始处理 command&lt;/span&gt;&lt;br/&gt;        processCommandAndResetClient(c);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数 processCommandAndResetClient 会调用 processCommand，查询命令并开始执行。执行的核心方法是 call 函数，我们直接看它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;call&lt;/span&gt;&lt;span&gt;(client *c, &lt;span&gt;int&lt;/span&gt; flags)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 查找处理命令，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;redisCommand&lt;/span&gt; *&lt;span&gt;real_cmd&lt;/span&gt; = &lt;span&gt;c&lt;/span&gt;-&amp;gt;&lt;span&gt;cmd&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 调用命令处理函数&lt;/span&gt;&lt;br/&gt;    c-&amp;gt;cmd-&amp;gt;proc(c);&lt;br/&gt;&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 server.c 中定义了每一个命令对应的处理函数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;redisCommand&lt;/span&gt; &lt;span&gt;redisCommandTable&lt;/span&gt;[] = {&lt;/span&gt;&lt;br/&gt;    {&lt;span&gt;&quot;module&quot;&lt;/span&gt;,moduleCommand,&lt;span&gt;-2&lt;/span&gt;,&lt;span&gt;&quot;as&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;get&quot;&lt;/span&gt;,getCommand,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;&quot;rF&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;set&quot;&lt;/span&gt;,setCommand,&lt;span&gt;-3&lt;/span&gt;,&lt;span&gt;&quot;wm&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;setnx&quot;&lt;/span&gt;,setnxCommand,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;&quot;wmF&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;setex&quot;&lt;/span&gt;,setexCommand,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;&quot;wm&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    {&lt;span&gt;&quot;mget&quot;&lt;/span&gt;,mgetCommand,&lt;span&gt;-2&lt;/span&gt;,&lt;span&gt;&quot;rF&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;-1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;rpush&quot;&lt;/span&gt;,rpushCommand,&lt;span&gt;-3&lt;/span&gt;,&lt;span&gt;&quot;wmF&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;lpush&quot;&lt;/span&gt;,lpushCommand,&lt;span&gt;-3&lt;/span&gt;,&lt;span&gt;&quot;wmF&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;rpushx&quot;&lt;/span&gt;,rpushxCommand,&lt;span&gt;-3&lt;/span&gt;,&lt;span&gt;&quot;wmF&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 get 命令来说，其对应的命令处理函数就是 getCommand。也就是说当处理 GET 命令执行到 &lt;code&gt;c-&amp;gt;cmd-&amp;gt;proc&lt;/code&gt; 的时候会进入到 getCommand 函数中来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/t_string.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;getCommand&lt;/span&gt;&lt;span&gt;(client *c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    getGenericCommand(c);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;getGenericCommand&lt;/span&gt;&lt;span&gt;(client *c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    robj *o;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((o = lookupKeyReadOrReply(c,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;],shared.null[c-&amp;gt;resp])) == &lt;span&gt;NULL&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; C_OK;&lt;br/&gt;    ...&lt;br/&gt;    addReplyBulk(c,o);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; C_OK;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;getGenericCommand 方法会调用 lookupKeyReadOrReply 来从内存中查找对应的 key值。如果找不到，则直接返回 C_OK；如果找到了，调用 addReplyBulk 方法将值添加到输出缓冲区中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;addReplyBulk&lt;/span&gt;&lt;span&gt;(client *c, robj *obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    addReplyBulkLen(c,obj);&lt;br/&gt;    addReply(c,obj);&lt;br/&gt;    addReply(c,shared.crlf);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 写处理结果到发送缓存区&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其主体是调用 addReply 来设置回复数据。在 addReply 方法中做了两件事情：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;prepareClientToWrite 判断是否需要返回数据，并且将当前 client 添加到等待写返回数据队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用
_addReplyToBuffer 和 _addReplyObjectToList 方法将返回值写入到输出缓冲区中，等待写入 socekt&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;addReply&lt;/span&gt;&lt;span&gt;(client *c, robj *obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (prepareClientToWrite(c) != C_OK) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (sdsEncodedObject(obj)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (_addReplyToBuffer(c,obj-&amp;gt;ptr,sdslen(obj-&amp;gt;ptr)) != C_OK)&lt;br/&gt;            _addReplyStringToList(c,obj-&amp;gt;ptr,sdslen(obj-&amp;gt;ptr));&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        ......        &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看 prepareClientToWrite 的详细实现，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;prepareClientToWrite&lt;/span&gt;&lt;span&gt;(client *c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!clientHasPendingReplies(c) &amp;amp;&amp;amp; !(c-&amp;gt;flags &amp;amp; CLIENT_PENDING_READ))&lt;br/&gt;        clientInstallWriteHandler(c);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;clientInstallWriteHandler&lt;/span&gt;&lt;span&gt;(client *c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    c-&amp;gt;flags |= CLIENT_PENDING_WRITE;&lt;br/&gt;    listAddNodeHead(server.clients_pending_write,c);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 server.clients_pending_write 就是我们说的任务队列，队列中的每一个元素都是有待写返回数据的 client 对象。在 prepareClientToWrite 函数中，把 client 添加到任务队列 server.clients_pending_write 里就算完事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下再来 _addReplyToBuffer，该方法是向固定缓存中写，如果写不下的话就继续调用 _addReplyStringToList 往链表里写。简单起见，我们只看 _addReplyToBuffer 的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; _addReplyToBuffer(client *c, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *s, &lt;span&gt;size_t&lt;/span&gt; len) {&lt;br/&gt;    ......&lt;br/&gt;    &lt;span&gt;// 拷贝到 client 对象的 Response buffer 中&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;memcpy&lt;/span&gt;(c-&amp;gt;buf+c-&amp;gt;bufpos,s,len);&lt;br/&gt;    c-&amp;gt;bufpos+=len;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; C_OK;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要注意的是，本节的读请求处理过程是主线程和 io 线程在并行执行的。主线程在处理完后会等待其它的 io 线程处理。在所有的读请求都处理完后，主线程 beforeSleep 中对 handleClientsWithPendingReadsUsingThreads 的调用就结束了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、主线程 &amp;amp;&amp;amp; io 线程配合处理写请求&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当所有的读请求处理完后，handleClientsWithPendingReadsUsingThreads 会退出。主线程会紧接着进入 handleClientsWithPendingWritesUsingThreads 中来处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2032520325203253&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYUJcNIVYrRCx1n2DbgykpHsVjjFvtYS84hZl2gemoia4z5FUdjice11Kw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;beforeSleep&lt;/span&gt;&lt;span&gt;(struct aeEventLoop *eventLoop)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//处理读任务队列&lt;/span&gt;&lt;br/&gt;    handleClientsWithPendingReadsUsingThreads();&lt;br/&gt;    &lt;span&gt;//处理写任务队列&lt;/span&gt;&lt;br/&gt;    handleClientsWithPendingWritesUsingThreads();&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 主线程分配任务&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;handleClientsWithPendingWritesUsingThreads&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//没有开启多线程的话，仍然是主线程自己写&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.io_threads_num == &lt;span&gt;1&lt;/span&gt; || stopThreadedIOIfNeeded()) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; handleClientsWithPendingWrites();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//获取待写任务&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; processed = listLength(server.clients_pending_write);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//在N个任务列表中分配该任务&lt;/span&gt;&lt;br/&gt;    listIter li;&lt;br/&gt;    listNode *ln;&lt;br/&gt;    listRewind(server.clients_pending_write,&amp;amp;li);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; item_id = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        c-&amp;gt;flags &amp;amp;= ~CLIENT_PENDING_WRITE;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;/* Remove clients from the list of pending writes since&lt;br/&gt;         * they are going to be closed ASAP. */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;flags &amp;amp; CLIENT_CLOSE_ASAP) {&lt;br/&gt;            listDelNode(server.clients_pending_write, ln);&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//hash的方式进行分配&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; target_id = item_id % server.io_threads_num;&lt;br/&gt;        listAddNodeTail(io_threads_list[target_id],c);&lt;br/&gt;        item_id++;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//告诉对应的线程该开始干活了&lt;/span&gt;&lt;br/&gt;    io_threads_op = IO_THREADS_OP_WRITE;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; server.io_threads_num; j++) {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = listLength(io_threads_list[j]);&lt;br/&gt;        setIOPendingCount(j, count);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//主线程自己也会处理一些&lt;/span&gt;&lt;br/&gt;    listRewind(io_threads_list[&lt;span&gt;0&lt;/span&gt;],&amp;amp;li);&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        writeToClient(c,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    listEmpty(io_threads_list[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//循环等待其它线程结束处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pending = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; server.io_threads_num; j++)&lt;br/&gt;            pending += getIOPendingCount(j);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pending == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 io 线程中收到消息后，开始遍历自己的任务队列 io_threads_list[id]，并将其中的 client 挨个取出来开始处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;IOThreadMain&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *myid)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;//遍历当前线程等待队列里的请求 client&lt;/span&gt;&lt;br/&gt;        listRewind(io_threads_list[id],&amp;amp;li);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;            client *c = listNodeValue(ln);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_WRITE) {&lt;br/&gt;                writeToClient(c,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_READ) {&lt;br/&gt;                readQueryFromClient(c-&amp;gt;conn);&lt;br/&gt;            } &lt;br/&gt;        }&lt;br/&gt;        listEmpty(io_threads_list[id]);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 写请求处理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这次任务队列里都是写请求，所以 io 线程会进入 writeToClient。而主线程在分配完任务以后，自己开始处理起了 io_threads_list[0]，并也进入到 writeToClient。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;writeToClient&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; fd, client *c, &lt;span&gt;int&lt;/span&gt; handler_installed)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(clientHasPendingReplies(c)) {&lt;br/&gt;        &lt;span&gt;// 先发送固定缓冲区&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;bufpos &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            nwritten = write(fd,c-&amp;gt;buf+c-&amp;gt;sentlen,c-&amp;gt;bufpos-c-&amp;gt;sentlen);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nwritten &amp;lt;= &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            ......&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 再发送回复链表中数据&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            o = listNodeValue(listFirst(c-&amp;gt;reply));&lt;br/&gt;            nwritten = write(fd, o-&amp;gt;buf + c-&amp;gt;sentlen, objlen - c-&amp;gt;sentlen);&lt;br/&gt;            ......&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;writeToClient 中的主要逻辑就是调用 write 系统调用让内核帮其把数据发送出去即可。由于每个命令的处理结果大小是不固定的。所以 Redis 采用的做法用固定的 buf + 可变链表来储存结果字符串。这里自然发送的时候就需要分别对固定缓存区和链表来进行发送了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当所有的写请求也处理完后，beforeSleep 就退出了。主线程将会再次调用 epoll_wait 来发现请求，进入下一轮的用户请求处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、总结&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1.1 主线程初始化&lt;/span&gt;&lt;br/&gt;    initServer();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1.2 启动 io 线程&lt;/span&gt;&lt;br/&gt;    InitServerLast();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 进入事件循环&lt;/span&gt;&lt;br/&gt;    aeMain(server.el);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 initServer 这个函数内，Redis 做了这么三件重要的事情。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建一个 epoll 对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对配置的监听端口进行 listen&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把 listen socket 让 epoll 给管理起来&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 initThreadedIO 中调用 pthread_create 库函数创建线程，并且注册线程回调函数 IOThreadMain。在 IOThreadMain 中等待其队列 io_threads_list[id] 产生请求，当有请求到达的时候取出 client，依次处理。其中读操作通过 readQueryFromClient 处理， 写操作通过 writeToClient 处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主线程在 aeMain 函数中，是一个无休止的循环，它是 Redis 中最重要的部分。它先是调用事件分发器发现事件。如果有新连接请求到达的时候，执行 accept 接收新连接，并为其注册事件处理函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户连接上有命令请求到达的时候，主线程在 read 处理函数中将其添加到读发送队列中。然后接着在 beforeSleep 中开启对读任务队列和写任务队列的处理。总体工作过程如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9093701996927803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYaB7F2T5hicCh9YkbJ5hu7NuF8US7wgrokaWiaC2WiaiaxcIFy6GR62QBTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个处理过程中，对读任务队列和写任务队列的处理都是多线程并行进行的（前提是开篇我们开启了多 IO 线程并且也并发处理读）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当读任务队列和写任务队列的都处理完的时候，主线程再一次调用 epoll_wait 去发现新的待处理事件，如此往复循环进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，多线程版本的 Redis 的工作原理就介绍完了。坦白讲，我觉得这种多线程模型实现的并不足够的好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因是主线程是在处理读、写任务队列的时候还要等待其它的 io 线程处理完才能进入下一步。假设这时有 10 个用户请求到达，其中 9 个处理耗时需要 1 ms，而另外一个命令需要 1 s。则这时主线程仍然会等待这个 io 线程处理 1s 结束后才能进入后面的处理。整个 Redis 服务还是被一个耗时的命令给 block 住了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我倒是希望我的理解哪里有问题。因为这种方式真的是没能很好地并发起来。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>