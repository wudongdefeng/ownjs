<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>78ffde476203b361bebd1fc9f2bc0255</guid>
<title>如何打造一个可以服务地球 80 亿人的高并发系统？</title>
<link>https://toutiao.io/k/tjn3iog</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;本文共 6500 字，阅读大约需要 22 分钟。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;前面两篇文章每一篇都花了我五十个小时以上，写的我是欲仙欲死，本文我们来务点虚，上上价值。&lt;/section&gt;&lt;p&gt;我们将从微服务架构讲起，一步一步追根溯源，找寻“分布式数据库”在另一个维度的投影，探寻基建、应用、服务、组织之间的联系，通过观察自然规律和人类社会，引出本文的中心思想，并对“找出单点，进行拆分”做出最后的升华。&lt;/p&gt;&lt;p&gt;最后，我们将得到一个可行的 100 万 API QPS、500 万数据库 QPS 的系统设计方案，并顺便简单地讨论一下“高可用”背后的哲学悖论。&lt;/p&gt;&lt;h3&gt;如何定义“一个系统”&lt;/h3&gt;&lt;p&gt;前面第七篇文章我们说过：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果两个系统的数据库不在一起，那他们就不是一个系统，就像拼多多有 7.5 亿月活用户，淘宝有 8.5 亿，你不能说“拼宝宝”电商系统有 16 亿月活用户一样。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;如果两个 API 的数据落到同一张表上，那他们两个就属于同一个系统。&lt;/p&gt;&lt;p&gt;那，在一个电商系统内，用户 API 和商品 API 似乎没有多对多交集？是的，这就是微服务架构的拆分逻辑。&lt;/p&gt;&lt;h2&gt;微服务架构&lt;/h2&gt;&lt;p&gt;我们都知道，微服务的拆分方式，反映的是其背后技术团队的组织方式。（你不知道也没关系，你现在知道了(￣▽￣)&quot; ）&lt;/p&gt;&lt;p&gt;那，技术团队的组织方式是什么决定的呢？&lt;/p&gt;&lt;p&gt;是由系统内各部分天然的内聚性决定的：用户相关的业务和商品相关的业务都有很强的内聚性，他们之间不会主动发生关联，但他们会分别和订单发生关联。&lt;/p&gt;&lt;h3&gt;数据库调用推演&lt;/h3&gt;&lt;p&gt;我们用商品下单处理流程来推演一个电商订单的生命周期内对用户、商品、订单三个部分数据库的读写情况。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;搜索：商品数据库-读&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;点进详情：商品数据库-读，用户数据库-读（地址、会员）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;立即购买：商品数据库-读，用户数据库-读，订单数据库-写&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支付：订单数据库-读写，用户数据库-读&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;商家后台查看并处理订单：订单数据库-读写，用户数据库-读，商品数据库-读&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们可以看出，大部分情况下，每一步都只有一个主要的微服务被需要，其它微服务都处于辅助地位：只读，且大部分都是单点读取。这就为我们降低了数据库单点的负载——只要把这三个微服务部署到三个独立的数据库上，就可以通过 API 调用的形式降低单个数据库的极限 QPS。&lt;/p&gt;&lt;h3&gt;微服务背后的哲学&lt;/h3&gt;&lt;p&gt;既然我们不能把拼多多和淘宝的系统称作一个系统，那么，在拼多多和淘宝系统内，肯定还可以基于类似的逻辑继续拆分：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;在大量调用的 API 中，一次携带了数据写入的请求一定只会对单个微服务进行写入，但会对多个微服务进行数据读取&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果某个头部 API 请求会对两个微服务系统进行写入，那说明微服务的划分出了问题，需要调整系统结构划分&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;把几乎不相互写入的数据拆到两个数据库上，这种组织形态在人类社会随处可见：两个国家的人分别在自己国家申请护照，他们有时也可以到对方国家内的本国领事馆申领本国护照；两个村的人各自在本村的井里打水，有时也可以不怕麻烦地去隔壁村的水井里打水；你每天早上都用滴滴打车上班，万一滴滴打不到车你还可以用高德来补救...&lt;/p&gt;&lt;h3&gt;微服务照进现实&lt;/h3&gt;&lt;p&gt;微服务的拆分思想相信大家都理解了，下面我们来解决现实问题。&lt;/p&gt;&lt;p&gt;如果你真的成为了“设计百万 QPS 系统”的架构师，相信我，你第一个想到的，一定是“削峰”。&lt;/p&gt;&lt;h2&gt;削峰&lt;/h2&gt;&lt;p&gt;顾名思义，将突发的流量高峰削平。大促的时候，系统顶不住，其实就是那么一会儿顶不住，只要初期的高热度下去了，系统的整体负载会迅速下降到没那么危险的水平。所以，对付突发流量，削峰是第一要务。&lt;/p&gt;&lt;h3&gt;1. 缓存——饮鸩止渴&lt;/h3&gt;&lt;p&gt;请原谅我用饮鸩止渴这个词形容 95% 的 web 系统的真正性能顶梁柱，实际上缓存的贡献远不止于此。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;缓存以降低数据更新频率为代价，极大地提升了读取 API 的 QPS 极限&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存可以设计成多级，形成一个逻辑上的“存储器山”&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存可以像事务隔离级别一样划分成好几种 性能+数据一致性 级别&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;但是，使用缓存确实是在饮鸩止渴：缓存在带来性能的同时，大幅削弱了数据库提供的“单点性”，为系统失效埋下了一堆地雷。&lt;/p&gt;&lt;p&gt;缓存的毒性无法消除，一旦系统的某些部分失效，这杯毒酒就会发作，但是会不会把自己毒死还要看架构水平和基建能力：你的机房别随便断电，你的服务器别随便宕机，你在喝下缓存毒酒之后，就能活的够长。&lt;/p&gt;&lt;h4&gt;终极缓存方案&lt;/h4&gt;&lt;p&gt;我们上一篇文章讨论的 OceanBase 就采用了一种终极缓存方案：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;内存不是快吗，那我就把所有热数据全部放到内存里&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;那对热数据的修改怎么办？redo log 落盘啊&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;你说数据库重启怎么办？上冗余，一个节点一时半会儿起不来也没问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;整个集群重启呢？都天灾了，集群重启后，停止服务一个小时还是可以接受的吧&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;12306 每天夜里都要维护一个小时，我有理由怀疑，它在将 redo log 落盘¹ :-D&lt;/p&gt;&lt;h3&gt;2. 队列——欢迎来到地球&lt;/h3&gt;&lt;p&gt;缓存可以削读的峰，队列就是拿来削写的峰的。&lt;/p&gt;&lt;p&gt;队列的思想其实早就贯穿在人类社会的每一个角落了：超市结账需要排队，做核酸需要排队，火车站打车需要排队，网上抢购商品也需要排队。排队的本质是将一拥而上购买变成了“异步”购买：你想买东西？先排队，过段时间轮到你了，看看商品有没有卖完，没卖完你就能买到。&lt;/p&gt;&lt;p&gt;排队的思维特别好理解，而现实中防止超售功能也确实是基于排队功能做的。传统数据库的事务隔离属于强迫用户等待，而现在大多使用队列系统来处理排队，排队这件事情才真正异步起来了。&lt;/p&gt;&lt;h3&gt;3. 奇技淫巧&lt;/h3&gt;&lt;p&gt;电商下单在普通压力下，一个队列就能解决问题，但是当你面临每秒几十万单的时候，如何让这些订单真正地下单成功，才是最需要解决的问题，这个数字就是“系统容量”。队列是无法提升系统的绝对容量的，那该怎么办呢？&lt;/p&gt;&lt;p&gt;继续找东西和信息之神交换：过去的时间换现在的时间。&lt;/p&gt;&lt;p&gt;在大促之前，先把订单生成好，然后用户下单时直接写入用户信息：不需要执行“检查库存”这个单点操作了，负载低了很多。&lt;/p&gt;&lt;p&gt;骚，实在是骚。&lt;/p&gt;&lt;h3&gt;现实世界中的削峰&lt;/h3&gt;&lt;p&gt;现实世界中，一个一百万 QPS 的电商系统，真正需要触达到数据的 QPS 其实是没有 500 万那么多的，在削峰的操作下，200 万 QPS 的 PolarDB 集群在 Redis 集群的配合下，是可以顶住 100 万 API QPS 的。史上流量最大的那一年双 11，每秒订单创建最大值仅为 58.3 万笔，这已经是这个地球上的最高记录了。&lt;/p&gt;&lt;p&gt;但是，现实世界中，一切都要讲 ROI（收益成本之比），搞一个顶配的 PolarDB 集群确实可以顶住巅峰时期一百万 API QPS，但是你老板看着账单肯定会肉痛，那，该如何省钱呢？&lt;/p&gt;&lt;p&gt;答：&lt;code&gt;站在地球表面&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;站在地球表面&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.749375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA1dcaBesl7vS0TqUkqWugicTMXGC0ib5wrgg7xks0LESCvPF1VSocXjIwe53KLekiagr6ZjQ6tFBFYibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;center&gt;一望无际的华北平原&lt;/center&gt;&lt;p&gt;北京位于美丽的华北平原北端，生活着两千多万人，在巅峰的 2020 年双 11，天猫平台北京地区销售额为 216 亿，全国总额为 4982 亿，占比为 4.33%，略高于北京占全国 3.44% 的 GDP 比例。那我们就可以计算得出，北京的两千多万人，给天猫贡献了&lt;code&gt;583000 * 0.0433 = 25243.9&lt;/code&gt;笔/秒的并发。&lt;/p&gt;&lt;p&gt;虽然全国订单数看起来十分惊人，但是北京这一个地方的压力却只有 2.5 万单每秒，这个哪怕不用奇技淫巧硬抗，十万数据库 QPS 只用主从架构可能都能抗住。但是，系统能基于地理位置划分吗？系统不是必须全国一盘棋吗？不是的，可以划分。&lt;/p&gt;&lt;p&gt;下面我们讨论一下怎么划分。&lt;/p&gt;&lt;h3&gt;基于地理位置对应用和数据库分区&lt;/h3&gt;&lt;p&gt;为什么非要全国的用户访问同一个数据库呢？我们可以利用微服务思想对业务系统和数据进行拆分：北京的用户和上海的用户，理论上讲可以只访问“本地天猫”。&lt;/p&gt;&lt;p&gt;接下来我们分析一下，在一个标准的电商业务中，哪些地方会让一个北京的用户和一个上海的用户发生联系。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;用户表自增 ID&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;商品库存检查&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;商家订单聚合&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;离线数据分析&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;实际上，地理上被隔开的两个人，在系统内还真没什么机会需要相互查询对方的数据，这就是我们能基于地理位置对应用和数据库进行分区的逻辑原因。下面我们一一拆除上面的单点：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;可以预分配 ID 段，也可以用算法保证，例如一奇一偶&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;预分配库存，再异步刷新缓存：这个部分能玩出花，甚至有在客户端上提前下发抢购结果的骚操作，大家可以自己探索&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;简单地从两个地方各拉一次即可&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更不用说了，都离线了，本身也是要做很多数据同步和聚合的，不差这一点&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;基于地理位置对应用和数据库进行划分，产生出两个“本地天猫”后，就需要我们老朋友 DNS 出来表演了。&lt;/p&gt;&lt;h3&gt;进击的 DNS&lt;/h3&gt;&lt;p&gt;域名当初可能是为了方便记忆而发明的，但是域名背后的 DNS 服务却几乎是最重要的互联网高并发基础设施：不同地区的人，对同一个域名进行访问，可以获得两个公网 ip，这样“本地天猫”就实现了。&lt;/p&gt;&lt;h4&gt;类 DNS 哲学思想：Consul 和 Kong&lt;/h4&gt;&lt;p&gt;DNS 几乎完全放弃了一致性，但却实现了极高的可用性和分区容错性。其实，gossip 协议也是这个思想：让消息像病毒一样传播，能够实现最终一致性就行了，要啥自行车。&lt;/p&gt;&lt;p&gt;异曲同工的 Kong 集群思想也让我震惊：所有节点每 5 秒从数据库读取最新的配置文件，然后，这些节点就成了一个行为完全一致的集群啦。“想那么多干什么，短时间内多个节点的行为不一致，就让他们不一致好了，5 秒之后不就一致了。”&lt;/p&gt;&lt;h3&gt;高性能计算第一原则：数据离 CPU 越近，性能越高，容量越小&lt;/h3&gt;&lt;p&gt;在我们熟悉的存储器山中，这是一个大家都理解的基本特性，而这个特性引申到分布式系统中，就是：一定不能让应用和数据库分离。&lt;/p&gt;&lt;p&gt;和 InnoDB 一样，很多时候其实是“局部性”这个我们宇宙的基本属性在帮助我们提升系统的性能，让应用和数据库分布在同一个地域，也是在利用局部性获得性能增益。&lt;/p&gt;&lt;p&gt;所以，让应用去隔壁区域的数据库读数据是要极力避免的——我们应该用 API 网关直接把请求发给隔壁区域的应用服务器，这显然是在今天这个异地网络传输速度接近光速的时代最佳的选择。&lt;/p&gt;&lt;h3&gt;跟 Clickhouse 学习如何打造高并发系统&lt;/h3&gt;&lt;p&gt;Clickhouse 在亿级数据量面前丝毫不怵：MySQL、MongoDB、Hadoop，谁也没有老子快。为什么 Clickhouse 这么快呢？&lt;/p&gt;&lt;h4&gt;列存储还压缩&lt;/h4&gt;&lt;p&gt;首先，它将数据以列为单位组织起来，压缩后存入磁盘上一个又一个的 block，这些 block 就像 InnoDB 的 16KB 页一样，只是它更大（64KB~1MB）。这样，当我们 select 某个 column 的时候，Clickhouse 就能顺序读出磁盘上这个 column 下面所有行的数据。&lt;/p&gt;&lt;h4&gt;Clickhouse 对多 CPU 的利用能力非常惊人&lt;/h4&gt;&lt;p&gt;除了列存储之外，每个 block 内，Clickhouse 还用“稀疏索引”的方式，将每一列的数据划分为了多个 granularity(颗粒度)，然后给每个 granularity 分配一个 CPU 核心进行并行计算，并且它还利用 SSE4.2 指令集，利用 CPU 的 SIMD(Single Instruction Multiple Data) 指令，在 CPU 寄存器层面进行并行操作。&lt;/p&gt;&lt;h4&gt;放弃内存缓存&lt;/h4&gt;&lt;p&gt;这是 Clickhouse 整个架构中我最喜欢的部分。我们通过上一篇文章可以看出，所有的分布式数据库，其本质都是在搞“内存缓存的数据同步”，Clickhouse 直接掀桌子：老子不要内存缓存了。由于所有数据都在磁盘上，而节点的 CPU 又直接和磁盘数据打交道，所以 Clickhouse 实现了真正的并行：增加 CPU 核心数就能提升系统容量，无论在不在同一台机器上都行，反正 CPU 相互之前完全不需要通信。这样，Clickhouse 通过堆核心数就能够实现系统容量的“近线性扩展”。&lt;/p&gt;&lt;h4&gt;太暴力了，我喜欢。&lt;/h4&gt;&lt;p&gt;我们可以学习这种思想，打造一个可以线性扩展的系统架构：只要不同地区的本地系统之间完全没有“数据实时同步”需求，那其实他们就是两个系统，就可以实现性能的线性扩展。&lt;/p&gt;&lt;h3&gt;理论无限容量&lt;/h3&gt;&lt;p&gt;我们说过，关系型数据库的关系，指的就是两行数据之间的关系。现实世界中，位于异地甚至是异国的两个人之间，几乎是不会发生实时相互数据读取的。&lt;/p&gt;&lt;p&gt;站在地球表面来思考，你会发现人类社会和自然规律都是契合高并发“找出单点，进行拆分”哲学原理的：每一个人类居所，本质上都是散落在整个地球上的一个又一个点。因为这些点的存在，我们发明了国省市县乡村逐级政府，同级政府之间几乎没有相互通信。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;将一个大系统拆成不需要实时相互通信的多个小系统，可以获得线性的性能提升。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;当你的系统顶不住的时候，按照这个原理来拆就行了，绝对顶得住。别说区区一百万 QPS 了，服务全人类也做得到。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA1dcaBesl7vS0TqUkqWugicTFbscbgk3rll3FTS6Lr3Z9bOnTghEljkUNotmmQFg3ia798bcXIZAFqQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;价值上完了，我们最后再讨论五毛钱的高可用。&lt;/p&gt;&lt;h2&gt;番外篇：高可用&lt;/h2&gt;&lt;p&gt;我相信，很多人都像我一样做过思想实验，希望设计一个“完全高可用”的系统，但是最终可能都败下阵来，为什么？因为高可用和其它常见的分布式系统需求是互斥的。&lt;/p&gt;&lt;p&gt;数据重要如银行，也只是要求在天灾面前要尽量不丢数据、少丢数据，凭什么你就要求自己的系统永远可用呢？其实，想从架构层面实现高可用是非常困难的，终极高可用就是将数据完整地复制到世界各地的所有节点上，并用超长的时间来达到完全一致，这是什么，这是区块链呀。&lt;/p&gt;&lt;p&gt;高可用和性能、一致性都是冲突的，只能采用策略尽量压制问题。&lt;/p&gt;&lt;h3&gt;熔断&lt;/h3&gt;&lt;p&gt;这个词在技术圈的流行应该有微博一半功劳，压力一大就熔断：主动停止不重要的服务，断尾自救，争取让核心业务不挂。&lt;/p&gt;&lt;h3&gt;限流&lt;/h3&gt;&lt;p&gt;限制一部分地区、一部分用户的访问，以保护整个集群不崩，一般用于限制单个用户对系统造成的压力过大，对面很可能是机器人。&lt;/p&gt;&lt;h3&gt;Facebook 2021年 10 月 4 号宕机²&lt;/h3&gt;&lt;p&gt;Facebook 的用户不可谓不多，对高可用的投入不可谓不足，为什么还是会整个公司完全宕机 7 小时呢？&lt;/p&gt;&lt;p&gt;事故的起因是一个错误的命令意外断开了 Facebook 的 DNS 服务，结果问题大了：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;所有客户端 API 失效，用户无法获得任何信息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据中心 VPN 服务失效，无法远程登录到数据中心内的设备上&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;亲自去机房，发现门禁卡刷不开门，破拆后才接触到物理设备，插上显示器和键盘才能解决问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;邮件、Google 文档、Zoom 都登不上&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;办公大楼的门禁卡系统也失效了，无法刷开会议室的门，甚至无法离开办公楼&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;结合阿里云香港一个数据中心因为空调故障导致整个数据中心宕机超过 24 小时³，认命吧，商业机构做不了真正的高可用的：资源使用率就是钱呐。&lt;/p&gt;&lt;h2&gt;系列收尾&lt;/h2&gt;&lt;p&gt;本系列文章一共十篇，超过八万字，对我自己来说也是一次很有价值的总结，不知道各位读者感觉如何呢？欢迎到下列位置留下你的评论：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Github：https://github.com/johnlui/tech-epic/issues/1&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;微博：https://weibo.com/balishengmuyuan&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;博客：https://lvwenhan.com/tech-epic/508.html&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;参考资料&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;《12306互联网售票系统的架构优化及演进》 http://tljsjyy.xml-journal.net/article/id/3756&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2021 年 Facebook 宕机事件 https://zh.wikipedia.org/wiki/2021%E5%B9%B4Facebook%E7%95%B6%E6%A9%9F%E4%BA%8B%E4%BB%B6&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关于阿里云香港Region可用区C服务中断事件的说明 https://help.aliyun.com/noticelist/articleid/1061819219.html&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;【全书完】&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>18305e10f4eaa1341363f4ac077472a8</guid>
<title>前端工程师扭伤了，也不忘背单词</title>
<link>https://toutiao.io/k/ah8yqn9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;看完文章，希望我的脚没有白扭，你能多记几个单词。&lt;/p&gt;&lt;p&gt;时隔上次滑板扭伤一年后，周末又扭到了脚了，英文的叫法是 &lt;code&gt;ankle twisted&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ankle&lt;/code&gt; （音：安可儿） 脚脖子，脚踝，&lt;code&gt;twisted&lt;/code&gt;（音：推丝贴的） 扭。直译得一塌糊涂。&lt;/p&gt;&lt;p&gt;那作为前端工程师怎么能通过这次脚扭了多记几个单词呢？&lt;/p&gt;&lt;h2&gt;Ankle&lt;/h2&gt;&lt;p&gt;首先是 &lt;code&gt;ankle&lt;/code&gt;，它的词源是 &lt;code&gt;angle&lt;/code&gt; 角，角度。看看自己的脚踝，是不是就像一个角啊。还有当初鼎鼎有名的前端框架 &lt;code&gt;Angular&lt;/code&gt; 也是一个角。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs6s0DhQ6tlml8jq07cxN78D0LOeiboCywicoDjZCInUcsKe1S6ElyFldpibXxhXxwcJibd2uOFiaZfCHXQ/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;294&quot; data-cropy1=&quot;29&quot; data-cropy2=&quot;141&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3843537414965986&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dlEwIVcKGs6s0DhQ6tlml8jq07cxN78DnVkv3xgLAKRvPCL7fT627I3qWDo9IYZ6pzHXCjjvZ6pawml3vYfmyA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;294&quot;/&gt;&lt;/p&gt;&lt;p&gt;它们都像一个角，那如果两个角呢？这个我们叫什么啊？对！锚。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6655518394648829&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dlEwIVcKGs6s0DhQ6tlml8jq07cxN78Dq6jX2evF6mVnYsWKLibkhbZmC7nuX8FXwkwK8gibpIhTicjcva5eVFRgg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;598&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;anchor&lt;/code&gt; 锚，（音：安可）这个单词和前端可大有关系， &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 标签就是 &lt;code&gt;anchor&lt;/code&gt; 的简写。所以以后写一个 a 标签记得想想 pshu 肿得圆圆的脚踝。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs6s0DhQ6tlml8jq07cxN78Dny4tRxOGYxhd0kbsPuIRIyvzcYyibHWjfLKiaFTEYEjicaEyxgsnicHkug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;h2&gt;Twisted&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Twisted&lt;/code&gt; 动词原形是 &lt;code&gt;twist&lt;/code&gt;（音：推丝特），扭。但是它还一种翻译是 &lt;strong&gt;“拧”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;比如把两股绳拧在一起就是一根双捻的绳子。如果绳子大家不熟悉，大家看看这个，就知道了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.54&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs6s0DhQ6tlml8jq07cxN78DsvxXurX1woDLKthsQSH3B60LeoPIVSTgzE0wkwLmpCrVONJVau5KsQ/640?wx_fmt=png&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个叫双绞线的东西就是两根铜丝绞在一起，捻在一起。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6654545454545454&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs6s0DhQ6tlml8jq07cxN78Dh0Hf79LlSdFb0HIqf3lgcR9W95jSI8hjqvZdT2MAaniapwUHQ0w9NFQ/640?wx_fmt=png&quot; data-type=&quot;jpeg&quot; data-w=&quot;275&quot;/&gt;&lt;/p&gt;&lt;p&gt;不过“捻”这个叫法用的更多地方是纺织行业。纺织业的原材料纱线，和前端包管理工具 &lt;span&gt;yarn&lt;/span&gt; 是同一个单词。(这一段是写给 p嫂的，她从事在纺织行业的工作，我惊讶地发现她做 yarn 的生意，而我有段时间在使用 yarn 这个命令，缘分啊！)&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs6s0DhQ6tlml8jq07cxN78DHibZFbrY8KP8WSicicZYetCg1ozHsHCKdWwLMiacvMjibZ0rD2KuL3SdkibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;h2&gt;再扩展下&lt;/h2&gt;&lt;p&gt;说回扭脚踝，扭到的其实是脚踝里面的“韧带”，&lt;code&gt;ligament&lt;/code&gt;（音：立个门特）。之前的文章也提到英文单词的字母也有&lt;strong&gt;象形&lt;/strong&gt;的造词法在里面，这个 &lt;code&gt;L&lt;/code&gt; 是和线，条，带相关的（line，ladder，light，lace，leg 等等）。那这个 &lt;code&gt;ligament&lt;/code&gt; 韧带也是“带”，后面的 ment 是一个后缀表示名词。而 &lt;code&gt;liga&lt;/code&gt; 这个单词简单的形变下就变成我们前端常用的 &lt;code&gt;Link&lt;/code&gt; 组件或者 &lt;code&gt;link&lt;/code&gt; 标签。下次写 &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; 组件的时候记得想想我两次扭伤的韧带。：P&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5225&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs6s0DhQ6tlml8jq07cxN78D9kHaproDVwgwTUr2ZobC3GHFcujHNc379xXtBQibK9Libib5ict4LQodZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;好了最后再扩展一个，扭伤的韧带是连接人骨头的组织，连接骨头的除了韧带当有肌肉，muscle （音：嘛嗖），韧带和肌肉这类东西都统称为 &lt;code&gt;connective tissue&lt;/code&gt;，结缔组织。后缀 -tive 是形容词词性后缀，&lt;code&gt;tissue&lt;/code&gt; 这个单在生物学词汇中是&lt;span&gt;组织&lt;/span&gt;。&lt;code&gt;tissue&lt;/code&gt; 大家不熟悉，但是在 Github 的 &lt;code&gt;issue&lt;/code&gt; 熟悉，以后你们看到 &lt;code&gt;issue&lt;/code&gt; 就记得我现在这个痛（T）的 &lt;code&gt;tissue&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-templateid=&quot;list&quot; data-traceid=&quot;f1d8b955-ed0a-4d2f-949e-afcca8954f7a&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;100_26976641801&quot; data-appuin=&quot;3574415453&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:5,&amp;quot;pid&amp;quot;:&amp;quot;100_26976641801&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3574415453&amp;quot;,&amp;quot;trace_id&amp;quot;:&amp;quot;f1d8b955-ed0a-4d2f-949e-afcca8954f7a&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;100_26976641801&amp;quot;,&amp;quot;source_id&amp;quot;:3,&amp;quot;source_name&amp;quot;:&amp;quot;拼多多&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://pcm-img.zhls.qq.com/productcenter-1f779418--1018825-2652340823978442714/81110541710082022/f24d708c39d62bd887dced4d0989a8b0.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;维达棉韧纸巾6/24包餐巾纸面巾纸卫生纸家庭装家用实惠维达抽纸&amp;quot;,&amp;quot;current_price&amp;quot;:1450,&amp;quot;first_category_id&amp;quot;:&amp;quot;5&amp;quot;,&amp;quot;discount&amp;quot;:&amp;quot;600&amp;quot;,&amp;quot;product_label_name_list&amp;quot;:[&amp;quot;包邮&amp;quot;],&amp;quot;select_tag_name_list&amp;quot;:[],&amp;quot;templateId&amp;quot;:&amp;quot;list&amp;quot;,&amp;quot;appuin&amp;quot;:&amp;quot;3574415453&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个彩蛋：&lt;/span&gt;&lt;span&gt;tissue 用多伤 tissue&lt;/span&gt;&lt;/p&gt;&lt;p&gt;好了，去年滑板脚扭伤的时候就想写一篇类似的文章，一直拖延到再一次扭伤；看来是老天爷来催更了。赶紧写完了。&lt;/p&gt;&lt;p&gt;-完-&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c79950ed653a3e8aa170a75d2c3f272c</guid>
<title>PHP 源码加密与解密方式比较</title>
<link>https://toutiao.io/k/uuy3q1r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;努力成为一个初级程序员！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;早期文章&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        代码的保护一直是软件公司所担心的问题，因为很多源码对于公司来说就是命脉，而有些公司则弱化了代码的保护，转而将更多的精力花在服务上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        最近研究了一两天 PHP 代码的加解密问题，因为 PHP 编写的程序是直接通过源码发布的，并没有编译生成二进制文件或者是字节码文件（虽然二进制和字节码一样可以通过其他方式得到，但至少不是源码那么直接）。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        PHP 代码的保护大概分为三种吧，至少我是这么了解的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        第一种是三种里面最简单的一种，基本就是混淆变换之类的。混淆的方式就是将代码就是变量名、方法名进行粉碎，将代码进行变换（也可以称之为加密，我为什么称它为变换呢，因为它并不一定是只用加密，也可能只是进行了其他的编码），再加一些花指令（花指令就是让人眼花的指令，加一些无关紧要的代码进行），指令乱序（正常逻辑顺序的代码语句打乱后，用 goto 重新连接使之执行时依然正确）。上面的一些词不一定准确，基本能表达清楚就行。这种方式我认为兼容性比较好，因为都是在 PHP 代码层面进行；问题是，还原的代码也在 PHP 代码文件中，虽然还原代码也进行了混淆变换之类，但是毕竟还是有下手的地方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        关于上面这种加密的解密方式，这里有两篇以前的文章，可供参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        第二种是使用 PHP 扩展进行代码的混淆变换等，这种方式对代码的处理和第一种的方式基本一样，只不过代码的加解密放在 PHP 扩展层面了。&lt;/span&gt;&lt;span&gt;这种方式已经算是比较底层了。&lt;/span&gt;&lt;span&gt;因为处理方式已经不在 PHP 代码的层面了，也就是在执行代码时对代码进行还原，也是 PHP 的扩展完成的。&lt;/span&gt;&lt;span&gt;因为 PHP 扩展大部分是使用 C 语言来编写的（貌似有其他语言可以写，据说好像还有类似 PHP 的语言还是框架可以写 PHP 扩展，记不清楚了），而且发布使用的是二进制文件，比如是 .so 文件，或者是 .dll 文件。&lt;/span&gt;&lt;span&gt;这样就已经有门槛了。&lt;/span&gt;&lt;span&gt;毕竟二进制文件是无法直接通过文本文件能看懂的（还是有人能看懂的，只是少）。&lt;/span&gt;&lt;span&gt;这种方法我认为是最好的，这种方法比较折中，安全这种东西本身没有绝对的，也只有在性价比方面最合适的吧。&lt;/span&gt;&lt;span&gt;因为，它在代码层面无法直接查看（用文本编辑器打开没法看），再者对于 PHP 而言它只是一个扩展一个插件。&lt;/span&gt;&lt;span&gt;但是缺点是，貌似需要版本兼容，也就是这个扩展需要跟指定的 PHP 版本或者一个版本范围要兼容，但是也不完全算是缺点，毕竟能满足主流的版本就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;span&gt;关于上面这种&lt;/span&gt;&lt;span&gt;加密&lt;/span&gt;&lt;span&gt;的解密方式，在网上也有相关的文章，这里就不给出了，自己搜索吧。解密的基本思路是，分析加密后代码的文件结构，确定加密体、加密体长度、加密算法、加密密钥，从而进行解密。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        第三种是 PHP 引擎级别的，这种级别对于 PHP 而言应该是最底层的了。在底层实现一套自己的解释引擎，然后将 PHP 源码生成为自己实现的解释引擎可以识别的字节码从而到达加密的效果。这种加密效果较上面两种效果是最好的，但是实现难度也是最大的。对于版本的要求也是更严格的；对于技术要求也是最难的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        以上三种加密方式的破解难度是递增的，实现难度也是递增的。个人感觉上拿到加密后的文件和运行环境是应该可以破解的，毕竟最终都是要实际运行的。但是具体肯定视水平而定。毕竟加解密是加密者和解密者水平的一个较量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        最后再补充一下，据说有的程序员在写 PHP 程序员时，部分代码专门用 C 写，然后用 PHP 调用，精力足够，貌似也不错。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0712962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthBDooApBDUM9yqM6BWHMOaJyrXzMxqibI7B90xNgZswWSVSatF56vMAicAA56UmJkc2rQlDUARycYQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【mongo】 下载 SpringBoot 整合操作 MongoDB 的文档。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【&lt;/strong&gt;&lt;strong&gt;cisp知识整理&lt;/strong&gt;&lt;strong&gt;】 下载 CISP 读书笔记。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复【java开发手册】获取《Java开发手册》黄山版。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;努力成为一个初级程序员！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JHWsQdz8yVn3MVh22hia7NFoPyNJz4ZI7XUnMa9xM50TJRqPkWf7BRibQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>43f0249cbe0a0d47538cdb8f5822c32b</guid>
<title>C语言不支持重载，多种 main() 如何实现的呢？</title>
<link>https://toutiao.io/k/pf2nu0p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0MzI4OTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHhKgtwWvzaYZodgfpphdA6WWKEMXTn6ImCCCuEzlPKicNBcpzBUyjK1XicWwqIwusqLGpwyyOc87JPQ/0?wx_fmt=png&quot; data-nickname=&quot;高性能架构探索&quot; data-alias=&quot;gxnjgts&quot; data-signature=&quot;专注于分享干货，硬货，欢迎关注😄&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;你好，我是雨乐！&lt;span/&gt;&lt;/p&gt;&lt;p&gt;前几天群里二哥问了个问题，如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.28217821782178215&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHgZ5sbbcHzj6VuphZnS20IdFCoVTBpZCybg4PjI2adddD90f1TOc5f93gtyr48q9RDeKRECBAJJZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;808&quot;/&gt;&lt;/p&gt;&lt;p&gt;大家都知道，我是做上层应用的，对底层不是很了解，更别说那帮人在讨论内核的时候，根本插不上话。更多的时候，还是默默记笔记，紧跟大佬们的步伐😁。&lt;/p&gt;&lt;p&gt;于是，为了调研这个问题，也查了相关资料。今天借助本文，来分析下C语言中main()的实现，顺便解答下群里的这个问题。&lt;/p&gt;&lt;h2&gt;定义&lt;/h2&gt;&lt;p&gt;作为C/C++开发人员，都知道main()函数是一个可执行程序的入口函数，大都会像如下这样写:&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {}&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *argv[]) {}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，作为一个开发老油条，也仅仅知道是这样做的，当看到二哥提出这个问题的时候，第一反应是&lt;code&gt;重载&lt;/code&gt;，但是大家都知道C语言是不支持重载的，那么有没有可能使用的是默认参数呢？如下这种：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; argc = &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;char&lt;/span&gt; **argv = &lt;span&gt;NULL&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了，为了验证我的疑问，咱们着手开始进行分析。&lt;/p&gt;&lt;p&gt;ps:在&lt;span&gt;cppreference&lt;/span&gt;上对于main()的声明有第三个参数即char *envp[],该参数是环境变量相关，因为我们使用更多的是不涉及此参数的方式，所以该参数不在本文的讨论范围内。&lt;/p&gt;&lt;h2&gt;断点调试&lt;/h2&gt;&lt;p&gt;为了能够更清晰的理解main()函数的执行过程，写了一个简单的代码，通过gdb查看堆栈信息，代码如下：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译之后，我们通过gdb进行调试，在main()函数处设置断点，然后看堆栈信息，如下：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;(gdb) bt&lt;br/&gt;#&lt;span&gt;0&lt;/span&gt;  main () at main.c:&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;(gdb)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上述gdb信息，我们看出main()位于栈顶，显然，我们的目的是分析main()的调用堆栈信息，而这种main()在栈顶的方式显然不足以解答我的疑问。&lt;/p&gt;&lt;p&gt;于是，查阅了相关资料后，发现可以通过其它方式打印出更详细的堆栈信息。&lt;/p&gt;&lt;p&gt;编译命令如下：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;gcc -gdwarf-5 main.c  -o main&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后gdb的相关命令(具体的命令可以网上查阅，此处不做过多分析):&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;gdb ./main -q&lt;br/&gt;Reading symbols from /mtad/main...done.&lt;br/&gt;(gdb) set backtrace past-entry&lt;br/&gt;(gdb) set backtrace past-main&lt;br/&gt;(gdb) show backtrace past-entry&lt;br/&gt;Whether backtraces should continue past the entry point of a program is on.&lt;br/&gt;(gdb) show backtrace past-main&lt;br/&gt;Whether backtraces should continue past &quot;main&quot; is on.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在main()处设置断点，运行，查看堆栈信息，如下：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;(gdb) bt&lt;br/&gt;#&lt;span&gt;0&lt;/span&gt;  main () at main.c:&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;#&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0x00007ffff7a2f555&lt;/span&gt; in __libc_start_main () from /lib64/libc.so&lt;span&gt;.6&lt;/span&gt;&lt;br/&gt;#&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;0x0000000000400429&lt;/span&gt; in _start ()&lt;br/&gt;(gdb)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过如上堆栈信息，我们看到_start()--&amp;gt;__libc_start_main()--&amp;gt;main()，看来应该在这俩函数中，开始分析~~&lt;/p&gt;&lt;h2&gt;_start()&lt;/h2&gt;&lt;p&gt;为了查看_start()的详细信息，继续在_start()函数处打上断点，然后分析查看：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;(gdb) r&lt;br/&gt;Starting program: xxx&lt;br/&gt;Missing separate debuginfos, use: debuginfo-install glibc&lt;span&gt;-2.17&lt;/span&gt;&lt;span&gt;-317.&lt;/span&gt;el7.x86_64&lt;br/&gt;&lt;br/&gt;Breakpoint &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0x0000000000400400&lt;/span&gt; in _start ()&lt;br/&gt;(gdb) s&lt;br/&gt;Single stepping until &lt;span&gt;exit&lt;/span&gt; from function _start,&lt;br/&gt;which has no line number information.&lt;br/&gt;&lt;span&gt;0x00007ffff7a2f460&lt;/span&gt; in __libc_start_main () from /lib64/libc.so&lt;span&gt;.6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过如上分析，没有看到_start()函数的可执行代码，于是通过网上搜索，发现_start()是用汇编编写，于是下载了glibc2.5源码，在路径处sysdeps/i386/elf/start.S&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;#include &quot;bp-sym.h&quot;&lt;br/&gt;&lt;br/&gt;    .text&lt;br/&gt;    .globl _start&lt;br/&gt;    .type _start,@function&lt;br/&gt;_start:&lt;br/&gt;    /* Clear the frame pointer.  The ABI suggests this be done, to mark&lt;br/&gt;       the outermost frame obviously.  */&lt;br/&gt;    xorl %ebp, %ebp&lt;br/&gt;&lt;br/&gt;    /* Extract the arguments as encoded on the stack and set up&lt;br/&gt;       the arguments for `main&#x27;: argc, argv.  envp will be determined&lt;br/&gt;       later in __libc_start_main.  */&lt;br/&gt;    popl %esi  /* Pop the argument count.  */&lt;br/&gt;    movl %esp, %ecx  /* argv starts just at the current stack top.*/&lt;br/&gt;&lt;br/&gt;    /* Before pushing the arguments align the stack to a 16-byte&lt;br/&gt;    (SSE needs 16-byte alignment) boundary to avoid penalties from&lt;br/&gt;    misaligned accesses.  Thanks to Edward Seidl &amp;lt;seidl@janed.com&amp;gt;&lt;br/&gt;    for pointing this out.  */&lt;br/&gt;    andl $0xfffffff0, %esp&lt;br/&gt;    pushl %eax  /* Push garbage because we allocate&lt;br/&gt;                   28 more bytes.  */&lt;br/&gt;&lt;br/&gt;    /* Provide the highest stack address to the user code (for stacks&lt;br/&gt;       which grow downwards).  */&lt;br/&gt;    pushl %esp&lt;br/&gt;&lt;br/&gt;    pushl %edx  /* Push address of the shared library&lt;br/&gt;                   termination function.  */&lt;br/&gt;&lt;br/&gt;#ifdef SHARED&lt;br/&gt;    /* Load PIC register.  */&lt;br/&gt;    call 1f&lt;br/&gt;    addl $_GLOBAL_OFFSET_TABLE_, %ebx&lt;br/&gt;&lt;br/&gt;    /* Push address of our own entry points to .fini and .init.  */&lt;br/&gt;    leal __libc_csu_fini@GOTOFF(%ebx), %eax&lt;br/&gt;    pushl %eax&lt;br/&gt;    leal __libc_csu_init@GOTOFF(%ebx), %eax&lt;br/&gt;    pushl %eax&lt;br/&gt;&lt;br/&gt;    pushl %ecx  /* Push second argument: argv.  */&lt;br/&gt;    pushl %esi  /* Push first argument: argc.  */&lt;br/&gt;&lt;br/&gt;    pushl BP_SYM (main)@GOT(%ebx)&lt;br/&gt;&lt;br/&gt;    /* Call the user&#x27;s main function, and exit with its value.&lt;br/&gt;       But let the libc call main.    */&lt;br/&gt;    call BP_SYM (__libc_start_main)@PLT&lt;br/&gt;#else&lt;br/&gt;    /* Push address of our own entry points to .fini and .init.  */&lt;br/&gt;    pushl $__libc_csu_fini&lt;br/&gt;    pushl $__libc_csu_init&lt;br/&gt;&lt;br/&gt;    pushl %ecx  /* Push second argument: argv.  */&lt;br/&gt;    pushl %esi  /* Push first argument: argc.  */&lt;br/&gt;&lt;br/&gt;    pushl $BP_SYM (main)&lt;br/&gt;&lt;br/&gt;    /* Call the user&#x27;s main function, and exit with its value.&lt;br/&gt;       But let the libc call main.    */&lt;br/&gt;    call BP_SYM (__libc_start_main)&lt;br/&gt;#endif&lt;br/&gt;&lt;br/&gt;    hlt   /* Crash if somehow `exit&#x27; does return.  */&lt;br/&gt;&lt;br/&gt;#ifdef SHARED&lt;br/&gt;1: movl (%esp), %ebx&lt;br/&gt;    ret&lt;br/&gt;#endif&lt;br/&gt;&lt;br/&gt;/* To fulfill the System V/i386 ABI we need this symbol.  Yuck, it&#x27;s so&lt;br/&gt;   meaningless since we don&#x27;t support machines &amp;lt; 80386.  */&lt;br/&gt;    .section .rodata&lt;br/&gt;    .globl _fp_hw&lt;br/&gt;_fp_hw: .long 3&lt;br/&gt;    .size _fp_hw, 4&lt;br/&gt;    .type _fp_hw,@object&lt;br/&gt;&lt;br/&gt;/* Define a symbol for the first piece of initialized data.  */&lt;br/&gt;    .data&lt;br/&gt;    .globl __data_start&lt;br/&gt;__data_start:&lt;br/&gt;    .long 0&lt;br/&gt;    .weak data_start&lt;br/&gt;    data_start = __data_start&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述实现也是比较简单的：&lt;/p&gt;&lt;p&gt;xorl %ebp, %ebp：将ebp寄存器清零。&lt;/p&gt;&lt;p&gt;popl %esi、movl %esp, %ecx：装载器把用户的参数和环境变量压栈，实际上按照压栈的方法，栈顶的元素就是argc，接着其下就是argv和环境变量的数组。这两句相当于int argc = pop from stack; char **argv = top of stack。&lt;/p&gt;&lt;p&gt;call BP_SYM (__libc_start_main)：相当于调用__libc_start_main，调用的时候传入参数，包括argc、argv。&lt;/p&gt;&lt;p&gt;上述逻辑功能，伪代码实现如下：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt; _start() {&lt;br/&gt;  %ebp = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; argc = pop from stack&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; ** argv = top of stack;&lt;br/&gt;  __libc_start_main(main, argc, argv, __libc_csu_init, __linc_csu_fini,&lt;br/&gt;  edx, top of stack);&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;__libc_start_main&lt;/h2&gt;&lt;p&gt;在上一节中，我们了解到，_start()才是整个可执行程序的入口函数，在_start()函数中调用__libc_start_main()函数，该函数声明如下：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;STATIC &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LIBC_START_MAIN&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; (*main) (&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;char&lt;/span&gt; **, &lt;span&gt;char&lt;/span&gt; ** MAIN_AUXVEC_DECL),&lt;br/&gt;                 &lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *__unbounded *__unbounded ubp_av,&lt;br/&gt;#ifdef LIBC_START_MAIN_AUXVEC_ARG&lt;br/&gt;                 ElfW(&lt;span&gt;auxv_t&lt;/span&gt;) *__unbounded auxvec,&lt;br/&gt;#endif&lt;br/&gt;                 __typeof (main) init,&lt;br/&gt;                 &lt;span&gt;void&lt;/span&gt; (*fini) (&lt;span&gt;void&lt;/span&gt;),&lt;br/&gt;                 &lt;span&gt;void&lt;/span&gt; (*rtld_fini) (&lt;span&gt;void&lt;/span&gt;), &lt;span&gt;void&lt;/span&gt; *__unbounded stack_end)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;#&lt;span&gt;if&lt;/span&gt; __BOUNDED_POINTERS__&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; **argv;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# &lt;span&gt;define&lt;/span&gt; argv ubp_av&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/* Result of the &#x27;main&#x27; function.  */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; result;&lt;br/&gt;&lt;br/&gt;  __libc_multiple_libcs = &amp;amp;_dl_starting_up &amp;amp;&amp;amp; !_dl_starting_up;&lt;br/&gt;&lt;br/&gt;...&lt;br/&gt;...&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (init)&lt;br/&gt;    (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;exit&lt;/span&gt; (result);&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出，在该函数中，最终调用了main()函数，并传入了相关命令行。（result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);）&lt;/p&gt;&lt;p&gt;截止到此，我们了解了整个main()函数的调用过程，但是，仍然没有回答二哥的问题，main()是如何实现&lt;strong&gt;有参和无参&lt;/strong&gt;两种方式的，其实说白了，&lt;strong&gt;在标准中，main()只有一种声明方式，即有参方式。无论是否有命令行参数，都调用该函数。如果有参数，则通过压栈出栈(对于x86 32位)或者寄存器(x86 64位)的方式获取参数，然后传入main()，如果命令行为空，则对应的字段为空（即没有从栈上取得对应的数据）&lt;/strong&gt;。&lt;/p&gt;&lt;h2&gt;结语&lt;/h2&gt;&lt;p&gt;二哥一句简简单单的问题，断断续续研究了将近一个月。可能此问题对于从事嵌入式或者内核研究的同学来说非常简单。我是偏向于上层，所以这种问题研究起来非常痛苦，毕竟隔行如隔山。在期间也请教了二哥，但是难免还是有理解偏差或者错误之处，也有很多内容因为不了解，所以没有细究，担心搞不定。&lt;/p&gt;&lt;p&gt;最后借用狗哥的一句话来结束此文：&lt;strong&gt;搜广推何去何从&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;好了，今天的文章就到这，我们下期见！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果对本文有疑问可以加笔者&lt;span&gt;&lt;strong&gt;微信&lt;/strong&gt;&lt;/span&gt;直接交流，笔者也建了C/C++相关的技术群，有兴趣的可以联系笔者加群。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JZPMOM7IrSb3r6zGUQGsP6fMsBhGXeoMw43aL9OEACnPAHdSKmuDljQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;90215&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; data-width=&quot;100%&quot;&gt;&lt;strong&gt;往期&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;精彩&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;回顾&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-bdless=&quot;spin&quot; data-bdlessp=&quot;280&quot; data-bdopacity=&quot;50%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247488842&amp;amp;idx=1&amp;amp;sn=d39efe4a60dfc2a2146bbdfa37442e71&amp;amp;chksm=c337738df440fa9bd4000d097c76ef530b13f0d4c53ee45a03a0a033ea57b7b0b3f436af1e4a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;惯用法之CRTP&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;惯用法之CRTP&lt;/a&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247488826&amp;amp;idx=1&amp;amp;sn=5ec3f6e6959b51de02b850aeee609f34&amp;amp;chksm=c33773fdf440faebd97a0184c3e30ce77b3ce306d7d6dea9967ece6bef41e9f6d9d9030b2a62&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;聊聊内存模型与内存序&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;聊聊内存模型与内存序&lt;/a&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247488441&amp;amp;idx=1&amp;amp;sn=f75be00bcd12934c2e7331956707a429&amp;amp;chksm=c337757ef440fc6816fdef3c144361a0e21ebe24da6ea497d8122ca04c81c7dcc40445ae3f1a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;vector初始化与否导致的巨大性能差异&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;vector初始化与否导致的巨大性能差异&lt;/a&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247488372&amp;amp;idx=1&amp;amp;sn=f3acc2893cbafc99c21203f4db0e24ee&amp;amp;chksm=c33775b3f440fca5410edde4ce29f1cbeec7c1734357e54c02bbe549ed3f435a4243f7e8d297&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;问题解决了，我却不知道原因&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;问题解决了，我却不知道原因&lt;/a&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247488290&amp;amp;idx=1&amp;amp;sn=c4d2416b3ee3968303379a8cef66105d&amp;amp;chksm=c33775e5f440fcf30a3a8bef429eb199577f71a15d688ddf729ed1edbb94d119d58c470195f1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;揭开lambda的神秘面纱&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;揭开lambda的神秘面纱&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247488149&amp;amp;idx=1&amp;amp;sn=4b7718a8798245b3a50e1fc9aebf5dee&amp;amp;chksm=c3377452f440fd44d13a4a99d3e16a2d06de0539b9f8365b7346de9c8037ea91b59f46df934f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;多态实现-虚函数、函数指针以及变体&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;多态实现-虚函数、函数指针以及变体&lt;/a&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247488000&amp;amp;idx=1&amp;amp;sn=156cad69e290f1e898cded46cd4cedc9&amp;amp;chksm=c33774c7f440fdd1e7db21f175029adcf622fe53f1968bb8acefa027bf95f01d5e2c2bb3d7a7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【Modern C++】深入理解移动语义&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;【Modern C++】深入理解移动语义&lt;/a&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247487751&amp;amp;idx=1&amp;amp;sn=3da21227cb1a4c80e36f91dc823529af&amp;amp;chksm=c33777c0f440fed6f9ebaa7f206f1e423f68c09a809a4d30033f34bd123ccf45d9e42655e199&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【Modern C++】深入理解左值、右值&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;【Modern C++】深入理解左值、右值&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247487474&amp;amp;idx=1&amp;amp;sn=e29d0178bfd4139313c44139e1cb3899&amp;amp;chksm=c3376935f440e023b96e9f8feeb34e4e22fbb74f00ca345a2b867edfd4c088bc595821fe878e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;智能指针-使用、避坑和实现&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;智能指针-使用、避坑和实现&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247487009&amp;amp;idx=1&amp;amp;sn=a812d27b9d65369ce2f38375b4a4ee96&amp;amp;chksm=c33768e6f440e1f015252fecf354f9f3712f59fc04b47b03401486c86fe51875428503ee9819&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;内存泄漏-原因、避免以及定位&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;内存泄漏-原因、避免以及定位&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247486816&amp;amp;idx=1&amp;amp;sn=a6dfc1361ce15ce5ad1c7d7734f9c939&amp;amp;chksm=c3376ba7f440e2b18267c303c35572ab089fb97d3b2fe0adb58009637d6631020bb52bd9a28c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;GDB调试-从入门实践到原理&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;GDB调试-从入门实践到原理&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247486357&amp;amp;idx=1&amp;amp;sn=3e7b88218f4416980b20add7575baa9a&amp;amp;chksm=c3376d52f440e444d28a01ef930ddfb92b5d30f26e7284012f08624ca1599e7efac1da3fb17c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【线上问题】P1级公司故障，年终奖不保&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;【线上问题】P1级公司故障，年终奖不保&lt;/a&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247486254&amp;amp;idx=1&amp;amp;sn=ebce58aa6b547af2a818faa5a6412e89&amp;amp;chksm=c3376de9f440e4ffea267926b7ce09ac439ab33a1da9dc6b4d631c971053f628cf91202d0f53&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【性能优化】高效内存池的设计与实现&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;【性能优化】高效内存池的设计与实现&lt;/a&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247485953&amp;amp;idx=1&amp;amp;sn=f8cd484607ab07f15247ecde773d2e1c&amp;amp;chksm=c3376cc6f440e5d047f7e648c951fd583df82ab4e3dab5767baeddef9fe7c1270f05b039d8c4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2万字|30张图带你领略glibc内存管理精髓&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;2万字|30张图带你领略glibc内存管理精髓&lt;/a&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是雨乐，从业十二年有余，历经过传统行业网络研发、互联网推荐引擎研发，目前在广告行业从业8年。目前任职某互联网公司高级技术专家一职，负责广告引擎的架构和研发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本公众号专注于架构、技术、线上bug分析等干货，欢迎关注。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0MzI4OTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHhKgtwWvzaYZodgfpphdA6WWKEMXTn6ImCCCuEzlPKicNBcpzBUyjK1XicWwqIwusqLGpwyyOc87JPQ/0?wx_fmt=png&quot; data-nickname=&quot;高性能架构探索&quot; data-alias=&quot;gxnjgts&quot; data-signature=&quot;专注于分享干货，硬货，欢迎关注😄&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c5385cdc7f9c98bdc2a3e61d52e00b1</guid>
<title>谈谈我工作中的 23 个设计模式</title>
<link>https://toutiao.io/k/3cghyiz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;a class=&quot;weui-flex original_primary_card appmsg_card_context wx_tap_card js_wx_tap_highlight&quot; href=&quot;#&quot; id=&quot;copyright_info&quot;&gt;
                  
                  &lt;div class=&quot;weui-flex__item&quot; role=&quot;option&quot;&gt;
                    &lt;strong class=&quot;original_primary_nickname&quot;&gt;阿里开发者&lt;/strong&gt;
                                          &lt;span class=&quot;weui-hidden_abs&quot;&gt;.&lt;/span&gt;
                      &lt;p class=&quot;original_primary_desc&quot;&gt;阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。&lt;/p&gt;
                                      &lt;/div&gt;
                  &lt;p class=&quot;weui-flex__ft&quot;/&gt;
                &lt;/a&gt;
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>