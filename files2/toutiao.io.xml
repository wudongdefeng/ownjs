<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2a41dd14875d6247d4f74c4e68009720</guid>
<title>一文彻底理解Go语言栈内存/堆内存</title>
<link>https://toutiao.io/k/8csj4gy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;h2 data-line=&quot;4&quot;&gt;&lt;strong&gt;&lt;span&gt;系列导读&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code data-line=&quot;6&quot;&gt;&lt;code&gt;&lt;p&gt;&lt;span&gt;本文基于64位平台、1Page=8KB、Go1.6&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4148148148148147&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhuZuquZTuGz1icCkzeiaibsvUMJqnMRfNy72uw1NtsQUia3OFIXwbI35mSQRLy9k2VP8kxJib9zxWWJicg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-line=&quot;16&quot;&gt;&lt;/p&gt;&lt;p data-line=&quot;16&quot;&gt;&lt;span&gt;本文为《Go语言轻松进阶》系列第二章「内存与垃圾回收」的第三小节。&lt;span&gt;第二章目录&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;知识预备&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Go内存设计与实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Go的垃圾回收原理&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MDEwMDYyOA==&amp;amp;mid=2454619630&amp;amp;idx=1&amp;amp;sn=2aa429b75e4300ea6e7b841885256623&amp;amp;chksm=87aae315b0dd6a03c6e5ff32fadabcf09cd9b496ab3f45c24ff5d0b927aa2be045bba39f56c3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;TCMalloc内存分配原理(完结)&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;(未开始)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;查看本系列完整内容请访问&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n347&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n694&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;http://tigerb.cn/go/#/kernal/&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 cid=&quot;n3&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;本文导读&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;p cid=&quot;n4&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;本文将从6个方向层层递进，帮助大家彻底理解Go语言的栈内存和堆内存：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n5&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n7&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;计算机为什么需要内存？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n9&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;为什么需要栈内存？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n11&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;为什么需要堆内存？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Go语言分配的是虚拟内存&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Go语言栈内存的分配&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n17&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Go语言堆内存的分配&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 cid=&quot;n18&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;计算机为什么需要内存？&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;计算机是运行自动化程序的载体，程序(或称之为进程)由可执行代码被执行后产生。那么计算机在运行程序的过程中为什么需要「内存」呢？为了轻松理解这个问题，我们先来简单看看：&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n25&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;代码的本质&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n26&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;简单来看代码主要包含两部分：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n27&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n29&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;指令部分：中央处理器CPU可执行的指令&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n31&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;数据部分：常量等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n32&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;代码包含了指令，代码被转化为可执行二进制文件，被执行后加载到内存中，中央处理器CPU通过内存获取指令，图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220731175631.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;591&quot; data-backw=&quot;713&quot; data-ratio=&quot;0.8284547311095983&quot; data-type=&quot;png&quot; data-w=&quot;2938&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWRGS3Q8vlruicXalPE6SJM2FWGJTSDfkqIq60A4uSG6RTwgWLrYoq1tQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n34&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;详细请移步历史文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5MDEwMDYyOA==&amp;amp;mid=2454620218&amp;amp;idx=1&amp;amp;sn=e09eae504ea538c508c174c620757fa9&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;「回到本真，代码到底是什么？」&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n35&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;程序的运行过程&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n36&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;可执行代码文件被执行之后，代码中的待执行指令被加载到了内存当中。这时CPU就可以从内存中获取指令、并执行指令。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n37&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;CPU执行指令简易过程分为三步：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n38&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;取指：&lt;strong&gt;CPU控制单元&lt;/strong&gt;从内存中获取指令&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n42&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;译指：&lt;strong&gt;CPU控制单元&lt;/strong&gt;解析从内存中获取指令&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n44&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;执行：&lt;strong&gt;CPU运算单元&lt;/strong&gt;负责执行具体的指令操作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n45&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们通过一个简易的时序图来看看CPU获取并执行指令的过程：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n46&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220807232114.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6604998377150276&quot; data-type=&quot;png&quot; data-w=&quot;3081&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWQrfTyibb3Dx5RvnLE4ib5OBRpC25YBFiaUR9nmscMUgVesDOVdLjOvDhQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n47&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;详细请移步历史文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5MDEwMDYyOA==&amp;amp;mid=2454620244&amp;amp;idx=1&amp;amp;sn=10d2d3e3a2605a21fa6621098bd3bcb8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;「回到本真，代码是如何运行的？」&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n48&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;内存的作用&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n49&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通过以上我们可以基本看出「内存」在计算机中扮演的角色：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n57&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;至此我们基本明白了内存存在的意义。但是呢，我们又经常会听到关于「栈内存」、「堆内存」的概念，那「栈内存」和「堆内存」到底是什么呢？接下来我们继续来看看这个问题。&lt;/span&gt;&lt;/p&gt;&lt;h1 cid=&quot;n58&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;为什么需要栈内存？&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;p cid=&quot;n59&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;程序在使用内存的过程中，不仅仅只需要关注内存的分配问题，还需要关注到内存使用完毕的回收问题，这就是内存管理中面临的最大两个问题：&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n347&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n694&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;有没有简单、高效、且通用的办法统一解决这个内存分配问题呢？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n67&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;答：最简单、高效的分配和回收方式就是对一段&lt;/span&gt;&lt;span&gt;&lt;strong&gt;连续内存&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;线性分配&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」，「栈内存」的分配就采用了这种方式。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n68&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;「栈内存」的简易管理过程：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;strong&gt;&lt;span&gt;1. 栈内存分配逻辑：current - alloc&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p cid=&quot;n72&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220807234036.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6102051551814834&quot; data-type=&quot;png&quot; data-w=&quot;1901&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWfic8CaPhZn75pwFEjoiaK6O9oTW68bQex1H01tPVPricAgmJMqMJCcXWg/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n75&quot; mdtype=&quot;paragraph&quot;&gt;&lt;strong&gt;&lt;span&gt;2. 栈内存释放逻辑：current + alloc&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p cid=&quot;n76&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220807234046.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6827330508474576&quot; data-type=&quot;png&quot; data-w=&quot;1888&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWf95uYdAB20TXQGMtz6Q3pYicsAicTicXvjJhx3RRR2TIfSOgEAbRbqChw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n77&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通过利用「栈内存」，CPU在执行指令过程中可以高效地存储临时变量。其次：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n83&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220807235914.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5689555683785343&quot; data-type=&quot;png&quot; data-w=&quot;3466&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylW7K8l8ImP2hyhMfP3g9QExWzFnziaLuoiaAZxo6ThPBHzvkUBlrZTOseg/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n84&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所以同时你应该也理解了「为什么称之为栈内存？」。&lt;/span&gt;&lt;span&gt;&lt;span&gt;「栈内存」是计算机对连续内存的采取的「线性分配」管理方式，便于高效存储指令运行过程中的临时变量&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 cid=&quot;n85&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;为什么需要堆内存？&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;p cid=&quot;n86&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;假如函数A内变量是个指针且被函数B外的代码依赖，如果对应变量内存被回收，这个指针就成了野指针不安全。怎么解决这个问题呢？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n87&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;答：这就是「堆内存」存在的意义，Go语言会在代码编译期间通过「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;逃逸分析&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」把分配在「栈」上的变量分配到「堆」上去。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n88&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220808002156.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;612&quot; data-backw=&quot;713&quot; data-ratio=&quot;0.8584821428571429&quot; data-type=&quot;png&quot; data-w=&quot;2240&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWtxbmiaURfMRK04xhSQvVn3YeFZ9Xj6gyMibicUqWluEYYyzxyytsXA1kA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n347&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n694&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;「堆内存」如何回收呢？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n91&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;答：堆内存通过「垃圾回收器」回收，关于「垃圾回收器」后续我们详解。&lt;/span&gt;&lt;/p&gt;&lt;h1 cid=&quot;n92&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Go语言分配的是虚拟内存&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;p cid=&quot;n93&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过以上我们了解了「内存」、「栈内存」、「堆内存」存在的意义。除此之外，还有一个重要的知识点：程序和操作系统实际操作的都是虚拟内存，最终由&lt;/span&gt;&lt;span&gt;CPU通过&lt;strong&gt;内存管理单元MMU&lt;/strong&gt;(Memory Manage Unit)把虚拟内存的地址转化为实际的物理内存地址&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。图示如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n94&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20210129194928.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6819243344231667&quot; data-type=&quot;png&quot; data-w=&quot;2141&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWKTdDQTYK90ChM6F1BsQ9XcSybnOUYO3ACRlicmYfLqic5NgvbFzg1rnQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n95&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;使用虚拟内存的原因：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n96&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n98&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;对于我们的&lt;/span&gt;&lt;span&gt;进程而言，可使用的内存是连续的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n100&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;安全，防止了进程直接对物理内存的操作&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;(如果进程可以直接操作物理内存，那么存在某个进程篡改其他进程数据的可能)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n102&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;提升物理内存的利用率&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，当进程真正要使用物理内存时再分配&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n104&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;虚拟内存和物理内存是通过MMU(管理单元内存Memory Management Unit)映射的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n105&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所以，一个很重要的知识点：&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n347&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n694&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;结论：&lt;/span&gt;&lt;span&gt;Go语言源代码对「栈内存」和「堆内存」的分配、释放等操作，都是对虚拟内存的操作，最终中央处理器CPU会统一通过MMU(管理单元内存Memory Management Unit)转化为实际的物理内存。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n108&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;也就是说Go语言源代码中：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n109&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n111&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;「栈内存」的分配或释放都是对虚拟内存的操作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n113&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;「堆内存」的分配或释放都是对虚拟内存的操作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n113&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n114&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220818132131.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9715743440233237&quot; data-type=&quot;png&quot; data-w=&quot;1372&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWUkhmUskJ98SKoeicmCh3LOx4VXWReypPliam1cvica5iaUedkGeIeQic2icA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n115&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n115&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;接着我们分别通过&lt;strong&gt;分配时机&lt;/strong&gt;、&lt;strong&gt;分配过程&lt;/strong&gt;两部分，来看看Go语言栈内存和堆内存的分配。&lt;/span&gt;&lt;/p&gt;&lt;h1 cid=&quot;n116&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Go语言栈内存的分配&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;h2 cid=&quot;n117&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Go语言栈内存分配的时机&lt;/span&gt;&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-1&quot; cid=&quot;n1192&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1194&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;创建&lt;code&gt;Goroutinue&lt;/code&gt;时&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p cid=&quot;n1203&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;栈扩容时&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;h3 cid=&quot;n130&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;栈内存分配时机-创建&lt;code&gt;Goroutinue&lt;/code&gt;时&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n131&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;创建&lt;code&gt;g0&lt;/code&gt;函数代码片段：&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// src/runtime/proc.go::1720&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 创建 m&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;allocm&lt;/span&gt;&lt;span&gt;(_p_ *p, fn &lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;, &lt;span&gt;id&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;) *&lt;span&gt;m&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; iscgo || mStackIsSystemAllocated() {&lt;br/&gt;        mp.g0 = malg(&lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;&lt;span&gt;// 创建g0 并申请8KB栈内存&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 依赖的malg函数&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        mp.g0 = malg(&lt;span&gt;8192&lt;/span&gt; * sys.StackGuardMultiplier)&lt;br/&gt; }&lt;br/&gt;    &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;创建&lt;code&gt;g&lt;/code&gt;函数代码片段：&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// src/runtime/proc.go::3999&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 创建一个带有任务fn的goroutine&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newproc1&lt;/span&gt;&lt;span&gt;(fn *funcval, argp unsafe.Pointer, narg &lt;span&gt;int32&lt;/span&gt;, callergp *g, callerpc &lt;span&gt;uintptr&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;g&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;    newg := gfget(_p_)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; newg == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;&lt;span&gt;// 全局队列、本地队列找不到g 则 创建一个全新的goroutine&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// _StackMin = 2048&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 申请2KB栈内存&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 依赖的malg函数&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;      newg = malg(_StackMin)&lt;br/&gt;      casgstatus(newg, _Gidle, _Gdead)&lt;br/&gt;      allgadd(newg)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;以上都依赖&lt;code&gt;malg&lt;/code&gt;函数代码片段，其作用是创建一个全新&lt;code&gt;g&lt;/code&gt;：&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// src/runtime/proc.go::3943&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 创建一个指定栈内存的g&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;malg&lt;/span&gt;&lt;span&gt;(stacksize &lt;span&gt;int32&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;g&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; newg := &lt;span&gt;new&lt;/span&gt;(g)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; stacksize &amp;gt;= &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;     systemstack(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;// 分配栈内存&lt;/span&gt;&lt;br/&gt;     newg.stack = stackalloc(&lt;span&gt;uint32&lt;/span&gt;(stacksize))&lt;br/&gt;  })&lt;br/&gt;     &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; newg&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 cid=&quot;n138&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;栈内存分配时机-栈扩容&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// src/runtime/stack.go::838&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;copystack&lt;/span&gt;&lt;span&gt;(gp *g, newsize &lt;span&gt;uintptr&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 分配新的栈空间&lt;/span&gt;&lt;br/&gt; &lt;span&gt;new&lt;/span&gt; := stackalloc(&lt;span&gt;uint32&lt;/span&gt;(newsize))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;结论：&lt;/span&gt;&lt;span&gt;创建Goroutine和栈扩容时，栈内存的分配都是由函数&lt;code&gt;stackalloc&lt;/code&gt;&lt;/span&gt;&lt;span&gt;分配。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n142&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405133309.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4086629001883239&quot; data-type=&quot;png&quot; data-w=&quot;531&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWXuqhX6Q27nb2Qp2v0icyOq7urRhqB7PCicUibYWTguXjCeT1sfPrRiaI0g/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n143&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所以，我们通过分析&lt;code&gt;stackalloc&lt;/code&gt;函数就可以知道栈内存的分配过程了，具体如下。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n144&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;栈内存分配过程&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n145&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Go语言栈内存的分配按待分配的栈大小分为两大类：&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n151&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;小于32KB栈分配过程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n154&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1. 先去&lt;code&gt;M&lt;/code&gt;线程缓存&lt;code&gt;mcache&lt;/code&gt;的栈内存缓存&lt;code&gt;stackcache&lt;/code&gt;中分配：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n154&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n155&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220819133249.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30138768430182133&quot; data-type=&quot;png&quot; data-w=&quot;2306&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWoKtPicgxGgpfve3L61JRJ7MVhuQxicaZ8ZgVHY6ZrCb6glQAUjsJcrFw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2. 如果&lt;code&gt;stackcache&lt;/code&gt;内存不足，则从全局栈内存缓存池&lt;code&gt;stackpool&lt;/code&gt;中分配：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n159&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234800.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6745098039215687&quot; data-type=&quot;png&quot; data-w=&quot;1785&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWNuQTmqoayicaAZFKCOtYmNKTKhcraFrabWudFv6Mib32xcJKK1ucNkAw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n162&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n162&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n162&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;3. 如果&lt;code&gt;stackpool&lt;/code&gt;内存不足，则从逻辑处理器结构&lt;code&gt;p&lt;/code&gt;中的&lt;code&gt;p.pagecache&lt;/code&gt;中分配：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n162&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n163&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220819133321.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9514310494362532&quot; data-type=&quot;png&quot; data-w=&quot;2306&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWic74ibcxpScsCiaJxCIfRanMpDEXtpKSKpRVl4PU3YxoNaPrXDvFr4x1Q/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n166&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n166&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n166&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;4. 如果&lt;code&gt;p.pagecache&lt;/code&gt;内存不足，则从堆&lt;code&gt;mheap&lt;/code&gt;中分配：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n166&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n167&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220819133338.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.293148308759757&quot; data-type=&quot;png&quot; data-w=&quot;2306&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWcQ5RVramd7nKOXFHvOVQsy2gjVGva7CkbEKM7LPX4iblWZWGHBGC2dA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n168&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 cid=&quot;n168&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;大于等于32KB栈分配过程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1660&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1. 直接从全局栈内存缓存池&lt;code&gt;stackLarge&lt;/code&gt;中分配：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n169&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234822.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42533081285444235&quot; data-type=&quot;png&quot; data-w=&quot;1587&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWXK7jQF0hhRbjs6K1sNMoSyI90CLAqoIGhczCeibKibeGHfbBFbUhX10g/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n169&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234822.png&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n2380&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2. 全局栈内存缓存池&lt;code&gt;stackLarge&lt;/code&gt;不足，则从逻辑处理器结构&lt;code&gt;p&lt;/code&gt;中的&lt;code&gt;p.pagecache&lt;/code&gt;中分配，如果&lt;code&gt;p.pagecache&lt;/code&gt;则去堆上&lt;code&gt;mheap&lt;/code&gt;分配：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n169&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n170&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234828.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8182283666154634&quot; data-type=&quot;png&quot; data-w=&quot;1953&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWhAH6KfJeSE8nLXW1OxsibPfUVMq3SPFAwuLFLYG6W54ria9wFYcPHJIg/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 cid=&quot;n171&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Go语言堆内存的分配&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;p cid=&quot;n2383&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;想要更好的理解Go堆内存分配需要先了解Go的内存三层架构以及Go的内存管理单元&lt;code&gt;mspan&lt;/code&gt;。历史文章请查看：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n2388&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n172&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Go语言堆内存分配时机&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n174&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;判断一个变量是否应该分配到「堆内存」的关键点就是：&lt;/span&gt;&lt;span&gt;代码编译阶段，编译器会通过&lt;strong&gt;逃逸分析&lt;/strong&gt;&lt;strong&gt;判断并标记&lt;/strong&gt;上该变量是否需要分配到堆上。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n175&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通常我们在创建如下变量时，变量都有可能被分配到堆上：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n2392&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n2396&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;切片&lt;code&gt;Slice&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n2404&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;创建数组时&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n2406&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;创建&lt;code&gt;Channel&lt;/code&gt;时&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n2408&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Map&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n2415&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n200&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;涉及相关数据类型的写操作函数整理如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n200&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;表格可左右滑动查看&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n201&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n202&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;名称&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;代码位置&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n207&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;切片&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;makeslice(et *_type, len, cap int) unsafe.Pointer&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;创建切片&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;src/runtime/slice.go::83&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n212&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;切片&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;growslice(et *_type, old slice, cap int) slice&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;切片扩容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;src/runtime/slice.go::125&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n217&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;切片&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;makeslicecopy(et *_type, tolen int, fromlen int, from unsafe.Pointer) unsafe.Pointer&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;copy切片&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;src/runtime/slice.go::36&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n222&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;字节字符串&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;gobytes(p *byte, n int) (b []byte)&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;转换字符串&lt;code&gt;string&lt;/code&gt;为&lt;code&gt;[]byte&lt;/code&gt;类型&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;src/runtime/string.go::301&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n227&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;字节字符串&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;slicebytetostring(buf *tmpBuf, ptr *byte, n int) (str string)&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;转换字节字符串&lt;code&gt;[]byte&lt;/code&gt;为类型&lt;code&gt;string&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;src/runtime/string.go::80&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n232&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;字节字符串&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;rawstring(size int) (s string, b []byte)&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;按大小初始化一个新的&lt;code&gt;string&lt;/code&gt;类型&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;src/runtime/string.go::83&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n237&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;字节字符串&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;rawbyteslice(size int) (b []byte)&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;按大小初始化一个新的&lt;code&gt;[]byte&lt;/code&gt;类型&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;src/runtime/string.go::83&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n242&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;字节字符串&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;rawruneslice(size int) (b []rune)&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;按大小初始化一个新的&lt;code&gt;[]rune&lt;/code&gt;类型&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;src/runtime/string.go::83&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n247&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;Channel&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;makechan(t *chantype, size int) *hchan&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;创建一个&lt;code&gt;chan&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;src/runtime/chan.go::71&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n252&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;数组&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;func newarray(typ *_type, n int) unsafe.Pointer&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;初始化一个数组&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;src/runtime/malloc.go::1191&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n257&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;Map&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;map申请内存&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;src/runtime/map.go::571&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n262&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;Map&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;map申请溢出桶&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;src/runtime/map.go::245&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n267&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n268&quot; mdtype=&quot;table_cell&quot;&gt;等等&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n269&quot; mdtype=&quot;table_cell&quot;&gt;...&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n270&quot; mdtype=&quot;table_cell&quot;&gt;...&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n272&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这里我们以初始化切片的源代码为例来看看切片何时被分配到堆上的逻辑判断：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n285&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;切片分配过程源代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 代码位置：src/cmd/compile/internal/gc/walk.go::1316&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 初始化切片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; OMAKESLICE:&lt;br/&gt;    &lt;span&gt;// ...略...&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// &lt;/span&gt;&lt;span&gt;逃逸标识，是否需要逃逸到堆上&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; n.Esc == EscNone {&lt;br/&gt;        &lt;span&gt;// ...略...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;// 不需要逃逸&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 直接栈上分配内存&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        t = types.NewArray(t.Elem(), i) &lt;span&gt;// [r]T&lt;/span&gt;&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;// ...略...&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;       &lt;span&gt; &lt;span&gt;// 需要内存逃逸到堆上&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;// ...略...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;       &lt;span&gt; &lt;span&gt;// 默认使用makeslice64函数从堆上分配内存&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        fnname := &lt;span&gt;&quot;makeslice64&quot;&lt;/span&gt;&lt;br/&gt;        argtype := types.Types[TINT64]&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// ...略...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;len&lt;/span&gt;.Type.IsKind(TIDEAL) || maxintval[&lt;span&gt;len&lt;/span&gt;.Type.Etype].Cmp(maxintval[TUINT]) &amp;lt;= &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp;&lt;br/&gt;            (&lt;span&gt;cap&lt;/span&gt;.Type.IsKind(TIDEAL) || maxintval[&lt;span&gt;cap&lt;/span&gt;.Type.Etype].Cmp(maxintval[TUINT]) &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;// 校验通过，则&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 使用makeslice函数从堆上分配内存&lt;/span&gt;&lt;br/&gt;            fnname = &lt;span&gt;&quot;makeslice&quot;&lt;/span&gt;&lt;br/&gt;            argtype = types.Types[TINT]&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// ...略...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 调用上面指定的runtime函数&lt;/span&gt;&lt;br/&gt;        m.Left = mkcall1(fn, types.Types[TUNSAFEPTR], init, typename(t.Elem()), conv(&lt;span&gt;len&lt;/span&gt;, argtype), conv(&lt;span&gt;cap&lt;/span&gt;, argtype))&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// ...略...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n287&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;最终分配堆内存的地方都会依赖函数&lt;code&gt;mallocgc&lt;/code&gt;，我们通过阅读&lt;code&gt;mallocgc&lt;/code&gt;的代码就可以看到堆内存的分配过程。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n288&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405235337.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6477611940298508&quot; data-type=&quot;png&quot; data-w=&quot;335&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylW2qsymCAbtmXhuqAyAa737iaRyU1l8h6j0LG9nSHoIdHEbKxaBicaSqGA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n289&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Go语言堆内存分配过程&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n290&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;堆内存的分配按对象的大小分，主要分为三大类：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n298&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;「微对象」和「小对象」&lt;strong&gt;通常&lt;/strong&gt;通过逻辑处理器结构&lt;code&gt;P&lt;/code&gt;的线程缓存&lt;code&gt;mcache&lt;/code&gt;分配，「大对象」直接从堆上&lt;code&gt;mheap&lt;/code&gt;中分配，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n299&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405235126.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5704622322435174&quot; data-type=&quot;png&quot; data-w=&quot;1774&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWQq8uPibrfIZPzEiaEE2R2v72Ym5DZAoRn0KHDjQtotqDAmcee8lH2Uwg/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n305&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405235250.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWXHv5rspLZ7I3kQTSr2MYUaYt2RiaiakBeictH2okSKKtKoywZLK8CoF5Q/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n306&quot; mdtype=&quot;heading&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 cid=&quot;n306&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;微对象的分配过程&lt;/span&gt;&lt;/h3&gt;&lt;blockquote cid=&quot;n307&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n308&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;微对象 0 &amp;lt; Micro Object &amp;lt; 16B&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n311&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n311&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1. 线程缓存&lt;code&gt;mcache&lt;/code&gt;的&lt;code&gt;tiny&lt;/code&gt;内存充足，则直接分配「微对象」所需内存，图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n311&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n312&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234253.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6942800788954635&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWNiaOA6EVfn7VgLicAJoVaSRpXLXlc1pgPIGroE3gOllBBOlcIzibcic2Iw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n315&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n315&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n315&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2. 线程缓存&lt;code&gt;mcache&lt;/code&gt;的&lt;code&gt;tiny&lt;/code&gt;内存不足，先去线程缓存&lt;code&gt;mcache&lt;/code&gt;的&lt;code&gt;alloc&lt;/code&gt;申请16B给&lt;code&gt;tiny&lt;/code&gt;，再分配「微对象」所需内存，简易图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n315&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n316&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234330.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6194144838212635&quot; data-type=&quot;png&quot; data-w=&quot;1298&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWrwg9OK3Fic6J7ic8MHXdtF4jHyvm8oQgmoxkvZymibxGRVA6iaCc0zgfxw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n317&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;申请16B详细过程图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n317&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n318&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234341.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9503296703296703&quot; data-type=&quot;png&quot; data-w=&quot;2275&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWicpnNW9dOq2LS95Fh4ctCfgnhgOic6HiauxmFMqVerMyqKnTUQty3ql0A/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n319&quot; mdtype=&quot;heading&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 cid=&quot;n319&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 cid=&quot;n319&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;小对象的分配过程&lt;/span&gt;&lt;/h3&gt;&lt;blockquote cid=&quot;n320&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n321&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;小对象 16B =&amp;lt; Small Object &amp;lt;= 32KB&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n324&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n324&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1. 线程缓存&lt;code&gt;mcache&lt;/code&gt;的&lt;code&gt;alloc&lt;/code&gt;充足，则直接分配「小对象」所需内存，简易图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n324&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n325&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220820172242.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.054270462633452&quot; data-type=&quot;png&quot; data-w=&quot;1124&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWQYWia0seNfMyf1odcYps91IAXOImhV3RV3VlMibA5QnZTEkZwSEcnnqw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n326&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n326&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;详细分配过程图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n326&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n327&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234425.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4949618320610687&quot; data-type=&quot;png&quot; data-w=&quot;3275&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWPSqCPdqjNyYPTJpM94Yby3FLXkpKZnXtrC7GsK8QZaribydysoE1hsw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n330&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n330&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2. 线程缓存&lt;code&gt;mcache&lt;/code&gt;的&lt;code&gt;alloc&lt;/code&gt;不足，则去中央缓存&lt;code&gt;mcentral&lt;/code&gt;获取一个&lt;code&gt;mspan&lt;/code&gt;，再分配「小对象」所需内存，图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n330&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n331&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234513.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7551487414187643&quot; data-type=&quot;png&quot; data-w=&quot;2185&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWtKGA3rHJozV3flicicdKIQFhYGPicynibIJibk9Zf4zbPxH2k5UFZOPFkNw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n331&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234513.png&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n2996&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;3. 线程缓存&lt;code&gt;mcache&lt;/code&gt;的&lt;code&gt;alloc&lt;/code&gt;不足，且中央缓存&lt;code&gt;mcentral&lt;/code&gt;不足，则去逻辑处理器结构的&lt;code&gt;pagecache&lt;/code&gt;分配，如果&lt;code&gt;pagecache&lt;/code&gt;直接去堆上&lt;code&gt;mheap&lt;/code&gt;获取一个&lt;code&gt;mspan&lt;/code&gt;，再分配「小对象」所需内存，图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n2550&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n335&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234521.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4068905364151767&quot; data-type=&quot;png&quot; data-w=&quot;2293&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylW31oVa9ibbyqwV9wF4sN7BjHblXicXZl9EJ94yS1nzcNkSZJrdhSZHOAQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n336&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 cid=&quot;n336&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;大对象的分配过程&lt;/span&gt;&lt;/h3&gt;&lt;blockquote cid=&quot;n337&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n338&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;大对象 32KB &amp;lt; Large Object&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n341&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n341&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1. 逻辑处理器结构的&lt;code&gt;pagecache&lt;/code&gt;充足，则直接分配「大对象」所需内存，图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n341&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n342&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234609.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5937193326790972&quot; data-type=&quot;png&quot; data-w=&quot;1019&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWnHOBTm4fQEWK86B7NhmowHMKFLbRJMnofjdsG6Cetpb8bOZMnK6UAQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n345&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n345&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2. 逻辑处理器结构的&lt;code&gt;pagecache&lt;/code&gt;不足，则直接去堆上&lt;code&gt;mheap&lt;/code&gt;分配「大对象」所需内存，图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n345&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n346&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220405234616.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9336349924585219&quot; data-type=&quot;png&quot; data-w=&quot;1326&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhicj3gELvLibsUzupCVSJylWScLrwVHn8Pam3SpXQk4p3GnypR7zVmYibrvwf11OENUMsU3oQJqvtuA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 cid=&quot;n347&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n3067&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n3068&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.tigerb.cn/20220503213918.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7425578831312017&quot; data-type=&quot;png&quot; data-w=&quot;1814&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdgHkALTycoQMSlP76DG3nC61JiaFvjVibZ4XmbHvCSTH1lTeb87eQxNx0t0qQFyRuMdWGP0rW9gsm8A/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Go轻松进阶系列&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 更多文章&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5MDEwMDYyOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TiccVmMZ3icdia9Gagoyr7f529Zq7RkVUsUymKGWVic6b7J5eK7cgQ8RxtxsZPh0yicclre6QclI6oprVIrxV5axibtQ/0?wx_fmt=png&quot; data-nickname=&quot;TIGERB&quot; data-alias=&quot;tigerbcode&quot; data-signature=&quot;技术不凌驾业务 业务不拖累技术&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06302521008403361&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;714&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdjOmxkheVnwCeibLWia2yTSSAnu4wH1RgmdCrGrIicz5oicSN5gbZxKaiaZ3oicxDC3iaOCm92d2VjbqGMmw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;36694&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.375&quot; data-type=&quot;gif&quot; data-w=&quot;40&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/TiccVmMZ3icdiazAwOwey9wAIliamDeGicTOXib4HFynOX3BUxJMO7b4Azq3fNx3JgEwKU3NMG3N2hLLfIsqCUJMd43w/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          

          



                    
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>40d4260ef6f939069d33e531a6b88b19</guid>
<title>Python爬虫之BeautifulSoup4使用</title>
<link>https://toutiao.io/k/3nzbc9s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;钢铁知识库，一个学习python爬虫、数据分析的知识库。人生苦短，快用python。&lt;/p&gt;

&lt;p&gt;上一章我们讲解针对结构化的&lt;code&gt;html&lt;/code&gt;、&lt;code&gt;xml&lt;/code&gt;数据，使用&lt;code&gt;Xpath&lt;/code&gt;实现网页内容爬取。本章我们再来聊另一个高效的神器：&lt;code&gt;Beautiful Soup4&lt;/code&gt;。相比于传统正则表达方式去解析网页源代码，这个就简单得多，实践是检验真理的唯一标准，话不多说直接上号开搞验证。&lt;/p&gt;

&lt;h2&gt;Beautiful Soup 简介&lt;/h2&gt;

&lt;p&gt;首先说说BeautifulSoup是什么。简单来说，这是Python的一个HTML或XML的解析库，我们可以用它方便从网页中提取数据，官方解释如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;BeautifulSoup 提供一些简单的、Python 式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 BeautifulSoup 自动将输入文档转换为 Unicode 编码，输出文档转换为 utf-8 编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时你仅仅需要说明一下原始编码方式就可以了。 BeautifulSoup 已成为和 lxml、html5lib 一样出色的 Python 解释器，为用户灵活地提供不同的解析策略或强劲的速度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以，利用它可以省去很多繁琐的提取工作，提高解析效率。&lt;/p&gt;

&lt;h2&gt;BeautifulSoup 安装&lt;/h2&gt;

&lt;p&gt;BeautifulSoup3 目前已经停止开发，推荐使用 BeautifulSoup4，不过它也被移植到&lt;code&gt;bs4&lt;/code&gt;了，也就是说导入时我们需要&lt;code&gt;import bs4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在开始之前，请确保已经正确安装&lt;code&gt;beautifulsoup4&lt;/code&gt;和&lt;code&gt;lxml&lt;/code&gt;，使用pip安装命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install beautifulsoup4
pip install lxml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;解析器&lt;/h2&gt;

&lt;p&gt;BeautifulSoup在解析时实际上依赖解析器。除了支持Python标准库中的HTML解析器，还支持一些第三方的解析器，如果不安装它，则Python会使用默认的解析器。&lt;/p&gt;

&lt;p&gt;下面列出BeautifulSoup支持的解析器&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;解析器&lt;/th&gt;
&lt;th&gt;使用方法&lt;/th&gt;
&lt;th&gt;优势&lt;/th&gt;
&lt;th&gt;劣势&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Python 标准库&lt;/td&gt;
&lt;td&gt;BeautifulSoup(markup, &quot;html.parser&quot;)&lt;/td&gt;
&lt;td&gt;Python 的内置标准库、执行速度适中 、文档容错能力强&lt;/td&gt;
&lt;td&gt;Python 2.7.3 or 3.2.2) 前的版本中文容错能力差&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LXML HTML 解析器&lt;/td&gt;
&lt;td&gt;BeautifulSoup(markup, &quot;lxml&quot;)&lt;/td&gt;
&lt;td&gt;速度快、文档容错能力强&lt;/td&gt;
&lt;td&gt;需要安装 C 语言库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LXML XML 解析器&lt;/td&gt;
&lt;td&gt;BeautifulSoup(markup, &quot;xml&quot;)&lt;/td&gt;
&lt;td&gt;速度快、唯一支持 XML 的解析器&lt;/td&gt;
&lt;td&gt;需要安装 C 语言库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;html5lib&lt;/td&gt;
&lt;td&gt;BeautifulSoup(markup, &quot;html5lib&quot;)&lt;/td&gt;
&lt;td&gt;最好的容错性、以浏览器的方式解析文档、生成 HTML5 格式的文档&lt;/td&gt;
&lt;td&gt;速度慢、不依赖外部扩展&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;通过上面可以看出，lxml 有解析HTML和XML的功能，相比默认的HTML解析器更加强大，速度，容错能力强。&lt;/p&gt;

&lt;p&gt;推荐使用它，下面统一使用lxml进行演示。使用时只需在初始化时第二个参数改为 lxml 即可。&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;from bs4 import BeautifulSoup
soup = BeautifulSoup(&#x27;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&#x27;, &#x27;lxml&#x27;)
print(soup.p.string)
&#x27;&#x27;&#x27;
Hello
&#x27;&#x27;&#x27;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;基本使用&lt;/h2&gt;

&lt;p&gt;下面举个实例来看看BeautifulSoup的基本用法：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html = &quot;&quot;&quot;
&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;The Dormouse&#x27;s story&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&amp;gt;&amp;lt;b&amp;gt;The Dormouse&#x27;s story&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p class=&quot;story&quot;&amp;gt;Once upon a time there were three little sisters; and their names were
&amp;lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&amp;gt;&amp;lt;!-- Elsie --&amp;gt;&amp;lt;/a&amp;gt;,
&amp;lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt; and
&amp;lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;;
and they lived at the bottom of a well.&amp;lt;/p&amp;gt;
&amp;lt;p class=&quot;story&quot;&amp;gt;...&amp;lt;/p&amp;gt;
&quot;&quot;&quot;
from bs4 import BeautifulSoup
soup = BeautifulSoup(html, &#x27;lxml&#x27;)  # 初始化
print(soup.prettify())
print(soup.title.string)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果，你们也可以将上面代码复制到编辑器执行看看：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;&amp;lt;html&amp;gt;
 &amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;
   The Dormouse&#x27;s story
  &amp;lt;/title&amp;gt;
 &amp;lt;/head&amp;gt;
 &amp;lt;body&amp;gt;
  &amp;lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&amp;gt;
   &amp;lt;b&amp;gt;
    The Dormouse&#x27;s story
   &amp;lt;/b&amp;gt;
  &amp;lt;/p&amp;gt;
  &amp;lt;p class=&quot;story&quot;&amp;gt;
   Once upon a time there were three little sisters; and their names were
   &amp;lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&amp;gt;
    &amp;lt;!-- Elsie --&amp;gt;
   &amp;lt;/a&amp;gt;
   ,
   &amp;lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&amp;gt;
    Lacie
   &amp;lt;/a&amp;gt;
   and
   &amp;lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&amp;gt;
    Tillie
   &amp;lt;/a&amp;gt;
   ;
and they lived at the bottom of a well.
  &amp;lt;/p&amp;gt;
  &amp;lt;p class=&quot;story&quot;&amp;gt;
   ...
  &amp;lt;/p&amp;gt;
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
The Dormouse&#x27;s story
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先声明一个html变量，它是一个HTML字符串，注意html和body标签都没有闭合。&lt;/p&gt;

&lt;p&gt;经过初始化，使用&lt;code&gt;prettify()&lt;/code&gt;方法把要解析的字符串以标准缩进格式输出，发现结果中自动补全了html和body标签。这一步不是&lt;code&gt;prettify()&lt;/code&gt;方法做的，而是在初始化BeautifulSoup时就完成了。然后调用&lt;code&gt;soup.title.string&lt;/code&gt;拿到title里面的文本内容。&lt;/p&gt;

&lt;p&gt;通过简单调用几个属性完成文本提取，是不是非常方便呢？&lt;/p&gt;

&lt;h2&gt;节点选择器&lt;/h2&gt;

&lt;p&gt;直接调用节点的名称就可以选择节点元素，再调用 string 属性就可以得到节点内的文本了，这种选择方式速度非常快。如果单个节点结构层次非常清晰，可以选用这种方式来解析。&lt;/p&gt;

&lt;h3&gt;选择元素&lt;/h3&gt;

&lt;p&gt;还是以上面的HTML代码为例，详细说明选择元素的方法：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;from bs4 import BeautifulSoup
soup = BeautifulSoup(html, &#x27;lxml&#x27;)
print(soup.title)
print(type(soup.title))
print(soup.title.string)
print(soup.head)
print(soup.p)
&#x27;&#x27;&#x27;
&amp;lt;title&amp;gt;The Dormouse&#x27;s story&amp;lt;/title&amp;gt;
&amp;lt;class &#x27;bs4.element.Tag&#x27;&amp;gt;
The Dormouse&#x27;s story
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;The Dormouse&#x27;s story&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&amp;gt;&amp;lt;b&amp;gt;The Dormouse&#x27;s story&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;
&#x27;&#x27;&#x27;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先输出title节点的选择结果，包含标签。&lt;/p&gt;

&lt;p&gt;接下来输出它的类型，是一个&lt;code&gt;bs4.element.Tag&lt;/code&gt;类型，Tag具有一些属性，比如string。&lt;/p&gt;

&lt;p&gt;调用string属性可以看到输出节点的文本内容。&lt;/p&gt;

&lt;p&gt;继续尝试head、p节点。发现p只取了第一个匹配的节点。说明当有多个节点时只取一个。&lt;/p&gt;

&lt;h3&gt;获取属性&lt;/h3&gt;

&lt;p&gt;每个节点可能有多个属性比如id 、class等，选择元素后可以调用attrs获取所有属性：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;print(soup.p.attrs)
print(soup.p.attrs[&#x27;name&#x27;])
&#x27;&#x27;&#x27;
{&#x27;class&#x27;: [&#x27;title&#x27;], &#x27;name&#x27;: &#x27;dromouse&#x27;}
dromouse
&#x27;&#x27;&#x27;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到attrs返回结果是字典，它把选择节点所有属性都组合成一个字典。取值直接按字典方式即可。&lt;/p&gt;

&lt;p&gt;当然还有一种更简单的获取方式：不写attrs，直接在元素后面中括号取值也行：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;print(soup.p[&#x27;name&#x27;])
print(soup.p[&#x27;class&#x27;])
&#x27;&#x27;&#x27;
dromouse
[&#x27;title&#x27;]
&#x27;&#x27;&#x27;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是注意区分：有的返回字符串、有的返回字符串组成的列表。&lt;/p&gt;

&lt;p&gt;对于class，一个节点元素可能有多个class，所以返回的是列表。&lt;/p&gt;

&lt;h3&gt;子节点和子孙节点&lt;/h3&gt;

&lt;p&gt;选取节点元素之后，如果想要获取它的直接子节点，可以调用 contents 属性，示例如下：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html4 = &quot;&quot;&quot;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;The Dormouse&#x27;s story&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;p class=&quot;story&quot;&amp;gt;
            钢铁知识库
            &amp;lt;a href=&quot;http://a.com&quot; class=&quot;钢铁学数据分析&quot; id=&quot;link1&quot;&amp;gt;
                &amp;lt;span&amp;gt;Elsie&amp;lt;/span&amp;gt;
            &amp;lt;/a&amp;gt;
            &amp;lt;a href=&quot;http://b.com&quot; class=&quot;钢铁学自动化&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt; 
            and
            &amp;lt;a href=&quot;http://example.com&quot; class=&quot;cccc&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;
            钢铁学爬虫.
        &amp;lt;/p&amp;gt;
        &amp;lt;p class=&quot;story&quot;&amp;gt;...&amp;lt;/p&amp;gt;
&quot;&quot;&quot;
from bs4 import BeautifulSoup
soup = BeautifulSoup(html4, &#x27;lxml&#x27;)
print(soup.p.contents)
&#x27;&#x27;&#x27;
[&#x27;\n            钢铁知识库\n            &#x27;, &amp;lt;a class=&quot;钢铁学数据分析&quot; href=&quot;http://a.com&quot; id=&quot;link1&quot;&amp;gt;
&amp;lt;span&amp;gt;Elsie&amp;lt;/span&amp;gt;
&amp;lt;/a&amp;gt;, &#x27;\n&#x27;, &amp;lt;a class=&quot;钢铁学自动化&quot; href=&quot;http://b.com&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt;, &#x27; \n            and\n            &#x27;, &amp;lt;a class=&quot;cccc&quot; href=&quot;http://example.com&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;, &#x27;\n            钢铁学爬虫.\n        &#x27;]

&#x27;&#x27;&#x27;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到返回结果是列表形式。p 节点里既包含文本，又包含文本，最后统一返回列表。&lt;/p&gt;

&lt;p&gt;需要注意，列表中的每个元素都是 p 节点的直接子节点。比如第一个 a 节点里面的span节点，这相当于子孙节点了，但返回结果并没有单独把span节点列出来。所以说，contents属性得到的结果是直接子节点的列表。&lt;/p&gt;

&lt;p&gt;同样，我们可以调用children属性得到相应的结果：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;from bs4 import BeautifulSoup
soup = BeautifulSoup(html, &#x27;lxml&#x27;)
print(soup.p.children)
for i, child in enumerate(soup.p.children):
    print(i, child)
&#x27;&#x27;&#x27;
&amp;lt;list_iterator object at 0x0000000001D9A1C0&amp;gt;
0 
            钢铁知识库

1 &amp;lt;a class=&quot;钢铁学数据分析&quot; href=&quot;http://a.com&quot; id=&quot;link1&quot;&amp;gt;
&amp;lt;span&amp;gt;Elsie&amp;lt;/span&amp;gt;
&amp;lt;/a&amp;gt;
2 

3 &amp;lt;a class=&quot;钢铁学自动化&quot; href=&quot;http://b.com&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt;
4  
            and

5 &amp;lt;a class=&quot;cccc&quot; href=&quot;http://example.com&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;
6 
            钢铁学爬虫.
&#x27;&#x27;&#x27;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还是同样的 HTML 文本，这里调用了 children 属性来选择，返回结果是生成器类型。接下来，我们用 for 循环输出相应的内容。&lt;/p&gt;

&lt;p&gt;如果要得到所有的子孙节点的话，可以调用 descendants 属性：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;&amp;lt;generator object Tag.descendants at 0x000001D77A90E570&amp;gt;
0 
            钢铁知识库

1 &amp;lt;a class=&quot;钢铁学数据分析&quot; href=&quot;http://a.com&quot; id=&quot;link1&quot;&amp;gt;
&amp;lt;span&amp;gt;Elsie&amp;lt;/span&amp;gt;
&amp;lt;/a&amp;gt;
2 

3 &amp;lt;span&amp;gt;Elsie&amp;lt;/span&amp;gt;
4 Elsie
5 

6 

7 &amp;lt;a class=&quot;钢铁学自动化&quot; href=&quot;http://b.com&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt;
8 Lacie
9  
            and

10 &amp;lt;a class=&quot;cccc&quot; href=&quot;http://example.com&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;
11 Tillie
12 
            钢铁学爬虫.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时返回结果还是生成器。遍历输出一下可以看到，这次的输出结果就包含了 span 节点。descendants 会递归查询所有子节点，得到所有的子孙节点。&lt;/p&gt;

&lt;p&gt;除此之外，还有父节点&lt;code&gt;parent&lt;/code&gt; 和祖先节点&lt;code&gt;parents&lt;/code&gt;，兄弟节点&lt;code&gt;next_sibling&lt;/code&gt;和&lt;code&gt;previous_siblings&lt;/code&gt; 日常用得少不再演示，后续需要自行查官方文档即可。&lt;/p&gt;

&lt;h2&gt;方法选择器&lt;/h2&gt;

&lt;p&gt;前面聊的通过属性选择节点，但如果进行比较复杂的话还是比较繁琐。幸好BeautifulSoup还为我们提供另外一些查询方法，比如find_all 和 find ，调用他们传入相应参数就可以灵活查询。&lt;/p&gt;

&lt;h3&gt;find_all&lt;/h3&gt;

&lt;p&gt;顾名思义，就是查询所有符合条件的元素，可以给它传入一些属性或文本来得到符合条件的元素，功能十分强大。&lt;/p&gt;

&lt;p&gt;它的 API 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find_all(name , attrs , recursive , text , **kwargs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以根据节点名来查询元素，下面我们用一个实例来感受一下：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html5=&#x27;&#x27;&#x27;
&amp;lt;div class=&quot;panel&quot;&amp;gt;
    &amp;lt;div class=&quot;panel-heading&quot;&amp;gt;
        &amp;lt;h4&amp;gt;Hello&amp;lt;/h4&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;panel-body&quot;&amp;gt;
        &amp;lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;钢铁&amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;知识&amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;仓库&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
        &amp;lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;python&amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;java&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&#x27;&#x27;&#x27;
from bs4 import BeautifulSoup
soup = BeautifulSoup(html5, &#x27;lxml&#x27;)
print(soup.find_all(name=&#x27;ul&#x27;))
print(type(soup.find_all(name=&#x27;ul&#x27;)[0]))
&#x27;&#x27;&#x27;
[&amp;lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&amp;gt;
&amp;lt;li class=&quot;element&quot;&amp;gt;钢铁&amp;lt;/li&amp;gt;
&amp;lt;li class=&quot;element&quot;&amp;gt;知识&amp;lt;/li&amp;gt;
&amp;lt;li class=&quot;element&quot;&amp;gt;仓库&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;, &amp;lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&amp;gt;
&amp;lt;li class=&quot;element&quot;&amp;gt;python&amp;lt;/li&amp;gt;
&amp;lt;li class=&quot;element&quot;&amp;gt;java&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;]
&amp;lt;class &#x27;bs4.element.Tag&#x27;&amp;gt;
&#x27;&#x27;&#x27;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到返回了一个列表，分别是两个ul长度为2，且类型依然是bs4.element.Tag类型。&lt;/p&gt;

&lt;p&gt;因为都是Tag类型，所以依然可以继续嵌套查询，还是同样文本，查询ul节点后再继续查询内部li节点。&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;from bs4 import BeautifulSoup
soup = BeautifulSoup(html5, &#x27;lxml&#x27;)
for ul in soup.find_all(name=&#x27;ul&#x27;):
    print(ul.find_all(name=&#x27;li&#x27;))
&#x27;&#x27;&#x27;
[&amp;lt;li class=&quot;element&quot;&amp;gt;钢铁&amp;lt;/li&amp;gt;, &amp;lt;li class=&quot;element&quot;&amp;gt;知识&amp;lt;/li&amp;gt;, &amp;lt;li class=&quot;element&quot;&amp;gt;仓库&amp;lt;/li&amp;gt;]
[&amp;lt;li class=&quot;element&quot;&amp;gt;python&amp;lt;/li&amp;gt;, &amp;lt;li class=&quot;element&quot;&amp;gt;java&amp;lt;/li&amp;gt;]
&#x27;&#x27;&#x27;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回结果是列表类型，元素依然是Tag类型。&lt;/p&gt;

&lt;p&gt;接下来我们可以遍历每个li获取它的文本：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;for ul in soup.find_all(name=&#x27;ul&#x27;):
    print(ul.find_all(name=&#x27;li&#x27;))
    for li in ul.find_all(name=&#x27;li&#x27;):
        print(li.string)
&#x27;&#x27;&#x27;
[&amp;lt;li class=&quot;element&quot;&amp;gt;钢铁&amp;lt;/li&amp;gt;, &amp;lt;li class=&quot;element&quot;&amp;gt;知识&amp;lt;/li&amp;gt;, &amp;lt;li class=&quot;element&quot;&amp;gt;仓库&amp;lt;/li&amp;gt;]
钢铁
知识
仓库
[&amp;lt;li class=&quot;element&quot;&amp;gt;python&amp;lt;/li&amp;gt;, &amp;lt;li class=&quot;element&quot;&amp;gt;java&amp;lt;/li&amp;gt;]
python
java
&#x27;&#x27;&#x27;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;find&lt;/h3&gt;

&lt;p&gt;除了 find_all 方法，还有 find 方法，不过 find 方法返回的是单个元素，也就是第一个匹配的元素，而 find_all 返回的是所有匹配的元素组成的列表。示例如下：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html5=&#x27;&#x27;&#x27;
&amp;lt;div class=&quot;panel&quot;&amp;gt;
    &amp;lt;div class=&quot;panel-heading&quot;&amp;gt;
        &amp;lt;h4&amp;gt;Hello&amp;lt;/h4&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;panel-body&quot;&amp;gt;
        &amp;lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;钢铁&amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;知识&amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;仓库&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
        &amp;lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;python&amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;java&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&#x27;&#x27;&#x27;
from bs4 import BeautifulSoup
soup = BeautifulSoup(html5, &#x27;lxml&#x27;)
print(soup.find(name=&#x27;ul&#x27;))
print(type(soup.find(name=&#x27;ul&#x27;)))
print(soup.find(class_=&#x27;list&#x27;))


&#x27;&#x27;&#x27;
&amp;lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&amp;gt;
&amp;lt;li class=&quot;element&quot;&amp;gt;钢铁&amp;lt;/li&amp;gt;
&amp;lt;li class=&quot;element&quot;&amp;gt;知识&amp;lt;/li&amp;gt;
&amp;lt;li class=&quot;element&quot;&amp;gt;仓库&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;class &#x27;bs4.element.Tag&#x27;&amp;gt;
&amp;lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&amp;gt;
&amp;lt;li class=&quot;element&quot;&amp;gt;钢铁&amp;lt;/li&amp;gt;
&amp;lt;li class=&quot;element&quot;&amp;gt;知识&amp;lt;/li&amp;gt;
&amp;lt;li class=&quot;element&quot;&amp;gt;仓库&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&#x27;&#x27;&#x27;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回结果不再是列表形式，而是第一个匹配的节点元素，类型依然是 Tag 类型。&lt;/p&gt;

&lt;h3&gt;其它方法&lt;/h3&gt;

&lt;p&gt;另外还有许多的查询方法，用法与前面介绍的 find_all、find 方法完全相同，只不过查询范围不同，在此做一下简单的说明。&lt;/p&gt;

&lt;p&gt;find_parents 和 find_parent：前者返回所有祖先节点，后者返回直接父节点。&lt;/p&gt;

&lt;p&gt;find_next_siblings 和 find_next_sibling：前者返回后面所有的兄弟节点，后者返回后面第一个兄弟节点。&lt;/p&gt;

&lt;p&gt;find_previous_siblings 和 find_previous_sibling：前者返回前面所有的兄弟节点，后者返回前面第一个兄弟节点。&lt;/p&gt;

&lt;p&gt;find_all_next 和 find_next：前者返回节点后所有符合条件的节点，后者返回第一个符合条件的节点。&lt;/p&gt;

&lt;p&gt;find_all_previous 和 find_previous：前者返回节点前所有符合条件的节点，后者返回第一个符合条件的节点。&lt;/p&gt;

&lt;h2&gt;CSS选择器&lt;/h2&gt;

&lt;p&gt;BeautifulSoup还提供了另外一种选择器，CSS选择器。如果对 Web 开发熟悉的话，那么对 CSS 选择器肯定也不陌生。如果不熟悉的话，可以参考 &lt;a href=&quot;http://www.w3school.com.cn/cssref/css_selectors.asp&quot;&gt;http://www.w3school.com.cn/cssref/css_selectors.asp&lt;/a&gt; 了解。&lt;/p&gt;

&lt;p&gt;使用 CSS 选择器，只需要调用 select 方法，传入相应的 CSS 选择器即可，我们用一个实例来感受一下：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html5=&#x27;&#x27;&#x27;
&amp;lt;div class=&quot;panel&quot;&amp;gt;
    &amp;lt;div class=&quot;panel-heading&quot;&amp;gt;
        &amp;lt;h4&amp;gt;Hello&amp;lt;/h4&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;panel-body&quot;&amp;gt;
        &amp;lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;钢铁&amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;知识&amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;仓库&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
        &amp;lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;python&amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;element&quot;&amp;gt;java&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&#x27;&#x27;&#x27;
from bs4 import BeautifulSoup
soup = BeautifulSoup(html5, &#x27;lxml&#x27;)
print(soup.select(&#x27;.panel .panel-heading&#x27;))
print(soup.select(&#x27;ul li&#x27;))
print(soup.select(&#x27;#list-2 .element&#x27;))
print(type(soup.select(&#x27;ul&#x27;)[0]))
&#x27;&#x27;&#x27;
[&amp;lt;div class=&quot;panel-heading&quot;&amp;gt;
&amp;lt;h4&amp;gt;Hello&amp;lt;/h4&amp;gt;
&amp;lt;/div&amp;gt;]
[&amp;lt;li class=&quot;element&quot;&amp;gt;钢铁&amp;lt;/li&amp;gt;, &amp;lt;li class=&quot;element&quot;&amp;gt;知识&amp;lt;/li&amp;gt;, &amp;lt;li class=&quot;element&quot;&amp;gt;仓库&amp;lt;/li&amp;gt;, &amp;lt;li class=&quot;element&quot;&amp;gt;python&amp;lt;/li&amp;gt;, &amp;lt;li class=&quot;element&quot;&amp;gt;java&amp;lt;/li&amp;gt;]
[&amp;lt;li class=&quot;element&quot;&amp;gt;python&amp;lt;/li&amp;gt;, &amp;lt;li class=&quot;element&quot;&amp;gt;java&amp;lt;/li&amp;gt;]
&amp;lt;class &#x27;bs4.element.Tag&#x27;&amp;gt;
&#x27;&#x27;&#x27;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果为所有匹配的节点。例如&lt;code&gt;select(&#x27;ul li&#x27;)&lt;/code&gt;则是所有ul节点下面的所有li节点，返回结果是列表。&lt;/p&gt;

&lt;p&gt;select 方法同样支持嵌套选择(soup.select(&#x27;ul&#x27;))、属性获取(ul[&#x27;id&#x27;])，以及文本获取(li.string/li.get_text())&lt;/p&gt;

&lt;p&gt;---- 钢铁知识库 2022.08.22&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;到此 BeautifulSoup 的使用介绍基本就结束了，最后钢铁知识库做一下简单的总结：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;推荐使用 LXML 解析库，速度快、容错能力强。&lt;/li&gt;
&lt;li&gt;建议使用 find、find_all 方法查询匹配单个结果或者多个结果。&lt;/li&gt;
&lt;li&gt;如果对 CSS 选择器熟悉的话可以使用 select 匹配，可以像Xpath一样匹配所有。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>680c0adbfd8ca76147e7650227094a41</guid>
<title>老手也常误用！详解 Go channel 内存泄漏问题</title>
<link>https://toutiao.io/k/m3mjhpl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一说到 go channel，很多人会使用“优秀”“哲学”这些词汇来描述。殊不知，go channel 恐怕还是 golang 中最容易造成问题的特性之一。很多情况下，我们使用 go channel 时，常常以为可以关闭 channel，但实际上却没有关闭，这就是导致 go channel 内存泄漏的元凶。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;阅读本文前要求读者熟悉 go channel 的基本知识。如果你不够了解 go channel，那么可以先阅读《新手使用 go channel 需要注意的问题》。本文会默认你已经了解相关内容。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;情境一：&lt;code&gt;select-case&lt;/code&gt; 误用导致的内存泄露&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话说少，先看代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestLeakOfMemory&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;NumGoroutine:&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;   chanLeakOfMemory()&lt;br/&gt;   time.Sleep(time.Second * &lt;span&gt;3&lt;/span&gt;) &lt;span&gt;// 等待 goroutine 执行，防止过早输出结果&lt;/span&gt;&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;NumGoroutine:&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;chanLeakOfMemory&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   errCh := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; error) &lt;span&gt;// (1)&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; { &lt;span&gt;// (5)&lt;/span&gt;&lt;br/&gt;      time.Sleep(&lt;span&gt;2&lt;/span&gt; * time.Second)&lt;br/&gt;      errCh &amp;lt;- errors.New(&lt;span&gt;&quot;chan error&quot;&lt;/span&gt;) &lt;span&gt;// (2)&lt;/span&gt;&lt;br/&gt;   }()&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt;   &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(time.Second): &lt;span&gt;// (3) 大家也经常在这里使用 &amp;lt;-ctx.Done()&lt;/span&gt;&lt;br/&gt;      fmt.Println(&lt;span&gt;&quot;超时&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; err = &amp;lt;-errCh: &lt;span&gt;// (4)&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;         fmt.Println(err)&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;         fmt.Println(&lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家认为输出的结果是什么？正确的输出结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;NumGoroutine: 2&lt;br/&gt;超时&lt;br/&gt;NumGoroutine: 3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 go channel 导致内存泄漏的经典场景。根据输出结果（开始有两个 goroutine，结束时有三个 goroutine），我们可以知道，直到测试函数结束前，仍有一个 goroutine 没有退出。原因是由于 (1) 处创建的 errCh 是不含缓存队列的 channel，如果 channel 只有发送方发送，那么发送方会阻塞；如果 channel 只有接收方，那么接收方会阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到由于没有发送方往 errCh 发送数据，所以 (4) 处代码一直阻塞。直到 (3) 处超时后，打印“超时”，函数退出，(4) 处代码都未接收成功。而 (2) 处的所在的 goroutine 在“超时”被打印后，才开始发送。由于外部的 goroutine 已经退出了，errCh 没有接收者，导致 (2) 处一直阻塞。因此 (2) 处代码所在的协程一直未退出，造成了内存泄漏。如果代码中有许多类似的代码，或在 for 循环中使用了上述形式的代码，随着时间的增长会造成多个未退出的 gorouting，最终导致程序 OOM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况其实还比较简单。我们只需要为 channel 增加一个缓存队列。即把 (1) 处代码改为 &lt;code&gt;errCh := make(chan error, 1)&lt;/code&gt; 即可。修改后输出如下所示，可知我们创建的 goroutine 已经退出了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;NumGoroutine: 2&lt;br/&gt;超时&lt;br/&gt;NumGoroutine: 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能会有人想要使用 &lt;code&gt;defer close(errCh)&lt;/code&gt; 关闭 channel。比如把 (1) 处代码改为如下形式(错误)：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;errCh := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; error)&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(errCh)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 (2) 处代码没有接收者，所以一直阻塞。直到 &lt;code&gt;close(errCh)&lt;/code&gt; 运行，(2) 处仍在阻塞。这导致关闭 channel 时，仍有 goroutine 在向 errCh 发送。然而在 golang 中，在向 channel 发送时不能关闭 channel，否则会 panic。因此这种方式是错误的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又或在 (5) 处 goroutine 的第一句加上 &lt;code&gt;defer close(errCh)&lt;/code&gt;。由于 (2) 处阻塞， &lt;code&gt;defer close(errCh)&lt;/code&gt; 会一直得不到执行。因此也是错误的。即便对调 (2) 处和 (4) 处的发送者和接收者，也会因为 channel 关闭，导致输出无意义的零值。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;情景二：&lt;code&gt;for-range&lt;/code&gt; 误用导致的内存泄露&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述示例中只有一个发送者，且只发送一次，所以增加一个缓存队列即可。但在其他情况下，可能不止有一个发送者（或者不只发送一次），所以这个方案要求，缓存队列的容量需要和发送次数一致。一旦缓存队列容量被用完后，再有发送者发送就会阻塞发送者 goroutine。如果恰好此时接收者退出了，那么仍然至少会有一个 goroutine 无法退出，从而造成内存泄漏。就比如下面的代码。不知道经过上面的讲解，读者是否能够发现其中的问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestLeakOfMemory2&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;NumGoroutine:&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;   chanLeakOfMemory2()&lt;br/&gt;   time.Sleep(time.Second * &lt;span&gt;3&lt;/span&gt;) &lt;span&gt;// 等待 goroutine 执行，防止过早输出结果&lt;/span&gt;&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;NumGoroutine:&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;chanLeakOfMemory2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   ich := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;) &lt;span&gt;// (3)&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// sender&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(ich)&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++ {&lt;br/&gt;         ich &amp;lt;- i&lt;br/&gt;         time.Sleep(time.Millisecond) &lt;span&gt;// 控制一下，别发太快&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;   }()&lt;br/&gt;   &lt;span&gt;// receiver&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      ctx, cancel := context.WithTimeout(context.Background(), time.Second)&lt;br/&gt;      &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;range&lt;/span&gt; ich { &lt;span&gt;// (2)&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; ctx.Err() != &lt;span&gt;nil&lt;/span&gt; { &lt;span&gt;// (1)&lt;/span&gt;&lt;br/&gt;            fmt.Println(ctx.Err())&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;         }&lt;br/&gt;         fmt.Println(i)&lt;br/&gt;      }&lt;br/&gt;   }()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// NumGoroutine: 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// ...(省略)...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 789&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// context deadline exceeded&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// NumGoroutine: 3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们聪明地使用了 channel 的缓存队列。我们以为我们循环发送，发完之后就会把 channel 关闭。而且我们使用 for range 获取 channel 的值，会一直获取，直到 channel 关闭。但在代码 (1) 处，接收者的 goroutine 中，我们加了一个判断语句。这会让代码 (2) 处的 channel 还没被接收完就退出了接收者 goroutine。尽管代码 (3) 处有缓存，但是因为发送 channel 在 for 循环中，缓存队列很快就会被占满，阻塞在第 101 的位置。所以这种情况我们要使用一个额外的 stop channel 来终结发送者所在的 goroutine。方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestLeakOfMemory2&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;NumGoroutine:&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;   chanLeakOfMemory2()&lt;br/&gt;   time.Sleep(time.Second * &lt;span&gt;3&lt;/span&gt;) &lt;span&gt;// 等待 goroutine 执行，防止过早输出结果&lt;/span&gt;&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;NumGoroutine:&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;chanLeakOfMemory2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   ich := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;   stopCh := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt;   &lt;span&gt;// sender&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(ich)&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++ {&lt;br/&gt;         &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;         &lt;span&gt;case&lt;/span&gt; &amp;lt;-stopCh:&lt;br/&gt;             &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;case&lt;/span&gt; ich &amp;lt;- i:&lt;br/&gt;         }&lt;br/&gt;         time.Sleep(time.Millisecond) &lt;span&gt;// 控制一下，别发太快&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;   }()&lt;br/&gt;   &lt;span&gt;// receiver&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      ctx, cancel := context.WithTimeout(context.Background(), time.Second)&lt;br/&gt;      &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;range&lt;/span&gt; ich {&lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; ctx.Err() != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            fmt.Println(ctx.Err())&lt;br/&gt;            &lt;span&gt;close&lt;/span&gt;(stopCh)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;         }&lt;br/&gt;         fmt.Println(i)&lt;br/&gt;      }&lt;br/&gt;   }()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// NumGoroutine: 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// ...(省略)...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 789&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// context deadline exceeded&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// NumGoroutine: 2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有人会问，要是接收者 goroutine 关闭 stop channel 的时候，发送者又继续发送了怎么办？不会内存泄漏吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是不会的。因为只可能存在两种情况，一种是发送者把数据发送到了缓存中，发送者想要继续发送时，select 发现 stop channel 已经关闭，发送者 goroutine 会退出；一种是 channel 没有缓存了，发送者只能阻塞，此时 select 发现 stop channel 已经关闭，发送者 goroutine 也会退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，通常情况下，我们只会遇到这两种 go channel 造成内存泄漏的情况（一个发送者导致的内存泄漏和多个发送者导致的内存泄漏）。如果你了解其他 go channel 造成的内存泄漏情况，也欢迎在评论区留言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们仔细观察上述两个内存泄漏的案例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;chanLeakOfMemory&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   errCh := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; error) &lt;span&gt;// (1)&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; { &lt;span&gt;// (5)&lt;/span&gt;&lt;br/&gt;      time.Sleep(&lt;span&gt;2&lt;/span&gt; * time.Second)&lt;br/&gt;      errCh &amp;lt;- errors.New(&lt;span&gt;&quot;chan error&quot;&lt;/span&gt;) &lt;span&gt;// (2)&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; errCh&lt;br/&gt;   }()&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt;   &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(time.Second): &lt;span&gt;// (3) 大家也经常在这里使用 &amp;lt;-ctx.Done()&lt;/span&gt;&lt;br/&gt;      fmt.Println(&lt;span&gt;&quot;超时&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; err = &amp;lt;-errCh: &lt;span&gt;// (4)&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;         fmt.Println(err)&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;         fmt.Println(&lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;chanLeakOfMemory2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   ich := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;) &lt;span&gt;// (3)&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// sender&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(ich)&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++ {&lt;br/&gt;         ich &amp;lt;- i&lt;br/&gt;         time.Sleep(time.Millisecond) &lt;span&gt;// 控制一下，别发太快&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;   }()&lt;br/&gt;   &lt;span&gt;// receiver&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      ctx, cancel := context.WithTimeout(context.Background(), time.Second)&lt;br/&gt;      &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;range&lt;/span&gt; ich { &lt;span&gt;// (2)&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; ctx.Err() != &lt;span&gt;nil&lt;/span&gt; { &lt;span&gt;// (1)&lt;/span&gt;&lt;br/&gt;            fmt.Println(ctx.Err())&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;         }&lt;br/&gt;         fmt.Println(i)&lt;br/&gt;      }&lt;br/&gt;   }()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现&lt;strong&gt;不论发送者发送一次还是多次，如果接收者所在 goroutine 不会在接收完 channel 中的数据之前结束，那么就不会造成内存泄漏。&lt;/strong&gt; 如果接收者需要在 channel 关闭之前提前退出，为防止内存泄漏，在发送者与接收者发送次数是一对一时，应设置 channel 缓冲队列为 1；在发送者与接收者的发送次数是多对多时，应使用专门的 stop channel 通知发送者关闭相应 channel。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[1] 如何退出协程 goroutine (超时场景): https://geektutu.com/post/hpg-timeout-goroutine.html&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[2] go channel 关闭的那些事儿: https://juejin.cn/post/7033671944587182087&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>26833cf24bd032283a5d41f8c0b3d974</guid>
<title>重新推荐一下ssseg，一个简单好用的通用分割框架</title>
<link>https://toutiao.io/k/qufjf59</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;只对这个项目相关的有趣应用感兴趣的小伙伴可以直接跳过这个part。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;项目地址&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;https:&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;更新的内容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 增加了&lt;/span&gt;&lt;span&gt;一些SOTA模型的支持，例如BEiT和ConvNeXt，相关模型和训练log都已经在相关文档里提供：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46308186195826645&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZTbkic2pYRo6JcTjaHU0lkzfcJ8gVQV14zuTDWKLdmprib6jMOENRdfhwCxo8lR90WJHJZZicbTFiaYFdDE8bX8uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1246&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. Config文件结构调整，方便大家更好地搭建训练模型，例如训练backbone为BEiT的upernet，你只需要在Config里这样定义：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SEGMENTOR_CFG = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;type&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;upernet&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;num_classes&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;benchmark&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__keyword&quot;&gt;True&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;align_corners&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__keyword&quot;&gt;False&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;backend&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;nccl&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;norm_cfg&#x27;&lt;/span&gt;: {&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;type&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;syncbatchnorm&#x27;&lt;/span&gt;},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;act_cfg&#x27;&lt;/span&gt;: {&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;type&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;relu&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;inplace&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__keyword&quot;&gt;True&lt;/span&gt;},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;backbone&#x27;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;type&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;beit_base_patch16_224_pt22k_ft22k&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;series&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;beit&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;pretrained&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__keyword&quot;&gt;True&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;selected_indices&#x27;&lt;/span&gt;: (&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;norm_cfg&#x27;&lt;/span&gt;: {&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;type&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;layernorm&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;eps&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1e-6&lt;/span&gt;},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;head&#x27;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;feature2pyramid&#x27;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;embed_dim&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;768&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;rescales&#x27;&lt;/span&gt;: [&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0.5&lt;/span&gt;],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;in_channels_list&#x27;&lt;/span&gt;: [&lt;span class=&quot;code-snippet__number&quot;&gt;768&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;768&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;768&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;768&lt;/span&gt;],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;feats_channels&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;512&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;pool_scales&#x27;&lt;/span&gt;: [&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;dropout&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;0.1&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;auxiliary&#x27;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;in_channels&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;768&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;out_channels&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;512&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;dropout&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;0.1&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;而不需要像之前那样分别在&lt;span&gt;SEGMENTOR_CFG&lt;/span&gt;里去定义FPN，decoder等等模块的参数。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 支持借助slurm进行多机训练，例如：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;git&lt;/span&gt; clone https://github.com/SegmentationBLWX/sssegmentation&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;cd&lt;/span&gt; sssegmentation&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;bash&lt;/span&gt; scripts/slurmtrain.sh TEST(即分组名称) \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attribute&quot;&gt;deeplab&lt;/span&gt;(任务Tag) \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attribute&quot;&gt;4&lt;/span&gt;(使用的卡数) \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attribute&quot;&gt;ssseg&lt;/span&gt;/configs/deeplabv3/deeplabv3_resnet50os8_ade20k.py(config文件路径)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;4. 对优化器和scheduler进行了重构，方便更好地适配当前主流的以transformer为backbone的模型训练所需的tricks。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5. 部分Bug修复和模型调用方式的优化等等。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;快速使用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;项目repo提供了几百个训练好的分割模型供大家调用，具体而言，需要先安装一下我们的SSSegmentation：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;pip&lt;/span&gt; install sssegmentation&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;然后简单写个脚本即可：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import torch.utils.model_zoo as model_zoo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;from ssseg.modules.models.segmentors import BuildSegmentor&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;config = {} &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;weight_url = &#x27;&#x27; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;segmentor = BuildSegmentor(config, &#x27;TEST&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;segmentor.load_state_dict(model_zoo.load_url(weight_url, map_location=&#x27;cpu&#x27;)[&#x27;model&#x27;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;results = segmentor(imgs)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;相关的config和weight_url可以根据自己想要调用的模型在这里找到：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__symbol&quot;&gt;https:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/sssegmentation.readthedocs.io/en&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/latest/&lt;/span&gt;ModelZoo.html&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;当然，你也可以参考在线文档进行环境配置和模型调用：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__symbol&quot;&gt;https:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/sssegmentation.readthedocs.io/en&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/latest/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;git&lt;/span&gt; clone https://github.com/SegmentationBLWX/sssegmentation&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;wget https://github.com/SegmentationBLWX/modelstore/releases/download/ssseg_pspnet/pspnet_resnet101os8_ade20k_train.pth&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;bash scripts/inference.sh ssseg/configs/pspnet/pspnet_resnet101os8_ade20k.py pspnet_resnet101os8_ade20k/epoch_130.pth --imagepath dog.jpg&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3a9b25c1dbd4f576335839ba144a7a1e</guid>
<title>你真的需要Apple TV吗？不如自制一个Android TV！</title>
<link>https://toutiao.io/k/52qhy81</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;去年我写了一篇《树莓派家用指北》，介绍了树莓派是如何作为家庭服务器改善我的生活的，指路链接 👉 &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484910&amp;amp;idx=1&amp;amp;sn=c539198095c8d4828d06f933777510a9&amp;amp;chksm=ceb3d15cf9c4584aa5c5b4e104e8aba0ad41f1df5e4fc57588400939d3e6a208135476e34140&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;树莓派家用指北&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;树莓派家用指北&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们的主角依旧是我的那个树莓派，只是以另一种形式在我的家里发光发热——电视盒子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这可能有人会好奇，这个树莓派用作电视盒子后，原先的家庭服务器怎么办？事实上我之所以把这个树莓派做成电视盒子，第一个原因是我搬家了，需要重新升级规划下家里的软件系统，第二是我用 NAS 替代了原先的树莓派用作家庭服务器（有机会的话以后讲一下）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以为了不让这个“理财产品”就这么吃灰下去，我一直积极探索可能的用处，终于，我发现了一个最适合他的场景——Android TV。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;为什么会想到 Android TV？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搬家之后，新屋子里有一个电视 + 办宽带送的中国移动的电视盒子，第一次打开它的时候，卡顿的系统、上古的 UI、繁杂的广告让我不禁感叹，这真的是 2022 年的东西吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;心想那要不买一个 Apple TV 吧？可再看看价格，不免囊中羞涩，算了算了，还是留点老婆本吧。况且 Apple TV 这么好的盒子用在一个只有 1080P 的电视里属实是有些浪费了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49859154929577465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gyby8dXA5fdSPqCvX08kuHVhlyqGwA1TGgHWG5lWkoAbibaSibMP9FzuoIGibThMvZffmG3uIp4UL2dDuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1420&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然用不了苹果的电视服务，用安卓的总可以吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是我又去搜索了一些国内的电视盒子，什么小米的、当贝的、荣耀的，横向比较了一下，不是性能孱弱（通常都是 2GB+32GB）就是广告遍地，而且还不能看海外电视。当然了，最关键的是还要多花一笔钱，想了想还是放弃了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然国内的安卓盒子不行，为什么不试试原生的 Android TV 呢？2022 年了，原生的 Android TV 应该有不少的发展了吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抱着试一试的心态，我打开了 Android 开发者的官网，发现 2022 年的 Android TV 无论是 UI 还是体验，都比以前有了长足进步，现在就差一个载体，而我刚好有这个最好的载体——树莓派。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4972253052164262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gyby8dXA5fdSPqCvX08kuHVhlOzicZCoyg24N3hUno6DAj2Z9fgSXE5D7MqeYia3PhP6apYNQibFqphPZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1802&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;行动起来&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文不是一个教学贴，因此不会手把手的记录整个流程，简单介绍一些我在自制这一过程中的关键点以及可能出现的问题。参考的帖子：https://konstakang.com/devices/rpi4/LineageOS18-ATV/&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;准备工作&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你需要准备的东西有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一个树莓派 3B/4B，至少有 2GB RAM，建议 32GB+ 的 SD 卡（我的是 8GB RAM + 256GB ROM）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一根 mini HDMI 转 HDMI/DP/VGA 数据线（根据你家的电视接口定）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;树莓派风扇（如果有最好，毕竟是 24 小时不关机的，散热还是有必要的）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我选择的是 konstakang 提供的 LineageOS 18.1 Android TV (Android 11)，没有选择上 Android 12 的原因是当时还没有出 12 的 GApps（谷歌提供的一些套件），再加上一个电视盒子也没必要追求那么新的操作系统（国内还有不少手机停在 Android 10 万年不更新）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rom 地址在 👉https://www.androidfilehost.com/?fid=17825722713688273838&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给树莓派刷入安卓系统的方法和刷入其他系统的方法基本一致，建议直接使用 Raspberry Pi Imager 烧录系统。工具地址 👉https://www.raspberrypi.com/software/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就和安卓刷机没什么区别了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;resize 你的 SD 卡&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1717557251908397&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gyby8dXA5fdSPqCvX08kuHVhl2OuTNkK9RyIP56l3xAus49olRKyx33p3jUaViaDkpyCMHgsGuPKibMTA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1572&quot;/&gt;刚烧录的 Android TV 系统会出现不正常分区的问题，我们需要将 SD 卡上的空白空间都利用起来，执行 resize 的流程也很简单，只需要使用 TWRP 将提供的 resize.zip 刷入系统即可。流程和安卓刷机是一样的，需要借助一个叫做 TWRP 的工具，有安卓刷机经验的小伙伴应该很了解这个步骤。有关 TWRP 的介绍这里就不展开了，移步 👉https://twrp.me&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gyby8dXA5fdSPqCvX08kuHVhl5iaYLzsxN5AxZfIRLhEicYR8ZkLdR4HLsWnIaPYicb5Xfc8a8iaC8icicgJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;resize.zip 的下载地址：https://androidfilehost.com/?fid=2981970449027577728&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;root &amp;amp; GApps 的安装&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gyby8dXA5fdSPqCvX08kuHVhljGErGoPiaWOzBjGPOmB6vbiaicxmZUccG0peh5VCLPKeRKIQNMyMcmTyA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然选择了自建 Android TV，肯定是希望可以享受到一些海外的优质媒体服务，那么谷歌套件就必不可少了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要借助 magisk 实现 root，然后刷入一些谷歌套件 GApps（需要科学上网），通常我们会选择 OpenGApps（感谢开源 🙏）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rpi-magisk 地址：https://androidfilehost.com/?fid=2981970449027577730&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenGApps for andriod tv：https://opengapps.org/?arch=arm64&amp;amp;api=11.0&amp;amp;variant=tvstock&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;其他实用技巧&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;SSH 连接你的 Android TV&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;打开开发者选项&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;连接电视盒子&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;adb connect 192.168.2.134&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;以 root 方式访问 adb&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19562575941676794&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gyby8dXA5fdSPqCvX08kuHVhlrIgl2mFJl4plQ0AUq9r4MkziasicePEugaApoyhiak9sObW2SIZbMlJyQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1646&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;adb root&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;从 android tv 获取 ssh 访问的 private key&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;adb pull /data/ssh/ssh_host_rsa_key my_private_key&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;文件添加权限&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因为该文件是利用 adb 下载得到的，利用该文件执行 ssh 命令时会提示权限过高，因此需要设置权限为 400&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.26700680272108845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gyby8dXA5fdSPqCvX08kuHVhlw7EdVBNI2HicLibt5oiaP4PjlB6pbgFtbMae3fia3cJCHv1druLdXegr0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1176&quot;/&gt;&lt;/figure&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod 400 my_private_key&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;ssh 连接树莓派&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5886666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gyby8dXA5fdSPqCvX08kuHVhlADWZJycBLpBTVYq53yEcRUDGibaISJiceOVtMJ3ae3LrD5U5ZlicayiakQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1500&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ssh -i my_private_key root@&amp;lt;你的树莓派地址&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;查看当前 cpu 温度&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过查看你的树莓派运行时的温度，来决定是否需要为其加装一个风扇&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat /sys/class/thermal/thermal_zone0/temp&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09237875288683603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gyby8dXA5fdSPqCvX08kuHVhlOaDfVb5fhYMLZOOYibribicWt2J9AZR204FwNKKD7ac2aScVFSiaIkg03Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;866&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;最后&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前这个 Android TV 服务在我家里已经运行了有半年了，配合着家里的软路由实现入口级的科学上网以及 NAS 用作家庭媒体中心，最后利用小爱音箱红外版接入了小米智能家居，已经可以实现不逊色于 Apple TV 的娱乐服务。不信，你看看我家的猫咪都爱上了看电视呢！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8568464730290456&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gyby8dXA5fdSPqCvX08kuHVhlIx1vDFUWAdsenxtM6UBaYIicjyNWJHCDobflrrJnJ1zkiasevETtfHHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;964&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>