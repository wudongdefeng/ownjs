<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bd3b35dbfbf81871fa3721da6ab35b4c</guid>
<title>东方证券：我们如何成功实施微服务</title>
<link>https://toutiao.io/k/xafz64h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;引     言&lt;/span&gt;&lt;/section&gt;&lt;p&gt;近年来，随着证券市场客户和业务量的不断攀升，以及互联网金融的兴起和金融科技的发展，各证券公司都制定了数字化转型的战略目标。为了把握新一轮数字化技术革命浪潮，企业信息系统架构正在不断升级变迁，很多企业内部的传统软件系统都开始向微服务架构转型，通过服务拆分、降低系统耦合性，达到“高内聚、低耦合”，提供更为灵活的服务支撑。&lt;/p&gt;&lt;p&gt;随着研发人员对系统进行解耦和拆分，对大量微服务实例进行有效管控、提升系统运行时的服务质量变得非常困难。在此背景下，东方证券为了顺应互联网 + 时代的潮流，响应快速更新的业务需求，迫切需要以统一、服务化的思路来进行系统建设，建设服务治理平台，通过分析服务调用关系及拓扑结构、优化服务质量、制定服务协议规范，达到新建系统与已有系统统一服务治理，实现轻应用（业务为导向，实现业务应用敏捷构建，及时响应市场需求）、重平台（将数据和核心应用转化成平台服务，成为整个架构的核心）、服务化（构建核心服务网络，简化应用开发与部署）的整体企业技术架构转型目标，实现应用全生命周期管理。&lt;/p&gt;&lt;section&gt;&lt;span&gt;微服务架构&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;单体架构&lt;/span&gt;&lt;/section&gt;&lt;p&gt;传统信息系统多采用单体架构，单体架构应用把所有的功能都打包在一个独立单元中，并当做一个整体来开发、测试和部署 [1]。Java Web 应用就是典型的单体架构应用，项目被打包成一个 WAR 包部署在同一个 WEB 容器中，其中囊括了数据访问层的 DAO 对象、业务逻辑层的各模块、表示层呈现的 UI 等功能。单体架构的优势是开发、调试、部署简单方便，在业务发展初期，信息系统的规模较小，使用传统的单体架构可以有效地支撑业务的发展。然而，随着业务的爆炸性增长，应用系统规模不断增大，单体架构将给业务系统的开发、维护、部署带来巨大的问题。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;第一，开发效率持续下降，庞大的代码规模和错综复杂的业务耦合大大增加了研发新功能的难度，开发者不仅要掌握自己负责的模块，还需要了解整个应用系统的逻辑，否则修改代码后可能会引发冲突或其他模块错误；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第二，持续迭代存在障碍，任何一个非核心功能的小修改都需要重新部署整个项目，使得系统运维中与发布相关的风险显著增加；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第三，系统可靠性变差，传统的单体架构将所有的应用都部署在同一个进程中，如果应用中某个接口发生故障，将会影响整个系统正常提供服务的能力，在巨大的瞬间流量冲击下，很容易引发系统雪崩；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第四，扩展性先天不足，单体架构的应用只能在一个维度上进行扩展，但是不同的模块可能有不同的资源需求属性，例如有的功能是计算密集型，有的则是 IO 密集型，由于它们运行在一个实例中，因此无法对特定模块进行扩展；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第五，技术僵化无法重构，各个业务使用的技术栈不得不与整个应用的技术栈捆绑在一起，很难更新 SDK 版本或使用新的技术框架。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;微服务架构&lt;/span&gt;&lt;/section&gt;&lt;p&gt;由于单体架构已不能适应现代企业信息系统的需要，近年来微服务架构被广为推崇，并在越来越多的证券公司中得以实践和落地。微服务架构是由传统的单体架构逐渐演化而来 [2]，将大型单体应用按照业务功能设计拆分成多个能独立运行、职能单一的服务，与其他服务之间通过统一协议进行通讯 [3][4]。&lt;/p&gt;&lt;p&gt;微服务架构可以很好地解决单体架构下的诸多问题：第一，将巨大的单体应用拆分成颗粒度更小的服务，服务内逻辑简单、高度内聚，易于开发和维护；第二，各个微服务独立部署，功能修改后可以针对特定部分进行发布，使得各个微服务系统能够持续化部署，加快了迭代的速度；第三，当单个服务系统出现故障时，只需要将出现故障的服务下线修复即可，不会导致整个系统的级联故障；第四，可根据不同微服务系统的访问量和资源需求，动态的实现横向扩展和纵向扩展，这大大的提高系统的利用率；第五，各个研发团队可以根据自己的需求选择编程语言和技术栈，具有更大的灵活性。&lt;/p&gt;&lt;p&gt;虽然微服务架构有着明显的优越性，但是证券公司普遍存在的系统异构化问题也给微服务架构的落地带来了巨大挑战。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（1）业务接口标准不统一，管控风险大&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;券商行业的核心系统由传统供应商组成，以东方证券经纪业务核心系统为例，分别由金仕达、新意、恒生、顶点、同花顺等厂商架构组成，SPX、T2、Rest、WebService 等多种类型服务接口存在于东方证券企业内部，多业务协同适配问题突出，服务多样性对同步、异步、流式数据等都提出了技术需求，统一化难度大；缺乏有效的关键业务流量控制技术手段；全局化平台协同与调度困难重重，缺乏全局视角对内部服务进行统一化管理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）自研系统上线面临诸多困难&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;随着金融科技的深入发展，证券行业纷纷开始进行自研核心系统，但因为缺乏统一的开发框架，各业务研发团队在具体开发过程中除了业务分析之外，还需同时会关注非常多的技术细节，如依赖服务接口对接，开发语言技能，灵活可扩展架构支撑，客户服务治理保障，对外服务协议选型，服务故障定位，请求流量控制，服务安全配置，配置管理，流量管控等，自研业务也面临着诸多现实问题。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（３）传统网关模式存在不足&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;传统核心系统基本采用网关模式进行对外服务，由网关进行接入管控，其一般具有身份认证、路由配置、负载均衡等功能，在对类似手机端这样的客户端时，其能起到比较好的作用，但用在核心机房内部服务调用就存在着明显的不足。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;采用网关模式，渠道端须自己封装 TCP SDK，进行网关切换，所有的流量都会打到单网关节点，网关本身往往会成为瓶颈；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;采用网关模式，往往通过部署多个网关节点进行横向扩展，在运维部署上就会增加相当的工作量，也消耗资源；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;采用网关模式，相当于多了一路网络跳转，增加网络耗时，在同等部署模式下，降低了系统整体能承受的并发容量，增大系统延时；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;采用网关模式，系统内部微服务对外采用网关对外服务，无法发挥出微服务自动注册，自动发现的优势，新增服务往往需要修改网关配置进行发现，整体架构退化成了传统架构模式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;理想情况下，业务人员关心业务梳理和场景定义，开发人员把相关业务转换成服务定义，借助代码生成工具自动化生成接口代码，最后根据业务实现接口内部逻辑。由开发框架和外部工具负责架构扩展性、服务治理、配置管理等一系列非业务相关的功能实现，实现业务和框架的解耦，提高开发效率。&lt;/p&gt;&lt;section&gt;&lt;span&gt;东方证券服务治理平台&lt;/span&gt;&lt;/section&gt;&lt;p&gt;完善的服务治理方案是微服务架构应用稳定运行的基石，东方证券凭借在服务治理领域的技术沉淀和实践经验，在 gRPC 框架基础上新增服务治理特性，建设了 gRPC-Nebula 服务治理框架和星辰服务治理平台，从而实现企业内部及外部服务的统一化管理，构建服务调用关系及拓扑结构，优化改进服务质量，图 1 展示了东方证券服务治理项目的总体架构。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8968609865470852&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;892&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3NUto49xFnPsibn9icutBXLwFkk9e7PfqpUictvLz3ZMOPaJUVGnqQZDmw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 1 东方证券服务治理项目总体架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;东方证券服务治理方案主要包括如下几个模块：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（1）注册中心&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;注册中心是一个分布式、高可用的配置维护系统，用于服务的注册和订阅，它存放着所有的服务描述信息以及服务接口信息。在微服务框架系统中，服务和接口的数量非常庞大，同时由于系统的动态调整，服务运行的实例数量也是动态变化的，注册中心通过将服务统一管理起来，可以有效地优化服务消费者对服务提供者的感知和管理，避免硬编码地址信息。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）服务消费者（客户端）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;服务的消费者，通过注册中心交互获取服务注册信息，基于服务注册信息发起对服务端的调用；同时，采集调用端信息发送到数据处理引擎中进行分析处理，为调用链分析提供客户端数据。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（3）服务提供者（服务端）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;服务的提供者，通过注册中心对外发布服务信息，响应消费者的服务调用请求；同时，响应控制台等发起的配置管理操作，对服务质量、安全策略、数据收集等进行配置管理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（4）信息收集器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;独立的部署的服务，收集服务调用过程中在服务提供者和服务消费者产生的服务调用、服务响应、服务异常、服务时间、调用链路、内部队列长度、安全事件等信息，收集后统一发送到数据处理引擎进行处理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（5）数据处理引擎&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数据处理引擎，对信息采集器发送过来的信息事件流进行实时分析处理，处理操作包括性能统计、依赖分析、阈值告警、相关聚类、状态跟踪、可用新分析等；同时，数据被存储到性能管理数据库，用于进一步的分析操作。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（6）服务治理门户&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;服务治理门户汇总了服务治理领域的运行数据和管理系统，它是全公司服务治理的综合平台。在服务治理门户，可以查询每个微服务的实例信息、接口信息、服务状态、依赖和被依赖关系、数据统计、服务调用追踪记录等关键信息和数据，展现了企业服务治理生态的全景图。同时服务治理平台支持黑白名单、流量控制、权重配置、主备配置、上下线状态的管理功能，支持调用量、性能、服务质量、可靠性、故障事件等对象的监控告警功能，是管理人员对微服务进行集中式管理的人机接口，也是故障定位与可视化呈现的中控界面。&lt;/p&gt;&lt;section&gt;&lt;span&gt;gRPC-Nebula 服务治理框架&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术方案&lt;/span&gt;&lt;/section&gt;&lt;p&gt;东方证券调研了目前比较流行的开源微服务框架，包括阿里巴巴的 Dubbo[5]、Facebook 的 Thirft[6]、Google 的 gRPC[7] 以及从 Spring Boot 框架发展而来的 Spring Cloud 项目 [8]，它们都具有较好的连通性、健壮性、伸缩性和拓展性，但 Dubbo 和 Spring Cloud 框架不支持多语言，Dubbo 开源社区曾有一段时间不维护更新，最近才重新启动更新。&lt;/p&gt;&lt;p&gt;因为历史原因，证券行业的原有核心系统存在多种语言开发的现状，例如核心交易系统和同花顺网上交易等系统采用 C++ 语言框架开发，账户、产品、资产配置、App 及自研类系统大多采用 Java 语言框架进行开发，为了解决证券行业天然存在的跨语言场景，最终我们选择以 gRPC 框架为基础，研发 gRPC-Nebula 服务治理框架，为业务方提供服务治理整体解决方案。&lt;/p&gt;&lt;p&gt;相比其他几种框架，gRPC 有以下优势：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;全面的多语言支持，gRPC 支持多种语言，包括 C、C++、Java、Python、PHP、Node.js、C#、Objective-C、Go、Ruby、Dart 等。目前券商网上交易和核心交易系统均是 C++ 架构，而其他自研系统大多是 Java 和 Python 架构，gRPC 能有效解决服务的跨语言调用问题；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;gRPC 在 Google 和广大开源爱好者的大力支持下，目前社区活跃、更新频繁，已在全世界多家大型科技公司内投入生产；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;gRPC 使用 Google 开源的 Protobuf 3.0 协议定义接口服务，Protobuf 是一种平台无关、语言无关、可扩展且轻便高效的序列化数据结构的协议，广泛应用于网络通信和数据存储，技术人员对 Protobuf 的熟悉有助于 gRPC 技术在企业内的推广；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;gRPC 的传输使用 HTTP/2 标准，支持同步、异步、双向流，支持 SSL 和自定义鉴权，支持 iOS、Android、Windows、Linux 等平台，可以简单地实现客户端到后台的多路复用与 RPC 调用。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;相对于原生 gRPC 框架，gRPC-Nebula 服务治理框架引入了 ZooKeeper 作为注册中心，  如图 2 所示，融合了服务注册发现、负载均衡、黑白名单、动态分组、集群容错、流量控制等服务治理机制，本章节后面的部分将详细介绍这些服务治理机制的技术方案。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8967674661105318&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;959&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3LibbnOpuRrb1KTPGcdKBKh1N5Z90Y8rhjMjNbqiaKVZv7Urvs4iaDSKLA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 2 东方证券 gRPC-Nebula 服务治理框架架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们分别对 Dubbo、原生 gRPC、gRPC- Nebula 框架进行了性能测试，如表 1 所示，gRPC- Nebula 框架的性能仅比 Dubbo 和原生 gRPC 框架低 1% 左右，满足高性能服务框架的需求。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2927536231884058&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3dvDZBecqpQEfeiaiaDtrmC2ciaOKO5cCPuexMeicricw2J8Z0iaGCeZVzlwg/640?wx_fmt=png&quot;/&gt;&lt;span&gt;表 1 多框架性能测试比较&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;服务注册发现&lt;/span&gt;&lt;/section&gt;&lt;p&gt;服务注册发现是服务治理领域最核心的机制，服务提供者在启动时向注册中心注册它提供的服务信息，服务消费者向注册中心获取服务提供者的地址列表，如图 3 所示。gRPC-Nebula 服务治理框架使用 ZooKeeper 作为注册中心，具有以下特性：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4104938271604938&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;972&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3IqicpPiczT7FkZ3GE6eNxBuNJOcAbWVbDVcJUyiakKaFde3IvDcQr4vIQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 3 服务注册发现机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;（1）具备高可用性。当注册中心任意一个节点宕机时，服务能够自动切换连接到其它正常的节点上；当注册中心全部宕机时，只影响新服务的发布与已发布服务的下线，不影响服务的正常运行，服务消费者会使用本地缓存的服务地址列表继续调用。&lt;/p&gt;&lt;p&gt;（2）保证数据一致性。所有服务消费者同一时刻从注册中心不同节点获取到的服务地址列表是同一份数据，不能出现读或写数据的不一致。ZooKeeper 使用 ZAB 协议作为其数据一致性的核心算法 [10]，是具有严格的访问控制的能力的分布式协调服务。&lt;/p&gt;&lt;p&gt;（3）服务变更主动推送。服务消费者只需要在启动时向注册中心拉取一次全量服务地址列表，其后向注册中心订阅相关服务的变更事件，一旦服务地址列表发生变更，注册中心会主动将变更的内容推送给服务消费者，服务消费者即时调整调用的服务地址。&lt;/p&gt;&lt;p&gt;（4）实时感知服务状态。注册中心与服务建立长连接，通过心跳检测机制，能够周期性地检测服务的健康状态，当服务进程意外终止或服务器宕机时，注册中心能够立刻向服务消费者推送服务下线的通知，实现故障隔离。&lt;/p&gt;&lt;section&gt;&lt;span&gt;服务路由&lt;/span&gt;&lt;/section&gt;&lt;p&gt;在生产环境上，微服务都是多实例部署，服务路由决定了服务消费者如何从服务地址列表中选择服务提供者进行调用。gRPC-Nebula 服务治理框架的服务路由以下三大机制构成：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（1）负载均衡机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;gRPC-Nebula 服务治理框架支持连接负载均衡和请求负载均衡两种模式，默认连接负载均衡，同时提供了四种负载均衡算法可供选择：随机策略、轮询策略、权重配置优先策略、一致性哈希策略。&lt;/p&gt;&lt;p&gt;随机策略即随机地选择服务提供者进行调用；轮询策略即遍历服务地址列表，每次调用时依次选择一个服务提供方进行调用；权重配置优先策略可根据配置文件或管理门户对每个服务节点配置的权重比来选择服务提供者；一致性哈希策略中，相同参数的网络请求总由同一个服务提供者处理，当某个服务提供者的节点宕机时，系统基于一致性哈希算法来选择其他的节点；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;85&quot; data-backw=&quot;566&quot; data-ratio=&quot;0.15012722646310434&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3FO4eOTWcibzMp9NJd6FLxpdUuPcZefxSAY8q1t1OwL0sWQKgBPSYp5w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;76&quot; data-backw=&quot;571&quot; data-ratio=&quot;0.13231552162849872&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3aLcm5XMeq0ET0jpRZly3I7Ep4Xq2rIs8gK1wHZpLmaZScm7E8pdS0w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 4  gRPC-Nebula 负载均衡配置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）黑白名单机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过设置服务端实例的黑名单、白名单，可以动态实现请求流程的转移以及服务端实例的访问控制。如果将某 IP 加入一个服务的黑名单，部署在这个 IP 上的服务消费者无法从注册中心获取到这个服务的地址列表。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;308&quot; data-backw=&quot;414&quot; data-ratio=&quot;0.7439613526570048&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3MibAHZGOMy9lmZkQJYI2w0qsOIK6PCicTEzpJP6V22lRAtoMtHiaR0kgA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 5  黑白名单设置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（3）权重配置&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;gRPC-Nebula 能够对服务提供者实例设置不同的服务权重，框架根据权重进行流量分发，这样可以达到根据不同的后端资源能力进行动态平衡。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2373684210526316&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3L24YFpE53evYs05TjZIYoCds6L3KwOjEGYOjiaMJpe5WBV8T9EzkYCQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 6  服务权重列表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.27459231983166754&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3YpJZ6cYibVKbIVFbnCgqyTMGWlJpb6rCgFicteiayTZpqfbUc65ibYKVbw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 7 服务权重设置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（4）动态分组机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;每个微服务实例都有一个分组属性存放在注册中心，分组属性既可以通过配置文件预先设定，也可以通过管理平台动态配置。通过分组一个微服务的集群可以被划分为多个集合，服务消费者可以按优先级调用某几个特定分组的服务，动态分组机制可以灵活实现同机房调用和业务隔离等场景。&lt;/p&gt;&lt;p&gt;服务端配置：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;43&quot; data-backw=&quot;374&quot; data-ratio=&quot;0.11497326203208556&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS34eG0lr0R34uwE4iaKWFXjVHAnEERrAATYN8AmePsOBeESETPonibl9sg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;客户端配置：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;41&quot; data-backw=&quot;375&quot; data-ratio=&quot;0.10933333333333334&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3taVAB5fTJib2jytKMAtqdt4P2rHbEb6dgVnzLLO3eiav70GSuILfbLFQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 8 动态分组配置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;机房调用场景，在数据机房安全性越来越得到重视的今天，多机房灾备方案被各类企业广泛使用，但是跨机房调用的高耗时可能造成系统的容量降低。如图 8 所示，假设所有服务实例均部署在 A、B 两个异地机房，服务消费者希望优先调用属于同机房的服务提供者，使用 IP 段定义机房的策略灵活性和扩展性不足，服务分组策略可以有效满足这一需求。例如将机房 A 的服务提供者定义为 a 分组，将机房 A 的服务消费者配置成优先调用 a 分组的节点，同时机房 B 的服务也进行类似配置。这样，机房 A 的服务消费者会优先调用机房 A 的服务提供者，避免高耗时的跨机房调用，当 Server1 和 Server2 全部宕机时，机房 A 的服务消费者会把请求自动切换到机房 B 的 Server3 和 Server4 上。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4839142091152815&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3DWzOalN9DZkqfjIDKWic5UdJKD1CuJsFt8Od3W2YBnAZ76zsXzVfOVQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 9 机房调用场景&lt;/span&gt;&lt;/p&gt;&lt;p&gt;业务隔离场景，业务隔离是避免微服务系统雪崩效应的常用策略，当一个服务提供者被多个消费者调用时，个别消费者的流量激增可能导致整个服务提供者集群超负荷运作，从而影响所有消费者的调用。服务治理平台的服务分组功能可以将服务提供者集群划分为一个个独立集合，消费者只调用特定分组的实例，这样每个消费者的调用相互隔离、互不影响，可以有效保证整个系统的高可用性。如图 9 所求，后端服务通过设置 tc、wmp、matrix 分组，可对交易接入、财富销售中心、东方睿等系统分别提供不同服务等级保障，达到业务隔离诉求。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4732041049030787&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3u65OY2qA2uS7rYdvyU0iaLsd8b4toHFJLgfOQCYTTu8QAvAlcbnKibhQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 10 业务隔离场景&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;集群容错&lt;/span&gt;&lt;/section&gt;&lt;p&gt;当服务提供者无法正常为消费者提供服务时，如连接被拒绝、请求超时、后台服务异常等，服务框架需要进行集群容错，重新进行路由选择和调用，gRPC-Nebula 服务治理框架支持快速失败（Failfast）和失效转移（Failover）两种策略：&lt;/p&gt;&lt;p&gt;快速失败是指如果服务提供者返回异常，消费者不用重试直接报错。这种策略适合一些非核心的服务，可以为重要的核心服务节约宝贵的资源。&lt;/p&gt;&lt;p&gt;失效转移是指当服务调用异常时，重新进行路由选择，查找下一个可用的服务提供者来发起新的调用请求。当调用一个节点连续多次失败或在一段时间内失败率超过限制时，框架认为这个节点当前已不适合再对外提供服务，服务消费者会将其从服务地址列表中剔除，保证一段时间内都不会调用到这个异常节点。这个机制的目的是降低系统对网络抖动的敏感性，不会因为一次偶然的调用失败而调整流量分配，保持服务器负载的稳定性。和服务分组属性一样，连续失败次数和一段时间内失败率的阈值都可以通过配置文件和管理平台配置。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4399596367305752&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3YrbsMLQib8YY6Xbn9WStCMdeKGzb2TiaJ0peyicmKwicXIICVdvQ2umAEw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 11  集群容错配置&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;流量控制&lt;/span&gt;&lt;/section&gt;&lt;p&gt;历史上券商核心系统事故都是由流量冲击引起的，当网络流量瞬间爆发性增长时，对服务器 CPU 和 IO 资源的抢占会造成系统出现瓶颈，服务错误率迅速上升，此时上游或用户的重试行为又进一步加大了网络流量，最终使得服务彻底崩溃且长时间难以恢复，这即是雪崩效应。为了防止雪崩，需要对服务调用过程进行控制，通过一些策略削减流量，保证后台服务接收的请求在可承受的范围内。&lt;/p&gt;&lt;p&gt;gRPC-Nebula 服务治理框架通过设置请求数和连接数限制，动态实现对各服务接口的流控管理。请求数限制即当单位时间内请求数过多时，丢弃多余的请求；连接数限制即控制每个 IP 连接到服务提供者的连接数，在框架内服务间调用通过 gRPC 的 HTTP/2 协议保持长连接，当连接数达到阈值时，服务提供者会拒绝建立新连接的请求。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.25390218522372526&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1922&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3rQy8B9ice91yiaFAcYNFlqvS24DFO4CFKs4YKw3luyR7HeJnyhQBTu2A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 12 流量控制配置&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;访问保护状态&lt;/span&gt;&lt;/section&gt;&lt;p&gt;访问保护状态功能是服务治理平台控制服务端节点上下线的方式，可以用于无损发布和快速摘除故障节点等场景。例如系统上线更新时，服务的关闭或重启会导致一段时间内调用失败率升高，为了避免失败产生，可以通过服务治理平台将待操作实例设置为不可访问，注册中心会通知所有消费者不再调用不可访问节点。待确认服务端实例无调用请求后，运维人员实施更新操作，更新成功后再将实例重新设置为可以访问。更新过程中流量会平滑地从实例移除和返回，不会产生调用失败。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.12640901771336555&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3bRQdagZQVdQH21QpfOmyY0t8icxIBKTWkRmiaDqnb6dkZriaR2w1iaRhbQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 13 访问保护流程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.28094820017559263&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2278&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3nGn743FPeLOaiavNVFT5qicXd0PVwfAJaB9URKM61G1m3OIuQebDEueQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 14  访问保护设置&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;多注册中心支持&lt;/span&gt;&lt;/section&gt;&lt;p&gt;出于安全管控需求，很多企业将网络划分为多个网段，每个网段部署独立的注册中心。GRPC-Nebula 框架支持将服务同时注册到多个注册中心，并且可以将自定义的服务端 IP 端口注册到注册中心，这个特性为了适配多网段间可能存在的 IP 地址映射或代理的场景。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3884943181818182&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS32hnGR9slXiagicvxltzg7DJbS2iaL1yrybu6RVWoVKJxOdEYZITkE01SQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 15  多注册中心支持&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;主备服务支持&lt;/span&gt;&lt;/section&gt;&lt;p&gt;gRPC-Nebula 框架支持主备服务，能够对实例设置主服务器和备服务器。当主服务器可用时客户端只能调用主服务器，不调用备服务器；当所有主服务器不可用时，客户端自动切换到备服务器进行服务调用。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3282828282828283&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS35hGb4xhicCxVSxOtqXYJ21N7HaEuymZNPfa75M1Abk8ZibB1Qr9iaWDIA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 16 主备服务示意图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2495798319327731&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2380&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS30LYGtjb4mhRMHWRHBqGicWajwwr0KuFNUiaLibRiatqtCBbztaBCLM2Weg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 17  主备服务设置&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;内外部服务&lt;/span&gt;&lt;/section&gt;&lt;p&gt;gRPC-Nebula 框架支持同一项目不同类型的 grpc 服务具有不同的可见性。服务提供者实现的接口可以划分为两类服务，对于内部项目间 gRPC 调用服务，此类服务并不对外暴露，因此应该避免外部项目可见；对于项目对外提供的 gRPC 服务则需要允许外部系统可见。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.30442583732057416&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1672&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3QXsDOyowhWc6etYoYPkSsAicDQUbl7CmPBOe4q7IicXnbj5l7qTLHIUA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 18  内外部服务&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;原生 gRPC 框架优化&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt;断线重连指数退避算法支持&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;当 gRPC 连接到服务端发生失败时，通常希望不要立即重试 (以避免泛滥的网络流量或大量的服务请求)，而是做某种形式的指数退避算法。参考链接如下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md&lt;/span&gt;&lt;/p&gt;&lt;p&gt;但这种形式往往会造成服务端失败后，客户端不断的退化重连时间，长时间会退化成一个非常大的时间，当服务端重新启动成功后，客户端反而长时间不能连接成功，故此 gRPC-Nebula 修改了原生框架，客户端可以自行配置最大的重连时间，规避此类风险。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.16189111747851004&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3XudSibroQlxcSLfQ2XNqxcWbdjNMf8UzXcWL6TKIMGk8y7jsszmhRJw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 19 退避算法设置&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt;Keepalive 心跳&lt;/section&gt;&lt;section&gt;&lt;span&gt;gRPC 原生逻辑具备 keepalive 心跳机制，客户端心跳默认关闭，服务端心跳 2 小时发送一次，参考链接如下：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;https://github.com/grpc/grpc/blob/master/doc/keepalive.md。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;但在实际生产网络环境中，防火墙通常设置为 15 分钟就会主动断开无请求的 TCP 连接，证券行业的特点造成了服务请求主要集中在 9:15-15:30 这个时间段，这样在非交易时间会有大量 TCP 连接断开，为此我们修改了 gRPC 框架，使客户端和服务端都可自行配置心跳时间。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2639198218262806&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3V1QZPDb7v4Ijzd5ZFfhbQ02icmicyE5b220CHgwWXEicn3fP8V72gL4tw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 20 客户端心跳设置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3030973451327434&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1808&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3tiaea1G1lydYntGtbUPyoWjsBSGYwnqOCeicRhXOQhGzvu9zAK5AEnDA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 21 服务端心跳设置&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;星辰服务治理平台&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;建设目标&lt;/span&gt;&lt;/section&gt;&lt;p&gt;由于业务的实际需求和技术发展，开发部门和供应商通常会根据需要选择不同的微服务框架，呈现多样化选型。如何管理好这些服务，成为研发和运维部门需要面对的问题。如果可以将这些框架和服务对接到统一的服务治理平台，将可以大大降低协作开发的成本，并提升整体的版本迭代效率，因此东方证券星辰服务治理平台的建设目标包括：&lt;/p&gt;&lt;p&gt;通用治理能力：引入中间层设计，兼容多框架的通用治理能力，采用分发器和治理组件协调工作统一多框架通用治理能力，由分发器下发任务至不同的治理组件，由理组件完成平台纳管多框架，完成分发器下发治理任务。平台自服务：平台本身采用微服务架构及容器平台集成，提供更深度的治理功能，提供平台应用生命周期、组件部署管理、灰度、弹性和统一配置支持。&lt;/p&gt;&lt;p&gt;多框架兼容的应用管理：兼容基于 gRPC、Spring Cloud、Dubbo 三种微服务框架，帮助客户快速部署或迁移微服务应用。&lt;/p&gt;&lt;p&gt;业务服务架构防腐化：通过服务注册中心对服务强弱依赖进行分析，结合运行时服务调用链关系分析，梳理不合理的依赖和调用路径，优化服务化架构，防止代码腐化。&lt;/p&gt;&lt;p&gt;快速故障定界定位：通过服务调用链日志、服务性能 KPI 数据、服务接口日志、运行日志等，实时汇总和分析，实现故障的自动发现、自动分析和在线条件检索，方便运维人员进行故障诊断。&lt;/p&gt;&lt;p&gt;服务微管控：运行态服务治理，包括限流降级、服务迁入迁出、服务超时控制、智能路由、统一配置等，通过一系列细粒度的治理策略，在故障发生时可以多管齐下，在线调整，快速恢复业务。服务生命周期管理：包括服务的上线审批、下线通知，服务的在线升级，以及上线、下线，自动弹性伸缩，资源扩容。&lt;/p&gt;&lt;section&gt;&lt;span&gt;功能模块&lt;/span&gt;&lt;/section&gt;&lt;p&gt;星辰服务治理平台包含以下功能模块：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（1）服务治理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;星辰服务治理平台支持对 gRPC、Spring Cloud、Dubbo 三种微服务框架进行管理，如图 5 所示，支持查询注册中心维护的服务实例信息，支持通过控制台配置注册中心、访问控制、主备、分组、黑白名单、流量控制、熔断等信息。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36752988047808766&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3WjOsZ5IZsXt12V24icz4GlcnNvbGzyxJyOSriaibASicz6TyVwaHqtAPBw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 22 服务治理功能&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.28873611845584346&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1891&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3bwE0pOoMPXjtzxxibDhMd6k9icd6XriaicmWwIz311wGFGbjZJQqRzNjKw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 23 服务间调用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）服务地图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;服务地图将项目与项目、服务与服务之间的调用关系和调用量通过拓扑图的形式进行展示，如图 6 所示。系统架构师可以从服务地图提炼出全公司的核心系统拓扑图，找出不合理的环形调用链；运维人员可以从服务地图掌握核心系统所依赖的上游系统，并给予核心系统同级别的重点保障。当预期面临流量猛增时，服务地图还可用于流量预估，因为从客户端等入口预估流量最准确，进而可以沿着服务地图下沉计算出各个微服务分摊到的流量，协助后台系统制定扩容预案。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4562394127611519&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1771&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS36X9y0T6l52CVTWqMgJWjpE4qoxa7jQAklxOEC9rTf3CHPRL7t2UwtA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 24 星辰服务治理平台服务地图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（3）链路跟踪&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在微服务架构中，一个用户操作涉及到多个微服务的协同才能完成，在业务调用链路上任何一个微服务出现异常或者网络超时，都会导致失败。通过链路跟踪，我们可以很方便的看到每个请求各个环节的耗时以及异常，帮助我们对系统进行优化。星辰的链路跟踪功能基于 Google 的 DApper 论文 [11] 实现，在系统入口接收用户的请求后，会为用户的请求分配一个 TraceID 用来唯一标识调用链。TraceID 会跟随远程调用消息传递到下游服务，直到整个链路的节点都拥有了 TraceID，通过 TraceID 可以串起这个请求的完整调用链路。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4017008504252126&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3STO5v1SyQjqJ4y4HQGicOk3EecY5d1WVRO7wOMx7SzC4mnctYC6uA0A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 25  调用链关系&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（4）文档中心&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;文档中心对 ProtoBuf 格式接口定义文件进行自动解析，提供技术人员查询各服务注释信息与接口定义的功能。我们把文档中心看作是一个服务集市，技术人员在实现一个涉及通用模块或第三方应用的功能前，可以像逛集市一样来文档中心查询接口的详细信息。未来我们还将强化文档中心的交互沟通功能，增加问答与评论功能，打通各服务上下游的交流渠道。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.43223880597014924&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3Jd4paHV1W7KKlbHgJ1BJEvSTbCJ0B2p38VkmicQ3XzN8c9voVejTKmg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 26  文档中心&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（5）统计分析&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;统计分析模块支持对服务、实例、端点的性能监控，包括响应时间、可用性、吞吐量等；支持数据大屏，全景展示当前所有服务的运行状态；记录用户请求处理时间，分析出被调用服务的性能；记录服务响应时间，并展示响应时间最长的数个服务，即慢服务列表。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.46149789029535865&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1896&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3xGbU1HNgvB8fLAzmgI4icP1ibapaJTt3licQ2icibj1QZT7drsFvc8M4v3A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 27  平台统计分析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（6）告警中心&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;告警中心支持基于监控数据的告警规则设置，并以自定义的方式发出告警通知。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2347457627118644&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2360&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3yZyDic8gib13VUSYVTsRKI6dibdNqlicS5Bk6WGfmISkQzpns4HR0an15Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 28  告警设置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（7）框架统一纳管&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;为了更好的支持企业架构转型，也便于各业务方系统内部有更多的微服务框架供选择，晨辰服务治理平台同时对多种微服务框架进行了统一纳管，在支持 gRPC 服务的基础上，增加了 dubbox 及 Spring Cloud 框架。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.46386946386946387&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1287&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3mJM4Ut5VXAhAfMSZLFREOrvbknCdxfyOWianmS4pF0N5nXxqgs9Rqsg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 29  多框架支持&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;转型实践&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数字化转型&lt;/span&gt;&lt;/section&gt;&lt;p&gt;多年来，随着东方证券各类业务的持续发展，数百套业务及支撑系统在线运营，各类应用系统间开始呈现复杂的依赖关系，系统运维的复杂度急剧增加。特别是由于以往系统建设主要由各厂商开发等因素的影响，东方证券内部存在大量的异构业务系统，对外暴露的接口也呈现多种形式，各厂商都有各自私有协议，且存在有 SPX、T2、Web Service、REST、TCP 等各类型异构接口，进一步增加了系统开发、运维的难度。基于这些原因，东方证券从公司战略和技术管理上进行了变革。2018 年初，公司提出了“数字化转型”的战略目标，并将“增强金融科技应用”列入公司的六大发展战略任务之一，这促使我们以更加积极和开放的心态发展科技。&lt;/p&gt;&lt;p&gt;与此同时，东方证券同步在企业技术架构上制定了大中台战略，这也是公司数字化转型中的三个核心战略之一（另两个为：核心自主研发、重构企业技术架构），旨在通过架构转型为公司科技工作的长远发展打下坚实基础。为了推进架构转型工作，2019 年初，东方证券成立了以首席信息官舒宏总担任主任的架构委员会，旨在通过架构委员会重点进行企业架构转型的工作，同时创建了金融科技创新研究院，以整合东方证券及子公司的技术资源、倡导以研究为主导的技术应用为主要任务。&lt;/p&gt;&lt;section&gt;&lt;span&gt;架构标准&lt;/span&gt;&lt;/section&gt;&lt;p&gt;为了建设各业务方遵循标准进行开发的能力，让企业架构建设有据可依，东方证券架构委员会制定了架构标准的决策流程及机制，通过架构标准去约束各系统相应开发实践，2019 年 5 月，我们通过服务治理平台接入规范的架构标准，确定了企业技术架构转型的核心框架，各系统采用统一的接口调用方式，要求系统间调用必须使用 gRPC 提供服务，系统内部可以采用 gRPC/dubbo/Spring Cloud 三种框架，支持东方证券 IT 技术架构从传统架构向微服务为核心的现代化面向服务架构全面转型。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9215449607724804&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1657&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS30bibHsQW7DMHMQ0RS9DelOUcOHq4zY9nibdNzzQjoSB5ibkib5jicniae7mg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 30  服务治理架构决策&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;大中台战略&lt;/span&gt;&lt;/section&gt;&lt;p&gt;为了实现数字化转型，东方证券制定了三年架构规划，通过架构规划及落地实施，打造行业领先的 IT 架构和一流的 IT 队伍，形成公司科技发展的竞争力，架构规划中有七大重点任务，其中一项是建设强大的业务共享中台，提炼核心业务流程，为前端产品线提供业务共享能力，给前台提供强大的“炮火支援”能力，确保“厚中台，薄应用”的成功落地，。&lt;/p&gt;&lt;p&gt;按照证券行业的领域特点，我们将整个中台领域划分为产品、账户、财富、交易、资产、行情、资讯、日志、认证等中心，而服务治理框架也成为了整个业务中台的核心基础设施。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5627813906953477&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3RsEicXj85mqTnJxr6MkC0tFTYBeEAnqaI54F7z7c41nqnSFaibY5gelQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 31  东方证券大中台战略&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;开源共享 / 行业标准&lt;/span&gt;&lt;/section&gt;&lt;p&gt;东方证券 gRPC-Nebula[9]，本身就是在站在开源 gRPC 的巨人肩膀之上发展而来，为了更好的反馈社区，2019 年 6 月中旬，东方证券宣布开源 gRPC-Nebula 服务治理框架，开源地址：https://github.com/grpc-nebula，目前社区已建设了社区决策委员会，初期拟设 7 名委员，含 1 名委员会主席，设有专人进行 GitHub 代码的跟踪、维护、解决。同时，委员会会定期组织研讨和常态化沟通、社区技术交流、协调开发力量进行社区开发、社区筹款、审议版本 maintainer 的版本和功能集、进行社区委员会选举等工作。社区将秉持金融科技创新，对外技术输出的原则，致力于成为行业内首家基于 gRPC 可治理 RPC 框架下的开源社区，并获得了 2019 年信通院 OSCAR 尖峰开源技术创新奖（基于社区开源二次开发）及第四届中国优秀云计算开源案例一等奖。&lt;/p&gt;&lt;p&gt;同时整个证券行业长期以来在技术架构领域没有统一标准，各家厂商都有自己相应的技术框架，从而造成了整个行业一直面对的异构化难题，gRPC-Nebula 开源也旨在为整个行业提供参考建议，同时，我们也积极加入了深交所技术产品联盟，推广 gRPC-Nebula 在行业内的使用，希望能达成行业共识，形成统一技术标准，大幅降低行业各系统间对接成本。&lt;/p&gt;&lt;section&gt;&lt;span&gt;实践成果&lt;/span&gt;&lt;/section&gt;&lt;p&gt;从 2019 年初开始，东方证券进行服务治理框架研发工作，截止 2020.9 月，gRPC-Nebula 框架 Java 语言共迭代 14 个版本，C++ 语言共迭代 8 个版本，平台迭代了 4 个版本，较好的支撑了业务各类的需求。&lt;/p&gt;&lt;p&gt;同时，东方证券在内部大力推广服务治理框架及平台的使用，截止 2020.9 月，共接入各类应用 46 个，项目 99 个，服务数 369 个，方法数 3125 个，日承载各类请求量已达到数千万级。&lt;/p&gt;&lt;p&gt;从系统维度来看，东方证券服务治理框架已接入内部东方赢家 App、私行 App 通达信网上交易、同花顺机构版、东方睿、东方大脑、智能投顾、大营运平台、业务中台（财富、交易、产品、账户、资产、行情、资讯等）、资产配置等核心系统，从厂商维度来看，微软、恒生、金仕达、新意、顶点、通达信、同花顺等核心厂商及自研团队也已按照架构标准接入服务治理框架及平台，实践成果非常明显。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4600496277915633&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNznVc2mXK3wzT2a00JleS3R0wQBDbM09Pf26OPiaibpmJZ0T0o7YNWiawoQmAOsdibG1KibyrlftX6LSQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 32 服务治理平台实践成果&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;总    结&lt;/span&gt;&lt;/section&gt;&lt;p&gt;本文探讨了企业架构领域的关键技术，并详细介绍了东方证券服务治理项目的建设成果与实践经验。东方证券在企业架构层面制定了大中台战略，旨在通过业务架构转型为公司科技工作的长远发展打下坚实基础。作为大中台战略的核心组成部分，服务治理项目的建设，是公司提高金融科技核心竞争力的重要突破。gRPC-Nebula 框架和星辰服务治理平台已经应用于东方证券业务中台（财富中心、交易中心、账户中心、产品中心等）、东方赢家 App、私行 App 和东方睿机构交易产品线等数十个项目，同时实现了各微服务框架 (gRPC-Nebula/dubbox/Spring Cloud) 的统一纳管，为业务线开发提供了更多的开发框架选择，随着平台生态的不断优化和发展，未来将在内部全面推广，服务于更多产品线和用户，为公司 IT 治理规范和体系化架构建设做出更多贡献。&lt;/p&gt;&lt;section&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;[1]Fowler M, Lewis J. Microservices. Viittattu, 2014, 28: 2015&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2]Fotis Aisopos, Konstantinos Tserpes, Theodora Varvarigou. Resource management in software as a service using the knapsack problem model.  International Journal of Production Economics. 2013 (2)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3]Thones J. Microservices. Software IEEE, 2015, 32(1): 116-116&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4] 李贞昊. 微服务架构的发展与影响分析. 信息系统工程, 2017(1): 154-155&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;span&gt;https://dubbo.io/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;span&gt;https://thrift.apache.org&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;span&gt;https://grpc.io/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;span&gt;https://spring.io/projects/spring-cloud/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;span&gt;https://github.com/grpc-nebula&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[10]Hunt P,Konar M,Junqueira F P, et a1. ZooKeeper:Wait-free Coordination for Interact-scale Systems[C]// USENIX Annual Technical Conference. 2010, 8: 9.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[11]Sigelman, Benjamin H., et al. DApper, a Large-Scale Distributed Systems Tracing Infrastructure. Technical report, Google, 2010&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c4aa9ceba43a93a7ed7b9196e5130c52</guid>
<title>搜索中常见数据结构与算法探究（一）</title>
<link>https://toutiao.io/k/nrqhhvl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h3&gt;1 前言&lt;/h3&gt;

&lt;p&gt;ES现在已经被广泛的使用在日常的搜索中，Lucene作为它的内核值得我们深入研究，比如FST，下面就用两篇分享来介绍一些本文的主题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 第一篇主要介绍数据结构和算法基础和分析方法，以及一些常用的典型的数据结构；&lt;/li&gt;
&lt;li&gt; 第二篇主要介绍图论，以及自动机，KMP，FST等算法；&lt;br/&gt;
下面开始第一篇&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;2 引言&lt;/h3&gt;

&lt;p&gt;“算法是计算机科学领域最重要的基石之一“&lt;br/&gt;
“编程语言虽然该学，但是学习计算机算法和理论更重要，因为计算机算法和理论更重要，因为计算机语言和开发平台日新月异，但万变不离其宗的是那些算法和理论，例如数据结构、算法、编译原理、计算机体系结构、关系型数据库原理等等。“——《算法的力量》&lt;/p&gt;

&lt;h4&gt;2.1 提出问题&lt;/h4&gt;

&lt;p&gt;2.1.1 案例一&lt;/p&gt;

&lt;p&gt;设有一组N个数而要确定其中第k个最大者，我们称之为&lt;strong&gt;选择问题&lt;/strong&gt;。常规的解法如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 该问题的一种解法就是将这N个数读进一个数组中，在通过某种简单的算法，比如冒泡排序法，以递减顺序将数组排序，然后返回位置k上的元素。&lt;/li&gt;
&lt;li&gt; 稍微好一点的算法可以先把前k个元素读入数组并对其排序。接着，将剩下的元素再逐个读入。当新元素被读到时，如果它小于数组中的第k个元素则忽略之，否则就将其放到数组中正确的位置上，同时将数组中的一个元素挤出数组。当算法终止时，位于第k个位置上的元素作为答案返回。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两种算法编码都很简单，但是我们自然要问：哪个算法更好？哪个算法更重要？还是两个算法都足够好？使用N=30000000和k=15000000进行模拟将发现，两个算法在合理的时间量内均不能结束；每一种算法都需要计算机处理若干时间才能完成。&lt;br/&gt;
其实还有很多可以解决这个问题，比如二叉堆，归并算法等等。&lt;/p&gt;

&lt;p&gt;2.2.2 案例二&lt;/p&gt;

&lt;p&gt;输入是由一些字母构成的一个二维数组以及一组单词组成。目标是要找出字谜中的单词，这些单词可能是水平、垂直、或沿对角线上任何方向放置。下图所示的字谜由单词this、two、fat和that组成。&lt;br/&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/982c2cc630eb4c63853210b56b9c2af6%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在至少也有两种直观的算法来求解这个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 对单词表中的每个单词，我们检查每一个有序三元组（行，列，方向）验证是否有单词存在。这需要大量嵌套的for循环，但它基本上是直观的算法。&lt;/li&gt;
&lt;li&gt; 对于每一个尚未越出迷板边缘的有序四元组（行，列，方向，字符数）我们可以测试是否所指的单词在单词表中。这也导致使用大量嵌套的for循环。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述两种方法相对来说都不难编码，但如果增加行和列的数量，则上面提出的两种解法均需要相当长的时间。&lt;/p&gt;

&lt;p&gt;以上两个案例中，我们可以看到要写一个工作程序并不够。如果这个程序在巨大的数据集上运行，那么运行时间就变成了重要问题。&lt;/p&gt;

&lt;p&gt;那么，使用自动机理论可以快速的解决这个问题，下一篇中给大家详细的分析。&lt;/p&gt;

&lt;h3&gt;3 数据结构与算法基础&lt;/h3&gt;

&lt;h4&gt;3.1 数据结构基础&lt;/h4&gt;

&lt;p&gt;3.1.1 什么是数据结构&lt;/p&gt;

&lt;p&gt;在计算机领域中，数据是信息的载体，是能够输入到计算机中并且能被计算机识别、存储和处理的符号的总称。数据结构是指数据元素和数据元素之间的相互关系或数据的组织形式。数据元素是数据的的基本单位，数据元素有若干基本项组成。&lt;/p&gt;

&lt;p&gt;3.1.2 数据之间的关系&lt;/p&gt;

&lt;p&gt;数据之前的关系分为两类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;逻辑关系&lt;br/&gt;
表示数据之间的抽象关系，按每个元素可能具有的前趋数和直接后继数将逻辑结构分为线性结构和非线性结构。逻辑关系或逻辑结构有如下特点：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;  只是描述数据结构中数据元素之间的联系规律；&lt;/li&gt;
&lt;li&gt;  是从具体问题中抽象出来的数学模型，是独立于计算机存储器的（与硬件无关）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;逻辑结构的分类如下：&lt;/p&gt;



&lt;p&gt;2)物理关系&lt;br/&gt;
逻辑关系在计算中的具体实现方法，分为顺序存储方法、链式存储方法、索引存储方法、散列存储方法。物理关系或物理结构有如下特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  是数据的逻辑结构在计算机存储其中的映像；&lt;/li&gt;
&lt;li&gt;  存储结构是通过计算机程序来实现，因而是依赖于具体的计算机语言的；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;物理结构分类如下：&lt;/p&gt;



&lt;h4&gt;3.2 算法基础&lt;/h4&gt;

&lt;h4&gt;3.2.1 基础概念&lt;/h4&gt;

&lt;p&gt;算法是为求解一个问题需要遵循的、被清楚指定的简单指令的集合。对于一个问题，一旦某种算法给定并且被确定是正确的，那么重要的一步就是确定该算法将需要多少诸如时间或空间等资源量的问题。如果一个问题的求解算法竟然需要长达一年时间，那么这种算法就很难能有什么用处。同样，一个需要若干个GB的内存的算法在当前的大多数机器上也是无法使用的。&lt;/p&gt;

&lt;h4&gt;3.2.2 数学基础&lt;/h4&gt;

&lt;p&gt;一般来说，估算算法资源消耗所需的分析是一个理论问题，因此需要一套数学分析法，我们先从数学定义开始。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  定理1：如果存在正常数c和n0，使得当N&amp;gt;= n0时，T(N) &amp;lt;= cf(N)，则记为T(N) = O(f(N))。&lt;/li&gt;
&lt;li&gt;  定理2：如果存在正常数c和n0，使得当N&amp;gt;=n0时，T(N) &amp;lt;= cg(N)，则记为T(N) = Ω(g(N))。&lt;/li&gt;
&lt;li&gt;  定理3：T(N) = θ(h(N))当且仅当T(N) = O(h(N)) 和 T(N) = Ω(h(N))。&lt;/li&gt;
&lt;li&gt;  定理4：如果对每一个正常数c都存在常数n0使得当N&amp;gt;n0时，T(N) &amp;lt; cp(N)，则T(N) = o(p(N))。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些定义的目的是要在函数间建立一种相对的级别。给定两个函数，通常存在一些点，在这些点上一个函数的值小于另一个函数的值，因此，一般宣称f(N)&amp;lt;g(N)，是没有什么意义的。于是，我们比较他们的相对增长率。当将相对增长率应用到算法分析时，会明白它是重要的度量。&lt;/p&gt;

&lt;p&gt;如果用传统的不等式来计算增长率，那么第一个定义T(N) = O(f(N))是说T(N)的增长率小于或者等于f(N)的增长率。第二个定义T(N) = Ω(g(N))是说T(N)增长率大于或者等于g(N)的增长率。第三个定义T(N) = θ(h(N))是说T(N)的增长率等于h(N)的增长率。最后一个定义T(N) = o(p(N))说的则是T(N)的增长率小于p(N)的增长率。他不同于大O，因为大O包含增长率相同的可能性。&lt;/p&gt;

&lt;p&gt;要证明某个函数T(N) = O(f(N)) ，通常不是形式的使用这些定义，而是使用一些已知的结果（比如说T(N) = O(log(N))）。一般来说，这就意味着证明是非常简单的计算而不应涉及微积分，除非遇到特殊情况。如下是常见的已知函数结果&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  c（常数函数）&lt;/li&gt;
&lt;li&gt;  logN（对数函数）&lt;/li&gt;
&lt;li&gt;  logN^2（对数平方函数）&lt;/li&gt;
&lt;li&gt;  N（线性函数）&lt;/li&gt;
&lt;li&gt;  NlogN&lt;/li&gt;
&lt;li&gt;  N^2（二次函数）&lt;/li&gt;
&lt;li&gt;  N^3（三次函数）&lt;/li&gt;
&lt;li&gt;  2^N（指数函数）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在使用已知函数结果时，有几点需要注意：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 首先，将常数或低阶项放进大O是非常坏的习惯。不要写成T(N) = O(2*N^2)或T(N) = O(N^2 + N)。这两种情形下，正确的形式是T(N) = O(N^2)。也就是说低阶项一般可以被忽略，而常数也可以弃掉。&lt;/li&gt;
&lt;li&gt; 其次，我们总能够通过计算极限limN→∞f(N)/g(N)（极限公式）来确定两个函数f(N)和g(N)的相对增长率。该极限可以有四种可能的值：&lt;br/&gt;
极限是0：这意味着f(N) = o(g(N))。&lt;br/&gt;
极限是c != 0： 这意味着f(N) = θ(g(N))。&lt;br/&gt;
极限是∞ ：这意味着g(N) = o(f(N))。&lt;br/&gt;
极限摆动：二者无关。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.2.3 复杂度函数&lt;/p&gt;

&lt;p&gt;正常情况下的复杂度函数包含如下两种：&lt;br/&gt;
时间复杂度&lt;br/&gt;
空间复杂度&lt;/p&gt;

&lt;p&gt;时间和空间的度量并没有一个固定的标准，但是在正常情况下，时间复杂度的单位基本上是以一次内存访问或者一次IO来决定。空间复杂度是指在算法执行过程中需要占用的存储空间。对于一个算法来说，时间复杂度和空间复杂度往往是相互影响，当追求一个好的时间复杂度时，可能会使空间复杂度变差，即可能占用更多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度变差，即可能占用较长的运算时间。&lt;/p&gt;

&lt;h4&gt;3.3 知识储备&lt;/h4&gt;

&lt;p&gt;3.3.1 质数分辨定理（HashTree的理论基础）&lt;/p&gt;

&lt;p&gt;简单的说就是，n个不同的质数可以分辨的连续数的个数和他们的乘机相同。分辨是指这些连续的整数不可能有相同的余数序列。&lt;/p&gt;

&lt;p&gt;3.3.2 Hash算法&lt;/p&gt;

&lt;p&gt;1)Hash&lt;br/&gt;
Hash一般翻译成散列，也可以直接音译成哈希，就是把任意长度的输入，通过散列算法变换成固定长度的输出，该输入就是散列值。不同的输入可能散列成相同的值，确定的散列值不可能确定一个输入。&lt;/p&gt;

&lt;p&gt;2)常见的Hash算法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  MD4：消息摘要算法；&lt;/li&gt;
&lt;li&gt;  MD5：消息摘要算法，MD4的升级版本；&lt;/li&gt;
&lt;li&gt;  SHA-1：SHA-1的设计和MD4相同原理，并模仿该算法&lt;br/&gt;
自定义HASH算法：程序设计者可以自定义HASH算法，比如java中重写的hashCode()方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3)Hash碰撞&lt;br/&gt;
解决Hash碰撞常见的方法有一下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  分离链接法（链表法）：做法是将散列到同一个值的所有元素保留在一个表中，例如JDK中的HashMap；&lt;/li&gt;
&lt;li&gt;  探测散列表：当发生Hash碰撞时，尝试寻找另外一个单元格，直到知道到空的单元为止。包括：线性探测法，平方探测法，双散列。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.3.3 树结构的基本概念&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  树的递归定义：一棵树是一些节点的集合。这个集合可以是空集；若不是空集，则树由根节点root以及0个或多个非空的子树组成，这些子树中每一棵的根都被来自根root的一条有向的边所连接；&lt;/li&gt;
&lt;li&gt;  树叶节点：没有儿子节点称为树叶；&lt;/li&gt;
&lt;li&gt;  深度：对于任意节点ni，ni的深度为从根到ni的唯一路径的长；&lt;/li&gt;
&lt;li&gt;  高度：对于任意节点ni，ni的高度为从ni到一片树叶的最长路径的长。&lt;/li&gt;
&lt;li&gt;  树的遍历：树的遍历分为两种，先序遍历和后续遍历；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.3.4 二叉搜索树&lt;/p&gt;

&lt;p&gt;二叉搜索树是一棵二叉树，其中每个节点都不能有多于两个子节点。&lt;br/&gt;
对于二叉查找树的每一个节点X，它的左子树中所有项的值都小于X节点中的项，而它的右子树中所有项的值大于X中的项；&lt;/p&gt;

&lt;h3&gt;4 常见数据结构与算法分析&lt;/h3&gt;

&lt;h4&gt;4.1 线性数据结构&lt;/h4&gt;

&lt;p&gt;4.1.1 HashMap&lt;/p&gt;

&lt;p&gt;1)总述&lt;br/&gt;
HashMap是开发中最常用的数据结构之一，数据常驻于内存中，对于小的数据量来说，HashMap的增删改查的效率都非常高，复杂度接近于O(1)。&lt;/p&gt;

&lt;p&gt;2)数据结构和算法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  HashMap由一个hash函数和一个数组组成；&lt;/li&gt;
&lt;li&gt;  数据插入，当进入到map的时候，根据hash(key)找到对应点位置，如果位置为空，直接保存，如果位置不为空，则使用链表的方式处理；为了解决遍历链表所增加的时间，JDK中的链表在大小增大到8时，将会演变成红黑树以降低时间复杂度。为什么开始使用链表，后面使用红黑树：&lt;/li&gt;
&lt;li&gt;  -   数据量较小的时候，链表的查询效率相对来说也比较高，使用红黑树占用空间比链表要大；&lt;/li&gt;
&lt;li&gt;  -   为什么选择8，请参考泊松分布；&lt;/li&gt;
&lt;li&gt;  查找和删除的过程，同插入的过程类似；&lt;/li&gt;
&lt;li&gt;  HashMap可以支持自动扩容，扩容机制需要看具体的实现；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70d75d5d7d3a47db89906d92b1c942fe%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3)优缺点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  优点：动态可变长存储数据，快速的查询速度，查询复杂度接近O(1);&lt;/li&gt;
&lt;li&gt;  缺点：只支持小数据量的内存查询；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4)使用场景&lt;/p&gt;



&lt;p&gt;4.1.2 Bloom Filter（布隆过滤器）&lt;/p&gt;

&lt;p&gt;1)总述&lt;br/&gt;
布隆过滤器算法为大数据量的查找提供了快速的方法，时间复杂度为O(k)，布隆过滤器的语义为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  布隆过滤器的输出为否定的结果一定为真；&lt;/li&gt;
&lt;li&gt;  布隆过滤器的输出为肯定的结果不一定为真；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2)数据结构和算法&lt;br/&gt;
布隆过滤器的具体结构和算法为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  布隆过滤器包含k个hash函数，每个函数可以把key散列成一个整数（下标）；&lt;/li&gt;
&lt;li&gt;  布隆过滤器包含了一个长度为n的bit数组（向量数组），每个bit的初始值为0；&lt;/li&gt;
&lt;li&gt;  当某个key加入的时候，用k个hash函数计算出k个散列值，并把数组中对应的比特置为1；&lt;/li&gt;
&lt;li&gt;  判断某个key是否在集合时，用k个hash函数算出k个值，并查询数组中对应的比特位，如果所有的bit位都为1，认为在集合中；&lt;/li&gt;
&lt;li&gt;  布隆过滤器的大小需要提前评估，并且不能扩容；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;布隆过滤器的插入过程如下：&lt;br/&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cdbf0c3f0ba4e95ab17f58c3d0183e6%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;判断某个key是否在集合时，用k个hash函数算出k个值，并查询数组中对应的比特位，如果所有的bit位都为1，认为在集合中&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  布隆过滤器无法删除数据；&lt;/li&gt;
&lt;li&gt;  布隆过滤器查询的时间复杂度为O(k)；&lt;/li&gt;
&lt;li&gt;  布隆过滤器空间的占用在初始化的时候已经固定不能扩容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3)优缺点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  优点：布隆过滤器在时间和空间上都有巨大的优势。布隆过滤器存储空间和插入/查找时间都是常数。布隆过滤器不需要存储数据本身，节省空间。&lt;/li&gt;
&lt;li&gt;  缺点：布隆过滤器的缺点是有误差。元素越多误差越高。可以通过提高hash函数的个数和扩大bit数组的长度来降低误差率；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4)场景&lt;/p&gt;



&lt;p&gt;4.1.3 SkipList（跳表）&lt;/p&gt;

&lt;p&gt;1)总述&lt;br/&gt;
跳表是一种特殊的链表，相比一般的链表有更高的查找效率，可比拟二差查找树，平均期望的插入，查找，删除的时间复杂度都是O(logN);&lt;/p&gt;

&lt;p&gt;2)数据结构和算法&lt;br/&gt;
跳表可视为水平排列（Level）、垂直排列（Row）的位置（Position）的二维集合。每个Level是一个列表Si，每个Row包含存储连续列表中相同Entry的位置，跳表的各个位置可以通过以下方式进行遍历。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  After(P)：返回和P在同一Level的后面的一个位置，若不存在则返回NULL；&lt;/li&gt;
&lt;li&gt;  Before(P)：返回和P在同一Level的前面的一个位置，若不存在则返回NULL；&lt;/li&gt;
&lt;li&gt;  Below(P)：返回和P在同一Row的下面的一个位置，若不存在则返回NULL；&lt;/li&gt;
&lt;li&gt;  Above(P)：返回和P在同一Row的上面的一个位置，若不存在则返回NULL；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ac70639b3514f21af3484b1112813b6%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有顺序关系的多个Entry(K,V)集合M可以由跳表实现，跳表S由一系列列表{S0，S1，S2，……，Sh}组成，其中h代表的跳表的高度。每个列表Si按照Key顺序存储M项的子集，此外S中的列表满足如下要求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  列表S0中包含了集合M的每个一个Entry；&lt;/li&gt;
&lt;li&gt;  对于i = 1 ，…… ，h-1列表Si包含列表Si-1中Entry的随机子集；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Si中的Entry是从Si-1中的Entry集合中随机选择的，对于Si-1中的每一个Entry，以1/2的概率来决定是否需要拷贝到Si中，我们期望S1有大约n/2个Entry，S2中有大约n/4个Entry，Si中有n/2^i。跳表的高度h大约是logn。从一个列表到下一个列表的Entry数减半并不是跳表的强制要求；&lt;br/&gt;
插入的过程描述，以上图为例，插入Entry58：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  找到底层列表S0中55的位置，在其后插入Entry58；&lt;/li&gt;
&lt;li&gt;  假设随机函数取值为1，紧着回到20的位置，在其后插入58，并和底层列表S0的- Entry58链接起来形成Entry58的Row；&lt;/li&gt;
&lt;li&gt;  假设随机函数取值为0，则插入过程终止；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图为随机数为1的结果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b396e9d98104ad4a530fc6ecce084a6%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;删除过程：同查找过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  查找包括两个循环，外层循环是从上层Level到底层Level，内层循环是在同一个Level，从左到右;&lt;/li&gt;
&lt;li&gt;  跳表的高度大概率为O(logn)，所以外层循环的次数大概率为O(logn);&lt;/li&gt;
&lt;li&gt;  在上层查找比对过的key，不会再下层再次查找比对，任意一个key被查找比对的概率为1/2，因此内存循环比对的期望次数是2也就是O(1);&lt;/li&gt;
&lt;li&gt;  因此最终的时间复杂度函数O(n) = O(1)*O(logn) 也就是O(logn)；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  Level i期望的元素个数为 n/2^i；&lt;/li&gt;
&lt;li&gt;  跳表中所有的Entry（包含同一个Entry的Row中的元素） Σ n/2^i = nΣ1/2^i，其中有级数公式得到Σ1/2^i &amp;lt; 2；&lt;/li&gt;
&lt;li&gt;  期望的列表空间为O(n)；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3)优缺点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  优点：快速查找，算法实现简单；&lt;/li&gt;
&lt;li&gt;  缺点：跳表在链表的基础上增加了多级索引以提升查询效率，使用空间来换取时间，必然会增加存储的负担。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4)使用场景&lt;br/&gt;
许多开源的软件都在使用跳表：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  Redis中的有序集合zset&lt;/li&gt;
&lt;li&gt;  LevelDB Hbase中的memtable&lt;/li&gt;
&lt;li&gt;  Lucene中的Posting List&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;4.2 简单非线性数据结构&lt;/h4&gt;

&lt;p&gt;4.2.1 AVL&lt;/p&gt;

&lt;p&gt;1)总述&lt;br/&gt;
AVL树是带有平衡条件的二叉查找树，这个平衡条件必须要容易保持，而且它保证树的深度必须是O(logN)。在AVL树中任何节点的两个子树的高度最大差别为1。&lt;/p&gt;

&lt;p&gt;2)数据结构和算法&lt;br/&gt;
AVL树本质上还是一棵二叉查找树，有以下特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  AVL首先是一棵二叉搜索树；&lt;/li&gt;
&lt;li&gt;  带有平衡条件：每个节点的左右子树的高度之差的绝对值最多为1；&lt;/li&gt;
&lt;li&gt;  当插入节点或者删除节点时，树的结构发生变化导致破坏特点二时，就要进行旋转保证树的平衡；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对旋转做详细分析如下：&lt;br/&gt;
我们把必须重新平衡的节点叫做a，由于任意节点最多有两个儿子，因此出现高度不平衡就需要a点的两棵子树的高度差2。可以看出，这种不平衡可能出现一下四种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  对a的左儿子的左子树进行一次插入；&lt;/li&gt;
&lt;li&gt;  对a的左儿子的右子树进行一次插入；&lt;/li&gt;
&lt;li&gt;  对a的右儿子的左子树进行一次插入；&lt;/li&gt;
&lt;li&gt;  对a的右儿子的柚子树进行一次插入；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;情形1和4是关于a的对称，而2和3是关于a点的对称。因此理论上解决两种情况。&lt;br/&gt;
第一种情况是插入发生在外侧的情况，该情况通过对树的一次单旋转而完成调整。第二种情况是插入发生在内侧的情况，这种情况通过稍微复杂些的双旋转来处理。&lt;/p&gt;

&lt;p&gt;单旋转的简单示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1684afb4f424136a8b039842c666f39%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;双旋转的简单示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b44ccdcd3f3a4c7692f85dbfdd2d7e89%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3)优缺点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  优点：使用二叉查找算法时间复杂度为O(logN)，结构清晰简单；&lt;/li&gt;
&lt;li&gt;  缺点：插入和删除都需要进行再平衡，浪费CPU资源；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4)使用场景&lt;/p&gt;



&lt;p&gt;.4.2.2 Red Black Tree&lt;/p&gt;

&lt;p&gt;1)总述&lt;br/&gt;
红黑树是一种自平衡的二叉查找树，是2-3-4树的一种等同，它可以在O(logN)内做查找，插入和删除。&lt;/p&gt;

&lt;p&gt;2)数据结构和算法&lt;br/&gt;
在AVL的基础之上，红黑树又增加了如下特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  每个节点或者是红色，或者是黑色；&lt;/li&gt;
&lt;li&gt;  根节点是黑色；&lt;/li&gt;
&lt;li&gt;  如果一个节点时红色的，那么它的子节点必须是黑色的；&lt;/li&gt;
&lt;li&gt;  从一个节点到一个null引用的每一条路径必须包含相同数目的黑色节点；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;红黑树的示意图如下（图片来源于网络）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f91fd0bb7ea411a8e845a12ea3ae31f%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么将一个节点插入到红黑树中，需要执行哪些步骤呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  将红黑树当做一棵二叉搜索树，将节点插入；&lt;/li&gt;
&lt;li&gt;  将插入的节点着色为红色；&lt;/li&gt;
&lt;li&gt;  通过一系列的旋转和着色等操作，使之重新成为一棵红黑树；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在第二步中，被插入的节点被着为红色之后，他会违背哪些特性呢&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  对于特性1，显然是不会违背；&lt;/li&gt;
&lt;li&gt;  对于特性2，显然也是不会违背；&lt;/li&gt;
&lt;li&gt;  对于特性4，显然也是不会违背；&lt;/li&gt;
&lt;li&gt;  对于特性3，有可能会违背，我们将情况描述如下&lt;/li&gt;
&lt;li&gt;  -   被插入的节点是根节点：直接把此节点涂为黑色；&lt;/li&gt;
&lt;li&gt;  -   被插入的节点的父节点是黑色：什么也不需要做。节点被插入后，仍然是红黑树；&lt;/li&gt;
&lt;li&gt;  -   被插入的节点的父节点是红色：此种情况下与特性3违背，所以将情况分析如下：&lt;/li&gt;
&lt;li&gt;  -   -   当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点也是红色。处理策略为：将父节点置为黑色、将叔叔节点置为黑色、将祖父节点置为红色；&lt;/li&gt;
&lt;li&gt;  -   -   当前节点的父节点是红色，叔叔节点时黑色，且当前节点是其父节点的右子节点。将父节点作为新的当前节点、以新的当前节点作为支点进行左旋；&lt;/li&gt;
&lt;li&gt;  -   -   当前节点的父节点是红色，叔叔节点时黑色，且当前节点时父节点的左子节点。将父节点置为黑色、将祖父节点置为红色、以祖父节点为支点进行右旋；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;定理：一棵含有n个节点的红黑树的高度至多为2log(N+1)，证明过程请查看参考资料。&lt;br/&gt;
由此定理可推论红黑树的时间复杂度为log(N)；&lt;/p&gt;

&lt;p&gt;3)优缺点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  优点：查询效率高，插入和删除的失衡的代销比AVL要小很多；&lt;/li&gt;
&lt;li&gt;  缺点：红黑树不追求完全平衡；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4)使用场景&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  红黑树的应用很广泛，主要用来存储有序的数据，时间复杂度为log(N)，效率非常高。例如java中的TreeSet、TreeMap、HashMap等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4.2.3 B+Tree&lt;/p&gt;

&lt;p&gt;1)总述&lt;br/&gt;
提起B+Tree都会想到大名鼎鼎的MySql的InnoDB引擎，该引擎使用的数据结构就是B+Tree。B+Tree是B-Tree（平衡多路查找树）的一种改良，使得更适合实现存储索引结构，也是该篇分享中唯一一个与磁盘有关系的数据结构。首先我们先了解一下磁盘的相关东西。&lt;/p&gt;

&lt;p&gt;系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位，位于同一块磁盘块中的数据会被一次性读取出来。InnoDB存储引擎中有页（Page）的概念，页是引擎管理磁盘的基本单位。&lt;/p&gt;

&lt;p&gt;2)数据结构和算法&lt;br/&gt;
首先，先了解一下一棵m阶B-Tree的特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  每个节点最多有m个子节点；&lt;/li&gt;
&lt;li&gt;  除了根节点和叶子结点外，其他每个节点至少有m/2个子节点；&lt;/li&gt;
&lt;li&gt;  若根节点不是叶子节点，则至少有两个子节点；&lt;/li&gt;
&lt;li&gt;  所有的叶子结点都是同一深度；&lt;/li&gt;
&lt;li&gt;  每个非叶子节点都包含n个关键字&lt;/li&gt;
&lt;li&gt;  关键字的个数的关系为 m/2-1 &amp;lt; n &amp;lt; m -1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;B-Tree很适合作为搜索来使用，但是B-Tree有一个缺点就是针对范围查找支持的不太友好，所以才有了B+Tree；&lt;br/&gt;
那么B+Tree的特性在B-Tree的基础上又增加了如下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  非叶子节点只存储键值信息；&lt;/li&gt;
&lt;li&gt;  所有的叶子节点之间都有一个链指针（方便范围查找）；&lt;/li&gt;
&lt;li&gt;  数据记录都存放在叶子节点中；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们将上述特点描述整理成下图（假设一个页（Page）只能写四个数据）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ac0e664400f41c9ae75071a80ea894d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这样的数据结构可以进行两种运算，一种是针对主键的范围查找和分页查找，另外一种是从根节点开始，进行随机查找；&lt;/p&gt;

&lt;p&gt;3)优缺点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  优点：利用磁盘可以存储大量的数据，简单的表结构在深度为3的B+Tree上可以保存大概上亿条数据；B+Tree的深度大概也就是2~4，深度少就意味这IO会减少；B+Tree的时间复杂度log(m)N&lt;/li&gt;
&lt;li&gt;  缺点：插入或者删除数据有可能会导致数据页分裂；即使主键是递增的也无法避免随机写，这点LSM-Tree很好的解决了；无法支持全文索引；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4)使用场景&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  使用场景大多数数据库的引擎，例如MySql,MongoDB等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4.2.4 HashTree&lt;/p&gt;

&lt;p&gt;1)总述&lt;br/&gt;
HashTree是一种特殊的树状结构，根据质数分辨定理，树每层的个数为1、2、3、5、7、11、13、17、19、23、29…..&lt;/p&gt;

&lt;p&gt;2)数据结构和算法&lt;br/&gt;
从2起的连续质数，连续10个质数接可以分辨大约6464693230个数，而按照目前CPU的计算水平，100次取余的整数除法操作几乎不算什么难事。&lt;/p&gt;

&lt;p&gt;我们选择质数分辨算法来构建一颗哈希树。选择从2开始的连续质数来构建一个10层的哈希树。第一层节点为根节点，根节点先有2个节点，第二层的每个节点包含3个子节点；以此类推，即每层节点的数据都是连续的质数。对质数进行取余操作得到的数据决定了处理的路径。下面我们以随机插入10个数（442 9041 3460 3164 2997 3663 8250 908 8906 4005）为例，来图解HashTree的插入过程，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2575fab7529247d29d17e0f58d1dacad%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;HashTree的节点查找过程和节点插入过程类似，就是对关键字用质数取余，根据余数确定下一节点的分叉路径，知道找到目标节点。如上图，在从对象中查找所匹配的对象，比较次数不超过10次，也就是说时间复杂度最多是o(1).&lt;/p&gt;

&lt;p&gt;删除的过程和查找类似。&lt;/p&gt;

&lt;p&gt;3)优缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  优点：结构简单，查找迅速，结构不变。&lt;/li&gt;
&lt;li&gt;  缺点：非有序性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4.2.5 其他数据结构&lt;/p&gt;

&lt;p&gt;鉴于篇幅有限，余下重要数据结构将在下一篇文章中再来一起讨论，敬请期待！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;作者：郑冰 潘坤&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;京东云官网：&lt;a href=&quot;https://www.jdcloud.com/cn/pages/jinqiucaigou&quot;&gt;https://www.jdcloud.com/cn/pages/jinqiucaigou&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2cafcaf48167448b9e950f8087e9ca2f</guid>
<title>记一次因 @Async 引发的程序 bug</title>
<link>https://toutiao.io/k/ka76qjk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注我们&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5Al9mGgcTicr2DRNWiap86UpD9uae1wYx7cE12EicWUeAtoVfWsdFpCuDFITlJdJ6D80PJnSCibGVPa4rt7lns3gPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事情的起因是微服务A通过feign调用微服务B的某个接口，报了形如下的异常&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;feign&lt;span&gt;.FeignException&lt;/span&gt;&lt;span&gt;$NotFound&lt;/span&gt;: [&lt;span&gt;404&lt;/span&gt;] during [GET] to [http://feign-provider/test/async] [AyncTestServiceClient#testAsync()]: [{&lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;:&lt;span&gt;&quot;2022-05-28T01:16:36.283+0000&quot;&lt;/span&gt;,&lt;span&gt;&quot;status&quot;&lt;/span&gt;:&lt;span&gt;404&lt;/span&gt;,&lt;span&gt;&quot;error&quot;&lt;/span&gt;:&lt;span&gt;&quot;Not Found&quot;&lt;/span&gt;,&lt;span&gt;&quot;message&quot;&lt;/span&gt;:&lt;span&gt;&quot;No message available&quot;&lt;/span&gt;,&lt;span&gt;&quot;path&quot;&lt;/span&gt;:&lt;span&gt;&quot;/test/async&quot;&lt;/span&gt;}]&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负责微服务A的工程师小张就找到负责提供该接口的工程师小李，问小李是不是改动了接口，小李一脸无辜说他最近没对这个接口做任何改动，不过小李还是说道他排查一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;排查过程&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;小李排查的过程如下，他先通过swagger查看他提供给A服务接口是否存在，他一查发现他在swagger上看不到他提供给A服务的接口。于是他怀疑是不是有人动了他的代码，他就去查找最近的git提交记录，发现没人动他的代码，因为项目还没发布，都在测试阶段，他就根据项目集成的git-commit-id-maven-plugin插件定位到测试目前发布具体是哪个版本。（ps：对&lt;br data-filtered=&quot;filtered&quot;/&gt;git-commit-id-maven-plugin感兴趣的朋友，可以查看之前的文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247503020&amp;amp;idx=1&amp;amp;sn=c27c188d00f7ad01d0d5bf47d995f2fc&amp;amp;chksm=e9ed22dade9aabcc2c955ee6c73ca36f0509453ce1b8668a71192445bb4963a39f737787e88c&amp;amp;token=520781830&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;聊聊如何验证线上的版本是符合预期的版本&lt;/a&gt;）。然后他将该版本的代码下到本地进行调试，他发现代码中提供给A的接口还在，target下的class也有提供给A的接口class，但诡异的是swagger就是没显示他提供出去的接口，他一度以为是swagger出了问题，于是他用postman直接请求他提供A的接口，发现报了404。然后他就叫负责同个微服务B的同事小王，也帮忙试一下，发现结果就是404。后面没招，小李就去求助他们项目资深同事小林。&lt;/p&gt;&lt;p&gt;小林的排查思路如下，他先走查一下小李的接口代码，发现他提供的接口实现层的方法上加了一个@Async，示例形如下&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(AsyncTestService.INTER_NAME)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AsyncTestServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;AsyncTestService&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;async&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;testAsync&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;testAsync start....&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.doAsynBiz();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;testAsync end....&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello async&quot;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Async&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doAsynBiz&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            System.out.println(&lt;span&gt;&quot;doAsynBiz.....&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小林凭多年的经验直觉告诉小李说，应该是@Async引起。小李很斩钉截铁的说不可能啊，他@Async很早就加了，之前接口都可以访问的，小林一看小李说得那么肯定，他也不好打击小李。于是他接下来做了如下操作，先在项目中yml配置如下参数，开启springweb日志&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;loggin&lt;span&gt;g:&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  leve&lt;span&gt;l:&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    org.springframework.we&lt;span&gt;b:&lt;/span&gt; trace&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后在项目中加了形如下代码，来跟踪接口bean的类型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (String &lt;span&gt;beanDefinitionName &lt;/span&gt;: applicationContext.getBeanDefinitionNames()) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;if&lt;/span&gt;(beanDefinitionName.toLowerCase().startsWith(&lt;span&gt;&quot;AsyncTestService&quot;&lt;/span&gt;.toLowerCase())){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.err&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(beanDefinitionName + &lt;span&gt;&quot;=&quot;&lt;/span&gt; + applicationContext.getBean(beanDefinitionName).getClass());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启动控制台，看日志形如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;c.d.f.c.ConfigController:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {GET /config/&lt;span&gt;test&lt;/span&gt;}: &lt;span&gt;test&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;09:15:04 [main] TRACE o.s.w.s.m.m.a.RequestMappingHandlerMapping - &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  c.d.f.c.ConfigController:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {GET /config/&lt;span&gt;test&lt;/span&gt;}: &lt;span&gt;test&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;2022-05-28 09:15:04.564 TRACE 10120 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  c.d.f.i.UserServiceImpl:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {GET /user/{id}}: getUserById(Long)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;09:15:04 [main] TRACE o.s.w.s.m.m.a.RequestMappingHandlerMapping - &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  c.d.f.i.UserServiceImpl:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {GET /user/{id}}: getUserById(Long)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;2022-05-28 09:15:04.577 TRACE 10120 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  s.d.s.w.ApiResourceController:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  { /swagger-resources/configuration/ui}: &lt;span&gt;&lt;span&gt;uiConfiguration&lt;/span&gt;&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  { /swagger-resources}: &lt;span&gt;&lt;span&gt;swaggerResources&lt;/span&gt;&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  { /swagger-resources/configuration/security}: securityConfiguration()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;09:15:04 [main] TRACE o.s.w.s.m.m.a.RequestMappingHandlerMapping - &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  s.d.s.w.ApiResourceController:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  { /swagger-resources/configuration/ui}: &lt;span&gt;&lt;span&gt;uiConfiguration&lt;/span&gt;&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  { /swagger-resources}: &lt;span&gt;&lt;span&gt;swaggerResources&lt;/span&gt;&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  { /swagger-resources/configuration/security}: securityConfiguration()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;2022-05-28 09:15:04.590 TRACE 10120 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  o.s.b.a.w.s.e.BasicErrorController:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  { /error}: error(HttpServletRequest)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  { /error, produces [text/html]}: errorHtml(HttpServletRequest,HttpServletResponse)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;09:15:04 [main] TRACE o.s.w.s.m.m.a.RequestMappingHandlerMapping - &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  o.s.b.a.w.s.e.BasicErrorController:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  { /error}: error(HttpServletRequest)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  { /error, produces [text/html]}: errorHtml(HttpServletRequest,HttpServletResponse)&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发现确实没打印出相关requestMapping映射信息，这可以说明一点就是小李那个接口没有绑定到springmvc映射，也就是出现404的原因。接着观察控制台打印的bean，内容形如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;asyncTestServiceImpl&lt;/span&gt;=class com.sun.proxy.&lt;span&gt;$Proxy127&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这很明显这个接口bean已经被jdk动态代理给替换。小李看到控制台打印的信息，若有所思，然后说，我把@Async去掉试下。小李把@Async去掉后，再观察下控制台&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;2022-05-28&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;:09&lt;/span&gt;&lt;span&gt;:40.814&lt;/span&gt; &lt;span&gt;TRACE&lt;/span&gt; &lt;span&gt;13028&lt;/span&gt; &lt;span&gt;---&lt;/span&gt; &lt;span&gt;[ main]&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;.RequestMappingHandlerMapping&lt;/span&gt; : &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.d&lt;/span&gt;&lt;span&gt;.f&lt;/span&gt;&lt;span&gt;.c&lt;/span&gt;&lt;span&gt;.AsyncTestServiceImpl&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {&lt;span&gt;GET&lt;/span&gt; /&lt;span&gt;test&lt;/span&gt;/&lt;span&gt;async&lt;/span&gt;}: &lt;span&gt;testAsync&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;:09&lt;/span&gt;&lt;span&gt;:40&lt;/span&gt; &lt;span&gt;[main]&lt;/span&gt; &lt;span&gt;TRACE&lt;/span&gt; &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;.RequestMappingHandlerMapping&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.d&lt;/span&gt;&lt;span&gt;.f&lt;/span&gt;&lt;span&gt;.c&lt;/span&gt;&lt;span&gt;.AsyncTestServiceImpl&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {&lt;span&gt;GET&lt;/span&gt; /&lt;span&gt;test&lt;/span&gt;/&lt;span&gt;async&lt;/span&gt;}: &lt;span&gt;testAsync&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;2022-05-28&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;:09&lt;/span&gt;&lt;span&gt;:40.817&lt;/span&gt; &lt;span&gt;TRACE&lt;/span&gt; &lt;span&gt;13028&lt;/span&gt; &lt;span&gt;---&lt;/span&gt; &lt;span&gt;[ main]&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;.RequestMappingHandlerMapping&lt;/span&gt; : &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.d&lt;/span&gt;&lt;span&gt;.f&lt;/span&gt;&lt;span&gt;.c&lt;/span&gt;&lt;span&gt;.ConfigController&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {&lt;span&gt;GET&lt;/span&gt; /&lt;span&gt;config&lt;/span&gt;/&lt;span&gt;test&lt;/span&gt;}: &lt;span&gt;test&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;:09&lt;/span&gt;&lt;span&gt;:40&lt;/span&gt; &lt;span&gt;[main]&lt;/span&gt; &lt;span&gt;TRACE&lt;/span&gt; &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;.RequestMappingHandlerMapping&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.d&lt;/span&gt;&lt;span&gt;.f&lt;/span&gt;&lt;span&gt;.c&lt;/span&gt;&lt;span&gt;.ConfigController&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {&lt;span&gt;GET&lt;/span&gt; /&lt;span&gt;config&lt;/span&gt;/&lt;span&gt;test&lt;/span&gt;}: &lt;span&gt;test&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;2022-05-28&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;:09&lt;/span&gt;&lt;span&gt;:40.820&lt;/span&gt; &lt;span&gt;TRACE&lt;/span&gt; &lt;span&gt;13028&lt;/span&gt; &lt;span&gt;---&lt;/span&gt; &lt;span&gt;[ main]&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;.RequestMappingHandlerMapping&lt;/span&gt; : &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.d&lt;/span&gt;&lt;span&gt;.f&lt;/span&gt;&lt;span&gt;.i&lt;/span&gt;&lt;span&gt;.UserServiceImpl&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {&lt;span&gt;GET&lt;/span&gt; /&lt;span&gt;user&lt;/span&gt;/{&lt;span&gt;id&lt;/span&gt;}}: &lt;span&gt;getUserById&lt;/span&gt;(Long)&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;asyncTestServiceImpl&lt;/span&gt;=class com.demo.feign.controller.AsyncTestServiceImpl&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过控制台可以发现，此时接口已经绑定到springmvc映射，而且打印出bean类型是真实对象bean。小李看到这个现象，也百思不得其解，他说道他之前确实是加了@Async，接口也能正常访问。于是小林就问一句，你确定你加了@Async，异步生效了吗，小李说开启spring异步，不都是加@Async吗。小林又问了一句，你在项目中开启异步，除了加@Async，还有做什么处理吗，小李说没了，他之前在项目使用异步就都是加了@Async，也能用了好好的，小林一听，基本上知道为什么小李之前@Async，接口还能正常访问了，小林为了验证想法，就问同负责该项目的小王，说你最近有加什么异步操作吗，小王说有，小林进一步问，你是怎么做的，小王说，他先加@EnabledAsyn，开启异步，然后在业务逻辑层上的方法上加@Async注解。小李一听，说原来使用@Async还要配合@EnabledAsyn啊，他之前都不知道&lt;/p&gt;&lt;p&gt;接着小李说&lt;strong&gt;那在controller是不是就不能使用@Async注解了？&lt;/strong&gt;，小林说最好是把加@Async的逻辑挪到service层去处理，不过也不是controller就不能使用@Async注解了，接着小林为了验证这个想法，他把原来实现的接口类去掉，形如下&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;@&lt;span&gt;RestController&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;@RequestMapping(AsyncTestService.INTER_NAME)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class AsyncTestServiceImpl{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    @&lt;span&gt;GetMapping&lt;/span&gt;(&quot;&lt;span&gt;async&lt;/span&gt;&quot;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    public String testAsync() {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.toString&lt;/span&gt;() + &quot;&lt;span&gt;-----testAsync&lt;/span&gt; &lt;span&gt;start&lt;/span&gt;....&quot;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.doAsynBiz&lt;/span&gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.toString&lt;/span&gt;() + &quot;&lt;span&gt;-----testAsync&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;....&quot;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;hello&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&quot;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    @&lt;span&gt;Async&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    public void doAsynBiz(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.toString&lt;/span&gt;() + &quot;&lt;span&gt;-----doAsynBiz&lt;/span&gt;.....&quot;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启动后，查看控制台&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;2022-05-28&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;:41&lt;/span&gt;&lt;span&gt;:31.624&lt;/span&gt; &lt;span&gt;TRACE&lt;/span&gt; &lt;span&gt;5068&lt;/span&gt; &lt;span&gt;---&lt;/span&gt; &lt;span&gt;[ main]&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;.RequestMappingHandlerMapping&lt;/span&gt; : &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.d&lt;/span&gt;&lt;span&gt;.f&lt;/span&gt;&lt;span&gt;.c&lt;/span&gt;&lt;span&gt;.AsyncTestServiceImpl&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {&lt;span&gt;GET&lt;/span&gt; /&lt;span&gt;test&lt;/span&gt;/&lt;span&gt;async&lt;/span&gt;}: &lt;span&gt;testAsync&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;:41&lt;/span&gt;&lt;span&gt;:31&lt;/span&gt; &lt;span&gt;[main]&lt;/span&gt; &lt;span&gt;TRACE&lt;/span&gt; &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;.RequestMappingHandlerMapping&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.d&lt;/span&gt;&lt;span&gt;.f&lt;/span&gt;&lt;span&gt;.c&lt;/span&gt;&lt;span&gt;.AsyncTestServiceImpl&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {&lt;span&gt;GET&lt;/span&gt; /&lt;span&gt;test&lt;/span&gt;/&lt;span&gt;async&lt;/span&gt;}: &lt;span&gt;testAsync&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;2022-05-28&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;:41&lt;/span&gt;&lt;span&gt;:31.627&lt;/span&gt; &lt;span&gt;TRACE&lt;/span&gt; &lt;span&gt;5068&lt;/span&gt; &lt;span&gt;---&lt;/span&gt; &lt;span&gt;[ main]&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;.RequestMappingHandlerMapping&lt;/span&gt; : &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.d&lt;/span&gt;&lt;span&gt;.f&lt;/span&gt;&lt;span&gt;.c&lt;/span&gt;&lt;span&gt;.ConfigController&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {&lt;span&gt;GET&lt;/span&gt; /&lt;span&gt;config&lt;/span&gt;/&lt;span&gt;test&lt;/span&gt;}: &lt;span&gt;test&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;:41&lt;/span&gt;&lt;span&gt;:31&lt;/span&gt; &lt;span&gt;[main]&lt;/span&gt; &lt;span&gt;TRACE&lt;/span&gt; &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;.RequestMappingHandlerMapping&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时bean的类型如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;asyncTestServiceImpl&lt;/span&gt;=class com.demo.feign.controller.AsyncTestServiceImpl$&lt;span&gt;$EnhancerBySpringCGLIB&lt;/span&gt;$&lt;span&gt;$a285a21c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;访问接口，打印内容如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;Thread&lt;span&gt;[http-nio-8080-exec-1,5,main]&lt;/span&gt;-----testAsync start....&lt;br mpa-from-tpl=&quot;t&quot;/&gt;Thread&lt;span&gt;[http-nio-8080-exec-1,5,main]&lt;/span&gt;-----doAsynBiz.....&lt;br mpa-from-tpl=&quot;t&quot;/&gt;Thread&lt;span&gt;[http-nio-8080-exec-1,5,main]&lt;/span&gt;-----testAsync end....&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从控制台可以发现，都是http-nio-8080-exec-1线程触发，说明异步没生效，即@Async失效。后面对controller做了如下改造&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;@&lt;span&gt;RestController&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;@RequestMapping(AsyncTestService.INTER_NAME)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class AsyncTestServiceImpl{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    @&lt;span&gt;Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private ObjectProvider&amp;lt;AsyncTestServiceImpl&amp;gt; asyncTestServices;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    @&lt;span&gt;GetMapping&lt;/span&gt;(&quot;&lt;span&gt;async&lt;/span&gt;&quot;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    public String testAsync() {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.toString&lt;/span&gt;() + &quot;&lt;span&gt;-----testAsync&lt;/span&gt; &lt;span&gt;start&lt;/span&gt;....&quot;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;asyncTestServices&lt;/span&gt;&lt;span&gt;.getIfAvailable&lt;/span&gt;()&lt;span&gt;.doAsynBiz&lt;/span&gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.toString&lt;/span&gt;() + &quot;&lt;span&gt;-----testAsync&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;....&quot;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;hello&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&quot;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    @&lt;span&gt;Async&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    public void doAsynBiz(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.toString&lt;/span&gt;() + &quot;&lt;span&gt;-----doAsynBiz&lt;/span&gt;.....&quot;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;访问接口，打印内容如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;Thread&lt;span&gt;[http-nio-8080-exec-2,5,main]&lt;/span&gt;-----testAsync start....&lt;br mpa-from-tpl=&quot;t&quot;/&gt;Thread&lt;span&gt;[http-nio-8080-exec-2,5,main]&lt;/span&gt;-----testAsync end....&lt;br mpa-from-tpl=&quot;t&quot;/&gt;Thread&lt;span&gt;[task-1,5,main]&lt;/span&gt;-----doAsynBiz.....&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这说明在controller其实也是可以用@Async，只是要额外做处理。所以建议是把@Async从controller中抽离出去，在新类中进行处理，示例如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AysncService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Async&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doAsynBiz&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;-----doAsynBiz.....&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(AsyncTestService.INTER_NAME)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@RequiredArgsConstructor&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AsyncTestServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;AsyncTestService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AysncService aysncService;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;testAsync&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;-----testAsync start....&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        aysncService.doAsynBiz();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;-----testAsync end....&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello async&quot;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;访问接口，打印内容&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;http-nio-8080-exec-1&lt;span&gt;-----testAsync start....&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;http-nio-8080-exec-1&lt;span&gt;-----testAsync end....&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;task-1&lt;span&gt;-----doAsynBiz.....&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说明异步生效&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;排查结果分析&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icdkN5zDv0xCRzIgMSJh5wYKVFZJBvY1tPMtIfib5jAGA6ozWMx9DxxYFxzUdMBrh2zkJChfkTrPia3ibgcUicAg1Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;36&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;接口404&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从mvc日志&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;2022-05-28&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;:59&lt;/span&gt;&lt;span&gt;:50.394&lt;/span&gt; &lt;span&gt;TRACE&lt;/span&gt; &lt;span&gt;14152&lt;/span&gt; &lt;span&gt;---&lt;/span&gt; &lt;span&gt;[ main]&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;.RequestMappingHandlerMapping&lt;/span&gt; : &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.d&lt;/span&gt;&lt;span&gt;.f&lt;/span&gt;&lt;span&gt;.c&lt;/span&gt;&lt;span&gt;.AsyncTestServiceImpl&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {&lt;span&gt;GET&lt;/span&gt; /&lt;span&gt;test&lt;/span&gt;/&lt;span&gt;async&lt;/span&gt;}: &lt;span&gt;testAsync&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;:59&lt;/span&gt;&lt;span&gt;:50&lt;/span&gt; &lt;span&gt;[main]&lt;/span&gt; &lt;span&gt;TRACE&lt;/span&gt; &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;.RequestMappingHandlerMapping&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.d&lt;/span&gt;&lt;span&gt;.f&lt;/span&gt;&lt;span&gt;.c&lt;/span&gt;&lt;span&gt;.AsyncTestServiceImpl&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  {&lt;span&gt;GET&lt;/span&gt; /&lt;span&gt;test&lt;/span&gt;/&lt;span&gt;async&lt;/span&gt;}: &lt;span&gt;testAsync&lt;/span&gt;()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;2022-05-28&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;:59&lt;/span&gt;&lt;span&gt;:50.397&lt;/span&gt; &lt;span&gt;TRACE&lt;/span&gt; &lt;span&gt;14152&lt;/span&gt; &lt;span&gt;---&lt;/span&gt; &lt;span&gt;[ main]&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;.RequestMappingHandlerMapping&lt;/span&gt; :&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以知道，controller映射处理是在RequestMappingHandlerMapping 这个类中，但具体是哪个方法进行处理呢，我们可以通过日志打印的信息，进行倒推，也可以基于spring的特性加断点调试，比如通过afterPropertiesSet这一启动扩展点调试起，就会发现RequestMappingHandlerMapping的映射处理是在&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initHandlerMethods&lt;/span&gt;() {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;for&lt;/span&gt; (String &lt;span&gt;beanName &lt;/span&gt;: getCandidateBeanNames()) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;processCandidateBean&lt;/span&gt;(beanName);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;handlerMethodsInitialized&lt;/span&gt;(getHandlerMethods());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进行处理，具体是通过processCandidateBean进行处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processCandidateBean&lt;/span&gt;(&lt;span&gt;String beanName&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Class&amp;lt;?&amp;gt; beanType = &lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      beanType = obtainApplicationContext().getType(beanName);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;catch&lt;/span&gt; (Throwable ex) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;// An unresolvable bean type, probably from a lazy bean - let&#x27;s ignore it.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (logger.isTraceEnabled()) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        logger.trace(&lt;span&gt;&quot;Could not resolve type for bean &#x27;&quot;&lt;/span&gt; + beanName + &lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;, ex);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (beanType != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; isHandler(beanType)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      detectHandlerMethods(beanName);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终是通过detectHandlerMethods进行处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; detectHandlerMethods(&lt;span&gt;Object&lt;/span&gt; handler) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Class&amp;lt;?&amp;gt; handlerType = (handler &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; ?&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        obtainApplicationContext().getType((&lt;span&gt;String&lt;/span&gt;) handler) : handler.getClass());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (handlerType != &lt;span&gt;null&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      Class&amp;lt;?&amp;gt; userType = ClassUtils.getUserClass(handlerType);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      Map&amp;lt;Method, T&amp;gt; methods = MethodIntrospector.selectMethods(userType,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;          (MethodIntrospector.MetadataLookup&amp;lt;T&amp;gt;) method -&amp;gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;              &lt;span&gt;return&lt;/span&gt; getMappingForMethod(method, userType);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;catch&lt;/span&gt; (Throwable ex) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;              &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;Invalid mapping on handler class [&quot;&lt;/span&gt; +&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                  userType.getName() + &lt;span&gt;&quot;]: &quot;&lt;/span&gt; + method, ex);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;          });&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (logger.isTraceEnabled()) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        logger.trace(formatMappings(userType, methods));&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      methods.forEach((method, mapping) -&amp;gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        registerHandlerMethod(handler, invocableMethod, mapping);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      });&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个里面就是做了实际注册。而执行detectHandlerMethods的前提是&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;beanType != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; isHandler(beanType)&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;@Override&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  protected boolean isHandler(Class&amp;lt;?&amp;gt; beanType) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;return&lt;/span&gt; (AnnotatedElementUtils.hasAnnotation(beanType, Controller.&lt;span&gt;class&lt;/span&gt;) &lt;span&gt;||&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.&lt;span&gt;class&lt;/span&gt;));&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即只有加了@Controller或者@RequestMapping的类会进行处理，而@RestController为啥也处理，点击&lt;/span&gt;&lt;span&gt;@RestController发现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Controller&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public &lt;span&gt;@interface&lt;/span&gt; RestController {&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他本质就是@Controller。但我们通过反射查找注解，正常只会查找一层，比如&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;AsynTestController&lt;/span&gt;&lt;span&gt;.class&lt;/span&gt;&lt;span&gt;.getAnnotation&lt;/span&gt;(&lt;span&gt;RestController&lt;/span&gt;&lt;span&gt;.class&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;他找到@RestController这一层，而不会找继续再找@RestController里面的@Controller，而AnnotatedElementUtils.hasAnnotation，这个注解方法就不一样，他是可以找到合并注解，即使是使用&lt;br data-filtered=&quot;filtered&quot;/&gt;@RestController，他还会继续找到里面的@Controller。因此这个方法对于找复合型注解很有用&lt;/p&gt;&lt;p&gt;&lt;strong&gt;当我们使用jdk动态代理时，因为父类上没加@Controller或者@RequestMapping，因此他不会被mvc进行映射处理，导致404。而使用cglib时，因为他是作为子类继承了目标类，因此他会继承目标类上的注解，因此当为cglib代理时，他会正常被mvc进行映射处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icdkN5zDv0xCRzIgMSJh5wYKVFZJBvY1tPMtIfib5jAGA6ozWMx9DxxYFxzUdMBrh2zkJChfkTrPia3ibgcUicAg1Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;36&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;为何controller里面加了@Asyn异步就失效了&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;这是因为加了@Async后，controller变成代理了，而当要异步处理方法，用this时，他使用的是目标对象，而非代理对象。这跟现在面试事务为啥事务失效的八股文基本是一个套路&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;04&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文主要讲@Async导致controller 404，同时也使@Async失效的原因。解决的推荐方法就是将@Async抽离出controller，新建一个service类进行处理。&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>83cadbe68dbcf691dab28900d1773f2b</guid>
<title>从 SpringBoot 启动，阅读源码设计</title>
<link>https://toutiao.io/k/1s3gzfx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;服务启动堪称Spring源码设计的答案；&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、背景说明&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;初学SpringBoot框架时，第一次启动服务，直呼什么鬼？只需要简单的几步配置，几个核心的注解，就可以快速实现工程的搭建和运行；&lt;/p&gt;&lt;p&gt;虽然从Spring框架迁移到SpringBoot框架，在初期会有很多的不适应，但是更好用的框架会快速得到认可，从而成为主流的技术选型；&lt;/p&gt;&lt;p&gt;对于大多数的框架或者组件来说，如果使用起来越是简便，那么其内部的封装策略就越是复杂；&lt;/p&gt;&lt;p&gt;比如在Spring框架更新到SpringBoot版本时，其用法的简便与内部封装的复杂性已经形成强烈的对比；再到SpringCloud微服务框架时，其封装逻辑复杂到离谱；&lt;/p&gt;&lt;p&gt;对于服务端的开发来说，绕不开对Spring框架的深度学习，如果单纯站在源码阅读的角度，建议先熟读SpringBoot启动流程，然后再适当扩展其他源码块；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、SpringBoot工程&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;首先聊一聊阅读源码的基本思路，从一个极简的案例开始，围绕案例中的核心API作为切入点，通过对源码逻辑的断点调试，从而体会其设计的原理；&lt;/p&gt;&lt;p&gt;阅读SpringBoot的源码，可以从服务启动方法作为切入点，然后不断的分析启动过程涉及到的核心API和设计原理，再基于具体的启动日志去分析抽象的加载逻辑；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.29609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBtDLGkJtfWb7piaCorDSicVH9wVs5DMaOAiajic0VwxyTROOyhoY01X7tuKmHN7UICQ6icEKhBNrUKlyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;在看具体的源码之前，还需要说下分析思路，Spring项目中，要注意每个API所属工程与层级，然后再去分析API之间关系，核心的构造、属性、方法等；&lt;/p&gt;&lt;p&gt;在SpringBoot的启动类中，有两个核心的切入点，一个是类的构造方法，完成一列的初始化动作；一个是启动方法，实现应用上下文的创建和装载；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;构造方法&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.26015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBtDLGkJtfWb7piaCorDSicVHuR5mBpyKCws0sfBzCr5jTicJDvBDiapCDqC7bxVNpmJkk4R4y3X2oBEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;启动方法&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.26015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBtDLGkJtfWb7piaCorDSicVHMqAHTbiajY7KRTUL8ZHHXabyJib4LJzdOAeGG8GKAaIbzSA9zqxH2M3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;需要说明的是，由于SpringBoot服务启动过程涉及源码过多，所以上面的源码中只是罗列部分的核心切入点，然后围绕这些关键流程展开，分析一些常见的源码设计；&lt;/p&gt;&lt;p&gt;另外说明一点，以下源码的核心版本：&lt;code&gt;JDK-1.8&lt;/code&gt;，&lt;code&gt;spring-5.2.4&lt;/code&gt;，&lt;code&gt;spring-boot-2.2.5&lt;/code&gt;，在不同的版本下源码会存在差异；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、应用上下文&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;服务启动时，根据应用类型判断创建的上下文，此处启动的是基于servlet的web应用，所以也依赖相应的web服务器，默认为Tomcat；&lt;/p&gt;&lt;p&gt;启动方法的核心在于对应用上下文的创建、准备、刷新，应用上下文是一个十分抽象的描述，可以理解为应用运行的整体环境，其中涉及到资源加载，配置文件装配，运行服务的管理等，后续的源码分析都围绕该API展开；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBtDLGkJtfWb7piaCorDSicVH08O9RQbI0mqgV5gOicsRIa9ia8CNxs9O8cImQFsmRYfNcdzVmxHnLBIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ApplicationContext&lt;/strong&gt;：应用上下文核心接口，在该接口中所有的方法都是只读模式，即只能通过Get方法进行访问；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ConfigurableApplicationContext&lt;/strong&gt;：上下文配置扩展接口，提供了应用上下文的配置能力，生命周期的维护，以及在关闭之后的相关资源释放；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;AbstractApplicationContext&lt;/strong&gt;：上下文接口抽象实现，核心的API，对应用上下文中的公共能力做了实现；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ConfigurableWebApplicationContext&lt;/strong&gt;：Web应用上下文配置扩展接口，提供了Web应用的上下文配置能力；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;WebServerApplicationContext&lt;/strong&gt;：Web服务上下文，创建并管理Web应用的服务器，在该流程中嵌入的是Tomcat服务；&lt;/p&gt;&lt;p&gt;根据应用上下文几个核心的API设计，体会Spring源码的设计思路，从顶级的接口开始，不断向下扩展并且新增方法，理解抽象实现类的逻辑，以及服务运行时所依赖的具体API；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、资源加载&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;什么是资源，可以是各种类型的文件和配置，字节输入流的转换，也可以是URL资源定位，Spring框架在运行的过程中，需要依赖Resource接口实现对底层资源的访问；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBtDLGkJtfWb7piaCorDSicVHBtyialWLB49j0kYPxibvu2NxTBhBLmftxnd9ohLIQI7ibHUNcZvdq7eEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Resource&lt;/strong&gt;：资源描述的顶级接口，提供了一系列的方法，继承InputStreamSource接口，支持将资源转换为流的形式操作；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;AbstractResource&lt;/strong&gt;：资源访问的抽象实现类，这里的设计原理与AbstractApplicationContext类似，提供资源访问方法的基础实现；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ResourceLoader&lt;/strong&gt;：资源加载的封装接口，应用下文需要依赖该接口实现资源的获取与访问；&lt;/p&gt;&lt;p&gt;针对不同应用场景需求，Resource接口的实现类有如下几个：FileSystemResource文件系统资源，ClassPathResource类路径下资源，InputStreamResource输入流资源等；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、应用环境&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;对于Property和Environment源码设计体系，参考上述的源码模块，在思路上是相似的，此处不多描述；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.19375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBtDLGkJtfWb7piaCorDSicVHXBIrGlk8gicicb8qTF9aiaRZRkiaIYQS3EevVA2oib7icjShDyErlfRaicjbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;应用程序的属性和环境涉及到的参数描述非常多，比较直接的手段是通过System类中的方法输出，至于信息如何加载，在StandardEnvironment类中提供了方法，可以断点查看；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;六、Bean对象&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;基于Spring框架的应用程序中，由Spring容器负责创建，装配，设置属性，进而管理整个生命周期的对象，称为Bean对象；Bean的生命周期非常复杂，过程大致如下：实例化，属性加载，初始化前后管理，销毁；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.06640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBtDLGkJtfWb7piaCorDSicVHfq0QvVtN5RfJbRNzMFz8vxgUQUchwY8oGmwW94e9ibD6ZGYEZrXDiacA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;BeanFactory&lt;/strong&gt;：工厂类，Spring框架的核心能力，Bean容器的顶级接口，提供了一系列Bean对象的访问方法，是IOC思想和依赖注入的基础支撑；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ConfigurableBeanFactory&lt;/strong&gt;：Bean容器可配置化接口，该扩展接口只是为了允许框架内部的即插即用和访问bean工厂的配置方法；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;AbstractBeanFactory&lt;/strong&gt;：Bean管理的抽象实现类，可以查看其内部doGetBean方法，提供Bean实例对象的获取逻辑，如果无法获取则执行创建逻辑；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;七、Tomcat服务&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;初次启动SpringBoot工程时，最大的疑问就是可见Tomcat启动日志，但是没有显式的做服务器装配，直接启动JAR包即可，这在流程上简化了一大步；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.09609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBtDLGkJtfWb7piaCorDSicVHxXiauuBwm4fega2yNxK5mEEaibg2hIZ59g9YnSxck1Cc7s3sol66n4CA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;WebServer&lt;/strong&gt;：Web应用服务器接口，比如常用的Tomcat，Jetty，Netty等，根据应用类型选择，只提供了启动、停止、获取端口三个方法，通过WebServerApplicationContext与应用上下文相关联；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TomcatWebServer&lt;/strong&gt;：SpringBoot框架管理内置Tomcat服务的核心类，对Tomcat生命周期的管理提供了一层包装；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Tomcat&lt;/strong&gt;：Apache组件中轻量级Tomcat启动器，提供了Tomcat基础配置，比如默认的Port和HostName，以及生命周期管理的方法，TomcatWebServer类中调用的就是该API中的具体方法；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;八、事件模型&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;事件驱动模型是复杂流程中的常用解耦手段，即通过事件发送和监听两个拆解动作，实现流程的分步执行，这在SpringBoot启动流程和上下文装载中更是发挥的淋漓尽致；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.13359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBtDLGkJtfWb7piaCorDSicVHcCTDXblfcYjicSLj1e1EWOJNCRHicnMsKIMbNEEicfMicLfewVNOnLIVAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ApplicationEvent&lt;/strong&gt;：应用事件基础抽象类，继承自JDK中EventObject类，具体事件会继承该类，内部声明了事件源和发生时间两个核心属性；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ApplicationEventMulticaster&lt;/strong&gt;：应用事件广播的顶级接口，可以将指定的应用事件广播给适合的监听器；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;SimpleApplicationEventMulticaster&lt;/strong&gt;：应用事件广播接口的简单实现，可以断点该类的multicastEvent方法，查看广播时应用事件和其相应的监听器；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ApplicationListener&lt;/strong&gt;：应用事件监听器接口，继承自JDK中EventListener接口，Spring中扩展了多种具体的事件监听器，以实现各种不同的场景需求，比如最常见的ConfigFileApplicationListener配置文件监听器；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;九、配置加载&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;SpringBoot工程中，配置文件的管理策略非常复杂，有内部程序执行加载配置，也有外部集成的组件配置，当然最核心的就是工程的自定义配置；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.23125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBtDLGkJtfWb7piaCorDSicVHfpoCNibWv3tJcjkLHkpYjR3XiavEBYuK9JFFCDSVVLwFNqtRbeXvFUsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ConfigFileApplicationListener.Loader&lt;/strong&gt;：配置文件监听器的内部类，实现对工程中的配置源加载，其核心逻辑在Loader.load方法中实现，具体逻辑由相关的实现类完成；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;PropertySourceLoader&lt;/strong&gt;：配置加载的策略接口，在Spring工程中支持多种类型的文件配置，比如yml、yaml、properties、xml，需要通过文件的扩展名选择相应的加载实现类；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;YamlPropertySourceLoader&lt;/strong&gt;：加载&lt;code&gt;.yml&lt;/code&gt;或者&lt;code&gt;.yaml&lt;/code&gt;类型的文件，SpringBoot工程中常用的配置文件类型，最终转换成Name和Value的属性源集合，即通过PropertySource抽象类来描述；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;十、数据库集成&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;Spring框架的强大之处还在于能够和其他组件进行简单快速的集成，比如常用的数据库、缓存、消息队列等各种类型的组件，分析内部的集成逻辑，会发现很多原理上的相似性，尤其在SpringBoot框架中，约定大于配置；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.0921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBtDLGkJtfWb7piaCorDSicVHhb6nJXSlKym3vRdMozhCWbt4qj64rxTAQ6tT6MQ7NTrwB6TenH5YfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;DataSourceAutoConfiguration&lt;/strong&gt;：SpringBoot工程中数据库的自动化配置类，在配置中Hikari是默认选择的连接池，也是号称速度最快的；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;DataSourceProperties&lt;/strong&gt;：数据源配置相关的基础类，在DataSourceConfiguration配置类中，会基于参数去创建数据源对象；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;HikariDataSource&lt;/strong&gt;：Hikari连接池组件中的数据源API，描述数据源的具体信息，例如配置、连接池、状态等，具体的数据库连接逻辑是在该组件内部完成的；&lt;/p&gt;&lt;p&gt;基于SpringBoot集成数据库的原理，可以扩展性的看看：Redis组件的RedisAutoConfiguration配置类；Kafka组件的KafkaAutoConfiguration配置类，Elasticsearch组件的RestClientAutoConfiguration配置类，在设计原理上都有异曲同工之妙；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;写在最后&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从个人经验来看，想要阅读Spring框架的源码设计，需要基于应用流程先构建一个大的轮廓结构，理解设计中的常用策略和原理，然后再深入单个模块的细节逻辑，这样容易找到阅读节奏；&lt;/p&gt;&lt;p&gt;本文并没有涉及源码中过多的细节逻辑，只是从服务启动作为切入点，整理与开发关联性较为直接的源码模块，描述个人对于Spring源码阅读的基础思路。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;十一、参考源码&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;br/&gt;&lt;br/&gt;组件封装：&lt;br/&gt;https://gitee.com/cicadasmile/butte-frame-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBj3abVSgCmvm7FIYw55ficInd2se9ia6KSic0ma25AUvrmUtXUwXibjhHmCc7DUawfXBI30QuHBjDnzw/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累、总结、用心记录。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d93180fd44ff694f62bd696615a4e2f8</guid>
<title>即时通讯技术周刊（第1期）：懒人网络编程系列</title>
<link>https://toutiao.io/k/drn05h7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;为了更好地分类阅读 &lt;span&gt;52im.net 总计1000多篇&lt;/span&gt;精编文章，我将在每周三推送新的一期技术周刊，本次是第 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;1&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;&lt;span&gt;期。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;1 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;&lt;span&gt;[标题]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(一)：快速理解网络通信协议（上篇）&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;[链接]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-1095-1-1.html&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;[摘要] &lt;/span&gt;&lt;span&gt;互联网的核心是一系列协议，总称为&quot;互联网协议&quot;（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。&lt;/span&gt;&lt;span&gt;本篇将带你从理论上快速理解这些协议&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;2 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;&lt;span&gt;[标题]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(二)：快速理解网络通信协议（下篇）&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;[链接]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-1103-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[摘要]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;接上篇，本篇将以普通人实际上网为例子，通俗易懂地讲解网络通信协议到底是什么。&lt;/span&gt;&lt;span&gt;本篇带了有些基础的计网理论知识，但力求通俗不枯燥&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;3 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;[标题] &lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(三)：快速理解TCP协议一篇就够&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;[链接] &lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-1107-1-1.html&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;[摘要] &lt;/span&gt;&lt;span&gt;TCP 是互联网的核心协议之一，鉴于它的重要性，&lt;/span&gt;&lt;span&gt;本文将单独介绍它的基础知识，希望能加深您对TCP协议的理解&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;4 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;[标题] &lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(四)：快速理解TCP和UDP的差异&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;[链接] &lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-1160-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[摘要] &lt;/span&gt;&lt;span&gt;对于即时通讯开者新手来说，在开始着手编写IM或消息推送系统的代码前，最头疼的问题莫过于到底该选TCP还是UDP作为传输层协议。&lt;/span&gt;&lt;span&gt;本文延续《网络编程懒人入门》系列文章的风格，通过快速对比分析 TCP 和 UDP 的区别，来帮助即时通讯初学者快速了解这些基础的知识点，从而在IM、消息推送等网络通信应用场景中能准确地选择合适的传输层协议&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;5 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;[标题] &lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(五)：快速理解为什么说UDP有时比TCP更有优势&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;[链接] &lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-1277-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;[摘要] &lt;/span&gt;&lt;span&gt;随着网络技术飞速发展，网速已不再是传输的瓶颈，UDP协议以其简单、传输快的优势，在越来越多场景下取代了TCP，如网页浏览、流媒体、实时游戏、物联网。&lt;/span&gt;&lt;span&gt;本文作为《网络编程懒人入门》系列文章的第5篇，将为您快速梳理UDP协议在某些场景下对比TCP协议所具有的优势。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;6 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;[标题] &lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(六)：史上最通俗的集线器、交换机、路由器功能原理入门&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;[链接] &lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-1629-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;[摘要] &lt;/span&gt;&lt;span&gt;本文旨在简单地说明集线器、交换机与路由器的区别，因而忽略了很多细节，三者实际的发展过程和工作原理并非文中所写的这么简单。&lt;/span&gt;&lt;span&gt;如果你看完本文能大概了解到三者的异同，本文的目的就达到了。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;7 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;&lt;span&gt;[标题]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(七)：深入浅出，全面理解HTTP协议&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;[链接]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-1677-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[摘要]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;对于移动端即时通讯（尤其IM应用）来说，现今主流的数据通信总结下来无外乎就是长连接+短连接的方式，而短连接在应用上讲就是本文将要介绍的HTTP协议的应用，而正确地理解HTTP协议对于写好IM来说，是相当有益的&lt;/span&gt;&lt;span&gt;（关于移动端的HTTP具体应用情况，可以阅读《&lt;/span&gt;现代移动端网络短连接的优化手段总结：请求速度、弱网适应、安全保障 &lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-1413-1-1.html&lt;/span&gt;&lt;span&gt;&lt;span&gt;》）&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;8 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;[标题]&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(八)：手把手教你写基于TCP的Socket长连接&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;[链接]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-1722-1-1.html&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;[摘要]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;TCP 是互联网的核心协议之一，鉴于它的重要性，希望通过阅读上面介绍的几篇理论文章，再针对本文的动手实践，能真正加深您对TCP协议的理解。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;9 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;&lt;span&gt;[标题]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(九)：通俗讲解，有了IP地址，为何还要用MAC地址？&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;[链接]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-2067-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;[摘要]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;标题虽然是为了解释有了 IP 地址，为什么还要用 MAC 地址，但是本文的重点在于理解为什么要有 IP 这样的东西。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;本文对读者的定位是知道 MAC 地址是什么，IP 地址是什么&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;10 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;&lt;span&gt;[标题]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(十)：一泡尿的时间，快速读懂QUIC协议&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;[链接] &lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-2816-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[摘要] &lt;/span&gt;&lt;span&gt;&lt;span&gt;一般的稳定网络传输都是通过TCP，但是在网络基建本身就已经越来越完善的情况下，TCP设计本身的问题便暴露了出来，特别是在弱网环境下，让我们不得不考虑一些新的可能性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;11 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;&lt;span&gt;[标题]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(十一)：一文读懂什么是IPv6&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;[链接] &lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-2979-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[摘要]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;本文将用浅显易懂的文字，带你了解到底什么是IPv6&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;12 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;[标题] &lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(十二)：快速读懂Http/3协议，一篇就够！&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;[链接] &lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-3020-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[摘要]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;多年来，为了跟上互联网的发展，以及WWW上交换的内容种类增加，HTTP进行了几次重大升级，而HTTP/3就是目前的最新版本。&lt;/span&gt;&lt;span&gt;本文将从HTTP/3的基本概念、技术原理、应用场景和如何使用它等方面进行介绍，确保在有限的篇幅内，能让你通俗地理解它&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;13 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;[标题] &lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(十三)：一泡尿的时间，快速搞懂TCP和UDP的区别&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;[链接] &lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-3793-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[摘要] &lt;/span&gt;&lt;span&gt;不同于其它长篇大论，本文尽量以简洁精炼的文字，帮你总结归纳TCP和UDP协议的主要区别&lt;/span&gt;&lt;span&gt;，方便那些想掌握这方面知识又不愿意耗费太多时间去系统地学习网络理论基础的同学快速理解！&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;第 &lt;/span&gt;&lt;em&gt;14 &lt;/em&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span&gt;[标题] &lt;/span&gt;&lt;strong&gt;&lt;span&gt;网络编程懒人入门(十四)：到底什么是Socket？一文即懂！&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;[链接]&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-3821-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;[摘要] &lt;/span&gt;&lt;span&gt;本系列文章前面那些主要讲解的是计算机网络的理论基础，但对于即时通讯IM这方面的应用层开发者来说，跟计算机网络打道的其实是各种API接口。&lt;/span&gt;&lt;span&gt;本篇文章就来聊一下网络应用程序员最熟悉的Socket这个东西，抛开生涩的计算机网络理论，从应用层的角度来理解到底什么是Socket&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本篇是技术周刊首期，如果您对于周刊的文章归类、排版、阅读体验等方面有更好的建议，欢迎留言，非常感谢！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/st3UArDtcvLSeYZwq1QNSZTWTsN24excibESJQaSDIVo0NRHed1CLG4RQzNvXeGeSL3C74tGTs4cSqcXb6ZqnZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;  &lt;span&gt;我是Jack Jiang，我为自已带盐！&lt;/span&gt;&lt;br/&gt;&lt;span&gt;https://github.com/JackJiang2011/MobileIMSDK/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzMjM5ODk5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/st3UArDtcvI9RlO0mnPicSu8bvoyicibG3ALyNUI57TRFOJOdDOCibSIib46fjrqQHdsuWlrZYnDeM3sITicdVczVCMQ/0?wx_fmt=png&quot; data-nickname=&quot;即时通讯网&quot; data-alias=&quot;hello_52im&quot; data-signature=&quot;即时通讯网(52im.net)官方公众号，专注即时通讯技术的传播与分享。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>