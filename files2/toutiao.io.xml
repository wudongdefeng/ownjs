<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4fc7195464992e82a884e4900778b01a</guid>
<title>高并发是一种架构思维模式</title>
<link>https://toutiao.io/k/imslmgz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么是高并发，从字面上理解，就是在某一时刻产生大量的请求，那么多少量称为大量，业界并没有标准的衡量范围。&lt;span&gt;原因非常简单，不同的业务处理复杂度不一样&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我所理解的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;高并发，&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;它并不只是一个数字，而更是一种架构思维模式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，它让你在面对不同的复杂情况下，从容地选择不同的技术手段，来提升应用系统的&lt;span&gt;处理能力。&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，并不意味应用系统从诞生的那一刻，就需要具备强大的处理能力，这种做法并不提倡。要知道，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;脱离实际情况的技术，会显得毫无价值，甚至是一种浪费的表现&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;言归正传，那高并发到底是一种怎样的架构思维模式，它对架构设计又有什么影响，以及如何通过它来驱动架构演进，让我们接着往下读，慢慢去体会这其中的精髓。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;性能是一种基础&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在架构设计的过程中，思考固然重要，但目标更为关键。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;通过目标的牵引力，可以始终确保推进方向，不会脱离成功的轨道&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;那高并发的目标是什么，估计你的第一反应就是性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;没错，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;性能是高并发的目标之一，它不可或缺，但并不代表所有&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。而我将它视为是高并发的一种基础能力，它的能力高低将会直接影响到其他能力的取舍。例如：服务可用性，数据一致性等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能在软件研发过程中无处不在，不管是在非功能性需求中，还是在性能测试报告中，都能见到它的身影。那么如何来衡量它的高低呢，先来看看常用的性能指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每秒处理&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;事务&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;数（TPS）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每秒能够处理的事务数，其中T(Transactions)可以定义不同的含义，它可以是完整的一笔业务，也可以是单个的接口请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每秒请求数（RPS）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每秒请求数量，也可以叫做QPS，但它与TPS有所不同，前者注重请求能力，后者注重处理能力。不过，若所有请求都在得到响应后再次发起，那么RPS基本等于TPS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;响应时&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;长（RT）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从发出请求到得到响应的耗时，一般可以采用毫秒单位来表示，而在一些对RT比较敏感的业务场景下，可以使用精度更高的微秒来表示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;并发用户数（VU）&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;同时请求的用户数，很多人将它与并发数画上等号，&lt;/span&gt;但两者稍有不同，前者关注客户端，后者关注服务端，除非&lt;span&gt;每个&lt;/span&gt;&lt;span&gt;用户仅发送一笔请求，且请求从&lt;/span&gt;&lt;span&gt;&lt;span&gt;客户端到服务端&lt;/span&gt;没有延迟，同时服务端有足够的处&lt;/span&gt;&lt;/span&gt;&lt;span&gt;理线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上都是些常用的性能指标，基本可以覆盖80%以上的性能衡量要求。但千万不要以单个指标的高低来衡量性能。比如：订单查询TPS=100万就认为性能很高，但RT=10秒。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这显然毫无意义。因此，&lt;/span&gt;&lt;span&gt;建议同时观察多个指标的方式来衡量性能的高低，大多数情况下主要会关注TPS和RT，而你可以&lt;/span&gt;&lt;strong&gt;&lt;span&gt;将TPS视为一种水平能力，注重并行处理能力，&lt;span&gt;将RT视为一种垂直能力，注重单笔处理能力，&lt;/span&gt;两者缺一不可&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接触过性能测试的同学，可能会见过如下这种性能测试结果图，图中包含了刚才提到过的三个性能指标，其中横坐标为VU，纵坐标分别为TPS和RT。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.491796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gusYCVib6QezRYG7TTupdtd6tAbjoxSAT3jdWVkPJicOUGibzYb5sCfaiaWwawbMFsrG0K9wHnxzDibUzqYsmNEKxFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.067578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gusYCVib6QezRYG7TTupdtd6tAbjoxSAT4VKcATbkPbjCu9G3wDAMGggwEPbR0PnV97nHPBBP1vVico5U9BtIXyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：表格中的数据都是理想情况下的，实际上会有上下抖动，而这里只是为了想用它来解释一种现象而已。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图中的&lt;span&gt;两条曲线，&lt;/span&gt;在不断增加VU的情况下，TPS不断上升，但RT保持稳定，但当VU增加到一定量级的时候，TPS开始趋于稳定，而RT不断上升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你仔细观察，还会&lt;/span&gt;&lt;span&gt;发现一个奇妙的地方，当RT=25ms时，它们三者存在着某种关系，即：TPS=VU/RT。但当RT&amp;gt;25ms时，这种关系似乎被打破了，这里暂时先卖个关子，稍后再说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据表格中的数据，性&lt;/span&gt;&lt;span&gt;能测试报告结论：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最大TPS=65000，当&lt;/span&gt;&lt;span&gt;RT=25ms(最短)时，最大可承受VU=1500&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感觉有点不对劲，用刚才的公式来验证一下，1500/0.025s=60000，但最大却是TPS=65000。那是因为，当VU=1500时，应用系统的使用资源还有空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再来观察一下表格中的数据，VU从1500增加到1750时，TPS继续上升，且到了最大值65000。此时，你是不是会理解为当VU增加到1750时，使用资源被耗尽了。话虽没错，但不严谨。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：使用资源不一定是指硬件资源，也可能是其他方面，例如：应用系统设置的最大处理线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实在VU增加到1750前，使用资源就已饱和，那如何来测算VU的临界值呢。你可以将最大TPS作为已知条件，即：VU=TPS*RT，65000*0.025s=1625。也就是说，当VU=1625时，使用资源将出现瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;调整性能测试报告&lt;/span&gt;&lt;span&gt;结论：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最大TPS=65000，&lt;strong&gt;&lt;span&gt;当RT=25ms(最短)时&lt;/span&gt;&lt;/strong&gt;，最大可承受VU=1625&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有人会问，表格中的RT是不是平均值，首先回答为是。不过，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;高并发场景对RT会特别敏感，所以除了要考虑RT的平均值外，建议还要考虑它的分位值&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，例如：P99。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;举例：假设1000笔请求，其中900笔RT=23ms，50笔RT=36ms，50笔RT=50ms&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;平均值&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;P99值&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;P95值&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;P90值&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;25ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;50ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;36ms&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;23ms&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;P99的计算方式，是将1000笔请求的RT从小到大进行排序，然后取排在第99%位的数值，基于以上举例数据来进行计算，P99=50ms，其他分位值的计算方式类似。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再次调整性能测试报告结论：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;最大TPS=65000，当&lt;/span&gt;RT(平均)=25ms(最短)时，最大可承受VU=1625，RT(P99)=50ms，RT(P95)=36ms，RT(P90)=23ms&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在非功能性需求中，你可能会看到这样的需求，性能指标要求：&lt;span&gt;RT(平均)&lt;/span&gt;&amp;lt;=30。结合刚才的性能测试报告结论，&lt;/span&gt;&lt;span&gt;当&lt;/span&gt;&lt;span&gt;RT(平均)=25ms(最短)时，最大可承受VU=1625。那就等于在RT上还有5ms的容忍时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然是这样的话，那我们不妨就继续尝试增加VU，不过RT&lt;span&gt;(平均)&lt;/span&gt;会出现上升，但只要控制不要上升到30ms即可，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;这是一种通过牺牲耗时(RT)来换取并发用户数(VU)的行为&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。但请不要把它理解为每笔请求耗时都会上升5ms，这将是一个严重的误区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RT(平均)&lt;/span&gt;&lt;span&gt;的增加，完全可能&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;由于应用系统&lt;span&gt;当前&lt;/span&gt;没有足够的使用资源来处理请求所造成的，例如：处理线程。如果没有可用线程可以分配给请求时，就会将这请求先放入队列，等前面的请求处理完成并释放线程后，就可以继续处理队列中的请求了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那也就是说，没有进入队列的请求并不会增加额外的耗时，而只有进入队列的请求会增加。那么&lt;/span&gt;&lt;span&gt;进入队列的请求会&lt;/span&gt;&lt;span&gt;增加多少耗时呢，&lt;span&gt;在理想情况下(RT恒定)，&lt;/span&gt;可能会&lt;/span&gt;&lt;span&gt;是正常处理一笔请求耗时的倍数，而倍数的大小又取决于并发请求的数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设&lt;span&gt;最大处理&lt;/span&gt;线程=1625，若每个用户仅发送一笔请求，且请求从&lt;span&gt;客户端到服务端没有延迟的条件下，&lt;/span&gt;当并发用户数=1625时，能够保证&lt;/span&gt;&lt;span&gt;RT=25ms，但当&lt;span&gt;并发用户数&lt;/span&gt;&amp;gt;1625时，因为线程只能分配给1625笔请求，那多余的请求就无法保证RT=25ms。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;超过1625笔的请求会先放入队列，等前面1625笔请求处理完成后，再从队列中拿出最多1625笔请求进行下一批处理，如果队列中还有剩余请求，那就继续按照这种方式循环处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进入队列的请求，每等待一批就需要增加前一批的处理耗时。在理想情况下，每一批都是&lt;/span&gt;&lt;span&gt;RT=25ms，如果这笔请求在队列中等待了两批，那就要额外增加50ms的耗时。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;VU&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;第一批&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;第二批&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;第三批&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1000&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1000笔请求&lt;br/&gt;RT=25ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;2000&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1625笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=25ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;375笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=50ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;4000&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1625笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=25ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;1625&lt;/span&gt;笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=50ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;750笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=75ms&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，并不能简单通过VU=TPS*RT=&lt;span&gt;65000*0.03=1950&lt;/span&gt;来计算最大可承受VU。而是需要&lt;/span&gt;&lt;span&gt;引入一种叫做&lt;/span&gt;&lt;span&gt;&lt;strong&gt;科特尔法则(Little’s Law)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的排队模型来估算，不过由于这个法则比较复杂，这里暂时不做展开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过粗略估算后，VU大约在2032，我们再对这个值用上述表格中再反向验算一下。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;VU&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;第一批&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;第二批&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;(平均)&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;2032&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1625笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=25ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;407笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=50ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;(1625*25+407*50)/(1625+407&lt;/span&gt;&lt;span&gt;)≈30ms&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终&lt;span&gt;调整性能测试报告结论：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;最大TPS=65000，当RT(平均)=25(最短)时，最大可承受VU=1625，RT(P99)=50，RT(P95)=36，RT(P90)=23；当RT(平均)=30(容忍)时，(理想情况)最大可承受VU=2032&lt;span&gt;，&lt;strong&gt;RT(P99)=RT(P95)=50，RT(P90)=25&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这就解释了为什么当RT&amp;gt;25ms时，VU=TPS*RT会不成立的原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;不过，这些都是在理想情况下推演出来的，实际情况会比这要复杂得多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，还是尽量采用多轮性能测试来得到性能指标，这样也更具备真&lt;/span&gt;&lt;span&gt;实性。毕竟&lt;/span&gt;&lt;span&gt;影响性能的因素实在大多且很难完全掌控，任何细微变化都将影响&lt;/span&gt;&lt;span&gt;性能指标的变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到这里，我们已经了解了可以用哪些&lt;span&gt;指标&lt;/span&gt;来衡量性能的高低。不过，这里更想强调的是，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;性能是高并发的基础能力，是实现高并发的基础条件，并且你需要有侧重性地提升不同维度的性能指标，而非仅关注某一项&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr data-style=&quot;font-size: 16px; outline: 0px; max-width: 100%; border-color: rgba(0, 0, 0, 0.1); caret-color: rgba(255, 255, 255, 0.6); color: rgba(255, 255, 255, 0.6); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.5440000295639038px; white-space: normal; border-style: solid; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; transform-origin: 0px 0px 0px; transform: scale(1, 0.5); box-sizing: border-box !important; word-wrap: break-word !important;&quot; class=&quot;js_darkmode__27&quot; data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;/&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;br data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;/&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;限制是一种设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上文说到，性能是高并发的目标之一。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;追求性能没有错，但并非永无止境&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。想要提升&lt;/span&gt;性能，势必投入成本，不过它们并不是一直成正比，而是随着成本不断增加，性能提升幅度逐渐衰减，甚至可能不再提升。所以，有时间我们要懂得适可而止。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;思考一下，追求性能是为了解决什么问题，至少有一点，是为了让应用系统能够应对突发请求。换言之，如果能解决这个问题，是不是也算实现了高并发的目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;而有时候，我们&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;在解决问题时，不要总是习惯做加法，还可以尝试做减法&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，架构设计同样如此。那么，如何通过做减法的方式，来解决应对突发请求的问题呢。让我们来讲讲限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;限制，从狭义上可以理解为是一种约束或控制能力&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。在软件领域中，它可以针对功能性或非功能性，而在高并发的场景中，它更偏向于非功能性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;限制应用系统的处理能力，并不代表要降低应用系统的处理能力&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，而是通过某些控制手段，&lt;span&gt;让突发请求能够被平滑地处理，同时起到&lt;span&gt;应用系统的保护能力，&lt;span&gt;避免瘫痪，&lt;/span&gt;还能&lt;/span&gt;将应用系统的资源进行合理分配，避免浪费&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，到底有哪些控制手段，既能实现以上这些能力，&lt;span&gt;又能减少对客户体验上的影响，下面就来介绍几种常用的控制手段&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;第一招：限流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;限流，是在一个时间窗口内，对请求进行速率控制&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。若请求达到提前设定的阈值&lt;span&gt;时&lt;/span&gt;，则对请求进行排队或拒绝。常用的限流算法有两种：漏桶算法和令牌桶算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;漏桶算法，所有请求先进入漏桶，然后按照一个恒定的速率对漏桶里的请求进行处理，是一种控制处理速率的限流方式，用于平滑突发请求速率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的优点是，能够确保资源不会瞬间耗尽，避免请求处理发生阻塞现象，另外，还能够保护被应用系统所调用的外部服务，也免受突发请求的冲击。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的缺点是，对于突发请求仍然会以一个恒定的速率来进行处理，其灵活性会较弱一点，容易发生突发请求超过漏桶的容量，导致后续请求直接被丢弃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;令牌桶算法，应用系统会以一个恒定的速率往桶里放入令牌，请求处理前，会从桶里获取令牌，当桶里没有令牌可取时，则拒绝服务，是一种平均流入速率的限流方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的优点是，在限制平均流入速率的同时，还能在面对突发请求的情况下，确保资源被充分利用，不会被闲置或浪费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的缺点是，舍弃了处理速率的强控制能力，那么如果某些功能依赖外部服务，可能将会让外部服务无法承受压力，导致无法正常返回，而且还浪费了这次获取的令牌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;两种算法并没有绝对的好坏，而是需要根据实际的情况，选择合适的方式，从而在发挥限流作用的同时不会引发其他问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;但在一些秒杀活动中，软件党的高频请求，会很容易触发限流，导致大量正常请求被误杀的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然在请求被限流后，会返回友好话术，减轻对客户体验的影响，但也有可能他们的请求，会一直无法得到有效处理，这时候耐心再好的客户也会离开及抱怨。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我们&lt;span&gt;除了使用限流这招外，还得搭配其他的招数组合一起使用，从而让&lt;span&gt;应用系统能够对资源进行合理分配，避免资源浪费，减少正常请求被误杀的情况。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;第二招：降频&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;降频，是在一个时间窗口内，对同一特征的请求进行速率控制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;span&gt;若请求达到提前设定的阈值时，则会对请求进行拒绝。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然和限流&lt;/span&gt;&lt;span&gt;有点类似，但存在着细微的差别。对限流而言，它并不关心请求方，而只对服务端的速率进行控制，而对降频而言，它会基于某种特征，对请求方的请求速率进行控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;而降频的目的，是为了减少&lt;/span&gt;&lt;span&gt;应用系统资源被不正常的请求所消耗，而导致正常的请求因限流被拒绝的情况发生&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。它的实现方式也有多种，而且在前端和后端都可以使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;识别不正常的请求是降频的第一步，也是最关键的一步。一般会制定某种特征+某段时间+请求数量这种三段式的识别规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特征可以是账号、会话、IP地址、设备号等，时间一般会是1秒，也可以设置更长。账号+1秒+5笔，意思就是同一个账号在1秒内可以发生5笔请求，但是这里请求数量与限流的设定参考依据不同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;限流大小主要依据性能来决定，而降频中的请求数量，一般会以正常人的交互速率作为参考&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。所以，并不能因为性能好，就设定账号+1秒+100笔这种识别规则，这不但不科学还会浪费资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，有了识别规则还得搭配对应的处置手段，常见的有两种模式：挑战和拒绝。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;挑战&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;弹出验证码，输入并验证通过后，可以继续请求&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;仅适用于前端&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;拒绝&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;弹出“请求频繁”提示，且这笔请求将直接被拒绝&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;适用于前端及后端&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;限流会发生误杀，难道降频就不会吗，其实也会发生，特别是用户的网络环境是一个出口IP地址时。所以，如果是基于IP地址特征的识别规则，请求数量建议适当放大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在降频策略方面，建议配置多层+渐进式的方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，&lt;span&gt;识别规则较为严格的&lt;/span&gt;采用挑战模式，&lt;span&gt;识别规则较为宽松的&lt;/span&gt;采用拒绝模式，减少因&lt;span&gt;降频而引发的误杀情况，参考如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;优先级&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;识别规则&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;处置手段&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;账号+1秒+5笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;挑战&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;账号+1秒+10笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;拒绝&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;IP地址+1秒+20笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;挑战&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;IP地址+1秒+40笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;拒绝&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;降频确实可以使应用系统的资源，被合理地分配给请求方，但并不能保证万无一失，特别对于那些技术高超的软件党们，他们仍然可以通过其他方式绕开这种控制手段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;你可以将此视为一种攻防战，通过增强防守的方式，来提高攻击者成本&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，而攻击者一定会权衡成本和收益，当成本大于收益时，可能就不会有攻击，毕竟没有人会这么无聊透顶&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16440279916325=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16440279916325=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16440279916325=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16440279916325=&quot;#fff|rgb(62, 62, 62)&quot; data-style=&quot;max-width: 100%; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__574&quot;&gt;&lt;span&gt;虽然有了限流和降频这两招，但仍可能无法应对高并发的场景，况且在初期，限&lt;/span&gt;&lt;span&gt;流和&lt;/span&gt;&lt;span&gt;&lt;span&gt;降频的策略，也&lt;/span&gt;&lt;span&gt;无法&lt;/span&gt;&lt;/span&gt;&lt;span&gt;设计&lt;/span&gt;&lt;span&gt;得&lt;/span&gt;&lt;span&gt;非常完美。所以，有些时候还得使出最后一招。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;第三招：降级&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;降级，是当应用系统处理超载时，对其服务进行裁剪的一种机制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。常见的是应用系统&lt;span&gt;处理阻塞时，会关闭&lt;span&gt;非核心服务，并将资源给到核心服务，从而确保核心服务正常。&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;经常有人将它与熔断混为一谈，但并非一回事&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。降级主要是针对应用系统本身，若处理能力不足则可触发，而熔断主要是针对应用系统所调用的外部服务，若外部服务不稳定时则可触发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;当然，两者也有一定的关系，因为当发生熔断时，也可以触发降级机制，比如当同步调用外部服务出现性能问题时，可以降级为异步调用，避免造成线程阻塞而瘫痪&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过在降级前，必须得先梳理应用系统中的核心服务，可以采用经典的二八原则，将服务划分为&lt;span&gt;20%核心服务+&lt;/span&gt;80%非核心服务。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;而&lt;/strong&gt;&lt;strong&gt;这种分法的意图，是希望让你找到真正重要的核心服务，不然，你会觉得都很重要&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在梳理过程中，建议通过多个维度来进行综合评判，如下是我经常采用的一种梳理方法，你可以将此作为一种参考，并结合自己的服务分类标准进行调整。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，可以设计一张类似如下的矩阵图，请尽量地简约它，将应用系统中的各类服务，按照矩阵所设定的不同属性进行分门别类。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;操作类&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;查询类&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;业务类&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;订单下单&lt;br/&gt;订单支付&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;订单退货&lt;br/&gt;&lt;/span&gt;...&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;商品查询&lt;br/&gt;订单查询&lt;br/&gt;退货进度&lt;br/&gt;...&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;基础类&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;用户登录&lt;br/&gt;用户登出&lt;br/&gt;密码修改&lt;br/&gt;头像修改&lt;/span&gt;&lt;span&gt;&lt;br/&gt;...&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;用户查询&lt;br/&gt;历史浏览&lt;br/&gt;我的收藏&lt;br/&gt;我的分享&lt;br/&gt;...&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后，将业务类+操作&lt;/span&gt;&lt;span&gt;类的挑选出来作为&lt;span&gt;核心服务&lt;/span&gt;，你会不会认为这就结束了。不好意思，游戏才刚刚开始。不过你可以试想一下，假设&lt;/span&gt;&lt;span&gt;仅保留这些核心服务，会出现什么问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户登录不了无法订单支付，订单查询不了无法订单退货。所以，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;我们还需引入服务关键路径的概念，可以理解为在使用某个服务前，还必须要使用的其他服务&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分别对挑选出来的核心服务，进行服务关键路径的&lt;span&gt;梳理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;路径1&lt;/span&gt;&lt;span&gt;：用户登录——&amp;gt;商品查询&lt;/span&gt;&lt;span&gt;——&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;订单下单&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;路径2：&lt;/span&gt;&lt;span&gt;用户登录——&lt;span&gt;&amp;gt;&lt;/span&gt;商品查询&lt;/span&gt;&lt;span&gt;——&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;订单下单——&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;订单支付&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;路径3：用户登录——&lt;span&gt;&amp;gt;&lt;/span&gt;订&lt;/span&gt;&lt;span&gt;单&lt;/span&gt;&lt;span&gt;查询——&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;订单退货&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;待服务关键路径梳理完成后，再对路径上的所有服务进行合并及去重，将会得到一组新的核心服务：用户登录/商品查询/订单下单/订单支付/订单查询/订单退货。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来计算下核心服务的占比，所有服务14个/核心服务6个，占42.86%，远远超过了20%。所以，建议继续从这些核心服务中，识别更核心的部分，但仍然以服务关键路径为整体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相比订单下单/订单支付/订单退货这三条服务关键路径，我想订单支付可能会更有价值。最后，我们可以仅将订单支付这条服务关键路径上的服务作为核心服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重新再来计算下核心服务的占比，&lt;span&gt;所有服务14个/核心服务4个，占28.57%，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;虽然还是超过了20%，但这并不是重点，重点是我们已经找到了最核心的服务&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其余的核心服务，可以降级为准核心服务，重组后得到如下这份服务重要程度清单。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;核心服务&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;准核心服务&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;非核心服务&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;span&gt;用户登录&lt;br/&gt;商品查询&lt;br/&gt;订单下单&lt;br/&gt;订单支付&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;span&gt;订单查询&lt;br/&gt;订单退货&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;span&gt;退货进度&lt;br/&gt;用户登出&lt;br/&gt;密码修改&lt;br/&gt;头像修改&lt;br/&gt;用户查询&lt;br/&gt;历史浏览&lt;br/&gt;我的收藏&lt;br/&gt;我的分享&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当拥有这份清单后，若&lt;span&gt;应用系统处理阻塞时&lt;/span&gt;，就&lt;/span&gt;&lt;span&gt;可以按照非核心服务&amp;gt;准&lt;span&gt;核心服务&amp;gt;&lt;span&gt;核心服务这个顺序依次进行降级&lt;/span&gt;&lt;/span&gt;。不过，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;降级&lt;/strong&gt;&lt;strong&gt;不一定要拒绝请求，也可以是限流请求，这样可以减少对服务能力的裁剪力度&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上只是一种相对较粗的降级策略，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果你想要制定更精细化的降级策略，还需要&lt;span&gt;对&lt;/span&gt;&lt;/span&gt;每个服务进行优先级的设定&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，高低依据可以结合自身需要来制定，例如：&lt;span&gt;历史&lt;/span&gt;服务使用情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当有了限流、降频、降级这三招，基本就能够在资源有限的情况下，让突发请求能够被平滑地处理，将应用系统的资源能够被合理地分配，以及当应用系统处理堵塞时，&lt;span&gt;确保核心服务正常。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr data-style=&quot;font-size: 16px; outline: 0px; max-width: 100%; border-color: rgba(0, 0, 0, 0.1); caret-color: rgba(255, 255, 255, 0.6); color: rgba(255, 255, 255, 0.6); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.5440000295639038px; white-space: normal; border-style: solid; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; transform-origin: 0px 0px 0px; transform: scale(1, 0.5); box-sizing: border-box !important; word-wrap: break-word !important;&quot; class=&quot;js_darkmode__27&quot; data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;/&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;br data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;/&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;取舍是一种权衡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;现在，我们已经基本了解了如何衡量性能的指标，以及大致掌握了如何保护应用系统的招数。但这些就是高并发全部了吗，我想说这仅仅只是入门级别。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;上述内容，主要是为了让你能够清晰地看到应用系统的性能水位在哪里，以及在资源有限下，当面对突发请求时可以采取哪些招数，能让应用系统安全地存活下来。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;strong&gt;&lt;span&gt;存活，即代表着可用性，它也是高并发的一个特性，而且是我认为相对比较重要的特性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。设想一下，如果你的应用系统连可用性都无法保证，那再高的性能又有何意义。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;对于大部分应用系统而言，大家都会比较关注应用系统的可用性，99.9%不够那就99.99%，甚至还有想做到99.999%的，毕竟可用性的不足会直接影响到业务运作。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;但对于&lt;/span&gt;&lt;span&gt;&lt;strong&gt;一个想成为高并发的应用系统而言，仅单方面关注高可用，肯定无法称得上这个头衔&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，它仍然还需要在其他特性上具备极佳的表现。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;让我们拉回到最初的目标，性能是高并发的目标之一，&lt;/span&gt;&lt;span&gt;不过，这里我们不再谈论性能指标，而是来研究如何来提升性能。&lt;/span&gt;&lt;span&gt;因为，高性能是高并发的另外一个重要特性。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;想要提升性能，势必投入成本。随着成本不断增加，性能提升幅度逐渐衰减。这两句话，是不是觉得有点耳熟，但不管你是否还记得，先让我在这里打个问号再说。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;在架构设计的过程中，你是否经常会听到“取舍”的这个词，它是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;通过牺牲一种能力来换取另外一种能力的方式&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这些能力可以是性能、可用性、数据一致性或是其他能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;等等，你是不是突然有意识到，提升性能并不只有投入成本这种方式，至少是在硬件资源方面，我们还可以通过牺牲一种能力去换取。&lt;/span&gt;&lt;span&gt;那到底选择牺牲哪种能力呢，牺牲可用性，一般不会第一时间考虑，那是不是可以考虑牺牲数据一致性。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;但在考虑前得先声明一下，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;所谓牺牲数据一致性，并不是完全不要，而是将数据强一致性降级为最终一致性&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;而对于数据最终一致性的理解，就是在数据更新后，要过一段时间后才能看到，而时间的长短就代表着牺牲了多少。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;但并不是说，所有情况都必须牺牲数据一致性来提升性能，有些时候也可以考虑牺牲其他能力。但在取舍前，得先弄清楚当前要什么，但更需要弄清楚当前可以失去什么，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;不合理的取舍，不但无法换取收益，反而还会引来更多的问题&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;情况1：数据缓存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;strong&gt;缓存，是高并发架构设计中一种不可或缺的能力&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，一般是指那些经常被访问的热点数据，可以将它放入缓存中，从而提升数据被读取的效率。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;但是否所有的数据都适合放入缓存中，如果是静态数据，那么你可以很安心地放入。原因很简单，静态数据不会更新，那么缓存和数据源始终保持一致，而且就算缓存中的数据丢失了，至少还有一份在数据源。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;通过将静态数据缓存，可以很轻易地提升静态数据的访问性能，甚至可能是几十倍的效果。但应用系统中还有大量的动态数据，仅提升静态数据可能对总体的提升并不一定显著。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;你是不是想说，那就把动态数据也放入缓存中不就行了。在下这个决定前，建议你先想一下，动态数据是会更新的，&lt;/span&gt;&lt;span&gt;这就意味着动态数据在放入缓存后，当数据源中的数据被更新后，再次访问返回的都是更新前的数据，这种效果你是否可以接受。&lt;/span&gt;&lt;/section&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;我想应该没有人会接受吧，而你是不是又想说，设置下缓存会过期不就能解决了。没错，但得等过期后才能解决，那还没过期前呢，这种方式只能缓解，但并不能根治，而且还会引入一个新的问题，请问过期设置多久才合适。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;设置缓存5秒钟过期，可能永远无法命中缓存，而且不但没有提升性能，还增加了代码复杂度，有点画蛇添足的感觉。&lt;/span&gt;&lt;span&gt;设置缓存5分钟过期，命中缓存的几率可能会提高，但缓存后在5分钟内的如果数据更新，要从缓存开始往后推5分钟才能看到。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;即：&lt;/span&gt;&lt;span&gt;第1分钟缓存，第1-6分钟内的任何数据更新，要第6分钟后才能看到。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;所以，如果你无法容忍这种情况，请你不要滥用缓存，虽然性能提高了，但问题可能也出现了。反之，如果你可以容忍这种情况，那就可以这么操作，而至于过期设置多久，可以结合业务场景及使用频率综合来评估，毕竟不同的业务容忍度是不同的。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;对于是否要将动态数据进行缓存，本质上，其实就是一种取舍，是一种性能与数据一致性的权衡，而&lt;/span&gt;&lt;span&gt;&lt;strong&gt;缓存的过期时长，就像是保持这种平衡的支点，从而让这种牺牲变得更有意义&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;情况2：单机限流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;限流，前面已经有介绍过，它有两种常用的限流算法，&lt;span&gt;漏桶算法和令牌桶算法。不过&lt;/span&gt;，这两种算法都仅支持单机限流，不支持全局限流。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;单机限流，就是对单节点设定一个限流阈值，如果单节点上的请求到达阈值，则会拒绝请求。例如：&lt;span&gt;限流阈值=每秒100次请求，如果在1秒内单节点上，有第101次的请求则拒绝。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;全局限流，就是对一组节点设定一个限流总阈值，如果这组节点上的汇总请求到达阈值，则会拒绝请求。例如：&lt;/span&gt;&lt;span&gt;10个节点的限流总阈值=1000次请求，如果在1秒内这组节点上，汇总有第1001次请求则拒绝，不过单节点上有超过第100次的请求也会接受。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;这么看下来，感觉单机限流控制能力更厉害一点，它能保证单节点的请求不会超过100次。而全局限流在极端情况下，单节点都有可能在1秒内会接受1000次请求。当然，这种情况的可能性比较低，比如在突发请求时，9个节点同时宕机。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;既然如此，那全局限流有存在的意义吗，难道这就是&lt;span&gt;漏桶算法和令牌桶算法都不支持全局限流的原因。全局限流就真的没有存在的意义吗。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;存在即合理，既然存在，那就一定有它存在的道理&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;换个情况，还是将&lt;span&gt;10个节点为一组，不过这次换成采用单机限流。问题来了，每个节点的限流阈值该如何设定，如果采用平均分配，则&lt;span&gt;限流阈值=每秒100次请求，让我们来测试一下，在1秒内依次发出1000次请求，会发生什么现象。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结果是在第100次请求后，从第101次到第1000次的请求中，可能有些请求会发生被拒绝的情况，而且请求一会儿成功一会儿拒绝，没有任何规律。原因可能是10个节点请求负载不均所引发的，导致某个节点提前超过了100次请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于以上情况，最终1000次请求没有全部成功，这种情况等同于降低了应用系统的吞吐能力。而在实际情况中，就算采用&lt;/span&gt;&lt;span&gt;轮询的负载算法，请求数不均的可能性仍然还是会存在的&lt;/span&gt;&lt;span&gt;。这么一看，单机限流好像也有缺陷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;估计你已经被我说晕了吧，让我们整体再重新梳理一遍，并对&lt;span&gt;两&lt;/span&gt;&lt;span&gt;种不同限流模式的影响进行对比。不过，这次&lt;span&gt;还加上每秒不同的请求数量。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;每秒请求&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;单机限流&lt;br/&gt;10*100笔/秒&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;全局限流&lt;br/&gt;&lt;strong&gt;1000笔/秒&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;100笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;无影响&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;无影&lt;/span&gt;&lt;span&gt;响&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1000笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;少量请求拒绝&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;耗时小幅波动&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;10000笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;请求拒绝&amp;gt;9000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;请求拒绝=9000&lt;br/&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;耗时大幅&lt;/span&gt;&lt;span&gt;波动&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;注：每个节点的处理能力为100笔/秒&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;两种限流对比下来，单机限流更强调单机的控制范围，但可能会造成额外的请求拒绝，但对单节点不会造成性能压力，而全局限流更强调整体的控制范围，虽不会造成额外的请求拒绝，但可能会对单节点造成性能压力，引发性能过载。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;除此之外，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;全局限流还是一种采用中心化的设计思路&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，因此在网络开销方面，还会产生额外的性能损耗，这种损耗在请求量少的时候估计还可以容忍，但在高并发的情况下可能是场灾难，因为在每次限流判断前，还会产生一次网络开销。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;所以，不能为了想要实现更精准的限流，就盲目地采用全局限流，它将在高并发的情况下损耗更多的性能。而单机限流所额外造成的少量请求拒绝，在某些情况下，可以考虑采用某些技术手段进行补偿。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;span&gt;不过，不管是单机限流还是全局限流，似乎都和数据一致性没有关系。但事实上，全局限流这种精准限流的方式，也可以视为另一种一致性的表现，而单机限流就是通过对这种一致性的牺牲，来减少性能损耗，何尝不是提升性能的另一种方式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;以上，只是简单列举了两种不同情况下的取舍，而在高并发架构上，可取舍的地方远不止这些。你得知道，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;高并发的每一处设计或每一份设计方案的背后，都曾是通过不断地取舍所获得的&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，而没有取舍的高并发架构决策，将会显得毫无说服力。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;strong&gt;取舍不但可以作为高并发架构决策的有力武器，也将是驱动架构演进最合理的一种方式&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。但要切记，取舍的方向并不是一成不变的，而是会随着外界环境的变化而变化，它将是一种独特的艺术。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr data-style=&quot;border-style: solid; border-width: 1px 0px 0px; border-color: rgba(0, 0, 0, 0.1); transform-origin: 0px 0px; transform: scale(1, 0.5);&quot; class=&quot;js_darkmode__107&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgb(61, 170, 214)&quot;&gt;写在最后&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;高并发的魅力之处，就在于它没有唯一的答案，而答案是需要我们以不同的业务场景作为线索去不断地寻找，这种寻找的过程也是一种不断思考的过程&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这就是我为什么说高并发是一种架构思维模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文从浅到深依次讲述了性能是实现高并发的基础条件，控制是实现资源最大化利用的方式，以及如何通过取舍来换取当前应用系统更所需的能力，但这些仅仅只是高并发世界里的一个角落。因篇幅有限，今天就暂告一段落。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后想说，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;高并发其实并不可怕，可怕的是你知其然而不知其所以然&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。对于追求技术的你，&lt;span&gt;需要不断地拓宽你的技术深度与广度，才能更好地掌握高并&lt;/span&gt;&lt;/span&gt;&lt;span&gt;发，以及运用高并发的思维模式来提升应用系统处理能力。&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-darkmode-color-16371208717484=&quot;rgb(157, 157, 157)&quot; data-darkmode-original-color-16371208717484=&quot;#fff|rgb(73, 73, 73)&quot; data-darkmode-bgcolor-16371208717484=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16371208717484=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-darkmode-color-16371208717484=&quot;rgb(157, 157, 157)&quot; data-darkmode-original-color-16371208717484=&quot;#fff|rgb(73, 73, 73)&quot; data-darkmode-bgcolor-16371208717484=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16371208717484=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16371208717484=&quot;rgb(157, 157, 157)&quot; data-darkmode-original-color-16371208717484=&quot;#fff|rgb(73, 73, 73)&quot; data-darkmode-bgcolor-16371208717484=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16371208717484=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;span&gt;期待同样追求技术的你，可以一起探讨与交流&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0085470085470085&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gusYCVib6QexgrFKrleLJh7nmy0ooJyIsibiaJju0Tvc11FqcoNVUyV4BJGV5eo3ZsEOia3h5WSdTjG1InsgzINB6g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;351&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者简介：金融业IT人士，熟悉信用卡业务领域。曾负责系统运维、软件开发、团队管理，现主要推动系统架构演进、技术组件自研、以及AI类产品规划等。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5NTU2NTY5MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/gusYCVib6Qex4SJXYhiblbeQHnuDBAGouXicIK4uq3J3mtwdNWZMnfdra0qlJYwIV4WDdwfGl0gBuVCRNT3QeRcdw/0?wx_fmt=png&quot; data-nickname=&quot;技术奇妙物语&quot; data-alias=&quot;&quot; data-signature=&quot;让你沉浸在充满技术氧气的奇妙世界里，带你领略到技术改变未来的独特魅力。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a24fd8eb4c5b61e1dee5adeffbd7c07b</guid>
<title>谁让你跪舔了，程序员得这样向上管理</title>
<link>https://toutiao.io/k/5m90d51</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;没有这些信息，跟上级打交道的过程中，你就像盲人摸象，无头苍蝇，糊涂乱撞。可能就会跟领导产生不必要的冲突和误解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总之，你需要注意时刻上级领导的蛛丝马迹，保持对领导工作风格的敏感度非常重要，尤其是面对的是新老板。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;三、了解你自己&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;上面讲到的是了解上级领导，这还只是你跟领导关系中的一半，另一半就是你自己。你还需要知道你自己的情况，包括，性格、优缺点和工作方式，幸运的是这一半会更加容易控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然人的性格很难去改变，但是如果你知道的自己的性格，就能够更好地改善你和领导的工作关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;打一个错误示范：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;你和你的领导的观点不一致的时候，你的领导典型反应是坚持自己的立场。而你的典型反应是找出领导观点中的漏洞，然后放大，大肆攻击，来佐证你自己的观点。而你的领导更加会坚定自己的立场。这种冲突，慢慢升级，最终可能会导致你和领导的关系破裂。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果读者的你就是例子中的情况，可以先控制住自己的急躁情绪，暂时先避开领导的锋芒，给足领导面子，然后过一段时间再去讨论，彼此之间的分歧已经淡化，可以更好进行讨论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上诉例子中描述的就是一种典型“反依赖”的例子，也就是说如果你的行动被上级领导的决策所束缚时，就会表现出一定程度的愤怒。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与反依赖相对应的另一个极端就是过分依赖，也就是俗话说的“默不作声”，明知道上级领导的观点有问题或者是跟自己的观点不一致时，但是丝毫不影响继续跪舔。这种情况下，往往会让领导认为你的能力欠缺，不敢质疑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你认为你有一些反依赖倾向，就需要压制自己的过激反应，如果你认为你有一些过分依赖倾向，就要考虑下是否需要适当的展示下自己能力，表现自己。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;四、建立联系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;如果你对领导和自己都有清晰的了解，你应该能找到一个最恰当的和领导共事的方式。我将我自己的总结如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、保持一致工作风格&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;要和领导建立良好的工作关系，首先要有一致的工作风格。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举例：如果你的领导是雷厉风行，有想法就要立即去执行。那么你最好也能保持和领导一致风格，做事不要拖拉，积极主动的完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;另外还需要吸取领导的长处、弥补自己的短处。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果你的领导是考虑周全，面面俱到的人，那么你向他汇报时就应该做好十足的准备。如果你的领导专业能力偏弱，那么就需要你主动的承担起技术方面的工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、确定期望&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;在中国企业中，领导布置任务，往往是模棱两可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如：小明领导对他布置了一个任务“小明，这个方案你去制定下，尽快给我。”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很明显，领导并没有将他的期望最终方案的效果和交付时间告诉小明，这个艰巨的任务就交给小明了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你是小明，你应该这么做，首先起草一份详细的设计流程，将那些关键方面记录在内，然后提交给领导审批，最好找个时间跟领导面对面的讨论，仔细的检查每一项，最终敲定交付时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;上述例子中，最重要的是要找到领导的期望，否则你干的任何事情在领导看来都是不满意的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、信息反馈&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;你要知道一点，任何领导都想时时刻刻的了解下属的信息。所以一般情况下，领导都会认为下属的反馈信息量太少，聪明的你就应该要想方设法的通过各种途径（邮件、微信、电话、会议）来反馈当前的任务情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你的领导好大喜功，喜欢回避问题。你要做的就是在不影响实际公司的情况下，可以适当的减少坏消息的比例，提高好消息的占比。这样做带来的好处对领导和自己都是双赢的局面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、忠诚&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;忠诚包含了可靠和诚实，没有领导喜欢总把事情搞砸的，不可靠的下属，所以尽量让自己任务交付质量和时间都要OK。没有领导喜欢整天油嘴滑舌，满嘴跑火车的员工，所以不要掩盖事实的真相，勇敢的承担责任。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;在如今的互联网浪潮中，要能脱颖而出，光靠技术能力是不够的，如果不能很好的管理上级领导，就终将会被后浪拍在沙滩上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;管理上级领导就像是武功秘籍“易筋经”，一旦练成，就能在职场中如鱼得水，游刃有余。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;祝各位尽快修炼成功！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;作者丨袁吴范&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源丨公众号：pointers（ID：cpointers）&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dbaplus社群欢迎广大技术人员投稿，投稿邮箱：&lt;/span&gt;&lt;span&gt;editor@dbaplus.cn&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36086956521739133&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1150&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YY6J547ZhgwY87vBia8l2ic7vAeqPaIJicV0RiacMHFOs2HBwzojCN94ROMWN3hCF1Z5DAwEaibibQSLxQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07734375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zf2jiaBBH3vdgfP4A2rem5YEAHYH074dc4GibhojA5B3lLZrXLDRciaVnficveaHcAUCiaIPoDsTkAduA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5fb8b93856689720ac314d100c86037d</guid>
<title>高效能人士的七个习惯｜码农周刊VIP会员专属邮件周报 Vol.081</title>
<link>https://toutiao.io/k/01b9ika</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f4d2608b64218f0deeb9425d9072df49</guid>
<title>Spark Structured Streaming 2021年最新进展的总结</title>
<link>https://toutiao.io/k/sltylsw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxMjI3NTI5OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/DicvpKIBbiaxdvguk5d6BgaNvk9mvMnmticIjibcW5fOibhicUCZDRVGq2SfEib6bRT7djd8icz5HV0sWuKkse9k0Ve7ow/0?wx_fmt=png&quot; data-nickname=&quot;Java与大数据架构&quot; data-alias=&quot;deltalake_bigdata&quot; data-signature=&quot;7年老码农，10W关注者。【Java与大数据架构】全面分享Java编程、Spark、Flink、Kafka、Elasticsearch、数据湖等干货。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;本文我们将花点时间来回顾一下 Databricks 和 Apache Spark™ 在流数据处理方面所取得的巨大进步！2021年，工程团队和开源贡献者在以下三个目标取得了一些进展：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;降低延迟并改进有状态流处理；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;提高 Databricks 和 Spark Structured Streaming 工作负载的可观测性；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;改进资源分配和可伸缩性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下面我们来简单地看下这些目标。&lt;/p&gt;&lt;h2&gt;目标一：降低延迟并改进有状态流处理&lt;/h2&gt;&lt;p&gt;有两个新的关键特性专门用于降低有状态操作的延迟，以及对有状态 APIs 的改进。第一种是针对大型有状态操作的异步检查点（asynchronous checkpointing），它改进了传统的同步和延迟更高的设计。&lt;/p&gt;&lt;h3&gt;异步检查点&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0yBD9iarX0ntQKkemmme9a5OhRHWzWbEIkl2M711z96szILBuWZOGRSfaicbNvLUsIbRr37prnk8fwedJy6APVGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.525&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果想及时了解Spark、Hadoop或者HBase相关的文章，欢迎关注微信公众号：过往记忆大数据&lt;/span&gt; &lt;/p&gt;&lt;p&gt;在这个模型中，状态更新会在下一个微批开始之前写到云存储检查点位置。这样做的好处是，如果有状态流查询失败，我们可以使用最后一个成功完成的批处理中的信息轻松地重新启动查询。在异步模型中，下一个微批不必等待状态更新，从而提高了整个微批执行的端到端延迟。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0yBD9iarX0ntQKkemmme9a5OhRHWzWbEIXfuomic9P17Ts4ewiaPibJV6A7lSRK81IgyydaYDmZicermb69xibeLIOZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.525&quot; data-w=&quot;1080&quot;/&gt;&lt;span&gt;如果想及时了解Spark、Hadoop或者HBase相关的文章，欢迎关注微信公众号：过往记忆大数据&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;任意状态操作符的改进&lt;/h3&gt;&lt;p&gt;在这篇文章中，社区用 [flat]MapGroupsWithState 在结构化流中引入了任意状态处理。这些操作符提供了很大的灵活性，并支持聚合之外的更高级的有状态操作。在过去的一年，社区已经对这些操作符进行了改进：&lt;/p&gt;&lt;p&gt;允许初始状态，避免重新处理所有流数据；通过公开一个新的 TestGroupState 接口，允许用户创建 GroupState 的实例，并访问已设置的内部值，简化状态转换函数的单元测试，从而实现更简单的逻辑测试。&lt;/p&gt;&lt;h3&gt;允许初始状态&lt;/h3&gt;&lt;p&gt;让我们从下面的 flatMapGroupswithState 操作符开始：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; flatMapGroupsWithState&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Encoder&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; U&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Encoder&lt;/span&gt;&lt;span&gt;](&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    outputMode&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;OutputMode&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    timeoutConf&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GroupStateTimeout&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    initialState&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;KeyValueGroupedDataset&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; S&lt;/span&gt;&lt;span&gt;])(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    func&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Iterator&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;],&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GroupState&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;])&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Iterator&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;U&lt;/span&gt;&lt;span&gt;])&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;下面的例子计算每种水果的总数：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;val fruitCountFunc &lt;/span&gt;&lt;span&gt;=(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; values&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Iterator&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;],&lt;/span&gt;&lt;span&gt; state&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GroupState&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;RunningCount&lt;/span&gt;&lt;span&gt;])&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  val count &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; state&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getOption&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;).&lt;/span&gt;&lt;span&gt;getOrElse&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0L&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; valList&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  state&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;RunningCount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;))&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;Iterator&lt;/span&gt;&lt;span&gt;((&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; count&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toString&lt;/span&gt;&lt;span&gt;))&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;现在，我们针对某些水果的计数设置初始值：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;val fruitCountInitialDS&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Dataset&lt;/span&gt;&lt;span&gt;[(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;RunningCount&lt;/span&gt;&lt;span&gt;)]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Seq&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;apple&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;RunningCount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)),&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;orange&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;RunningCount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)),&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;mango&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;RunningCount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)),&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;).&lt;/span&gt;&lt;span&gt;toDS&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;val fruitCountInitial &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; initialState&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;groupByKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;x &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; x&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_1&lt;/span&gt;&lt;span&gt;).&lt;/span&gt;&lt;span&gt;mapValues&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;fruitStream&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;groupByKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;x &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; x&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;flatMapGroupsWithState&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Update&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GroupStateTimeout&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;NoTimeout&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; fruitCountInitial&lt;/span&gt;&lt;span&gt;)(&lt;/span&gt;&lt;span&gt;fruitCountFunc&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;简单的逻辑测试&lt;/h3&gt;&lt;p&gt;您现在还可以使用 TestGroupState API 测试状态更新。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;apache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;spark&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;sql&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;streaming&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;apache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;spark&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Optional&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flatMapGroupsWithState&#x27;s state update function&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; prevState &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;TestGroupState&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;UserStatus&lt;/span&gt;&lt;span&gt;](&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    optionalState &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Optional&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;empty&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;UserStatus&lt;/span&gt;&lt;span&gt;],&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    timeoutConf &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GroupStateTimeout&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;EventTimeTimeout&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    batchProcessingTimeMs &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1L&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    eventTimeWatermarkMs &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Optional&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;of&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1L&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    hasTimedOut &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  val userId&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  val actions&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Iterator&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;UserAction&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt;&lt;span&gt;(!&lt;/span&gt;&lt;span&gt;prevState&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;hasUpdated&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  updateState&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;userId&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; actions&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; prevState&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;prevState&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;hasUpdated&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;关于 TestGroupState 的更多例子可以参见这里。&lt;/p&gt;&lt;h3&gt;内置支持会话窗口（Session Windows）&lt;/h3&gt;&lt;p&gt;Structured Streaming 引入了在基于事件时间的窗口上使用滚动或滑动窗口进行聚合的能力，这两种窗口都是固定长度的窗口。在 Spark 3.2 中，社区引入了会话窗口的概念，它允许动态窗口长度。这需要使用 flatMapGroupsWithState 自定义状态操作符。我们可以看下下面的例子：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# Define the session window having dynamic gap duration based on eventType&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;session_window expr &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; session_window&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;events&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;when&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;events&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;eventType &lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;type1&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;5 seconds&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;when&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;events&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;eventType &lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;type2&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;20 seconds&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;otherwise&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;5 minutes&quot;&lt;/span&gt;&lt;span&gt;))&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# Group the data by session window and userId, and compute the count of each group&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;windowedCountsDF &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; events \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;withWatermark&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;10 minutes&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;groupBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;events&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;userID&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; session_window_expr&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;关于会话窗口的介绍可以参见 Apache Spark 3.2 内置支持会话窗口。&lt;/p&gt;&lt;h2&gt;目标二：提高 Databricks 和 Spark Structured Streaming 工作负载的可观测性&lt;/h2&gt;&lt;p&gt;虽然 StreamingQueryListener API 允许我们在 SparkSession 中异步监视查询，并为查询状态、进度和终止事件定义自定义回调函数，但理解反压（understanding back pressure）和推断瓶颈在微批处理中的位置仍然是一个挑战。从 Databricks Runtime 8.1 开始，StreamingQueryProgress 对象报告了 Kafka、Kinesis、Delta Lake 和 Auto Loader 流数据源的特定数据源背压指标(back pressure metrics)。&lt;/p&gt;&lt;p&gt;比如下面是 Kafka 数据源的 metrics 例子：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&quot;sources&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&quot;description&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;KafkaV2[Subscribe[topic]]&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&quot;metrics&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;avgOffsetsBehindLatest&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;4.0&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;maxOffsetsBehindLatest&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;4&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;minOffsetsBehindLatest&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;4&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;estimatedTotalBytesBehindLatest&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;80.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;},&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;关于上面新增指标可以参见 SPARK-34854。注意，社区版好像没有 estimatedTotalBytesBehindLatest 指标。&lt;/p&gt;&lt;p&gt;另外，Databricks Runtime 8.3 引入了实时指标，以帮助理解 RocksDB 状态存储的性能，调试状态操作的性能；这些还可以帮助识别异步检查点的目标工作负载。一个新的状态存储监控的例子如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&quot;id&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;6774075e-8869-454b-ad51-513be86cfd43&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&quot;runId&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;3d08104d-d1d4-4d1a-b21e-0b2e1fb871c5&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&quot;batchId&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&quot;stateOperators&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&quot;numRowsTotal&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;20000000&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&quot;numRowsUpdated&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;20000000&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&quot;memoryUsedBytes&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;31005397&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&quot;numRowsDroppedByWatermark&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&quot;customMetrics&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbBytesCopied&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;141037747&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbCommitCheckpointLatency&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbCommitCompactLatency&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;22061&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbCommitFileSyncLatencyMs&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1710&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbCommitFlushLatency&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;19032&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbCommitPauseLatency&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbCommitWriteBatchLatency&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;56155&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbFilesCopied&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbFilesReused&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbGetCount&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;40000000&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbGetLatency&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21834&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbPutCount&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbPutLatency&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;56155599000&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbReadBlockCacheHitCount&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1988&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbReadBlockCacheMissCount&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;40341617&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbSstFileSize&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;141037747&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbTotalBytesReadByCompaction&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;336853375&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbTotalBytesReadByGet&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;680000000&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbTotalBytesReadThroughIterator&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbTotalBytesWrittenByCompaction&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;141037747&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbTotalBytesWrittenByPut&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;740000012&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbTotalCompactionLatencyMs&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21949695000&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbWriterStallLatencyMs&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;&quot;rocksdbZipFileBytesUncompressed&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;7038&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;],&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&quot;sources&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;],&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&quot;sink&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;关于这个功能可以参见 SPARK-36236。&lt;/p&gt;&lt;h2&gt;目标三：改进资源分配和可伸缩性&lt;/h2&gt;&lt;h3&gt;Streaming Autoscaling Delta Live Tables (DLT)&lt;/h3&gt;&lt;p&gt;在去年的 Data + AI Summit 峰会上，数砖发布了 Delta Live Tables，这是一个框架，允许我们声明式地构建和编排数据管道，并在很大程度上抽象了配置集群和节点类型的需求。在过去的一边这个功能得以提升，并为流管道引入了一个智能自动伸缩解决方案，该解决方案改进了现有的 Databricks 优化自动伸缩（Databricks Optimized Autoscaling）。这些好处包括：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;更好地利用集群&lt;/strong&gt;：新的算法利用新的背压度量（back pressure metrics）来调整集群大小，以更好地处理流工作负载波动的场景，这最终导致更好的集群利用率。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;主动优雅的 Worker 关闭&lt;/strong&gt;：现有的自动伸缩解决方案只有在节点空闲时才会关闭节点，而新的 DLT Autoscaler 会在利用率低时主动关闭选定的节点，同时保证不会因为关闭而导致任务失败。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;Trigger.AvailableNow&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 Structured Streaming 中，触发器允许用户定义流查询数据处理的时间。这些触发器类型可以是 micro-batch (默认)、fixed interval micro-batch (Trigger.ProcessingTime)、one-time micro-batch (Trigger.Once)和 continuous (Trigger.Continuous)。&lt;/p&gt;&lt;p&gt;Databricks Runtime 10.1 （对应社区的 Spark 3.3.0 版本，参见 SPARK-36533）引入了一种新的触发器：Trigger.AvailableNow，类似于 Trigger.Once ，但提供了更好的可伸缩性。与 Trigger Once 一样，所有可用的数据都将在查询停止之前处理，但是是以多批处理的方法来处理而不是一次处理所有的数据，这有可能会导致 Driver 出现 OOM。这个功能支持 Delta Lake 、Auto Loader 以及 Kafka（SPARK-36649）流数据源。下面是一个使用例子：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;spark&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readStream&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;delta&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;maxFilesPerTrigger&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;load&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;inputDir&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeStream&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;trigger&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Trigger&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;AvailableNow&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;checkpointLocation&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; checkpointDir&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;本文翻译自《Structured Streaming: A Year in Review》https://databricks.com/blog/2022/02/07/structured-streaming-a-year-in-review.html。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>872486fadb57528f1a521fa228189a5a</guid>
<title>点赞动画还可以做得那么飘逸！</title>
<link>https://toutiao.io/k/h0drzhi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxODE4MTEzMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/HLN2IKtpicicEzibgjagSQ7yicf4NY6Dkmf6DvDxBCbIchu1bia9LAP5wKGX0ckGtxdU7NEIduTsFIgCaVSnAVibicBSA/0?wx_fmt=png&quot; data-nickname=&quot;前端开发博客&quot; data-alias=&quot;caibaojian_com&quot; data-signature=&quot;回复 加群，秒进群，「前端开发博客」专注前端开发技术，分享前端开发资源和前沿技术资讯，助力前端开发工程师更好成长。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;关注公众号 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;&lt;span&gt;前端开发博客&lt;/span&gt;&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;&lt;span&gt;领27本电子书&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;加群&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，自助秒进前端群&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;以前在看微信视频号直播的时候，经常点击右下角的点赞按钮。看着它的数字慢慢从一位数变成五位数，还是挺有氛围感的。特别是长按的时候，有个手机震动的反馈，很带感。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.14375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnZAVNKXV6pohRgZHxYe68hicnejt0jqiaJQ4Dr9FLdJFJicb199s9RcOrQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;320&quot;/&gt;&lt;/p&gt;&lt;p&gt;虽然之前很好奇这些飘动的点赞动效是怎么实现的，但没有特别去钻研。直到前阵子投入腾讯课堂 H5 直播间的需求，需要自己去实现一个这样的效果时，才开始摸索。&lt;/p&gt;&lt;p&gt;先看看最后的效果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7890625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnNYSbDhHmnWxASR45B7zGmFbnRjsiaolyCEXj9trb2XI35UzMNlibbZpg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;256&quot;/&gt;&lt;/p&gt;&lt;p&gt;相比视频号的点赞动效，轨迹复杂了很多。可以看到课堂直播间的这一段点赞动效，大概分为这么三个阶段：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从无到有，在上升过程中&lt;strong&gt;放大&lt;/strong&gt;成正常大小&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上升过程中&lt;strong&gt;左右摇曳&lt;/strong&gt;，且&lt;strong&gt;摇曳的幅度随机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;左右摇曳上升的过程中，&lt;strong&gt;渐隐并缩小&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;在动手之前，我先想到了使用 &lt;strong&gt;CSS animation&lt;/strong&gt; 去实现这种运动轨迹。在完成之后，又用 &lt;strong&gt;Canvas&lt;/strong&gt; 重构了一版，优化了性能。&lt;/p&gt;&lt;p&gt;接下来我们分别来看看这两种实现方式。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;2. CSS 实现点赞动效&lt;/strong&gt;&lt;/h2&gt;&lt;h3&gt;&lt;strong&gt;2.1 轨迹分析&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;由于点赞动画是在一个二维平面上的，我们可以将它的运动轨迹拆分为 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 上的两段。&lt;/p&gt;&lt;p&gt;在 &lt;strong&gt;y 轴&lt;/strong&gt; 上非常简单，我们的点赞图标会做一段&lt;span&gt;垂直上升的&lt;/span&gt;匀速运动，从容器底部上升到容器顶部。&lt;/p&gt;&lt;p&gt;而 &lt;strong&gt;x 轴&lt;/strong&gt; 上是左右摇曳的，用数学的角度说，是一段简谐运动。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5864485981308412&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cn2ZYgnv2KkzoW2WoNHFD5PSDsaAiabyfxA6qK8MwRfyWWL1U0Ab8M0Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;&lt;/p&gt;&lt;p&gt;但用 css 实现的时候，其实不用这么精细。为了简化计算，我们可以用几个关键帧来串联这段运动轨迹，例如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    中间&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;25%&lt;/span&gt; {&lt;br/&gt;    最左&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;75%&lt;/span&gt; {&lt;br/&gt;    最右&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    中间&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;2.2 轨迹设计&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;根据上面的分析，我们可以设计一段相同的上升轨迹，以及几段不同的左右摇曳轨迹。&lt;/p&gt;&lt;p&gt;上升轨迹很简单，&lt;span&gt;同时&lt;/span&gt;我们还可以加上透明度（opacity）、大小（transform）的变化，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_y {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;margin-bottom&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;5%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1.5&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;80%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;margin-bottom&lt;/span&gt;: &lt;span&gt;var&lt;/span&gt;(--cntHeight);&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;0.8&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，--cntHeight 指的是容器的高度。也就是说，我们通过让 margin-bottom 不断增大，来控制点赞图标从容器底部上升到容器顶部。&lt;/p&gt;&lt;p&gt;而对于横向运动的轨迹，为了增加运动轨迹的多样性，我们&lt;span&gt;可&lt;/span&gt;&lt;span&gt;以设计多段&lt;/span&gt;左右摇曳的轨迹，比如说一段 “中间 -&amp;gt; 最左 -&amp;gt; 中间 -&amp;gt; 最右” 的轨迹：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_1 {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    // 中间&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;25%&lt;/span&gt; {&lt;br/&gt;    // 最左&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;75%&lt;/span&gt; {&lt;br/&gt;    // 最右&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里同样使用 margin 来控制图标的左右移动。类似的，我们还可以设计几段别的轨迹：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 任意轨迹&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_2 {&lt;br/&gt;  0% {&lt;br/&gt;    &lt;span&gt;// 中间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  33% {&lt;br/&gt;    &lt;span&gt;// 最左&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  100% {&lt;br/&gt;    &lt;span&gt;// 随机位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;6px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 简谐反向&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_3 {&lt;br/&gt;  0% {&lt;br/&gt;    &lt;span&gt;// 中间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  25% {&lt;br/&gt;    &lt;span&gt;// 最右&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  75% {&lt;br/&gt;    &lt;span&gt;// 最左&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  100% {&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们把 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 的轨迹（@keyframes）结合起来，并设置一个随机的动画时间，比如说：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$i&lt;/span&gt; from &lt;span&gt;1&lt;/span&gt; through &lt;span&gt;3&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$j&lt;/span&gt; from &lt;span&gt;1&lt;/span&gt; through &lt;span&gt;2&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;.bl_&lt;/span&gt;#{&lt;span&gt;$i&lt;/span&gt;}_#{&lt;span&gt;$j&lt;/span&gt;} {&lt;br/&gt;      &lt;span&gt;animation&lt;/span&gt;: bubble_y calc(&lt;span&gt;1.5s&lt;/span&gt; + &lt;span&gt;$j&lt;/span&gt; * &lt;span&gt;0.5s&lt;/span&gt;) linear &lt;span&gt;1&lt;/span&gt; forwards,&lt;br/&gt;        bubble_swing_#{&lt;span&gt;$i&lt;/span&gt;} calc(&lt;span&gt;1.5s&lt;/span&gt; + &lt;span&gt;$j&lt;/span&gt; * &lt;span&gt;0.5s&lt;/span&gt;) linear &lt;span&gt;1&lt;/span&gt; forwards;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里生成了 3 * 2 = 6 种不同的轨迹。针对这类重复的选择器，用 SCSS 中的循环语法，可以少写很多代码。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.3 随机选择图片（雪碧图）&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;我们每次点赞会出现不同的图标，于是这里设计了一系列选择器给不同的图标，让它们呈现不同的图片。首先我们要准备一张雪碧图，保持所有图标的大小一致，然后同样使用 SCSS 的循环语法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$i&lt;/span&gt; from &lt;span&gt;0&lt;/span&gt; through &lt;span&gt;7&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;.b&lt;/span&gt;#{&lt;span&gt;$i&lt;/span&gt;} {&lt;br/&gt;    &lt;span&gt;background&lt;/span&gt;: url(&lt;span&gt;&#x27;../../images/like_sprites.png&#x27;&lt;/span&gt;) calc(#{&lt;span&gt;$i&lt;/span&gt;} * -&lt;span&gt;24px&lt;/span&gt;) &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;像上面生成了 8 个选择器，我们在程序执行时就可以随机给图标赋予一个选择器。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.4 生成一个点赞图标&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;CSS 的部分差不多了，我们现在来看 JS 是怎么执行的。我们需要有一个容器 div，让它来装载要生成的点赞图标。以及一个按钮来绑定点击事件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const cacheRef = useRef&amp;lt;LikeCache&amp;gt;({&lt;br/&gt;    bubbleCnt: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    likeIcon: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    bubbleIndex: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    timer: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    cacheRef.current.bubbleCnt = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;like-bubble-cnt&#x27;&lt;/span&gt;);&lt;br/&gt;    cacheRef.current.likeIcon = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;like-icon&#x27;&lt;/span&gt;);&lt;br/&gt;}, []);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在点击事件中，生成一个新的 div 元素，并为它设置 className。接着将它 append 到容器下，最后在一段时间后销毁这个点赞图标元素。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 添加 bubble&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; addBubble = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { bubbleCnt } = cacheRef.current;&lt;br/&gt;&lt;br/&gt;  cacheRef.current.bubbleIndex %= maxBubble;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; d = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;div&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 图片类 b0 - b7&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 随机动画类 bl_1_1 - bl_3_2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; swing = &lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;3&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; speed = &lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;2&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  d.className = &lt;span&gt;`like-bubble b&lt;span&gt;${cacheRef.current.bubbleIndex}&lt;/span&gt; bl_&lt;span&gt;${swing}&lt;/span&gt;_&lt;span&gt;${speed}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  bubbleCnt?.appendChild(d);&lt;br/&gt;  cacheRef.current.bubbleIndex++;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 动画结束后销毁元素&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;setTimeout&lt;/span&gt;(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    bubbleCnt?.removeChild(d);&lt;br/&gt;  }, &lt;span&gt;2600&lt;/span&gt;);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这里，我们就实现得差不多了。不过，我们还可以给点击的图标加点动画，让它有一个被按压后弹起的效果：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 点击“喜欢”&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; onClick = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { timer, likeIcon } = cacheRef.current;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!likeIcon) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (timer) {&lt;br/&gt;    &lt;span&gt;clearTimeout&lt;/span&gt;(timer);&lt;br/&gt;    cacheRef.current.timer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  likeIcon.classList.remove(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;// 删除并重新添加类，需要延迟添加&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;setTimeout&lt;/span&gt;(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    likeIcon.classList.add(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;  }, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;  cacheRef.current.timer = &lt;span&gt;window&lt;/span&gt;.setTimeout(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    likeIcon.classList.remove(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;clearTimeout&lt;/span&gt;(timer!);&lt;br/&gt;    cacheRef.current.timer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }, &lt;span&gt;300&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  addBubble();&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;2.5 最终效果&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;最后来看看效果吧！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.3728813559322033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnKMM9EDicGnPXbFbLpMNpr4JMGcT53f2hbKZjW68KbtSACvXxibu3gI3g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;177&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;3. Canvas 实现点赞动效&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;我们都知道 Canvas 的绘制更流畅一些，能够带来更好的体验。但苦于编码比较复杂，也有一定的学习成本，实现起来要比 CSS 复杂不少。&lt;/p&gt;&lt;p&gt;接下来我们看看基于 &lt;span&gt;C&lt;/span&gt;&lt;span&gt;anvas&lt;/span&gt; 的点赞动效实现。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;3.1 画布创建&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;首先我们读取一个 &lt;span&gt;C&lt;/span&gt;&lt;span&gt;anvas&lt;/span&gt; 元素的 id，并通过 getContext 获取它的上下文。除此之外，还传入了一个 canvasScale，指的是画布放大的比例，这个在之后会用到：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;constructor&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;canvasId: string, canvasScale: number&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; canvas = &lt;span&gt;document&lt;/span&gt;.getElementById(canvasId) &lt;span&gt;&lt;strong&gt;as&lt;/strong&gt;&lt;/span&gt; HTMLCanvasElement;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.context = canvas.getContext(&lt;span&gt;&#x27;2d&#x27;&lt;/span&gt;)!;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.width = canvas.width;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.height = canvas.height;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.canvasScale = canvasScale;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.img = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.loadImages();&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.2 预加载图片（雪碧图）&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在 constructor 这里，我们还通过 loadImages 这个函数，预加载了雪碧图：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;/span&gt; likeSprites &lt;span&gt;&lt;strong&gt;from&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&#x27;../../images/like_sprites.png&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 预加载图片&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;loadImages = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; p = &lt;span&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve: (image: HTMLImageElement) =&amp;gt; &lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; img = &lt;span&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/span&gt; Image();&lt;br/&gt;    img.onerror = &lt;span&gt;() =&amp;gt;&lt;/span&gt; resolve(img);&lt;br/&gt;    img.onload = &lt;span&gt;() =&amp;gt;&lt;/span&gt; resolve(img);&lt;br/&gt;    img.src = likeSprites;&lt;br/&gt;  });&lt;br/&gt;  p.then(&lt;span&gt;(&lt;span&gt;img&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (img &amp;amp;&amp;amp; img.width &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.img = img;&lt;br/&gt;    } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// error(&#x27;[live-connect]预加载喜欢动效图片失败&#x27;);&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.3 轨迹拆解&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;同样的，我们需要从 Canvas 的视角来拆解点赞图标的运动轨迹。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;y 轴&lt;/strong&gt; 的运动和 CSS 一样，我们知道起始位置和终止位置就可以得出。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;x 轴&lt;/strong&gt; 的运动可以好好推敲。由于 Canvas 是逐帧绘制的，我们可以模拟出一个比较逼真的简谐运动。这里要来讲一讲大家耳熟能详的初中数学了，下面是我们要使用的一条正弦函数的公式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;y = A sin(Bx + C) + D&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数说明：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;振幅是 &lt;strong&gt;A&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;周期是 &lt;strong&gt;2π/B&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;相移是 &lt;strong&gt;−C/B&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;垂直移位是 &lt;strong&gt;D&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;套入点赞动效：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;赋予图标元素随机的振幅 A。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;赋予图标元素随机的周期，即 B 是随机的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;取 C = 0，即相移为 0。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;取 D = 0，即不需要垂直移位。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;y = A sinBx。&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.4 横竖位移计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;确定位移轨迹之后，我们先定义一些常量，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/** 图片显示宽高 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; IMAGE_WIDTH = &lt;span&gt;30&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 图片原始宽高 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; SOURCE_IMAGE_WIDTH = &lt;span&gt;144&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 图片数量 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; IMG_NUM = &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 放大阶段（百分比）*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; ENLARGE_STAGE = &lt;span&gt;0.1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 收缩渐隐阶段（百分比）*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; FADE_OUT_STAGE = &lt;span&gt;0.8&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先我们可以设计 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 两个方向上的位移计算函数，函数参数 progress 是 0 到 1 之间的数值，表示一个过程量（0 -&amp;gt; 1）。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 起始位置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; basicX = &lt;span&gt;this&lt;/span&gt;.width / &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 正弦频率&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; frequency = random(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 正弦振幅&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; amplitude = random(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;) * (random(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt; : -&lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;this&lt;/span&gt;.canvasScale;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取横向位移（x轴）&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getTranslateX = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; ENLARGE_STAGE) {&lt;br/&gt;    &lt;span&gt;// 放大期间，不进行摇摆位移&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; basicX;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; basicX + amplitude * &lt;span&gt;Math&lt;/span&gt;.sin(frequency * (progress - ENLARGE_STAGE));&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取竖向位移（y轴）&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getTranslateY = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; IMAGE_WIDTH / &lt;span&gt;2&lt;/span&gt; + (&lt;span&gt;this&lt;/span&gt;.height - IMAGE_WIDTH / &lt;span&gt;2&lt;/span&gt;) * (&lt;span&gt;1&lt;/span&gt; - progress);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.5 大小和透明度计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;要绘制的图标大小怎么控制呢？在 Canvas 中，其实就是计算一个 scale，表示放缩的比例。&lt;/p&gt;&lt;p&gt;我们根据放大/收缩阶段的过程常量和 progress 变量来调节它的大小。起始阶段先线性放大至 1，最后阶段再线性缩小至 0。&lt;/p&gt;&lt;p&gt;透明度同理，在消失之前都是返回 1，其余时刻线性缩小。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 获取放缩比例&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getScale = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; r = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; ENLARGE_STAGE) {&lt;br/&gt;    &lt;span&gt;// 放大&lt;/span&gt;&lt;br/&gt;    r = progress / ENLARGE_STAGE;&lt;br/&gt;  } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;gt; FADE_OUT_STAGE) {&lt;br/&gt;    &lt;span&gt;// 缩小&lt;/span&gt;&lt;br/&gt;    r = (&lt;span&gt;1&lt;/span&gt; - progress) / (&lt;span&gt;1&lt;/span&gt; - FADE_OUT_STAGE);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; r;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取透明度&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getAlpha = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; FADE_OUT_STAGE) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; - (progress - FADE_OUT_STAGE) / (&lt;span&gt;1&lt;/span&gt; - FADE_OUT_STAGE);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.6 Canvas 绘制&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;绘制时，我们先挑选一张图片。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 按顺序读取图片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { curImgIndex } = &lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 更新顺序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;.curImgIndex = ++&lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;.curImgIndex % IMG_NUM;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.1 画布元素清晰度&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;接下来需要用到我们之前提到的 canvasScale 了：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; newWidth = IMAGE_WIDTH * &lt;span&gt;this&lt;/span&gt;.canvasScale;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么这里要乘以一个 canvasScale 呢？因为 Canvas 是&lt;strong&gt;位图模式&lt;/strong&gt;的，它会根据设备的 &lt;strong&gt;dpi&lt;/strong&gt; 来渲染图片。&lt;/p&gt;&lt;p&gt;首先先介绍一下高分屏的概念：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;高分屏：在同样大小的屏幕面积上显示更多的像素点，也就是更多的可视信息。常见的就是 SXGA（1400 * 1050），UXGA（1600 * 1200）。1024 * 768 分辨率的屏幕叫普通屏，也就是 XGA 的屏幕，这个分辨率以上的屏幕叫高分屏。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在高分屏上，每平方英寸会有更多的像素。原来在普通屏上绘制的 1 个像素，为了适应高分屏，被迫放大，变成了 4 个像素或者更多。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可以想象成，一张清晰度正常的普通图片为了布满整个背景被强行放大 n 倍，所以看起来模糊了&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7434869739478958&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnbPNrjWlfSpuw7eSdysHUzPsroUKbjBBCf0f6Ik4MAkF99lOAqf1gRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;499&quot;/&gt;&lt;/p&gt;&lt;p&gt;为了解决这个问题，就需要我们将绘制的图片放大。同时还要控制 Canvas 画布在 CSS 中的宽高。做到绘制内容变大的同时，画布依然呈现原来的大小。这样一来，图片就会因为绘制了更多的内容，而在高分屏上变得清晰且细腻。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;3.6.2 绘制元素&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;绘制我们用到了 drawImage。在调用它之前，我们需要&lt;span&gt;根据计算出的 translateX 和 translateY，&lt;/span&gt;&lt;span&gt;调&lt;/span&gt;&lt;span&gt;整绘制的起&lt;/span&gt;&lt;span&gt;点&lt;/span&gt;。并且调整放缩比例和透明度，即 &lt;code&gt;context.scale()&lt;/code&gt; 和 &lt;code&gt;context.globalAlpha&lt;/code&gt;。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 动画过程 0 -&amp;gt; 1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;gt;= &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  context.save();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; scale = getScale(progress);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; translateX = getTranslateX(progress);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; translateY = getTranslateY(progress);&lt;br/&gt;  context.translate(translateX, translateY);&lt;br/&gt;  context.scale(scale, scale);&lt;br/&gt;  context.globalAlpha = getAlpha(progress);&lt;br/&gt;  context.drawImage(&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.img!,&lt;br/&gt;    SOURCE_IMAGE_WIDTH * curImgIndex,&lt;br/&gt;    &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    SOURCE_IMAGE_WIDTH,&lt;br/&gt;    SOURCE_IMAGE_WIDTH,&lt;br/&gt;    -newWidth / &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    -newWidth / &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    newWidth,&lt;br/&gt;    newWidth,&lt;br/&gt;  );&lt;br/&gt;  context.restore();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.3 创建绘制实例&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;我们用一个 start 函数来生成点赞动画，每当调用它时，都会创建一个 render 方法，并塞入一个 renderList。renderList 中存放的就是当前所有点赞图标的绘制任务。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;start = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; render = &lt;span&gt;this&lt;/span&gt;.createRender();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; duration = random(&lt;span&gt;2100&lt;/span&gt;, &lt;span&gt;2600&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!render) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.renderList.push({&lt;br/&gt;    render,&lt;br/&gt;    duration,&lt;br/&gt;    &lt;span&gt;timestamp&lt;/span&gt;: &lt;span&gt;Date&lt;/span&gt;.now(),&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.scanning) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    requestAnimationFrame(&lt;span&gt;this&lt;/span&gt;.scan);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.4 实时绘制&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;知道了需要绘制哪些对象之后，就需要通过下面的 scan 方法，让 Canvas 在每一帧都去绘制内容。&lt;/p&gt;&lt;p&gt;每次绘制分为这么几个过程：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;清空画布为透明。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从绘制列表中取出一个点赞图标的 render 方法，并调用它。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;假如它返回了 true，代表点赞图标已经完整经历了整个动效的过程，需要将它从绘制列表中剔除出去。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重复 2、3 过程，直至列表中没有任务需要执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;requestAnimationFrame&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 调用 scan 方法自身，等待下一帧重新调用 scan 绘制内容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;scan = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.context.clearRect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.width, &lt;span&gt;this&lt;/span&gt;.height);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; { length } = &lt;span&gt;this&lt;/span&gt;.renderList;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (length &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    requestAnimationFrame(&lt;span&gt;this&lt;/span&gt;.scan);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt; (index &amp;lt; length) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; child = &lt;span&gt;this&lt;/span&gt;.renderList[index];&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!child || !child.render || child.render.call(&lt;span&gt;null&lt;/span&gt;, (&lt;span&gt;Date&lt;/span&gt;.now() - child.timestamp) / child.duration)) {&lt;br/&gt;      &lt;span&gt;// 结束了，删除该动画&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.renderList.splice(index, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;      length--;&lt;br/&gt;    } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;      index++;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.7 调用&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;接下来我们只需要在点击的时候，调用一下 &lt;code&gt;start&lt;/code&gt; 方法即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 点击“喜欢”&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; onClick = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  cacheRef.current.LikeAni?.start?.();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{cn(&lt;/span&gt;&#x27;&lt;span&gt;like-wrap&lt;/span&gt;&#x27;, &lt;span&gt;className&lt;/span&gt;)}&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;canvas&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{CANVAS_ID}&lt;/span&gt; &lt;span&gt;width&lt;/span&gt;=&lt;span&gt;{CANVAS_WIDTH}&lt;/span&gt; &lt;span&gt;height&lt;/span&gt;=&lt;span&gt;{CANVAS_HEIGHT}&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;like-bubble-cnt&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{cn(&lt;/span&gt;&#x27;&lt;span&gt;like-icon-cnt&lt;/span&gt;&#x27;, &lt;span&gt;className&lt;/span&gt;)} &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{onClick}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;i&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;like-icon&quot;&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;like-icon&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在直播场景下，还有很多不同的触发方式。除了自己点击，我们还可以接受来自其他用户的反馈（网络请求）来触发&lt;span&gt; &lt;/span&gt;&lt;code&gt;start&lt;/code&gt;&lt;span&gt; 方法&lt;/span&gt;。或者根据在线人数，多次调用 &lt;code&gt;start&lt;/code&gt; 方法来生成一定数量的点赞图标。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;3.8 最终效果&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.3728813559322033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnYP7LBJLR62gxgcnGSICWb4VWTXCy1PFJEvticiaLXO5TWh19eA5M2xZQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;177&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;4. 性能比较&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;以下内容是在 MacBook Pro 16 的屏幕上测试的。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;4.1 Frame Rendering Stats&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在 chrome devtools 中，有两个小功能可以来观察我们绘制的性能情况：&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;这两个功能，可以在 chrome devtools 中使用快捷键 Command + Shift + P，呼起命令搜索的 Panel 来搜索到。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;CSS 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;我们可以看到高亮区域在频繁闪动，以及 GPU 内存的使用比率较高，这是因为 CSS 的实现方式是不断生成新的元素（并在随后销毁），会消耗更多的内存。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0235690235690236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cn61PuKHuVcJY64I0ciaw5Yib7aKR0QeczWS6w7Vov2EtcKhruOHEXIuAw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;297&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Canvas 性能&lt;/strong&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;相反，Canvas 是集中在画布上绘制并输出的，不会反复创建和销毁元素。会比 CSS 的实现更加流畅，性能更好一点。&lt;/p&gt;&lt;p&gt;除了流畅以外，Canvas 还能够放大画布和画布元素，这也是一个非常重要的优势。这意味着 Canvas 能够绘制出更清晰的内容，生成出来的点赞图标更加细腻。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0235690235690236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CneXgmLZDgbvcd17KZ2etPibicNN9GTMoSaib6cFxiaHuCRAlrB4tkvuibrLw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;297&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;4.2 Performance&lt;/strong&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;在 chrome devtools 中切换到 Performance 面板，还可以观察动画绘制过程中，页面的一些性能指标。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;CSS 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;CSS 的实现之所以看起比较卡顿，主要是因为绘制任务太频繁。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1705790297339593&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnUB3NiciafG8nmTuKibbRQ4OKZVeJicHbvMxclwKsmicZ6k6jQwumiaFCb9Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1278&quot;/&gt;&lt;/p&gt;&lt;p&gt;具体到每一帧，我们可以观察到 LayoutShift 的警告。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.50431654676259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cnh2hVHf4azOrrBKM4A1mHibNyeGI0x6ad3ze5OtdPuPBZuBQ5ogzfYaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1390&quot;/&gt;&lt;/p&gt;&lt;p&gt;每次可视元素在两次渲染帧中的起始位置不同时，就说是发生了 LS（Layout Shift）。&lt;strong&gt;改变了起始位置的元素被认为是不稳定元素&lt;/strong&gt;。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Canvas 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Canvas 实现的性能情况看起来就比较正常，即使绘制清晰一些的图片也不在话下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0332409972299168&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnKibqyoXGwzYP3IPzDj3bfosticSBNhal4Nr1rrz5HjibvRDqsJ1kHT5iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;5. 相关&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;实现参考：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2Fantiter%2Fpraise-animation&amp;amp;title=&quot; href=&quot;&quot;&gt;https://github.com/antiter/praise-animation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;往期推荐：&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&amp;amp;mid=2650092727&amp;amp;idx=1&amp;amp;sn=962d516d9927c04a45f8435d49936a71&amp;amp;chksm=83dba9d2b4ac20c474c19eb19363f28a3e4de090be03f45da5ce736d716580d58b12be7fe179&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;CSS 动画制作的 12 个技巧&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;CSS 动画制作的 12 个技巧&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&amp;amp;mid=2650085832&amp;amp;idx=2&amp;amp;sn=434cc6bc2d8a3648826dc2db180ee680&amp;amp;chksm=83db84adb4ac0dbb9c24f821df6ccddda0b7a3daa47fb4db4f7562ef4e2b4de7f09be1a88f06&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;CSS3实现5个常用的网页动画效果&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;CSS3实现5个常用的网页动画效果&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&amp;amp;mid=2650098819&amp;amp;idx=2&amp;amp;sn=a4fdd7377b44f390e8192b90534d5b74&amp;amp;chksm=83dbd1e6b4ac58f0f767aff48096bcc31238b86b3181465bf6be6f8697aa0b0062363e970a76&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;万字长文：分享前端性能优化知识体系&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;万字长文：分享前端性能优化知识体系&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&amp;amp;mid=2650098795&amp;amp;idx=1&amp;amp;sn=73d512f22b3dc74f8f00b8ed28431fab&amp;amp;chksm=83dbd10eb4ac5818f5e65de078dcd3dba5c0512d70a468a7257ffba21a49a4c8e7638883f72c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;面试常见的7个高频正则表达式，没你想的那么难！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;面试常见的7个高频正则表达式，没你想的那么难！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外欢迎大家围观我的朋友圈，搞搞技术，&lt;/span&gt;&lt;span&gt;吹吹牛逼。关注我，秒添加，回复&lt;strong&gt;加群&lt;/strong&gt;，可以进入 500人前端群。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HLN2IKtpicicE775qGlNWd9SzJXX16Hu5j7hTrzo5SK3lldLxyC7ibvOez3IyqWhLPhv9mYcyKp7GFgUHDfL4wGDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>