<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9dd94c2f5d73b74473f75d8c6db3d671</guid>
<title>2023 年该学点什么技术？「GitHub 热点速览 v.23.03」</title>
<link>https://toutiao.io/k/2hoku7p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6220462543991956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EB8enjr9LGXGe12YbsD2n93Gvz0ANXkU1e2XTkszFMzzOiaaeV0ejTJLA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;7956&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：HelloGitHub-小鱼干&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;春节期间，小鱼干读了一篇万字回顾数据库行业的文章，在文字缝隙里我看见了两个词：AI+ 和数据两个词（当然数据是废话，毕竟是一个数据库的回顾文）。在 GitHub 上热点趋势上，可见到 AI+ 的身影，几乎百分之九十迅速蹿红的项目都同 AI 相关。所以在兔年的开头，本期收录一些入门 AI 的项目，希望兔年的你和那些 AI 项目一样突飞猛进。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以下内容摘录自微博&lt;/span&gt;&lt;span&gt;@HelloGitHub&lt;/span&gt;&lt;span&gt; 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;/span&gt;&lt;code&gt;&lt;span&gt;新发布&lt;/span&gt;&lt;/code&gt;&lt;span&gt; | &lt;/span&gt;&lt;code&gt;&lt;span&gt;实用&lt;/span&gt;&lt;/code&gt;&lt;span&gt; | &lt;/span&gt;&lt;code&gt;&lt;span&gt;有趣&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，根据项目 release 时间分类，发布时间不超过 14 day 的项目会标注 &lt;/span&gt;&lt;code&gt;&lt;span&gt;New&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，无该标志则说明项目 release 超过半月。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5082547169811321&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EBsh29cEFFibFic6jicGicd0mDYRZmHfLlTR32nnqxsuXic5dVaIz4OkFicKYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1696&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 本周特推&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1.1 数据工程：data-engineering-zoomcamp&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主语言：Jupyter Notebook、Python、Java&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个免费的数据工程教程，带你入门大数据。教程一共分为 9 周，前面三周了解基础知识、讲 Workflow Orchestration、数据湖，从第四周开始分析处理数据，教批处理和流处理等常见处理方式，最后 3 周为实操的 Project 部分。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/DataTalksClub/data-engineering-zoomcamp&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.091451292246521&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EBvLPwF9ZY5FYGG1qL0QKRRTqD7EmK8YicWgc2G19GnW0YP5d5MWp7ALw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1.2 微软 AI 教程：AI-For-Beginners&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主语言：Jupyter Notebook&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;微软出品的 AI 新手教程，同它的其他 For Beginner 教程一样，它对新手十分友好，将复杂的 AI 知识进行分解，在 24 节课程中一一教授给你。除了课程之外，Microsoft Learn 还提供了一个方便启用的 GPU 环境让你更好地深入了解该课程。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/microsoft/AI-For-Beginners&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7049576783555018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EBt63y7jGxUqfibTCwN3CO1su5ZkHvfoThkwBHssicKaiclMtZTHWottrcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2481&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. GitHub Trending 周榜&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 AI 想象：imaginAIry&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：3,500+&lt;strong&gt;，&lt;/strong&gt;主语言：Python&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想知道 AI 的想象力到底如何么？ImaginAIry 便是一个根据你的描述生成对应图片的项目。也许你可以试试用它来生成你兔年兔飞猛进的那个时刻 :D 项目暂时可以在 macOS（M1）和 Linux 下运行，并未能在 Windows 下运行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面的示例代码能生成相关的示例图（下图）&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# on macOS, make sure rust is installed first&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt; pip install imaginairy&lt;br/&gt;&amp;gt;&amp;gt; imagine &lt;span&gt;&quot;a scenic landscape&quot;&lt;/span&gt; &lt;span&gt;&quot;a photo of a dog&quot;&lt;/span&gt; &lt;span&gt;&quot;photo of a fruit bowl&quot;&lt;/span&gt; &lt;span&gt;&quot;portrait photo of a freckled woman&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Stable Diffusion 2.1&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt; imagine --model SD&lt;span&gt;-2.1&lt;/span&gt; &lt;span&gt;&quot;a forest&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/brycedrennan/imaginAIry&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5067796610169492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EBTYaCqZrb42wNoENeiaJwtLgAuz4EPVxScORhwfic5bicTrbicAky9Ngr3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 为懒人而生：LazyVim&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,600+&lt;strong&gt;，&lt;/strong&gt;主语言：Lua&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想用 Neovim 又懒得配置？LazyVim for lazy，它可轻松自定义、扩展你的配置。它可灵活调整配置，也有预先配置的便利，免你从头开始搞配置。特性：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将你的 Neovim 转为功能齐全的 IDE；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用 &lt;/span&gt;&lt;span&gt;lazy.vim&lt;/span&gt;&lt;span&gt; 轻松定制配置；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;快速；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;选项、autocmd、 keymap 都有恰到好处的默认设置；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;丰富的插件；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/LazyVim/LazyVim&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6919642857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EB7ic1GQnMtlXnc3UtdLfusQCuf7gCQziahLWO3f8foaI0UdjEOfHtByFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.3 深度学习的模型优化：tuning_playbook&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：10,800+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;New&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 想提升深度学习模型的性能么？Google 研究所开源了他们的模型优化方式，项目侧重点是高参数调整的过程，以此得到更好的模型性能。顺便提一嘴，这个刚开源没有一星期的项目，已经破 10k star 可见它的受欢迎程度。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/google-research/tuning_playbook&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.4 GitHub 档案：octosuite&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：500+&lt;strong&gt;，&lt;/strong&gt;主语言：Python&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个收集 GitHub 用户、仓库、组织的开源情报的框架，简单来说你可以看到一个 ID（用户、仓库、组织）相关的信息，比如：粉丝、所在地、组织多少个仓库。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/bellingcat/octosuite&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5619791666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EBfXpNzHxJQLIj0UXFTOXW3o6cmMsibpmjnCEK4OMNibT7NA4rUxu0Ficiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.5 可视化 git：git-sim&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,550+&lt;strong&gt;，&lt;/strong&gt;主语言：Python&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用命令在你终端模拟你的 git 操作，下图为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;git-sim merge &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的展示结果。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/initialcommit-com/git-sim&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EBrbCd9mrJ9Wn2Pz75zxmv4a5OxFNFuMMVw75kwiaqibfwyVyVhn8S8RjA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 往期回顾&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;往期回顾：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上为 2023 年第 3 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 &lt;/span&gt;&lt;span&gt;HelloGitHub&lt;/span&gt;&lt;span&gt; issue 区和我们分享下哟 🌝&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，记得你在本文留言区留下你想看的主题 Repo（限公众号），例如：AI 换头。👀 和之前的送书活动类似，留言点赞 Top3 的小伙伴(&lt;span&gt;棒&lt;/span&gt;），小鱼干会努力去找 Repo 的^^&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub001 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;&lt;/blockquote&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>19a01f81a278e1a5aef0efc341c28949</guid>
<title>Python 的垃圾回收机制</title>
<link>https://toutiao.io/k/mkz3pjd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;151&quot; data-source-title=&quot;&quot; data-text=&quot;几乎所有的高级编程语言都有自己的垃圾回收机制，开发者不需要关注内存的申请与释放，Python 也不例外。Python 官方团队的文章 https://devguide.python.org/internals/garbage-collector 详细介绍了 Python 中的垃圾回收算法，本文是这篇文章的译文。&quot; data-editid=&quot;6r1avmr7hpo0000000&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;几乎所有的高级编程语言都有自己的垃圾回收机制，开发者不需要关注内存的申请与释放，Python 也不例外。Python 官方团队的文章 https://devguide.python.org/internals/garbage-collector 详细介绍了 Python 中的垃圾回收算法，本文是这篇文章的译文。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;摘要&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;CPython 中主要的垃圾回收算法是引用计数。引用计数顾名思义就是统计每个对象有多少个引用，每个引用可能来自另外一个对象，或者一个全局（或静态）C 变量，或者 C 语言函数中的局部变量。当一个变量的引用计数变成 0，那么这个对象就会被释放。如果被释放的对象包含对其他对象的引用，那么其他对象的引用计数就会相应地减 1。如果其他对象的引用计数在减 1 之后变成 0，这些对象也会级联地被释放掉。在 Python 代码中可以通过 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;sys.getrefcount&lt;/span&gt; 函数获取一个对象的引用计数（函数的返回值会比实际的引用计数多 1，因为函数本身也包含一个对目标对象的引用）。&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;x&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;sys&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getrefcount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;y&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;x&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;sys&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getrefcount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;del&lt;/span&gt; &lt;span&gt;y&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;sys&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getrefcount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;引用计数最大的问题就是不能处理循环引用。&lt;/span&gt;&lt;span&gt;下面是一个循环引用的例子：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;container&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;container&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;sys&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getrefcount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;del&lt;/span&gt; &lt;span&gt;container&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在这个例子中，&lt;/span&gt;&lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;container&lt;/span&gt;&lt;span&gt; 对象包含一个对自己的引用，所以即使我们移除了一个引用（变量 &lt;/span&gt;&lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;container&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span data-token-index=&quot;5&quot; spellcheck=&quot;false&quot;&gt;container&lt;/span&gt;&lt;span&gt; 对象的引用计数也不会变成 0，因为 &lt;/span&gt;&lt;span data-token-index=&quot;7&quot; spellcheck=&quot;false&quot;&gt;container&lt;/span&gt;&lt;span&gt; 对象内部仍然有一个对自身的引用。&lt;/span&gt;&lt;span&gt;因此如果仅仅通过简单的引用计数，&lt;/span&gt;&lt;span data-token-index=&quot;9&quot; spellcheck=&quot;false&quot;&gt;container&lt;/span&gt;&lt;span&gt; 对象永远不会被释放。&lt;/span&gt;&lt;span&gt;鉴于此，当对象不可达的时候（译注：&lt;/span&gt;&lt;span&gt;当代码中没有对实际对象的引用时），我们需要额外的机制来清除这些不可达对象间的循环引用。&lt;/span&gt;&lt;span&gt;这个额外的机制就是循环垃圾收集器，通常简称为垃圾收集器（Garbage Collector，GC），虽然引用计数也是一种垃圾回收算法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;内存布局和对象结构&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般的 Python 对象在 C 语言中的结构体表示如下&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;object -----&amp;gt; +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                    ob_refcnt                  |&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |&lt;/span&gt; PyObject_HEAD&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                    *ob_type                   |&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ /&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                      ...                      |&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了支持垃圾回收，在一般 Python 对象的内存布局前面加了一些额外的信息&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                    *_gc_next                  |&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |&lt;/span&gt; PyGC_Head&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                    *_gc_prev                  |&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;object -----&amp;gt; +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ /&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              |&lt;/span&gt;                    ob_refcnt                  &lt;span class=&quot;code-snippet__params&quot;&gt;| \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |&lt;/span&gt; PyObject_HEAD&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                    *ob_type                   |&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ /&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                      ...                      |&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过这种方式，object 可以被看做一般的 Python 对象，当需要垃圾回收相关的信息时可以通过简单的类型转换来访问前面的字段：&lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;((PyGC_Head *)(the_object)-1)&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;在后面的章节 &lt;strong&gt;优化：通过复用字段来节省内存&lt;/strong&gt; 会介绍这两个字段通常用来串联起被垃圾收集器管理的对象构成的双向链表（ 每个链表对应垃圾回收中的一个分代，更多细节在 &lt;strong&gt;优化：分代回收&lt;/strong&gt; 中有介绍），但是在不需要链表结构的时候这两个字段会被用作其他功能来减少内存的使用。&lt;/p&gt;&lt;p&gt;使用双向链表是因为其能高效地支持垃圾回收对链表的一些高频操作。所有被垃圾收集器管理的对象被划分成一些不相交的集合，每个集合都在各自的双向链表中。不同的集合表示不同的分代，对象所处的分代反映了其在垃圾回收中存活了多久。每次垃圾回收的时候，每个分代中的对象会进一步划分成可达对象和不可达对象。双向链表的一些操作比如移动对象、添加对象、完全删除一个对象（垃圾收集器管理的对象一般情况下会在两次垃圾回收之间通过引用计数系统回收）、合并链表等，都会在常量时间复杂度完成。并且双向链表支持在遍历的时候添加和删除对象，垃圾收集器在运行的时候这也是一个非常频繁的操作。&lt;/p&gt;&lt;section&gt;&lt;span&gt;为了支持对象的垃圾回收，Python 的 C 接口提供了一些 API 来分配、释放、初始化、添加和移除被垃圾收集器维护的对象。这些 API 的详情参见 &lt;span&gt;https://docs.python.org/3/c-api/gcsupport.html&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除了上面的对象结构之外，对于支持垃圾回收的对象的类型对象必须要在 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;tp_flags&lt;/span&gt; 字段中设置 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;Py_TPFLAGS_HAVE_GC&lt;/span&gt; 标记，并且实现 &lt;span data-token-index=&quot;5&quot; spellcheck=&quot;false&quot;&gt;tp_traverse&lt;/span&gt; 句柄。另外这些类型对象还要实现 &lt;span data-token-index=&quot;7&quot; spellcheck=&quot;false&quot;&gt;tp_clear&lt;/span&gt; 句柄，除非能够证明仅仅通过该类型的对象不会形成循环引用或者支持垃圾回收的对象是不可变类型。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;循环引用的识别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;CPython 中识别循环引用的算法在 &lt;code&gt;gc&lt;/code&gt; 模块中实现。垃圾收集器只关注清除容器类型的对象（也就是那些能够包含对其他对象的引用的对象）。比如数组、字典、列表、自定义类实例和扩展模块中的类等等。虽然循环引用并不常见， 但是 &lt;code&gt;CPython&lt;/code&gt; 解释器自身也会由于一些内部引用的存在形成循环引用。下面是一些典型场景&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;异常对象 exception 会包含栈跟踪对象 traceback，栈跟踪对象包含栈帧的列表，这些栈帧最终又会包含异常对象。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;模块级别的函数会引用模块的字典 dict（用于解析全局变量），模块字典反过来又会包含模块级别的函数。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;类的实例对象会引用其所属的类对象，类对象会引用其所在的模块，模块会包含模块内的所有对象（可能还会包含其他的模块）从而最终会引用到最初的类实例对象。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当要表示图这类数据结构的时候，很容易产生对自身的引用。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果想要正确释放不可达的对象，第一步就是要识别出不可达对象。在识别循环引用的函数中维护了两个双向链表：一个链表包含所有待扫描的对象，另一个链表包含暂时不可达的对象。&lt;/p&gt;&lt;section&gt;为了理解算法的原理，我们看一下下面的示例，其中 A 引用了一个循环链表，另外还有一个不可达的自我引用的对象：&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Link&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;next_link&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;         &lt;span&gt;self&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;next_link&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next_link&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;link_3&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Link&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;link_2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Link&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;link_3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;link_1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Link&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;link_2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;link_3&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;next_link&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;link_1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;link_1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;del&lt;/span&gt; &lt;span&gt;link_1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;link_2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;link_3&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;link_4&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Link&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;link_4&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;next_link&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;link_4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;del&lt;/span&gt; &lt;span&gt;link_4&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 回收不可达的 Link 对象 (和它的字典 __dict__)。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;collect&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;当垃圾收集器开始工作的时候，会将所有要扫描的容器对象放在第一个链表中，这样做是为了将所有不可达对象移除。&lt;/span&gt;&lt;span&gt;因为正常情况下大多数对象都是可达的，所以移除不可达对象会涉及更少的指针操作，因此更高效。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;算法开始的时候会为所有支持垃圾回收的对象另外初始化一个引用计数字段（下图中的 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt;），初始值设置为对象实际的引用计数。因为算法在识别循环引用的计算中会修改引用计数，通过使用一个另外的字段 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 解释器就不会修改对象真正的引用计数。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2916666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icAqJzf0cgMAuxicQMZDAUCMH6JCyWNEyUPGcA4CHBM6xqDj5q5ZK0zyA5vjpABiacLaW4NyyVWyOoK4DicC5kPPIw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;垃圾收集器会遍历第一个列表中的所有容器对象，每遍历一个对象都会将其所引用的所有的其他对象的 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 字段减 1。为了找到容器对象所引用的其他对象需要调用容器类的 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;tp_traverse&lt;/span&gt; 方法（通过 C API 实现或者由超类继承）。在遍历完之后，只有那些被外部变量引用的对象的 &lt;span data-token-index=&quot;5&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 的值才会大于 0。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2916666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icAqJzf0cgMAuxicQMZDAUCMH6JCyWNEyU1GhqFNASiaQrpgHJRe9Pvss2x9eZpoDRliahgqhBZfvYXolCyuFHbjeQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;需要注意的是即使 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc_ref == 0&lt;/span&gt; 也不能说明对象就是不可达的。因为被外部变量引用的对象（&lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;gc_ref &amp;gt; 0&lt;/span&gt;）仍然可能引用它们。比如在我们的例子中，&lt;span data-token-index=&quot;5&quot; spellcheck=&quot;false&quot;&gt;link_2&lt;/span&gt; 对象在第一次遍历之后 &lt;span data-token-index=&quot;7&quot; spellcheck=&quot;false&quot;&gt;gc_ref == 0&lt;/span&gt;，但是 &lt;span data-token-index=&quot;9&quot; spellcheck=&quot;false&quot;&gt;link_1&lt;/span&gt; 对象仍然会引用 &lt;span data-token-index=&quot;11&quot; spellcheck=&quot;false&quot;&gt;link_2&lt;/span&gt;，而 &lt;span data-token-index=&quot;13&quot; spellcheck=&quot;false&quot;&gt;link_1&lt;/span&gt; 是从外部可达的。为了找到那些真正不可达的对象，垃圾收集器需要重新遍历容器对象，这次遍历的时候会将 &lt;span data-token-index=&quot;15&quot; spellcheck=&quot;false&quot;&gt;gc_ref == 0&lt;/span&gt; 的对象标记为暂时不可达并且移动到暂时不可达的链表中。下图描述了垃圾收集器在处理了 &lt;span data-token-index=&quot;17&quot; spellcheck=&quot;false&quot;&gt;link_3&lt;/span&gt; 和 &lt;span data-token-index=&quot;19&quot; spellcheck=&quot;false&quot;&gt;link_4&lt;/span&gt; 对象但是还没处理 &lt;span data-token-index=&quot;21&quot; spellcheck=&quot;false&quot;&gt;link_1&lt;/span&gt; 和 &lt;span data-token-index=&quot;23&quot; spellcheck=&quot;false&quot;&gt;link_2&lt;/span&gt; 对象时的状态。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2916666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icAqJzf0cgMAuxicQMZDAUCMH6JCyWNEyUT06tdtFmZYXQZrNptzclib0vf4YPSd47oPqMhM5fZVMaPSfhGibx56gA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;垃圾收集器接下来会处理 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;link_1&lt;/span&gt; 对象。由于 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;gc_ref == 1&lt;/span&gt;，垃圾收集器不会对其做特殊处理因为知道其可达（并且已经在可达对象链表中）。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2916666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icAqJzf0cgMAuxicQMZDAUCMH6JCyWNEyU56o7h3x9GyWneDM7B1Z5tZu719ictxxxHuWSUXcWbg5RDVQz9zcfx6g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;当垃圾收集器遇到可达对象时（&lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc_ref &amp;gt; 0&lt;/span&gt;），会通过 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;tp_traverse&lt;/span&gt; 找到其所引用的其他对象，并且将这些对象移动到可达对象链表（它们最初所在的链表）的末尾，同时设置 &lt;span data-token-index=&quot;5&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 字段为 1。&lt;span data-token-index=&quot;7&quot; spellcheck=&quot;false&quot;&gt;link_2&lt;/span&gt; 和 &lt;span data-token-index=&quot;9&quot; spellcheck=&quot;false&quot;&gt;link_3&lt;/span&gt; 对象就会被这样处理，因为它们都被 &lt;span data-token-index=&quot;11&quot; spellcheck=&quot;false&quot;&gt;link_1&lt;/span&gt; 引用。在上图所示状态之后，垃圾收集器会检查被 &lt;span data-token-index=&quot;13&quot; spellcheck=&quot;false&quot;&gt;link_1&lt;/span&gt; 引用的对象从而知道 &lt;span data-token-index=&quot;15&quot; spellcheck=&quot;false&quot;&gt;link_3&lt;/span&gt; 是可达的，所以将其移回到原来的链表中并且设置 &lt;span data-token-index=&quot;17&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 字段值为 1，那么垃圾收集器下次遇到 &lt;span data-token-index=&quot;19&quot; spellcheck=&quot;false&quot;&gt;link_3&lt;/span&gt; 的时候就知道它是可达的。为了避免重复处理同一个对象，垃圾收集器在处理被可达对象引用的对象的时候会标记它们已经被访问过（通过清除 &lt;span data-token-index=&quot;21&quot; spellcheck=&quot;false&quot;&gt;PREV_MASK_COLLECTING&lt;/span&gt; 标记）。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2916666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icAqJzf0cgMAuxicQMZDAUCMH6JCyWNEyUUVZgr5BvhgrylCHDTKEjQmDMnu5OCZcfXWtk2FenicwQm1COKudxxmg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;需要注意的是那些开始被标记为暂时性不可达后来又被回到可达对象链表的对象，会再次被垃圾收集器访问到，因为按照算法逻辑现在被这些对象引用的其他对象也要被处理。第二次遍历实际上是对这些对象间引用关系构成的图的广度优先搜索。在第二遍遍历结束后，垃圾收集器就可以确定现在还留在暂时性不可达对象链表中的对象是真的不可达，因此可以被回收掉。&lt;/p&gt;&lt;p&gt;值得注意的是，整个算法中没有递归操作，也不需要相对于对象数量、指针数量或引用链长度的线性内存空间。除了临时的 C 变量占用 O(1) 的常量空间外，对象本身的字段都已经包含了算法需要的所有数据。&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;为什么选择移动不可达的对象&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;因为大多数对象都是可达对象，因此移动不可达对象看起来很合理。但是真正的原因并非想象的那么简单。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们依次创建了 A、B 和 C 三个对象，那么它们在第一代（译注：这里的第一代指的是分代回收）中的顺序就是创建顺序。如果 B 引用 A，C 引用 B，并且 C 有外部引用，那么在垃圾回收算法的第一轮遍历之后 A、B 和 C 的 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 值分别为 0、0 和 1，因为只有 C 是外部可达对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在算法的第二轮遍历中，会先访问 A，因为 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 为 0 会被移动到暂时性不可达对象链表中，B 也一样。当访问到 C 的时候会将 B 移回到可达对象链表中，当再次访问 B 的时候 A 也会被移回到可达对象链表中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本可以不用移动，A 和 B 却来回移动了两次，为什么要这么做呢？如果算法直接移动可达对象的话，那么只用将 A、B 和 C 分别移动一次即可。这么做的关键是在垃圾回收结束的时候这几个对象在链表中的顺序依次为 C、B 和 A，与它们最初的创建顺序相反。在后续的垃圾回收中，它们不再需要做任何移动。因为大多数对象之间都没有循环引用，这样做只会在第一次垃圾回收的时候开销比较大，在后续的垃圾回收中能节省很多移动的开销。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;销毁不可达对象&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一旦垃圾收集器确定了最终的不可达对象列表，就开始销毁这些对象，销毁的大体过程如下&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;处理并且清除弱引用（如果有的话）。如果要销毁的不可达对象有弱引用的回调，那么需要处理回调函数。这个处理过程需要特别小心，因为一个小小的错误就可能让状态不一致的对象被复活或者被回调函数所调用的 Python 函数引用。如果弱引用对象本身也是不可达的（弱引用和其引用的对象在不可达的循环引用中），那么这个弱引用对象需要马上被清理并且不用调用回调函数。如果不马上清理的话，那么在后来调用 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;tp_clear&lt;/span&gt; 的时候会造成严重后果。当弱引用和其引用的对象都不可达的时候，那么两者都会被销毁，因此可以先销毁弱引用，这个时候其引用的对象还存在，所以可以忽略弱引用的回调。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果对象有老版本的终结器（&lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;tp_del&lt;/span&gt;）需要将其移到 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;gc.garbage&lt;/span&gt; 列表中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调用不可达对象的终结器（&lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;tp_finalize&lt;/span&gt;函数）并且标记这些对象已终结，避免对象被复活后或者在其他对象的终结器已经移除该对象的情况下重复调用 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;tp_finalize&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;处理被复活的对象。如果有些不可达对象在上一步被复活，垃圾收集器需要重新计算出最终的不可达对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于每个最终的不可达对象，调用 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;tp_clear&lt;/span&gt; 来打破循环引用使每个对象的引用计数都变成 0，从而触发基于引用计数的销毁逻辑。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;优化：分代回收&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了避免每次垃圾回收的时候耗时太久，垃圾收集器使用了一个常用的优化：分代回收。分代回收有个前提假设，认为大多数对象的生命周期都很短，会在创建后很快就被回收。这个假设与现实中很多 Python 程序的情况一致，因为很多临时对象会被很快地创建和销毁。存活越久的对象越不容易因为不可达而被回收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了充分利用这一点，所有容器对象都会被分成三代中的某一代。每个新建的容器对象都处于第一代（generation 0）。上面描述的垃圾回收算法只在某一个具体的分代中进行，那些没有被回收的对象会进入下一代（generation 1），这一代中的对象相对于上一代执行垃圾回收的次数会更少。如果对象在新一代中仍然没有被回收就会移动到最后一代（generation 2），在最后一代中执行垃圾回收的次数是最少的。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;垃圾收集器会记录在上次垃圾回收之后新增对象与销毁对象数量之差，也就是净新增对象数量。如果超过了 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;threshold_0&lt;/span&gt; 垃圾收集器就会执行。最初的时候垃圾回收只在 generation 0 中执行。如果 generation 1 在上次执行垃圾回收之后， generation 0 中执行垃圾回收的次数超过了 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;threshold_1&lt;/span&gt; 那么就会再次在 generation 1 中执行垃圾回收。对于 generation 2 的处理稍微复杂点，在 &lt;strong&gt;第三代中的垃圾回收&lt;/strong&gt; 中单独介绍。前面说的阈值 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;threshold_0&lt;/span&gt; 和 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;threshold_1&lt;/span&gt; 可以通过函数 &lt;span data-token-index=&quot;5&quot; spellcheck=&quot;false&quot;&gt;gc.get_threshold&lt;/span&gt; 查看（译注：原文这里描述有误，我在 issue &lt;span&gt;https://github.com/python/devguide/issues/1027&lt;/span&gt; 中提出并被作者采纳）：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get_threshold&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;700&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;每个分代中的对象可以通过函数 &lt;/span&gt;&lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc.get_objects(generation=NUM)&lt;/span&gt;&lt;span&gt; 查看，另外可以通过调用函数 &lt;/span&gt;&lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;gc.collect(generation=NUM)&lt;/span&gt;&lt;span&gt; 指定在哪个分代中执行垃圾回收。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyObj&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 为了更容易观察年轻代中的对象需要将第一代和第二代中的对象都移动到第三代&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;collect&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;# 译注：不同版本执行的时候的结果不一样&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 创建循环引用&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;x&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;MyObj&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;x&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;self&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;x&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# x 最初在第一代中&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get_objects&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;generation&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[...,&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MyObj&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; &lt;span&gt;at&lt;/span&gt; &lt;span&gt;0x7fbcc12a3400&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;...]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 在第一代中执行垃圾回收之后，x 就移动到了第二代&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;collect&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;generation&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get_objects&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;generation&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[]&lt;/span&gt; &lt;span&gt;# 译注：在交互模式下，每次键入的代码都会经过编译再执行，所以输出中还有编译过程生成的一些被垃圾收集器管理的对象&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get_objects&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;generation&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[...,&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MyObj&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; &lt;span&gt;at&lt;/span&gt; &lt;span&gt;0x7fbcc12a3400&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;...]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;第三代中的垃圾回收&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在上面提到的各种阈值的基础之上，只有当比率 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;long_lived_pending / long_lived_total&lt;/span&gt; 的值高于一个给定值（硬编码为 25%）的时候，才会在第三代中进行一次全量回收。因为尽管对于非全量的回收（比如第一代和第二代中的回收）每次都会遍历差不多数量的对象（具体的大约数量由上面提到的阈值决定），但是对于一次全量回收的时间复杂度与长期存在的对象数量呈线性关系，而长期存在的对象数量是不可控的。实际上对于那些创建和保存很多长期存在的对象的程序，已经被证明如果每创建固定数量的对象就进行一次全量垃圾回收会导致性能的急剧下降（比如创建很多被垃圾收集器管理的对象并且都放进一个列表中，那么垃圾回收的时间复杂度不是线性的，而是 O(N²)。（译注：这里的时间复杂度不是上面说的一次垃圾回收的时间与分代中对象数量的关系，而是指在创建很多对象到列表中这种程序模式下，所有垃圾回收的总耗时与创建的对象数量的关系，详情见 &lt;span&gt;https://mail.python.org/pipermail/python-dev/2008-June/080579.html&lt;/span&gt;））。如果使用上面的比率，就会变成摊还之后的线性复杂度（这种做法可以总结为：尽管随着创建的对象越来越多全量垃圾回收会变得越来越慢，但是全量垃圾回收的次数也会变得越来越少）。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;优化：通过复用字段来节省内存&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了节省内存，支持垃圾回收的对象中的用于链表的两个指针也会被用作其他用途。这种常见的优化叫做胖指针或标记指针：在指针中存储额外的数据，能够这样做也是利用了内存寻址的特性。大多数架构会将数据的内存同数据的大小对齐，通常是一个字或多个字对齐。对齐之后就会使得指针的最低几位不会被使用，而这些低位就可以用作标记或存储其他信息 —— 通常作为位域（每一位都是一个独立的标记）—— 只要程序在使用指针寻址前屏蔽掉这些位域即可。例如在 32 位架构上，一个字大小是 32 位 4 字节，所以字对齐的地址都是 4 的倍数，也就是以 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;00&lt;/span&gt; 结尾，因此最低 2 位可以用作他用；类似的在 64 位结构上，一个字大小是 64 位 8 字节，字对齐的地址以 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;000&lt;/span&gt; 结尾，最低 3 位可以用来保存其他数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CPython 的垃圾收集器的实现就使用了&lt;strong&gt; 内存布局和对象结构&lt;/strong&gt; 中描述的 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;PyGC_Head&lt;/span&gt; 结构体中的两个胖指针：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;注意事项&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;因为胖指针或标记指针保存了其他数据，所以不能直接用来寻址，必须在清除这些其他数据之后才能得到真正的地址。尤其需要注意那些直接操作链表的函数，因为这些函数经常会假设链表中的指针状态一致。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;优化：延迟管理容器对象&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;有些容器对象不会产生循环引用，所以垃圾收集器没必要管理它们。解除对这些对象的管理会提高垃圾收集器的性能。但是判断一个对象是否可以解除管理也是有成本的，因此必须要权衡一下成本和由此给垃圾收集器带来的收益。有两个可能的时机可以解除对容器对象的管理：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;容器对象创建的时候&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;垃圾回收的时候&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;大的原则是原子类型不需要被垃圾收集器管理，非原子类型（容器、用户自定义对象等）需要。也有一些针对特定类型的优化避免垃圾收集器在垃圾回收时对一些简单对象做不必要的检查。下面是一些对内置类型延迟管理的例子：&lt;/section&gt;&lt;section&gt;垃圾回收模块提供了 Python 函数 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;is_tracked(obj)&lt;/span&gt; 返回对象当前是否被垃圾收集器管理。当然后续垃圾回收的时候可能会改变管理状态。&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_tracked&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_tracked&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_tracked&lt;/span&gt;&lt;span&gt;([])&lt;/span&gt;&lt;br/&gt;&lt;span&gt;True&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_tracked&lt;/span&gt;&lt;span&gt;({})&lt;/span&gt;&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_tracked&lt;/span&gt;&lt;span&gt;({&lt;/span&gt;&lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;})&lt;/span&gt;&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_tracked&lt;/span&gt;&lt;span&gt;({&lt;/span&gt;&lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[]})&lt;/span&gt;&lt;br/&gt;&lt;span&gt;True&lt;/span&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​&lt;/p&gt;&lt;p&gt;​&lt;/p&gt;&lt;p&gt;​&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2b851ce7f17771c3b30df405b53d8379</guid>
<title>还能这样玩？Go 将会增强 Go1 向前兼容性</title>
<link>https://toutiao.io/k/nz2juqx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;span&gt;新春快乐呀！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;年前我们在《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247497929&amp;amp;idx=1&amp;amp;sn=1f730d9812918edac5a959d34e932152&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;醒醒吧，未来不会有 Go2 了！&lt;/a&gt;》文章中讨论了 Go2 的未来，明确了未来是以 Go1.x.y 为主的 Go1 时代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现这个北极星目标，Go 团队采取的策略分别是：增强 Go1 向后兼容（在前文已分享）和 Go1 向前兼容（本文重点内容）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次要提到的 “向前兼容”，指的是&lt;strong&gt;旧版本的 Go 编译新的 Go 代码&lt;/strong&gt;。这个方向比较少被谈论，甚至特意设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我有种，还能这样搞的感觉？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go1 向前兼容&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 团队的大当家 Russ Cox，针对如下几个方面做了新设计和调整，输出了《&lt;span&gt;Proposal: Extended forwards compatibility in Go&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;》，已经得到讨论，很大概率落地，把版本号停留在 Go1.x.y。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将会涉及的部分重点如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新增 GOTOOLCHAIN 环境变量的设置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;改变在工作模块（work module）中解释 go 行的方式，增加了新的工具链（toolchain）行以此实现声明。此对应的是 go.mod 文件的 go 行和 &lt;span&gt;toolchain 行。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对 go get 等命令进行联动修改，允许对 GOTOOLCHAIN 和工作模块的 go 版本进行修改。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;增强工作模块的 go.mod 和 toolchain&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;声明 Go 版本号&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们会在 go module 生成时，在 Go 工程下生成一个 go.mod 文件。其中会包含一个 go 行，将会声明该模块应该应用的 go 版本语义是什么版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图，声明的是 go1.13：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4857916102841678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4h8ngBvgMWsicFibbwaibPia5jnVQ5ibHU5bdTPBqUKIpurlmxT3JQiccDGz9PxYwFQO9ELiaF7EicPUGbvoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1478&quot;/&gt;&lt;figcaption&gt;go.mod 文件中的 go 版本声明&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在该提案落地后，本地安装的 Go 工具链如果比 go 行所声明的 go 版本新时，它将会直接提供所要求的旧语义，而不会重新下载和调用一个旧版本的 Go 工具链。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果 go 行声明了一个较新的 Go 工具链，那么本地安装的 Go 工具链就会下载并运行较新的工具链来满足其需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是一个例子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在例子中，我们正在运行的版本是 go1.30。但在模块中，有一个 go.mod 声明了 go 版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go 1.30.1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go1.30 会下载并调用 go1.30.1 来完成命令，因为模块中要求的 go 版本比本地安装的更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果 go.mod 文件中声明的是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go 1.20rc1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go1.30 将自己提供 go1.20rc1 语义，而不是运行 go1.20 rc1 工具链。因为本地安装的版本更新，可以通过 GODEBUG 来满足旧语义的诉求。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;声明 Go 工具链版本号&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能会有同学想要运行更新版本的 Go 工具链，但 Go 语义上还是使用旧版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了满足这点诉求，go.mod 文件也会支持 toolchain 行的设置，以此来支持新版本的工具链的使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 go.mod 文件中设置了 toolchain 行，将指定使用的工具链版本，go 行只指定语言语义的 Go 版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go.mod 文件如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go 1.18&lt;br/&gt;toolchain go1.20rc1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作用是将为这个模块选择 go1.18 的语义，使用 go1.20rc1 的工具链来构建应用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;增强 Go 工具链 GOTOOLCHAIN&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将会在 Go 工具链新增 GOTOOLCHAIN 环境变量的设置和使用可以使用 &lt;code&gt;go env -w&lt;/code&gt; 设置。也可以在 go test 时做如下调整：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GOTOOLCHAIN=go1.17.2 go &lt;span&gt;test&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go build 编译时可以：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GOTOOLCHAIN=go1.18rc1 go build -o myprog.exe&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能会有同学疑惑 GOTOOLCHAIN 的默认值哪来，有哪些值？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;设置 &lt;code&gt;GOTOOLCHAIN=local&lt;/code&gt;：使用本地安装的 Go 工具链，不会下载不同版本的工具链。这是现在的的默认行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置 &lt;code&gt;GOTOOLCHAIN=auto&lt;/code&gt;：使用工作模块的 go.mod 中声明的 go 版本（当它比本地安装的 Go 工具链要新时）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GOTOOLCHAIN 环境变量的默认值取决于 Go 工具链。标准 Go 发行版默认为 &lt;code&gt;GOTOOLCHAIN=auto&lt;/code&gt;，也就是将控制权交给 go.mod 文件。这是在实施这个提案后 99% 会看到的默认行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 工具链的一揽子东西里也比较多，例如：go get 命令，也会对 go.mod 文件中的 go 版本或 toolchain 行进行变更，以配合使用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在今天这篇文章中，我们介绍了 Go1 兼容性增强中的 “向前兼容” 部分，其中要点是：加大对 go.mod 文件中的 go 行和 toolchain 行和工具链 GOTOOLCHAIN 相关的应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心目的是为了将 go 语法语义和 go 工具链的版本声明公开出来，达到隔离使用。再配合 “向后兼容” 中的 GODEBUG 的使用，让 Go 语言做兼容性时有更多更大的使用空间来实现机制上的保障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么一来，Go 语言在这一块会变得异常复杂，理解成本也会变高。希望大家后续在这块也不要再踩坑了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐阅读&lt;span/&gt;&lt;/h4&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Proposal: Extended forwards compatibility in Go: &lt;em&gt;https://go.googlesource.com/proposal/+/master/design/57001-gotoolchain.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注和加煎鱼微信，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一手消息和知识，拉你进技术交流群&lt;span&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9988738738738738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jVkzHVvaqjo3O0BIqDRJKkEyib7SJsryxHBFGsvek0FkdiczfJP6AdbWnK25DvlX3dY8wRObPbVJQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;888&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07106598984771574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/486RHs1WbcgGib6o96dHbvGUGGwPicd8wusUGH1cXR29tM4bO0lNzialzkQhvU6m5ZUdaKibmcF2OQayjMe9Bia6iaXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是煎鱼，&lt;span&gt;出版过 Go 畅销书《Go 语言编程之旅》，再到获得 GOP（Go 领域最有观点专家）荣誉，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247483854&amp;amp;idx=1&amp;amp;sn=ec422fbf4d846975f2930ddeb5e81373&amp;amp;chksm=f9041493ce739d85a4b987eece14da627206cdad798f645cc770868312e4a22b6df24804f186&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击蓝字查看我的出书之路&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点击蓝字查看我的出书之路&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日常分享高质量文章，输出 Go 面试、工作经验、架构设计，&lt;span&gt;加微信拉读者交流群，和大家交流！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e98060ce820620c1406afcabc30e6e7e</guid>
<title>vivo 超大规模消息中间件实践之路</title>
<link>https://toutiao.io/k/9ht0dms</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;作者：vivo 互联网存储技术团队-Luo Mingbo、中间件团队- Liu Runyun&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;本文根据“2022 vivo开发者大会&quot;现场演讲内容整理而成。公众号回复【2022 VDC】获取互联网技术分会场议题相关资料。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;本文主要介绍超大数据规模场景下分布式消息中间件在vivo的应用实践。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在线业务侧主要从RocketMQ集群部署架构、平台系统架构、日常运维操作平台、监控告警一体化实践以及vivo如何通过建设AMQP消息网关的方式完成所有在线业务服务从RabbitMQ到RocketMQ的业务无感迁移，实现了在线业务消息中间件组件的统一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大数据侧主要从资源隔离、流量均衡、智能动态限流、集群治理四个维度介绍Kafka在vivo的最佳实践以及Kafka核心技术架构在超大数据规模场景下的缺陷以及未来对Pulsar组件的长线规划和建设。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、分布式消息中间件在vivo的运营现状&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;1.1 技术选型&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH3qevgGib6aO0vVp7Uacesibpslt4IHKLeiccSKNqWRhcbE1I5guiaV59Vw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;88.58131487889274&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.49375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH2biaOO85WibCI9icRPYiaSyCSkWYuJ0bzDibz8jkOfbxjNEBBLVDjcQWwCw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在技术选型上，我们从吞吐量、功能特性、生态集成、开源活跃等多个维度对比了当前主流的分布式消息中间件，最终在线业务侧我们选择基于RocketMQ构建消息平台，依托RocketMQ丰富的功能特性满足业务间削峰、解耦、异步化的需求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大数据侧我们选择具备高并发、高可用、低延迟、高吞吐能力的分布式消息中间件Kafka。构建超大数据规模处理能力的统一数据接入服务和实时数仓服务。Kafka组件作为统一数据接入服务，是大数据全链路中的咽喉要道，是大数据生态体系建设中不可或缺的重要组件之一。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;1.2 规模现状&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;运营指标方面目前大数据业务侧Kafka集群接入项目数百、接入规模方面Topic数量达到数万、集群日均处理消息达数十万亿条、可用性保障99.99%、单机日均处理消息达数百亿条。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在线业务侧RocketMQ集群接入项目数百、接入规模方面接入数千服务、集群日均处理消息达数百亿条、可用性保障100%，发送平均耗时&amp;lt;1ms。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、大数据侧消息中间件最佳实践&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.1 Kafka简介&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHzWbyEKPGuD2wctSaVOPnnXAicAm4Ne2WKnL2yicgiaKkKriaVcadJdf3Rw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;117.37024221453288&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.47109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH1thZ7x7mOzJvms0B1y0N8SDXS5aQJIXvMZgCDqbiaX2uX2VB6bWm17A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先我们看下Kafka的官网定义及发展历史，Kafka是由Apache软件基金会开源的一个流处理平台，是一种高吞吐量的分布式发布订阅消息系统。具有高吞吐、低延迟、高并发、高可用、高可扩等特性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Kafka是由LinkedIn公司在2010年开源，2011年交由Apache软件基金会进行孵化，2012年成为Apache软件基金会的顶级开源项目。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.2 Kafka在超大数据规模场景下面临的挑战&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHIbCFmrhogoDZBLOPMzLNSnkGp3aM2TkfOTBcLpkl7HCLicUFibD0H8uw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;117.37024221453288&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.47109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH7CN4eRA93WVZdziaxiaIEREL9Bk3Yj2DG2yWj3DADiaVY2s4V3tOvrotA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;在超大数据规模场景下我们会面临以下几个问题？&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;如何规划资源隔离保证核心业务、高优业务、一般业务之间相互不受影响？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如何保证集群内部节点间流量均衡，降低单节点或部分节点流量差异太大带来的资源浪费？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;超大数据规模场景下如何进行限流保障集群的稳定性并尽可能降低对业务可用性的影响？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;集群长期运行，客户端版本多样，如何持续保障集群的高可用性？&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;下面我将从资源隔离、流量均衡、智能动态限流、集群治理四个维度和大家一起交流Kafka在vivo的最佳实践。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.3 资源隔离&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH9mrMGcib0VFwqAzn60vdMRcbyclzMB8uriaNfxflVD1J2tPch8fkowYw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;73.07958477508652&quot; data-cropy2=&quot;719.7231833910035&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.50546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHkWeWCWXNrKILfVWXwCe94qbOibMagVNnAJS4OKNibZaciaVMcH6b6wqlQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;资源隔离的核心作用在于避免业务与业务之间的相互影响，但隔离粒度、资源利用率、运维成本之间如何进行权衡，是我们需要思考的重点。隔离粒度太粗会导致隔离效果不佳，隔离粒度太细会导致资源利用率较低、运维成本增加。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;那vivo在Kafka集群资源隔离上是如何平衡三者关系的呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先我们根据业务属性、业务线两个维度进行集群维度的隔离，例如我们在集群划分上分为了商业化专用集群，监控专用集群，日志专用集群等。在集群维度做了机器资源的物理隔离。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时我们在集群内部引入了资源组的概念。同一个集群内部可以包含多个资源组。每个资源组可以为多个业务提供服务。资源组与资源组之间相互独立。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上图中右上图是我们没有引入资源组概念时集群内部不同业务Topic分区的分散情况，大家可以看到业务A和业务B的Topic分区分散到集群内的所有broker上，若业务A的流量突增可能会造成业务B受到影响，右下图是我们引入资源组概念后不同业务Topic分区的分散情况，可以看到不同业务的topic分区只会分配到自己业务所属的资源组内，即使业务A的流量突增导致机器不可用也不会对业务B造成影响。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;引入资源组概念后让我们能在集群内部实现机器资源的逻辑隔离。所以我们在资源隔离方面采用了物理隔离和逻辑隔离两种方式相结合，实现了在超大数据规模场景下Kafka集群的资源隔离方案。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;2.4 流量均衡&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHvHFs0zy3TCWySicC6eG2u4QTIoKsoIwW3xticI4lPEjbx0KhaTT478Rw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;126.22837370242216&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.4640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHK6tKv024R2mfy3JOxicqVLTuRKXXmbCibtkjCQc2ppC4DkYqzpDv3PzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;流量均衡的核心作用在于充分利用集群内部资源，提升资源利用率。Kafka服务作为一个有状态的服务，Kafka在技术架构设计上Topic分区与节点绑定，不支持分区同一副本数据在磁盘和节点维度分散存储。对分区的读写请求都由分区Leader所在节点进行处理。所以Kafka集群流量均衡的本质是Topic分区的分散均衡。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在流量均衡方面我们做两期的建设，第一期我们在分区分散均衡算法上引入机器的实时出入流量、cpu负载、磁盘存储等指标作为负载因子生成分区迁移计划。执行分区迁移后达到流量均衡的目的。流量均衡一期功能上线后我们将资源组内节点间流量差异从数百兆/s降低到数十兆/s。随着集群数据规模的持续增加，我们发现数十兆/s的流量差异依然会造成资源浪费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以在流量均衡二期功能建设上我们增加了分区分散均衡、Leader分散均衡、副本分散均衡、磁盘均衡等Kafka元数据指标作为负载因子生成Kafka分区迁移计划，并在分区迁移执行上增加了多种迁移提交策略。流量均衡二期功能上线后我们将资源组内节点间流量差异从数十兆/s降低到十兆以内/s。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHibPch87SBh98VhwfUcAs6Tibydth1QYsVTtL6dx8lHSS9NbA5ibG9QHRg/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;137.30103806228374&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.45546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHo47by9BOdkQ5M6fwYFDF5tPVslV3wD8zRYRBwD9ibgplHiaC8BFHDgjA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;上图是我们流量均衡一期功能上线前后资源组内节点的流量监控面板，可以看到一期功能上线前资源组内节点间的流量偏差在数百兆/s。一期功能上线后资源组内节点间流量偏差在数十兆/s以内，资源组内节点间流量偏差降低75%。极大提升了服务端的资源利用率。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHKt54iag59e1VhJ7lZ4tnNEsqiaj8499yl6bl91OVPzddqsZ67eTrYib9g/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;130.6574394463668&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.4609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHiaiclgqju5xydeyicic1I0KYJz8qCVGEl2y6zORVkpgGux5J53BsCX8uibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;上图是我们流量均衡二期功能上线前后资源组内节点的入出流量监控面板，可以看到节点间入出流量偏差从数十兆/s降低到&lt;span&gt;十兆以内/s&lt;/span&gt;，资源组内节点间流量偏差降低80%。效果也是非常明显。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.5 智能动态限流&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHfdaKeSs7yMv8QxiaIzVs7cGUTTlSmicgHF77Nw9nm495rw3WteP5ibFLA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;90.79584775086506&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.4921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH6BGdsA0eHtuIoMKLxpPI3euA03AX95U8zfseoZibvEFcX6B6BAp8kww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;限流的本质是限制客户端的流量突增以确保服务端的可用性。避免客户端的流量突增导致服务端整体不可用。限流的粒度，限流阈值的设定，资源利用率、服务端稳定性之间应该如何做权衡呢？是我们需要思考的重点。限流粒度太粗会导致限流效果不佳，当大部分业务同时流量突增会对服务端的稳定性带来风险。限流粒度太细服务端应对客服端流量突增能力不足，限流阈值设置太大会给服务端稳定性带来风险，限流阈值设置太小会导致服务端资源利用率较低。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;限流方面，&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;首先我们采用多平台联合诊断机制根据项目实际生产数据情况判别是否需要进行流量调整，计算调整后的限流阈值。其中多平台包含（JMX统一指标采集平台，统一监控平台、统一告警平台、Kafka集群管理平台等）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第二、智能分析Kafka集群服务资源负载情况，计算各资源剩余情况。确定是否可以进行阈值调整并结合客户端实际生产数据情况计算阈值调整到多少合适。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第三、自动实时调整限流阈值。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过以上三步实现智能动态限流方案。解决了限流粒度、限流阈值设定、资源利用率、Kafka集群可用性四者之间的平衡关系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实现智能动态限流后给我们带来以下几点明显的收益。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHfIZlJdUJMVggibOA2DNzib8I1tfXGjMxM0RbKbc1zdibCnK0JkNJc7Zkw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;121.79930795847751&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.46796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHBHsx6tBWpJmGmZzGBHFAjBeMW2yc0ydYPMERKXWztcQRjc8Yic4R0PQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;大大提升Kafka集群服务端应对客户端流量突增的能力。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;利用项目错峰的方式进一步提升Kafka集群的资源利用率。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;智能化自动调整项目限流阈值无需人工介入，大大降低Kafka集群在超大数据规模场景下的运维成本。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;动态根据服务端负载情况调整项目限流阈值，尽可能减小限流对业务可用性的影响。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.6 集群治理&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHviaDLG0sb5WkqUrfuvByfL8Td7QibjVWs8N6GG268xR1ISCuXHJEAHjQ/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;115.15570934256056&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.47265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH1ep0BOwYUiaN3TNXh821NR6ME98Yiazx9R3icq4KTXKGUjtKUB2qYjwnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Kafka集群元数据统一由ZooKeeper集群管理，元数据信息永久有效永不过期，元数据的下发由Kafka Controller节点统一下发，随着业务的不断发展，数据规模的不断增加，集群内部Topic的数量达到万级，分区数量达到数十万级。元数据治理能有效避免元数规模给Kafka集群稳定性带来的影响。随着接入的服务、Kafka用户越来越多，正确的使用Kafka 客户端也能大大提升Kafka服务端的稳定性和资源利用率。Kafka分区与磁盘目录绑定，创建Topic、Topic分区扩容时根据Topic流量合理设置Topic分区数能有效避免单机或单盘性能瓶颈成为集群整体的性能瓶颈。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;vivo在Kafka集群治理方面实现了节点流量偏差治理、Topic元数据治理、Topic分区数据倾斜治理、Topic超大分区治理、Topic消费延迟治理等方案为Kafka集群的高可用性保驾护航。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.7 实践经验沉淀&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5Qatchvh0x14rHGOU3aplzbnCc4njqvXAUl1I1ePIibFzWlof8zRTfs8cNKIrswfSRK5qS7LRSY5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;vivo Kafka消息中间件团队在三年时间内，根据实际的业务场景和生产数据规模沉淀了较多的实践经验。例如在高可用/高可扩方面实现了机架感知、弹性伸缩、数据压缩等能力建设，在监控告警方面提供了用户限流告警、Topic流量突增告警、消费延迟告警、Leader实时监控告警，多平台联合故障感知告警等能力建设。我们为Kafka集群做了很多的扩展能力建设，那解决了Kafka集群在超大数据规模场景下的所有问题了吗？答案是否定的。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;接下来我们一起看看Kafka集群在超大数据规模场景下面临的新挑战。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.8 Kafka在超大数据规模场景下由技术架构带来的缺陷&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH05sfNVrKmAV4VPcMP4FcsGd1QlfNEEkgh6Lps8sdVj8G0NQK5pOQZA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;139.51557093425606&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.45390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHqAicpFRYLD0GdZQPJQZMlUgVkbfRicFc0qks6zAtD591hX4cHkMFRic7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;由Kafka架构设计所带来的一些痛点无法通过扩展能力解决，并且Kafka架构设计上分区同一副本数据与磁盘强绑定不支持分散存储、不支持存储与运算分离、不支持冷热数据分层存储等设计缺陷在超大数据规模场景下显得尤为明显。所以在超大数据规模场景下Kafka集群面临了以下几个&lt;strong&gt;痛点&lt;/strong&gt;。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;资源利用率低。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;无法快速响应业务增长。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;故障恢复时间长。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;历史数据消费故障率高（主要体现在磁盘io性能上）。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.9 大数据侧分布式消息中间件未来规划&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;基于以上Kafka在架构设计上的缺陷，vivo Kafka团队于2021年开始对另一款开源分布式消息中间件Pulsar进行调研。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.9.1 Pulsar简介&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHF75VicjaynWBaprjBYUAk2GJytCZ304plvib8FibviccXX3GkAQOKMBVAg/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;117.37024221453288&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.47109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHTE7llUVk717m91e2JBt7k2C6XZdTuLFRkxY1ZRtYp0lAuThjIdgaQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们看下Pulsar的官网定义及发展史：Pulsar 是 Apache软件基金会的顶级开源项目，是集消息、存储、轻量化函数式计算为一体的下一代云原生分布式消息流组件，采用了计算与存储分离的架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有高并发、高吞吐、低延时、高可扩，高可用等特性。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Pulsar 诞生于2012 雅虎公司内部，2016年开源交由Apache软件基金会进行孵化，2018年成为Apache软件基金会顶级开源项目。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.9.2 Pulsar核心优势&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHE34NN9yWAoK9LDk9JVxKDRDa5LVyrjwOONtTonrKicibiaZNiaK34STgHw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;90.79584775086506&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.4921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHlmlmxPXLf1LmrOs7bYZ4qaMKMicEzy1p8NckArjPWXCZHMKFFoS2hXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;基于Pulsar支持存算分离，分区数据分散存储、冷热数据分层存储、Broker无状态等架构设计，让Pulsar在超大数据规模场景下具备了资源利用率较高、快速响应业务增长、秒级故障恢复、实时流量均衡、支持海量数据存储等明显优势。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.9.3 Pulsar未来规划&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH1CGibWrHgQxtElonEWwEB17dq5kTFOHZm6NjWn9CJWlf6SbIStKoxMg/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;95.2249134948097&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.48828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHNXMVj9S1dzzUYqhdyrb6j6h4icWvh1KuJPkUoa5eiciaFJROdmqlBfxYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们对Pulsar组件的规划分为四个阶段，包含项目启动、稳定性建设、能力进阶、稳定运营。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前我们处在Pulsar组件&lt;strong&gt;稳定性建设&lt;/strong&gt;阶段。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;2022年我们的目标是打造支持日均万亿级消息处理能力的Pulsar集群，完成分层存储，监控告警一体化、KoP功能平台化等扩展能力建设。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;计划2023年打造具备日均十万亿级消息处理能力的Pulsar集群，达到行业一流水准。并完成Pulsar broker容器化部署、Pulsar生态体系建设、Pulsar Sql和Pulsar Function的应用调研等扩展能力建设。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;将在2024年实现日均数十万亿级消息处理能力的Pulsar集群，达到行业超一流的水准。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、在线业务侧消息中间件最佳实践&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.1 RocketMQ简介&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH3IlQE2MVSdgVD5FXncd0J3aBPesiarnOvja691q0xoIPG03iaCPjZhUw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;106.29757785467129&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.4796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHkAQfqdxDtbfl2X9PbyhSFOWOjRRSh40SJd0um1RUJw5X6y8ww7gqjg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;RocketMQ是阿里巴巴于2012年开源的低延时、高并发、高可用、高可靠的分布式消息中间件，具有海量消息堆积、高吞吐、可靠重试等特性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;RocketMQ于2012年开源，2016年进入Apache孵化，于2017年成为Apache顶级项目。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.2 RocketMQ在vivo内部使用现状&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHrUe5yPEmhG6UA5sMoLpklRicG2skagpb5ju4Mat0qT5693qic6K0aL0g/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;101.86851211072666&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.48359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH6YRbyohWdNicesa2ssmhUFBpDHnLG6mOrSzuTGM0ux3dd2Y8mgibrkug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;vivo中间件团队在2021年引入RocketMQ并且完成了高可用和平台化建设。&lt;/p&gt;&lt;p&gt;当前分别在多个机房部署了多个集群供业务使用，每日消息量数百亿。&lt;/p&gt;&lt;p&gt;集群分布在多个机房，每日消息量级也不低，高可用运维保障是有难度的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.3 vivo基于RocketMQ的高可用保障实践经验&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;3.3.1 集群部署架构介绍&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHtwVD06AnLXADVicu8NkHXLQpQ5LLLye2MyiaHvAlLp05WFiajXKxkEYcQ/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;106.29757785467129&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.4796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHYedKj7z6SbV94pTwlvueQlysp835UzjVSy2iaCia0Pdr55Pvky4KswcA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了更好的保障集群的高可用，我们采用了双机房热备的方式进行集群搭建。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们会在两个机房进行Broker的部署，业务Topic会默认分布在两个机房，以此来保障在一个机房内的Broker节点异常时业务可以保持正常生产消费能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;业务默认是会优先使用本机房的节点进行生产消费，只有在异常时才会自动快速完成跨机房的流量切换。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时我们构建了一个BrokerController模块用于实现Broker节点的主从切换，以此保障集群容量的快速恢复。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;双机房热备模式有哪些优势呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;双机房热备模式的劣势是每个机房的节点都需要冗余一定的buffer来支撑其它机房的节点异常时自动转移过来的业务流量。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;3.3.2 平台系统架构介绍&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHMqiaKVMCXDSSBwMGOxGVcVSicqZh5jvST8FvYr122rW8JrZkHYo4EXhg/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;95.2249134948097&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.48828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHETwZnHonLZU3rGBvuiaKSZyfiaS83k0GNZQANPib9ibvEibCeCH75JP6xwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;集群双机房热备部署模式是消息平台的高可用基石，在此之外我们还建设了多个平台模块来保障平台的高可靠。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如上图所示，&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;mq-rebalance模块用于支撑集群流量的自动负载均衡；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;mq-monitor模块进行监控指标的采集并且与vivo内部的监控系统打通；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;mq-recover模块主要用于业务流量的降级和恢复处理；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;mq-live模块用于集群的探活。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外我们还基于社区的connector组件建设了RabbitMQ-connector，实现了全球消息路由能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后续我们计划建设基于gRPC协议建设通用的消息网关实现与集群的交互，以此屏蔽不同的消息中间件选型。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;3.3.3 运维能力平台化提升运维效率&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH6MHnPD0xQb2LvSn6Psu6se18C7Ig5ia3E3Oe36hPkACqicoOGriaPTfaA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;90.79584775086506&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.4921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHdKzDtRmlnBL2Q0SrmwZSQkd5ibzku0T7VEKxSibXwPwyO3boeIUCFdEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主要有三点实践：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一，&lt;/strong&gt;RocketMQ集群配置平台化管理。RocketMQ集群含有较多的配置项，默认是通过节点文件管理的，在大规模集群运维过程中会存在维护困难的问题。&lt;/p&gt;&lt;p&gt;通过平台化管理可以确保集群内配置统一，节点在启动时从平台中读取到所有的配置，避免在集群部署时需要登录到机器进行配置维护，并且我们支持了集群配置的动态生效。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二，&lt;/strong&gt;运维操作平台化，例如Broker节点的流量摘除与挂载、Topic一键扩缩容等直接通过平台支撑，实现便捷运维。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第三，&lt;/strong&gt;集群维护平台化，我们将集群与Broker节点的关系维护在平台中，并且在首次部署时分配Broker节点所在集群，这样在平台上就有清晰的集群信息，便于我们维护管理多套集群。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;3.3.4 平台监控告警能力建设&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHGJ6iatEZIFylkZI70EZCTYGPibQOC1eQO4TibOHZ2cX865Kic8GXib6oa7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHuibf9E8hLD1GycGBuDp9KnQtkKzUA3vxmvBToqZu2j37nGmlPbQJTDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.562962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;一方面，&lt;/strong&gt;我们为每个集群都建设了如上图所示的监控大盘。&lt;/p&gt;&lt;p&gt;在监控大盘中有每个集群的生产消费流量、业务生产消费统计、发送耗时等信息，支撑我们快速观察集群的运行状态，方便日常巡检。&lt;/p&gt;&lt;p&gt;消息中间件作为在线业务请求处理链路中的关键环节，高可用尤为关键。监控大盘中的发送耗时信息是我们认为观察集群是否稳定运行的最关键的指标。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;另一方面，&lt;/strong&gt;我们对集群构建了丰富的监控告警能力。&lt;/p&gt;&lt;p&gt;如上图所示，我们分别对主机维度、集群维度、Topic/Group维度、客户端维度都做了监控指标埋点上报。&lt;/p&gt;&lt;p&gt;通过丰富的监控告警，我们可以及时发现问题并快速介入处理问题，详细的监控告警也可以帮助我们快速确认问题根源。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.4 业务从RabbitMQ无感迁移到RocketMQ实战经验&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;3.4.1 使用RocketMQ替换RabbitMQ根因分析&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHZtW5cpkXtrjjLM83990BuDOiarmUWZuYZuia4p76N6mtPpqwR7d86FtA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;88.58131487889274&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.49375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHzvC0ncmDopzdtooDazOdcZmpCCrEeIVApEoyd36Yd4WRLxgTJNaJxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;分别从&lt;strong&gt;可用性保障&lt;/strong&gt;、&lt;strong&gt;性能&lt;/strong&gt;、&lt;strong&gt;容量&lt;/strong&gt;、&lt;strong&gt;功能特性&lt;/strong&gt;对比RabbitMQ和RocketMQ。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可用性保障方面，&lt;/strong&gt;RabbitMQ集群无负载均衡能力，队列流量实际由集群内某个节点承载，存在瓶颈。其次RabbitMQ存在脑裂问题，从我们的运维经验看如果出现网络故障集群通常无法自动恢复，并且可能丢失少量数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;性能方面，&lt;/strong&gt;RabbitMQ集群整体性能较低，并且不支持水平扩展。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;容量方面，&lt;/strong&gt;从我们的运维经验看，当消息堆积到千万后，RabbitMQ性能就会有所下降。在大量消息堆积开始消费后，因为RabbitMQ的背压流控机制，最终可能会因为集群负载过大导致发送限流甚至发送阻塞。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;功能特性方面，&lt;/strong&gt;RabbitMQ不支持消费异常延时重投递功能，也不支持消息轨迹、事务消息、顺序消息等特性。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;而RocketMQ在可用性保障、性能、容量、功能特性方面相对于RabbitMQ都是更优的。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可用性保障方面，&lt;/strong&gt;RocketMQ采用多主多从的松耦合架构部署，主从间通过同步双写保障消息的可靠性和一致性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;性能方面，&lt;/strong&gt;Topic可以分布在多个Broker中，实现水平扩容，并且RocketMQ支持从从节点拉取消息，读写分离的设计很好的支持了业务读取冷数据的诉求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;容量方面，&lt;/strong&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;span&gt;使用磁盘存储，磁盘容量就是消息的存储容量，利用从从节点拉取冷数据特性，海量消息堆积对消息写入性能基本无影响。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;功能特性方面，&lt;/strong&gt;RocketMQ支持了消息轨迹、事务消息、顺序消息等特性。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;综合分析，RocketMQ可以更好的支撑互联网业务的诉求。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;3.4.2 AMQP消息网关架构支撑实现无感迁移&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHkAkibTdVQLN6ecJXpRZVcTe7JSOk2aAcib03tVU7niaBaMFLzicOe6SV2Q/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;88.58131487889274&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.49375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHa78414Vp5jwORo5P59BvJSSlZtDh5vsYOCknoGNXxj9mYFHLxNClOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于当前RabbitMQ已经有数千个服务接入，为了让业务不修改代码即可迁移到RocketMQ，我们建设了一个AMQP消息网关来实现MQ协议的解析和流量转发。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如上图所示，MQ-Proxy模块用于解析AMQP协议，代理客户端的生产消费请求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;RabbitMQ的元数据信息存在在集群中，并且与RocketMQ元数据概念存在差异，为此我们建设了MQ-Meta模块用于维护Exchange/Queue极其绑定关系等元数据信息，并且Proxy模块可以动态感知元数据变更。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外，为了更好的支撑业务诉求，我们对AMQP协议进行了扩展，支持了局部有序和批量消费能力。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;3.4.3 RabbitMQ和RocketMQ元数据概念映射&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH3MLHzpzIiaBibcsHKvJ2gBibvQOicAibuCOXwcWvheCFTgfIyB3Q7w84MsA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;86.36678200692042&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.4953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHSibNJ56jMEbicaDMIKWW2k93KRn8DnkMUK6O3iaP1Gia6OuAsSbZPnHjFQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了更好的整合RabbitMQ和RocketMQ，我们对它们的元数据进行了一一对应。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中将RabbitMQ的Exchange映射为RocketMQ的Topic，Queue映射为Group，RoutingKey映射为消息头的一个参数，VirtualHost映射为Namespace。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为什么将RoutingKey映射为消息头的一个参数而不是Tag呢？这是因为RabbitMQ的RoutingKey是有模糊匹配过滤能力的，而RocketMQ的Tag是不支持模糊匹配的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外我们还通过扩展使得RocketMQ也支持了RoutingKey过滤。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在经过多轮优化后，在1KB消息体场景下，一台8C16G的机器在单发送下可支撑超过九万的TPS，单推送可以支撑超过六万TPS，性能上很好的满足了当前业务的诉求。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.5 在线业务消息中间件的未来规划&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPHSA3wnPV9LUibiaBxKeDUNvib6ud9KciaKOx9kX9vzeW8iavrz2DL5cdrNvw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;101.86851211072666&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.48359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5tOIlStYWkmALxhMvuQibPH98Cv6etyzDh3aicU1iaFgHcKeBkeCPQBicmXLlC0mT3tenDviceCXVuNiaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主要有两部分：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一方面，&lt;/strong&gt;我们希望可以调研升级到RocketMQ5.0版本架构，RocketMQ5.0的存算分离架构可以更好的解决我们当前遇到的存储瓶颈问题，Pop消费可以帮助我们实现更好的消费负载均衡。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们还希望可以基于gRPC协议建设统一的消息网关能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;另一方面，&lt;/strong&gt;我们希望可以探索消息中间件容器化部署，提供消息中间件的快速弹性扩缩容能力，更好的支持业务需求。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;回顾vivo消息中间件演进历史，我们完成了在线业务消息中间件从RabbitMQ迁移到RocketMQ，大数据消息中间件正在从kafka演进为使用pulsar支撑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们理解消息中间件将继续朝着云原生演进，满足业务快速增长的诉求，充分利用云的优势为业务提供极致的体验。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:138.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dd479c4bf8e09a11d80f2cc5de13d488</guid>
<title>从 lsof 开始，深入理解 Linux 虚拟文件系统</title>
<link>https://toutiao.io/k/qn8nc71</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;点击上方 &lt;/span&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;java那些事 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，选择 &lt;/span&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;星标 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;公众号&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h4&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;pre&gt;&lt;pre&gt;&lt;pre&gt;&lt;pre&gt;&lt;pre&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;h2&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;有时会出现这样的情况，磁盘空间显示已经被占满，但是在查看磁盘的具体文件占用情况时，发现磁盘仍然有很大的空余空间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.执行&lt;/span&gt;&lt;code&gt;&lt;span&gt;df&lt;/span&gt;&lt;/code&gt;&lt;span&gt;命令查看磁盘使用情况，发现磁盘已经满了。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-bash-4.2$ df -Th&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Filesystem     Type      Size  Used Avail Use% Mounted on&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/dev/vda1      ext4       30G    30G 0      100% /&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;devtmpfs       devtmpfs  489M     0  489M   0% /dev&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tmpfs          tmpfs     497M     0  497M   0% /dev/shm&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tmpfs          tmpfs     497M   50M  447M  11% /run&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tmpfs          tmpfs     497M     0  497M   0% /sys/fs/cgroup&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;2.执行 du 命令查看各个目录的磁盘占用情况，把各个目录文件的大小相加，发现并没有占满磁盘，有10多G空间莫名失踪。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;diff&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-bash-4.2$ du -h --max-depth=1 /home16M /home/logs11G /home/serverdog11G /home&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;3.为何会出现这样的情况呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为虽然文件已被删除，但是一些进程仍然打开这些文件，因此其占用的磁盘空间并没有被释放。执行&lt;/span&gt;&lt;code&gt;&lt;span&gt;lsof&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 命令显示打开已删除的文件。将有问题的进程重启（或，清空），磁盘空间就会得到释放。&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-bash-4.2# lsof | grep deletemysqld     2470         mysql    4u      REG              253,1           0     523577 /var/tmp/ibfTeQFn (deleted)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mysqld     2470         mysql    5u      REG              253,1           0     523579 /var/tmp/ibaHcIdW (deleted)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mysqld     2470         mysql    6u      REG              253,1           0     523581 /var/tmp/ibLjiALu (deleted)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mysqld     2470         mysql    7u      REG              253,1           0     523585 /var/tmp/ibCFnzTB (deleted)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mysqld     2470         mysql   11u      REG              253,1           0     523587 /var/tmp/ibCjuqva (deleted)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;那么，Linux 的文件系统，到底为什么这么设计呢？要了解这些，就要先弄清楚并不容易，下面将从一些基本概念入手，一步步将这些梳理清楚：&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;虚拟文件系统（virtual filesystem）&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;下图显示了 Linux 操作系统中负责文件管理的基本组件。上半区域为用户模式，下半区域为内核模式。应用程序使用标准库libc来访问文件，库将请求映射到系统调用，以便进入内核模式。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32783505154639175&quot; data-type=&quot;png&quot; data-w=&quot;485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yNKv1P4Q9eWKLBUHUbRzPSyMdRYJUIdYHhTlz9BuncOhOVuXNh9QCtPWBWnVz6LlQrFknArcVnopZkAMXuaZYA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;所有与文件相关的操作的入口都是虚拟文件系统（VFS），而非特定的额文件系统（如Ext3、ReiserFS和NFS）。VFS 提供了系统库和特定文件系统之间的接口。因此，VFS 不仅充当抽象层，而且实际上它提供了一个文件系统的基本实现，可以由不同的实现来使用和扩展。因此，要了解文件系统是如何工作的，就要先了解VFS 。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;通用文件模型&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;VFS 的主要思想在于引入了一个通用文件模型（common file model）。通用文件模型由以下对象类型组成：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;超级块对象（superblock object）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;内存：文件系统安装时创建，存放文件系统的有关信息&lt;br/&gt;磁盘：对应于存放在磁盘上的文件系统控制块（filesystem control block）&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;索引节点对象（inode object）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;内存：访问时创建，存放关于具体文件的一般信息（&lt;code&gt;inode 结构&lt;/code&gt;）&lt;br/&gt;磁盘：对应于存放在磁盘上的文件控制块（file control block）&lt;br/&gt;每个索引节点对象都有一个索引节点号，唯一地标识文件系统的文件&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;文件对象（file object）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;内存：打开文件时创建，存放 打开文件 与进程之间进行交互的有关信息（&lt;code&gt;file 结构&lt;/code&gt;）&lt;br/&gt;打开文件信息，仅当进程访问文件期间存在于内核内存中。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;目录项对象（dentry object）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;内存：目录项一旦被读入内存，VFS就会将其转换成&lt;code&gt;dentry 结构&lt;/code&gt;的目录项对象&lt;br/&gt;磁盘：特定文件系统以特定的方式存储在磁盘上&lt;br/&gt;存放目录项（即，文件名称）与对应文件进行链接的有关信息&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;目录树&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;综合来说，Linux 的 根文件系统(system’s root filessystem) 是内核启动mount的第一个文件系统。内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后，从中把一些基本的初始化脚本和服务等加载到内存中去运行（文件系统和内核是完全独立的两个部分）。其他文件系统，则后续通过脚本或命令作为子文件系统安装在已安装文件系统的目录上，最终形成整个目录树。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;start_kernel &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　vfs_caches_init &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　　　mnt_init &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　　　　　init_rootfs     // 注册rootfs文件系统&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　　　　　init_mount_tree // 挂载rootfs文件系统 &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　… &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　rest_init &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　kernel_thread(kernel_init, NULL, CLONE_FS);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;就单个文件系统而言，在文件系统安装时，创建超级块对象；沿树查找文件时，总是首先从初识目录的中查找匹配的目录项，以便获取相应的索引节点，然后读取索引节点的目录文件，转化为dentry对象，再检查匹配的目录项，反复执行以上过程，直至找到对应的文件的索引节点，并创建索引节点对象。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;软链接 vs 硬链接&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;软链接是一个普通的文件，其中存放的是另外一个文件的路径名。硬链接则指向同一个索引节点，硬链接数记录在索引节点对象的 i_nlink 字段。当&lt;/span&gt;&lt;code&gt;&lt;span&gt;i_nlink&lt;/span&gt;&lt;/code&gt;&lt;span&gt;字段为零时，说明没有硬链接指向该文件。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;文件 &amp;amp; 进程管理&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;下图是一个简单示例，说明进程是怎样与文件进行交互。三个不同进程打开同一个文件，每个进程都有自己的文件对象，其中两个进程使用同一个硬链接（每个硬链接对应一个目录对象），两个目录项对象都指向同一个 索引节点对象。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5849056603773585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yNKv1P4Q9eWKLBUHUbRzPSyMdRYJUIdY69gween04UvFIdicicZ0sVCHFU2DYvRKqmVVTzfGK8V55jxpGRl5lbSA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;索引节点的数据又由两部分组成：内存数据和磁盘数据。Linux 使用 Write back 作为索引节点的数据一致性策略。对于索引节点的数据，当文件被打开时，才会加载索引节点到内存；当不再被进程使用，则从内存踢出；如果中间有更新，则需要把数据写回磁盘。&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;*  &quot;in_use&quot; - valid inode, i_count &amp;gt; 0, i_nlink &amp;gt; 0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;*  &quot;dirty&quot;  - as &quot;in_use&quot; but also dirty&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;*  &quot;unused&quot; - valid inode, i_count = 0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;索引节点是否仍在使用，是通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;open()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;close()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 操作建立和销毁文件对象，文件对象通过索引节点提供的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;iget&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;iput&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  更新索引节点的i_count字段，以完成使用计数。open 操作使得 i_count 加一， close 操作使得 i_count 减一。在 close 操作时判断索引节点是否释放，如果 i_count = 0，则意味着不再有进程引用，将会从内存释放。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;文件 &amp;amp; 磁盘管理&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;文件与磁盘管理联系最紧密的操作，莫过于&lt;/span&gt;&lt;code&gt;&lt;span&gt;touch&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;rm&lt;/span&gt;&lt;/code&gt;&lt;span&gt;操作，而尤以后者最为关键。通过strace(或 dtruss)，查看 rm 的实际的系统调用&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# dtruss rm tmp&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;geteuid(0x0, 0x0, 0x0)       = 0 0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ioctl(0x0, 0x4004667A, 0x7FFEE06F09C4)       = 0 0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;lstat64(&quot;tmp\0&quot;, 0x7FFEE06F0968, 0x0)        = 0 0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;access(&quot;tmp\0&quot;, 0x2, 0x0)        = 0 0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;unlink(&quot;tmp\0&quot;, 0x0, 0x0)        = 0 0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;可以发现 rm 实际是通过 unlink 完成的。unlink代表删除目录项，以及减少其索引节点的计数。由通用文件模型可知，父目录本身同样是一个文件，也就意味着目录项是其文件数据的一部分。删除目录项等价于从父目录的文件中删除数据，也就意味着首先要打开父目录的文件。那么，删除操作即可理解为：&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;删除命令（一个进程）使用 open 操作获得父目录文件对象&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;iget&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 增加 目录文件的索引节点对象计数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;读取目录文件数据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;删除目录的目录项&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;减少文件索引节点对象的硬链接计数i_nlink&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;iput&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 结束对文件索引节点对象的操作，使用计数 i_count 减一&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 iput 结束对目录索引节点对象的操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;回头来看遇到的问题，其实可以从两个角度来理解：&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;索引与数据&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;文件系统与文件、磁盘管理与文件、进程管理与文件，最核心的都是文件的索引，而不是文件的数据。把数据和索引分开是理解文件系统的关键。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7886178861788617&quot; data-type=&quot;png&quot; data-w=&quot;369&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yNKv1P4Q9eWKLBUHUbRzPSyMdRYJUIdYK7fdZj3alR3qQ4lKdibRL2Psuicc3I6RvxTzrzxribFvq3xz2NRYn1qUQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;缓存策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;由于操作系统使用 Write back 的策略，意味着只有先释放内存，才有可能释放磁盘。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Why lsof ?&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;从上面的模型可以很清楚的理解，因为目录已经没有索引到文件了，但是打开文件还有索引到文件，所以不能立刻释放磁盘空间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为什么 lsof 可以找到已删除未释放的文件呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;lsof，顾名思义：list open files，该命令的原理就是查找打开文件的列表，因此可以找到已删除未释放的文件。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by wxb-style.com&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by wxb-style.com&quot;&gt;&lt;section label=&quot;Powered by bj.96weixin.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; data-width=&quot;100%&quot;&gt;&lt;text y=&quot;20&quot; x=&quot;470.02&quot; fill=&quot;rgb(255,255,255)&quot;&gt;收外国男人的钱，骗中国妹子的炮？天朝竟有这样一帮「女权组织」 2018-03-19 INSIGHT视界 From 酷玩实验室 微信号：coollabs 其实我读书的时候 也曾经想过做一个女权主义者 但是后来发生了一些事情 让我选择了放弃 简单来说是这么一个事情：我发现 女权对于一些中国人来说是信仰 但是对另一些中国人来说是生意 所谓的“伪女权”“女权癌” 大概就是这么回事 尽管早就有这样的思想准备 但让我没想到的是 这两天，知乎上曝光了一件大事 还是让我三观震碎 我没想到，这些“伪女权” 竟然已经形成了黑色产业链 让人细思恐极—— 国内竟然有一群人 打着“女权主义”的名号 从事着组织卖淫的事情 在中国女生不知情的情况下 把她们卖给外国男人！事情是这样的：根据知乎用户伊利丹·怒风的爆料 他在知乎和一个伪女权主义者 吵了起来 一开始，他可能以为这只是一个 脑子比较轴的伪女权主义者 所以两人就吵了一通 本来，他以为就是撕个逼而已 没想到的是 这个伪女权主义者 可不是什么好惹的主 这个自称为“玛丽女王”的人 竟然在半个月中 持续不断地骚扰他 而最夸张的是 玛丽女王声称 自己有能力 让伊利丹的QQ号 在5天之内被封掉 到这里为止 伊利丹一直以为 他不过是碰到了一个杠精 但是万万没想到 5天之后 他的QQ号竟然真的被永久封禁了！说真的，这就有点吓人了 这个不起眼的玛丽女王 竟然还能操控别人的QQ账号被封？难不成，她真的背后有人？伊利丹这才意识到 自己好像惹到了一个组织 他去扒了扒这个玛丽女王的QQ空间 这才发现 自己简直捅出一个马蜂窝：这个人平时干的 竟然是把中国女生 卖给外国男人的皮肉生意！真的，我本来以为 我是一个见过不少套路的人 但没想到 这一套操作 真的是惊为天人 简单来说是这样的 首先，玛丽女王自称是“女权主义者” 但是实际上她的言论 宣传的却是 中国男人配不上中国女人 她甚至恶意辱骂中国男人 恨不得中国男人全部死光 连自己的爸爸都不放过 但是，这么做对她有什么好处呢？很简单 骂完中国男人以后 接下来她就说—— 既然中国男人这么差劲 那就找外国男人吧！于是，她就经常发布外国男人的介绍 看起来是一个热心的媒婆 还在各种QQ和微信群里 散播此类信息 但是看到这里 我们不难发现有点问题 看看其中这些不堪入目的措辞 这并不是普通的介绍男友啊！这简直是在拉皮条啊！果然，伊利丹发现 玛丽女王真的在 拉皮条的过程中 收外国男人的钱！下面是聊天记录实锤：而且，请注意—— 在这个过程中 她会收外国男人的钱 但是钱不给中国女生 却落到了她自己的腰包 于是一个诡异的情况出现了：中国妹子 并不知道收钱这回事 还以为是正常交友 而外国男人 却都交了钱 很可能认为自己是在买春！额，也就是说 在中国女孩不知情的情况下 她们被“卖”给了外国男人 而好处费 却全都进了玛丽女王的腰包... 我真的是没见过这种操作 这说轻了是骗炮 说重了，已经可以算是卖淫了吧？我想请熟悉刑法的朋友们看看 这个玛丽女王 至少应该算是个 介绍组织卖淫罪吧？而且，从伊利丹曝光的资料看来 这个组织规模不小 玛丽女王甚至把外国男生的信息 建了一个完整的表格 有详细的个人资料、照片 可以说 是一条非常完整的产业链 那如果按照这样操作 外国男人都是来嫖的 中国女生却不知道 还以为是要跟他们谈恋爱 那双方难道不会穿帮吗？恩，在这方面 玛丽女王早有对策 根据知乎一位 从事过这个产业的匿名用户提供的信息 针对这种情况 玛丽女王们 还会手把手地教外国男人 怎么快速摆脱女生的纠缠 怎么调教中国女生 怎么让女生觉得自己很可爱 可以说 各种套路一应俱全 甚至还可以开发票！看到这里 她们背后的产业就非常清楚了 这个玛丽女王 她根本就不是什么女权主义者 而是打着女权主义的口号 贩卖中国女生的人贩子 一方面 她们通过辱骂中国男人 吸引对外国男人感兴趣的中国女生 另一方面 她们向外国男人收钱 然后把中国女生卖给他们！图片来源：知乎@渭水徐工 而可怜的中国妹子们 还以为自己是在 追求男女平权 其实，不过是沦为了 这些老鸨的赚钱工具 伊利丹把这整个事情 写出来以后 在知乎、微博引起了巨大的关注 关于其中提到的 伊利丹的QQ被永久封禁的问题 腾讯经过核查 目前也有了结果：经调查，是玛丽女王利用伪造证据 恶意举报了伊利丹的QQ号 目前，腾讯已经将伊利丹的QQ解封 同时封禁了玛丽女王等人的 两个QQ账号 警方也就此事立案侦查了 相信很快就会有结果 这个事情算是告一段落了 但是在我看来 却有一件事让我无法释怀：为什么“女权主义”竟然会和 辱骂中国男性等同起来？为什么“和外国男人交友” 竟然还能演变成 一个免费的陪睡组织？我想，这个玛丽女王 也许只是一个 发现了恶性赚钱模式的生意人 但是在这背后隐藏的 其实是一个很深的问题：为什么有不少中国女人 越来越看不上中国男人 甚至觉得嫁给外国男人 是一种时尚？这里面的原因可能非常复杂 我这里先提供一个思路 供大家讨论：我发现 现在中国很多大型的女权组织 背后都有着西方势力的影子 她们打着女权的名号 为自己谋取暴利 为西方国家从事破坏活动 而那些真正为女性平权而奔走的人 却得不到应有的帮助 我之所以这样说 并不是信口开河 而是有充足的证据 有一个非常有名的民间女权组织 叫做“女权之声” 它一再声称 自己只是一个自发的民间组织 致力于促进男女平等的 它所有的微博账号、微信账号 全部都是由一个 叫做妇女传媒监测网络的创办的 而这个妇女传媒监测网络 有这么多媒体产品 那它的钱都是哪里来的呢？从她们介绍的合作组织里 我们可以清楚地找到 她们的资助者—— 竟然有西方的福特基金会 有人也许会问 收了西方的钱怎么了？中国的组织不能收西方的钱吗？然而，她们不只是收了西方的钱而已 女权之声组织里 有一个人叫做郑楚然 她除了女权运动之外 没有任何其他工作 表面上，是一个全职的女权工作者 在2015年的时候 她还因为寻衅滋事 被警察拘留过30多天 甚至在她被拘留的时候 希拉里还借题发挥 指责中国侵犯人权、压制民主 一个中国的小小民间组织的首领 在互联网上的粉丝还没有我多 竟然能得到希拉里这个级别的关注？我真的是惊掉了下巴 这样看来 我离希拉里也不是很远了？？而不止是希拉里 这样一个明明思想上毫无建树的人 却被西方媒体BBC评为了 全球百大思想家 图：郑楚然在王宝强事件中发表的言论 除此以外 更让人匪夷所思的 是她们平时就喜欢攻击政府 甚至于，她们还会试图分裂我们国家 比如，女权之声这个组织里 著名的女权斗士洪理达 就曾经转发著名的港独媒体 Hong Kong Free Press的言论 甚至曾公开发表过 支持藏独、港独、台独的言论 她也经常和郑楚然混在一起 我很想不通 如果她们真的只是单纯的女权主义者 为何要发表分裂国家的言论？为何要支持藏独、港独、台独？我只能说，这大概就叫 拿人家的手短，吃人家的嘴软吧 以前，我在接触中国的女权组织时 我就觉得很奇怪 她们都喜欢声称 自己是不盈利的非政府组织 但是她们无论是宣传 还是组织各类活动 都需要大量的钱 如果她们真的不盈利 那这些钱都是哪里来的呢？而这些外国的金主 他们也更加不可能是什么慈善组织 大发善心来给中国人投钱 每一分投出去的钱 一定都是要有回报的 那么，他们的回报是什么呢？他们给中国的“女权组织”投钱 能得到什么利益呢？联想到中国网络上 如火如荼的对中国男人的讨伐 我只能说，细思恐极 我绝不是危言耸听 因为我们就看不远的邻国日本 近些年来日本对于西方的崇拜 可谓深入骨髓 已经到了崇洋媚外的程度 而这其中 当然也包括对白人男性的崇拜 甚至在2016年一个瑞士白人 发了一个视频，赤裸裸的说 “在东京，只要你是白人， 做什么都可以” 视频里面他在日本便利店 随意的亲吻不认识的收银员女孩 在酒吧把不认识的日本女孩 按向自己的裤裆 而日本女孩回应的却是谄媚的笑容 我想，并不会有那么多中国人 真正被西方伪女权主义控制 但是，我们要警惕的是 别在你自己都没有察觉的时候 被别有用心的人洗了脑 更有甚者 别在你自己都不知道的情况下 被别人卖给了外国男人 还去帮他数钱 本文系授权发布，From 酷玩实验室，微信号：coollabs，欢迎分享到朋友圈，未经许可不得转载，INSIGHT视界 诚意推荐 Forwarded from Official Account 酷玩实验室 酷玩实验室 Learn More Scan QR Code via WeChat to follow Official Account 采集文章采集样式近似文章查&lt;/text&gt;&lt;/svg&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;更多精彩内容，&lt;strong&gt;关注我们&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;▼▼&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable js_wx_tap_highlight&quot; data-id=&quot;MjM5MTM0NjQ2MQ==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/jNmCBexQlC5YGTbia3dRd6YFXWAlPsJK3gZQap6oK8Vk7BLiaBbsvq3BwicyEKwJiaIfeAYXzucAvXP00PKQKVLzJQ/0?wx_fmt=png&quot; data-nickname=&quot;java那些事&quot; data-alias=&quot;csh624366188&quot; data-signature=&quot;分享java开发中常用的技术，分享软件开发中各种新技术的应用方法。每天推送java技术相关或者互联网相关文章。关注“java那些事”，让自己做一个潮流的java技术人！《java程序员由笨鸟到菜鸟》系列文章火热更新中。&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot; has-insert-preloading=&quot;1&quot; data-index=&quot;0&quot; data-origin_num=&quot;0&quot; data-isban=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果看到这里，说明你喜欢这篇文章，&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;标星（置顶）&lt;/span&gt;&lt;span&gt;本公众号可以第一时间接受到博文推送。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt; “分享、点赞&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;在看” 支持一波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lolOWBY1tkwzw3lDgVHOcuEv7IVq2gCXN5rPlfruYGicNRAP8M5fbZZk7VHjtM8Yv1XVjLFxXnrCQKicmser8veQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>