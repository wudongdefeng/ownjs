<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>083ccdee35e90742c3372b81df6e9062</guid>
<title>万字长文细说 Code Review 的正确姿势</title>
<link>https://toutiao.io/k/cxf9ver</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家，InfoQ写作社区签约作者。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h3 data-pm-slice=&quot;1 1 []&quot;&gt;&lt;span&gt;hello，大家好，我是张张，「架构精进之路」公号作者。&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着研发团队规模的逐步扩大，新项目及新成员越来越多，如何做好 code review，把控研发人员的代码质量很是关键。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相信大部分团队，谈到 code review 时候就会面漏哀状：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;“上线时间倒排，研发工期这么紧，连码代码的时间都不够了，你还要我CR？”&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;“上版的需求，这版就变了，代码生命周期太短，烂就烂吧，反正能用就行啦”&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文是我在腾讯工作时结识的一位朋友，也是我为代码委员会 Golang 分会首批选中的理事。他这个人呀，讨论问题，总是喜欢追根问底，考古论今～ :D&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;他在2020年写下的一篇关于 Code Review 的长篇文章。本文&lt;/span&gt;&lt;span&gt;的特点是：一看就是仍旧奋战在一线的工程师写的，不但给出了一些真实代码的示例，还将他对代码的想法与思路写了出来。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;希望能给大家的工作带来一些借鉴和思考~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6082121471343028&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgSMHICGib2SwuGF8IT83WLr6vGNOYMz3JI0icNdSWicdCdqJ04j0vM2rSvh6lRmTJxjavZVQlxsJZDHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1169&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作为公司代码委员会 golang 分会的理事，我 review 了很多代码，看了很多别人的 review 评论。发现不少同学 code review 与写出好代码的水平有待提高。在这里，想分享一下我的一些理念和思路。 &lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么技术人员包括 leader 都要做 code review&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &#x27;Talk Is Cheap, Show Me The Code&#x27;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;知易行难，知行合一更难。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;嘴里要讲出来总是轻松，把别人讲过的话记住，组织一下语言，再讲出来，很容易。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;绝知此事要躬行。设计理念你可能道听途说了一些，以为自己掌握了，但是你会做么？有能力去思考、改进自己当前的实践方式和实践中的代码细节么？不客气地说，很多人仅仅是知道并且认同了某个设计理念，进而产生了一种虚假的安心感---自己的技术并不差。但是，他根本没有去实践这些设计理念，甚至根本实践不了这些设计理念，从结果来说，他懂不懂这些道理/理念，有什么差别？变成了自欺欺人。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;代码，是设计理念落地的地方，是技术的呈现和根本。&lt;/span&gt;&lt;span&gt;同学们可以在 review 过程中做到落地沟通，不再是空对空的讨论，可以在实际问题中产生思考的碰撞，互相学习，大家都掌握团队里积累出来最好的实践方式！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;当然，如果 leader 没时间写代码，仅仅是 review 代码，指出其他同学某些实践方式不好，&lt;/span&gt;&lt;span&gt;要给出好的实践的意见&lt;/span&gt;&lt;span&gt;，即使没亲手写代码，也是对最佳实践要有很多思考。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么同学们要在 review 中思考和总结最佳实践&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;我这里先给一个我自己的总结：&lt;/span&gt;&lt;span&gt;所谓架构师，就是掌握大量设计理念和原则、落地到各种语言及附带工具链（生态）下的实践方法、垂直行业模型理解，定制系统模型设计和工程实践规范细则。进而控制 30+万行代码项目的开发便利性、可维护性、可测试性、运营质量&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;厉害的技术人，主要可以分为下面几个方向：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;掌握很多技巧，以及发现技巧一系列思路，比如很多编程大赛，比的就是这个。但是，这个对工程，用处好像并不是很大。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如约翰*卡马克，他创造出了现代计算机图形高效渲染的方法论。不论如果没有他，后面会不会有人发明，他就是第一个发明了。1999 年，卡马克登上了美国时代杂志评选出来的科技领域 50 大影响力人物榜单，并且名列第 10 位。但是，类似的殿堂级位置，没有几个，不够大家分，没我们的事儿。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;八十年代李开复博士坚持采用隐含马尔可夫模型的框架，成功地开发了世界上第一个大词汇量连续语音识别系统 Sphinx。我辈工程师，好像擅长这个的很少。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小龙哥（注：微信缔造者 张小龙）是标杆。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个是大家都可以做到，按照上面架构师的定义。在这条路上走得好，就能为任何公司组建技术团队，组织建设高质量的系统。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从上面的讨论中，可以看出，我们普通工程师的进化之路，就是不断打磨最佳实践方法论、落地细节。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码变坏的根源&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在讨论什么代码是好代码之前，我们先讨论什么是不好的。计算机是人造的学科，我们自己制造了很多问题，进而去思考解法。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重复的代码&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// BatchGetQQTinyWithAdmin 获取QQ uin的tinyID, 需要主uin的tiny和登录态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// friendUins 可以是空列表, 只要admin uin的tiny&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BatchGetQQTinyWithAdmin&lt;/span&gt;&lt;span&gt;(ctx context.Context, adminUin &lt;span&gt;uint64&lt;/span&gt;, friendUin []&lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;br/&gt; adminTiny &lt;span&gt;uint64&lt;/span&gt;, sig []&lt;span&gt;byte&lt;/span&gt;, frdTiny &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;uint64&lt;/span&gt;]&lt;span&gt;uint64&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; friendAccountList []*basedef.AccountInfo&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; friendUin {&lt;br/&gt;  friendAccountList = &lt;span&gt;append&lt;/span&gt;(friendAccountList, &amp;amp;basedef.AccountInfo{&lt;br/&gt;   AccountType: proto.String(def.StrQQU),&lt;br/&gt;   Userid:      proto.String(fmt.Sprint(v)),&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; req := &amp;amp;cmd0xb91.ReqBody{&lt;br/&gt;  Appid:       proto.Uint32(model.DocAppID),&lt;br/&gt;  CheckMethod: proto.String(CheckQQ),&lt;br/&gt;  AdminAccount: &amp;amp;basedef.AccountInfo{&lt;br/&gt;   AccountType: proto.String(def.StrQQU),&lt;br/&gt;   Userid:      proto.String(fmt.Sprint(adminUin)),&lt;br/&gt;  },&lt;br/&gt;  FriendAccountList: friendAccountList,&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为最开始协议设计得不好，第一个使用接口的人，没有类似上面这个函数的代码，自己实现了一个嵌入逻辑代码的填写请求结构结构体的代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;一开始，挺好的。但当有第二个人，第三个人干了类似的事情，我们将无法再重构这个协议，必须做到麻烦的向前兼容。&lt;/span&gt;&lt;span&gt;而且每个同学，都要理解一遍上面这个协议怎么填，理解有问题，就触发 bug。或者，如果某个错误的理解，普遍存在，我们就得找到所有这些重复的片段，都修改一遍。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当你要读一个数据，发现两个地方有，不知道该选择哪个。当你要实现一个功能，发现两个 rpc 接口、两个函数能做到，你不知道选哪一个。你有面临过这样的&#x27;人生难题&#x27;么？其实怎么选并不重要了，你写的这个代码已经在走向 shit 的道路上迈出了坚实的一步。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是，&lt;/span&gt;&lt;span&gt;A little copying is better than a little dependency&lt;/span&gt;&lt;span&gt;。这里提一嘴，不展开。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里，我必须额外说一句。大家使用 trpc。感觉自己被鼓励&#x27;每个服务搞一个 git&#x27;。那，你这个服务里访问 db 的代码，rpc 的代码，各种可以复用的代码，是用的大家都复用的 git 下的代码么？每次都重复写一遍，db 字段细节改了，每个使用过 db 的 server 对应的 git 都改一遍？这个通用 git 已经写好的接口应该不知道哪些 git 下的代码因为自己不向前兼容的修改而永远放弃了向前不兼容的修改？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;早期有效的决策不再有效&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很多时候，我们第一版代码写出来，是没有太大的问题的。比如，下面这个代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Update 增量更新&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *FilePrivilegeStore)&lt;/span&gt; &lt;span&gt;Update&lt;/span&gt;&lt;span&gt;(key def.PrivilegeKey,&lt;br/&gt; clear, isMerge &lt;span&gt;bool&lt;/span&gt;, subtract []*access.AccessInfo, increment []*access.AccessInfo,&lt;br/&gt; policy *&lt;span&gt;uint32&lt;/span&gt;, adv *access.AdvPolicy, shareKey &lt;span&gt;string&lt;/span&gt;, importQQGroupID &lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 获取之前的数据&lt;/span&gt;&lt;br/&gt; info, err := s.Get(key)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; incOnlyModify := update(info, &amp;amp;key, clear, subtract,&lt;br/&gt;  increment, policy, adv, shareKey, importQQGroupID)&lt;br/&gt; stat := statAndUpdateAccessInfo(info)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !incOnlyModify {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; stat.groupNumber &amp;gt; model.FilePrivilegeGroupMax {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; errors.Errorf(errors.PrivilegeGroupLimit,&lt;br/&gt;    &lt;span&gt;&quot;group num %d larger than limit %d&quot;&lt;/span&gt;,&lt;br/&gt;    stat.groupNumber, model.FilePrivilegeGroupMax)&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !isMerge {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; key.DomainID == &lt;span&gt;uint64&lt;/span&gt;(access.SPECIAL_FOLDER_DOMAIN_ID) &amp;amp;&amp;amp;&lt;br/&gt;   &lt;span&gt;len&lt;/span&gt;(info.AccessInfos) &amp;gt; model.FilePrivilegeMaxFolderNum {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; errors.Errorf(errors.PrivilegeFolderLimit,&lt;br/&gt;    &lt;span&gt;&quot;folder owner num %d larger than limit %d&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;len&lt;/span&gt;(info.AccessInfos), model.FilePrivilegeMaxFolderNum)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(info.AccessInfos) &amp;gt; model.FilePrivilegeMaxNum {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; errors.Errorf(errors.PrivilegeUserLimit,&lt;br/&gt;    &lt;span&gt;&quot;file owner num %d larger than limit %d&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;len&lt;/span&gt;(info.AccessInfos), model.FilePrivilegeMaxNum)&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; pbDataSt := infoToData(info, &amp;amp;key)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; updateBuf []&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; updateBuf, err = proto.Marshal(pbDataSt); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; errors.Wrapf(err, errors.MarshalPBError,&lt;br/&gt;   &lt;span&gt;&quot;FilePrivilegeStore.Update Marshal data error, key[%v]&quot;&lt;/span&gt;, key)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = s.setCKV(generateKey(&amp;amp;key), updateBuf); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; errors.Wrapf(err, errors.Code(err),&lt;br/&gt;   &lt;span&gt;&quot;FilePrivilegeStore.Update setCKV error, key[%v]&quot;&lt;/span&gt;, key)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;现在看，这个代码挺好的，长度没超过 80 行，逻辑比价清晰。但是当 isMerge 这里判断逻辑，&lt;/span&gt;&lt;span&gt;如果加入更多的逻辑，把局部行数撑到 50 行以上，这个函数，味道就坏了。出现两个问题：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1）函数内代码不在一个逻辑层次上，阅读代码，本来在阅读着顶层逻辑，突然就掉入了长达 50 行的 isMerge 的逻辑处理细节，还没看完，读者已经忘了前面的代码讲了什么，需要来回看，挑战自己大脑的 cache 尺寸。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2）代码有问题后，再新加代码的同学，是改还是不改前人写好的代码呢？出 bug 谁来背？这是一个灵魂拷问。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;过早的优化&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个大家听了很多了，这里不赘述。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对合理性没有苛求&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&#x27;两种写法都 ok，你随便挑一种吧&#x27;，&#x27;我这样也没什么吧&#x27;，这是我经常听到的话。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Get 获取IP&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(i *IPGetter)&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(cardName &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; i.l.RLock()&lt;br/&gt; ip, found := i.m[cardName]&lt;br/&gt; i.l.RUnlock()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; found {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ip&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; i.l.Lock()&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; ip, err = getNetIP(cardName)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  i.m[cardName] = ip&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;  i.l.Unlock()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ip&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;i.l.Unlock()可以放在当前的位置，也可以放在 i.l.Lock()下面，做成 defer。两种在最初构造的时候，好像都行。这个时候，很多同学态度就变得不坚决。实际上，这里必须是 defer 的。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  i.l.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; i.l.Unlock()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; ip, err = getNetIP(cardName)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; i.m[cardName] = ip&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ip&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样的修改，是极有可能发生的，它还是要变成 defer，那，为什么不一开始就是 defer，进入最合理的状态？不一开始就进入最合理的状态，在后续协作中，其他同学很可能犯错！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总是面向对象/总喜欢封装&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是软件工程科班出身，学的第一门编程语言是 c++。当时自己读完教材，初入程序设计之门，对于里面讲的&#x27;封装&#x27;，惊为天人，多么美妙的设计啊，面向对象，多么智慧的设计啊。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;但是，这些年来，我看到了大牛&#x27;云风&#x27;对于&#x27;毕业生使用 mysql api 就喜欢搞个 class 封装再用&#x27;的嘲讽；看到了各种莫名其妙的 class 定义；体会到了经常要去看一个莫名其妙的继承树，必须要把整个继承树整体读明白才能确认一个细小的逻辑分支；多次体会到了我需要辛苦地压抑住自己的抵触情绪，去细度一个自作聪明的被封装的代码，确认我的 bug。除了 UI 类场景，我认为&lt;/span&gt;&lt;span&gt;少用继承、多用组合。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; _&lt;span&gt;PKG_TYPE&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CSuperAction&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; CSuperActionBase {&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;typedef&lt;/span&gt; _PKG_TYPE pkg_type;&lt;br/&gt;    &lt;span&gt;typedef&lt;/span&gt; CSuperAction&amp;lt;pkg_type&amp;gt; this_type;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是 sspp 的代码。CSuperAction 和 CSuperActionBase，一会儿 super，一会儿 base，Super 和 SuperBase 是在怎样的两个抽象层次上，不通读代码，没人能读明白。我想确认任何细节，都要把多个层次的代码都通读了，有什么封装性可言？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好，你说是作者没有把 class name 取得好。那，问题是，你能取得好么？一个刚入职的 T1.2 的同学能把 class name、class 树设计得好么？即使是对简单的业务模型，也需要无数次&#x27;坏&#x27;的对象抽象实践，才能培养出一个具有合格的 class 抽象能力的同学，这对于大型却松散的团队协作，不是破坏性的？已经有了一套继承树，想要添加功能就只能在这个继承树里添加，以前的继承树不再适合新的需求，这个继承树上所有的 class，以及使用它们的地方，你都去改？不，是个正常人都会放弃，开始堆屎山。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;封装，就是我可以不关心实现。但是，做一个稳定的系统，每一层设计都可能出问题。例如，API 总有合适的用法和不合适的用法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;真的存在我们能完全不关心封装的部分是怎么实现的？不，你不能&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;bug 和性能问题，常常就出现在：你用了错误的用法去使用一个封装好的函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;即使是 android、ios 的 api，golang、java 现成的 api，我们常常都要去探究实现，才能把 api 用好。那，我们是不是该一上来，就做一个透明性很强的函数，才更为合理？使用者想知道细节，进来吧，我的实现很易读，你看看就明白，使用时不会迷路！对于逻辑复杂的函数，我们还要强调函数内部工作方式&#x27;可以让读者在大脑里想象呈现完整过程&#x27;的可现性，让使用者轻松读懂，有把握，使用时，不迷路！&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;根本没有设计&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个最可怕，所有需求，上手就是一顿撸，&#x27;设计是什么东西？我一个文件 5w 行，一个函数 5k 行，干不完需求？&#x27;从第一行代码开始，就是无设计的，随意地踩着满地的泥坑，对于旁人的眼光没有感觉，一个人独舞，产出的代码，完成了需求，毁灭了接手自己代码的人。这个就不举例了，每个同学应该都能在自己的项目类发现这种代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;必须形而上的思考&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;常常，同学们听演讲，公开课，就喜欢听一些细枝末节的&#x27;干活&#x27;。这没有问题。但是，你干了几年活，学习了多少干货知识点？构建起自己的技术思考&#x27;面&#x27;，进入立体的&#x27;工程思维&#x27;，把技术细节和系统要满足的需求在思考上连接起来了么？当听一个需求的时候，你能思考到自己的 code package 该怎么组织，函数该怎么组织了么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;那，技术点要怎么和需求连接起来呢？答案很简单，&lt;/span&gt;&lt;span&gt;你需要在时间里总结，总结出一些明确的原则、思维过程。思考怎么去总结，特别像是在思考哲学问题。从一些琐碎的细节中，由具体情况上升到一些原则、公理&lt;/span&gt;&lt;span&gt;。同时，大家在接受原则时，不应该是接受和记住原则本身，而应该是结构原则，让这个原则在自己这里重新推理一遍，自己完全掌握这个原则的适用范围。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再进一步具体地说，对于工程最佳实践的形而上的思考过程，就是：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;把工程实践中遇到的问题，从问题类型和解法类型，两个角度去归类，总结出一些有限适用的原则，就从点到了面。把诸多总结出的原则，组合应用到自己的项目代码中，就是把多个面结合起来构建了一套立体的最佳实践的方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当你这套方案能适应 30w+行代码的项目，超过 30 人的项目，你就架构师入门了！当你这个项目，是多端，多语言，代码量超过 300w 行，参与人数超过 300 人，代码质量依然很高，代码依然在高效地自我迭代，每天消除掉过时的代码，填充高质量的替换旧代码和新生的代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;恭喜你，你已经是一个很高级的架构师了！再进一步，你对某个业务模型有独到或者全面的理解，构建了一套行业第一的解决方案，结合刚才高质量实现的能力，实现了这么一个项目。没啥好说的，你已经是专家工程师了。级别再高，我就不了解了，不在这里讨论。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，我们要重头开始积累思考和总结？不，有一本书叫做《unix 编程艺术》，我在不同的时期分别读了 3 遍，等一会，我讲一些里面提到的，我觉得在腾讯尤其值得拿出来说的原则。这些原则，正好就能作为 code review 时大家判定代码质量的准绳。但，在那之前，我得讲一下另外一个很重要的话题，模型设计。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;model 设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;没读过 oauth2.0 RFC，就去设计第三方授权登陆的人，终归还要再发明一个撇脚的 oauth。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2012 年我刚毕业，我和一个去了广州联通公司的华南理工毕业生聊天。当时他说他工作很不开心，因为工作里不经常写代码，而且认为自己有 ACM 竞赛金牌级的算法熟练度+对 CPP 代码的熟悉，写下一个个指针操作内存，什么程序写不出来，什么事情做不好。当时我觉得，挺有道理，编程工具在手，我什么事情做不了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;现在，我会告诉他，复杂如 linux 操作系统、Chromium 引擎、windows office，你做不了。原因是，他根本没进入软件工程的工程世界。&lt;/span&gt;&lt;span&gt;不是会搬砖就能修出港珠澳大桥。&lt;/span&gt;&lt;span&gt;但是，这么回答并不好，举证用的论据离我们太遥远了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;见微知著。我现在会回答，你做不了，简单如一个权限系统，你知道怎么做么？堆积一堆逻辑层次一维展开的 if else？简单如一个共享文件管理，你知道怎么做么？堆积一堆逻辑层次一维展开的 ife lse？你联通有上万台服务器，你要怎么写一个管理平台？堆积一堆逻辑层次一维展开的 ife lse？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上来就是干，能实现上面提到的三个看似简单的需求？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想一想，亚马逊、阿里云折腾了多少年，最后才找到了容器 + Kubernetes 的大杀器。谷歌用了多少年才在 BORG 系统上的实践，提出了优秀的服务编排领域模型。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;权限领域，有 RBAC、DAC、MAC 等等模型，到了业务，又会有细节的不同。如 Domain Driven Design 说的，没有良好的领域思考和模型抽象，逻辑复杂度就是 n^2 指数级的，你得写多少 ifelse，得思考多少可能的 if 路径，来 cover 所有的不合符预期的情况。你必须要有 Domain 思考探索、model 拆解/抽象/构建的能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;有人问过我，要怎么有效地获得这个能力？这个问题我没能回答，就像是在问我，怎么才能获得 MIT 博士的学术能力？我无法回答。唯一回答就是，&lt;/span&gt;&lt;span&gt;进入某个领域，就是首先去看前人的思考，站在前人的肩膀上，再用上自己的通识能力&lt;/span&gt;&lt;span&gt;，去进一步思考。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至于怎么建立好的通识思考能力，可能得去常青藤读个书吧：）或者，就在工程实践中思考和锻炼自己的这个能力！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同时，基于 model 设计的代码，能更好地适应产品经理不断变更的需求。比如说，一个 calendar(日历)应用，简单来想，不要太简单！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以&#x27;userid_date&#x27;为 key 记录一个用户的每日安排不就完成了么？只往前走一小步，设计一个任务，上限分发给 100w 个人。创建这么一个任务，是往 100w 个人下面添加一条记录？你得改掉之前的设计，换 db。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再往前走一步，要拉出某个用户和某个人一起要参与的所有事务，是把两个人的所有任务来做 join？好像还行。如果是和 100 个人一起参与的所有任务呢？100 个人的任务来 join？不现实了吧。好，你引入一个群组 id，那么，你最开始的&#x27;userid_date&#x27;为 key 的设计，是不是又要修改和做数据迁移了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经常来一个需求，你就得把系统推翻重来，或者根本就只能拒绝用户的需求，这样的战斗力，还好意思叫自己工程师？你一开始就应该思考自己面对的业务领域，思考自己的日历应用可能的模型边界，把可能要做的能力都拿进来思考，构建一个 model，设计一套通用的 store 层接口，基于通用接口的逻辑代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当产品不断发展，就是不停往模型里填内容，而不是推翻重来。这，思考模型边界，构建模型细节，就是两个很重要的能力，也是绝大多数腾讯产品经理不具备的能力，你得具备，对整个团队都是极其有益的。你面对产品经理时，就听取他们出于对用户体验负责思考出的需求点，到你自己这里，用一个完整的模型去涵盖这些零碎的点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;model 设计，是形而上思考中的一个方面，一个特别重要的方面。接下来，我们来抄袭抄袭 unix 操作系统构建的实践为我们提出的前人实践经验和&#x27;公理&#x27;总结。在自己的 coding/code review 中，站在巨人的肩膀上去思考。不重复地发现经典力学，而是往相对论挺进。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;UNIX 设计哲学&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不懂 Unix 的人注定最终还要重复发明一个撇脚的 Unix。--Henry Spenncer, 1987.11&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面这一段话太经典，我必须要摘抄一遍(自《UNIX 编程艺术》)：&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;260&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;工程和设计的每个分支都有自己的技术文化。在大多数工程领域中，就一个专业人员的素养组成来说，有些不成文的行业素养具有与标准手册及教科书同等重要的地位(并且随着专业人员经验的日积月累，这些经验常常会比书本更重要)。资深工程师们在工作中会积累大量的隐性知识，他们用类似禅宗&#x27;教外别传&#x27;的方式，通过言传身教传授给后辈。软件工程算是此规则的一个例外：技术变革如此之快，软件环境日新月异，软件技术文化暂如朝露。然而，例外之中也有例外。确有极少数软件技术被证明经久耐用，足以演进为强势的技术文化、有鲜明特色的艺术和世代相传的设计哲学。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我用我的理解，讲解一下几个我们常常做不到的原则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 1 ：&lt;/span&gt;Keep It Simple and Stupid!&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;KISS 原则，大家应该是如雷贯耳了。但是，你真的在遵守？什么是 Simple？简单？golang 语言主要设计者之一的 Rob Pike 说&#x27;大道至简&#x27;，这个&#x27;简&#x27;和简单是一个意思么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，简单不是面对一个问题，我们印入眼帘第一映像的解法为简单。我说一句，感受一下。&quot;把一个事情做出来容易，把事情用最简单有效的方法做出来，是一个很难的事情。&quot;比如，做一个三方授权，oauth2.0 很简单，所有概念和细节都是紧凑、完备、易用的。你觉得要设计到 oauth2.0 这个效果很容易么？要做到简单，就要对自己处理的问题有全面的了解，然后需要不断积累思考，才能做到从各个角度和层级去认识这个问题，打磨出一个通俗、紧凑、完备的设计，就像 ios 的交互设计。简单不是容易做到的，需要大家在不断的时间和 code review 过程中去积累思考，pk 中触发思考，交流中总结思考，才能做得愈发地好，接近&#x27;大道至简&#x27;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;两张经典的模型图，简单又全面，感受一下，没看懂，可以立即自行 google 学习一下：RBAC:&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5752808988764045&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvateFibZunwicamXNtmtrXYQ6TJME4nHnTKJ2BAnU4eDRjsjIYzMMSUeIFUPoQLUq9sGUmoO0WCPfdvA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;890&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;logging:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43802083333333336&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvateFibZunwicamXNtmtrXYQ6TeE8VCDD3htjWxgBIPrSibzOXqXY0n7gb82LuMAfDBTOzeFXGiaVzactA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 2 组合原则: 设计时考虑拼接组合&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于 OOP，关于继承，我前面已经说过了。那我们怎么组织自己的模块？对，用组合的方式来达到。linux 操作系统离我们这么近，它是怎么架构起来的？往小里说，我们一个串联一个业务请求的数据集合，如果使用 BaseSession，XXXSession inherit BaseSession 的设计，其实，这个继承树，很难适应层出不穷的变化。但是如果使用组合，就可以拆解出 UserSignature 等等各种可能需要的部件，在需要的时候组合使用，不断添加新的部件而没有对老的继承树的记忆这个心智负担。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;使用组合，其实就是要让你明确清楚自己现在所拥有的是哪个部件。&lt;/span&gt;&lt;span&gt;如果部件过于多，其实完成组合最终成品这个步骤，就会有较高的心智负担，每个部件展开来，琳琅满目，眼花缭乱。比如 QT 这个通用 UI 框架，看它的Class 列表，有 1000 多个。如果不用继承树把它组织起来，平铺展开，组合出一个页面，将会变得心智负担高到无法承受。OOP 在&#x27;需要无数元素同时展现出来&#x27;这种复杂度极高的场景，有效的控制了复杂度 。&#x27;那么，古尔丹，代价是什么呢？&#x27;代价就是，一开始做出这个自上而下的设计，牵一发而动全身，每次调整都变得异常困难。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际项目中，各种职业级别不同的同学一起协作修改一个 server 的代码，就会出现，职级低的同学改哪里都改不对，根本没能力进行修改，高级别的同学能修改对，也不愿意大规模修改，整个项目变得愈发不合理。对整个继承树没有完全认识的同学都没有资格进行任何一个对继承树有调整的修改，协作变得寸步难行。代码的修改，都变成了依赖一个高级架构师高强度监控继承体系的变化，低级别同学们束手束脚的结果。组合，就很好的解决了这个问题，把问题不断细分，每个同学都可以很好地攻克自己需要攻克的点，实现一个 package。产品逻辑代码，只需要去组合各个 package，就能达到效果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是 golang 标准库里 http request 的定义，它就是 Http 请求所有特性集合出来的结果。其中通用/异变/多种实现的部分，通过 duck interface 抽象，比如 Body io.ReadCloser。你想知道哪些细节，就从组合成 request 的部件入手，要修改，只需要修改对应部件。[这段代码后，对比.NET 的 HTTP 基于 OOP 的抽象]&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// A Request represents an HTTP request received by a server&lt;br/&gt;// or to be sent by a client.&lt;br/&gt;//&lt;br/&gt;// The field semantics differ slightly between client and server&lt;br/&gt;// usage. In addition to the notes on the fields below, see the&lt;br/&gt;// documentation for Request.Write and RoundTripper.&lt;br/&gt;type Request struct {&lt;br/&gt;// Method specifies the HTTP method (GET, POST, PUT, etc.).&lt;br/&gt;// For client requests, an empty string means GET.&lt;br/&gt;//&lt;br/&gt;// Go&#x27;s HTTP client does not support sending a request with&lt;br/&gt;// the CONNECT method. See the documentation on Transport for&lt;br/&gt;// details.&lt;br/&gt;Method string&lt;br/&gt;&lt;br/&gt;// URL specifies either the URI being requested (for server&lt;br/&gt;// requests) or the URL to access (for client requests).&lt;br/&gt;//&lt;br/&gt;// For server requests, the URL is parsed from the URI&lt;br/&gt;// supplied on the Request-Line as stored in RequestURI.  For&lt;br/&gt;// most requests, fields other than Path and RawQuery will be&lt;br/&gt;// empty. (See RFC 7230, Section 5.3)&lt;br/&gt;//&lt;br/&gt;// For client requests, the URL&#x27;s Host specifies the server to&lt;br/&gt;// connect to, while the Request&#x27;s Host field optionally&lt;br/&gt;// specifies the Host header value to send in the HTTP&lt;br/&gt;// request.&lt;br/&gt;URL *url.URL&lt;br/&gt;&lt;br/&gt;// The protocol version for incoming server requests.&lt;br/&gt;//&lt;br/&gt;// For client requests, these fields are ignored. The HTTP&lt;br/&gt;// client code always uses either HTTP/1.1 or HTTP/2.&lt;br/&gt;// See the docs on Transport for details.&lt;br/&gt;Proto      string // &quot;HTTP/1.0&quot;&lt;br/&gt;ProtoMajor int    // 1&lt;br/&gt;ProtoMinor int    // 0&lt;br/&gt;&lt;br/&gt;// Header contains the request header fields either received&lt;br/&gt;// by the server or to be sent by the client.&lt;br/&gt;//&lt;br/&gt;// If a server received a request with header lines,&lt;br/&gt;//&lt;br/&gt;//Host: example.com&lt;br/&gt;//accept-encoding: gzip, deflate&lt;br/&gt;//Accept-Language: en-us&lt;br/&gt;//fOO: Bar&lt;br/&gt;//foo: two&lt;br/&gt;//&lt;br/&gt;// then&lt;br/&gt;//&lt;br/&gt;//Header = map[string][]string{&lt;br/&gt;//&quot;Accept-Encoding&quot;: {&quot;gzip, deflate&quot;},&lt;br/&gt;//&quot;Accept-Language&quot;: {&quot;en-us&quot;},&lt;br/&gt;//&quot;Foo&quot;: {&quot;Bar&quot;, &quot;two&quot;},&lt;br/&gt;//}&lt;br/&gt;//&lt;br/&gt;// For incoming requests, the Host header is promoted to the&lt;br/&gt;// Request.Host field and removed from the Header map.&lt;br/&gt;//&lt;br/&gt;// HTTP defines that header names are case-insensitive. The&lt;br/&gt;// request parser implements this by using CanonicalHeaderKey,&lt;br/&gt;// making the first character and any characters following a&lt;br/&gt;// hyphen uppercase and the rest lowercase.&lt;br/&gt;//&lt;br/&gt;// For client requests, certain headers such as Content-Length&lt;br/&gt;// and Connection are automatically written when needed and&lt;br/&gt;// values in Header may be ignored. See the documentation&lt;br/&gt;// for the Request.Write method.&lt;br/&gt;Header Header&lt;br/&gt;&lt;br/&gt;// Body is the request&#x27;s body.&lt;br/&gt;//&lt;br/&gt;// For client requests, a nil body means the request has no&lt;br/&gt;// body, such as a GET request. The HTTP Client&#x27;s Transport&lt;br/&gt;// is responsible for calling the Close method.&lt;br/&gt;//&lt;br/&gt;// For server requests, the Request Body is always non-nil&lt;br/&gt;// but will return EOF immediately when no body is present.&lt;br/&gt;// The Server will close the request body. The ServeHTTP&lt;br/&gt;// Handler does not need to.&lt;br/&gt;Body io.ReadCloser&lt;br/&gt;&lt;br/&gt;// GetBody defines an optional func to return a new copy of&lt;br/&gt;// Body. It is used for client requests when a redirect requires&lt;br/&gt;// reading the body more than once. Use of GetBody still&lt;br/&gt;// requires setting Body.&lt;br/&gt;//&lt;br/&gt;// For server requests, it is unused.&lt;br/&gt;GetBody func() (io.ReadCloser, error)&lt;br/&gt;&lt;br/&gt;// ContentLength records the length of the associated content.&lt;br/&gt;// The value -1 indicates that the length is unknown.&lt;br/&gt;// Values &amp;gt;= 0 indicate that the given number of bytes may&lt;br/&gt;// be read from Body.&lt;br/&gt;//&lt;br/&gt;// For client requests, a value of 0 with a non-nil Body is&lt;br/&gt;// also treated as unknown.&lt;br/&gt;ContentLength int64&lt;br/&gt;&lt;br/&gt;// TransferEncoding lists the transfer encodings from outermost to&lt;br/&gt;// innermost. An empty list denotes the &quot;identity&quot; encoding.&lt;br/&gt;// TransferEncoding can usually be ignored; chunked encoding is&lt;br/&gt;// automatically added and removed as necessary when sending and&lt;br/&gt;// receiving requests.&lt;br/&gt;TransferEncoding []string&lt;br/&gt;&lt;br/&gt;// Close indicates whether to close the connection after&lt;br/&gt;// replying to this request (for servers) or after sending this&lt;br/&gt;// request and reading its response (for clients).&lt;br/&gt;//&lt;br/&gt;// For server requests, the HTTP server handles this automatically&lt;br/&gt;// and this field is not needed by Handlers.&lt;br/&gt;//&lt;br/&gt;// For client requests, setting this field prevents re-use of&lt;br/&gt;// TCP connections between requests to the same hosts, as if&lt;br/&gt;// Transport.DisableKeepAlives were set.&lt;br/&gt;Close bool&lt;br/&gt;&lt;br/&gt;// For server requests, Host specifies the host on which the&lt;br/&gt;// URL is sought. For HTTP/1 (per RFC 7230, section 5.4), this&lt;br/&gt;// is either the value of the &quot;Host&quot; header or the host name&lt;br/&gt;// given in the URL itself. For HTTP/2, it is the value of the&lt;br/&gt;// &quot;:authority&quot; pseudo-header field.&lt;br/&gt;// It may be of the form &quot;host:port&quot;. For international domain&lt;br/&gt;// names, Host may be in Punycode or Unicode form. Use&lt;br/&gt;// golang.org/x/net/idna to convert it to either format if&lt;br/&gt;// needed.&lt;br/&gt;// To prevent DNS rebinding attacks, server Handlers should&lt;br/&gt;// validate that the Host header has a value for which the&lt;br/&gt;// Handler considers itself authoritative. The included&lt;br/&gt;// ServeMux supports patterns registered to particular host&lt;br/&gt;// names and thus protects its registered Handlers.&lt;br/&gt;//&lt;br/&gt;// For client requests, Host optionally overrides the Host&lt;br/&gt;// header to send. If empty, the Request.Write method uses&lt;br/&gt;// the value of URL.Host. Host may contain an international&lt;br/&gt;// domain name.&lt;br/&gt;Host string&lt;br/&gt;&lt;br/&gt;// Form contains the parsed form data, including both the URL&lt;br/&gt;// field&#x27;s query parameters and the PATCH, POST, or PUT form data.&lt;br/&gt;// This field is only available after ParseForm is called.&lt;br/&gt;// The HTTP client ignores Form and uses Body instead.&lt;br/&gt;Form url.Values&lt;br/&gt;&lt;br/&gt;// PostForm contains the parsed form data from PATCH, POST&lt;br/&gt;// or PUT body parameters.&lt;br/&gt;//&lt;br/&gt;// This field is only available after ParseForm is called.&lt;br/&gt;// The HTTP client ignores PostForm and uses Body instead.&lt;br/&gt;PostForm url.Values&lt;br/&gt;&lt;br/&gt;// MultipartForm is the parsed multipart form, including file uploads.&lt;br/&gt;// This field is only available after ParseMultipartForm is called.&lt;br/&gt;// The HTTP client ignores MultipartForm and uses Body instead.&lt;br/&gt;MultipartForm *multipart.Form&lt;br/&gt;&lt;br/&gt;// Trailer specifies additional headers that are sent after the request&lt;br/&gt;// body.&lt;br/&gt;//&lt;br/&gt;// For server requests, the Trailer map initially contains only the&lt;br/&gt;// trailer keys, with nil values. (The client declares which trailers it&lt;br/&gt;// will later send.)  While the handler is reading from Body, it must&lt;br/&gt;// not reference Trailer. After reading from Body returns EOF, Trailer&lt;br/&gt;// can be read again and will contain non-nil values, if they were sent&lt;br/&gt;// by the client.&lt;br/&gt;//&lt;br/&gt;// For client requests, Trailer must be initialized to a map containing&lt;br/&gt;// the trailer keys to later send. The values may be nil or their final&lt;br/&gt;// values. The ContentLength must be 0 or -1, to send a chunked request.&lt;br/&gt;// After the HTTP request is sent the map values can be updated while&lt;br/&gt;// the request body is read. Once the body returns EOF, the caller must&lt;br/&gt;// not mutate Trailer.&lt;br/&gt;//&lt;br/&gt;// Few HTTP clients, servers, or proxies support HTTP trailers.&lt;br/&gt;Trailer Header&lt;br/&gt;&lt;br/&gt;// RemoteAddr allows HTTP servers and other software to record&lt;br/&gt;// the network address that sent the request, usually for&lt;br/&gt;// logging. This field is not filled in by ReadRequest and&lt;br/&gt;// has no defined format. The HTTP server in this package&lt;br/&gt;// sets RemoteAddr to an &quot;IP:port&quot; address before invoking a&lt;br/&gt;// handler.&lt;br/&gt;// This field is ignored by the HTTP client.&lt;br/&gt;RemoteAddr string&lt;br/&gt;&lt;br/&gt;// RequestURI is the unmodified request-target of the&lt;br/&gt;// Request-Line (RFC 7230, Section 3.1.1) as sent by the client&lt;br/&gt;// to a server. Usually the URL field should be used instead.&lt;br/&gt;// It is an error to set this field in an HTTP client request.&lt;br/&gt;RequestURI string&lt;br/&gt;&lt;br/&gt;// TLS allows HTTP servers and other software to record&lt;br/&gt;// information about the TLS connection on which the request&lt;br/&gt;// was received. This field is not filled in by ReadRequest.&lt;br/&gt;// The HTTP server in this package sets the field for&lt;br/&gt;// TLS-enabled connections before invoking a handler;&lt;br/&gt;// otherwise it leaves the field nil.&lt;br/&gt;// This field is ignored by the HTTP client.&lt;br/&gt;TLS *tls.ConnectionState&lt;br/&gt;&lt;br/&gt;// Cancel is an optional channel whose closure indicates that the client&lt;br/&gt;// request should be regarded as canceled. Not all implementations of&lt;br/&gt;// RoundTripper may support Cancel.&lt;br/&gt;//&lt;br/&gt;// For server requests, this field is not applicable.&lt;br/&gt;//&lt;br/&gt;// Deprecated: Set the Request&#x27;s context with NewRequestWithContext&lt;br/&gt;// instead. If a Request&#x27;s Cancel field and context are both&lt;br/&gt;// set, it is undefined whether Cancel is respected.&lt;br/&gt;Cancel &amp;lt;-chan struct{}&lt;br/&gt;&lt;br/&gt;// Response is the redirect response which caused this request&lt;br/&gt;// to be created. This field is only populated during client&lt;br/&gt;// redirects.&lt;br/&gt;Response *Response&lt;br/&gt;&lt;br/&gt;// ctx is either the client or server context. It should only&lt;br/&gt;// be modified via copying the whole Request using WithContext.&lt;br/&gt;// It is unexported to prevent people from using Context wrong&lt;br/&gt;// and mutating the contexts held by callers of the same request.&lt;br/&gt;ctx context.Context&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看看.NET 里对于 web 服务的抽象，仅仅看到末端，不去看完整个继承树的完整图景，我根本无法知道我关心的某个细节在什么位置。进而，我要往整个 http 服务体系里修改任何功能，都无法抛开对整体完整设计的理解和熟悉，还极容易没有知觉地破坏者整体的设计。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说到组合，还有一个关系很紧密的词，叫插件化。大家都用 vscode 用得很开心，它比 visual studio 成功在哪里？如果 vscode 通过添加一堆插件达到 visual studio 具备的能力，那么它将变成另一个和 visual studio 差不多的东西，叫做 vs studio 吧。大家应该发现问题了，我们很多时候其实并不需要 visual studio 的大多数功能，而且希望灵活定制化一些比较小众的能力，用一些小众的插件。甚至，我们希望选择不同实现的同类型插件。这就是组合的力量，各种不同的组合，它简单，却又满足了各种需求，灵活多变，要实现一个插件，不需要事先掌握一个庞大的体系。体现在代码上，也是一样的道理。至少后端开发领域，组合，比 OOP，&#x27;香&#x27;很多。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 3 吝啬原则: 除非确无它法, 不要编写庞大的程序&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可能有些同学会觉得，把程序写得庞大一些才好拿得出手去评 T11、T12。leader 们一看评审方案就容易觉得：很大，很好，很全面。但是，我们真的需要写这么大的程序么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我又要说了&quot;那么，古尔丹，代价是什么呢？&quot;。代价是代码越多，越难维护，难调整。说&quot;&quot;。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;删除一行代码，给我带来的成就感要比添加一行要大&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;—— C 语言之父 Ken Thompson &lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们对于代码，要吝啬。能把系统做小，就不要做大。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;腾讯不乏 200w+行的客户端，很大，很牛。但是，同学们自问，现在还调整得动架构么。手 Q 的同学们，看看自己代码，曾经叹息过么?&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;能小做的事情就小做，寻求通用化，通过 duck interface(甚至多进程，用于隔离能力的多线程)把模块、能力隔离开，时刻想着删减代码量，才能保持代码的可维护性和面对未来的需求、架构，调整自身的活力。客户端代码，UI 渲染模块可以复杂吊炸天，非 UI 部分应该追求最简单，能力接口化，可替换、重组合能力强。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;落地到大家的代码，review 时，就应该最关注核心 struct 定义，构建起一个完备的模型，核心 interface，明确抽象 model 对外部的依赖，明确抽象 model 对外提供的能力。其他代码，就是要用最简单、平平无奇的代码实现模型内部细节。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 4 透明性原则: 设计要可见，以便审查和调试&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，定义一下，什么是透明性和可显性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&quot;如果没有阴暗的角落和隐藏的深度，软件系统就是透明的。透明性是一种被动的品质。如果实际上能预测到程序行为的全部或大部分情况，并能建立简单的心理模型，这个程序就是透明的，因为可以看透机器究竟在干什么。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果软件系统所包含的功能是为了帮助人们对软件建立正确的&#x27;做什么、怎么做&#x27;的心理模型而设计，这个软件系统就是可显的。因此，举例来说，对用户而言，良好的文档有助于提高可显性；对程序员而言，良好的变量和函数名有助于提高可显性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可显性是一种主动品质。在软件中要达到这一点，仅仅做到不晦涩是不够的，还必须要尽力做到有帮助。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们要写好程序，减少 bug，就要增强自己对代码的控制力。你始终做到，理解自己调用的函数/复用的代码大概是怎么实现的。不然，你可能就会在单线程状态机的 server 里调用有 IO 阻塞的函数，让自己的 server 吞吐量直接掉到底。进而，为了保证大家能对自己代码能做到有控制力，所有人写的函数，就必须具备很高的透明性。而不是写一些看了一阵看不明白的函数/代码，结果被迫使用你代码的人，直接放弃了对掌控力的追取，甚至放弃复用你的代码，另起炉灶，走向了&#x27;制造重复代码&#x27;的深渊。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;透明性其实相对容易做到的，大家有意识地锻炼一两个月，就能做得很好。可显性就不容易了。有一个现象是，你写的每一个函数都不超过 80 行，每一行我都能看懂，但是你层层调用，很多函数调用，组合起来怎么就实现了某个功能，看两遍，还是看不懂。第三遍可能才能大概看懂。大概看懂了，但太复杂，很难在大脑里构建起你实现这个功能的整体流程。结果就是，阅读者根本做不到对你的代码有好的掌控力。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可显性的标准很简单，大家看一段代码，懂不懂，一下就明白了。但是，如何做好可显性？那就是要追求合理的函数分组，合理的函数上下级层次，同一层次的代码才会出现在同一个函数里，追求通俗易懂的函数分组分层方式，是通往可显性的道路。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，复杂如 linux 操作系统，office 文档，问题本身就很复杂，拆解、分层、组合得再合理，都难建立心理模型。这个时候，就需要完备的文档了。完备的文档还需要出现在离代码最近的地方，让人&#x27;知道这里复杂的逻辑有文档&#x27;，而不是其实文档，但是阅读者不知道。再看看上面 golang 标准库里的 http.Request，感受到它在可显性上的努力了么？对，就去学它。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 5 通俗原则: 接口设计避免标新立异&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设计程序过于标新立异的话，可能会提升别人理解的难度。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般，我们这么定义一个&#x27;点&#x27;，使用 x 表示横坐标，用 y 表示纵坐标：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type Point struct {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; X float64&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Y float64&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你就是要不同、精准：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Point &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; VerticalOrdinate   &lt;span&gt;float64&lt;/span&gt;&lt;br/&gt; HorizontalOrdinate &lt;span&gt;float64&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很好，你用词很精准，一般人还驳斥不了你。但是，多数人读你的 VerticalOrdinate 就是没有读 X 理解来得快，来得容易懂、方便。你是在刻意制造协作成本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面的例子常见，但还不是最小立异原则最想说明的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想想一下，一个程序里，你把用&#x27;+&#x27;这个符号表示数组添加元素，而不是数学&#x27;加&#x27;，&#x27;result := 1+2&#x27; --&amp;gt; &#x27;result = []int{1, 2}&#x27;而不是&#x27;result=3&#x27;，那么，你这个标新立异，对程序的破坏性，简直无法想象。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;最小立异原则的另一面是避免表象想死而实际却略有不同。这会极端危险，因为表象相似往往导致人们产生错误的假定。所以最好让不同事物有明显区别，而不要看起来几乎一模一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;-- Henry Spencer&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你实现一个 db.Add()函数却做着 db.AddOrUpdate()的操作，有人使用了你的接口，错误地把数据覆盖了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 6 缄默原则: 如果一个程序没什么好说的，就沉默&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个原则，应该是大家最经常破坏的原则之一。一段简短的代码里插入了各种&#x27;log(&quot;cmd xxx enter&quot;)&#x27;, &#x27;log(&quot;req data &quot; + req.String())&#x27;，非常害怕自己信息打印得不够。害怕自己不知道程序执行成功了，总要最后&#x27;log(&quot;success&quot;)&#x27;。但是，我问一下大家，你们真的耐心看过别人写的代码打的一堆日志么？不是自己需要哪个，就在一堆日志里，再打印一个日志出来一个带有特殊标记的日志&#x27;log(&quot;this_is_my_log_&quot; + xxxxx)&#x27;？结果，第一个作者打印的日志，在代码交接给其他人或者在跟别人协作的时候，这个日志根本没有价值，反而提升了大家看日志的难度。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个服务一跑起来，就疯狂打日志，请求处理正常也打一堆日志。滚滚而来的日志，把错误日志淹没在里面。错误日志失去了效果，简单地 tail 查看日志，眼花缭乱，看不出任何问题，这不就成了&#x27;为了捕获问题&#x27;而让自己&#x27;根本无法捕获问题&#x27;了么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;沉默是金。除了简单的 stat log，如果你的程序&#x27;发声&#x27;了，那么它抛出的信息就一定要有效！打印一个 log(&#x27;process fail&#x27;)也是毫无价值，到底什么 fail 了？是哪个用户带着什么参数在哪个环节怎么 fail 了？如果发声，就要把必要信息给全。不然就是不发声，表示自己好好地 work 着呢。不发声就是最好的消息，现在我的 work 一切正常！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&quot;设计良好的程序将用户的注意力视为有限的宝贵资源，只有在必要时才要求使用。&quot;程序员自己的主力，也是宝贵的资源！只有有必要的时候，日志才跑来提醒程序员&#x27;我有问题，来看看&#x27;，而且，必须要给到足够的信息，让一把讲明白现在发生了什么。而不是程序员还需要很多辅助手段来搞明白到底发生了什么。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每当我发布程序 ，我抽查一个机器，看它的日志。发现只有每分钟外部接入、内部 rpc 的个数/延时分布日志的时候，我就心情很愉悦。我知道，这一分钟，它的成功率又是 100%，没任何问题！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 7 补救原则: 出现异常时，马上退出并给出足够错误信息&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实这个问题很简单，如果出现异常，异常并不会因为我们尝试掩盖它，它就不存在了。所以，程序错误和逻辑错误要严格区分对待。这是一个态度问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&#x27;异常是互联网服务器的常态&#x27;。逻辑错误通过 metrics 统计，我们做好告警分析。对于程序错误 ，我们就必须要严格做到在问题最早出现的位置就把必要的信息搜集起来，高调地告知开发和维护者&#x27;我出现异常了，请立即修复我!&#x27;。可以是直接就没有被捕获的 panic 了。也可以在一个最上层的位置统一做好 recover 机制，但是在 recover 的时候一定要能获得准确异常位置的准确异常信息。不能有中间 catch 机制，catch 之后丢失很多信息再往上传递。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很多 Java 开发的同学，不区分程序错误和逻辑错误，要么都很宽容，要么都很严格，对代码的可维护性是毁灭性的破坏。&quot;我的程序没有程序错误，如果有，我当时就解决了。&quot;只有这样，才能保持程序代码质量的相对稳定，在火苗出现时扑灭火灾是最好的扑灭火灾的方式。当然，更有效的方式是全面自动化测试的预防：）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具体实践点&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面提了好多思考方向的问题。大的原则问题和方向。我这里，再来给大家简单列举几个细节执行点吧。毕竟，大家要上手，是从执行开始，然后才是总结思考，能把我的思考方式抄过去。下面是针对 golang 语言的，其他语言略有不同。以及，我一时也想不全我所执行的 所有细则，这就是我强调&#x27;原则&#x27;的重要性，原则是可枚举的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;对于代码格式规范，100%严格执行，严重容不得一点沙。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;文件绝不能超过 800 行，如何超过了800行，一定要思考怎么拆文件。没有足够好的理由，就不应该超过 800 行。工程思维，就在于拆文件的时候积累。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;函数对绝不能超过 80 行。如何超过了80行，一定要思考怎么拆函数，思考函数分组，层次。没有足够好的理由，就不应该超过 80 行。工程思维，就在于拆文件的时候积累。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;代码嵌套层次不能超过 4 层，超过了就得改。多想想能不能 early return。工程思维，就在于拆文件的时候积累。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; !needContinue {&lt;br/&gt; doA()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt; doB()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; !needContinue {&lt;br/&gt; doA()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;doB()&lt;br/&gt;&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面这个就是 early return，把两端代码从逻辑上解耦了。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从目录、package、文件、struct、function 一层层下来 ，信息一定不能出现冗余。比如 file.FileProperty 这种定义。只有每个&#x27;定语&#x27;只出现在一个位置，才为&#x27;做好逻辑、定义分组/分层&#x27;提供了可能性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多用多级目录来组织代码所承载的信息，即使某一些中间目录只有一个子目录。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;随着代码的扩展，老的代码违反了一些设计原则，应该立即原地局部重构，维持住代码质量不滑坡。比如:拆文件；拆函数；用 Session 来保存一个复杂的流程型函数的所有信息；重新调整目录结构。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于上一点考虑，我们应该尽量让项目的代码有一定的组织、层次关系。我个人的当前实践是除了特别通用的代码，都放在一个 git 里。特别通用、修改少的代码，逐渐独立出 git，作为子 git 连接到当前项目 git，让 goland 的 Refactor 特性、各种 Refactor 工具能帮助我们快速、安全局部重构。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;自己的项目代码，应该有一个内生的层级和逻辑关系。flat 平铺展开是非常不利于代码复用的。怎么复用、怎么组织复用，肯定会变成&#x27;人生难题&#x27;。T4-T7 的同学根本无力解决这种难题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果被 review 的代码虽然简短，但是你看了一眼却发现不咋懂，那就一定有问题。自己看不出来，就找高级别的同学交流。这是你和别 review 代码的同学成长的时刻。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;日志要少打。要打日志就要把关键索引信息带上。必要的日志必须打。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有疑问就立即问，不要怕问错。让代码作者给出解释。不要怕问出极低问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不要说&#x27;建议&#x27;，提问题，就是刚，你 pk 不过我，就得改！&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;请积极使用 trpc。总是要和老板站在一起！只有和老板达成的对于代码质量建设的共识，才能在团队里更好地做好代码质量建设。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消灭重复！消灭重复！消灭重复！&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主干开发&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，我来为&#x27;主干开发&#x27;多说一句话。道理很简单，只有每次被 review 代码不到 500 行，reviewer 才能快速地看完，而且几乎不会看漏。超过 500 行，reviewer 就不能仔细看，只能大概浏览了。而且，让你调整 500 行代码内的逻辑比调整 3000 行甚至更多的代码，容易很多，降低不仅仅是 6 倍，而是一到两个数量级。有问题，在刚出现的时候就调整了，不会给被 revew 的人带来大的修改负担。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于 持续集成（CI，continuous integration)，还有很多好的资料和书籍，大家应该及时去学习学习。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;《unix 编程艺术》&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;建议大家把这本书找出来读一读。特别是，T7 及更高级别的同学。你们已经积累了大量的代码实践，亟需对&#x27;工程性&#x27;做思考总结。很多工程方法论都过时了，这本书的内容，是例外中的例外。它所表达出的内容没有因为软件技术的不断更替而过时。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;佛教禅宗讲&#x27;不立文字&#x27;(不立文字，教外别传，直指人心，见性成佛)，很多道理和感悟是不能用文字传达的，文字的表达能力，不能表达。大家常常因为&quot;自己听说过、知道某个道理&quot;而产生一种安心感，认为&quot;我懂了这个道理&quot;，但是自己却不能在实践中做到。知易行难，知道却做不到，在工程实践里，就和&#x27;不懂这个道理&#x27;没有任何区别了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我面试过一个别的公司的总监，讲得好像一套一套，代码拉出来遛一遛，根本就没做到，仅仅会道听途说。他在工程实践上的探索前路可以说已经基本断绝了。我只能祝君能做好向上管理，走自己的纯管理道路吧。请不要再说自己对技术有追求，是个技术人了！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，大家不仅仅是看看我这篇文章，而是在实践中去不断践行和积累自己的&#x27;教外别传&#x27;吧。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;希望今天的讲解对大家有所帮助，谢谢！&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;Thanks for reading!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家，InfoQ写作平台签约作者。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注公众号，免费领学习资料&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;28&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;28&quot;&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;如果您觉得还不错，欢迎关注和转发~     &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5163398692810458&quot; data-type=&quot;png&quot; data-w=&quot;306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT930CzevNBb2yMhKjOn9yuJqsCPbyzicCBx6Zm9sNJCWibo6VzGRYbxrSfjJaaGibSRuyZFQmr3KcX07sw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9de39cc2de785cf4bc3c499df51ab237</guid>
<title>专项测试系列：缓存击穿、穿透、雪崩专项测试</title>
<link>https://toutiao.io/k/lv6coxq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：刘须华&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、背景概述：&lt;/strong&gt;  R2M 缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。而缓存最常见的问题是缓存穿透、击穿和雪崩，在高并发下这三种情况都会有大量请求落到数据库，导致数据库资源占满，引起数据库故障。平时对缓存测试时除了关注增删修改查询等基本功能，应该要重点关注缓存穿透、击穿和雪崩三种异常场景的测试覆盖，避免出现线上事故。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、基本概念说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、缓存击穿：&lt;/strong&gt; 是指在超级热点数据突然过期，导致针对超级热点的数据请求在过期期间直接打到数据库，这样数据库服务器会因为某一超热数据导致压力过大而崩掉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cd1980c4d9d48f09061f07305db8794%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、缓存穿透：&lt;/strong&gt; 是指查找的数据在缓存和数据库中都不存在，导致每一次请求数据从缓存中都获取不到，而将请求打到数据库服务器，但数据库中也没有对应的数据，最后每一次请求都到数据库；如果在高并发场景或有人恶意攻击，就会导致后台数据库服务器压力增大，最终系统可能崩掉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6e40c13bb354616b220f35a978f0fc0%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、缓存雪崩：&lt;/strong&gt; 是指突然缓存层不可用，导致大量请求直接打到数据库，最终由于数据库压力过大可能导致系统崩掉。缓存层不可用指以下两方面：缓存服务器宕机，系统将请求打到数据库； 缓存数据突然大范围集中过期失效，导致大量请求打到数据库重新加载数据，与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46d0cb4e411e4a90b08d2a1a1f55a110%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、测试工具 (非必须)&lt;/strong&gt; ：&lt;/p&gt;

&lt;p&gt;1、使用 Titan 压测平台进行并发请求测试&lt;/p&gt;

&lt;p&gt;2、使用 jmeter 工具模拟并发请求&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、测试方法举例说明 (非必须)&lt;/strong&gt; ：&lt;/p&gt;

&lt;p&gt;环境：测试环境&lt;/p&gt;

&lt;p&gt;工具：jmeter&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）缓存穿透场景&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;测试方法：查询一个根本不存在的数据，缓存层和存储层都不会命中。&lt;/p&gt;

&lt;p&gt;查询接口相关代码实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d82a57ec72e4b1d96ac0c2badd4e972%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;通过 JMETER 模拟多次重复调用：单线程重复调用&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea519ff2769a4d2bbbeae05bd64558d7%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;查看日志结果：从日志可以看出：执行并发请求后， 所有请求每次都走向了数据库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3cc033bc50b42d0abe7436924b3e728%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;预防方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当数据库查询为空时，将缓存赋值默认值，后续查询都走缓存，减少数据库压力。&lt;/p&gt;

&lt;p&gt;上述接口，增加赋值为 empty，则第一次查询到数据库为空，后续查询都查询到缓存中，缓存值为 empty。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b9dadd0fb57484cae321a83d50c7927%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;再次执行并发测试：从日志可以看出，可以看出每个 ID 都只执行了一次数据库查询并设置缓存，之后请求都命中了缓存，有效防止了缓存穿透问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84e0ccd477364b1bb057da5b7862f528%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）缓存击穿场景&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;测试方法：对某个 Key 有大量的并发请求，这时从缓存中删除这个 key。模拟热 key 过期失效的场景。这个时候大并发的请求可能会瞬间把后端 DB 压垮。&lt;/p&gt;

&lt;p&gt;接口相关部分代码实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0e84217b23749c2be4c617e240ec2ee%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;操作步骤：&lt;/p&gt;

&lt;p&gt;1、查询 pin 为 liuxuhua 的请求，这时 pin 为 liuxuhua 的数据会加载到缓存&lt;/p&gt;

&lt;p&gt;2、再次查询 pin 为 liuxuhua 的请求，命中缓存&lt;/p&gt;

&lt;p&gt;3、50 并发请求 pin 为 liuxuhua 的数据，这个时候请求全部命中缓存&lt;/p&gt;

&lt;p&gt;4、将 pin 为 liuxuhua 的缓存手动删除，模拟缓存失效&lt;/p&gt;

&lt;p&gt;5、50 并发请求 pin 为 liuxuhua 的数据，这个时候大量请求走向数据库，pin 为 liuxuhua 的缓存被击穿&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7ee1ad20ec249f59feae2a27924430a%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿﻿&lt;/p&gt;

&lt;p&gt;查看日志结果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfd820a9376f43c6ada175234a3c7edc%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;预防方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在设置默认缓存值的基础上，进行加锁处理。只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有。﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35ee6edde2f549f989cf17c052568546%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;从日志记录可以看到只有一个请求执行了数据库查询并设置缓存，其他请求都命中了缓存， 有效防止了缓存的击穿。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/934dc8c583804db5ab51f4f597ef9e5c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）缓存雪崩&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;测试方法：对多个使用到缓存的接口进行并发调用，设置这些缓存时间已过期（即删除缓存），调用时这些接口查询缓存时无数据，去查询数据库，这些请求都指向数据库，数据库压力增大，耗时增加。&lt;/p&gt;

&lt;p&gt;模拟接口：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fde4a68daf544edd8be29d78ef578bd0%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a865db6d42ac42959fc469a0f41430d1%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;通过 JMETER 模拟多次重复调用：单线程多接口重复调用&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e0648d58c874a40b3169bf819c20bf8%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;查看日志结果：可以看出大量请求到达数据库，并且同一个 pin 或 id 执行了多次数据库查询&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36260e1239e7491a82f731c180349993%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;预防方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;增加限流操作，即接口频繁调用时，增加一个缓存，设置时间为 3s，3s 内处理一定次数的请求，超过限制次数的请求直接返回结果，不做处理。&lt;/p&gt;

&lt;p&gt;接口：3s 内处理 6 次请求，超过则不处理；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71305d673cf14ff6b763d923fae45804%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;从日志可以看出：可以看到每个都只查询了一次数据库并设置缓存，之后的请求都命中了缓存&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d57b5b0564a444bf8c5a77cb3b56fd6d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、测试指标&lt;/strong&gt;：(或者叫通过标准，包括关注点以及意义)&lt;/p&gt;

&lt;p&gt;1、模拟缓存穿透场景测试，每个不存在的数据都只执行了一次数据库查询并设置缓存，之后请求都命中了缓存，有效防止了缓存穿透问题。&lt;/p&gt;

&lt;p&gt;2、模拟缓存雪崩场景测试，每个缓存失效的数据都只执行了一次数据库查询并设置缓存，之后请求都命中了缓存。&lt;/p&gt;

&lt;p&gt;3、模拟缓存击穿场景测试，缓存失效的那个数据只有一个请求执行了数据库查询并设置缓存，其他请求都命中了缓存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、适用业务场景：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、秒杀活动&lt;/p&gt;

&lt;p&gt;2、热门营销活动&lt;/p&gt;

&lt;p&gt;3、618 和双 11 大促&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;七、研发侧常见解决方案（参考）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、缓存穿透解决方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、缓存空值 之所以发生穿透，是因为缓存中没有存储这些数据的 key，从而每次都查询数据库 我们可以为这些 key 在缓存中设置对应的值为 null，后面查询这个 key 的时候就不用查询数据库了 当然为了健壮性，我们要对这些 key 设置过期时间，以防止真的有数据&lt;/p&gt;

&lt;p&gt;2、BloomFilter BloomFilter 类似于一个 hbase set 用来判断某个元素（key）是否存在于某个集合中 我们把有数据的 key 都放到 BloomFilter 中，每次查询的时候都先去 BloomFilter 判断，如果没有就直接返回 null 注意 BloomFilter 没有删除操作，对于删除的 key，查询就会经过 BloomFilter 然后查询缓存再查询数据库，所以 BloomFilter 可以结合缓存空值用，对于删除的 key，可以在缓存中缓存 null 缓存击穿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、缓存击穿解决方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;采用分布式锁，只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、缓存雪崩解决方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、采用集群，降低服务宕机的概率&lt;/p&gt;

&lt;p&gt;2、ehcache 本地缓存 + 限流 &amp;amp; 降级&lt;/p&gt;

&lt;p&gt;3、均匀过期，通常可以为有效期增加随机值&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1a771b88f628459cda3b1b3ea33a9d83</guid>
<title>分布式系统设计模式，你用过哪些？</title>
<link>https://toutiao.io/k/8eyyeev</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1、布隆过滤器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Bloom过滤器是一种节省空间的概率数据结构，用于测试元素是否为某集合的成员。它用于我们只需要检查元素是否属于对象的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25390625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk57w9icCtUnM7GDQWj267GAibtrcHgzEMcfFuqWlmUNNksHzDzdKH4vDPJtA1ArgibXoBoxnPQ0Lt8iakA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在BigTable（和Cassandra）中，任何读取操作都必须从组成Tablet的SSTable中读取。如果这些SSTable不在内存中，则读取操作可能最终会执行许多磁盘访问以便读取所需的SSTable。为了减少磁盘访问次数，BigTable 使用Bloom过滤器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2、一致性哈希&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一致的哈希允许您轻松扩展，从而允许以有效的方式复制数据，从而实现更好的可用性和容错能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;通过对数据项的键进行哈希处理以产生其在环上的位置，然后顺时针遍历环以查找位置大于该项位置的第一个节点，将每个由键标识的数据项分配给节点。与节点关联的节点是数据项的位置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk57w9icCtUnM7GDQWj267GAibtPk8SkH9yf6ibQSun4g1pVXUneNnDRo6bqvCkpeMhoXUf4t1ej5RtRHw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一致散列的主要优点是增量稳定性；节点离开或到达集群仅影响其直接邻居，其他节点不受影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3、Quorum&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在分布式环境中，quorum是在确认操作成功之前需要成功执行此分布式操作的最小服务器数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5749636098981077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk57w9icCtUnM7GDQWj267GAibtXj4Rp7nB2kR667XjLrMft2GBlZb8D22KROr53icusKbOLhTGe65lGbA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;687&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Cassandra，为了确保数据一致性，每个写入请求都可以配置为仅当数据已写入至少一个quorum（或大多数）副本节点时才成功。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于领导者选举，Chubby使用Paxos，它使用quorum来确保强大的一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Dynamo 将写入复制到系统中其他节点的草率quorum，而不是像Paxos那样的严格多数quorum。所有读/写操作都在首选项列表中的第一个NN正常节点上执行，该节点可能并不总是在遍历一致哈希环时遇到的第一个NN节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4、领导者（Leader）和追随者（Follower）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;为了在管理数据的系统中实现容错，需要在多个服务器上复制数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在集群中选择一个服务器作为领导者。领导者负责代表整个集群做出决策，并将决策传播到所有其他服务器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;三到五个节点的集群，就像在实现共识的系统中一样，领导者选举可以在数据集群本身内实施，而不依赖于任何外部系统。领导者选举在服务器启动时进行。每个服务器在启动时都会启动领导者选举，并尝试选举领导者。除非选出领导者，否则系统不接受任何客户端请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;5、心跳&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;心跳机制用于检测现有领导者是否失败，以便可以启动新的领导者选举。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;6、Fencing&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在领导者-追随者模式中，当领导者失败时，不可能确定领导者已停止工作。例如，慢速网络或网络分区可能会触发新的领导者选举，即使前一个领导者仍在运行并认为它仍然是活动的领导者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;屏蔽是指在以前处于活动状态的领导者周围设置围栏，使其无法访问集群资源，从而停止为任何读/写请求提供服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;使用以下两种技术：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;7、WAL（预写日志Write-ahead Log）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;预写日志记录是解决操作系统中文件系统不一致的问题的高级解决方案。受数据库管理系统的启发，此方法首先将要执行的操作的摘要记入“日志”中，然后再将其实际写入磁盘。在发生崩溃的情况下，操作系统只需检查此日志并从中断的位置继续。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;8、分段日志&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;将日志拆分为多个较小的文件，而不是单个大文件，以便于操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;单个日志文件在启动时读取时可能会增长并成为性能瓶颈。较旧的日志会定期清理，并且很难对单个大文件执行清理操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;单个日志拆分为多个段。日志文件在指定的大小限制后滚动。使用日志分段，需要有一种将逻辑日志偏移量（或日志序列号）映射到日志段文件的简单方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;9、高水位线（High-Water mark）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;跟踪领导者上的最后一个日志条目，该条目已成功复制到追随者的quorum。日志中此条目的索引称为高水位线索引。领导者仅公开到高水位线索引的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Kafka：为了处理非可重复读取并确保数据一致性，Kafka broker会跟踪高水位线，这是特定分区的最大偏移量。使用者只能看到高水位线之前的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;10、租约（Lease）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;租约就像一个锁，但即使客户端离开，它也能工作。客户端请求有限期限的租约，之后租约到期。如果客户端想要延长租约，它可以在租约到期之前续订租约。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Chubby客户端与领导者保持有时限的会话租约。在此时间间隔内，领导者保证不会单方面终止会话。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;11、Gossip协议&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Gossip协议是点对点通信机制，其中节点定期交换有关自己和他们所知道的其他节点的状态信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;每个节点每秒启动一轮Gossip回合，以与另一个随机节点交换有关自己和其他节点的状态信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0096385542168675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk57w9icCtUnM7GDQWj267GAibtxDRTJO5mZCUjnKgriaCLSGwCW7YRa21cJaEGdqUic1rzfA2ib9ibMXvyGQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;415&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;12、Phi 累计故障检测（Phi Accrual Failure Detection）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;此算法使用历史检测信号信息使阈值自适应。通用的应计故障检测器不会判断服务器是否处于活动状态，而是输出有关服务器的可疑级别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Cassandra使用Phi应计故障检测器算法来确定群集中节点的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;13、脑裂&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;分布式系统具有两个或多个活动领导者的场景称为脑裂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;通过使用生成时钟（Generation Clock）可以解决脑裂问题，生成时钟只是一个单调递增的数字，用于指示服务器的生成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;每次选出新领导者时，时钟数字（generation number）都会增加。这意味着，如果旧领导者的时钟数为“1”，则新领导人的时钟数将为“2”。此时钟号包含在从领导发送到其他节点的每个请求中。通过这种方式，节点现在可以通过简单地信任具有最高数字的领导者来轻松区分真正的领导者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Kafka：为了处理脑裂（我们可以有多个active controller broker），Kafka使用“纪元数”（Epoch number），这只是一个单调增加的数字来表示服务器的代次（generation）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;HDFS：ZooKeeper用于确保任何时候只有一个NameNode处于活动状态。epoch编号作为每个事务ID的一部分进行维护，以反映NameNode的代次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;14、校验和（checksum）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在分布式系统中，在组件之间移动数据时，从节点获取的数据可能会损坏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;计算校验和并将其与数据一起存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;要计算校验和，请使用MD5、SHA-1、SHA-256或SHA-512等加密哈希函数。哈希函数获取输入数据并生成固定长度的字符串（包含字母和数字）；此字符串称为校验和。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;当系统存储某些数据时，它会计算数据的校验和，并将校验和与数据一起存储。当客户端检索数据时，它会验证从服务器接收的数据是否与存储的校验和匹配。如果没有，则客户端可以选择从另一个副本检索该数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;HDFS和Chubby将每个文件的校验和与数据一起存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;15、CAP定理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;CAP定理指出，分布式系统不可能同时提供以下所有三个理想属性：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一致性（C）、可用性（A）和分区容差（P）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;根据CAP定理，任何分布式系统都需要从三个属性中选择两个。这三个选项是CA、CP和AP。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Dynamo：在CAP定理术语中，Dynamo属于AP系统的类别，旨在牺牲强一致性为代价实现高可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BigTable：就CAP定理而言，BigTable是一个CP系统，即它具有严格一致的读取和写入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;16、PACELEC定理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;PACELC定理指出，在复制数据的系统中：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6628498727735369&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk57w9icCtUnM7GDQWj267GAibtyjLro5JTREickNrz0pQd55FVRVA7fVX4H5hT0twN68bibowRlQDBd6gA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;定理（PAC）的第一部分与CAP定理相同，ELC是扩展。整个论点假设我们通过复制来保持高可用性。因此，当失败时，CAP定理占上风。但如果没有，我们仍然必须考虑复制系统的一致性和延迟之间的权衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;17、提示交接（Hinted Handoff）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果节点关闭，系统会保留它们错过的所有请求的提示（或注释）。故障节点恢复后，将根据存储的提示将请求转发给它们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;当节点关闭时，领导者会在本地磁盘上的文本文件中写入提示。此提示包含数据及其所属的节点信息。当领导者意识到它为其保留提示的节点已恢复时，它会将每个提示的写入请求转发到该节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;18、读取时修复&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在分布式系统中，数据跨多个节点复制，某些节点最终可能会拥有过时的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在读取操作期间修复过时的数据，因为此时，我们可以从多个节点读取数据以进行比较并找到具有过时数据的节点。此机制称为读取修复。一旦已知具有旧数据的节点，读取修复操作就会将较新版本的数据推送到具有较旧版本的节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Cassandra和Dynamo使用“读取修复”将最新版本的数据推送到具有旧版本的节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;19、默克尔树（Merkle Trees）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;“读取修复”可在处理读取请求时消除冲突。但是，如果某个副本明显落后于其他副本，则可能需要很长时间才能解决冲突。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;副本可以包含大量数据。单纯地拆分整个范围来计算校验和进行比较并不是很可行；有太多的数据需要传输。相反，我们可以使用Merkle树来比较一个范围的副本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Merkle树是哈希的二叉树，其中每个内部节点是其两个子节点的哈希，每个叶节点是原始数据一部分的哈希。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5011709601873536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk57w9icCtUnM7GDQWj267GAibtnuw9GHAZOD8zEUGUnWZZp8ZMqXqMMbYgz3KapCEab4JwpxOKOjylBQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;854&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;比较Merkle树在概念上很简单：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;比较两个树的根哈希。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果它们相等，请停止。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在左边和右边的孩子上递归检查。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;为了实现反熵和在后台解决冲突，Dynamo使用Merkle树。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;107447&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;218:358&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 往期推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;144&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;144&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWH0hficYGBZI8qZSNxI5FiadxVSicSfvTZSNbNJGbX8d3bNJbTg1HfvOEIbM2rVa8I078ibV7wcKys75w/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;长按二维码关注&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;以分布式设计、架构、体系思想为基础，兼论研发相关的点点滴滴，不限于代码、质量体系和研发管理。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>982de49246dbe7457d4c236efb7332ba</guid>
<title>鹅厂后台大佬教你 Go 内存管理</title>
<link>https://toutiao.io/k/glsxmhr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;导语 | &lt;/span&gt;&lt;span&gt;本文推选自腾讯云开发者社区-【技思广益 · 腾讯技术人原创集】专栏。该专栏是腾讯云开发者社区为腾讯技术人与广泛开发者打造的分享交流窗口。栏目邀约腾讯技术人分享原创的技术积淀，与广泛开发者互启迪共成长。本文作者是腾讯后台开发工程师罗元国。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FiaZYIGick0nWJJXC1lSLI8zy2asbcicfNgvgJXexvB9rOnicPxbKFdEibPg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;栈内存&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;栈区的内存由编译器自动进行分配和释放，栈区中存储着函数的参数以及局部变量，它们会随着函数的创建而创建，函数的返回而销毁。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每个goroutine都维护着一个自己的栈区，这个栈区只能自己使用不能被其他goroutine使用。栈区的初始大小是2KB。&lt;/span&gt;&lt;/section&gt;&lt;p msthash=&quot;3577173&quot; msttexthash=&quot;143274001&quot;&gt;&lt;/p&gt;&lt;p msthash=&quot;3577173&quot; msttexthash=&quot;143274001&quot;&gt;&lt;span&gt;栈内存空间、结构和初始大小经过了几个版本的更迭：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p msthash=&quot;3577174&quot; msttexthash=&quot;163334327&quot;&gt;&lt;/p&gt;&lt;p msthash=&quot;3577174&quot; msttexthash=&quot;163334327&quot;&gt;&lt;span&gt;栈结构经过了分段栈到连续栈的发展过程，介绍如下。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9F812pnpTVKsrLmlcKHlIuuBvuwqeIqmOLOsD9nTpkow7FlAh45LKRLA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;h2 name=&quot;%E5%88%86%E6%AE%B5%E6%A0%88&quot; msthash=&quot;365807&quot; msttexthash=&quot;7894354&quot;&gt;&lt;span&gt;分段栈&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;随着goroutine调用的函数层级的深入或者局部变量需要的越来越多时，运行时会调用runtime.morestack和runtime.newstack创建一个新的栈空间，这些栈空间是不连续的，但是当前goroutine的多个栈空间会以双向链表的形式串联起来，运行时会通过指针找到连续的栈片段。如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;3577176&quot; msttexthash=&quot;12484498&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9372549019607843&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97VSPuVgbYx9q2TXGcrEriaIibyBHJUuNNsE8833eIQPtLl8VF77250SBNWzibnZpicbyY6a5WRSTLA2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;510&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按需为当前&lt;span&gt;goroutine&lt;/span&gt;分配内存并且及时减少内存的占用。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;3577178&quot; msttexthash=&quot;13605800&quot;&gt;&lt;/p&gt;&lt;p msthash=&quot;3577178&quot; msttexthash=&quot;13605800&quot;&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果当前&lt;span&gt;goroutine&lt;/span&gt;的栈几乎充满，那么任意的函数调用都会触发栈的扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题（Hot split）。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;3577180&quot; msttexthash=&quot;264740697&quot;&gt;&lt;/p&gt;&lt;p msthash=&quot;3577180&quot; msttexthash=&quot;264740697&quot;&gt;&lt;span&gt;为了解决这个问题，Go在1.2版本的时候不得不将栈的初始化内存从4KB增大&lt;/span&gt;&lt;span&gt;到了8KB。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;47&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9Fl62j5eylelCcZwNOEv5HRg9xicSj2KIwvdQMPbwiau3eqyIUpKbjQ6nA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h2 name=&quot;%E8%BF%9E%E7%BB%AD%E6%A0%88&quot; msthash=&quot;376935&quot; msttexthash=&quot;9846746&quot;&gt;&lt;span&gt;连续栈&lt;/span&gt;&lt;/h2&gt;&lt;p msthash=&quot;3577181&quot; msttexthash=&quot;1781696839&quot;&gt;&lt;/p&gt;&lt;p msthash=&quot;3577181&quot; msttexthash=&quot;1781696839&quot;&gt;&lt;span&gt;连续栈可以解决分段栈中存在的两个问题，其核心原理就是每当程序的栈空间不足时，初始化一片比旧栈大两倍的新栈并将原栈中的所有值都迁移到新的栈中，新的局部变量或者函数调用就有了充足的内存空间。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;3577182&quot; msttexthash=&quot;126128249&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6124314442413162&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97VSPuVgbYx9q2TXGcrEriaIplLnBoBaTD1TT4ib7AkqtwIlnG0Xibib13aH66Do0cXF1icJoVUBHv58UQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;547&quot;/&gt;&lt;/p&gt;&lt;p msthash=&quot;3577182&quot; msttexthash=&quot;126128249&quot;&gt;&lt;/p&gt;&lt;p msthash=&quot;3577182&quot; msttexthash=&quot;126128249&quot;&gt;&lt;span&gt;栈空间不足导致的扩容会经历以下几个步骤：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FPB6mZB01WGXHsGUE2UYENHAJNeKa8y0qwiajZdfHR5lvk4rjnrQabwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h2 name=&quot;%E6%A0%88%E7%AE%A1%E7%90%86&quot; msthash=&quot;361517&quot; msttexthash=&quot;9190142&quot;&gt;&lt;span&gt;栈管理&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Span除了用作堆内存分配外，也用于栈内存分配，只是用途不同的Span对应的mSpan状态不同。用做堆内存的mSpan状态为mSpanInUse，而用做栈内存的状态为mSpanManual。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;栈空间在运行时中包含两个重要的全局变量，分别是runtime.stackpool和runtime.stackLarge，这两个变量分别表示全局的栈缓存和大栈缓存，前者可以分配小于32KB的内存，后者用来分配大于32KB的栈空间。&lt;/span&gt;&lt;/section&gt;&lt;p cid=&quot;n38&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n38&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;为提高栈内存分配效率，调度器初始化时会初始化两个用于栈分配的全局对象：stackpool和stackLarge，介绍如下。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 cid=&quot;n39&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（一）StackPool&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;stackpool面向32KB以下的栈分配，栈大小必须是2的幂，最小2KB，在Linux环境下，stackpool提供了2kB、4KB、8KB、16KB四种规格的mSpan链表。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5024630541871922&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97VSPuVgbYx9q2TXGcrEriaIN06hEUSOrvcBJibuwgUe9SqtkZgBgMsbIPKGsfVD0xZhyU0pMwmeiamQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;stackpool结构定义如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; stackpool [_NumStackOrders]&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  item stackpoolItem&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__number&quot;&gt;_&lt;/span&gt;    [cpu.&lt;span class=&quot;code-snippet__type&quot;&gt;CacheLinePadSize&lt;/span&gt; - unsafe.&lt;span class=&quot;code-snippet__type&quot;&gt;Sizeof&lt;/span&gt;(stackpoolItem{})%cpu.&lt;span class=&quot;code-snippet__type&quot;&gt;CacheLinePadSize&lt;/span&gt;]byte&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type stackpoolItem &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  mu   mutex&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  span mSpanList&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type mSpanList &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  first *mspan &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  last  *mspan &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 cid=&quot;n44&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（二）StackLarge&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n45&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n45&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;大于等于32KB的栈，由stackLarge来分配，这也是个mSpan链表的数组，长度为25。mSpan规格从8KB开始，之后每个链表的mSpan规格都是前一个的两倍。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46134347275031684&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97VSPuVgbYx9q2TXGcrEriaIVtjRiaGxqJK8b4I4XS0h1wVRwG2R4PiaibiaYybUwGKvMs0alnF8XqxCpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n47&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;8KB和16KB这两个链表，实际上会一直是空的，留着它们是为了方便使用mSpan包含页面数的（以2为底）对数作为数组下标。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n48&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n48&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;stackLarge结构定义如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var stackLarge &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  lock mutex&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;free&lt;/span&gt; [heapAddrBits - pageShift]mSpanList &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type mSpanList &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  first *mspan &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  last  *mspan &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n51&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（三）内存分配&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n52&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n52&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果运行时只使用全局变量来分配内存的话，势必会造成线程之间的锁竞争进而影响程序的执行效率，栈内存由于与线程关系比较密切，所以在每一个线程缓存runtime.mcache中都加入了栈缓存减少锁竞争影响。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n53&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n53&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;同堆内存分配一样，每个P也有用于栈分配的本地缓存(mcache.stackcache)，这相当于是stackpool的本地缓存，在mcache中的定义如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; mcache &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  nextSample &lt;span class=&quot;code-snippet__keyword&quot;&gt;uintptr&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  scanAlloc  &lt;span class=&quot;code-snippet__keyword&quot;&gt;uintptr&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  tiny       &lt;span class=&quot;code-snippet__keyword&quot;&gt;uintptr&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  tinyoffset &lt;span class=&quot;code-snippet__keyword&quot;&gt;uintptr&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  tinyAllocs &lt;span class=&quot;code-snippet__keyword&quot;&gt;uintptr&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  alloc [numSpanClasses]*mspan &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  stackcache [_NumStackOrders]stackfreelist&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  flushGen &lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;stackcache [_NumStackOrders]stackfreelist即为栈的本地缓存，在Linux环境下，每个P本地缓存有4（_NumStackOrders）种规格的空闲内存块链表：2KB，4KB，8KB，16KB，定义如下所示：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;_NumStackOrders = &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt; - goarch.PtrSize/&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;*goos.IsWindows - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;*goos.IsPlan9&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n57&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;小于32KB的栈分配：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n60&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n62&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n64&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n65&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n65&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;大于等于32KB的栈分配：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n68&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n70&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n72&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 cid=&quot;n73&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（四）内存释放&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n74&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n74&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;什么时候释放栈？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n77&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n79&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n79&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果协程栈增长过，就把协程栈释放掉，再把协程放入到没有栈的空闲G队列中。而这些空闲协程的栈，也会在GC执行markroot时被释放掉，到时候这些协程也会加入到没有栈的空闲协程队列中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n79&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46458333333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97VSPuVgbYx9q2TXGcrEriaIcsjC29sETrEXxjg5A3YcQKJKmRDEUVdEP8KZ5a9Q2OFDSZC6kyICWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;480&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;所以，常规goroutine栈的释放，一是发生在协程运行结束时，gfput会把增长过的栈释放掉，栈没有增长过的g会被放入sched.gFree.stack中；二是GC会处理sched.gFree.stack链表，把这里面所有g的栈都释放掉，然后把它们放入sched.gFree.noStack链表中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n80&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;协程栈释放时是放回当前P的本地缓存？还是放回全局栈缓存？还是直接还给堆内存？&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 cid=&quot;n88&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（五）栈扩容&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在goroutine运行的时候栈区会按照需要增长和收缩，占用的内存最大限制的默认值在64位系统上是1GB。栈大小的初始值和上限这部分的设置都可以在Go的源码runtime/stack.go查看。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5439560439560439&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97VSPuVgbYx9q2TXGcrEriaIFbJSbERO1KwKzYH9rKoICxZ2ojSs0Hj0uKOwcJcia4SzulAN1xRkUVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;546&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扩容流程&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n94&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n96&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n97&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 cid=&quot;n97&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（六）栈缩容&lt;/span&gt;&lt;/h3&gt;&lt;h3 cid=&quot;n97&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 cid=&quot;n97&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;在goroutine运行的过程中，如果栈区的空间使用率不超过1/4，那么在垃圾回收的时候使用runtime.shrinkstack进行栈缩容，当然进行缩容前会执行一堆前置检查，都通过了才会进行缩容。&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n97&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;softbreak&quot;/&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://image-1306104315.cos.ap-guangzhou.myqcloud.com/blog/pic21.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49625468164794007&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97VSPuVgbYx9q2TXGcrEriaIgQlfLUADLaeQq7q7yibkp7VNuySevzFiaa3MW6dnM2T3USjl3Hzl8NTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;534&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 cid=&quot;n97&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 cid=&quot;n97&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;softbreak&quot;/&gt;&lt;span&gt;缩容流程：&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n98&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n104&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n104&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;唯一发起栈收缩的地方就是GC。GC通过scanstack函数寻找标记root节点时，如果发现可以安全的收缩栈，就会执行栈收缩，不能马上执行时，就设置栈收缩标识（g.preemptShrink=true），等到协程检测到抢占标识（stackPreempt）。在让出CPU之前会检查这个栈收缩标识，为true的话就会先进行栈收缩，再让出CPU。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;&lt;h1 cid=&quot;n106&quot; mdtype=&quot;heading&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;1.GoLang之栈内存管理&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;2.白话Go语言内存管理三部曲（二）解密栈内存管理&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;105&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;105&quot; data-fileid=&quot;100044396&quot; data-ratio=&quot;1.0203703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe97VSPuVgbYx9q2TXGcrEriaIJZybAvxOhEMm82jicQxZecElXkUZHPo1C1EFrnFeiby9GkrBI6n7UJQA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;罗元国&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯云开发者社区【技思广益·腾讯技术人原创集】作者&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;腾讯后台开发工程师，目前负责腾讯游戏广告推荐后台开发工作，在广告推荐和Golang性能优化方面有着丰富的开发经验。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>66d0a15815f1003f1ed8395bf3802006</guid>
<title>深入浅出学习透析 Nginx 服务器的基本原理和配置指南（负载均衡篇）</title>
<link>https://toutiao.io/k/kzt04re</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-atom-one-dark&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h2&gt;&lt;a id=&quot;_0&quot;/&gt;负载均衡&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;之前的章节内容中【深入浅出学习透析Nginx服务器的基本原理和配置指南「初级实践篇 」】和 【深入浅出学习透析Nginx服务器的基本原理和配置指南「进阶实践篇」】，我们采用的代理仅仅指向一个服务器。但是网站在实际运营过程中，大部分都是以集群的方式运行，这时需要使用负载均衡来分流。Nginx也可以实现简单的负载均衡功能。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;&lt;a id=&quot;NginxHTTP_5&quot;/&gt;Nginx作为HTTP负载均衡器&lt;/h2&gt; 
&lt;p&gt;Nginx是以高并发和内存占用少出名，它是一个http服务器，也是反向代理服务器，它更是负载均衡器。作为负载均衡器，在版本1.9之前，它只能作为http的负载均衡，也就是在网络模型的第七层发挥作用，1.9之后，它可以对tcp进行负载均衡，比如redis，mysql等。&lt;/p&gt; 
&lt;p&gt;负载均衡跨越多个应用程序实例，在多个应用实例间做负载均衡是一个被广泛使用的技术，其用于优化资源利用率、最大化吞吐量、减少延迟和确保容错配置。可以使用Nginx作为高效的HTTP负载均衡器，将流量分布到多个应用服务器，并通过Nginx 提高 web 应用程序的性能、可扩展性和可靠性。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Nginx_11&quot;/&gt;Nginx的负载均衡方法&lt;/h3&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/87f85e2ff9f078f4957ca4d7d4900fe7.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;Nginx 提供了多种负载均衡策略，常用的支持以下负载均衡机制：&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;轮询（round-robin） - 发送给应用服务器的请求以轮询的方式分发&lt;/li&gt;&lt;li&gt;加权轮询（weight-round-robin）&lt;/li&gt;&lt;li&gt;最少连接（least-connected） - 下一个请求被分配给具有最少数量活动连接的服务器&lt;/li&gt;&lt;li&gt;加权最少连接（weight-least-connected）&lt;/li&gt;&lt;li&gt;ip 哈希（ip-hash） - 使用哈希函数确定下一个请求应该选择哪一个服务器（基于客户端的 IP 地址）&lt;/li&gt;&lt;li&gt;普通 Hash（url-hash）- request_uri，一个简单的负载均衡的示例，把url均衡到不同的服务器，也可以改为均衡到不同的地址上。&lt;/li&gt;&lt;/ul&gt; 
&lt;h3&gt;&lt;a id=&quot;Nginx_24&quot;/&gt;Nginx的负载均衡语法&lt;/h3&gt; 
&lt;h4&gt;&lt;a id=&quot;upstream_26&quot;/&gt;upstream指令&lt;/h4&gt; 
&lt;p&gt;upstream指令用于定义服务器集群。服务器可以监听在不同端口。另外，监听在TCP和UNIX-domain socket的服务器可以混合使用。默认，使用带权重的round-robin平衡算法将请求分派到服务器。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;http {
     upstream [你的负载均衡机制名称，随便设置一个就好] {
 server [ip地址]:[端口值];
 server [ip地址]:[端口值];
 server [ip地址]:[端口值];
 server [ip地址]:[端口值];
 }
 server {
 listen [nginx监听端口];
 server_name [head中的host对应的值]
 location / {
   proxy_pass http:// [你的负载均衡机制名称，对应上面upstream的值];
         }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;&lt;a id=&quot;_48&quot;/&gt;默认负载均衡配置&lt;/h3&gt; 
&lt;p&gt;使用Nginx进行负载均衡的最简单配置如下所示：&lt;/p&gt; 
&lt;p&gt;在上述案例中，在 【www.address1.com】、【www.address2.com】、【www.address3.com】，我们需要启动暴漏运行相同的应用的三个实例。当负载均衡方法没有被特别配置时，默认采用轮询（round-robin）。所有请求都被代理到服务器组loadBalanceServer，Nginx应用 HTTP 负载均衡来分发请求。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;http {
    upstream loadBalanceServer {
        server www.address1.com; // 或者ip+端口 ， 不需要加入http/https前缀
        server www.address2.com;
        server www.address3.com;
    }
    server {
        listen 80;
        location / {
            proxy_pass http://loadBalanceServer;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;Nginx中的反向代理实现包括 HTTP、HTTPS、FastCGI、uwsgi、SCGI 和 memcached。要配置 HTTPS 而不是 HTTP 负载均衡，只需要使用 HTTPS 协议。在为 FastCGI、uwsgi、SCGI 或 memcached 设置负载均衡时，分别使用 fastcgi_pass、uwsgi_pass、scgi_pass 和 memcached_pass 指令。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_73&quot;/&gt;最少连接负载均衡&lt;/h3&gt; 
&lt;ul&gt;&lt;li&gt;负载均衡的规则是最少连接。在一些请求需要更长的时间才能完成的情况下，最少连接可以更公正地控制应用程序实例的负载。使用最少连接的负载均衡，nginx 将尽量不给过于繁忙的应用服务器负载过多的请求，而是将新的请求分发到不太忙的服务器。&lt;/li&gt;&lt;li&gt;当使用 least_conn 指令作为服务组配置的一部分时，将激活 nginx 中的最少连接负载均衡：&lt;/li&gt;&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;http {
    upstream leastConnLoadBalanceServer {
        least_conn;
        server www.address1.com; // 或者ip+端口 ， 不需要加入http/https前缀
        server www.address2.com;
        server www.address3.com;
    }
    server {
        listen 80;
        location / {
            proxy_pass http://loadBalanceServer;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;&lt;a id=&quot;IP_95&quot;/&gt;IP哈希负载均衡&lt;/h3&gt; 
&lt;p&gt;配置 IP 哈希负载均衡，只需要将 &lt;strong&gt;ip_hash&lt;/strong&gt; 指令添加到服务器 upstream 组配置中即可：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;http {
upstream ipHashLoadBalanceServer {
        ip_hash;
        server www.address1.com; // 或者ip+端口 ， 不需要加入http/https前缀
        server www.address2.com;
        server www.address3.com;
    }
    server {
        listen 80;
        location / {
            proxy_pass http://loadBalanceServer;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;&lt;a id=&quot;_Hash_116&quot;/&gt;普通 Hash&lt;/h3&gt; 
&lt;p&gt;主要根据url进行hash计算处理操作，没啥可讲解的&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;http {
upstream ipHashLoadBalanceServer {
     hash $request_uri;
        server www.address1.com; // 或者ip+端口 ， 不需要加入http/https前缀
        server www.address2.com;
        server www.address3.com;
    }
    server {
        listen 80;
        location / {
            proxy_pass http://loadBalanceServer;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;&lt;a id=&quot;_137&quot;/&gt;加权负载均衡&lt;/h3&gt; 
&lt;p&gt;可以通过使用服务器权重进一步加强Nginx的负载均衡算法。&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;在上面的示例中，服务器权重没有被配置，这意味对于特定的负载均衡方法来说所有指定的服务器都具有同等资格。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;特别是使用轮询方式，这也意味着服务器上的请求分配或多或少都是相等的 —— 只要有足够的请求，并且以统一的方式足够快速地完成请求处理。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;当服务器指定 weight 参数时，权重将作为负载均衡决策的一部分进行核算, weigth参数表示权值，权值越高被分配到的几率越大，默认情况下（轮询）所有服务器权重为 1。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt; http {
upstream ipHashLoadBalanceServer {
        ip_hash;
        server www.address1.com weight=3;// 或者ip+端口 ， 不需要加入http/https前缀
        server www.address2.com; // default weight=1
        server www.address3.com;
    }
    server {
        listen 80;
        location / {
            proxy_pass http://loadBalanceServer;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;在 nginx 的最近版本中，可以在最少连接和 IP 哈希负载均衡中使用权重。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;&lt;a id=&quot;_167&quot;/&gt;最少连接负载均衡（加权）&lt;/h3&gt; 
&lt;pre&gt;&lt;code&gt;http {
    upstream leastConnLoadBalanceServer {
        least_conn;
        server www.address1.com; // 或者ip+端口 ， 不需要加入http/https前缀
        server www.address2.com weight=3;
        server www.address3.com;
    }
    server {
        listen 80;
        location / {
            proxy_pass http://loadBalanceServer;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;&lt;a id=&quot;_186&quot;/&gt;会话持久化&lt;/h4&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;使用轮询或者最少连接的负载均衡，每个后续客户端的请求都可能被分配到不同的服务器。不能保证同一个客户端始终指向同一个服务器。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;如果需要将客户端绑定到特定的应用服务器，换而言之，使客户端会话「粘滞」或者「永久」，始终尝试选择特定的服务器，IP 哈希负载均衡机制可以做到这点。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;使用 IP 哈希，客户端的 IP 地址用作为哈希键，以确定应用为客户端请求选择服务器组中的哪个服务器。此方法确保了来自同一个客户端的请求始终被定向到同一台服务器，除非该服务器不可用。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;h3&gt;&lt;a id=&quot;Nginx_194&quot;/&gt;Nginx健康检查&lt;/h3&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;Nginx中的反向代理实现包括了带内（或者被动）服务器健康检查。如果特定服务器的响应失败并出现错误，则 nginx 会将此服务器标记为失败，并尝试避免为此后续请求选择此服务器而浪费一段时间。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;max_fails 用于设置在 fail_timeout 期间与服务器通信失败重新尝试的次数。默认情况下，max_fails 设置为 1。当设置为 0 时，该服务器的健康检查将被禁用。fail_timeout 参数还定义了服务器被标记为失败的时间。在服务器发生故障后的 fail_timeout 间隔后，nginx 开始以实时客户端的请求优雅地探测服务器。如果探测成功，则将服务器标记为活动。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;h3&gt;&lt;a id=&quot;_201&quot;/&gt;故障下线和备份服务设置&lt;/h3&gt; 
&lt;h4&gt;&lt;a id=&quot;down_203&quot;/&gt;down&lt;/h4&gt; 
&lt;p&gt;假如有一台主机是出了故障，或者下线了，要暂时移出，那可以把它标为down，表示请求是会略过这台主机的。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;upstream downServer {
        server www.address1.com; // 或者ip+端口 ， 不需要加入http/https前缀
        server www.address2.com down;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;&lt;a id=&quot;backup_214&quot;/&gt;backup&lt;/h4&gt; 
&lt;p&gt;backup是指备份的机器，相对于备份的机器来说，其他的机器就相当于主要服务器，只要当主要服务器不可用的时候，才会用到备用服务器。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;upstream backupServer {
        server www.address1.com; // 或者ip+端口 ， 不需要加入http/https前缀
        server www.address2.com backup;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;&lt;a id=&quot;max_failsfail_timeout_225&quot;/&gt;max_fails和fail_timeout&lt;/h4&gt; 
&lt;p&gt;默认情况下，max_fails的值为1，表示的是请求失败的次数，请求1次失败就换到下台主机。另外还有一个参数是fail_timeout，表示的是请求失败的超时时间，在设定的时间内没有成功，那作为失败处理。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;upstream backupServer {
        server www.address1.com max_fails=2; // 或者ip+端口 ， 不需要加入http/https前缀
        server www.address2.com backup;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;那什么情况才叫请求失败呢？有可能是服务器内部错误，超时，无效的头部，或返回500以上的状态码的时候。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Nginx_239&quot;/&gt;Nginx实际案例配置&lt;/h3&gt; 
&lt;h4&gt;&lt;a id=&quot;nginxconf__241&quot;/&gt;nginx.conf 配置如下：&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;http {
     #设定mime类型,类型由mime.type文件定义
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    #设定日志格式
    access_log    /var/log/nginx/access.log;
    #设定负载均衡的服务器列表
    upstream load_balance_server {
        #weigth参数表示权值，权值越高被分配到的几率越大
        server 192.168.1.11:80   weight=5;
        server 192.168.1.12:80   weight=1;
        server 192.168.1.13:80   weight=6;
    }
   #HTTP服务器
   server {
        #侦听80端口
        listen       80;
        #定义使用www.xx.com访问
        server_name  www.helloworld.com;
        #对所有请求进行负载均衡请求
        location / {
            root        /root;                 #定义服务器的默认网站根目录位置
            index       index.html index.htm;  #定义首页索引文件的名称
            proxy_pass  http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表
            #以下是一些反向代理的配置(可选择性配置)
            #proxy_redirect off;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
            proxy_set_header X-Forwarded-For $remote_addr;
            proxy_connect_timeout 90;          #nginx跟后端服务器连接超时时间(代理连接超时)
            proxy_send_timeout 90;             #后端服务器数据回传时间(代理发送超时)
            proxy_read_timeout 90;             #连接成功后，后端服务器响应时间(代理接收超时)
            proxy_buffer_size 4k;              #设置代理服务器（nginx）保存用户头信息的缓冲区大小
            proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
            proxy_busy_buffers_size 64k;       #高负荷下缓冲大小（proxy_buffers*2）
            proxy_temp_file_write_size 64k;    #设定缓存文件夹大小，大于这个值，将从upstream服务器传
            client_max_body_size 10m;          #允许客户端请求的最大单文件字节数
            client_body_buffer_size 128k;      #缓冲区代理缓冲用户端请求的最大字节数
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;&lt;a id=&quot;1_288&quot;/&gt;里面没有介绍的不用担心，后面我会专门讲解介绍和说明对应的参数，大多数都属于优化和传输方面的参数1&lt;/h2&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>