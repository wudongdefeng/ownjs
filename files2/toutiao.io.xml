<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0646f20199904f04cc9e32a9cbe74f23</guid>
<title>优质网站同好者周刊（第 079 期） | 倾城博客</title>
<link>https://toutiao.io/k/iku9a8l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%8D%9A%E5%AE%A2&quot;&gt;&lt;code&gt;博客&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/SEO&quot;&gt;&lt;code&gt;SEO&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8&quot;&gt;&lt;code&gt;网站生成器&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：WordPress alternative, Medium alternative, Fast blogging platform, Light-weight blogging platform, Simple blog platform, Ghost Alternative, Easy blogging platform, Minimal blogging platform&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The fast, light-weight, and SEO friendly WordPress blog alternative you have been searching for. Generate more traffic and leads with superblog&#x27;s built-in best practices.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/superblog.ai.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Superblog: Fast, light, and beautiful blogging platform&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：Superblog 一个速度极快的博客平台，内置了最佳实践；是 WordPress 和 Medium 博客的快速替代品。针对 &lt;a href=&quot;https://nicelinks.site/tags/SEO&quot;&gt;SEO&lt;/a&gt;、转换和速度进行了自动优化，无需设置、维护，以便您可以专注于编写内容。它具有以下功能特色：&lt;/p&gt;&lt;h3 id=&quot;读者愿意阅读更多&quot;&gt;&lt;a href=&quot;#%E8%AF%BB%E8%80%85%E6%84%BF%E6%84%8F%E9%98%85%E8%AF%BB%E6%9B%B4%E5%A4%9A&quot; aria-label=&quot;读者愿意阅读更多 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;读者愿意阅读更多&lt;/h3&gt;&lt;p&gt;Superblog 具有漂亮的设计、字体、文本间距和可读性。您需要做的就是选择布局、选择品牌颜色并连接您的域。&lt;/p&gt;&lt;h3 id=&quot;已经优化的-seo&quot;&gt;&lt;a href=&quot;#%E5%B7%B2%E7%BB%8F%E4%BC%98%E5%8C%96%E7%9A%84-seo&quot; aria-label=&quot;已经优化的 seo permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;已经优化的 SEO&lt;/h3&gt;&lt;p&gt;自动在 SEO、Google Lighthouse 和 Core Web Vitals 中获得高分。您无需聘请专家即可获得这些黄金标准。&lt;/p&gt;&lt;h3 id=&quot;花时间写作而不是维护&quot;&gt;&lt;a href=&quot;#%E8%8A%B1%E6%97%B6%E9%97%B4%E5%86%99%E4%BD%9C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BB%B4%E6%8A%A4&quot; aria-label=&quot;花时间写作而不是维护 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;花时间写作，而不是维护&lt;/h3&gt;&lt;p&gt;使用 Superblog 提供的智能编辑器，以编写更好的内容。获取帖子的实时提示。Superblog 将自动修复页面上的 SEO 错误。&lt;/p&gt;&lt;h3 id=&quot;支持黑暗主题&quot;&gt;&lt;a href=&quot;#%E6%94%AF%E6%8C%81%E9%BB%91%E6%9A%97%E4%B8%BB%E9%A2%98&quot; aria-label=&quot;支持黑暗主题 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;支持黑暗主题&lt;/h3&gt;&lt;p&gt;Superblog 有一个漂亮的黑暗模式。它将顺利流入您的深色主题网站。&lt;/p&gt;&lt;h3 id=&quot;隐私友好型分析&quot;&gt;&lt;a href=&quot;#%E9%9A%90%E7%A7%81%E5%8F%8B%E5%A5%BD%E5%9E%8B%E5%88%86%E6%9E%90&quot; aria-label=&quot;隐私友好型分析 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;隐私友好型分析&lt;/h3&gt;&lt;p&gt;Superblog 具有内置分析功能，可帮助您了解哪些博客文章表现良好。您可以查看重要指标，例如在页面上花费的时间、跳出率、唯一访问者、国家/地区等。通过使用 Superblog，您无需向博客访问者显示 cookie 弹出通知。&lt;/p&gt;&lt;h3 id=&quot;更多的功能特征&quot;&gt;&lt;a href=&quot;#%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%8A%9F%E8%83%BD%E7%89%B9%E5%BE%81&quot; aria-label=&quot;更多的功能特征 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;更多的功能特征&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;访问速度总是很快；&lt;/li&gt;&lt;li&gt;支持连接您自己的域名；&lt;/li&gt;&lt;li&gt;免费的 SSL 和 CDN；&lt;/li&gt;&lt;li&gt;无需服务器维护；&lt;/li&gt;&lt;li&gt;自动图像优化；&lt;/li&gt;&lt;li&gt;自动站点地图；&lt;/li&gt;&lt;li&gt;99.99% 正常运行时间；&lt;/li&gt;&lt;li&gt;团队成员和角色；&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;为什么超级博客这么快&quot;&gt;&lt;a href=&quot;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%85%E7%BA%A7%E5%8D%9A%E5%AE%A2%E8%BF%99%E4%B9%88%E5%BF%AB&quot; aria-label=&quot;为什么超级博客这么快 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;为什么超级博客这么快？&lt;/h3&gt;&lt;p&gt;Superblog 对您的博客进行智能优化。它预先构建您的整个博客，并将页面、图像存储在世界各地的许多服务器上。每当用户访问您的网站时，您网站的预构建缓存副本都会显示在距用户位置最近的服务器上。Superblog 是一个 JAMStack 博客平台。&lt;/p&gt;&lt;p&gt;使用 Superblog，您无需担心最佳实践、SEO 审核和管理您的服务器。您可以完全专注于编写内容。其余全部由超级博客自动处理。您可以在不到 5 分钟的时间内，从 &lt;a href=&quot;https://nicelinks.site/post/602e4a576eaf2a7660805af1&quot;&gt;WordPress&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/5c3f3151a5957e07a40b30ff&quot;&gt;Ghost&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/5a7586d3ff655e7a265b8e93&quot;&gt;Medium&lt;/a&gt; 和 Blogger 迁移到 Superblog（超级博客）。值得说明的是 Superblog 仅支持 7 天免费可用，其针对个人和爱好项目所提供的基本（BASIC）版本，$9 每月。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62fe5b3828190628135d6764&quot;&gt;倾城之链 - Superblog: Fast, light, and beautiful blogging platform&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/HTTP&quot;&gt;&lt;code&gt;HTTP&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C&quot;&gt;&lt;code&gt;命令行&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/API&quot;&gt;&lt;code&gt;API&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Making APIs simple and intuitive for those building the tools of our time.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/httpie.io.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - HTTPie – API testing client that flows with you&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：HTTPie（发音为 &lt;code&gt;/aitch-tee-tee-pie/&lt;/code&gt;）是一个命令行 HTTP 客户端。它的目标是：使 CLI 与 Web 服务的交互尽可能人性化。HTTPie 设计用于&lt;strong&gt;测试&lt;/strong&gt;、&lt;strong&gt;调试&lt;/strong&gt;以及通常与 API 和 HTTP 服务器交互。&lt;code&gt;http&lt;/code&gt;&amp;amp;&lt;code&gt;https&lt;/code&gt; 命令允许创建和发送任意 HTTP 请求。它们使用简单自然的语法，并提供格式化和彩色输出。它具有以下功能特征：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;富有表现力和直观的语法；&lt;/li&gt;&lt;li&gt;格式化和彩色终端输出；&lt;/li&gt;&lt;li&gt;内置 JSON 支持；&lt;/li&gt;&lt;li&gt;表格和文件上传；&lt;/li&gt;&lt;li&gt;HTTPS、代理和身份验证；&lt;/li&gt;&lt;li&gt;任意请求数据；&lt;/li&gt;&lt;li&gt;自定义标题；&lt;/li&gt;&lt;li&gt;持续会话；&lt;/li&gt;&lt;li&gt;&lt;code&gt;wget&lt;/code&gt;- 类似下载；&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;如何安装&quot;&gt;&lt;a href=&quot;#%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85&quot; aria-label=&quot;如何安装 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;如何安装？&lt;/h3&gt;&lt;p&gt;HTTPie 推出了用于 Web 和桌面的 HTTPie（目前处于&lt;strong&gt;公测&lt;/strong&gt;中），终端版本的所有用户友好性，现在都包含在一个时尚的图形界面中。所以，如果您愿意的话，可以直接 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://httpie.io/app&quot;&gt;在线使用&lt;/a&gt; ；而终端版本的 HTTPie，您可以基于太多工具来安装它，如 brew、snap、apt 等等，如果您想了解更多安装方式，可参见： &lt;a href=&quot;https://nicelinks.site/redirect?url=https://httpie.io/docs/cli/installation&quot;&gt;HTTPie Install&lt;/a&gt; 。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bsh&quot;&gt;# brew，MacOS
brew install httpie

# apt
apt install httpie

# choco
choco install httpie

# pip
pip install httpie

# port
port install httpie

# snap
snap install httpie

# yum
yum install httpie
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8&quot; aria-label=&quot;如何使用 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;如何使用？&lt;/h3&gt;&lt;p&gt;关于 HTTPie 如何使用，实在过于丰富，这里只是简单列举几个示例，详情请移步至 &lt;a href=&quot;https://httpie.io/docs/cli/usage&quot;&gt;HTTPie usage&lt;/a&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 发起简单 Get 请求
https httpie.io/hello
https nicelinks.site

# 自定义 HTTP 方法、HTTP 标头和 JSON 数据
http PUT pie.dev/put X-API-Token:123 name=John

# 下载文件并通过重定向输出保存
http pie.dev/image/png &amp;gt; image.png
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与 HTTPie 同类型的工具还有 &lt;a href=&quot;https://nicelinks.site/post/62556c92f3a35106466b76fe&quot;&gt;Curl&lt;/a&gt; 以及 &lt;a href=&quot;https://nicelinks.site/post/619ce835465c2155e2d1587f&quot;&gt;Hurl&lt;/a&gt;，只不过侧重点有所不同。HTTPie 更偏向于 API 测试；如果您的工作中较多涉及到 API 测试相关，相信 HTTPie 能够俘获您的心❤️。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62fe257028190628135d6762&quot;&gt;倾城之链 - HTTPie – API testing client that flows with you&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/AI&quot;&gt;&lt;code&gt;AI&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9B%BE%E7%89%87&quot;&gt;&lt;code&gt;图片&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%A8%8B%E5%BA%8F&quot;&gt;&lt;code&gt;程序&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：alternative, self-hosted, photo management, cloud, web3, decentralized, google photos, artificial intelligence, face recognition&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;AI-Powered Photos App for the Decentralized Web.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/photoprism.app.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Browse Your Life in Pictures – PhotoPrism&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：PhotoPrism® 是用于&lt;strong&gt;去中心化&lt;/strong&gt;网络的 &lt;a href=&quot;https://nicelinks.site/tags/AI&quot;&gt;AI&lt;/a&gt; 驱动的照片应用程序。它利用最新技术自动标记和查找图片，而不会妨碍您。您可以在家里、私人服务器或云端运行它。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;去中心化&lt;/strong&gt;是与中心化相对的一个概念，简单的来说中心化的意思，是中心决定节点。节点必须依赖中心，节点离开了中心就无法生存。去中心化恰恰相反，在一个分布有众多节点的系统中，每个节点都具有高度自治的特征，每一个节点都是一个“小中心”。该想法提出重组互联网，以移除集中式数据托管服务，转而使用点对点基础设施。由于各种原因，对网络维护组织缺乏信任，人们对去中心化网络产生了兴趣。随着网络服务形态的多元化，去中心化网络模型越来越清晰，也越来越成为可能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;PhotoPrism 的使命是：提供对用户和隐私最友好的解决方案，以使您的照片井井有条且易于访问。这就是为什么 PhotoPrism 从头开始构建，可以在您需要的任何地方运行，而不会影响自由、隐私或功能；它具有以下功能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;浏览所有照片和视频，无需担心 RAW 转换、重复或视频格式；&lt;/li&gt;&lt;li&gt;使用强大的搜索过滤器轻松查找特定图片；&lt;/li&gt;&lt;li&gt;识别您的家人和朋友的面孔；&lt;/li&gt;&lt;li&gt;根据内容和位置自动分类图片；&lt;/li&gt;&lt;li&gt;通过将鼠标悬停在相册和搜索结果中来播放实况照片；&lt;/li&gt;&lt;li&gt;由于用户界面是一个渐进式网页应用程序，它提供了一种原生应用程序般的体验，您可以方便地将其安装在所有主要操作系统和移动设备的主屏幕上；&lt;/li&gt;&lt;li&gt;包括四个高分辨率世界地图，带回您最喜欢的旅行的回忆；&lt;/li&gt;&lt;li&gt;元数据从 Exif、XMP 和其他来源（例如 Google 照片）中提取和合并；&lt;/li&gt;&lt;li&gt;还可以搜索更多图像属性，例如 Colors、Chroma 和 Quality；&lt;/li&gt;&lt;li&gt;使用 PhotoSync 在后台安全备份 iOS 和 Android 手机；&lt;/li&gt;&lt;li&gt;WebDAV 客户端（如 Microsoft 的 Windows Explorer 和 Apple 的 Finder）可以直接连接到 PhotoPrism，让您可以像在本地一样打开、编辑和删除计算机中的文件；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;PhotoPrism 项目在 &lt;a href=&quot;https://nicelinks.site/post/59ba80d93df6765c75b77911&quot;&gt;Github&lt;/a&gt; 开源，如果您对自己拥有的图片或视频，有较好的管理和较强的隐私要求，基于 &lt;a href=&quot;https://nicelinks.site/post/5b7036890f8719053c094d68&quot;&gt;Docker&lt;/a&gt; 在您的私人服务器部署一套 PhotoPrism 程序，在目前看来是很棒的选择。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62fde83d28190628135d6760&quot;&gt;倾城之链 - Browse Your Life in Pictures – PhotoPrism&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Mac&quot;&gt;&lt;code&gt;Mac&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B7%A5%E5%85%B7&quot;&gt;&lt;code&gt;工具&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E9%AB%98%E6%95%88&quot;&gt;&lt;code&gt;高效&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Bring System-level Arrange Window features to Mac.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/wins.cool.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Wins - Bring System-level Arrange Window features to Mac&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：Wins，为 Mac 带来系统级的分屏功能，可让您的窗口和工作区井井有条，通过拖动和快捷键触发；Wins 致力于以 Apple 的方式，将拆分窗口功能带入 Mac。系统级集成，效率高，使用 Wins 像 Mac 系统功能。它具有以下功能特色：&lt;/p&gt;&lt;h3 id=&quot;快速分屏&quot;&gt;&lt;a href=&quot;#%E5%BF%AB%E9%80%9F%E5%88%86%E5%B1%8F&quot; aria-label=&quot;快速分屏 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;快速分屏&lt;/h3&gt;&lt;p&gt;只需拖动窗口到屏幕边缘即可进行分屏操作。&lt;/p&gt;&lt;h3 id=&quot;丝滑动画&quot;&gt;&lt;a href=&quot;#%E4%B8%9D%E6%BB%91%E5%8A%A8%E7%94%BB&quot; aria-label=&quot;丝滑动画 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;丝滑动画&lt;/h3&gt;&lt;p&gt;Wins 提供了分屏预览动画和触发分屏后的动画效果（该团队认为动画是软件的灵魂）。&lt;/p&gt;&lt;h3 id=&quot;悬浮分屏&quot;&gt;&lt;a href=&quot;#%E6%82%AC%E6%B5%AE%E5%88%86%E5%B1%8F&quot; aria-label=&quot;悬浮分屏 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;悬浮分屏&lt;/h3&gt;&lt;p&gt;拖动任意窗口，即可看到悬浮分屏，拖动到悬浮分屏上可快速拆分窗口。&lt;/p&gt;&lt;h3 id=&quot;深色模式&quot;&gt;&lt;a href=&quot;#%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F&quot; aria-label=&quot;深色模式 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;深色模式&lt;/h3&gt;&lt;p&gt;支持「深色模式」模式，“紧随潮流”与你的 Mac 体验一致。&lt;/p&gt;&lt;h3 id=&quot;系统级集成&quot;&gt;&lt;a href=&quot;#%E7%B3%BB%E7%BB%9F%E7%BA%A7%E9%9B%86%E6%88%90&quot; aria-label=&quot;系统级集成 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;系统级集成&lt;/h3&gt;&lt;p&gt;Wins 没有独立窗口，不占用 Menu Bar、不占用 Dock 栏，设置面板集成在系统偏好设置中，提供更加纯净的用户体验。&lt;/p&gt;&lt;p&gt;性能卓越&lt;/p&gt;&lt;p&gt;Wins 非常在意功耗，内存占用低于 30M，CPU 使用低于 10%，大多数情况仅占用 0.1%。&lt;/p&gt;&lt;p&gt;Mac 是我最喜欢的生产力工具，没有之一；如果您需要经常操纵图形化界面，推荐看下 Wins 所展示的功能效果视频，相信有这样的工具加持，会让您的操作更加得心应手，效率也将随之提升。需要说明的是，Wins 支持 7 天免费试用；支付 13.99 美元，便能得到永久授权。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62fcd16128190628135d675e&quot;&gt;倾城之链 - Wins - Bring System-level Arrange Window features to Mac&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%90%9C%E7%B4%A2&quot;&gt;&lt;code&gt;搜索&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%95%E6%93%8E&quot;&gt;&lt;code&gt;引擎&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&quot;&gt;&lt;code&gt;机器学习&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Yandex is a search engine and web portal. Yandex offers internet search and other services like maps, navigator, public transport, taxi, weather, news, music, TV program, translation, online shopping, and more. Free email service and cloud storage.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/yandex.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Yandex&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：Yandex，是一家技术公司（俄罗斯重要网络服务门户之一），致力于构建由机器学习驱动的智能产品和服务。其目标是帮助消费者和企业更好地驾驭线上和线下世界。自 1997 年以来，提供了世界一流的本地相关搜索和信息服务，包括搜索、最新新闻、地图和百科、电子信箱、电子商务、互联网广告及其他服务。此外，还为全球数百万消费者开发了市场领先的按需交通服务、导航产品和其他移动应用程序。Yandex 在全球设有 30 个办事处。&lt;/p&gt;&lt;p&gt;Yandex 的历史始于 1990 年代初——远在公司成立之前。Yandex 作为一家公司出现在 2000 年，也就是门户网站 &lt;code&gt;yandex.ru&lt;/code&gt; 推出三年后。那时，新公司的工资单上只有 25 个名字，Yandex 处理的所有数据,都可以放在一个服务器上。现在，Yandex 在十个国家设有办事处和代表处，员工人数超过 18,000 人。在俄罗斯本土市场，在所有搜索流量中的份额为 61.0%（2022 年第一季度），此外还在白俄罗斯、哈萨克斯坦和土耳其开展业务。&lt;/p&gt;&lt;p&gt;Yandex 几乎一半的收入来自上下文广告，它根据网络用户的需求为产品和服务投放广告。其中 Yandex.Direct 服务是俄罗斯第一个，也是最大的基于文本的广告投放系统。除了在搜索结果页面上投放广告外，还在构成 Yandex 广告网络的数千个第三方网站上投放广告。该公司于 2002 年开始盈利，此后收入一直在持续增长。2011 年 5 月，Yandex 在纳斯达克证券交易所上市，股票代码为 YNDX。&lt;/p&gt;&lt;p&gt;搜索一直是并且仍然是 Yandex 的核心产品，但现在我们对它的作用有了更广泛的理解：它是一种万能辅助工具、助手，是我们周围一切事物的指南。这是关于在正确的地点和时间给出正确的建议，帮助做出选择，以及完成事情的可能性。Yandex 在其网站说到：其所有产品都旨在让人们的生活更轻松、更美好。每个都可以帮助用户做一些曾经看似不可能的事情。知道 Yandex 网站的存在，是因为发现&lt;a href=&quot;https://nicelinks.site/&quot;&gt;倾城之链&lt;/a&gt;越来越多流量来自于 Yandex 搜索；如果您想了解更多，可移步 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://yandex.com/company/general_info/yandex_today&quot;&gt;Yandex — Mission&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62fa2a0b28190628135d675a&quot;&gt;倾城之链 - Yandex&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%9E%84%E5%BB%BA&quot;&gt;&lt;code&gt;构建&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/JavaScript&quot;&gt;&lt;code&gt;JavaScript&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;&lt;code&gt;Web开发&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Rollup is a module bundler for JavaScript which compiles small pieces of code into something larger and more complex, such as a library or application. It uses the standardized ES module format for code, instead of previous idiosyncratic solutions such as CommonJS and AMD.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/rollupjs.org.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Next-generation ES module bundler ｜ Rollup&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：Rollup 是一个 JavaScript 的模块捆绑器，它将小块的代码编译成更大、更复杂的东西，如一个库或应用程序。它使用 JavaScript 的 ES6 修订版中包含的新的标准化的代码模块格式，而不是以前的特异性解决方案，如 CommonJS 和 AMD。ES 模块让你自由和无缝地结合你最喜欢的库中最有用的个别功能。这最终将在所有地方实现原生，但 Rollup 让你今天就能做到这一点。&lt;/p&gt;&lt;p&gt;Rollup 和 Webpack、Parcel、Vite 等工具很类似，但专注于 ES6 的模块打包。 其亮点在于能针对 ES6 源码进行 Tree Shaking 以去除那些已被定义但没被使用的代码，以及 Scope Hoisting 以减小输出文件大小提升运行性能。然而 Rollup 的这些亮点随后就被 Webpack 模仿和实现，但在使用上 Rollup 相对更简单一些；以下列举些 Webpack 与 Rollup 存在的差别：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rollup 是在 Webpack 流行后出现的替代品；&lt;/li&gt;&lt;li&gt;Rollup 生态链还不完善，体验不如 Webpack；&lt;/li&gt;&lt;li&gt;Rollup 功能不如 Webpack 完善，但其配置和使用更加简单；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然，Rollup 也存在一些不可忽视的缺点，诸如：开发服务器不能实现模块热更新，调试繁琐。Rollup 在用于打包 JavaScript 库时比 Webpack 更加有优势，因为其打包出来的代码更小更快。因此，如果需要构建一个类库，且只需要导入很少第三方库，推荐使用 Rollup；如果需要构建一个复杂的应用，需要集成很多第三方库，并且需要代码分拆、HMR（热更新） 等功能，推荐使用 Webpack；如果您对开发时构建速度有要求，那 &lt;a href=&quot;https://nicelinks.site/post/6010e1b10c71de1fb957b64e&quot;&gt;Vite&lt;/a&gt; 值得尝试。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62f8b9e030be9b2450762124&quot;&gt;倾城之链 - Next-generation ES module bundler ｜ Rollup&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;太上，不知有之；其次，亲而誉之；其次，畏之；其次，侮之。信不足焉，有不信焉。犹兮其贵言。功成事遂，百姓皆谓“我自然”。──春秋末期人 · 老子李耳《道德经》第十七章&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>36232eb932edd1315254a773b421da61</guid>
<title>细思恐极，插上 U 盘就开始执行 Python 代码</title>
<link>https://toutiao.io/k/g2lmfmc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;↓&lt;/span&gt;&lt;span&gt;推荐关注↓&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzA5MzUxMzg5NA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/AQF4KzdPxcice1Gv5eYdy8vZKxrd4GyjRFTsXmbMy0ibZV040KibVic7aPBoLuz1HHiadKEib0bblbPRXG5UCluia06lA/0?wx_fmt=png&quot; data-nickname=&quot;Python开发精选&quot; data-alias=&quot;BestPython&quot; data-signature=&quot;分享 Python 技术文章、资源、课程、资讯。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;一个突发奇想，当你把usb插进去的时候，能不能自动执行usb上的程序。查了一下，发现只有windows上可以，具体的大家也可以搜索(搜索关键词usb autorun)到。但是，如果我想，比如，当一个usb插入时，在后台自动把usb里的重要文件神不知鬼不觉地拷贝到本地或者上传到某个服务器，就需要特殊的软件辅助。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;于是我心想，能不能用python写一个程序，让它在后台运行。每当有u盘插入的时候，就自动拷贝其中重要文件。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何判断U盘的插入与否?&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38402457757296465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5phCZPeBLhhLZ04EtLM5AHmzG2VZR00zRUt0tOOvMmNr7cuWrbVibUJNA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;651&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先我们打开电脑终端，进入/Volumes目录，这时候插入U盘，可以发现它被挂载在了这个目录之下，也就是说，我们只要在固定时间扫描这个目录，当这个目录有新文件夹出现的时候，很可能有U盘被插入了。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我的设计是这样的，用time.sleep(3)函数，让程序保持运行状态，并且每隔三秒查看一下/Volumes/目录，如果多出来文件夹，就将其拷贝到另外的文件夹。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pFaHJxu2OWq4nLAH3JBYP8DJ2SEL7ONsZynHCTG6SaxQL5RdU0CSnLA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;600&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;133.84615384615384&quot; data-ratio=&quot;0.22333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pibCXGfrsXBicXwvsic2sqicRtr7JcGZBjxlMFQTtFzpLITgOO3a8Os1Tlg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;就像标题所示，我们真的只用了10行(其实是11行，凑个整：)完成了这个“病毒”。我们可以发现usb中的目录，在插入半分钟后全部躺在了home目录下了。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何选择性的复制文件?&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;刚刚我们写了一个很简易的脚本测试了一下这个想法的可行性，但是还是有问题。刚才之所以能把U盘中所有文件很快复制进去，是因为U盘中只有两三个文件，大小不超过15M。如果目标U盘中有很多电影，音乐，这些我们并不需要的文件，我们的程序就应该能跳过它们，仅仅选择一些重要的比如.docx比如.ppt文件，或者仅仅复制最近修改过的那些文件，或者排除所有大小大于5M的文件。我们可以用python做到吗?当然！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还是举个例子吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我在某目录下创建了testwalk文件夹，里面有file123.txt三个文件，folder123三个文件夹，其中folder1中有文件file4.txt以及folder4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6577946768060836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pTSP5HnalLMM5TCa68nC7dckxfK3OjZqqz2g9MW9yoEiaJYY0wc67UTw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;526&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;现在我们来测试一下&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pZauOgaJIHiafRibEyh9A7NibsvXQCnRIqbLia5bWYeNWVeIibgbzpYkCicwg/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;610&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;297.96153846153845&quot; data-ratio=&quot;0.4885245901639344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pKRGAkCtRPam0YjGpn6VoqLWBYNvtxiaaePkKLbnrb1u2WQ1xB1Wh6CA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;610&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;root存放的是当前位置，它会把./testwalk/下所有的文件夹作为根目录，往下搜索&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23985239852398524&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pXQJIEHxysoaPMqhcOf8tMYwkHRTyvroks1Jze2pOIWdou7cFY8xaSg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;542&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;单独查看 dirs&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5psScxMyL7vribuDicIxbQHdKsIKLL0dO6lGfBaJ8ysvrlaRh14mhcYWibw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;504&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;146&quot; data-ratio=&quot;0.2896825396825397&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pB1YFdmJ0awn4UkduyDSbGfvicp82icBQiaiaOIdqyb6B7havxxRj3osKog/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;504&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;单独查看 files&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2727272727272727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pFA2UTEfK5uibVdxSJkO11kPFZY3RQIZw88kYSfB8nOzM5fPHiaxPuH0g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;550&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;好了，我们现在需要递归usb文件夹，找到所有的file，查看大小，如果小于，比如3M，就拷贝进home，大于就舍去。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;shutil模块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pdBCR5YekeWDYia3leQviaPNORbFT4gyIbFCrU2armgQqepdVeMUWOpeQ/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;595&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;238&quot; data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pV8U9MrglMCeVMFH6E9LICcTQtLlXdZmYZicsDJwHiaS7IdHP372JoEIw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;595&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;现在我们拿刚才的文件夹举例子，如果想把file1.txt拷贝到folder2：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13824057450628366&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5p9uR4FPjcLbRoeS3s5qnbnkdfDvqbGgn1TCN287TBKvhELiaoaOJZxEw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;557&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;还有许多使用工具在shutil里面这里就不详述了。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;os.path.getsize()判断大小&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;os.path.getsize(文件名)返回的是一个单位为byte的数值，如果用来查看文件大小，我们则需要手动写一个函数，将其换算成容易阅读的形式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6345776031434185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5p6goYvB8dgm14eTJQoCeYhIEK0M0O0icXPMmdCyaiaG0Jss7KW2kcl7SA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;509&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这里我们只要选择文件大小小于3M的即可，3M = 3 * 1024kB = 3 * 1024*1024byte&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pyDt4ibejGuRS3066qbYbutQ6NdXJQ6TVsVLrgJSjy2HGm8R5QtOfAwQ/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;639&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;94.62115384615385&quot; data-ratio=&quot;0.14710485133020346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pYd7NbWQJLoHuaoWsZc5f0kaQeBJJUQU1xkwViauOIHfosVSoPotNpPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;639&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;结合shutil.copy2就可以把选定大小的文件复制进我们的目标文件夹了&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何指定文件类型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;这里就需要正则表达式来帮助我们了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正则表达式内容很多，《python核心编程》中用了整整一章来讲，所以我们也不深入了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下，我们让指定文件后缀以及指定文件大小可以复制进我们的目标文件：&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;别忘了导入 re&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2246153846153846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5p4HTAlMgCqLTNZMJ5Vg5ZAouib9K7AWjnhia7XtRw4ZAlYEGXw1ib1icPJw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;650&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;用更加复杂的正则表达式可以更好地指定文件类型&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;根据修改时间筛选文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24237560192616373&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5p7zqzgdgxc2WPfzKLa9wSSUdoWa4HhKM5Fbe5e6GzOp6K8rJrByL2Hg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;623&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这时候我在目录下创建了一个文件叫做newfile&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HZW0wwFxbQDVqO3hO5bFtdTaqXv4lx5pia6NT9NSYTtDJs2uUYhsFHbqxk6OZCzcSTvYxKu6aQjOQaI28pkh5mw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; title=&quot;十行代码--用Python写一个USB病毒&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;总之，对每一个文件进行修改时间的筛选可以只复制那些近期，或者特定时期修改或者添加过的文件，这个功能在特定情况下很有用。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;其实，标题这么起只是为了吸引大家注意，这就是一个小程序，也谈不上病毒&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我更想通过这个例子，展示python对于文件处理的强大能力，引发大家的学习热情&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上实现都是基于macos，linux应该一样，windows稍加修改也可以成功。&lt;/span&gt;&lt;span&gt;以上技术仅供学习，切勿用于其他行为&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;来源：网络&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;svg&quot; data-w=&quot;150&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/SQd7RF5caa2sRkiaG4Lib8FHMVW1Ne13lrN37SiaB2ibEDF4OD31Vxh71vWXuOC2VaWME2CltDJsGdA5LnsdhdJianUR3GkoXe1Nx/640?wx_fmt=svg&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;加主页君微信，不仅Python技能+1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;svg&quot; data-w=&quot;150&quot; class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/SQd7RF5caa2sRkiaG4Lib8FHMVW1Ne13lr4b5vuiaNBnGZKzQI3kAgC4XOZVFnBxvvrXI2GOpiaH06UjrJSc4fqoPBZDKzPVRicCN/640?wx_fmt=svg&quot;/&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8666666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzDNI6O6hCFBc2O6VZiaHtzQn9pYBAmTD9EaEHCDBLkxE8Pln85fKLpIy3sRib8FX0Lzoagbs8TYxC5aAgTubZyw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;主页君日常还会在个人微信分享&lt;span&gt;&lt;strong&gt;Python相关&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;资源&lt;/strong&gt;&lt;/span&gt;和&lt;strong&gt;精选&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;技术文章&lt;/strong&gt;&lt;/span&gt;，不定期分享一些&lt;span&gt;&lt;strong&gt;有意思的活动&lt;/strong&gt;&lt;/span&gt;、&lt;span&gt;&lt;strong&gt;岗位内推&lt;/strong&gt;&lt;/span&gt;以及&lt;span&gt;&lt;strong&gt;如何用技术做业余项目&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;147&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;147&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fhujzoQe7TrFIO8Jm3ZqkmSv8hNC8lLzLF6Zs9s0oibfwtHHVibBNXxzMdZSpHaxCVm9ND86EutaUmfzHjgVic6lw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span&gt;加个微信，打开一扇窗&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;amp;mid=2652597423&amp;amp;idx=1&amp;amp;sn=b1e2462988a3fd36c17758a3c77c4f2d&amp;amp;chksm=846544e5b312cdf3fb27b55fea4736a8c99f91e3ef6ad14ac2fcee70e61903b12374a229d368&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Python 实现单例模式的五种写法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python 实现单例模式的五种写法&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;amp;mid=2652597405&amp;amp;idx=2&amp;amp;sn=73bdb7b18a3797bed44d94af19c694a8&amp;amp;chksm=846544d7b312cdc1019df3109071425adbc6a53b1d96fdb65ea79d161ce892e3dbd6b883b95e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;收藏! 38 个 Python 数据科学顶级库&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;收藏! 38 个 Python 数据科学顶级库&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;amp;mid=2652597405&amp;amp;idx=1&amp;amp;sn=68f5903537ea71f4a2852747914c982f&amp;amp;chksm=846544d7b312cdc1fa86eddb26d321b78b06f4f6fb245f3a7aa123b3d95f44bde7f5f9b5a6ae&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;为什么 Python、Ruby 等语言弃用了自增运算符？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;为什么 Python、Ruby 等语言弃用了自增运算符？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;推荐关注「Python开发者」，提升Python技能&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzA4MjEyNTA5Mw==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TpvdeLibiaAmU69kV0SyJIicdHKNjs7Cj55MMnHdNdX7mLRzmODUgfYTIb6pQXe10QcibSsPpHib7Ap7rw/0?wx_fmt=png&quot; data-nickname=&quot;Python开发者&quot; data-alias=&quot;PythonCoder&quot; data-signature=&quot;点击获取精选Python开发资源。「Python开发者」日常分享 Python 相关的技术文章、实用案例、工具资源、精选课程、热点资讯等。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          

          



                    
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6ced6ec00e6511537a5dae64bc89c08e</guid>
<title>Go：服务发现原理分析与源码解读</title>
<link>https://toutiao.io/k/i8bvlto</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务架构中，有许多绕不开的技术话题。比如服务发现、负载均衡、指标监控、链路追踪，以及服务治理相关的超时控制、熔断、降级、限流等，还有RPC框架。这些都是微服务架构的基础，只有打牢这些基础，才敢说对微服务是有了一点理解，出门也好意思和别人打招呼了，被人提问的时候也能侃侃而谈了，线上出了问题往往也能寻根溯源内心不慌了，旁边的女同事小芳看着你的时候也是满眼的小可爱了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在《微服务实践》公众号，之前写了《go-zero微服务实战系列》的系列文章，这个系列的文章更多的是偏向业务功能和高并发下的服务优化等。本人水平有限，难免有写的不足的地方，但也依然得到了大家的支持与鼓励，倍感荣幸，所以决定趁热打铁，乘胜追击，继续给大家输出干货。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《彻底搞懂系列》会基于 go-zero v1.3.5 和 grpc-go v1.47.0 和大家一起学习微服务架构的方方面面，主要形式是理论+源码+案例，如果时间允许也可能会加上配套视频。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章作为该系列的第一篇，会先介绍相对比较简单的服务发现相关内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;撸袖子开搞，奥利给！！！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;服务发现&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么在微服务架构中，需要引入服务发现呢？本质上，服务发现的目的是解耦程序对服务具体位置的依赖，对于微服务架构来说，服务发现不是可选的，而是必须的。因为在生产环境中服务提供方都是以集群的方式对外提供服务，集群中服务的IP随时都可能发生变化，比如服务重启，发布，扩缩容等，因此我们需要用一本“通讯录”及时获取到对应的服务节点，这个获取的过程其实就是“服务发现”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4743935309973046&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg17gVbgX0Cks9MeibYicExbmgfn3VAjDNAFcelms7GHDfNeQjO0t0yLpJsuvPHqLDkP68jZFLqsa8IA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要理解服务发现，需要知道服务发现解决了如下三个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;服务的注册（Service Registration）&lt;/p&gt;&lt;p&gt;当服务启动的时候，应该通过某种形式（比如调用API、产生上线事件消息、在Etcd中记录、存数据库等等）把自己（服务）的信息通知给服务注册中心，这个过程一般是由微服务框架来完成，业务代码无感知。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;服务的维护（Service Maintaining）&lt;/p&gt;&lt;p&gt;尽管在微服务框架中通常都提供下线机制，但并没有办法保证每次服务都能优雅下线（Graceful Shutdown），而不是由于宕机、断网等原因突然失联，所以，在微服务框架中就必须要尽可能的保证维护的服务列表的正确性，以避免访问不可用服务节点的尴尬。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;服务的发现（Service Discovery）&lt;/p&gt;&lt;p&gt;这里所说的发现是狭义的，它特指消费者从微服务框架（服务发现模块）中，把一个服务标识（一般是服务名）转换为服务实际位置（一般是ip地址）的过程。这个过程（可能是调用API，监听Etcd，查询数据库等）业务代码无感知。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务发现有两种模式，分别是服务端服务发现和客户端服务发现，下面分别进行介绍。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务端服务发现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于服务端服务发现来说，服务调用方无需关注服务发现的具体细节，只需要知道服务的DNS域名即可，支持不同语言的接入，对基础设施来说，需要专门支持负载均衡器，对于请求链路来说多了一次网络跳转，可能会有性能损耗。也可以把咱们比较熟悉的 nginx 反向代理理解为服务端服务发现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4295977011494253&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg17gVbgX0Cks9MeibYicExbmgCu9sKMiboHvD9DWnhewcQ42rwmZ7ibz0d1V4CUfvGpjguDMH5IaZnjVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1392&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;客户端服务发现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于客户端服务发现来说，由于客户端和服务端采用了直连的方式，比服务端服务发现少了一次网络跳转，对于服务调用方来说需要内置负载均衡器，不同的语言需要各自实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于微服务架构来说，我们期望的是去中心化依赖，中心化的依赖会让架构变得复杂，当出现问题的时候也会让整个排查链路变得繁琐，所以在 go-zero 中采用的是客户端服务发现的模式。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4039334341906203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg17gVbgX0Cks9MeibYicExbmg3iaVsVAeicpBFdCETR6MDibAMeIxJpByxIGicY4opiaGlFWXrD66gyYWJlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1322&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;gRPC的服务发现&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC提供了自定义Resolver的能力来实现服务发现，通过 &lt;strong&gt;Register&lt;/strong&gt;方法来进行注册自定义的Resolver，自定义的Resolver需要实现Builder接口，定义如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/resolver/resolver.go:261&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Builder &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;    Build(target Target, cc ClientConn, opts BuildOptions) (Resolver, error)&lt;br/&gt;    Scheme() &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说下 &lt;code&gt;Scheme()&lt;/code&gt; 方法的作用，该方法返回一个stirng。注册的 &lt;code&gt;Resolver&lt;/code&gt; 会被保存在一个全局的变量m中，m是一个map，这个map的key即为 &lt;code&gt;Scheme()&lt;/code&gt; 方法返回的字符串。也就是多个Resolver是通过Scheme来进行区分的，所以我们定义 &lt;code&gt;Resolver&lt;/code&gt; 的时候 &lt;code&gt;Scheme&lt;/code&gt; 不要重复，否则 &lt;code&gt;Resolver&lt;/code&gt; 就会被覆盖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/resolver/resolver.go:49&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Register&lt;/span&gt;&lt;span&gt;(b Builder)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    m[b.Scheme()] = b&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看下Build方法，Build方法有三个参数，还有Resolver返回值，乍一看不知道这些参数是干嘛的，遇到这种情况该怎么办呢？其实也很简单，去源码里看一下Build方法在哪里被调用的，就知道传入的参数是哪里来的，是什么含义了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用gRPC进行服务调用前，需要先创建一个 &lt;strong&gt;ClientConn&lt;/strong&gt; 对象，最终发起调用的时候，其实是调用了 &lt;strong&gt;ClientConn&lt;/strong&gt; 的 &lt;strong&gt;Invoke&lt;/strong&gt; 方法，可以看下如下代码，其中 &lt;strong&gt;ClientConn&lt;/strong&gt; 是通过调用 &lt;strong&gt;NewGreeterClient&lt;/strong&gt; 传入的，&lt;strong&gt;NewGreeterClient&lt;/strong&gt; 为 &lt;strong&gt;protoc&lt;/strong&gt; 自动生成的代码，并赋值给 &lt;strong&gt;cc&lt;/strong&gt; 属性，示例代码中创建 &lt;strong&gt;ClientConn&lt;/strong&gt; 调用的是 &lt;strong&gt;Dial&lt;/strong&gt; 方法，底层也会调用 &lt;strong&gt;DialContext&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/clientconn.go:104&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Dial&lt;/span&gt;&lt;span&gt;(target &lt;span&gt;string&lt;/span&gt;, opts ...DialOption)&lt;/span&gt; &lt;span&gt;(*ClientConn, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; DialContext(context.Background(), target, opts...)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 &lt;strong&gt;ClientConn&lt;/strong&gt; 对象，并传递给自动生成的 &lt;strong&gt;greeterClient&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/examples/helloworld/greeter_client/main.go:42&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    flag.Parse()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Set up a connection to the server.&lt;/span&gt;&lt;br/&gt;    conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatalf(&lt;span&gt;&quot;did not connect: %v&quot;&lt;/span&gt;, err)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; conn.Close()&lt;br/&gt;&lt;br/&gt;    c := pb.NewGreeterClient(conn)&lt;br/&gt;    &lt;span&gt;// Contact the server and print out its response.&lt;/span&gt;&lt;br/&gt;    ctx, cancel := context.WithTimeout(context.Background(), time.Second)&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;    r, err := c.SayHello(ctx, &amp;amp;pb.HelloRequest{Name: *name})&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatalf(&lt;span&gt;&quot;could not greet: %v&quot;&lt;/span&gt;, err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Greeting: %s&quot;&lt;/span&gt;, r.GetMessage())&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终通过 &lt;strong&gt;Invoke&lt;/strong&gt; 方法真正发起调用请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/examples/helloworld/helloworld/helloworld_grpc.pb.go:39&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *greeterClient)&lt;/span&gt; &lt;span&gt;SayHello&lt;/span&gt;&lt;span&gt;(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption)&lt;/span&gt; &lt;span&gt;(*HelloReply, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    out := &lt;span&gt;new&lt;/span&gt;(HelloReply)&lt;br/&gt;    err := c.cc.Invoke(ctx, &lt;span&gt;&quot;/helloworld.Greeter/SayHello&quot;&lt;/span&gt;, in, out, opts...)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; out, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了客户端调用发起的流程后，我们重点看下 &lt;strong&gt;ClientConn&lt;/strong&gt; 方法，该方法巨长，只看我们关注的Resolver部分。&lt;strong&gt;ClientConn&lt;/strong&gt; 第二个参数 &lt;strong&gt;Target&lt;/strong&gt; 的语法可以参考 &lt;strong&gt;https://github.com/grpc/grpc/blob/master/doc/naming.md&lt;/strong&gt; ，采用了URI的格式，其中第一部分表示Resolver的名称，即自定义Builder方法Scheme的返回值。格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;dns:[//authority/]host[:port] -- DNS（默认）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续往下看，通过调用 &lt;strong&gt;parseTargetAndFindResolver&lt;/strong&gt; 方法来获取Resolver&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/clientconn.go:251&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;resolverBuilder, err := cc.parseTargetAndFindResolver()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;strong&gt;parseTargetAndFindResolver&lt;/strong&gt; 方法中，主要就是把 &lt;strong&gt;target&lt;/strong&gt; 中的resolver name解析出来，然后根据resolver name去上面我们提到的保存Resolver的全局变量m中去找对应的Resolver。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/clientconn.go:1574&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(cc *ClientConn)&lt;/span&gt; &lt;span&gt;parseTargetAndFindResolver&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(resolver.Builder, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 非关键代码省略 ...&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; rb resolver.Builder&lt;br/&gt;    parsedTarget, err := parseTarget(cc.target)&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;// 非关键代码省略 ...&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;    rb = cc.getResolver(parsedTarget.Scheme)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; rb == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, fmt.Errorf(&lt;span&gt;&quot;could not get resolver for default scheme: %q&quot;&lt;/span&gt;, parsedTarget.Scheme)&lt;br/&gt;    }&lt;br/&gt;    cc.parsedTarget = parsedTarget&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; rb, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着往下看，找到我们自己注册的Resolver之后，又调用了 &lt;strong&gt;newCCResolverWrapper&lt;/strong&gt; 方法，把我们自己的Resolver也传了进去&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/clientconn.go:292&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;rWrapper, err := newCCResolverWrapper(cc, resolverBuilder)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入到 &lt;strong&gt;newCCResolverWrapper&lt;/strong&gt; 方法中，在这个方法中终于找到了我们自定义的 &lt;strong&gt;Builder&lt;/strong&gt; 的 &lt;strong&gt;Build&lt;/strong&gt; 方法在哪里被调用了，在 &lt;strong&gt;grpc-go/resolver_conn_wrapper.go:72&lt;/strong&gt; 调用了我们自定义的Build方法，其中第一参数target传入的为cc.parseTarget，cc为 &lt;strong&gt;newCCResolverWrapper&lt;/strong&gt; 第一个参数，即 &lt;strong&gt;ClientConn&lt;/strong&gt; 对象。cc.parseTarget是在上面提到的获取自定义Resolver方法 &lt;strong&gt;parseTargetAndFindResolver&lt;/strong&gt; 中最后赋值的，其中Scheme、Authority、Endpoint分别对应Target语法中定义的三部分，这几个属性即将被废弃，只保留URL属性，定义如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/resolver/resolver.go:245&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Target &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Deprecated: use URL.Scheme instead.&lt;/span&gt;&lt;br/&gt;    Scheme &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Deprecated: use URL.Host instead.&lt;/span&gt;&lt;br/&gt;    Authority &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Deprecated: use URL.Path or URL.Opaque instead. The latter is set when&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// the former is empty.&lt;/span&gt;&lt;br/&gt;    Endpoint &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// URL contains the parsed dial target with an optional default scheme added&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// to it if the original dial target contained no scheme or contained an&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// unregistered scheme. Any query params specified in the original dial&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// target can be accessed from here.&lt;/span&gt;&lt;br/&gt;    URL url.URL&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;URL的Scheme对应Target的Scheme，URL的Host对应Target的Authority，URL的Path对应Target的Endpoint&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;/usr/local/go/src/net/url/url.go:358&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; URL &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    Scheme      &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;    Opaque      &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// encoded opaque data&lt;/span&gt;&lt;br/&gt;    User        *Userinfo &lt;span&gt;// username and password information&lt;/span&gt;&lt;br/&gt;    Host        &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// host or host:port&lt;/span&gt;&lt;br/&gt;    Path        &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// path (relative paths may omit leading slash)&lt;/span&gt;&lt;br/&gt;    RawPath     &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// encoded path hint (see EscapedPath method)&lt;/span&gt;&lt;br/&gt;    ForceQuery  &lt;span&gt;bool&lt;/span&gt;      &lt;span&gt;// append a query (&#x27;?&#x27;) even if RawQuery is empty&lt;/span&gt;&lt;br/&gt;    RawQuery    &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// encoded query values, without &#x27;?&#x27;&lt;/span&gt;&lt;br/&gt;    Fragment    &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// fragment for references, without &#x27;#&#x27;&lt;/span&gt;&lt;br/&gt;    RawFragment &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// encoded fragment hint (see EscapedFragment method)&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续看传入自定义Build方法的第二个参数cc，这个cc参数是一个接口 &lt;strong&gt;ClientConn&lt;/strong&gt;，不要和我们之前讲的创建客户端调用用的 ClientConn混淆，这个 &lt;strong&gt;ClientConn&lt;/strong&gt;定义如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/resolver/resolver.go:203&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; ClientConn &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;    UpdateState(State) error&lt;br/&gt;    ReportError(error)&lt;br/&gt;    NewAddress(addresses []Address)&lt;br/&gt;    NewServiceConfig(serviceConfig &lt;span&gt;string&lt;/span&gt;)&lt;br/&gt;    ParseServiceConfig(serviceConfigJSON &lt;span&gt;string&lt;/span&gt;) *serviceconfig.ParseResult&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ccResolverWrapper&lt;/strong&gt; 实现了这个接口，并作为自定义Build方法的第二个参数传入&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/resolver_conn_wrapper.go:36&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; ccResolverWrapper &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    cc         *ClientConn&lt;br/&gt;    resolverMu sync.Mutex&lt;br/&gt;    resolver   resolver.Resolver&lt;br/&gt;    done       *grpcsync.Event&lt;br/&gt;    curState   resolver.State&lt;br/&gt;&lt;br/&gt;    incomingMu sync.Mutex &lt;span&gt;// Synchronizes all the incoming calls.&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自定义Build方法的第三个参数为一些配置项，newCCResolverWrapper实现如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/resolver_conn_wrapper.go:48&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newCCResolverWrapper&lt;/span&gt;&lt;span&gt;(cc *ClientConn, rb resolver.Builder)&lt;/span&gt; &lt;span&gt;(*ccResolverWrapper, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ccr := &amp;amp;ccResolverWrapper{&lt;br/&gt;        cc:   cc,&lt;br/&gt;        done: grpcsync.NewEvent(),&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; credsClone credentials.TransportCredentials&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; creds := cc.dopts.copts.TransportCredentials; creds != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        credsClone = creds.Clone()&lt;br/&gt;    }&lt;br/&gt;    rbo := resolver.BuildOptions{&lt;br/&gt;        DisableServiceConfig: cc.dopts.disableServiceConfig,&lt;br/&gt;        DialCreds:            credsClone,&lt;br/&gt;        CredsBundle:          cc.dopts.copts.CredsBundle,&lt;br/&gt;        Dialer:               cc.dopts.copts.Dialer,&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt;    ccr.resolverMu.Lock()&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; ccr.resolverMu.Unlock()&lt;br/&gt;    ccr.resolver, err = rb.Build(cc.parsedTarget, ccr, rbo)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ccr, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，到这里我们已经知道了自定Resolver的Build方法在哪里被调用，以及传入的参数的由来以及含义，如果你是第一次看gRPC源码的话可能现在已经有点懵了，可以多读几遍，为大家提供了时序图配合代码阅读效果更佳：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48104693140794225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg17gVbgX0Cks9MeibYicExbmgGOsuGkgLzKAncNsYlgXYNWCIfHXXicCN9nSg8813ZcsMPVqjAV3LibUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;go-zero中如何实现的服务发现&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过对gRPC服务发现相关内容的学习，我们大概已经知道了服务发现是怎么回事了，有了理论，接下来我们就一起看下go-zero是如何基于gRPC做服务发现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的时序图可以看到第一步是需要自定义Resolver，第二步注册自定义的Resolver。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go-zero的服务发现是在客户端实现的。在创建zRPC客户端的时候，通过init方法进行了自定义Resolver的注册。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/zrpc/internal/client.go:23&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    resolver.Register()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在go-zero中默认注册了四个自定义的Resolver。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/zrpc/resolver/internal/resolver.go:35&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;RegisterResolver&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    resolver.Register(&amp;amp;directResolverBuilder)&lt;br/&gt;    resolver.Register(&amp;amp;discovResolverBuilder)&lt;br/&gt;    resolver.Register(&amp;amp;etcdResolverBuilder)&lt;br/&gt;    resolver.Register(&amp;amp;k8sResolverBuilder)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 &lt;strong&gt;goctl&lt;/strong&gt; 自动生成的rpc代码默认使用的是etcd作为服务注册与发现组件的，因此我们重点来看下go-zero是如何基于etcd实现服务注册与发现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcdBuilder返回的Scheme值为etcd&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/zrpc/resolver/internal/etcdbuilder.go:7&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(b *etcdBuilder)&lt;/span&gt; &lt;span&gt;Scheme&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; EtcdScheme&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/zrpc/resolver/internal/resolver.go:15&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;EtcdScheme = &lt;span&gt;&quot;etcd&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得我们上面讲过的吗？在时序图的第五步和第六步，会通过scheme去全局的m中寻找自定义的Resolver，而scheme是从DialContext第二个参数target中解析出来的，那我们看下go-zero调用DialContext的时候，传入的target值是什么。target是通过 &lt;strong&gt;BuildTarget&lt;/strong&gt; 方法获取来的，定义如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/zrpc/config.go:72&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(cc RpcClientConf)&lt;/span&gt; &lt;span&gt;BuildTarget&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;string&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(cc.Endpoints) &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; resolver.BuildDirectTarget(cc.Endpoints), &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(cc.Target) &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; cc.Target, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err := cc.Etcd.Validate(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;, err&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; cc.Etcd.HasAccount() {&lt;br/&gt;        discov.RegisterAccount(cc.Etcd.Hosts, cc.Etcd.User, cc.Etcd.Pass)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; cc.Etcd.HasTLS() {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err := discov.RegisterTLS(cc.Etcd.Hosts, cc.Etcd.CertFile, cc.Etcd.CertKeyFile,&lt;br/&gt;            cc.Etcd.CACertFile, cc.Etcd.InsecureSkipVerify); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;, err&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; resolver.BuildDiscovTarget(cc.Etcd.Hosts, cc.Etcd.Key), &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终生成target结果的方法如下，也就是对于etcd来说，最终生成的target格式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;etcd://127.0.0.1:2379/product.rpc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/zrpc/resolver/target.go:17&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BuildDiscovTarget&lt;/span&gt;&lt;span&gt;(endpoints []&lt;span&gt;string&lt;/span&gt;, key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span&gt;&quot;%s://%s/%s&quot;&lt;/span&gt;, internal.DiscovScheme,&lt;br/&gt;        strings.Join(endpoints, internal.EndpointSep), key)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;似乎有点不对劲，scheme不应该是etcd么？为什么是discov？其实是因为etcd和discov共用了一套Resolver逻辑，也就是gRPC通过scheme找到已经注册的discov Resolver，该Resolver对应的Build方法同样适用于etcd，discov可以认为是对服务发现的一个抽象，etcdResolver的定义如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/zrpc/resolver/internal/etcdbuilder.go:3&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; etcdBuilder &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    discovBuilder&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务注册&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在详细看基于etcd的自定义Resolver逻辑之前，我们先来看下go-zero的服务注册，即如何把服务信息注册到etcd中的，我们以 &lt;strong&gt;lebron/apps/product/rpc&lt;/strong&gt; 这个服务为例进行说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在product-rpc的配置文件中配置了Etcd，包括etcd的地址和服务对应的key，如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;lebron/apps/product/rpc/etc/product.yaml:4&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;ListenOn:&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;:9002&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;Etcd:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;Hosts:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;:2379&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;Key:&lt;/span&gt; &lt;span&gt;product.rpc&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用zrpc.MustNewServer创建gRPC server，接着会调用 &lt;strong&gt;NewRpcPubServer&lt;/strong&gt; 方法，定义如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/zrpc/internal/rpcpubserver.go:17&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewRpcPubServer&lt;/span&gt;&lt;span&gt;(etcd discov.EtcdConf, listenOn &lt;span&gt;string&lt;/span&gt;, opts ...ServerOption)&lt;/span&gt; &lt;span&gt;(Server, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    registerEtcd := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        pubListenOn := figureOutListenOn(listenOn)&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; pubOpts []discov.PubOption&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; etcd.HasAccount() {&lt;br/&gt;            pubOpts = &lt;span&gt;append&lt;/span&gt;(pubOpts, discov.WithPubEtcdAccount(etcd.User, etcd.Pass))&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; etcd.HasTLS() {&lt;br/&gt;            pubOpts = &lt;span&gt;append&lt;/span&gt;(pubOpts, discov.WithPubEtcdTLS(etcd.CertFile, etcd.CertKeyFile,&lt;br/&gt;                etcd.CACertFile, etcd.InsecureSkipVerify))&lt;br/&gt;        }&lt;br/&gt;        pubClient := discov.NewPublisher(etcd.Hosts, etcd.Key, pubListenOn, pubOpts...)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; pubClient.KeepAlive()&lt;br/&gt;    }&lt;br/&gt;    server := keepAliveServer{&lt;br/&gt;        registerEtcd: registerEtcd,&lt;br/&gt;        Server:       NewRpcServer(listenOn, opts...),&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; server, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在启动Server的时候，调用Start方法，在Start方法中会调用registerEtcd进行真正的服务注册&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/zrpc/internal/rpcpubserver.go:44&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s keepAliveServer)&lt;/span&gt; &lt;span&gt;Start&lt;/span&gt;&lt;span&gt;(fn RegisterFn)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err := s.registerEtcd(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; s.Server.Start(fn)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在KeepAlive方法中，首先创建etcd连接，然后调用register方法进行服务注册，在register首先创建租约，租约默认时间为10秒钟，最后通过Put方法进行注册。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/core/discov/publisher.go:125&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *Publisher)&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(client internal.EtcdClient)&lt;/span&gt; &lt;span&gt;(clientv3.LeaseID, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    resp, err := client.Grant(client.Ctx(), TimeToLive)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; clientv3.NoLease, err&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    lease := resp.ID&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; p.id &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;        p.fullKey = makeEtcdKey(p.key, p.id)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        p.fullKey = makeEtcdKey(p.key, &lt;span&gt;int64&lt;/span&gt;(lease))&lt;br/&gt;    }&lt;br/&gt;    _, err = client.Put(client.Ctx(), p.fullKey, p.value, clientv3.WithLease(lease))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; lease, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key的规则定义如下，其中key为在配置文件中配置的Key，这里为product.rpc，id为租约id。value为服务的地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/core/discov/clients.go:39&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;makeEtcdKey&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;, id &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span&gt;&quot;%s%c%d&quot;&lt;/span&gt;, key, internal.Delimiter, id)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了服务注册的流程后，我们启动product-rpc服务，然后通过如下命令查看服务注册的地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; etcdctl get product.rpc --prefix&lt;/span&gt;&lt;br/&gt;product.rpc/7587864068988009477&lt;br/&gt;127.0.0.1:9002&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;strong&gt;KeepAlive&lt;/strong&gt; 方法中，服务注册完后，最后会调用 &lt;strong&gt;keepAliveAsync&lt;/strong&gt; 进行租约的续期，以保证服务一直是存活的状态，如果服务异常退出了，那么也就无法进行续期，服务发现也就能自动识别到该服务异常下线了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务发现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在已经把服务注册到etcd中了，继续来看如何发现这些服务地址。我们回到 &lt;strong&gt;etcdBuilder&lt;/strong&gt; 的Build方法的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得第一个参数target是什么吗？如果不记得了可以往上翻再复习一下，首先从target中解析出etcd的地址，和服务对应的key。然后创建etcd连接，接着执行update方法，在update方法中，通过调用cc.UpdateState方法进行服务状态的更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/zrpc/resolver/internal/discovbuilder.go:14&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(b *discovBuilder)&lt;/span&gt; &lt;span&gt;Build&lt;/span&gt;&lt;span&gt;(target resolver.Target, cc resolver.ClientConn, _ resolver.BuildOptions)&lt;/span&gt; &lt;span&gt;(&lt;br/&gt;    resolver.Resolver, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    hosts := strings.FieldsFunc(targets.GetAuthority(target), &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(r &lt;span&gt;rune&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; r == EndpointSepChar&lt;br/&gt;    })&lt;br/&gt;    sub, err := discov.NewSubscriber(hosts, targets.GetEndpoints(target))&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    update := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; addrs []resolver.Address&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; _, val := &lt;span&gt;range&lt;/span&gt; subset(sub.Values(), subsetSize) {&lt;br/&gt;            addrs = &lt;span&gt;append&lt;/span&gt;(addrs, resolver.Address{&lt;br/&gt;                Addr: val,&lt;br/&gt;            })&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err := cc.UpdateState(resolver.State{&lt;br/&gt;            Addresses: addrs,&lt;br/&gt;        }); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            logx.Error(err)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    sub.AddListener(update)&lt;br/&gt;    update()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;nopResolver{cc: cc}, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果忘记了Build方法第二个参数cc的话，可以往上翻翻再复习一下，cc.UpdateState方法定义如下，最终会调用 &lt;strong&gt;ClientConn&lt;/strong&gt; 的 &lt;strong&gt;updateResolverState&lt;/strong&gt; 方法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;grpc-go/resolver_conn_wrapper.go:94&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(ccr *ccResolverWrapper)&lt;/span&gt; &lt;span&gt;UpdateState&lt;/span&gt;&lt;span&gt;(s resolver.State)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ccr.incomingMu.Lock()&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; ccr.incomingMu.Unlock()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ccr.done.HasFired() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    ccr.addChannelzTraceEvent(s)&lt;br/&gt;    ccr.curState = s&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err := ccr.cc.updateResolverState(ccr.curState, &lt;span&gt;nil&lt;/span&gt;); err == balancer.ErrBadResolverState {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; balancer.ErrBadResolverState&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续看 &lt;strong&gt;Build&lt;/strong&gt; 方法，update方法会被添加到事件监听中，当有PUT和DELETE事件触发，都会调用update方法进行服务状态的更新，事件监听是通过etcd的Watch机制实现，代码如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/core/discov/internal/registry.go:295&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *cluster)&lt;/span&gt; &lt;span&gt;watchStream&lt;/span&gt;&lt;span&gt;(cli EtcdClient, key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    rch := cli.Watch(clientv3.WithRequireLeader(c.context(cli)), makeKeyPrefix(key), clientv3.WithPrefix())&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; wresp, ok := &amp;lt;-rch:&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;                logx.Error(&lt;span&gt;&quot;etcd monitor chan has been closed&quot;&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; wresp.Canceled {&lt;br/&gt;                logx.Errorf(&lt;span&gt;&quot;etcd monitor chan has been canceled, error: %v&quot;&lt;/span&gt;, wresp.Err())&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; wresp.Err() != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;                logx.Error(fmt.Sprintf(&lt;span&gt;&quot;etcd monitor chan error: %v&quot;&lt;/span&gt;, wresp.Err()))&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            c.handleWatchEvents(key, wresp.Events)&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &amp;lt;-c.done:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当有事件触发的时候，会调用事件处理函数 &lt;strong&gt;handleWatchEvents&lt;/strong&gt; ，最终会调用 &lt;strong&gt;Build&lt;/strong&gt; 方法中定义的update进行服务状态的更新：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;go-zero/core/discov/internal/registry.go:172&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *cluster)&lt;/span&gt; &lt;span&gt;handleWhandleWatchEventsatchEvents&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;, events []*clientv3.Event)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    c.lock.Lock()&lt;br/&gt;    listeners := &lt;span&gt;append&lt;/span&gt;([]UpdateListener(&lt;span&gt;nil&lt;/span&gt;), c.listeners[key]...)&lt;br/&gt;    c.lock.Unlock()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, ev := &lt;span&gt;range&lt;/span&gt; events {&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; ev.Type {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; clientv3.EventTypePut:&lt;br/&gt;            c.lock.Lock()&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; vals, ok := c.values[key]; ok {&lt;br/&gt;                vals[&lt;span&gt;string&lt;/span&gt;(ev.Kv.Key)] = &lt;span&gt;string&lt;/span&gt;(ev.Kv.Value)&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                c.values[key] = &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;string&lt;/span&gt;(ev.Kv.Key): &lt;span&gt;string&lt;/span&gt;(ev.Kv.Value)}&lt;br/&gt;            }&lt;br/&gt;            c.lock.Unlock()&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; _, l := &lt;span&gt;range&lt;/span&gt; listeners {&lt;br/&gt;                l.OnAdd(KV{&lt;br/&gt;                    Key: &lt;span&gt;string&lt;/span&gt;(ev.Kv.Key),&lt;br/&gt;                    Val: &lt;span&gt;string&lt;/span&gt;(ev.Kv.Value),&lt;br/&gt;                })&lt;br/&gt;            }&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; clientv3.EventTypeDelete:&lt;br/&gt;            c.lock.Lock()&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; vals, ok := c.values[key]; ok {&lt;br/&gt;                &lt;span&gt;delete&lt;/span&gt;(vals, &lt;span&gt;string&lt;/span&gt;(ev.Kv.Key))&lt;br/&gt;            }&lt;br/&gt;            c.lock.Unlock()&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; _, l := &lt;span&gt;range&lt;/span&gt; listeners {&lt;br/&gt;                l.OnDelete(KV{&lt;br/&gt;                    Key: &lt;span&gt;string&lt;/span&gt;(ev.Kv.Key),&lt;br/&gt;                    Val: &lt;span&gt;string&lt;/span&gt;(ev.Kv.Value),&lt;br/&gt;                })&lt;br/&gt;            }&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;            logx.Errorf(&lt;span&gt;&quot;Unknown event type: %v&quot;&lt;/span&gt;, ev.Type)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次会调用 &lt;strong&gt;load&lt;/strong&gt; 方法，获取key对应的服务列表，通过etcd前缀匹配的方式获取，获取方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *cluster)&lt;/span&gt; &lt;span&gt;load&lt;/span&gt;&lt;span&gt;(cli EtcdClient, key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; resp *clientv3.GetResponse&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt;        ctx, cancel := context.WithTimeout(c.context(cli), RequestTimeout)&lt;br/&gt;        resp, err = cli.Get(ctx, makeKeyPrefix(key), clientv3.WithPrefix())&lt;br/&gt;        cancel()&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        logx.Error(err)&lt;br/&gt;        time.Sleep(coolDownInterval)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; kvs []KV&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, ev := &lt;span&gt;range&lt;/span&gt; resp.Kvs {&lt;br/&gt;        kvs = &lt;span&gt;append&lt;/span&gt;(kvs, KV{&lt;br/&gt;            Key: &lt;span&gt;string&lt;/span&gt;(ev.Key),&lt;br/&gt;            Val: &lt;span&gt;string&lt;/span&gt;(ev.Value),&lt;br/&gt;        })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    c.handleChanges(key, kvs)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取的服务地址列表，通过map存储在本地，当有事件触发的时候通过操作map进行服务列表的更新，这里有个隐藏的设计考虑是当 etcd 连不上或者出现故障时，内存里的服务地址列表不会被更新，保障了当 etcd 有问题时，服务发现依然可以工作，保障服务继续正常运行。逻辑相对比较直观，这里就不再赘述，代码逻辑在 &lt;strong&gt;go-zero/core/discov/subscriber.go:76&lt;/strong&gt; ，下面是go-zero服务发现的时序图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48894348894348894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg17gVbgX0Cks9MeibYicExbmgk2IGp9HmicAqIXWicSqsaYpR0CLbMIK2tliaTWt0bOojZqYOn5Z2iazoow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1628&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结束语&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里服务发现相关的内容已经讲完了，内容还是有点多的，特别是代码部分需要反复仔细阅读才能加深理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一起来简单回顾下本篇的内容：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先介绍了服务发现的概念，以及服务发现需要解决哪些问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务发现的两种模式，分别是服务端发现模式和客户端发现模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接着一起学习了gRPC提供的注册Resolver的能力，通过注册Resolver来实现自定义的服务发现功能，以及gRPC内部是如何寻找到自定义的Resolver和触发调用自定义Resolver的逻辑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后学习了go-zero中服务发现的实现原理，&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先是介绍了go-zero的服务注册流程，演示了最终注册的效果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接着从自定义Resolver的Build方法出发，了解到先是通过前缀匹配的方式获取对应的服务列表存在本地，然后调用UpdateState方法更新服务状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过Watch的方式监听服务状态的变化，监听到变化后会触发调用update方法更新本地的服务列表和调用UpdateState更新服务的状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务发现是理解微服务架构的基础，希望大家能仔细的阅读本文，如果有疑问可以随时找我讨论，在社区群中可以搜索dawn_zhou找到我。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过服务发现获取到服务列表后，接着就会通过Invoke方法进行服务调用，在服务调用的时候就涉及到负载均衡，通过负载均衡选择一个合适的节点发起请求。负载均衡是下一篇文章要讲的内容，敬请期待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望本篇文章对你有所帮助，你的点赞是作者持续输出的最大动力。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4d691b88c0a33c353b4b13fe50baba72</guid>
<title>小红书KV存储架构：万亿级数据与跨云多活不在话下</title>
<link>https://toutiao.io/k/9bd7q5h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwOTIxNDQ3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YRIaicYx5pzj5Cxwick8DamnOgbTJu96QTibKyHEDZt1815yOV1r27oZ6HgoYTEYWYLRz4jIV4iasHgg/0?wx_fmt=png&quot; data-nickname=&quot;dbaplus社群&quot; data-alias=&quot;dbaplus&quot; data-signature=&quot;围绕Database、BigData、AIOps的企业级专业社群。资深大咖、技术干货，每天精品原创文章推送，每周线上技术分享，每月线下技术沙龙，每季度Gdevops&amp;amp;DAMS行业大会.&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;RedKV是小红书自研的一款基于NVMeSSD的分布式NoSQL KV存储系统，支持无中心和有中心的两种管控架构，旨在解决公司内实时落盘的KV存储需求。RedKV1.0基于Gossip协议做节点管理，在全公司已经大规模使用，实时QPS接近1亿/秒，存储量在数PB级别。RedKV2.0采用中心Shard管理架构，支持全球多云多副本在线弹性伸缩，异地容灾和服务秒级切换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过分层优化，RedKV对比开源同类产品，聚合写吞吐能力平均提升3倍，读1.5倍；对标HBase，成本优化近40%。RedKV部分兼容Redis协议，string/hash/zset等主要数据类型很好的的支持了公司的绝大部分在线存储业务，优化了早期Redis集群部署产生的成本问题以及HBase带来的性能及稳定性问题。RedKV和Hive数仓的数据互通能力为离线数据业务提供了一种解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、小红书存储发展历史&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小红书是年轻人的生活记录、分享平台，用户可以通过短视频、图文等形式记录生活点滴，分享生活方式。在当前的业务模型下，用户的画像数据和笔记数据用来做风险控制和内容推荐。存储数据具有对象-属性的特征、维度多，画像数据量已经达到数十TB， 在线业务对画像和笔记数据的访问P99时延要求非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020年之前公司选择的NoSQL存储产品主要有：Redis、HBase，随着公司DAU的高速增长，早期的存储方案遇到如下挑战：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着业务的持续增长，开源存储产品已经不能很好地满足公司的业务发展需求, 公司需要一款稳定的高性能KV系统支撑内部业务，一方面要满足业务对功能和性能的需求，另一方面要优化成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、小红书业务需求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、高QPS和低延时读取特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）特征数据存储场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;写入带宽达到数十GB/s，要求实时写入性能和读取性能都很高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）图片缓存的场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据量很大，要求读取时延低。可以接受故障场景下少量数据丢失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）高性能（P99 &amp;lt; 10ms）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、低成本的缓存特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）对标Redis&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;兼容Redis协议，性能比Redis慢一些，但资源成本降低50%+。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）典型场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告的关键词存储和反作弊业务，解决大数据量、低QPS的存储模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、NoSQL存储特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）对标HBase&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）典型场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、架构设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RedKV整体架构分3层，接入层兼容Redis协议，支持各种语言的社区版SDK和公司定制的中间件版；接入代理层支持千万QPS的读写能力，无状态扩展；存储层提供高可靠读写服务。RedKV1.0架构如下图1，下面我们详细地展开3层组件的介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;583&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0092592592592593&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHoBwhRKazUNNvvAWfA4JITib2Ow2jfmgAtdR8v6zJYHBMIdZzwhZqt4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1 RedKV1.0整体架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、Client接入层&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RedKV集群部署完成后，通过公司内部提供的Service Mesh组件做服务发现，对Client提供服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、Proxy&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Proxy层由一个无状态CorvusPlus进程组成。它兼容老的Redis Client，扩缩容、升级对无Client和后端集群无感，支持多线程、IO多路复用和端口复用特性。对比开源版本，CorvusPlus增强了自我防护和可观测特性，实现了可在线配置的功能特性：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Proxy限流&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据在线压缩&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程模型优化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;backup-read优化长尾&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;大key检测&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）Proxy限流&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小红书当前的业务模型比较多，客户端行为无法预期，可能出现的发版错误、系统问题及网络抖动引发客户端重试，突发的qps会影响服务稳定性。在高QPS压力下，Proxy处理客户端读写超时，大量重试会导致雪崩，业务高峰期单个 Proxy 带宽可能超过机器的出入带宽限制，而存储集群只能保证在有限的资源内提供稳定可靠的服务。针对这类场景，我们需要保证流量过载时，Proxy和RedKV服务不被打崩，能保障高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于以上问题和目标，对比原生的Redis Cluster模式，RedKV基于令牌桶的流控算法支持了对连接数、带宽和QPS多维度限流。在高QPS下，我们的Proxy限流防止了雪崩，如图2；在大带宽场景下，我们优化了时延，如图3。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;188&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.325&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHYVkXmn7NM9fzicqnBfZI1ozscsnwzEBZlICY7FLkliadqictDul4Y8qQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2 雪崩场景下的限流&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;176&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30462962962962964&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHoE0DHqQZIdV3N27Ned7QZZWNokS4ko7NsuXVicyKgjxutEibSYLwvKpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3 大带宽场景下的限流&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）数据在线压缩&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Proxy层本身只做路由转发，对CPU的消耗非常低。在大带宽的场景下，我们可以充分利用Proxy的CPU资源优化带宽和毛刺。在解析Redis协议时，使用LZ4算法对写入数据进行在线压缩，读取时在线解压。在推荐缓存的使用场景中网络带宽和存储空间压缩40%以上（如图4），总体时延并没有明显的下降。因为网络带宽和写入读取数据的减少，时延毛刺也变小了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;267&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46153846153846156&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SH4SoI4nZJErMxrsEyhhnzc5o77fxIQxqv18OHqVkY2T8icZJibBpF4E5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4 Proxy开压缩后的带宽优化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）线程模型的优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Proxy采用IO多路复用技术，每个连接维护一个请求处理队列和响应队列，保序的返回给客户端。Proxy在收到RedKV Server的回应之后，如果没有收到所有发送的cmd的返回，则会一直等待所有cmd的返回后再发送给client，对于读的场景这种模式非常不友好。经过改造，如果某个cmd之前的cmd都已经正常响应，则可以马上响应给client，不需要再等后面的所有cmd请求完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）backup-read优化长尾&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在公网环境下，一个CVM虚拟机和其他多个虚拟机共享一台物理机。当某个客户的CVM占用大量资源时，很容易影响到其他CVM的P99时延（由于QOS和隔离性做的不够好，SMI中断和内存CE）。在网络吞吐较大的情况下，某云的DPDK容易被打爆，出现母机OOB。而在RedKV的内部实现中，如果Server请求比较大，某些key的查询时延比较高的时候，容易产生排队堆积，或者compaction之后的block cache失效，很容易造成IO长尾。因此，RedKV的P99读时延的毛刺很难避免，但毛刺是偶尔发生的，当前我们的主从节点一定是离散部署在不同的母机上，同时出现P99毛刺的可能很小。基于这点，我们在Proxy层做了backup read功能，优化了RedKV的p99时延问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对以上模型，我们的优化思路：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;287&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4967948717948718&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHtqmIgTeIcxQx11dCIibPsHgo1OWed12OdicXibQoLjXWOLGux7aqqb8Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5 Backup-read 消峰&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为backup read转发不需要复制内存，通过索引来保证生命周期，而且只有超过P95时延的报文会被检查是否能发送backup read，因此，只要5%的报文会发送两次，对集群基本不会增加压力。图6为一个集群中 P999从35ms降低到4ms左右，效果非常明显。对比HBase同样的业务场景，客户端在同样的timeout的配置下，我们的方案提高了客户端的成功率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;157&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2724358974358974&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SH6qwEPLkKRs8v9ibqic9t1gXmjZAOnIWCyeV9VI8dvGAzZViclZqSzsw6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图6 Backup-read P999优化对比&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5）大Key检测&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们线上很多集群在业务使用过程中会偶发的产生一些毛刺，通过抓包发现，这里毛刺有很大一部分原因是因为大Key造成的。为了甄别这类问题，我们在Proxy层支持的大Key的可观测指标。Proxy在解析Redis的cmd可以附带统计KV的大小。对于string读类型的command，读到的val值大于 big-string-size 判定为大key；对于写类型的command， 请求值大于 big-string-size 判定为大key；对于hash/zset则为一次读取的kv总数大小。通过增加read_size（所有读请求总共读到的字节数） 和 write_size （所有写请求总共写入的字节数）监控，rate(read_size) / rate(total_req_amount) 可以计算出平均请求值大小。大Key和热Key是KV系统不可避免的2个场景，针对大Key，我们提供了Proxy层的数据压缩能力；对于热Key， 我们在Server层基于HeavyKeeper算法做了topK统计和处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、RedKV Cluster&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公司的存储需求场景比较多，如广告业务存储的标签和数据模型很多，同时是非常核心的业务，业务需要做资源隔离。为了减少节点故障缩小数据的爆炸半径 ，这里业务我们采用无中心管控的架构，即RedKV1.0架构，它能在部署和运维上能大大简化。无中心的集群架构采用的是Gossip协议，存储节点采用多进程多实例部署，如图7。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;245&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.42314814814814816&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SH6sk2vW1XZ5zrhXdb2e8yx1IDQJOJQM6IpxCb4k70vQy2LM86Zbiaekw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7 Gossip管控的KV Cluster&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐模型训练的数据量非常大，上下游业务很多，承载的QPS高，对应集群的节点也比较多，在故障处理和扩缩容方面会触发gossip抖动。针对大集群的节点管理，我们采用有中心管控的架构，即RedKV2.0架构。基于Shard管理的中心架构能更好的支持数据迁移和集群扩缩容，存储节点采用单进程多实例部署，在多活场景中可以支持副本数弹性扩展，如图8。RedKV2.0的相关组件会在后续的技术文章中详细介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;285&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4935897435897436&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHbdVsOL443npxz5RuTaD7ypxiaAlyMqic3NLVCk0jMTjicRar9mdPLRtpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图8 基于中心管控的KV Cluster&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）Gossip优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RedKV1.0采用Gossip协议通信，节点故障时主从节点的切换，最长影响时间为30s。一个节点出现故障时，集群中正常节点将故障节点标记为 fail 状态需要经过一段收敛时间。在这段时间内，Proxy层有可能将用户请求转发给已经 fail 的节点，导致请求失败。减小集群收敛时间能有效减少Proxy层错误请求数量，提高集群的稳定性和可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RedKV1.0通过如下三个步骤加快视图收敛：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis Gossip协议正常情况下会每隔100ms随机选取一个节点发送ping包，并更新节点的ping_sent值为发送ping包时间。如果集群很大，节点数很多，那么故障节点被ping到的概率就会变小，最多超过node_timeout/2时间给故障节点发送ping包。这样就会导致节点发生故障时，集群中正常节点不能第一时间ping到故障节点，从而无法立刻感知到故障节点发生了故障。为了减少这部分时间，当集群中有节点超过2s没有收到故障节点发送的pong报文时，就立马通知其他节点去ping故障节点。这样可以把节点故障到正常节点给故障节点发送ping的时间控制在2s左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Gossip 协议现有实现方式是超过node_timeout（通常为15s）时间没有收到pong报文，就将节点状态置为pfail。本次优化将这个时间设置为3s（可配置），如果24小时内（可配置）首次超过3s没有收到pong报文，就将节点置为pfail状态。如果24小时内频繁出现，那可能是网络抖动造成，还走原来的路径等待node_timeout。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只有一个节点收到集群1/2的节点的PFAIL信息的时候，才会将故障节点判定为FAIL状态。而PFAIL这个信息是通过Gossip协议交互的，最久需要1/2 node_timeout才会通知到其他节点。因此为了加速PFAIL到FAIL的状态，所有的节点按照统一的规则选出一个种子节点，PFAIL信息除了随机发送一个节点意外，还会通知这个种子节点。这样种子节点能在最快的时间学习到集群所有节点的PFAIL信息，从而将故障节点标记为FAIL状态广播到集群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）RedKV Server&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RedKV Server配置多个IO线程同时监听一个端口来接受连接请求，每个线程上的连接数目会随机均衡。每个线程只解析自己连接上的请求，并将解析出的报文通过key挂到对应的请求队列上，每个队列由一个Worker线程处理。这样同一个key/同一个slot上的请求都会落到同一根Worker线程上处理，避免了对key进行加锁，减少锁冲突和线程切换。Worker线程中会对数据进行重编码，存储到Rocksdb本地存储引擎。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RedKV内部的线程模型如下图9：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;303&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5235042735042735&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHEzCuibt569tlbVd1jqkF1d6cqoFyHw9Xib5qicEWX6DT73ERG9ruSU4xA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图9 RedKV Server无锁线程模型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）数据存储&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RedKV当前支持的数据类型有string、hash和zset，数据节点选择RocksDB作为本地存储引擎，集群创建时支持配置多副本，主从节点离散部署。采用hash打散的方式存储连续slot分片的数据，能比较好地避免热点key问题。不同的数据类型包含(MetaKey,MetaValue) 和（DataKey, DataValue）,设计格式如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;108&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.18628912071535023&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHyVPI9ia5TPFFFn85vkDNVLqjnHQ4JZEFEsDQiaNwmA9Yr9ibtAhxPP7WA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;671&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.48221343873517786&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SH0UgpX4kanRaT5v4ic4vNHGfzAkOxXNh6HHkfibkDQI5P3zmIkJmM9YgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;253&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;79&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13675213675213677&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHxeyz08zicbxRYBcLq9t3h96D5UmIZskW2Ce3MhDduD2ECaPAAuXx7qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHkajtBAdzap7cGLdicrUSPicRdNKkINxFMNXwoXbQgm0vialjk1BouiaiczQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;255&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在如上的编码方式下，key的设计中保留的slot信息，可以在扩缩容的场景中通过slot灵活地做数据迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、生态功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、数据复制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与传统解决方案引入同步组件的方式不同，我们快速实现了单向数据同步以及集群扩容需求，整体架构去除了对第三方组件的依赖，通过扩展Redis复制协议实现了RedKV数据节点的直接复制，如图10。单向复制的限制是扩容需要基于2n做节点同步，扩容完成后后台任务根据3.3.3中定义的key的分片删除不是本节点的数据。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在多活的部署形态下，多云集群的一对多的数据复制采用单向复制对主集群性能侵入较大，因此我们实现了基于中心管控的数据复制策略。该策略支持多个集群的分片异构部署，通过Checkpoint方式定向同步数据，不再需要额外的后台任务去做数据淘汰，能很好的支持多对多的多云集群数据复制、数据破环和扩缩容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;266&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4594017094017094&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHLiakgFOmmN29VvEeXInKekiciaf5ia43KeVNw7CaTAd1HzKCTjcCsfR98Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图10 RedKV的数据复制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、数据批量导入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小红书大量的离线业务数据存储在S3 Hive中，每天会有部分数据需要增量更新，其他的数据会被淘汰。这类场景有几个挑战：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）批量导入&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如小红书的笔记数据，一般需要小时级别甚至天级别的更新，所以业务需要有快捷的批量导入功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）快速更新&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特征数据的特点就是数据量特别大，以笔记为例，全量笔记在TB 级别数据量。如果通过 Jedis SDK 写入，那么存储集群需要支持百万QPS的机器资源。当下小红书数据平台支持业务把数据从hive通过工作流直接导入RedKV，一般是每天凌晨开始写数据，等到晚高峰时大量读取。这种方法实践下来，经常导致 RedKV集群的集群内存OOM，影响稳定性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）性能及稳定&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据在导入的过程中不能影响读的性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;实现方案如图11：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;259&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44814814814814813&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHlXwsmzDyibBfUPaDicmbk4ib38HTZ96V5JhHy7XYl6PN3jk0zbibR9GmFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图11 离线数据BulkLoad&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、数据批量导出&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小红书的业务模型训练数据通过Hash存储在RedKV集群中，业务下游需要对训练结果进行离线分析，希望RedKV具有和Hive数据流通的能力。RedKV本身是不支持Schema的，如果要将KV数据导入Hive表，则需要将Hash的KKV数据转化为一个Table。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RedKV的内部数据按hash打散，导入Hive表则需要提供table关键字，先按前缀扫描的方式扫描存储节点，再生成Hive识别的文件，最后通过Hive Load进行加载。为了更好地兼容其他spark任务，我们选择Hive支持的标准parquet列式存储文件，整个I/O链路如下图12：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;279&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.48183760683760685&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHcfViabicpobu1jJ7jEO3jj71Gu6l3tjKH8NoSVDcCT9v1Cd521yvDTicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图12 RedKV2Hive I/O&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;示例：RedKV里面的Key 写入规定以 {tablename}_ 开始，比如一个artical表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;307&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5308988764044944&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHxpKzPSJzPjowSHAhCurq1eJM95oKcQibfnHsS2CTRLm86ibNGrNHsWHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;&lt;p draggable=&quot;true&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RedKV中的数据采用hmset写入：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;hmset&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;{person}_1 name John quantity 20 price 200.23&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;hmset&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;{person}_2 name Henry quantity 30 price 3000.45&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过以上的写入方式，可以通过配置RedKV2Hive 将KV里面的数据导入到Hive里面的Person表 如果单表的数据量很大，可以采用分表写入，比如把person表分成16份&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;hmset&lt;/span&gt; {&lt;span class=&quot;code-snippet__attribute&quot;&gt;person&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;}_1 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;John&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;quantity&lt;/span&gt; 20 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;price&lt;/span&gt; 200&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.23&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;hmset&lt;/span&gt; {&lt;span class=&quot;code-snippet__attribute&quot;&gt;person&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;}_2 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Henry&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;quantity&lt;/span&gt; 30 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;price&lt;/span&gt; 3000&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.45&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;hmset&lt;/span&gt; {&lt;span class=&quot;code-snippet__attribute&quot;&gt;person&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;16&lt;/span&gt;}_100000 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Tom&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;quantity&lt;/span&gt; 43 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;price&lt;/span&gt; 234&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.56&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、数据的备份和恢复&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小红书的广告数据存储在自研的分布式KV系统中，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;数据安全主要面临如下挑战：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;实现方案如图13：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;294&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5085470085470085&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHRAHWBsXWslIOQgBgPsAG3mgnORUibpcMTrRS40rUlKPzg3bwCFlPibdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图13 集群备份&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、跨云多活&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了应对高速增长的业务需求，公司对云厂商的服务稳定性要求越来越高，单机房云服务难以满足公司稳定性的需求，跨云多活可以提高服务的稳定性，双写双读可以实现主备数据中心均对外提供读写服务, 这样既不会造成数据中心的资源浪费又可以实现跨地域容灾。我们对业界常用的方案做了一些对比分析：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;235&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4074074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHmBJ4rceGTySkn7ic2cG4fyVkZNgicn2msOMsHGcaOMWB431iaJKjGgbag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们综合调研其他厂商的架构经验，提出了RedKV双活设计( Replicator as Sidecar Service同机部署) 方案，如图14。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;架构灵活，适合日志类存储系统双活架构。Redis 以及图数据库的多云方案都可以改造适用，具体的功能组件和实战场景会在后续技术文章详细介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;370&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6399572649572649&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SHnOCib0f2ugVVMzyibdhTgLgoP8UFOY8juGibyAAjng2Dia4URRrOyzSIUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图14 跨云多活架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、实践案例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正如第2节描述的小红书业务需求场景，本节通过一个典型的业务场景来展示RedKV在NoSQL存储下的收益。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;早期在没有zprofile中台的场景下，zprofile用户和笔记信息都存储在HBase。为了保证集群的数据安全和服务稳定性，HBase采用了双集群部署，写入和读取方通过HBase Client API做数据存储。HBase的用户数据在数十TB，在百万QPS下，P99时延已经在70ms左右，随着QPS的快速增长，时延越来越高，集群扩容带来的存储成本也越来越高，稳定性保障也面临极大的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RedKV1.0上线后，经过半年多的打磨，开始慢慢承接公司的核心业务。推荐平台架构组也开始着手打造zprofile中台服务，收敛上下游的业务，提供标准统一的读写方式。在存储方案上，平台架构组同学和存储组经过多次的业务沟通，最终选择使用RedKV作为底层存储，主要对接两类业务方：分别是数据生产者 producer 以及数据消费方 consumer。zprofile最终的中台架构如下图15：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体架构改造完成后，使用RedKV对接同样QPS的业务能力，成本节省了36%, P99性能提升了约5倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;309&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5341880341880342&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8b15yngJibmHG8lfOhyWl0SH5yngqATtBeQxhF9CsjQIibATS3gccSxHeQib2bqat2cicTQgs8Q5JibyLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图15 zprofile中台&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85988&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>016772e50712ffe72f467060bdc54066</guid>
<title>干货 | ClickHouse增强计划之“Upsert”</title>
<link>https://toutiao.io/k/bdic1dh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;字节跳动内部已经将Click&lt;/span&gt;&lt;span&gt;House广泛应用，并在原引擎基础上重构了技术架构，&lt;/span&gt;&lt;strong&gt;本系列文章将从Upsert、多表关联查询、可用性提升等多方面介绍字节跳动基于ClickHouse的能力增强实践。&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jC2t9Zib67r3gByECN9YQcHzmo7F2Ys7ynHCrfqomfyD2oicrib36sUsnd135BxwZCjDwhTbuZoWfA6U2tVOqicvgg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;文 | Dash&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;来自字节跳动数据平台分析型数据库团队&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;相信大家都对大名鼎鼎的ClickHouse有一定的了解，它强大的数据分析性能让人印象深刻。但在字节大量生产使用中，发现了ClickHouse依然存在了一定的限制。例如：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，我们决定将ClickHouse能力进行全方位加强，打造一款更强大的数据分析平台。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;后面我们将从五个方面来和大家分享：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ClickHouse增强计划之查询优化&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ClickHouse增强计划之高可用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ClickHouse增强计划之资源隔离&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;本篇将详细介绍我们是如何为ClickHouse补全更新删除能力的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;实时人群圈选场景遇到的难题&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在电商业务中，人群圈选是非常常见的一个场景。字节原有的离线圈选的方案是以T+1的方式更新数据，而不是实时更新，这很影响业务侧的体验。现在希望能够基于实时标签，在数据管理平台中构建实时人群圈选的能力。整体数据链路如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5244393329499712&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r3gByECN9YQcHzmo7F2Ys7yef8DVC1YxSPGmVaRGOwzbCSpURlLoHOV2zsUGDqhxrRKoIkgsicykFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1739&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;为了保证实时数据和离线数据同时提供服务，在标签接入完毕后，在ClickHouse中完成宽表加工任务。但是原生ClickHouse只支持追加写的能力，只有&lt;span&gt;ReplacingMergeTree这种方案。但是选用ReplacingMergeTree引擎的限制比较多，不能满足业务的需求，主要体现在：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;解决方案：UniqueMergeTree&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这种情况下，字节在ByteHouse（字节基于ClickHouse能力增强的版本）中开发了一种支持实时更新删除的表引擎：UniqueMergeTree。UniqueMergeTree与以往的表引擎有什么差别呢？下面介绍两种&lt;span&gt;支持实时更新的常见技术方案：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;原生ClickHouse选择的技术方案&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;原生ClickHouse的更新表引擎ReplacingMergeTree使用Merge on Read的实现逻辑，整个思想比较类似LSMTree。对于写入，数据先根据key排序，然后生成对应的列存文件。每个Batch写入的文件对应一个版本号，版本号能用来表示数据的写入顺序。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;同一批次的数据不包含重复key，但不同批次的数据包含重复key，这就需要在读的时候去做合并，对key相同的数据返回去最新版本的值，所以叫merge on read方案。原生ClickHouse ReplacingMergeTree用的就是这种方案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大家可以看到，它的写路径是非常简单的，是一个很典型的写优化方案。它的问题是读性能比较差，有几方面的原因。首先，key-based merge通常是单线程的，比较难并行。其次merge过程需要非常多的内存比较和内存拷贝。最后这种方案对谓词下推也会有一些限制。大家用过ReplacingMergeTree的话，应该对读性能问题深有体会。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个方案也有一些变种，比如说可以维护一些index来加速merge过程，不用每次merge都去做key的比较。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;面向读优化的新方案&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;UniqueMergeTree使用的技术方案Mark-Delete + Insert方案刚好反过来，是一个读优化方案。在这个方案中，更新是通过先删除再插入的方式实现的。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.4488188976377954&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r3gByECN9YQcHzmo7F2Ys7y12tQgg6JhuZTEyKmsibXicx63icicj9xt1p3yPwqqTPkUZUkaWpJ6us6Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ref “Enhancements to SQLServer Column Stores”&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;下面以SQLServer的Column Stores为例介绍下这个方案。图中，每个RowGroup对应一个不可变的列存文件，并用Bitmap来记录每个RowGroup中被标记删除的行号，即DeleteBitmap。处理更新的时候，先查找key所属的RowGroup以及它在RowGroup中行号，更新RowGroup的DeleteBitmap，最后将更新后的数据写入Delta Store。查询的时候，不同RowGroup的扫描可以完全并行，只需要基于行号过滤掉属于DeleteBitmap的数据即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个方案平衡了写和读的性能。一方面写入时需要去定位key的具体位置，另一方面需要处理write-write冲突问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个方案也有一些变种。比如说写入时先不去查找更新key的位置，而是先将这些key记录到一个buffer中，使用后台任务将这些key转成DeleteBitmap。然后在查询的时候通过merge on read的方式处理buffer中的增量key。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Upsert和Delete使用示例&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先我们建了一张UniqueMergeTree的表，表引擎的参数和ReplacingMergeTree是一样的，不同点是可以通过UNIQUE KEY关键词来指定这张表的唯一键，它可以是多个字段，可以包含表达式等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7103448275862069&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r3gByECN9YQcHzmo7F2Ys7y23aUMibOOsHfgrRMGfWwZWGmicvsW1xbndcQibU8FH4l9GF5SgU5icaHeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1305&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;下面对这张表做写入操作就会用到upsert的语义，比如说第6行写了四条数据，但只包含1和2两个key，所以对于第7行的select，每个key只会返回最高版本的数据。对于第11行的写入，key 2是一个已经存在的key，所以会把key 2对应的name更新成B3; key 3是新key，所以直接插入。最后对于行删除操作，我们增加了一个delete flag的虚拟列，用户可以通过这个虚拟列标记Batch中哪些是要删除，哪些是要upsert。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;UniqueMergeTree表引擎的亮点&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于Unique表的写入，我们会采用upsert的语义，即如果写入的是新key，那就直接插入数据；如果写入的key已经存在，那就更新对应的数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;UniqueMergeTree表引擎既支持行更新的模式，也支持部分列更新的模式，用户可以根据业务要求开启或关闭。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ByteHouse也支持指定Unique Key的value来删除数据，满足实时行删除的需求。支持指定一个版本字段来解决回溯场景可能出现的低版本数据覆盖高版本数据的问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最后ByteHouse也支持数据在多副本的同步，避免整体系统存在单点故障。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;在性能方面，我们对UniqueMergeTree的写入和查询性能做了性能测试，结果如下图（箭头前是&lt;span&gt;ReplacingMergeTree的消耗时间，箭头后是UniqueMergeTree的消耗时间）&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;852&quot; data-ratio=&quot;0.4874141876430206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r3gByECN9YQcHzmo7F2Ys7ys8toJDlw5Y0gtdIx6LFvcmKuLgAMOagRaUo0ZaFJyurAbibicJlKjiaEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1748&quot; data-width=&quot;1748&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到，与ReplacingMergeTree相比，UniqueMergeTree的写入性能虽然略有下降，但在查询性能上取得了数量级的提升。我们进一步对比了UniqueMergeTree和普通MergeTree的查询性能，发现两者是非常接近的。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24390243902439024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib745vqibLBGIeAicnHiag9GCzTYjeicic5IWPqfyjLajDuwtJdNCAnCgcolqY8ROaE5CsEXR5zbjCU9aVl3WfkZpnDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;82&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;增强后的实施人群圈选&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过&lt;span&gt;UniqueMergeTree的加持，在原有架构不变的情况下，完美的满足了实时人群圈选场景的要求。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、通过&lt;span&gt;Unique Key配置唯一键，提供upsert更新写语义，查询自动返回每个唯一键的最新值&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、性能：单shard写入吞吐可以达到10k+行/s；查询性能与原生CH表几乎相同&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、支持根据&lt;span&gt;Unique Key实时删除数据&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;ByteHouse还通过UniqueMergeTree支持了一些其他特性：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、唯一键支持多字段和表达式&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、支持分区级别唯一和表级别唯一两种模式&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、支持自定义版本字段，写入低版本数据时自动忽略&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4、支持多副本部署，通过主备异步复制保障数据可靠性&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不仅在实时人群圈选场景，ByteHouse提供的upsert能力已经服务于字节内部众多应用，线上应用的表数量有数千张，受到实时类应用的广泛欢迎。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除Upsert能力外，ByteHouse在为原生ClickHouse的企业级能力进行了全方位的增强。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;下一期，我们将介绍ClickHouse增强计划之“多表关联查询”，大家有兴趣一定不要错过。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09191176470588236&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/B0dQTWeIyW0KQwPj8J39EOyT4ibzTqqEhqHYej9NovXTMGfSiaAWBftAf9FPkpW9r6lzyGa8LEMXLBdoL5js2u4Q/640?wx_fmt=png&quot; data-w=&quot;544&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;ByteHouse已经全面对外服务，并且提供各种版本以满足不同类型用户的需求。在ByteHouse官网上提交试用信息即可&lt;/span&gt;&lt;span&gt;&lt;strong&gt;免费试用&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;！欢迎大家试用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r3gByECN9YQcHzmo7F2Ys7y44picJeKP8VzrBjpibEDCgfvNKqQw2HpG9SoiarPX0WoFohQszPYicB2vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫码即可免费试用&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;另外，也欢迎大家扫描下方二维码加入&lt;/span&gt;&lt;strong&gt;&lt;span&gt;ByteHouse &amp;amp; ClickHouse交流群&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，交流关于ByteHouse和ClickHouse的使用经验，有问题也可以咨询群中技术专家。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;396&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jC2t9Zib67r3gByECN9YQcHzmo7F2Ys7yTfQVfPxTeTDicBQ7AUu35H3YQSNFz7C8cjIPakh14NqRor2oZRBqWWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;396&quot; data-width=&quot;396&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫码加入官方交流群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;span&gt;产品介绍&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;火山引擎ByteHouse&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;统一的大数据分析平台。目前提供企业版和云数仓两种版本，企业版是基于开源的企业级分析型数据库，支持用户交互式分析&lt;span lang=&quot;EN-US&quot;&gt;PB&lt;/span&gt;级别数据，通过多种自研表引擎，灵活支持各类数据分析和应用；云数仓版作为云原生的数据分析平台，实现统一的离线和实时数据分析，并通过弹性扩展的计算层和分布式存储层，有效降低&lt;/span&gt;&lt;span&gt;企业大数据分析。&lt;strong&gt;后台回复数字“6”了解产品&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;40&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/jC2t9Zib67r2rAVRBzMMF9nV9BqFPOhzHwu1XL92AFW8jK9zAQXmo5FcO2W6Ce3ld46owl9H8H1toPneEsh4mNA/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;阅读原文，&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;跳转ByteHouse官网试用产品&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          

          



                    
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>