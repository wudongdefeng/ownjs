<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e25a3abc836744c00ea5810ad310abd8</guid>
<title>Function 源码解析与实践</title>
<link>https://toutiao.io/k/21ce5v7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;作者：陈昌浩&lt;/h2&gt;

&lt;h3&gt;1 导读&lt;/h3&gt;

&lt;p&gt;if…else…在代码中经常使用，听说可以通过Java 8的Function接口来消灭if…else…！Function接口是什么？如果通过Function接口接口消灭if…else…呢？让我们一起来探索一下吧。&lt;/p&gt;

&lt;h3&gt;2 Function接口&lt;/h3&gt;

&lt;p&gt;Function接口就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口,Function接口可以被隐式转换为 lambda 表达式。可以通过FunctionalInterface注解来校验Function接口的正确性。Java 8允许在接口中加入具体方法。接口中的具体方法有两种，default方法和static方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@FunctionalInterface
interface TestFunctionService
{
    void addHttp(String url);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么就可以使用Lambda表达式来表示该接口的一个实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TestFunctionService testFunctionService = url -&amp;gt; System.out.println(&quot;http:&quot; + url);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.1 FunctionalInterface&lt;/h4&gt;

&lt;h5&gt;2.1.1 源码&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface FunctionalInterface {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;2.1.2 说明&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8ec68fb5272438e8c5f83dcc3f94f72%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上图是FunctionalInterface的注解说明。通过上面的注解说明，可以知道FunctionalInterface是一个注解，用来说明一个接口是函数式接口。 函数式接口只有一个抽象方法。 可以有默认方法，因为默认方法有一个实现，所以不是抽象的。函数接口的实例可以用lambda表达式、方法引用或构造函数引用创建。&lt;/p&gt;

&lt;p&gt;FunctionalInterface会校验接口是否满足函数式接口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  类型必须是接口类型，不能是注释类型、枚举或类。&lt;/li&gt;
&lt;li&gt;  只能有一个抽象方法。&lt;/li&gt;
&lt;li&gt;  可以有多个默认方法和静态方法。&lt;/li&gt;
&lt;li&gt;  可以显示覆盖java.lang.Object中的抽象方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;编译器会将满足函数式接口定义的任何接口视为函数式接口，而不管该接口声明中是否使用FunctionalInterface注解。&lt;/p&gt;

&lt;h3&gt;3 Function接口主要分类&lt;/h3&gt;

&lt;p&gt;Function接口主要分类:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  Function：Function函数的表现形式为接收一个参数，并返回一个值。&lt;/li&gt;
&lt;li&gt;  Supplier：Supplier的表现形式为不接受参数、只返回数据。&lt;/li&gt;
&lt;li&gt;  Consumer：Consumer接收一个参数，没有返回值。&lt;/li&gt;
&lt;li&gt;  Runnable：Runnable的表现形式为即没有参数也没有返回值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;3.1 Function&lt;/h4&gt;

&lt;p&gt;Function函数的表现形式为接收一个参数，并返回一个值。&lt;/p&gt;

&lt;h5&gt;3.1.1 源码&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;@FunctionalInterface
public interface Function&amp;lt;T, R&amp;gt; {
    R apply(T t);
    default &amp;lt;V&amp;gt; Function&amp;lt;V, R&amp;gt; compose(Function&amp;lt;? super V, ? extends T&amp;gt; before) {
        Objects.requireNonNull(before);
        return (V v) -&amp;gt; apply(before.apply(v));
    }
    default &amp;lt;V&amp;gt; Function&amp;lt;T, V&amp;gt; andThen(Function&amp;lt;? super R, ? extends V&amp;gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&amp;gt; after.apply(apply(t));
    }
    static &amp;lt;T&amp;gt; Function&amp;lt;T, T&amp;gt; identity() {
        return t -&amp;gt; t;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;3.1.2 方法说明&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;  apply：抽象方法。将此函数应用于给定的参数。参数t通过具体的实现返回R。&lt;/li&gt;
&lt;li&gt;  compose：default方法。返回一个复合函数，首先执行fefore函数应用于输入，然后将该函数应用于结果。如果任意一个函数的求值引发异常，则将其传递给组合函数的调用者。&lt;/li&gt;
&lt;li&gt;  andThen：default方法。返回一个复合函数，该复合函数首先对其应用此函数它的输入，然后对结果应用after函数。如果任意一个函数的求值引发异常，则将其传递给组合函数的调用者。&lt;/li&gt;
&lt;li&gt;  identity：static方法。返回一个始终返回其输入参数的函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;3.1.3 方法举例&lt;/h5&gt;

&lt;p&gt;1）apply&lt;/p&gt;

&lt;p&gt;测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public  String upString(String str){
    Function&amp;lt;String, String&amp;gt; function1 = s -&amp;gt; s.toUpperCase();
    return function1.apply(str);
}
 public static void main(String[] args) {
     System.out.println(upString(&quot;hello!&quot;));
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过apply调用具体的实现。执行结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccd31e28937347e690d16d991a4f499c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2）compose&lt;/p&gt;

&lt;p&gt;测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    Function&amp;lt;String, String&amp;gt; function1 = s -&amp;gt; s.toUpperCase();
    Function&amp;lt;String, String&amp;gt; function2 = s -&amp;gt; &quot;my name is &quot;+s;
    String result = function1.compose(function2).apply(&quot;zhangSan&quot;);
    System.out.println(result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a94885a63450403e8040335e919c14c6%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如结果所示：compose 先执行function2 后执行function1。&lt;/p&gt;

&lt;p&gt;3）andThen&lt;/p&gt;

&lt;p&gt;测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    Function&amp;lt;String, String&amp;gt; function1 = s -&amp;gt; s.toUpperCase();
    Function&amp;lt;String, String&amp;gt; function2 = s -&amp;gt; &quot;my name is &quot;+s;
    String result = function1.andThen(function2).apply(&quot;zhangSan&quot;);
    System.out.println(result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2be86523d81545a6b5e15f4c0dc7e038%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如结果所示：&lt;/p&gt;

&lt;p&gt;andThen先执行function1 后执行function2。&lt;/p&gt;



&lt;p&gt;测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;order&quot;, &quot;good&quot;, &quot;lab&quot;, &quot;warehouse&quot;);
    Map&amp;lt;String, Integer&amp;gt; map = stream.collect(Collectors.toMap(Function.identity(), String::length));
    System.out.println(map);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4668ef50875f4b318df7f5ab17cafb48%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;3.2 Supplier&lt;/h4&gt;

&lt;p&gt;Supplier的表现形式为不接受参数、只返回数据。&lt;/p&gt;

&lt;h5&gt;3.2.1 源码&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;@FunctionalInterface
public interface Supplier&amp;lt;T&amp;gt; {
    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;3.2.2 方法说明&lt;/h5&gt;

&lt;p&gt;get：抽象方法。通过实现返回T。&lt;/p&gt;

&lt;h5&gt;3.2.3 方法举例&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;public class SupplierTest {
    SupplierTest(){
        System.out.println(Math.random());
        System.out.println(this.toString());
    }
}
    public static void main(String[] args) {
        Supplier&amp;lt;SupplierTest&amp;gt; sup = SupplierTest::new;
        System.out.println(&quot;调用一次&quot;);
        sup.get();
        System.out.println(&quot;调用二次&quot;);
        sup.get();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5455fabd7dd8445a80df1c501fcf9b52%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如结果所示：Supplier建立时并没有创建新类，每次调用get返回的值不是同一个。&lt;/p&gt;

&lt;h4&gt;3.3 Consumer&lt;/h4&gt;

&lt;p&gt;Consumer接收一个参数，没有返回值。&lt;/p&gt;

&lt;h5&gt;3.3.1 源码&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;@FunctionalInterface
public interface Consumer&amp;lt;T&amp;gt; {
    void accept(T t);
    default Consumer&amp;lt;T&amp;gt; andThen(Consumer&amp;lt;? super T&amp;gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&amp;gt; { accept(t); after.accept(t); };
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;3.3.2 方法说明&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;  accept：对给定参数T执行一些操作。&lt;/li&gt;
&lt;li&gt;  andThen：按顺序执行Consumer -&amp;gt; after ,如果执行操作引发异常，该异常被传递给调用者。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;3.3.3 方法举例&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    Consumer&amp;lt;String&amp;gt; consumer = s -&amp;gt; System.out.println(&quot;consumer_&quot;+s);
    Consumer&amp;lt;String&amp;gt; after = s -&amp;gt; System.out.println(&quot;after_&quot;+s);
    consumer.accept(&quot;isReady&quot;);
    System.out.println(&quot;========================&quot;);
    consumer.andThen(after).accept(&quot;is coming&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a83755ec873d4f559853ec43de173630%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如结果所示：对同一个参数T，通过andThen 方法，先执行consumer，再执行fater。&lt;/p&gt;

&lt;h4&gt;3.4 Runnable&lt;/h4&gt;

&lt;p&gt;Runnable：Runnable的表现形式为即没有参数也没有返回值。&lt;/p&gt;

&lt;h5&gt;3.4.1 源码&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;3.4.2 方法说明&lt;/h5&gt;

&lt;p&gt;run：抽象方法。run方法实现具体的内容，需要将Runnale放入到Thread中，通过Thread类中的start()方法启动线程，执行run中的内容。&lt;/p&gt;

&lt;h5&gt;3.4.3 方法举例&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;public class TestRun implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;TestRun is running!&quot;);
    }
}
    public static void main(String[] args) {
        Thread thread = new Thread(new TestRun());
        thread.start();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f75b90567be24645bb4d1a6cb9c13ff7%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如结果所示：当线程实行start方法时，执行Runnable 的run方法中的内容。&lt;/p&gt;

&lt;h3&gt;4 Function接口用法&lt;/h3&gt;

&lt;p&gt;Function的主要用途是可以通过lambda 表达式实现方法的内容。&lt;/p&gt;

&lt;h4&gt;4.1 差异处理&lt;/h4&gt;

&lt;p&gt;原代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Data
public class User {
    /**
     * 姓名
     */
    private String name;
    /**
     * 年龄
     */
    private int age;
    /**
     * 组员
     */
    private List&amp;lt;User&amp;gt; parters;
}
    public static void main(String[] args) {
        User user =new User();
        if(user ==null ||user.getAge() &amp;lt;18 ){
            throw new RuntimeException(&quot;未成年！&quot;);
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a4a1bf1e0c040d1b2beea8e1b2642ca%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用Function接口后的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@FunctionalInterface
public interface testFunctionInfe {
    /**
     * 输入异常信息
     * @param message
     */
    void showExceptionMessage(String message);
}
    public static testFunctionInfe doException(boolean flag){
        return (message -&amp;gt; {
            if (flag){
                throw new RuntimeException(message);
            }
        });
    }
    public static void main(String[] args) {
        User user =new User();
        doException(user ==null ||user.getAge() &amp;lt;18).showExceptionMessage(&quot;未成年！&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f099bfa83c2f45f3a5156ccaf2332121%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用function接口前后都抛出了指定的异常信息。&lt;/p&gt;

&lt;h4&gt;4.2 处理if…else…&lt;/h4&gt;

&lt;p&gt;原代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    User user =new User();
    if(user==null){
        System.out.println(&quot;新增用户&quot;);
    }else {
        System.out.println(&quot;更新用户&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用Function接口后的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    User user =new User();
    Consumer trueConsumer = o -&amp;gt; {
        System.out.println(&quot;新增用户&quot;);
    };
    Consumer falseConsumer= o -&amp;gt; {
        System.out.println(&quot;更新用户&quot;);
    };
    trueOrFalseMethdo(user).showExceptionMessage(trueConsumer,falseConsumer);
}
public static testFunctionInfe trueOrFalseMethdo(User user){
    return ((trueConsumer, falseConsumer) -&amp;gt; {
        if(user==null){
            trueConsumer.accept(user);
        }else {
            falseConsumer.accept(user);
        }
    });
}
@FunctionalInterface
public interface testFunctionInfe {
    /**
     * 不同分处理不同的事情
     * @param trueConsumer
     * @param falseConsumer
     */
    void showExceptionMessage(Consumer trueConsumer,Consumer falseConsumer);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f90fadea4e7c445fa1d5c8eca55a2735%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;4.3 处理多个if&lt;/h4&gt;

&lt;p&gt;原代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    String flag=&quot;&quot;;
    if(&quot;A&quot;.equals(flag)){
        System.out.println(&quot;我是A&quot;);
    }else if (&quot;B&quot;.equals(flag)) {
        System.out.println(&quot;我是B&quot;);
    }else if (&quot;C&quot;.equals(flag)) {
        System.out.println(&quot;我是C&quot;);
    }else {
        System.out.println(&quot;没有对应的指令&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用Function接口后的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    String flag=&quot;B&quot;;
    Map&amp;lt;String, Runnable&amp;gt; map =initFunctionMap();
    trueOrFalseMethdo(map.get(flag)==null).showExceptionMessage(()-&amp;gt;{
        System.out.println(&quot;没有相应指令&quot;);
    },map.get(flag));
}
public static   Map&amp;lt;String, Runnable&amp;gt; initFunctionMap(){
    Map&amp;lt;String,Runnable&amp;gt; result  = Maps.newHashMap();
    result.put(&quot;A&quot;,()-&amp;gt;{System.out.println(&quot;我是A&quot;);});
    result.put(&quot;B&quot;,()-&amp;gt;{System.out.println(&quot;我是B&quot;);});
    result.put(&quot;C&quot;,()-&amp;gt;{System.out.println(&quot;我是C&quot;);});
    return result;
}
public static testFunctionInfe trueOrFalseMethdo(boolean flag){
    return ((runnable, falseConsumer) -&amp;gt; {
        if(flag){
            runnable.run();
        }else {
            falseConsumer.run();
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00acb28e334b4859be56482437ff0c9d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5 总结&lt;/h3&gt;

&lt;p&gt;Function函数式接口是java 8新加入的特性，可以和lambda表达式完美结合，是非常重要的特性,可以极大的简化代码。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cffcc91db17e8f2add2bf9a1adb08084</guid>
<title>ZooKeeper 核心通识</title>
<link>https://toutiao.io/k/14koa5h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：mosun，腾讯 PCG 后台开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;文章分三部分展开陈述：ZooKeeper 核心知识、ZooKeeper 的典型应用实现原理、ZooKeeper 在中间件的落地案例。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了应对大流量，现代应用/中间件通常采用分布式部署，此时不得不考虑 CAP 问题。ZooKeeper（后文简称 ZK）是面向 CP 设计的一个开源的&lt;strong&gt;分布式协调框架&lt;/strong&gt;，将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用，分布式应用程序可以基于它实现诸如 &lt;strong&gt;数据发布/订阅、负载均衡、命名服务、集群管理、Master 选举、分布式锁、分布式队列&lt;/strong&gt; 等功能。ZK 之所以能够提供上述一套分布式数据一致性解决方案，核心在于其设计精妙的&lt;strong&gt;数据结构、watcher 机制、Zab 一致性协议等&lt;/strong&gt;，下面将依次剖析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据结构&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZK 在&lt;strong&gt;内存&lt;/strong&gt;中维护了一个&lt;strong&gt;类似文件系统的树状数据结构&lt;/strong&gt;实现命名空间（如下），树中的节点称为 &lt;strong&gt;znode&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43982494529540483&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpO3s5nVWUt5fKWGicN67UFer4FWsibOanjJY2cjhwBlaIl2bzWicE9fJZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;914&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而，znode 要比文件系统的路径复杂，既可以通过路径访问，又可以存储数据。znode 具有四个属性 data、acl、stat、children，如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DataNode&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Record&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    byte data[];&lt;br/&gt;    Long acl;&lt;br/&gt;    public StatPersisted stat;&lt;br/&gt;    private &lt;span&gt;Set&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; children = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;data&lt;/strong&gt;: znode 相关的业务数据均存储在这里，但是，&lt;strong&gt;父节点不可存储数据&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;children&lt;/strong&gt;: 存储当前节点的子节点引用信息，因为内存限制，所以 &lt;strong&gt;znode 的子节点数不是无限的&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;stat&lt;/strong&gt;: 包含 znode 节点的状态信息，比如: 事务 id、版本号、时间戳等，&lt;strong&gt;其中事务 id 和 ZK 的数据一直性、选主相关，下面将重点介绍&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;acl&lt;/strong&gt;: 记录客户端对 znode 节点的访问权限；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;：znode 的&lt;strong&gt;数据操作具有原子性&lt;/strong&gt;，读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。&lt;strong&gt;znode 可存储的最大数据量是 1MB&lt;/strong&gt; ，但实际上我们在 znode 的数据量应该尽可能小，因为数据过大会导致 zk 的性能明显下降。&lt;strong&gt;每个 ZNode 都对应一个唯一的路径&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事物 ID：Zxid&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zxid 由 Leader 节点生成。当有新写入事件时，Leader 节点生成新的 Zxid，并随提案一起广播。Zxid 的生成规则如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2366255144032922&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpT80ibxqicWz4k1erLqv06ZRwmkco41euWbAVnxiaKsGKicJhzJzhq7pzAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;972&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;epoch：任期/纪元，Zxid 的高 32 位， ZAB 协议通过 epoch 编号来区分 Leader 周期变化，每次一个 leader 被选出来，它都会有一个新的 epoch=（原来的 epoch+1），标识当前属于那个 leader 的 统治时期；可以假设 leader 就像皇帝，epoch 则相当于年号，每个皇帝都有自己的年号；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务计数器：Zxid 的低 32 位，每次数据变更，计数器都会加一；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;zxid 是递增的，所以谁的 zxid 越大，就表示谁的数据是最新的。每个节点都保存了当前最近一次事务的 Zxid。&lt;strong&gt;Zxid 对于 ZK 的数据一致性以及选主都有着重要意义&lt;/strong&gt;，后边在介绍相关知识时会重点讲解其作用原理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;znode 类型&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节点根据&lt;strong&gt;生命周期&lt;/strong&gt;的不同可以将划分为&lt;strong&gt;持久节点&lt;/strong&gt;和&lt;strong&gt;临时节点&lt;/strong&gt;。持久节点的存活时间不依赖于客户端会话，只有客户端在显式执行删除节点操作时，节点才消失；临时节点的存活时间依赖于客户端会话，当会话结束，临时节点将会被自动删除（当然也可以手动删除临时节点）。&lt;strong&gt;注意：临时节点不能拥有子节点&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;节点类型是在创建时进行制定，后续不能改变&lt;/strong&gt;。如&lt;code&gt;create /n1 node1&lt;/code&gt;创建了一个数据为”node1”的持久节点/n1；在上述指令基础上加上参数-e：&lt;code&gt;create -e /n1/n3 node3&lt;/code&gt;，则创建了一个数据为”node3”的临时节点 /n1/n3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;create 命令还有一个可选参数&lt;/strong&gt;-s &lt;strong&gt;用于指定创建的节点是否具有顺序特性&lt;/strong&gt;。创建顺序节点时，zk 会在路径后面自动追加一个 &lt;strong&gt;递增的序列号&lt;/strong&gt; ，这个序列号可以保证在&lt;strong&gt;同一个父节点下是唯一的&lt;/strong&gt;，利用该特性我们可以实现&lt;strong&gt;分布式锁&lt;/strong&gt; 等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 znode 的上述两组特性，两两组合后可构建 4 种类型的节点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;PERSISTENT：永久节点&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;EPHEMERAL：临时节点&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;PERSISTENT_SEQUENTIAL：永久顺序节点&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;EPHEMERAL_SEQUENTIAL：临时顺序节点&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Watcher 监听机制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Watcher 监听机制是 ZK 非常重要的一个特性。ZK 允许 Client 端在指定节点上注册 Watcher，监听节点数据变更、节点删除、子节点状态变更等事件，当特定事件发生时，ZK 服务端会异步通知注册了相应 Watcher 的客户端，通过该机制，我们可以利用 ZK 实现数据的发布和订阅等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Watcher 监听机制由三部分协作完成：ZK 服务端、ZK 客户端、客户端的 WatchManager 对象。工作时，客户端首先将 Watcher 注册到服务端，同时将 Watcher 对象保存到客户端的 Watch 管理器中。当 ZK 服务端监听的数据状态发生变化时，服务端会主动通知客户端，接着客户端的 Watch 管理器会触发相关 Watcher 来回调相应处理逻辑。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45794392523364486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxptcFVTM6W1gHnibyPlKWNcDFaN5iaOCHyiao7iaCMiaCpZYjDSPCPFtqybkg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1070&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;watcher 变更通知是一次性的&lt;/strong&gt;：当数据发生变化的时候， ZK 会产生一个 watcher 事件，并且会发送到客户端。但是客户端只会收到一次通知。如果后续这个节点再次发生变化，那么之前设置 Watcher 的客户端不会再次收到消息。可以通过循环监听去达到永久监听效果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;客户端 watcher 顺序回调&lt;/strong&gt;：watcher 回调是顺序串行化执行的，只有回调后客户端才能看到节点最新的状态。watcher 回调逻辑不应太复杂，否则可能影响 watcher 执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不会告诉节点变化前后的具体内容&lt;/strong&gt;：watchEvent 是最小的通信单元，结构上包含通知状态、事件类型和节点路径，但是，不会告诉节点变化前后的具体内容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;时效性&lt;/strong&gt;：watcher 只有在当前 session 彻底失效时才会无效，若在 session 有效期内快速重连成功，则 watcher 依然存在，仍可收到事件通知。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ZK 集群&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了确保服务的高可用性，ZK 采用集群化部署，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3467966573816156&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpxIqLn0wLJ5CKoicppbFZJsAP73TdbCpEwtdvywpTkrJBILxHfGIcgAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZK 集群服务器有三种角色：Leader、Follower 和 Observer&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Leader&lt;/strong&gt;：一个 ZK 集群同一时间只会有一个实际工作的 Leader，它会发起并维护与各 Follwer 及 Observer 间的心跳。所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Follower&lt;/strong&gt;：一个 ZK 集群可同时存在多个 Follower，它会响应 Leader 的心跳。Follower 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理，参与事务请求 Proposal 的投票及 Leader 选举投票。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Observer&lt;/strong&gt;：Observer 是 3.3.0 版本开始引入的一个服务器角色，一个 ZK 集群可同时存在多个 Observer， 功能与 Follower 类似，但是，不参与投票。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;“早期的 ZooKeeper 集群服务运行过程中，只有 Leader 服务器和 Follow 服务器。随着集群规模扩大，follower 变多，ZK 在创建节点和选主等事务性请求时，需要一半以上节点 AC，所以导致性能下降写入操作越来越耗时，follower 之间通信越来越耗时。为了解决这个问题，就引入了观察者，可以处理读，但是不参与投票。既保证了集群的扩展性，又避免过多服务器参与投票导致的集群处理请求能力下降。”&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZK 集群中通常有很多服务器，那么如何区分不同的服务器的角色呢？可以通过服务器的状态进行区分&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;LOOKING：寻找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LEADING：领导者状态。表明当前服务器角色是 Leader。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FOLLOWING：跟随者状态，同步 leader 状态，参与投票。表明当前服务器角色是 Follower。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OBSERVING：观察者状态，同步 leader 状态，不参与投票。表明当前服务器角色是 Observer。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZK 集群是一主多从的结构，所有的所有的写操作必须要通过 Leader 完成，Follower 可直接处理并返回客户端的读请求。那么如何保证从 Follower 服务器读取的数据与 Leader 写入的数据的一致性呢？Leader 万一由于某些原因崩溃了，如何选出新的 Leader，如何保证数据恢复？Leader 是怎么选出来的？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Zab 一致性协议&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZK 专门设计了 ZAB 协议(Zookeeper Atomic Broadcast)来保证主从节点数据的一致性。下面分别从 client 向 Leader 和 Follower 写数据场景展开陈述。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;写 Leader 场景数据一致性&lt;/span&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44536817102137766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpa04EFxj1agx7UZNSfBgM0BBaZDyib3ibZu5StDjIq6d1KoaQxHpKWWwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1684&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端向 Leader 发起写请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Leader 将写请求以 Proposal 的形式发给所有 Follower 并等待 ACK&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Follower 收到 Leader 的 Proposal 后返回 ACK&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Leader 得到过半数的 ACK（Leader 对自己默认有一个 ACK）后向所有的 Follower 和 Observer 发送 Commmit&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Leader 将处理结果返回给客户端&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Leader 不需要得到所有 Follower 的 ACK，只要收到过半的 ACK 即可，同时 Leader 本身对自己有一个 ACK。上图中有 4 个 Follower，只需其中两个返回 ACK 即可，因为(2+1) / (4+1) &amp;gt; 1/2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Observer 虽然无投票权，但仍须同步 Leader 的数据从而在处理读请求时可以返回尽可能新的数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;写 Follower 场景数据一致性&lt;/span&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4284037558685446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpVITaXlDMiaT1zyUWXyHVlibyrm783BC9flRN4G98ECxxSPdDNlfpcUFQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1704&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.客户端向 Follower 发起写请求， Follower 将写请求转发给 Leader 处理；&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;其它流程与直接写 Leader 无任何区别&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;：Observer 与 Follower 写流程相同&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最终一致性&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zab 协议消息广播使用两阶段提交的方式，达到主从数据的最终一致性。为什么是最终一致性呢？从上文可知数据写入过程核心分成下面两阶段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一阶段：Leader 数据写入事件作为提案广播给所有 Follower 结点；可以写入的 Follower 结点返回确认信息 ACK。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二阶段：Leader 收到一半以上的 ACK 信息后确认写入可以生效，向所有结点广播 COMMIT 将提案生效。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据写入过程的两阶段的描述，可以知道 ZooKeeper 保证的是最终一致性，即 Leader 向客户端返回写入成功后，可能有部分 Follower 还没有写入最新的数据，所以是最终一致性。ZooKeeper 保证的最终一致性也叫顺序一致性，即每个结点的数据都是严格按事务的发起顺序生效的。ZooKeeper 集群的写入是由 Leader 结点协调的，真实场景下写入会有一定的并发量，那 Zab 协议的两阶段提交是如何保证事务严格按顺序生效的呢？ZK 事物的顺序性是借助上文中的 Zxid 实现的。Leader 在收到半数以上 ACK 后会将提案生效并广播给所有 Follower 结点，Leader 为了保证提案按 ZXID 顺序生效，使用了一个 ConcurrentHashMap，记录所有未提交的提案，命名为 outstandingProposals，key 为 ZXID，Value 为提案的信息。对 outstandingProposals 的访问逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Leader 每发起一个提案，会将提案的 ZXID 和内容放到 outstandingProposals 中，作为待提交的提案；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Leader 收到 Follower 的 ACK 信息后，根据 ACK 中的 ZXID 从 outstandingProposals 中找到对应的提案，对 ACK 计数;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行 tryToCommit 尝试将提案提交：判断流程是，先判断当前 ZXID 之前是否还有未提交提案，如果有，当前提案暂时不能提交；再判断提案是否收到半数以上 ACK，如果达到半数则可以提交；如果可以提交，将当前 ZXID 从 outstandingProposals 中清除并向 Followers 广播提交当前提案；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Leader 是如何判断当前 ZXID 之前是否还有未提交提案的呢？由于前提是保证顺序提交的，所以 Leader 只需判断 outstandingProposals 里，当前 ZXID 的前一个 ZXID 是否存在。代码如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16984732824427481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpDicO2l8ELfFBzZg0X0Ol96LbIh2GTXp2sq2cfImVRdqyeibpgMOG5LYg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1048&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 ZooKeeper 是通过两阶段提交保证数据的最终一致性，并且通过严格按照 ZXID 的顺序生效提案保证其顺序一致性的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;选主原理&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZK 中默认的并建议使用的 Leader 选举算法是：基于 TCP 的 FastLeaderElection。在分析选举原理前，先介绍几个重要的参数。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;服务器 ID(myid)：每个 ZooKeeper 服务器，都需要在数据文件夹下创建一个名为 myid 的文件，该文件包含整个 ZooKeeper 集群唯一的 ID（整数）。该参数在选举时如果无法通过其他判断条件选择 Leader，那么将该 ID 的大小来确定优先级。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务 ID(zxid)：单调递增，值越大说明数据越新，权重越大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逻辑时钟(epoch-logicalclock)：同一轮投票过程中的逻辑时钟值是相同的，每投完一次值会增加。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZK 的 leader 选举存在两类，一个是服务器启动时 leader 选举，另一个是运行过程中服务器宕机时的 leader 选举，下面依次展开介绍。以下两节引自&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649770438&amp;amp;idx=1&amp;amp;sn=a23ed1876fea4973df76c560c040fbb9&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;从 0 到 1 详解 ZooKeeper 的应用场景及架构&lt;/a&gt; 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;服务器启动时的 leader 选举&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、&lt;strong&gt;各自推选自己&lt;/strong&gt;：ZooKeeper 集群刚启动时，所有服务器的 logicClock 都为 1，zxid 都为 0。各服务器初始化后，先把第一票投给自己并将它存入自己的票箱，同时广播给其他服务器。此时各自的票箱中只有自己投给自己的一票，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.674074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpFU4g8TQnIOlJH7ATKMxkB9ydm9wdXNrhhbArzE0tv08N3vxuVzJKUw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、&lt;strong&gt;更新选票&lt;/strong&gt;：第一步中各个服务器先投票给自己，并把投给自己的结果广播给集群中的其他服务器，这一步其他服务器接收到广播后开始更新选票操作，以 Server1 为例流程如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）Server1 收到 Server2 和 Server3 的广播选票后，由于 logicClock 和 zxid 都相等，此时就比较 myid；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Server1 收到的两张选票中 Server3 的 myid 最大，此时 Server1 判断应该遵从 Server3 的投票决定，将自己的票改投给 Server3。接下来 Server1 先清空自己的票箱(票箱中有第一步中投给自己的选票)，然后将自己的新投票(1-&amp;gt;3)和接收到的 Server3 的(3-&amp;gt;3)投票一起存入自己的票箱，再把自己的新投票决定(1-&amp;gt;3)广播出去,此时 Server1 的票箱中有两票：(1-&amp;gt;3),(3-&amp;gt;3)；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）同理，Server2 收到 Server3 的选票后也将自己的选票更新为（2-&amp;gt;3）并存入票箱然后广播。此时 Server2 票箱内的选票为(2-&amp;gt;3)，(3-&amp;gt;3)；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）Server3 根据上述规则，无须更新选票，自身的票箱内选票仍为（3-&amp;gt;3）；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）Server1 与 Server2 重新投给 Server3 的选票广播出去后，由于三个服务器最新选票都相同，最后三者的票箱内都包含三张投给服务器 3 的选票。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6509259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpz9bfW5mOt3aGNYiasxF7GUtSF5GQHGLibku0STxUtDa2sK4j8b7dWLHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、&lt;strong&gt;根据选票确定角色&lt;/strong&gt;：根据上述选票，三个服务器一致认为此时 Server3 应该是 Leader。因此 Server1 和 Server2 都进入 FOLLOWING 状态，而 Server3 进入 LEADING 状态。之后 Leader 发起并维护与 Follower 间的心跳。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6527777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpOn0l7cttFJ1sGnVw7CYWYK2q15LVaYhU35qXImemr7krsGGQ5Y7KqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;运行时 Follower 重启选举&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本节讨论 Follower 节点发生故障重启或网络产生分区恢复后如何进行选举。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、&lt;strong&gt;Follower 重启投票给自己&lt;/strong&gt;：Follower 重启，或者发生网络分区后找不到 Leader，会进入 LOOKING 状态并发起新的一轮投票。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpDWq7zIDWgicDIiavxeXhiabg1bgR6g7d12smtFcoB5jZeg8xpL41u0LOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、&lt;strong&gt;发现已有 Leader 后成为 Follower&lt;/strong&gt;：Server3 收到 Server1 的投票后，将自己的状态 LEADING 以及选票返回给 Server1。Server2 收到 Server1 的投票后，将自己的状态 FOLLOWING 及选票返回给 Server1。此时 Server1 知道 Server3 是 Leader，并且通过 Server2 与 Server3 的选票可以确定 Server3 确实得到了超过半数的选票。因此服务器 1 进入 FOLLOWING 状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6657407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpic8GFktV37w8XkRl1Lk5cdL6lO74q3bvpQjL3b7sPvqUSJLBfF9NZlg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;运行时 Leader 重启选举&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Follower 发起新投票&lt;/strong&gt;：Leader（Server3）宕机后，Follower（Server1 和 2）发现 Leader 不工作了，因此进入 LOOKING 状态并发起新的一轮投票，并且都将票投给自己，同时将投票结果广播给对方。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.671147880041365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpaKfP8V1SX5kcsDomnibAvfE30NtTB51saoUIkAwiaiajDCSTnJXEwFNDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;967&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、&lt;strong&gt;更新选票&lt;/strong&gt;：（1）Server1 和 2 根据外部投票确定是否要更新自身的选票，这里跟之前的选票 PK 流程一样，比较的优先级为：logicLock &amp;gt; zxid &amp;gt; myid，这里 Server1 的参数(L=3, M=1, Z=11)和 Server2 的参数(L=3, M=2, Z=10)，logicLock 相等，zxid 服务器 1 大于服务器 2，因此服务器 2 就清空已有票箱，将(1-&amp;gt;1)和(2-&amp;gt;1)两票存入票箱，同时将自己的新投票广播出去 （2）服务器 1 收到 2 的投票后，也将自己的票箱更新。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6721991701244814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxppSfzfsSYR6Du4db6TJEQpIGXcIFicSWH23q7kpafIdklldS7jdouATA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;964&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、&lt;strong&gt;重新选出 Leader&lt;/strong&gt;：此时由于只剩两台服务器，服务器 1 投票给自己，服务器 2 投票给 1，所以 1 当选为新 Leader。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6680286006128703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpdo4PMvv8U3SUaDzEicMBibiafkR3AItUpRdblhT27MOicptHt0FaVda5HA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;979&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、&lt;strong&gt;旧 Leader 恢复发起选举&lt;/strong&gt;：之前宕机的旧 Leader 恢复正常后，进入 LOOKING 状态并发起新一轮领导选举，并将选票投给自己。此时服务器 1 会将自己的 LEADING 状态及选票返回给服务器 3，而服务器 2 将自己的 FOLLOWING 状态及选票返回给服务器 3。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6721479958890031&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpUrfYEQSz3P61Fp8CEM3iaZs3ffGPeNL5eRciaRfn1ItpIIypdVmOaAiaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;973&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、&lt;strong&gt;旧 Leader 成为 Follower&lt;/strong&gt;：服务器 3 了解到 Leader 为服务器 1，且根据选票了解到服务器 1 确实得到过半服务器的选票，因此自己进入 FOLLOWING 状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpFTmicqwDbBBT7zeXMzia4AnTOfZJibPnR82kJ2GhNENzuPgf8nmL7Ckmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;963&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;脑裂&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一主多从类的集群应用，通常要考虑脑裂问题，脑裂会导致数据不一致。那么，什么是脑裂？简单点来说，就是一个集群有两个 master。通常脑裂产生原因如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;假死：由于心跳超时（网络原因导致的）认为 Leader 死了，但其实 Leader 还存活着。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;脑裂：由于假死会发起新的 Leader 选举，选举出一个新的 Leader，但旧的 Leader 网络又通了，导致出现了两个 Leader ，有的客户端连接到老的 Leader，而有的客户端则连接到新的 Leader。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常解决脑裂问题有 Quorums（法定人数）方式、Redundant communications（冗余通信）方式、仲裁、磁盘锁等方式。ZooKeeper 采用 Quorums 这种方式来防止“脑裂”现象，&lt;strong&gt;只有集群中超过半数节点投票才能选举出 Leader&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;典型应用场景&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据发布/订阅&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可基于 ZK 的 Watcher 监听机制实现数据的发布与订阅功能。ZK 的发布订阅模式采用的是推拉结合的方式实现的，实现原理如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4151291512915129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxp0tYqadicKJiazYwmEYKEagQaYDbCmia4szPZ4V07drwPYicUYao7mLClzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1084&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当集群中的服务启动时，客户端向 ZK 注册 watcher 监听特定节点，并从节点拉取数据获取配置信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当发布者变更配置时，节点数据发生变化，ZK 会发送 watcher 事件给各个客户端；客户端在接收到 watcher 事件后，会从该节点重新拉取数据获取最新配置信息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：Watch 具有一次性，所以当获得服务器通知后要再次添加 Watch 事件。&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;负载均衡&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用 ZK 的临时节点、watcher 机制等特性可实现负载均衡，具体思路如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.66553480475382&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpmciaNibvmZjFibVqibw6gYPcsQIq1erAbhkPP0loJ4NRwyCKGRpDHgbTtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1178&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把 ZK 作为一个服务的注册中心，基本流程:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;服务提供者 server 启动时在 ZK 进行服务注册（创建临时文件）;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务消费者 client 启动时，请求 ZK 获取最新的服务存活列表并注册 watcher，然后将获得服务列表保存到本地缓存中;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;client 请求 server 时，根据自己的负载均衡算法，从服务器列表选取一个进行通信。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若在运行过程中，服务提供者出现异常或人工关闭不能提供服务，临时节点失效，ZK 探测到变化更新本地服务列表并异步通知到服务消费者，服务消费者监听到服务列表的变化，更新本地缓存&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;：服务发现可能存在延迟，因为服务提供者挂掉到缓存更新大约需要 3-5s 的时间（根据网络环境不同还需仔细测试）。为了保证服务的实时可用，client 请求 server 发生异常时，需要根据服务消费报错信息，进行重负载均衡重试等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;命名服务&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名服务是指通过指定的名字来获取资源或者服务的地址、提供者等信息。以 znode 的路径为名字，znode 存储的数据为值，可以很容易构建出一个命名服务。例如 Dubbo 使用 ZK 来作为其命名服务，如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41519250780437045&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpc56XLBpsHdJHpf8f6fGKZfNj6coHjE0o2HMYKpvnZYOtvQuVnia5OmQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1922&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;所有 Dubbo 相关的数据都组织在 &lt;code&gt;/dubbo&lt;/code&gt; 的根节点下；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二级目录是服务名，如 &lt;code&gt;com.foo.BarService&lt;/code&gt; ；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;三级目录有两个子节点，分别是 &lt;code&gt;providers&lt;/code&gt; 和 &lt;code&gt;consumers&lt;/code&gt; ，表示该服务的提供者和消费者；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;四级目录记录了与该服务相关的每一个应用实例的 URL 信息，在 &lt;code&gt;providers&lt;/code&gt; 下的表示该服务的所有提供者，而在 &lt;code&gt;consumers&lt;/code&gt; 下的表示该服务的所有消费者。举例说明， &lt;code&gt;com.foo.BarService&lt;/code&gt; 的服务提供者在启动时将自己的 URL 信息注册到 &lt;code&gt;/dubbo/com.foo.BarService/providers&lt;/code&gt; 下；同样的，服务消费者将自己的信息注册到相应的 &lt;code&gt;consumers&lt;/code&gt; 下，同时，服务消费者会订阅其所对应的 &lt;code&gt;providers&lt;/code&gt; 节点，以便能够感知到服务提供方地址列表的变化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;集群管理&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 ZK 的临时节点和 watcher 监听机制可实现集群管理。集群管理通常指监控集群中各个主机的运行时状态、存活状况等信息。如下图所示，主机向 ZK 注册临时节点，监控系统注册监听集群下的临时节点，从而获取集群中服务的状态等信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562273276904474&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpDXm2lCqRcbBpvXdxmWfMwypGurLzrj195F4PjJULELaUNEPWrIlysA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1654&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Master 选举&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZK 中某节点同一层子节点，名称具有唯一性，所以，多个客户端创建同一节点时，只会有一个客户端成功。利用该特性，可以实现 maser 选举，具体如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4642857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpqul7ib2GINM5fm2wvUPngIVicuicem1lscePoibpk0CTXfRJIPb3vSiaOvg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1008&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;多个客户端同时竞争创建同一临时节点/master-election/master，最终只能有一个客户端成功。这个成功的客户端成为 Master，其它客户端置为 Slave。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Slave 客户端都向这个临时节点的父节点/master-election 注册一个子节点列表的 watcher 监听。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一旦原 Master 宕机，临时节点就会消失，zk 服务器就会向所有 Slave 发送子节点变更事件，Slave 在接收到事件后会竞争创建新的 master 临时子节点。谁创建成功，谁就是新的 Master。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式锁&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 ZK 的临时顺序节点和 Watcher 机制可实现公平分布式锁。下面具体看下多客户端获取及释放 zk 分布式锁的整个流程及背后的原理。下面过程引自&lt;a href=&quot;https://juejin.cn/post/6844903729406148622&quot; data-linktype=&quot;2&quot;&gt;七张图彻底讲清楚 ZooKeeper 分布式锁的实现原理【石杉的架构笔记】&lt;/a&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如说客户端 A 先发起请求，就会搞出来一个顺序节点，大家看下面的图，Curator 框架大概会弄成如下的样子：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25651577503429357&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpwT4bwzhfMBBQud5fdGXwxu9oHbggTTtSgibLiaLc6O4ic2OicSrmV4kzxA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1458&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一大坨长长的名字都是 Curator 框架自己生成出来的。然后，因为客户端 A 是第一个发起请求的，所以给他搞出来的顺序节点的序号是&quot;1&quot;。接着客户端 A 会查一下&quot;&lt;strong&gt;my_lock&lt;/strong&gt;&quot;这个锁节点下的所有子节点，并且这些子节点是按照序号排序的，这个时候大概会拿到这么一个集合：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14162348877374784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxp3mGsnMKFx2EYbiaQicYRKwY2YJvSxMDOkiaSKTBehonOEJn9IXV9d4GVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1158&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着客户端 A 会走一个关键性的判断：唉！兄弟，这个集合里，我创建的那个顺序节点，是不是排在第一个啊？如果是的话，那我就可以加锁了啊！因为明明我就是第一个来创建顺序节点的人，所以我就是第一个尝试加分布式锁的人啊！bingo！&lt;strong&gt;加锁成功&lt;/strong&gt;！大家看下面的图，再来直观的感受一下整个过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.330718954248366&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxprv4NeR6AAfbPwHsa6Xia63ia7qGq0DflDUQyVvl0VtTWvRb561GwiaictQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1530&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如说客户端 A 加完锁完后，客户端 B 过来想要加锁，这个时候它会干一样的事儿：先是在&quot;&lt;strong&gt;my_lock&lt;/strong&gt;&quot;这个锁节点下创建一个&lt;strong&gt;临时顺序节点&lt;/strong&gt;，因为是第二个来创建顺序节点的，所以 zk 内部会维护序号为&quot;2&quot;。接着客户端 B 会走加锁判断逻辑，查询&quot;&lt;strong&gt;my_lock&lt;/strong&gt;&quot;锁节点下的所有子节点，按序号顺序排列，此时看到的类似于：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19316239316239317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpCEkZ4U6kcSVH26oAqlxazSsphLvmQtib8VZ3CH9eU1OiaHjmaCzQcXFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1170&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时检查自己创建的顺序节点，是不是集合中的第一个？明显不是，此时第一个是客户端 A 创建的那个顺序节点，序号为&quot;01&quot;的那个。&lt;strong&gt;所以加锁失败&lt;/strong&gt;！加锁失败了以后，客户端 B 就会通过 ZK 的 API 对他的顺序节点的&lt;strong&gt;上一个顺序节点加一个监听器，&lt;/strong&gt; 即对客户端 A 创建的那个顺序节加监听器！如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4479025710419486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpvVBZAmFIdiaowBCqnh7HiakLLU2QVFticmpoSsIHiaUBdMEIzgKt5v6kJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1478&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，客户端 A 加锁之后，可能处理了一些代码逻辑，然后就会释放锁。那么，释放锁是个什么过程呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实很简单，就是把自己在 zk 里创建的那个顺序节点，也就是：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06260869565217392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxptDBj1ibb1zVnwfGb4PB5uVO8DKMSlEc00WumY9y1FTcsCfo3UHBHldg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1150&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个节点被删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除了那个节点之后，zk 会负责通知监听这个节点的监听器，也就是客户端 B 之前加的那个监听器，说：兄弟，你监听的那个节点被删除了，有人释放了锁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4754316069057105&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpkmVZKEX9nnbg8e2NNVyqo1pQC0CPlpThDgiaDSFq9dVgBYIkhDTVuXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1506&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时客户端 B 的监听器感知到了上一个顺序节点被删除，也就是排在他之前的某个客户端释放了锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，就会通知客户端 B 重新尝试去获取锁，也就是获取&quot;&lt;strong&gt;my_lock&lt;/strong&gt;&quot;节点下的子节点集合，此时为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1433628318584071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpV6K6Zr3our4uoGueJk4VFp4m7vIFc6caPa8V8kzM2ia4VbdKU8nmt1Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1130&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集合里此时只有客户端 B 创建的唯一的一个顺序节点了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后呢，客户端 B 判断自己居然是集合中的第一个顺序节点，bingo！可以加锁了！&lt;strong&gt;直接完成加锁&lt;/strong&gt;，运行后续的业务代码即可，运行完了之后再次释放锁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.523680649526387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpYhnzlqyOibYnnrceNLtDS9icbWDaIkLiaS2Hq2Z3yaFDd0Qar9Fs3BYuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1478&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;：利用 ZK 实现分布式锁时要避免出现&lt;strong&gt;惊群效应&lt;/strong&gt;。上述策略中，客户端 B 通过监听比其节点顺序小的那个临时节点，解决了惊群效应问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式队列&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 ZK 的临时顺序节点和 Watcher 机制可实现简单的 FIFO 分布式队列。ZK 分布式队列和上节中的分布式锁本质是一样的，都是基于对上一个顺序节点进行监听实现的。具体原理如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7040417209908736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpicG9qV4wKTSkpW95kcLmIJxmwKhkBLm27mTickkycTVN3j01AKJ0f09w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1534&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;利用顺序节点的有序性，为每个数据在/FIFO 下创建一个相应的临时子节点；且每个消费者均在/FIFO 注册一个 watcher；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者从分布式队列获取数据时，首先尝试获取分布式锁，获取锁后从/FIFO 获取序号最小的数据，消费成功后，删除相应节点；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于消费者均监听了父节点/FIFO，所以均会收到数据变化的异步通知，然后重复 2 的过程，尝试消费队列数据。依此循环，直到消费完毕。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;中间件落地案例&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZK 在 Kafka 集群中扮演着极其重要的角色。Kafka 中很多信息都在 ZK 中维护，如 broker 集群信息、consumer 集群信息、 topic 相关信息、 partition 信息等。Kafka 的很多功能也是基于 ZK 实现的，如 partition 选主、broker 集群管理、consumer 负载均衡等，限于篇幅本文将不展开陈述，这里先附一张网上截图大家感受下，详情将在 Kafka 专题中细聊。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6625766871165644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauWbTm4m4ERUG6pZgCL2mxpXdZRiaUWoiaRQ3naibic3TJkVArnKcQX4qc5W1JodV9Nfr3icQfvSuVgHxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1630&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Dubbo&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dubbo 使用 Zookeeper 用于服务的注册发现和配置管理，详情见上文“命名服务”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://mp.weixin.qq.com/s/tiAQQXbh7Tj45_1IQmQqZg&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.jianshu.com/p/68b45694026c&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://time.geekbang.org/column/article/239261&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://blog.csdn.net/lihao21/article/details/51810395&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/378018463&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://juejin.cn/post/6974737393324654628&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://blog.csdn.net/liuao107329/article/details/78936160&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://blog.csdn.net/en_joker/article/details/78799737&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://blog.51cto.com/u_15077535/4199740&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://juejin.cn/post/6844903729406148622&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://blog.csdn.net/Saintmm/article/details/124110149&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.wumingx.com/linux/zk-kafka.html&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;抽奖红包封面&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2055555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvav94uOctNEdjFIaJORnOrUaYo5zibJtxZrd1093aankWOOcGsljyqTfeRLACTVibJczpibb6J62jYsgA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;后台回复：&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;1024 &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;参与&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasvpPfMrktl2xvC9A325p8Qa9dFeEzxZmZ2O1XuFGsVXyQhG9Dia8J8nTXVtzNcHozr0umH3R4iboXg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>70122757e65cf71184e38a9f7cf4a473</guid>
<title>如何解决前端领域的竞态问题？</title>
<link>https://toutiao.io/k/a5jzkdu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;今天&lt;/span&gt;&lt;span&gt;我们聊聊前端常见的竞态问题。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读完本文，你将会知道：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是竞态问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通常出现在哪些场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解决竞态问题有哪些方法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是竞态问题&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;竞态问题&lt;/strong&gt;，又叫&lt;strong&gt;竞态条件&lt;/strong&gt;（race condition），它旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。&lt;/p&gt;&lt;p&gt;此词源自于两个信号试着彼此竞争，来影响谁先输出。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，它出现的原因是无法保证异步操作的完成会按照他们开始时同样的顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个🌰，有一个分页列表，我们快速地切换第二页，第三页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会先后请求 data2 与 data3，分页器显示当前在第三页，并且进入 loading。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于网络的不确定性，先发出的请求不一定先响应，有可能 data3
比 data2 先返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终，请求返回 data2 后，分页器指示当前在第三页，但展示的是第二页的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是竞态条件，在前端开发中，常见于搜索，分页，选项卡等切换的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何解决竞态问题呢？在以上这些场景中，我们很容易想到：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当发出新的请求时，取消掉上次请求即可。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;取消过期请求&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有哪些方法可以取消请求呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;XMLHttpRequest 取消请求&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XMLHttpRequest（XHR）是一个内建的浏览器对象，它允许使用 JavaScript 发送 HTTP 请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果请求已被发出，可以使用 abort() 方法立刻中止请求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; xhr= &lt;span&gt;new&lt;/span&gt; XMLHttpRequest();&lt;br/&gt;&lt;br/&gt;xhr.open(&lt;span&gt;&#x27;GET&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;https://xxx&#x27;&lt;/span&gt;);&lt;br/&gt;xhr.send();&lt;br/&gt;    &lt;br/&gt;xhr.abort(); &lt;span&gt;// 取消请求&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;fetch API 取消请求&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fetch 号称是 AJAX 的替代品，出现于 ES6，它也可以发出类似 XMLHttpRequest 的网络请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要的区别在于 fetch 使用了 promise，要中止 fetch 发出的请求，需要使用 &lt;code&gt;AbortController&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; controller = &lt;span&gt;new&lt;/span&gt; AbortController();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; signal = controller.signal;&lt;br/&gt;&lt;br/&gt;fetch(&lt;span&gt;&#x27;/xxx&#x27;&lt;/span&gt;, {&lt;br/&gt;  signal,&lt;br/&gt;}).then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;response&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;controller.abort(); &lt;span&gt;// 取消请求&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;axios 取消请求&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;axios 是一个 HTTP 请求库，本质是对原生 XMLHttpRequest 的封装
后基于 promise 的实现版本，因此 axios 请求也可以被取消。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以利用 axios 的 CancelToken API 取消请求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; source = axios.CancelToken.source();&lt;br/&gt;&lt;br/&gt;axios.get(&lt;span&gt;&#x27;/xxx&#x27;&lt;/span&gt;, {&lt;br/&gt;  cancelToken: source.token&lt;br/&gt;}).then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;response&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;source.cancel() &lt;span&gt;// 取消请求&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 cancel 时，axios 会在内部调用 promise.reject() 与 xhr.abort()。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33853354134165364&quot; data-type=&quot;png&quot; data-w=&quot;1282&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K0dLoicpO1icfSVEyia1iaX6Rl1I5m7ZwskKClSMCIabldpO2XicbIkFhrIg3JjHxM88eZbnAtdjjo0GrMShHjZvqwg/640?wx_fmt=png&quot;/&gt;所以我们在处理请求错误时，需要判断 error 是否是 cancel 导致的，与常规错误区分处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;axios.get(&lt;span&gt;&#x27;/xxx&#x27;&lt;/span&gt;, {&lt;br/&gt;  cancelToken: source.token&lt;br/&gt;}).catch(&lt;span&gt;function&lt;/span&gt;(err) { &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (axios.isCancel(err)) {&lt;br/&gt;    console.log(&lt;span&gt;&#x27;Request canceled&#x27;&lt;/span&gt;, err.message);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    // 处理错误&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 cancelToken 从 v0.22.0 开始已被 axios 弃用。原因是基于实现该 API 的提案 &lt;span&gt;cancelable promises proposal&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 已被撤销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 v0.22.0 开始，axios 支持以 fetch API 方式的 AbortController 取消请求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; controller = &lt;span&gt;new&lt;/span&gt; AbortController();&lt;br/&gt;&lt;br/&gt;axios.get(&lt;span&gt;&#x27;/xxx&#x27;&lt;/span&gt;, {&lt;br/&gt;  signal: controller.signal&lt;br/&gt;}).then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;response&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;controller.abort() &lt;span&gt;// 取消请求&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，在处理请求错误时，也需要判断 error 是否来自 cancel。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;可取消的 promise&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原生 promise 并不支持 cancel，但 cancel 对于异步操作来说又是个很常见的需求。所以社区很多仓库都自己实现了 promise 的 cancel 能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以 &lt;span&gt;awesome-imperative-promise&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 为例，来看看 cancel 的实现，它的 cancel 实现基于&lt;strong&gt;指令式 promise&lt;/strong&gt;，源码一共只有 40 行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是指令式 promise？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们普遍使用的 promise，它的 resolve/reject 只能在 new Promise 内部调用，而指令式 promise 支持在 promise 外部手动调用 resolve/reject 等指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过它的用法能更好地理解何为指令式 promise：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { createImperativePromise } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;awesome-imperative-promise&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { resolve, reject, cancel } = createImperativePromise(promise);&lt;br/&gt;&lt;br/&gt;resolve(&lt;span&gt;&quot;some value&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// or&lt;/span&gt;&lt;br/&gt;reject(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;());&lt;br/&gt;&lt;span&gt;// or&lt;/span&gt;&lt;br/&gt;cancel();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部的 cancel 方法其实就是将 resolve，reject 设为 null，让 promise 永远不会 resolve/reject。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7965116279069767&quot; data-type=&quot;png&quot; data-w=&quot;688&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K0dLoicpO1icfSVEyia1iaX6Rl1I5m7ZwskKwso01CFYoV4zEBGRuWOlibky27QIKWhxCqZY5hICicdiagUr5QgLwMDmQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一直没有 resolve 也没有 reject 的 promise 会造成内存泄露吗？&lt;/p&gt;&lt;p&gt;有兴趣的同学可以了解下&lt;span&gt;这篇知乎提问&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;，回答众说纷纭。&lt;/p&gt;&lt;p&gt;我个人认为，如果没有保留对 promise 的引用，就不会造成内存泄露。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到 promise cancel，可以看到，虽然 API 命名为 cancel，但实际上没有任何 cancel 的动作，promise 的状态还是会正常流转，只是回调不再执行，被“忽略”了，所以看起来像被 cancel 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此解决竞态问题的方法，除了「取消请求」，还可以「忽略请求」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当请求响应时，只要判断返回的数据是否需要，如果不是则忽略即可。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;忽略过期请求&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们又有哪些方式来忽略过期的请求呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;封装指令式 promise&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用指令式 promise，我们可以手动调用 cancel API 来忽略上次请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果每次都需要手动调用，会导致项目中相同的模板代码过多，偶尔也可能忘记 cancel。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以基于指令式 promise 封装一个自动忽略过期请求的高阶函数 &lt;code&gt;onlyResolvesLast&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在每次发送新请求前，cancel 掉上一次的请求，忽略它的回调。&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;onlyResolvesLast&lt;/span&gt;(&lt;span&gt;fn&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 保存上一个请求的 cancel 方法&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; cancelPrevious = &lt;span&gt;null&lt;/span&gt;; &lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; wrappedFn = &lt;span&gt;(&lt;span&gt;...args&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 当前请求执行前，先 cancel 上一个请求&lt;/span&gt;&lt;br/&gt;    cancelPrevious &amp;amp;&amp;amp; cancelPrevious();&lt;br/&gt;    &lt;span&gt;// 执行当前请求&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; result = fn.apply(&lt;span&gt;this&lt;/span&gt;, args); &lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 创建指令式的 promise，暴露 cancel 方法并保存&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { promise, cancel } = createImperativePromise(result);&lt;br/&gt;    cancelPrevious = cancel;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; promise;&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; wrappedFn;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是 &lt;span&gt;awesome-only-resolves-last-promise&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要将 &lt;code&gt;onlyResolvesLast&lt;/code&gt; 包装一下请求方法，就能实现自动忽略，减少很多模板代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fn = &lt;span&gt;(&lt;span&gt;duration&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;r&lt;/span&gt; =&amp;gt;&lt;/span&gt; {    &lt;br/&gt;    setTimeout(r, duration);  &lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; wrappedFn = onlyResolvesLast(fn);&lt;br/&gt;&lt;br/&gt;wrappedFn(&lt;span&gt;500&lt;/span&gt;).then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;wrappedFn(&lt;span&gt;1000&lt;/span&gt;).then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;wrappedFn(&lt;span&gt;100&lt;/span&gt;).then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 输出 3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用唯一 id 标识每次请求&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了指令式 promise，我们还可以给「请求标记 id」的方式来忽略上次请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体思路是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;利用全局变量记录最新一次的请求 id&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在发请求前，生成唯一 id 标识该次请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在请求回调中，判断 id 是否是最新的 id，如果不是，则忽略该请求的回调&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; fetchId = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;// 保存最新的请求 id&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; getUsers = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 发起请求前，生成新的 id 并保存&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; id = fetchId + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  fetchId = id;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; 请求&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// 判断是最新的请求 id 再处理回调&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (id === fetchId) {&lt;br/&gt;    &lt;span&gt;// 请求处理&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的使用方法也会在项目中产生很多模板代码，经过封装后，也能实现一套同样用法的 &lt;code&gt;onlyResolvesLast&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;onlyResolvesLast&lt;/span&gt;(&lt;span&gt;fn&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 利用闭包保存最新的请求 id&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; id = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; wrappedFn = &lt;span&gt;(&lt;span&gt;...args&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 发起请求前，生成新的 id 并保存&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; fetchId = id + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    id = fetchId;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 执行请求&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; result = fn.apply(&lt;span&gt;this&lt;/span&gt;, args);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// result 可能不是 promise，需要包装成 promise&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;Promise&lt;/span&gt;.resolve(result).then(&lt;span&gt;(&lt;span&gt;value&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 只处理最新一次请求&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (fetchId === id) { &lt;br/&gt;          resolve(value);&lt;br/&gt;        }&lt;br/&gt;      }, &lt;span&gt;(&lt;span&gt;error&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 只处理最新一次请求&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (fetchId === id) {&lt;br/&gt;          reject(error);&lt;br/&gt;        }&lt;br/&gt;      });&lt;br/&gt;    })&lt;br/&gt;  };&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; wrappedFn;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用法也一样，使用 &lt;code&gt;onlyResolvesLast&lt;/code&gt; 包装一下请求方法，实现过期请求自动忽略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，这样的实现不依赖指令式 promise，也更轻量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fn = &lt;span&gt;(&lt;span&gt;duration&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;r&lt;/span&gt; =&amp;gt;&lt;/span&gt; {    &lt;br/&gt;    setTimeout(r, duration);  &lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; wrappedFn = onlyResolvesLast(fn);&lt;br/&gt;&lt;br/&gt;wrappedFn(&lt;span&gt;500&lt;/span&gt;).then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;wrappedFn(&lt;span&gt;1000&lt;/span&gt;).then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;wrappedFn(&lt;span&gt;100&lt;/span&gt;).then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 输出 3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;「取消」和「忽略」的比较&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;「取消」更实际&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果请求被「取消」了没有到达服务端，那么可以一定程度减轻服务的压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是取消请求也依赖底层的请求 API，比如 XMLHttpRequest 需要用 abort，而 fetch API 和 axios 需要用 AbortController。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;「忽略」更通用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而「忽略」的方式，不依赖请求的 API，更加通用，更容易抽象和封装。本质上所有的异步方法都可以使用 onlyResolvesLast 来忽略过期的调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个更实际，一个更通用，两者的使用需要根据具体场景来权衡。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前端常见的搜索，分页，选项卡等切换的场景中。由于网络的不确定性，先发出的请求不一定先响应，这会造成竞态问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决竞态问题，我们可以选择「取消」或「忽略」过期请求。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;「取消请求」，XMLHttpRequest 可以使用 abort 方法，fetch API 以及 axios 可以使用 AbortController&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;「忽略请求」，可以基于指令式 promise 或请求 id 的方式封装高阶函数来减少模板代码&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种方式各有各的好，需要根据实际场景权衡利弊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实解决方式不止这些，像 React Query，GraphQL，RxJS 等内部都有竞态处理，有兴趣的同学可以再深入了解。&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0MDMwMzQyOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQzPbKGcyI5H2Cn04KNKcY27cHJjtib3BNqmf4Tm0IaIry32OCnqAz0576nFxEsbubCwVIzmaz5hMw/0?wx_fmt=png&quot; data-nickname=&quot;code秘密花园&quot; data-alias=&quot;code_mmhy&quot; data-signature=&quot;这里有最前沿的前端技术、最新的前端消息、最精品的技术文章、最好用的工具推荐、还有一个有趣的作者。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;cancelable promises proposal: &lt;em&gt;https://github.com/tc39/proposal-cancelable-promises&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;awesome-imperative-promise: &lt;em&gt;https://github.com/slorber/awesome-imperative-promise&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;这篇知乎提问: &lt;em&gt;https://www.zhihu.com/question/386595851&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;awesome-only-resolves-last-promise: &lt;em&gt;https://github.com/slorber/awesome-only-resolves-last-promise/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c127ca6b6e16bbeccd4ab9e1a815c3f5</guid>
<title>十分钟搞懂 Java 限流及常见方案</title>
<link>https://toutiao.io/k/qmn9zav</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42407199100112486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8KKrHK5ic6XClpkwSjF7kRsNEUtqO5K6KzoibHl5VMVJoTI0RkmrGvn2DoHf5sGAMl7xibYFbygWA606aIKvFa3RQ/640?wx_fmt=jpeg&quot; data-w=&quot;889&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对一般的限流场景来说它具有两个维度的信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;时间 限流基于某段时间范围或者某个时间点，也就是我们常说的“时间窗口”，比如对每分钟、每秒钟的时间窗口做限定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;资源 基于可用资源的限制，比如设定最大访问次数，或最高可用连接数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面两个维度结合起来看，限流就是在某个时间窗口对资源访问做限制，比如设定每秒最多100个访问请求。但在真正的场景里，我们不止设置一种限流规则，而是会设置多个限流规则共同作用，主要的几种限流规则如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于连接数和QPS)限流来说，我们可设定IP维度的限流，也可以设置基于单个服务器的限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真实环境中通常会设置多个维度的限流规则，比如设定同一个IP每秒访问频率小于10，连接数小于5，再设定每台机器QPS最高1000，连接数最大保持200。更进一步，我们可以把某个服务器组或整个机房的服务器当做一个整体，设置更high-level的限流规则，这些所有限流规则都会共同作用于流量控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于“传输速率”大家都不会陌生，比如资源的下载速度。有的网站在这方面的限流逻辑做的更细致，比如普通注册用户下载速度为100k/s，购买会员后是10M/s，这背后就是基于用户组或者用户标签的限流逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;黑白名单是各个大型企业应用里很常见的限流和放行手段，而且黑白名单往往是动态变化的。举个例子，如果某个IP在一段时间的访问次数过于频繁，被系统识别为机器人用户或流量攻击，那么这个IP就会被加入到黑名单，从而限制其对系统资源的访问，这就是我们俗称的“封IP”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平时见到的爬虫程序，比如说爬知乎上的美女图片，或者爬券商系统的股票分时信息，这类爬虫程序都必须实现更换IP的功能，以防被加入黑名单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时我们还会发现公司的网络无法访问12306这类大型公共网站，这也是因为某些公司的出网IP是同一个地址，因此在访问量过高的情况下，这个IP地址就被对方系统识别，进而被添加到了黑名单。使用家庭宽带的同学们应该知道，大部分网络运营商都会将用户分配到不同出网IP段，或者时不时动态更换用户的IP地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;白名单就更好理解了，相当于御赐金牌在身，可以自由穿梭在各种限流规则里，畅行无阻。比如某些电商公司会将超大卖家的账号加入白名单，因为这类卖家往往有自己的一套运维系统，需要对接公司的IT系统做大量的商品发布、补货等等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式区别于单机限流的场景，它把整个分布式环境中所有服务器当做一个整体来考量。比如说针对IP的限流，我们限制了1个IP每秒最多10个访问，不管来自这个IP的请求落在了哪台机器上，只要是访问了集群中的服务节点，那么都会受到限流规则的制约。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们最好将限流信息保存在一个“中心化”的组件上，这样它就可以获取到集群中所有机器的访问状态，目前有两个比较主流的限流方案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;网关层限流 将限流规则应用在所有流量的入口处&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;中间件限流 将限流信息存储在分布式环境中某个中间件里（比如Redis缓存），每个组件都可以从这里获取到当前时刻的流量统计，从而决定是拒绝服务还是放行流量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sentinel，springcloud生态圈为微服务量身打造的一款用于分布式限流、熔断降级等组件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Boot + MyBatis Plus + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://github.com/YunaiV/ruoyi-vue-pro&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Token Bucket令牌桶算法是目前应用最为广泛的限流算法，顾名思义，它有以下两个关键角色：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;令牌 获取到令牌的Request才会被处理，其他Requests要么排队要么被直接丢弃&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;桶 用来装令牌的地方，所有Request都从这个桶里面获取令牌 主要涉及到2个过程：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;令牌生成&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个流程涉及到令牌生成器和令牌桶，前面我们提到过令牌桶是一个装令牌的地方，既然是个桶那么必然有一个容量，也就是说令牌桶所能容纳的令牌数量是一个固定的数值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于令牌生成器来说，它会根据一个预定的速率向桶中添加令牌，比如我们可以配置让它以每秒100个请求的速率发放令牌，或者每分钟50个。注意这里的发放速度是匀速，也就是说这50个令牌并非是在每个时间窗口刚开始的时候一次性发放，而是会在这个时间窗口内匀速发放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在令牌发放器就是一个水龙头，假如在下面接水的桶子满了，那么自然这个水（令牌）就流到了外面。在令牌发放过程中也一样，令牌桶的容量是有限的，如果当前已经放满了额定容量的令牌，那么新来的令牌就会被丢弃掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个访问请求到来后，必须获取到一个令牌才能执行后面的逻辑。假如令牌的数量少，而访问请求较多的情况下，一部分请求自然无法获取到令牌，那么这个时候我们可以设置一个“缓冲队列”来暂存这些多余的令牌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓冲队列其实是一个可选的选项，并不是所有应用了令牌桶算法的程序都会实现队列。当有缓存队列存在的情况下，那些暂时没有获取到令牌的请求将被放到这个队列中排队，直到新的令牌产生后，再从队列头部拿出一个请求来匹配令牌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当队列已满的情况下，这部分访问请求将被丢弃。在实际应用中我们还可以给这个队列加一系列的特效，比如设置队列中请求的存活时间，或者将队列改造为PriorityQueue，根据某种优先级排序，而不是先进先出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Leaky Bucket，又是个桶，限流算法是跟桶杠上了，那么漏桶和令牌桶有什么不同呢,&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶算法的前半段和令牌桶类似，但是操作的对象不同，令牌桶是将令牌放入桶里，而漏桶是将访问请求的数据包放到桶里。同样的是，如果桶满了，那么后面新来的数据包将被丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶算法的后半程是有鲜明特色的，它永远只会以一个恒定的速率将数据包从桶内流出。打个比方，如果我设置了漏桶可以存放100个数据包，然后流出速度是1s一个，那么不管数据包以什么速率流入桶里，也不管桶里有多少数据包，漏桶能保证这些数据包永远以1s一个的恒定速度被处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据它们各自的特点不难看出来，这两种算法都有一个“恒定”的速率和“不定”的速率。令牌桶是以恒定速率创建令牌，但是访问请求获取令牌的速率“不定”，反正有多少令牌发多少，令牌没了就干等。而漏桶是以“恒定”的速率处理请求，但是这些请求流入桶的速率是“不定”的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这两个特点来说，漏桶的天然特性决定了它不会发生突发流量，就算每秒1000个请求到来，那么它对后台服务输出的访问速率永远恒定。而令牌桶则不同，其特性可以“预存”一定量的令牌，因此在应对突发流量的时候可以在短时间消耗所有令牌，其突发流量处理效率会比漏桶高，但是导向后台系统的压力也会相应增多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说，我们在每一秒内有5个用户访问，第5秒内有10个用户访问，那么在0到5秒这个时间窗口内访问量就是15。如果我们的接口设置了时间窗口内访问上限是20，那么当时间到第六秒的时候，这个时间窗口内的计数总和就变成了10，因为1秒的格子已经退出了时间窗口，因此在第六秒内可以接收的访问量就是20-10=10个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;滑动窗口其实也是一种计算器算法，它有一个显著特点，当时间窗口的跨度越长时，限流效果就越平滑。打个比方，如果当前时间窗口只有两秒，而访问请求全部集中在第一秒的时候，当时间向后滑动一秒后，当前窗口的计数量将发生较大的变化，拉长时间窗口可以降低这种情况的发生概率&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Cloud Alibaba + Gateway + Nacos + RocketMQ + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://github.com/YunaiV/yudao-cloud&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如验证码、IP 黑名单等，这些手段可以有效的防止恶意攻击和爬虫采集；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在限流领域中，Guava在其多线程模块下提供了以&lt;code&gt;RateLimiter&lt;/code&gt;为首的几个限流支持类，但是作用范围仅限于“当前”这台服务器，也就是说Guawa的限流是单机的限流，跨了机器或者jvm进程就无能为力了 比如说，目前我有2台服务器[&lt;code&gt;Server 1&lt;/code&gt;，&lt;code&gt;Server 2&lt;/code&gt;]，这两台服务器都部署了一个登陆服务，假如我希望对这两台机器的流量进行控制，比如将两台机器的访问量总和控制在每秒20以内，如果用Guava来做，只能独立控制每台机器的访问量&amp;lt;=10。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管Guava不是面对分布式系统的解决方案，但是其作为一个简单轻量级的客户端限流组件，非常适合来讲解限流算法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务网关，作为整个分布式链路中的第一道关卡，承接了所有用户来访请求，因此在网关层面进行限流是一个很好的切入点 上到下的路径依次是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户流量从网关层转发到后台服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后台服务承接流量，调用缓存获取数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存中无数据，则访问数据库&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流量自上而下是逐层递减的，在网关层聚集了最多最密集的用户访问请求，其次是后台服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后经过后台服务的验证逻辑之后，刷掉了一部分错误请求，剩下的请求落在缓存上，如果缓存中没有数据才会请求漏斗最下方的数据库，因此数据库层面请求数量最小（相比较其他组件来说数据库往往是并发量能力最差的一环，阿里系的MySQL即便经过了大量改造，单机并发量也无法和Redis、Kafka之类的组件相比）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前主流的网关层有以软件为代表的Nginx，还有Spring Cloud中的Gateway和Zuul这类网关层组件&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Nginx限流&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在系统架构中，Nginx的代理与路由转发是其作为网关层的一个很重要的功能，由于Nginx天生的轻量级和优秀的设计，让它成为众多公司的首选，Nginx从网关这一层面考虑，可以作为最前置的网关，抵挡大部分的网络流量，因此使用Nginx进行限流也是一个很好的选择，在Nginx中，也提供了常用的基于限流相关的策略配置.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 提供了两种限流方法：一种是控制速率，另一种是控制并发连接数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;控制速率&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要使用 &lt;code&gt;limit_req_zone&lt;/code&gt; 用来限制单位时间内的请求数，即速率限制，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为Nginx的限流统计是基于毫秒的，我们设置的速度是 2r/s，转换一下就是500毫秒内单个IP只允许通过1个请求，从501ms开始才允许通过第2个请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的速率控制虽然很精准但是在生产环境未免太苛刻了，实际情况下我们应该控制一个IP单位总时间内的总访问次数，而不是像上面那样精确到毫秒，我们可以使用 burst 关键字开启此设置&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;burst=4&lt;/code&gt;意思是每个IP最多允许4个突发请求&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;控制并发数&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用 &lt;code&gt;limit_conn_zone&lt;/code&gt; 和 &lt;code&gt;limit_conn&lt;/code&gt; 两个指令即可控制并发数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 &lt;code&gt;limit_conn perip 10&lt;/code&gt; 表示限制单个 IP 同时最多能持有 10 个连接；&lt;code&gt;limit_conn perserver 100&lt;/code&gt; 表示 server 同时能处理并发连接的总数为 100 个。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：只有当 request header 被后端处理后，这个连接才进行计数。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;中间件限流&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于分布式环境来说，无非是需要一个类似中心节点的地方存储限流数据。打个比方，如果我希望控制接口的访问速率为每秒100个请求，那么我就需要将当前1s内已经接收到的请求的数量保存在某个地方，并且可以让集群环境中所有节点都能访问。那我们可以用什么技术来存储这个临时数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么想必大家都能想到，必然是redis了，利用Redis过期时间特性，我们可以轻松设置限流的时间跨度（比如每秒10个请求，或者每10秒10个请求）。同时Redis还有一个特殊技能–脚本编程，我们可以将限流逻辑编写成一段脚本植入到Redis中，这样就将限流的重任从服务层完全剥离出来，同时Redis强大的并发量特性以及高可用集群架构也可以很好的支持庞大集群的限流访问。【reids + lua】&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;限流组件&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面介绍的几种方式以外，目前也有一些开源组件提供了类似的功能，比如Sentinel就是一个不错的选择。Sentinel是阿里出品的开源组件，并且包含在了Spring Cloud Alibaba组件库中，Sentinel提供了相当丰富的用于限流的API以及可视化管控台，可以很方便的帮助我们对限流进行治理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真实的项目里，不会只使用一种限流手段，往往是几种方式互相搭配使用，让限流策略有一种层次感，达到资源的最大使用率。在这个过程中，限流策略的设计也可以参考前面提到的漏斗模型，上宽下紧，漏斗不同部位的限流方案设计要尽量关注当前组件的高可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以我参与的实际项目为例，比如说我们研发了一个商品详情页的接口，通过手机淘宝导流，app端的访问请求首先会经过阿里的mtop网关，在网关层我们的限流会做的比较宽松，等到请求通过网关抵达后台的商品详情页服务之后，再利用一系列的中间件+限流组件，对服务进行更加细致的限流控制&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）Tomcat 使用 maxThreads来实现限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）Nginx的&lt;code&gt;limit_req_zone&lt;/code&gt;和 burst来实现速率限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）Nginx的&lt;code&gt;limit_conn_zone&lt;/code&gt;和 &lt;code&gt;limit_conn&lt;/code&gt;两个指令控制并发连接的总数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4）时间窗口算法借助 Redis的有序集合可以实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5）漏桶算法可以使用Redis-Cell来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6）令牌算法可以解决Google的guava包来实现。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要注意的是借助Redis实现的限流方案可用于分布式系统，而guava实现的限流只能应用于单机环境。如果你觉得服务器端限流麻烦，可以在不改任何代码的情况下直接使用容器限流（Nginx或Tomcat），但前提是能满足项目中的业务需求。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat 8.5 版本的最大线程数在 &lt;code&gt;conf/server.xml&lt;/code&gt; 配置中，maxThreads 就是 Tomcat 的最大线程数，当请求的并发大于此值（maxThreads）时，请求就会排队执行，这样就完成了限流的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;maxThreads 的值可以适当的调大一些，Tomcat默认为 150（Tomcat 版本 8.5），但这个值也不是越大越好，要看具体的服务器配置，需要注意的是每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈之用，并且线程越多 GC 的负担也越重。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后需要注意一下，操作系统对于进程中的线程数有一定的限制，Windows 每个进程中的线程数不允许超过 2000，Linux 每个进程中的线程数不允许超过 1000。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0ba2a9343f8e29b6e96bae3c06593b63</guid>
<title>记一次使用 Nacos 2 踩到的坑</title>
<link>https://toutiao.io/k/p1w64m2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.1818181818181819&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WVgUIoNsxLj3WHqp5VSCUKsWnc9j9PZbnvoHf8P98oQ3MAQ8haSuNSwfLickhQpibz8SdkbwuNic2uLFiaB7GUH6Eg/640?wx_fmt=png&quot; data-w=&quot;22&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;nobr data-mid=&quot;&quot;/&gt;蓝字关注我们！&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文素材来源朋友学习nacos2.1.1踩到的坑。直接上正菜&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.0666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RicIZFibGS5cHzODvibibmXrGcxrcC78k97SdRrGnnbvwMCA4dFEy5g5GnTMY2Dic9qGOibh95LZfB2bvyTV8krerQog/640?wx_fmt=png&quot; data-w=&quot;30&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h2&gt;&lt;span&gt;坑点一：出现端口被占用&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.061946902654867256&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/028DBPe3b8hKWGXZhDuG7aPJMUMejicjrfKwbjPicGWuFR6H7hRiaOIibhxUeaqy2oTSiaoicajqq0cpuRcChGW1azVQ/640?wx_fmt=png&quot; data-w=&quot;678&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;因为是学习使用，朋友就在物理机搭建了搭建了nacos伪集群，即ip都一样，端口分别为8848,8847,8849。然而启动nacos服务器后，一台正常启动，其他两台都报了端口被占用&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;出现这种情况的原因，官网有做了解释&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2734375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxJPw845jZ6pH51klE7l8NUT5aXhVDWzadEU5JALiad3iaywGwhCJDibwKSLLe6wgEGM08ZatOjSga58A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1152&quot;/&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;通过官网我们可以很容易得知，这个端口被占用主要是因为grpc引起的，因为他端口的生成方式，是由主端口+1000、主端口+1001生成。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;解决方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;集群的端口不要采用相邻数字，步长尽量搞大点。比如设置为7777、8888、9999之类的&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.0666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RicIZFibGS5cHzODvibibmXrGcxrcC78k97SdRrGnnbvwMCA4dFEy5g5GnTMY2Dic9qGOibh95LZfB2bvyTV8krerQog/640?wx_fmt=png&quot; data-w=&quot;30&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h2&gt;&lt;span&gt;坑二：微服务项目启动出现com.alibaba.nacos.api.exception.NacosException: Client not connected, current status:STARTING异常&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.061946902654867256&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/028DBPe3b8hKWGXZhDuG7aPJMUMejicjrfKwbjPicGWuFR6H7hRiaOIibhxUeaqy2oTSiaoicajqq0cpuRcChGW1azVQ/640?wx_fmt=png&quot; data-w=&quot;678&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;这个问题出现在朋友在项目中配置的nacos地址为nginx地址，配置示例如下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;spring.cloud.nacos.discovery.server-addr=nginx ip&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一开始朋友nginx的配置示例如下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;upstream&lt;/span&gt; nacos-cluster { &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;server&lt;/span&gt; &lt;span&gt;127.0.0.1:7777&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;server&lt;/span&gt; &lt;span&gt;127.0.0.1:8888&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;server&lt;/span&gt; &lt;span&gt;127.0.0.1:9999&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;server&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;listen&lt;/span&gt;       &lt;span&gt;80&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;server_name&lt;/span&gt;  localhost;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;location&lt;/span&gt; / {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;proxy_pass&lt;/span&gt; http://nacos-cluster;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;浏览器通过nginx访问没问题，但是项目中把nacos服务地址配置为nginx ip就报了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.alibaba&lt;/span&gt;&lt;span&gt;.nacos&lt;/span&gt;&lt;span&gt;.api&lt;/span&gt;&lt;span&gt;.exception&lt;/span&gt;&lt;span&gt;.NacosException&lt;/span&gt;: &lt;span&gt;Client&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;connected&lt;/span&gt;, &lt;span&gt;current&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;&lt;span&gt;:STARTING&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个异常信息，后面朋友查资料，官网上有写&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07135874877810362&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxJPw845jZ6pH51klE7l8NUTfPZ3XwKgRXsTpc12ics2Yb9MPQFAxfXF876esVRLL7OoZ9oH7KVKmGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1023&quot;/&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;于是他就将转发方式改为TCP，他的nginx版本是1.9+以上版本，默认就支持TCP代理了，不用额外安装stream模块。nginx配置TCP的示例形如下&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;stream {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  upstream nacos-cluster-grpc{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      # nacos2版本，grpc端口与要比主端口多1000，主端口为7777、8888、9999&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      server 127&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;:&lt;span&gt;8777&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    server 127&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;:&lt;span&gt;9888&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    server 127&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;:&lt;span&gt;10999&lt;/span&gt;; &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  server{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     listen 9848;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        proxy_pass nacos-cluster-grpc;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当朋友配置好nginx tcp代理转发后，通过telnet命令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;telnet&lt;/span&gt; 127&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt; 9848&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来看是否能正常转发给nacos服务端，经过验证，网络可以连通。接着朋友在微服务项目的nacos配置填写如下地址&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;spring.cloud.nacos.discovery.server-addr=127.0.0.1:9848 &lt;span&gt;#nginx代理tcp的地址&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;本来以为万事大吉，结果项目一启动，仍然报&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.alibaba&lt;/span&gt;&lt;span&gt;.nacos&lt;/span&gt;&lt;span&gt;.api&lt;/span&gt;&lt;span&gt;.exception&lt;/span&gt;&lt;span&gt;.NacosException&lt;/span&gt;: &lt;span&gt;Client&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;connected&lt;/span&gt;, &lt;span&gt;current&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;&lt;span&gt;:STARTING&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;于是朋友懵了，啥情况？就来找我交流一下&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1364562118126273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxJPw845jZ6pH51klE7l8NUTOxrfFP2qY8fahmSvibjGrYUCt2ug0O5TmTkGibhfcssP6pj1vQsGuYrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;491&quot;/&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;其实在nacos官网的FAQ就有提到相应的解题思路了&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32954545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxJPw845jZ6pH51klE7l8NUTW8k6aZuG1NKdnMraOwguQI5J9WhgpqOmypn22E3QMXcfwNibUy3cuQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1232&quot;/&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;因为我们在nginx配置的代理tcp端口为9848，这个端口可以看成是grpc的端口，因为grpc的端口 = nacos主端口 + 1000，因此我们套这个公式就可以得出，nacos的主端口为 = 9848 - 1000 = 8848，而我们微服务项目配置nacos端口，其实配置是主端口，因此实际上我们配置要写成&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 &lt;span&gt;#nginx代理tcp端口 - 1000&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;配置这个后，果然成功注册。这个思路是官网带给我们的，但作为一个有点追求的程序员应该不会仅仅满足与此，我们可以直接根据控制台报出的异常来获取答案&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;异常排查过程就省略了，直接贴出关键的解题代码&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.92&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BickTA2TxQXnVswicE7CaLuJMxOUoSdptnZSyYfhuVibvTWIlg5G3pKKj6iaIro4x6Qp4kPnI0icDGeaYWW5MODyq9g/640?wx_fmt=png&quot; data-w=&quot;50&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;首先解析主端口号的核心代码&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;位置在&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.alibaba&lt;/span&gt;&lt;span&gt;.nacos&lt;/span&gt;&lt;span&gt;.common&lt;/span&gt;&lt;span&gt;.remote&lt;/span&gt;&lt;span&gt;.client&lt;/span&gt;&lt;span&gt;.RpcClient&lt;/span&gt;&lt;span&gt;#resolveServerInfo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;ServerInfo &lt;span&gt;private&lt;/span&gt; RpcClient.ServerInfo resolveServerInfo(&lt;span&gt;String&lt;/span&gt; serverAddress) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Matcher matcher = EXCLUDE_PROTOCOL_PATTERN.matcher(serverAddress);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt; (matcher.find()) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            serverAddress = matcher.group(&lt;span&gt;1&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;String&lt;/span&gt;[] ipPortTuple = serverAddress.split(&lt;span&gt;&quot;:&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        int defaultPort = Integer.parseInt(System.getProperty(&lt;span&gt;&quot;nacos.server.port&quot;&lt;/span&gt;, &lt;span&gt;&quot;8848&quot;&lt;/span&gt;));&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;String&lt;/span&gt; serverPort = (&lt;span&gt;String&lt;/span&gt;)CollectionUtils.getOrDefault(ipPortTuple, &lt;span&gt;1&lt;/span&gt;, Integer.toString(defaultPort));&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RpcClient.ServerInfo(ipPortTuple[&lt;span&gt;0&lt;/span&gt;], NumberUtils.toInt(serverPort, defaultPort));&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.92&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BickTA2TxQXnVswicE7CaLuJMxOUoSdptnZSyYfhuVibvTWIlg5G3pKKj6iaIro4x6Qp4kPnI0icDGeaYWW5MODyq9g/640?wx_fmt=png&quot; data-w=&quot;50&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;其次设置grpc端口的核心代码&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;位置在：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.alibaba&lt;/span&gt;&lt;span&gt;.nacos&lt;/span&gt;&lt;span&gt;.common&lt;/span&gt;&lt;span&gt;.remote&lt;/span&gt;&lt;span&gt;.client&lt;/span&gt;&lt;span&gt;.grpc&lt;/span&gt;&lt;span&gt;.GrpcClient&lt;/span&gt;&lt;span&gt;#connectToServer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39466840052015606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxJPw845jZ6pH51klE7l8NUTqNV535Vb72IzeAeK4bjDPbTtwbvIFWT81x2oFFGLImG4eKgpyvhUpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1538&quot;/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;端口设置就是在截图圈红部分，然后从this.rpcPortOffset()我们可以发现&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;rpcPortOffset&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; Integer.parseInt(System.getProperty(&lt;span&gt;&quot;nacos.server.grpc.port.offset&quot;&lt;/span&gt;, String.valueOf(Constants.SDK_GRPC_PORT_DEFAULT_OFFSET)));&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这个偏移量是可以通过nacos.server.grpc.port.offset进行修改，不修改默认就是1000。因此跟踪源码，我们可以得出另外一种解法。在微服务的nacos配置仍然填代理的nginx 的tcp地址，示例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;spring.cloud.nacos.discovery.server-addr=127.0.0.1:9848 &lt;span&gt;#nginx代理tcp的地址&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时启动的时候，加上&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;-Dnacos.server.grpc.port.offset=0&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;或者在主启动类硬编码也 可以&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.setProperty&lt;/span&gt;(&quot;&lt;span&gt;nacos&lt;/span&gt;&lt;span&gt;.server&lt;/span&gt;&lt;span&gt;.grpc&lt;/span&gt;&lt;span&gt;.port&lt;/span&gt;&lt;span&gt;.offset&lt;/span&gt;&quot;,&quot;0&quot;);&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;span&gt; 这边很重要的细节点就是：GRPC port = 主端口 + grpc端口偏移量，这个计算出来的端口值要和nginx代理tcp 端口值相等。&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为朋友用的是目前最新版的nacos2，所以有些问题搜索引擎不是那么好找答案，因此遇到这种问题，最好的解题思路就是官网和相应的github，还有就是源码跟踪了。&lt;/p&gt;&lt;p&gt;后面那个&lt;br data-filtered=&quot;filtered&quot;/&gt;Client not connected, current status:STARTING，其实还有一种解法，就是把客户端版本调低到1.x版本，因为这个问题本质上是连接不上grpc问题，因此我们可以不用grpc，直接用http就好了，而2.x服务端版本是同时支持http和grpc，因此客户端版本调成1.x，他就是以http的方式和服务端进行交互。不过是不建议这么做，因为你升级了2.x，有一方面就是为高性能，如果把版本降低，那还不如直接使用1.x就好了。&lt;/p&gt;&lt;p&gt;还有文中的那两种解法，我个人是建议不要改偏移量，直接通过主端口 + 1000这种方式去算就好了&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;附录&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;本文很多关于nacos2解题思路都是出自官网这篇文章&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.0666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RicIZFibGS5cHzODvibibmXrGcxrcC78k97SdRrGnnbvwMCA4dFEy5g5GnTMY2Dic9qGOibh95LZfB2bvyTV8krerQog/640?wx_fmt=png&quot; data-w=&quot;30&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;https://nacos.io/zh-cn/docs/2.0.0-compatibility.html&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.061946902654867256&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/028DBPe3b8hKWGXZhDuG7aPJMUMejicjrfKwbjPicGWuFR6H7hRiaOIibhxUeaqy2oTSiaoicajqq0cpuRcChGW1azVQ/640?wx_fmt=png&quot; data-w=&quot;678&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>