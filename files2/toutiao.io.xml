<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1c8e84c47e205a0d99975cb331a50f15</guid>
<title>花了一周，我总结了120个数据分析指标与术语。</title>
<link>https://toutiao.io/k/9pzybmk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4NjgzNzk4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/CWCpl8m0oQC18panFv8VgOcQGCz2HKrUBayxrxsYu5OH4OpSvEaqSFkmunggw6JIYWRoavAfypwxjh1pdfUzng/0?wx_fmt=png&quot; data-nickname=&quot;大鱼的数据人生&quot; data-alias=&quot;dayu_data&quot; data-signature=&quot;我是大鱼先生，CDO，跟你分享有关数据的一切！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小五。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据分析总是离不开各种指标和术语，最近我花了一周整理了共120个数据分析指标与术语：&lt;/span&gt;&lt;span&gt;用户数据指标、行为数据指标、业务数据指标、数据分析术语、统计学常用语、数据报告常用术语。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4479495268138801&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8e69iadGbxGPPj5oiaQ7Z9rdO1eZtkKdxzMrcOTGFecxbZ3TdfCEDZzkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章较长，建议大家先点击本文右上角收藏保存。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用户数据指标&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;IP、UV、PV、VV&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IP（Internet Protocol）：独立IP数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UV（Unique Visitor）：独立访问客数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PV（Page View）：页面浏览量/阅读量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VV（Visit View）：访问次数。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;注&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;在对视频产品的数据分析中，VV(Video View)是播放类指标，是指在一个统计周期内，视频被打开的次数之和。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DAU&lt;/strong&gt;(Daily Active User)：日活跃用户数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MAU&lt;/strong&gt;(Monthly Active users)：月活跃用户数&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24971493728620298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8rKMrBWuIJv9EZeR5ZaaUjrItKiaKu8KoicskGyxzJLxPVRh8TLibpHhJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DNU&lt;/strong&gt;(Day New User)：日新增用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;活跃留存率&lt;/strong&gt;：指某日新增用户在其后N日仍启动该APP的用户数，占所选日期新增用户数的比例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.517274472168906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8rgcFkBkVmzNZmWd6qsp8eFeicT9llTPpYtNun3ZlC7rTiawlZbmGeO1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1042&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TGI&lt;/strong&gt;&lt;span&gt;（Target Group Index)：&lt;/span&gt;&lt;span&gt;目标群体指数。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3926470588235294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8xGAhxUNico9ZpgIjUSHFqCePFsZxKnGPgAAYl0ib3H5ibcbFicPD39AMcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TGI指数高于100，代表该类用户该特征比例高于整体水平，即具有更高的相关倾向或偏好；小于100，则说明该类用户相关倾向较弱；等于100表示在平均水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TGI指数常用于用户画像的评判中，它可以清晰地反映不同群体某一特征的关联程度，并进行直观的比较，挖掘更多潜在的用户价值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4782608695652174&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8tfmuicrvDTZNGk2ibX6MF5E7JicDiaicIeiaJpe8vbhNdfqfyXI8NdV2zajQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;行为数据指标&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我曾经总结过&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5Nzg5ODQ3NQ==&amp;amp;mid=2247519961&amp;amp;idx=2&amp;amp;sn=1ae01914226203c3354b99f728d8c208&amp;amp;chksm=fe4eab5dc939224b1f07849b125aa8625be0c23682edff27c1a070a85236f79f680b484d6b3e&amp;amp;token=170624943&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;用户行为分析的5类指标&lt;/a&gt;，这里的行为数据指标便直接引用前文&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户访问类的指标有13个：&lt;strong&gt;PV、UV、DV、日新增用户数、获客成本、用户访问时长、人均页面访问量、人均浏览页数、平均访问页面、访问来源、平均停留时间、跳出率、搜索访问次数占比&lt;/strong&gt;。（其中PV、UV、日新增用户数前文已介绍，其余指标具体含义如下图所示。）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6563829787234042&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8A1t1MZFUvQS9Ocu0Xvck6udY3IlQwMeeeKoXrzNdCe6J44EmcBECibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;figcaption&gt;△点击查看大图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户转化类指标共有15个：&lt;strong&gt;最近购买间隔、购买频率、购买商品种类、平均每次消费额、单次最高消费额、日应用下载量、一次会话用户数、用户会话次数、漏斗转化—第一步进入次数、漏斗转化—中间步进入次数（漏斗中）、进漏斗转化—进入率（漏斗中）、漏斗转化—进入次数（漏斗中）、漏斗转化—进入率（漏斗中）、漏斗转化—退出次数、漏斗转化—退出率&lt;/strong&gt;，这些指标具体含义如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8311258278145696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8WFOIUsvjbyRweZjqvib12uIVA20ia3L2VHjv5Z75SsxxNic9INBS0QDgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;906&quot;/&gt;&lt;figcaption&gt;△点击查看大图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户留存类指标共有15个：&lt;strong&gt;用户留存率、渠道留存率、次日留存率、退出率、活跃度、活动参与率、活跃交易用户数、DAU、MAU、用户回访率、用户流失率、功能使用率、GMV、复购率、退货率&lt;/strong&gt;，这些指标具体含义如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.125984251968504&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8jw2bVxoAODf18KUzCWTffhK3OGiaibZs96P9f3VK2d7OfzGOYyEhV3lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;&lt;figcaption&gt;△点击查看大图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户社交类指标共有8个：&lt;strong&gt;好友数量、帖子数量、看帖数量、回复数量、分享数量、点赞数量、转发数量、评论数量&lt;/strong&gt;，这些指标具体含义如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.364551863041289&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8da2T6ho9lnnKeYraC8aQLBtCV3CA0tFsz2jr8GJTQKouNfGnicNCNeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;993&quot;/&gt;&lt;figcaption&gt;△点击查看大图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;业务数据指标&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互联网线上推广渠道总体上可以分为5种类型：原生广告类社交媒体、普通社交媒体、搜索引擎、软件商店和换量联盟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;渠道投放相关的数据指标有：&lt;strong&gt;曝光量、CPM、CPC、CPA和ROI&lt;/strong&gt;，这5个指标的具体含义如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24190213645761544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8BYRWqpYiaLNKCNr7gv8IXBOYkLPABYicEQOqhWdkCIheYrfPsfzcgmibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1451&quot;/&gt;&lt;figcaption&gt;△点击查看大图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，还有指标&lt;strong&gt;ARPU&lt;/strong&gt;与&lt;strong&gt;ARRPU&lt;/strong&gt;，这二者分别的含义为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ARPU（Average Revenue Per User）：每用户平均收入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ARRPU（Average Revenue Per Paying User）：每付费用户平均收益。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，关于广告渠道投放的常见CPM、CPC、CPA等指标，还包括以下6个指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CTR&lt;/strong&gt;（click through rate）：点击率，是衡量广告效果非常重要的一个指标：内容被点击的次数/内容展现的次数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35714285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8Xsic3kg9UiaDHJoBDlWX56MSyyt1zEM8bagdgjckcUuXHZTwhFNqaaeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CVR&lt;/strong&gt;(Click Value Rate)：转化率【衡量CPA广告效果的指标】&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CAC&lt;/strong&gt;(Customer Acquisition Cost)：获客成本【获取一个客户所花费的成本】&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CPR&lt;/strong&gt;(Cost Per Response)：每回应成本【以浏览者的每一个回应计费】&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ADPV&lt;/strong&gt;(Advertisement Page View)：载有广告的pa-geview流量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ADimp&lt;/strong&gt;(ADimpression)：单个广告的展示次数&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据分析术语&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;用户画像&lt;/strong&gt;简单来说，用户画像是根据用户的社会属性、生活习惯、消费行为等信息而抽象得出的一个标签化用户模型。勾画用户画像的核心在于给用户贴“标签”。（涉及的元素比如用户的姓名、年龄、收入、喜好、购物习惯等等）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.708&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tXYict40xfLiabFY74YEysG3BDzgoUCGib8j8czNPftcvuxmc5UTaQicpjc0eYjXmpR8J04zxfttc2licwicgqu6xXnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;海盗模型（AARRR）&lt;/strong&gt;获取用户（Acquisition）、提高活跃度（Activation）、提高留存率（Retention）、获取收入（Reve-nue)、自传播（Refer)，这个五个单词的缩写，分别对应用户生命周期中的5个重要环节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RARRA模型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AARRR模型的核心在于获客，而在RARRA的模型下，专注用户的留存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiahB3GYGNicej7hwxZo5MZUBp0rvkRpFzdibHyxbp6gImhEXbH4xJMAthMzU5VD8Q0KsmPHd61mlJTw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;1&quot; data-w=&quot;140&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;OSM模型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OSM模型（Object-Strategy-Measure）就是把宏大的目标拆解，[对应到部门内各个小组具体的、可落地、可度量的行为上，从保证执行计划没有偏离大方向](http://www.woshipm.com/pd/4356866.html 《OSM模型，最接地气的业务分析框架》)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;UJM模型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UJM模型（User Journey Map，用户旅程地图）就是我们在设计一款产品的过程中，必须要去梳理的用户生命旅程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.502&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tXYict40xfLiabFY74YEysG3BDzgoUCGib8aIZPqe1PnUrXjbkg75ibAQSv76ELy1ZRMKn5eMn5UXwoNY2ZUbU3zWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RFM&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据客户的交易频次和交易额衡量客户的价值，对客户进行细分。RFM是衡量客户价值的三个维度，分别为R（Recency）交易间隔、F（Frequency）交易频度、M（Monetary）交易金额组成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ABTest&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AB测试是为APP或Web的界面/流程制作两个（A/B）或多个（A/B/n）版本，在同一时间维度中，分别让组成成分相同/相似的访客群组（目标人群）随机的访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估出最优版本，正式采用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.330550918196995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8jzgysHvra0McTI6UdjVnk80xltJuWg81MpibvesW4aJiaFn91gSwHOpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1198&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据埋点&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据埋点是一种常用的数据采集方法，是数据产品经理、数据运营以及数据分析师，基于业务需求或产品需求对用户在应用内产生行为的每一个事件对应的页面和位置植入相关代码，并通过采集工具上报统计数据，以便相关人员追踪用户行为和应用使用情况，推动产品优化或指导运营的一项工程&lt;sup&gt;[2]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;用户生命周期价值&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LTV（life time value）也就是用户生命周期价值，是产品从用户获取到流失所得到的全部收益的总和。LTV用于衡量用户对产品所产生的价值，是所有用户运营手段为了改善的终极指标，同时LTV也应该是所有运营手段的最终衡量指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;归因分析&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据时代，广告的投放效果评估往往会产生很多的问题。而归因分析（Attribution Analysis）要解决的问题就是广告效果的产生，其功劳应该如何合理的分配给哪些渠道&lt;sup&gt;[3]&lt;/sup&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5467741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8m4YL9syicaVpHDf9L6r2wNNaGuczwOUnh12EU2QvicYZxflaGK5XtZOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;统计学常用语&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;绝对数和相对数&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;绝对数：是反应客观现象总体在一定时间、一定地点下的总规模、总水平的综合性指标，也是数据分析中常用的指标。比如年GDP，总人口等等&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对数：是指两个有联系的指标计算而得出的数值，它是反应客观现象之间的数量联系紧密程度的综合指标。相对数一般以倍数、百分数等表示。相对数的计算公式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对数=比较值（比数）/基础值（基数）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;百分比和百分点&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;百分比：是相对数中的一种，它表示一个数是另一个数的百分之几，也称为百分率或百分数。百分比的分母是100，也就是用1%作为度量单位，因此便于比较。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;百分点：是指不同时期以百分数的形式表示的相对指标的变动幅度，1%等于1个百分点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42213883677298314&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8k76libjybODVsFpMCOQ5mTHicUXTJABZBkW1iaibpFDWiaV1yASz25bLPbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;533&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;频数和频率&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;频数：一个数据在整体中出现的次数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;频率：某一事件发生的次数与总的事件数之比。频率通常用比例或百分数表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;比例与比率&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比例：是指在总体中各数据占总体的比重，通常反映总体的构成和比例，即部分与整体之间的关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比率：是样本(或总体)中各不同类别数据之间的比值，由于比率不是部分与整体之间的对比关系，因而比值可能大于1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;连续变量&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在统计学中，变量按变量值是否连续可分为连续变量与离散变量两种。在一定区间内可以任意取值的变量叫连续变量，其数值是连续不断的，相邻两个数值可作无限分割，即可取无限个数值。如:年龄、体重等变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;离散变量&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;离散变量的各变量值之间都是以整数断开的，如人数、工厂数、机器台数等，都只能按整数计算。离散变量的数值只能用计数的方法取得。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;定性变量&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又名分类变量：观测的个体只能归属于几种互不相容类别中的一种时，一般是用非数字来表达其类别，这样的观测数据称为定性变量。可以理解成可以分类别的变量，如学历、性别、婚否等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;均值&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即平均值，平均数是表示一组数据集中趋势的量数，是指在一组数据中所有数据之和再除以这组数据的个数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4649122807017544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8iaoytCKiaEkrOxDKOuOH02kLDq2UABE47PzRBB4cQzNVO2gfMpPNjiaZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;684&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;中位数&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺失值&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它指的是现有数据集中某个或某些属性的值是不完全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;异常值&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指一组测定值中与平均值的偏差超过两倍标准差的测定值，与平均值的偏差超过三倍标准差的测定值，称为高度异常的异常值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;方差&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是衡量随机变量或一组数据时离散程度的度量。概率论中方差用来度量随机变量和其数学期望（即均值）之间的偏离程度。统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数。在许多实际问题中，研究方差即偏离程度有着重要意义。方差是衡量源数据和期望值相差的度量值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;标准差&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又常称均方差，是离均差平方的算术平均数的平方根，用σ表示。标准差是方差的算术平方根。标准差能反映一个数据集的离散程度。平均数相同的两组数据，标准差未必相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;皮尔森相关系数&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;皮尔森相关系数是用来反映两个变量线性相关程度的统计量。相关系数用r表示，其中n为样本量，分别为两个变量的观测值和均值。r描述的是两个变量间线性相关强弱的程度。r的绝对值越大表明相关性越强。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据报告常用术语&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;倍数和番数&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;倍数：用一个数据除以另一个数据获得，倍数一般用来表示上升、增长幅度，一般不表示减少幅度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻n番：指原来数量的2的n次方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;同比和环比&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同比：指的是与历史同时期的数据相比较而获得的比值，反应事物发展的相对性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;环比：指与上一个统计时期的值进行对比获得的值，主要反映事物的逐期发展的情况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6209964412811388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8fQd6hCNAIpKxLDSiap6djFBqcZic2VuBolFNl3tZMjroG9qTzvu4UdxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;562&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;增量&lt;/strong&gt;：增长的绝对量=现期量-基期量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;增速&lt;/strong&gt;：增长速度=（现期量-基期量）÷基期量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;增长率&lt;/strong&gt;：增量与基期量之比。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;增幅&lt;/strong&gt;：即增长的幅度，也可理解为增量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基期和现期&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基期：被用作参照物的时期称为基期，描述基期的量即为基期量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现期：相对于基期的称为现期，描述现期的量即为现期量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;YTD&lt;/strong&gt;:截止到今天为止今年的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;LY&lt;/strong&gt;:last year去年&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;YoY&lt;/strong&gt;——跟上年相比&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MAT&lt;/strong&gt;（moving annual total）：年度动态变化总值&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Q4/Q1&lt;/strong&gt;：4季度/1季度&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GDP&lt;/strong&gt;:国内生产总值&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GNH&lt;/strong&gt;（gross national happiness）：国民幸福指数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GNP&lt;/strong&gt;:国民生产总值&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整理不易，如果看到文末的同学，麻烦给右下角点个赞再走吧👍&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于文章较长&lt;/span&gt;&lt;span&gt;，建议点击右上角收藏，需要时大家可以使用搜索功能查看自己感兴趣的指标/术语含义。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;书籍: &lt;span&gt;《大数据用户行为分析画像实操指南》&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;通俗易懂的理解：什么是数据埋点？: &lt;span&gt;https://blog.csdn.net/qq_38128179/article/details/108746513&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;4个方面解析：归因分析模型: &lt;span&gt;http://www.woshipm.com/marketing/3839887.html&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;一次性总结：64个数据分析常用术语！: &lt;span&gt;https://mp.weixin.qq.com/s/gVc1rTVYKtECSztau_I7RA&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8eefc934adf3263bfe06ac3d2f91d61c</guid>
<title>Vue项目中的preset-env, core-js, browserslist是干嘛的</title>
<link>https://toutiao.io/k/6jf8esr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如题这三个东西，相信很多人都见过，也都会用会配置，但要是让你说出个所以然来，恐怕还不是那么容易。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;曾经的我，一边google一边配置，只要能用就万事大吉了，且每次google出来的似乎还跟上次的都有所不同，所以每次配置项目时，有差异的。然而却很少去深究为啥？为啥这样配也可以，那样配也可以，那到底怎样配置才是最佳的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就来简单说说我的理解，不对的地方欢迎指正。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;名称解释&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;preset-env&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从名称看有个env，这里就是包含“环境”之意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在preset-env出来之前，我们需要自己知道要用什么es6的特性，然后自己去babel的配置文件中加进去，如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;plugins&quot;&lt;/span&gt;: [&lt;br/&gt;      &lt;span&gt;&quot;@babel/plugin-transform-arrow-functions&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;@babel/plugin-transform-classes&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;@babel/plugin-transform-spread&quot;&lt;/span&gt;,&lt;br/&gt;      ...&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做非常繁琐，开发体验也不好。再后来，后来就出现了@babel/preset-env。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@babel/preset-env可以通过target属性配置一个目标环境，babel会根据环境来转换那些它不支持的语法，这样就不需要我们一个一个的去自己加入所要支持的es6特性。如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;presets&quot;&lt;/span&gt;: [&lt;br/&gt;        [&lt;span&gt;&quot;@babel/preset-env&quot;&lt;/span&gt;, {&lt;br/&gt;            &lt;span&gt;&quot;target&quot;&lt;/span&gt;: {&lt;br/&gt;                &lt;span&gt;&quot;browsers&quot;&lt;/span&gt;: [&lt;span&gt;&quot;last 2 versions&quot;&lt;/span&gt;, &lt;span&gt;&quot;ie &amp;gt;= 7&quot;&lt;/span&gt;]&lt;br/&gt;            }&lt;br/&gt;        }]&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，@babel/preset-env的作用就是将常用的ES6特性放到一起了，然后添加一个可以配置的目标环境，它自己决定要转换那些ES6特性，这样开发体验就好很多。这样虽然不需要我们配置ES6特性，但需要我们自己配置目标环境，且这个环境只是babel自己知道，如果还有其他应用，如ESLint，TS等等，其他应用也需要读取目标环境来决定行为，还得配置……所以browserslist出现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;browserslist&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;browserslist提供了一种项目共享的目标环境配置，整个项目的babel、eslint，ts等都可以读取到。如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# Browsers that we support&lt;br/&gt;&lt;br/&gt;[modern]&lt;br/&gt;Firefox &amp;gt;= &lt;span&gt;53&lt;/span&gt;&lt;br/&gt;Edge &amp;gt;= &lt;span&gt;15&lt;/span&gt;&lt;br/&gt;Chrome &amp;gt;= &lt;span&gt;58&lt;/span&gt;&lt;br/&gt;iOS &amp;gt;= &lt;span&gt;10.1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;[legacy]&lt;br/&gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;%&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它有自己的配置语法，一看就会，它有多种具体文档：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbrowserslist%2Fbrowserslist&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了browserslist的配置，我们就可以不用配置@babel/preset-env的target了。browserslist的配置可以写在package.json里面也可以用独立的.browserslistrc文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;core-js&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信很多人一开始并不清楚core-js是干嘛的，因为我们已经有babel了，为何还要core-js呢？如果你这么想，那就是有个关键的概念没有搞清楚。一般babel只是用来将ES6+的语法转为ES5，它并不处理ES6新增的API，如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; t = [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(...t);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; x = t.includes(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(x);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;转换后&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;use strict&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; _console;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; t = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;(_console = &lt;span&gt;console&lt;/span&gt;).log.apply(_console, t);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; x = t.includes(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(x);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的扩展运算符是属于语法的范畴，而数组的includes方法是属于ES6新增的API，所以babel只是转换了扩展运算符，而并没有处理includes方法。所以当我们在比较老旧的浏览器中运行时会报错，如何让这些老旧的浏览器也能认识ES6新增的这些API，这就是core-js要做的事情了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一起使用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;core-js提供了各种“老旧浏览器”需要的ES6新API的实现，browserslist提供了指定哪些“老旧浏览器”的功能，而@babel/preset-env提供了针对browserslist指定的老旧浏览器来转换ES6到ES5，同时还能根据browserslist指定的环境从core-js中提取需要的ES6新增API的实现。简单说@babel/preset-env使用core-js、browserslist通过适当的配置来支持各种老旧的环境。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一些简单的代码来演示如何一起使用，假设我们有如下index.js文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;init();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; t = &lt;span&gt;Object&lt;/span&gt;.entries({&lt;span&gt;a&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;b&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;})&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; y = [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;].findIndex(&lt;span&gt;&lt;span&gt;x&lt;/span&gt; =&amp;gt;&lt;/span&gt; x === &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; t1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(resolve, &lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; obj = {&lt;br/&gt;        &lt;span&gt;maps&lt;/span&gt;: [p],&lt;br/&gt;        printArr() {&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(...t);&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;async&lt;/span&gt; p() {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; t1;&lt;br/&gt;        }&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    obj.printArr();&lt;br/&gt;    obj.p().then(&lt;span&gt;&lt;span&gt;s&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;span&gt;console&lt;/span&gt;.log(s)});&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;.browserslistrc只指定ie11&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ie 11&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;babel.config.json，指定usage方式引入core-js，以及指定使用的core-js版本&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;presets&quot;&lt;/span&gt;: [&lt;br/&gt;        [&lt;span&gt;&quot;@babel/preset-env&quot;&lt;/span&gt;, {&lt;br/&gt;            &lt;span&gt;&quot;useBuiltIns&quot;&lt;/span&gt;: &lt;span&gt;&quot;usage&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;corejs&quot;&lt;/span&gt;: &lt;span&gt;&quot;3&quot;&lt;/span&gt;&lt;br/&gt;        }]&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过babel命令行转译&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;use strict&quot;&lt;/span&gt;;&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.symbol.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.symbol.description.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.symbol.iterator.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.array.from.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.array.slice.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.function.name.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.regexp.exec.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;regenerator-runtime/runtime.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.array.iterator.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.map.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.object.to-string.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.string.iterator.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/web.dom-collections.iterator.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.object.entries.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.array.find-index.js&quot;&lt;/span&gt;);&lt;br/&gt;require(&lt;span&gt;&quot;core-js/modules/es.promise.js&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); &lt;span&gt;return&lt;/span&gt;; } &lt;span&gt;if&lt;/span&gt; (info.done) { resolve(value); } &lt;span&gt;else&lt;/span&gt; { Promise.resolve(value).&lt;span&gt;then&lt;/span&gt;(_next, _throw); } }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; _asyncToGenerator(fn) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;/span&gt; () { var self = this, args = arguments; &lt;span&gt;return&lt;/span&gt; new Promise(&lt;span&gt;function&lt;/span&gt; (resolve, reject) { var gen = fn.apply(self, args); &lt;span&gt;function&lt;/span&gt; _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, &lt;span&gt;&quot;next&quot;&lt;/span&gt;, value); } &lt;span&gt;function&lt;/span&gt; _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, &lt;span&gt;&quot;throw&quot;&lt;/span&gt;, err); } _next(undefined); }); }; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; _toConsumableArray(arr) { &lt;span&gt;return&lt;/span&gt; _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;_nonIterableSpread&lt;/span&gt;&lt;/span&gt;() { throw new TypeError(&lt;span&gt;&quot;Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;&lt;/span&gt;); }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; _unsupportedIterableToArray(o, minLen) { &lt;span&gt;if&lt;/span&gt; (!o) &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;if&lt;/span&gt; (typeof o === &lt;span&gt;&quot;string&quot;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); &lt;span&gt;if&lt;/span&gt; (n === &lt;span&gt;&quot;Object&quot;&lt;/span&gt; &amp;amp;&amp;amp; o.constructor) n = o.constructor.name; &lt;span&gt;if&lt;/span&gt; (n === &lt;span&gt;&quot;Map&quot;&lt;/span&gt; || n === &lt;span&gt;&quot;Set&quot;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; Array.from(o); &lt;span&gt;if&lt;/span&gt; (n === &lt;span&gt;&quot;Arguments&quot;&lt;/span&gt; || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.&lt;span&gt;test&lt;/span&gt;(n)) &lt;span&gt;return&lt;/span&gt; _arrayLikeToArray(o, minLen); }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; _iterableToArray(iter) { &lt;span&gt;if&lt;/span&gt; (typeof Symbol !== &lt;span&gt;&quot;undefined&quot;&lt;/span&gt; &amp;amp;&amp;amp; iter[Symbol.iterator] != null || iter[&lt;span&gt;&quot;@@iterator&quot;&lt;/span&gt;] != null) &lt;span&gt;return&lt;/span&gt; Array.from(iter); }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; _arrayWithoutHoles(arr) { &lt;span&gt;if&lt;/span&gt; (Array.isArray(arr)) &lt;span&gt;return&lt;/span&gt; _arrayLikeToArray(arr); }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; _arrayLikeToArray(arr, len) { &lt;span&gt;if&lt;/span&gt; (len == null || len &amp;gt; arr.length) len = arr.length; &lt;span&gt;for&lt;/span&gt; (var i = 0, arr2 = new Array(len); i &amp;lt; len; i++) { arr2[i] = arr[i]; } &lt;span&gt;return&lt;/span&gt; arr2; }&lt;br/&gt;&lt;br/&gt;init();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;init&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  var p = new Map();&lt;br/&gt;  var t = Object.entries({&lt;br/&gt;    a: 1,&lt;br/&gt;    b: 2&lt;br/&gt;  });&lt;br/&gt;  var y = [1, 2, 3].findIndex(&lt;span&gt;function&lt;/span&gt; (x) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; x === 3;&lt;br/&gt;  });&lt;br/&gt;  var t1 = new Promise(&lt;span&gt;function&lt;/span&gt; (resolve) {&lt;br/&gt;    setTimeout(resolve, 1000, 3, 2);&lt;br/&gt;  });&lt;br/&gt;  var obj = {&lt;br/&gt;    maps: [p],&lt;br/&gt;    printArr: &lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;printArr&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      var _console;&lt;br/&gt;&lt;br/&gt;      (_console = console).log.apply(_console, _toConsumableArray(t));&lt;br/&gt;    },&lt;br/&gt;    p: &lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;p&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; _asyncToGenerator( /*&lt;span&gt;#__PURE__*/regeneratorRuntime.mark(function _callee() {&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; regeneratorRuntime.wrap(&lt;span&gt;function&lt;/span&gt; _callee$(_context) {&lt;br/&gt;          &lt;span&gt;while&lt;/span&gt; (1) {&lt;br/&gt;            switch (_context.prev = _context.next) {&lt;br/&gt;              &lt;span&gt;case&lt;/span&gt; 0:&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; _context.abrupt(&lt;span&gt;&quot;return&quot;&lt;/span&gt;, t1);&lt;br/&gt;&lt;br/&gt;              &lt;span&gt;case&lt;/span&gt; 1:&lt;br/&gt;              &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;end&quot;&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; _context.stop();&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        }, _callee);&lt;br/&gt;      }))();&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;  obj.printArr();&lt;br/&gt;  obj.p().&lt;span&gt;then&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt; (s) {&lt;br/&gt;    console.log(s);&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;转换后的代码有点多，但这已经是babel根据browserslist指定环境转换的，我们可以看到babel提取了很多core-js中的实现，如：require(&quot;core-js/modules/es.array.from.js&quot;)等……，还有一些函数，如：&lt;code&gt;_asyncToGenerator&lt;/code&gt;等我们称为babel运行时(后面会说到)。要弄清楚转译后的文件为何这样，我们得理解@babel/preset-env的配置项。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;useBuiltIns&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要用于指定babel如何从core-js中提取合适的ES6新特性的实现，有两种模式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;usage：我们不需要在入口处导入core-js，babel会根据代码中使用的ES6 API来决定提取哪些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;entry：我们通过import在入口引入core-js，babel会根据引入的core-js模块来识别和拆分更细的导入，如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 源文件&lt;br/&gt;import &lt;span&gt;&quot;core-js/es/array&quot;&lt;/span&gt;;&lt;br/&gt;import &lt;span&gt;&quot;core-js/proposals/math-extensions&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;// 输出&lt;br/&gt;import &lt;span&gt;&quot;core-js/modules/es.array.unscopables.flat&quot;&lt;/span&gt;;&lt;br/&gt;import &lt;span&gt;&quot;core-js/modules/es.array.unscopables.flat-map&quot;&lt;/span&gt;;&lt;br/&gt;import &lt;span&gt;&quot;core-js/modules/esnext.math.clamp&quot;&lt;/span&gt;;&lt;br/&gt;import &lt;span&gt;&quot;core-js/modules/esnext.math.deg-per-rad&quot;&lt;/span&gt;;&lt;br/&gt;import &lt;span&gt;&quot;core-js/modules/esnext.math.degrees&quot;&lt;/span&gt;;&lt;br/&gt;import &lt;span&gt;&quot;core-js/modules/esnext.math.fscale&quot;&lt;/span&gt;;&lt;br/&gt;import &lt;span&gt;&quot;core-js/modules/esnext.math.rad-per-deg&quot;&lt;/span&gt;;&lt;br/&gt;import &lt;span&gt;&quot;core-js/modules/esnext.math.radians&quot;&lt;/span&gt;;&lt;br/&gt;import &lt;span&gt;&quot;core-js/modules/esnext.math.scale&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;corejs&lt;/strong&gt;用于指定core-js的版本，因为core-js有2和3的版本，这里babel默认会使用2的版本，这里建议用3的版本。babel还建议指定core-js的minor版本，这样能将最新实现的API包含进来。默认情况下，babel只会提取稳定的API实现，如果你想将还在提案阶段的API也包含进来，可以这样配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;corejs&quot;&lt;/span&gt;: { version: &lt;span&gt;&quot;3.8&quot;&lt;/span&gt;, proposals: &lt;span&gt;true&lt;/span&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说，useBuiltIns配置为usage，corejs配置为{ version: &quot;3.8&quot;, proposals: true }会是大部分场景的选择，不过后面还有更多的东西。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：生石灰
链接：https://juejin.cn/post/7088702716465119268&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8d5f80cf6592e9872494360192ae69a2</guid>
<title>聊聊并发编程的10个坑</title>
<link>https://toutiao.io/k/ajkvysg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于从事后端开发的同学来说，并发编程肯定再熟悉不过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，在java中并发编程是一大难点，至少我是这么认为的。不光理解起来比较费劲，使用起来更容易踩坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不信，让继续往下面看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天重点跟大家一起聊聊并发编程的10个坑，希望对你有帮助。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9125364431486881&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWohqZCBBOjUa71ia1g9GfqdJ8DVraxPmJaLo7ZpoQAzpGsUoxJr7088BJWVsGAtveDo4kibBloNjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1372&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. SimpleDateFormat线程不安全&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java8之前，我们对时间的格式化处理，一般都是用的&lt;code&gt;SimpleDateFormat&lt;/code&gt;类实现的。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleDateFormatService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;time&lt;/span&gt;&lt;span&gt;(String time)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;        SimpleDateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dateFormat.parse(time);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你真的这样写，是没问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就怕哪天抽风，你觉得dateFormat是一段固定的代码，应该要把它抽取成常量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是把代码改成下面的这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleDateFormatService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleDateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;time&lt;/span&gt;&lt;span&gt;(String time)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dateFormat.parse(time);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dateFormat对象被定义成了静态常量，这样就能被所有对象共用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只有一个线程调用time方法，也不会出现问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但Serivce类的方法，往往是被Controller类调用的，而Controller类的接口方法，则会被&lt;code&gt;tomcat&lt;/code&gt;的&lt;code&gt;线程池&lt;/code&gt;调用。换句话说，可能会出现多个线程调用同一个Controller类的同一个方法，也就是会出现多个线程会同时调用time方法的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而time方法会调用&lt;code&gt;SimpleDateFormat&lt;/code&gt;类的&lt;code&gt;parse&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(String text, ParsePosition pos)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    Date parsedDate;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        parsedDate = calb.establish(calendar).getTime();&lt;br/&gt;        ...&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IllegalArgumentException e) {&lt;br/&gt;        pos.errorIndex = start;&lt;br/&gt;        pos.index = oldStart;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; parsedDate;&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法会调用&lt;code&gt;establish&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Calendar &lt;span&gt;establish&lt;/span&gt;&lt;span&gt;(Calendar cal)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;//1.清空数据&lt;/span&gt;&lt;br/&gt;    cal.clear();&lt;br/&gt;    &lt;span&gt;//2.设置时间&lt;/span&gt;&lt;br/&gt;    cal.set(...);&lt;br/&gt;    &lt;span&gt;//3.返回&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; cal;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的步骤1、2、3是非原子操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果cal对象是局部变量还好，坏就坏在parse方法调用establish方法时，传入的calendar是&lt;code&gt;SimpleDateFormat&lt;/code&gt;类的父类&lt;code&gt;DateFormat&lt;/code&gt;的成员变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateFormat&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Forma&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ....&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Calendar calendar;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可能会出现多个线程，同时修改同一个对象即：dateFormat，他的同一个成员变量即：Calendar值的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样可能会出现，某个线程设置好了时间，又被其他的线程修改了，从而出现时间错误的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;SimpleDateFormat类的对象不要定义成静态的，可以改成方法的局部变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用ThreadLocal保存SimpleDateFormat类的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用java8的DateTimeFormatter类。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 双重检查锁的漏洞&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;单例模式&lt;/code&gt;无论在实际工作，还是在面试中，都出现得比较多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，单例模式有：&lt;code&gt;饿汉模式&lt;/code&gt;和&lt;code&gt;懒汉模式&lt;/code&gt;两种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;饿汉模式代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//持有自己类的引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//私有的构造方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//对外提供获取实例的静态方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用饿汉模式的好处是：没有线程安全的问题，但带来的坏处也很明显。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始就实例化对象了，如果实例化过程非常耗时，并且最后这个对象没有被使用，不是白白造成资源浪费吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还真是啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候你也许会想到，不用提前实例化对象，在真正使用的时候再实例化不就可以了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是我接下来要介绍的：&lt;code&gt;懒汉模式&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton2 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton2 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton2();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例中的INSTANCE对象一开始是空的，在调用getInstance方法才会真正实例化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嗯，不错不错。但这段代码还是有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有多个线程中都调用了getInstance方法，那么都走到 if (INSTANCE == null) 判断时，可能同时成立，因为INSTANCE初始化时默认值是null。这样会导致多个线程中同时创建INSTANCE对象，即INSTANCE对象被创建了多次，违背了只创建一个INSTANCE对象的初衷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决&lt;code&gt;饿汉模式&lt;/code&gt;和&lt;code&gt;懒汉模式&lt;/code&gt;各自的问题，于是出现了：&lt;code&gt;双重检查锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton4&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton4 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton4&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton4 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (SimpleSingleton4&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton4();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要在&lt;code&gt;synchronized&lt;/code&gt;前后两次判空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我要告诉你的是：这段代码有漏洞的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有什么问题？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton4 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (SimpleSingleton4&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;span&gt;//2&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//3&lt;/span&gt;&lt;br/&gt;                INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton4();&lt;span&gt;//4&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;span&gt;//5&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;getInstance方法的这段代码，我是按1、2、3、4、5这种顺序写的，希望也按这个顺序执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是java虚拟机实际上会做一些优化，对一些代码指令进行重排。重排之后的顺序可能就变成了：1、3、2、4、5，这样在多线程的情况下同样会创建多次实例。重排之后的代码可能如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton4 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//1&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//3&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;synchronized&lt;/span&gt; (SimpleSingleton4&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;span&gt;//2&lt;/span&gt;&lt;br/&gt;                INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton4();&lt;span&gt;//4&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;span&gt;//5&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原来如此，那有什么办法可以解决呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：可以在定义INSTANCE是加上&lt;code&gt;volatile&lt;/code&gt;关键字。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton7&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton7 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton7&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton7 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (SimpleSingleton7&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton7();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;volatile&lt;/code&gt;关键字可以保证多个线程的&lt;code&gt;可见性&lt;/code&gt;，但是不能保证&lt;code&gt;原子性&lt;/code&gt;。同时它也能&lt;code&gt;禁止指令重排&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双重检查锁的机制既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，如果你想了解更多单例模式的细节问题，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490452&amp;amp;idx=1&amp;amp;sn=a4275112240ea660c3b8e03f4064971d&amp;amp;chksm=c0ebc37cf79c4a6aeb2671c2cd39c2d88ff3a38f9235db6c968175e9487af8c09525d122ce74&amp;amp;token=1069875911&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;单例模式，真不简单&lt;/a&gt;》&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. volatile的原子性&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从前面我们已经知道&lt;code&gt;volatile&lt;/code&gt;，是一个非常不错的关键字，它能保证变量在多个线程中的&lt;code&gt;可见性&lt;/code&gt;，它也能&lt;code&gt;禁止指令重排&lt;/code&gt;，但是不能保证&lt;code&gt;原子性&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;volatile&lt;/code&gt;关键字禁止指令重排，前面已经说过了，这里就不聊了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;可见性&lt;/code&gt;主要体现在：一个线程对某个变量修改了，另一个线程每次都能获取到该变量的最新值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先一起看看反例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VolatileTest&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt;  &lt;span&gt;boolean&lt;/span&gt; stopFlag = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isStopFlag&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; stopFlag;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Thread.sleep(&lt;span&gt;300&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        stopFlag = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot; stopFlag = &quot;&lt;/span&gt; + stopFlag);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        VolatileTest vt = &lt;span&gt;new&lt;/span&gt; VolatileTest();&lt;br/&gt;        vt.start();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (vt.isStopFlag()) {&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;stop&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这段代码中，VolatileTest是一个&lt;code&gt;Thread&lt;/code&gt;类的子类，它的成员变量stopFlag默认是false，在它的run方法中修改成了true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后在main方法的主线程中，用vt.isStopFlag()方法判断，如果它的值是true时，则打印&lt;/span&gt;&lt;code&gt;stop&lt;/code&gt;&lt;span&gt;关键字。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何才能让stopFlag的值修改了，在主线程中通过vt.isStopFlag()方法，能够获取最新的值呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VolatileTest&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; stopFlag = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isStopFlag&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; stopFlag;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Thread.sleep(&lt;span&gt;300&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        stopFlag = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot; stopFlag = &quot;&lt;/span&gt; + stopFlag);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        VolatileTest vt = &lt;span&gt;new&lt;/span&gt; VolatileTest();&lt;br/&gt;        vt.start();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (vt.isStopFlag()) {&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;stop&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用&lt;code&gt;volatile&lt;/code&gt;关键字修饰stopFlag即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面重点说说volatile的原子性问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用多线程给count加1，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VolatileTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        count++;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; VolatileTest test = &lt;span&gt;new&lt;/span&gt; VolatileTest();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; Thread() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;1000&lt;/span&gt;; j++) {&lt;br/&gt;                        test.add();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                ;&lt;br/&gt;            }.start();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (Thread.activeCount() &amp;gt; &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//保证前面的线程都执行完&lt;/span&gt;&lt;br/&gt;            Thread.yield();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        System.out.println(test.count);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果每次都不一样，但可以肯定的是count值每次都小于20000，比如：19999。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中count是成员变量，虽说被定义成了volatile的，但由于add方法中的count++是非原子操作。在多线程环境中，count++的数据可能会出现问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，&lt;code&gt;volatile&lt;/code&gt;不能保证&lt;code&gt;原子性&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;synchronized&lt;/code&gt;关键字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造后的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VolatileTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        count++;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; VolatileTest test = &lt;span&gt;new&lt;/span&gt; VolatileTest();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; Thread() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;1000&lt;/span&gt;; j++) {&lt;br/&gt;                        test.add();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                ;&lt;br/&gt;            }.start();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (Thread.activeCount() &amp;gt; &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//保证前面的线程都执行完&lt;/span&gt;&lt;br/&gt;            Thread.yield();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        System.out.println(test.count);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 死锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁可能是大家都不希望遇到的问题，因为一旦程序出现了死锁，如果没有外力的作用，程序将会一直处于资源竞争的假死状态中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DeadLockTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String OBJECT_1 = &lt;span&gt;&quot;OBJECT_1&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String OBJECT_2 = &lt;span&gt;&quot;OBJECT_2&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LockA lockA = &lt;span&gt;new&lt;/span&gt; LockA();&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(lockA).start();&lt;br/&gt;&lt;br/&gt;        LockB lockB = &lt;span&gt;new&lt;/span&gt; LockB();&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(lockB).start();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockA&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_1) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_2) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;LockA&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockB&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_2) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_1) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;LockB&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个线程在获取OBJECT_1锁时，没有释放锁，又去申请OBJECT_2锁。而刚好此时，另一个线程获取到了OBJECT_2锁，也没有释放锁，去申请OBJECT_1锁。由于OBJECT_1和OBJECT_2锁都没有释放，两个线程将一起请求下去，陷入死循环，即出现&lt;code&gt;死锁&lt;/code&gt;的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如果避免死锁问题呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.1 缩小锁的范围&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现死锁的情况，有可能是像上面那样，锁范围太大了导致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么解决办法就是&lt;code&gt;缩小锁的范围&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockA&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_1) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_2) {&lt;br/&gt;             System.out.println(&lt;span&gt;&quot;LockA&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockB&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_2) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_1) {&lt;br/&gt;             System.out.println(&lt;span&gt;&quot;LockB&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在获取OBJECT_1锁的代码块中，不包含获取OBJECT_2锁的代码。同时在获取OBJECT_2锁的代码块中，也不包含获取OBJECT_1锁的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.2 保证锁的顺序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现死锁的情况说白了是，一个线程获取锁的顺序是：OBJECT_1和OBJECT_2。而另一个线程获取锁的顺序刚好相反为：OBJECT_2和OBJECT_1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如果我们能保证每次获取锁的顺序都相同，就不会出现死锁问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockA&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_1) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_2) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;LockA&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockB&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_1) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_2) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;LockB&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个线程，每个线程都是先获取OBJECT_1锁，再获取OBJECT_2锁。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 没释放锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中除了使用&lt;code&gt;synchronized&lt;/code&gt;关键字，给我们所需要的代码块加锁之外，还能通过&lt;code&gt;Lock&lt;/code&gt;关键字加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;synchronized&lt;/code&gt;关键字加锁后，如果程序执行完毕，或者程序出现异常时，会自动释放锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果使用&lt;code&gt;Lock&lt;/code&gt;关键字加锁后，需要开发人员在代码中手动释放锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock rLock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        rLock.lock();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;fun&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            rLock.unlock();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中先创建一个&lt;code&gt;ReentrantLock&lt;/code&gt;类的实例对象rLock，调用它的&lt;code&gt;lock&lt;/code&gt;方法加锁。然后执行业务代码，最后再&lt;code&gt;finally&lt;/code&gt;代码块中调用&lt;code&gt;unlock&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你没有在&lt;code&gt;finally&lt;/code&gt;代码块中，调用&lt;code&gt;unlock&lt;/code&gt;方法手动释放锁，线程持有的锁将不会得到释放。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. HashMap导致内存溢出&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;在实际的工作场景中，使用频率还是挺高的，比如：接收参数，缓存数据，汇总数据等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你在多线程的环境中使用HashMap，可能会导致非常严重的后果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HashMapService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;Long, Object&amp;gt; hashMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        hashMap.put(user.getId(), user.getName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在HashMapService类中定义了一个HashMap的成员变量，在add方法中往HashMap中添加数据。在controller层的接口中调用add方法，会使用tomcat的线程池去处理请求，就相当于在多线程的场景下调用add方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在jdk1.7中，HashMap使用的数据结构是：&lt;code&gt;数组&lt;/code&gt;+&lt;code&gt;链表&lt;/code&gt;。如果在多线程的情况下，不断往HashMap中添加数据，它会调用&lt;code&gt;resize&lt;/code&gt;方法进行扩容。该方法在复制元素到新数组时，采用的头插法，在某些情况下，会导致链表会出现死循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死循环最终结果会导致：&lt;code&gt;内存溢出&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，如果HashMap中数据非常多，会导致链表很长。当查找某个元素时，需要遍历某个链表，查询效率不太高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此，jdk1.8之后，将HashMap的数据结构改成了：&lt;code&gt;数组&lt;/code&gt;+&lt;code&gt;链表&lt;/code&gt;+&lt;code&gt;红黑树&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果同一个数组元素中的数据项小于8个，则还是用链表保存数据。如果大于8个，则自动转换成红黑树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要用红黑树？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：链表的时间复杂度是O(n)，而红黑树的时间复杂度是O(logn)，红黑树的复杂度是优于链表的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然这样，为什么不直接使用红黑树？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：树节点所占存储空间是链表节点的两倍，节点少的时候，尽管在时间复杂度上，红黑树比链表稍微好一些。但是由于红黑树所占空间比较大，HashMap综合考虑之后，认为节点数量少的时候用占存储空间更多的红黑树不划算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jdk1.8中HashMap就不会出现死循环？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：错，它在多线程环境中依然会出现死循环。在扩容的过程中，在链表转换为树的时候，for循环一直无法跳出，从而导致死循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如果想多线程环境中使用HashMap该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;ConcurrentHashMap&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 使用默认线程池&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道jdk1.5之后，提供了&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类，用它可以&lt;code&gt;自定义线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的好处有很多，比如：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;降低资源消耗&lt;/code&gt;：避免了频繁的创建线程和销毁线程，可以直接复用已有线程。而我们都知道，创建线程是非常耗时的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;提供速度&lt;/code&gt;：任务过来之后，因为线程已存在，可以拿来直接使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;提高线程的可管理性&lt;/code&gt;：线程是非常宝贵的资源，如果创建过多的线程，不仅会消耗系统资源，甚至会影响系统的稳定。使用线程池，可以非常方便的创建、管理和监控线程。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然jdk为了我们使用更便捷，&lt;span&gt;专门&lt;/span&gt;提供了：&lt;code&gt;Executors&lt;/code&gt;&lt;span&gt;类，&lt;/span&gt;给我们快速创建线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类中包含了很多静态方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt;：创建一个可缓冲的线程，如果线程池大小超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt;：创建一个固定大小的线程池，如果任务数量超过线程池大小，则将多余的任务放到队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newScheduledThreadPool&lt;/code&gt;：创建一个固定大小，并且能执行定时周期任务的线程池。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;：创建只有一个线程的线程池，保证所有的任务安装顺序执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的场景下，如果大家使用这些静态方法创建线程池，会有一些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们一起看看有哪些问题？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt;：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt;：允许创建的线程数是Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们该怎办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先推荐使用&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类，我们自定义线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ExecutorService threadPool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;br/&gt;    &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;//corePoolSize线程池中核心线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;//maximumPoolSize 线程池中最大线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;//线程池中线程的最大空闲时间，超过这个时间空闲线程将被回收&lt;/span&gt;&lt;br/&gt;    TimeUnit.SECONDS,&lt;span&gt;//时间单位&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue(&lt;span&gt;500&lt;/span&gt;), &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy()); &lt;span&gt;//拒绝策略&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说一下，如果是一些低并发场景，使用&lt;code&gt;Executors&lt;/code&gt;类创建线程池也未尝不可，也不能完全一棍子打死。在这些低并发场景下，很难出现OOM问题，所以我们需要根据实际业务场景选择。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. @Async注解的陷阱&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前在java并发编程中实现异步功能，一般是需要使用&lt;code&gt;线程&lt;/code&gt;或者&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的底层也是用的线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而实现一个线程，要么继承&lt;code&gt;Thread&lt;/code&gt;类，要么实现&lt;code&gt;Runnable&lt;/code&gt;接口，然后在run方法中写具体的业务逻辑代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发spring的大神们，为了简化这类异步操作，已经帮我们把异步功能封装好了。spring中提供了&lt;code&gt;@Async&lt;/code&gt;注解，我们可以通过它即可开启异步功能，使用起来非常方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体做法如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.在&lt;code&gt;springboot&lt;/code&gt;的启动类上面加上&lt;code&gt;@EnableAsync&lt;/code&gt;注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@EnableAsync&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Application&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SpringApplication.run(Application&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.在需要执行异步调用的业务方法加上&lt;code&gt;@Async&lt;/code&gt;注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CategoryService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;@Async&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(Category category)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//添加分类&lt;/span&gt;&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.在controller方法中调用这个业务方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/category&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CategoryController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; CategoryService categoryService;&lt;br/&gt;  &lt;br/&gt;     &lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(@RequestBody category)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        categoryService.add(category);&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能开启异步功能了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;是不是很easy？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有个坏消息是：&lt;span&gt;用@Async注解开启的异步功能，会调用&lt;/span&gt;&lt;code&gt;AsyncExecutionAspectSupport&lt;/code&gt;&lt;span&gt;类的&lt;/span&gt;&lt;code&gt;doSubmit&lt;/code&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5632022471910112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWohqZCBBOjUa71ia1g9GfqQ2TOM39gBAF2ylQdKDnrWUWwfBSTxKHsibEwua1IvYNZXcfDiczjShXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1424&quot;/&gt;默认情况会走else逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而else的逻辑最终会调用doExecute方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doExecute&lt;/span&gt;&lt;span&gt;(Runnable task)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Thread thread = (&lt;span&gt;this&lt;/span&gt;.threadFactory != &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;this&lt;/span&gt;.threadFactory.newThread(task) : createThread(task));&lt;br/&gt;  thread.start();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我去，这不是每次都会创建一个新线程吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，使用@Async注解开启的异步功能，默认情况下，每次都会创建一个新线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在高并发的场景下，可能会产生大量的线程，从而导致OOM问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;建议大家在@Async注解开启的异步功能时，请别忘了定义一个&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 自旋锁浪费cpu资源&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在并发编程中，&lt;code&gt;自旋锁&lt;/code&gt;想必大家都已经耳熟能详了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋锁有个非常经典的使用场景就是：&lt;code&gt;CAS&lt;/code&gt;（即比较和交换），它是一种无锁化思想（说白了用了一个死循环），用来解决高并发场景下，更新数据的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而atomic包下的很多类，比如：AtomicInteger、AtomicLong、AtomicBoolean等，都是用CAS实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以&lt;code&gt;AtomicInteger&lt;/code&gt;类为例，它的&lt;code&gt;incrementAndGet&lt;/code&gt;没有每次都给变量加1。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;incrementAndGet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; unsafe.getAndAddInt(&lt;span&gt;this&lt;/span&gt;, valueOffset, &lt;span&gt;1&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的底层就是用的自旋锁实现的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAndAddInt&lt;/span&gt;&lt;span&gt;(Object var1, &lt;span&gt;long&lt;/span&gt; var2, &lt;span&gt;int&lt;/span&gt; var4)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; var5;&lt;br/&gt;  &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;      var5 = &lt;span&gt;this&lt;/span&gt;.getIntVolatile(var1, var2);&lt;br/&gt;  } &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;.compareAndSwapInt(var1, var2, var5, var5 + var4));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; var5;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在do...while死循环中，不停进行数据的比较和交换，如果一直失败，则一直循环重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在高并发的情况下，compareAndSwapInt会很大概率失败，因此导致了此处cpu不断的自旋，这样会严重浪费cpu资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如果解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;LockSupport&lt;/code&gt;类的&lt;code&gt;parkNanos&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;compareAndSwapInt2&lt;/span&gt;&lt;span&gt;(Object var1, &lt;span&gt;long&lt;/span&gt; var2, &lt;span&gt;int&lt;/span&gt; var4, &lt;span&gt;int&lt;/span&gt; var5)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.compareAndSwapInt(var1,var2,var4, var5)) {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;          LockSupport.parkNanos(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当cas失败之后，调用LockSupport类的parkNanos方法休眠一下，相当于调用了Thread.Sleep方法。这样能够有效的减少频繁自旋导致cpu资源过度浪费的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. ThreadLocal用完没清空&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中保证线程安全的技术有很多，可以使用synchroized、Lock等关键字给代码块加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是它们有个共同的特点，就是加锁会对代码的性能有一定的损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在jdk中还提供了另外一种思想即：&lt;code&gt;用空间换时间&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，使用&lt;code&gt;ThreadLocal&lt;/code&gt;类就是对这种思想的一种具体体现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal为每个使用变量的线程提供了一个独立的变量副本，这样每一个线程都能独立地改变自己的副本，而不会影响其它线程所对应的副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal的用法大致是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先创建一个CurrentUser类，其中包含了ThreadLocal的逻辑。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CurrentUser&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;UserInfo&amp;gt; THREA_LOCAL = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(UserInfo userInfo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        THREA_LOCAL.set(userInfo);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UserInfo &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.get();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.remove();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在业务代码中调用CurrentUser类。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   CurrentUser.set(userInfo);&lt;br/&gt;   ...&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;   UserInfo userInfo = CurrentUser.get();&lt;br/&gt;   ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务代码的第一行，将userInfo对象设置到CurrentUser，这样在业务代码中，就能通过CurrentUser.get()获取到刚刚设置的userInfo对象。特别是对业务代码调用层级比较深的情况，这种用法非常有用，可以减少很多不必要传参。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在高并发的场景下，这段代码有问题，只往ThreadLocal存数据，数据用完之后并没有及时清理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal即使使用了&lt;code&gt;WeakReference&lt;/code&gt;（弱引用）也可能会存在&lt;code&gt;内存泄露&lt;/code&gt;问题，因为 entry对象中只把key(即threadLocal对象)设置成了弱引用，但是value值没有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;     CurrentUser.set(userInfo);&lt;br/&gt;     ...&lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;     UserInfo userInfo = CurrentUser.get();&lt;br/&gt;     ...&lt;br/&gt;   } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;      CurrentUser.remove();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要在&lt;code&gt;finally&lt;/code&gt;代码块中，调用remove方法清理没用的数据。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2b171205adb8396ca55cbb30fa657db4</guid>
<title>RabbitMQ、RocketMQ、Kafka 三元归一</title>
<link>https://toutiao.io/k/2gc8qxi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;h3&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;RabbitMQ各组件的功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Broker ：一个RabbitMQ实例就是一个Broker&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Virtual Host ：虚拟主机。&lt;strong&gt;相当于MySQL的DataBase&lt;/strong&gt;，一个Broker上可以存在多个vhost，vhost之间相互隔离。每个vhost都拥有自己的队列、交换机、绑定和权限机制。vhost必须在连接时指定，默认的vhost是/。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Exchange ：交换机，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Queue ：消息队列，用来保存消息直到发送给消费者。它是消息的容器。一个消息可投入一个或多个队列。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Banding ：绑定关系，用于&lt;strong&gt;消息队列和交换机之间的关联&lt;/strong&gt;。通过路由键（&lt;strong&gt;Routing Key&lt;/strong&gt;）将交换机和消息队列关联起来。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Channel ：管道，一条双向数据流通道。不管是发布消息、订阅队列还是接收消息，这些动作都是通过管道完成。因为对于操作系统来说，建立和销毁TCP都是非常昂贵的开销，所以引入了管道的概念，以复用一条TCP连接。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Connection ：生产者/消费者 与broker之间的TCP连接。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Publisher ：消息的生产者。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Consumer ：消息的消费者。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Message ：消息，它是由消息头和消息体组成。消息头则包括&lt;strong&gt;Routing-Key&lt;/strong&gt;、&lt;strong&gt;Priority&lt;/strong&gt;（优先级）等。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2636363636363636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv450CCK0SMtF8RUJxbDzueCoRuRfg1Bfj2sY7kkDgdtQAfshusQyRXHgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;RabbitMQ的多种交换机类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Exchange 分发消息给 Queue 时， Exchange 的类型对应不同的分发策略，有3种类型的 Exchange ：&lt;strong&gt;Direct&lt;/strong&gt;、&lt;strong&gt;Fanout&lt;/strong&gt;、&lt;strong&gt;Topic&lt;/strong&gt;。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Direct&lt;/strong&gt;：消息中的 Routing Key 如果和 Binding 中的 Routing Key 完全一致， Exchange 就会将消息分发到对应的队列中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Fanout&lt;/strong&gt;：每个发到 Fanout 类型交换机的消息都会分发到所有绑定的队列上去。Fanout交换机没有 Routing Key 。&lt;strong&gt;它在三种类型的交换机中转发消息是最快的&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Topic&lt;/strong&gt;：Topic交换机通过模式匹配分配消息，将 Routing Key 和某个模式进行匹配。它只能识别两个&lt;strong&gt;通配符&lt;/strong&gt;：&lt;strong&gt;&quot;#&quot;和&quot;*&quot;&lt;/strong&gt;。### 匹配0个或多个单词， * 匹配1个单词。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;TTL&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;TTL（Time To Live）：生存时间。RabbitMQ支持消息的过期时间，一共2种。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;生产者的消息确认机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Confirm机制：&lt;/p&gt;&lt;p&gt;如何实现Confirm确认消息？&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5218181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv458VekI6nAPdgwt3s7NKmSeppX1ylXIbcbq9dwh1bccTm39pbIZmHg2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot;/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;在channel上开启确认模式&lt;/strong&gt;：channel.confirmSelect()&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;在channel上开启监听&lt;/strong&gt;：addConfirmListener ，监听成功和失败的处理结果，根据具体的结果对消息进行重新发送或记录日志处理等后续操作。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Return消息机制：&lt;/p&gt;&lt;p&gt;Return Listener&lt;strong&gt;用于处理一些不可路由的消息&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;我们的消息生产者，通过指定一个Exchange和Routing，把消息送达到某一个队列中去，然后我们的消费者监听队列进行消息的消费处理操作。&lt;/p&gt;&lt;p&gt;但是在某些情况下，如果我们在发送消息的时候，当前的exchange不存在或者指定的路由key路由不到，这个时候我们需要监听这种不可达消息，就需要使用到Returrn Listener。&lt;/p&gt;&lt;p&gt;基础API中有个关键的配置项 Mandatory ：如果为true，监听器会收到路由不可达的消息，然后进行处理。如果为false，broker端会自动删除该消息。&lt;/p&gt;&lt;p&gt;同样，通过监听的方式， chennel.addReturnListener(ReturnListener rl) 传入已经重写过handleReturn方法的ReturnListener。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;消费端ACK与NACK&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;消费端进行消费的时候，如果由于业务异常可以进行日志的记录，然后进行补偿。但是对于服务器宕机等严重问题，我们需要&lt;strong&gt;手动ACK&lt;/strong&gt;保障消费端消费成功。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// deliveryTag：消息在mq中的唯一标识&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// multiple：是否批量(和qos设置类似的参数)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// requeue：是否需要重回队列。或者丢弃或者重回队首再次消费。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;basicNack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; deliveryTag, &lt;span&gt;boolean&lt;/span&gt; multiple, &lt;span&gt;boolean&lt;/span&gt; requeue)&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上代码，消息在&lt;strong&gt;消费端重回队列&lt;/strong&gt;是为了对没有成功处理消息，把消息重新返回到Broker。一般来说，实际应用中都会关闭重回队列（&lt;strong&gt;避免进入死循环&lt;/strong&gt;），也就是设置为false。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;死信队列DLX&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;死信队列（DLX Dead-Letter-Exchange）：当消息在一个队列中变成死信之后，它会被重新推送到另一个队列，这个队列就是死信队列。&lt;/p&gt;&lt;p&gt;DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。&lt;/p&gt;&lt;p&gt;当这个队列中有死信时，&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;amp;mid=2650357391&amp;amp;idx=1&amp;amp;sn=98a68099613a0f3d22b1f75c90f27f27&amp;amp;chksm=83004a6db477c37b1cd81500be3e7a474475780d70c760804119dc841362d88bb375c47d4d70&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;RabbitMQ&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;/a&gt;就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;阿里巴巴双十一官方指定消息产品，支撑阿里巴巴集团所有的消息服务，历经十余年高可用与高可靠的严苛考验，是阿里巴巴交易链路的核心产品。&lt;/p&gt;&lt;p&gt;Rocket：火箭的意思。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5727272727272728&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv45TG8Bo77icgLmDHLeE96iaH47UPxjbWXSoSWGPuQylfymN0eNRTh7nGUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot;/&gt;&lt;span&gt;&lt;strong&gt;RocketMQ的核心概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;他有以下核心概念：Broker 、 Topic 、 Tag 、 MessageQueue 、 NameServer 、 Group 、 Offset 、 Producer 以及 Consumer 。&lt;/p&gt;&lt;p&gt;下面来详细介绍。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Broker&lt;/strong&gt;：消息中转角色，负责&lt;strong&gt;存储消息&lt;/strong&gt;，转发消息。&lt;strong&gt;Broker&lt;/strong&gt;是具体提供业务的服务器，单个Broker节点与所有的NameServer节点保持长连接及心跳，并会定时将&lt;strong&gt;Topic&lt;/strong&gt;信息注册到NameServer，顺带一提底层的通信和连接都是&lt;strong&gt;基于Netty实现&lt;/strong&gt;的。&lt;strong&gt;Broker&lt;/strong&gt;负责消息存储，以Topic为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型。官网上有数据显示：具有&lt;strong&gt;上亿级消息堆积能力&lt;/strong&gt;，同时可&lt;strong&gt;严格保证消息的有序性&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Topic&lt;/strong&gt;：主题！它是消息的第一级类型。比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个 Topic 。&lt;strong&gt;Topic&lt;/strong&gt;与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。一个 Topic 也可以被 0个、1个、多个消费者订阅。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tag&lt;/strong&gt;：标签！可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同Topic而不同的&lt;strong&gt;Tag&lt;/strong&gt;来标识。比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有&lt;strong&gt;Tag&lt;/strong&gt;。标签有助于保持您的代码干净和连贯，并且还可以为&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;amp;mid=2650357391&amp;amp;idx=1&amp;amp;sn=98a68099613a0f3d22b1f75c90f27f27&amp;amp;chksm=83004a6db477c37b1cd81500be3e7a474475780d70c760804119dc841362d88bb375c47d4d70&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;RabbitMQ&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;/a&gt;提供的查询系统提供帮助。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;MessageQueue&lt;/strong&gt;：一个Topic下可以设置多个消息队列，发送消息时执行该消息的Topic，RocketMQ会轮询该Topic下的所有队列将消息发出去。消息的物理管理单位。一个Topic下可以有多个Queue，Queue的引入使得消息的存储可以分布式集群化，具有了水平扩展能力。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;NameServer&lt;/strong&gt;：类似Kafka中的ZooKeeper，但NameServer集群之间是&lt;strong&gt;没有通信&lt;/strong&gt;的，相对ZK来说更加&lt;strong&gt;轻量&lt;/strong&gt;。它主要负责对于源数据的管理，包括了对于&lt;strong&gt;Topic&lt;/strong&gt;和路由信息的管理。每个Broker在启动的时候会到NameServer注册，Producer在发送消息前会根据Topic去NameServer&lt;strong&gt;获取对应Broker的路由信息&lt;/strong&gt;，Consumer也会定时获取 Topic 的路由信息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Producer&lt;/strong&gt;：生产者，支持三种方式发送消息：&lt;strong&gt;同步、异步和单向&lt;/strong&gt;单向发送 ：消息发出去后，可以继续发送下一条消息或执行业务代码，不等待服务器回应，且&lt;strong&gt;没有回调函数&lt;/strong&gt;。异步发送 ：消息发出去后，可以继续发送下一条消息或执行业务代码，不等待服务器回应，&lt;strong&gt;有回调函数&lt;/strong&gt;。同步发送 ：消息发出去后，等待服务器响应成功或失败，才能继续后面的操作。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Consumer&lt;/strong&gt;：消费者，支持 PUSH 和 PULL 两种消费模式，支持&lt;strong&gt;集群消费&lt;/strong&gt;和&lt;strong&gt;广播消费&lt;/strong&gt;集群消费 ：该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。广播消费 ：会发给消费者组中的每一个消费者进行消费。相当于&lt;strong&gt;RabbitMQ&lt;/strong&gt;的发布订阅模式。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Group&lt;/strong&gt;：分组，一个组可以订阅多个Topic。分为ProducerGroup，ConsumerGroup，代表某一类的生产者和消费者，一般来说同一个服务可以作为Group，同一个Group一般来说发送和消费的消息都是一样的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Offset&lt;/strong&gt;：在RocketMQ中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用Offset来访问，Offset为Java Long类型，64位，理论上在 100年内不会溢出，所以认为是长度无限。也可以认为Message Queue是一个长度无限的数组，&lt;strong&gt;Offset&lt;/strong&gt;就是下标。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;延时消息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;开源版的RocketMQ不支持任意时间精度，仅支持特定的level，例如定时5s，10s，1min等。其中，level=0级表示不延时，level=1表示1级延时，level=2表示2级延时，以此类推。&lt;/p&gt;&lt;p&gt;延时等级如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;messageDelayLevel=&lt;span&gt;1s&lt;/span&gt; &lt;span&gt;5s&lt;/span&gt; &lt;span&gt;10s&lt;/span&gt; &lt;span&gt;30s&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;m &lt;span&gt;2&lt;/span&gt;m &lt;span&gt;3&lt;/span&gt;m &lt;span&gt;4&lt;/span&gt;m &lt;span&gt;5&lt;/span&gt;m &lt;span&gt;6&lt;/span&gt;m &lt;span&gt;7&lt;/span&gt;m &lt;span&gt;8&lt;/span&gt;m &lt;span&gt;9&lt;/span&gt;m &lt;span&gt;10&lt;/span&gt;m &lt;span&gt;20&lt;/span&gt;m &lt;span&gt;30&lt;/span&gt;m &lt;span&gt;1&lt;/span&gt;h &lt;span&gt;2&lt;/span&gt;h&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;顺序消息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;消息有序指的是可以按照消息的发送顺序来消费（FIFO）。RocketMQ可以严格的保证消息有序，可以分为 分区有序 或者 全局有序 。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;事务消息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30363636363636365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv45jMVIRW6JxbVicpM6ZmicUsXnH2r68ehOA3EbxVa5aNZTPPiag69OcEMIg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;p&gt;消息队列MQ提供类似X/Open XA的分布式事务功能，通过消息队列MQ事务消息能达到分布式事务的最终一致。上图说明了事务消息的大致流程：正常事务消息的发送和提交、事务消息的补偿流程。&lt;/p&gt;&lt;p&gt;事务消息发送及提交：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发送half消息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务端响应消息写入结果&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据本地事务状态执行Commit或Rollback（Commit操作生成消息索引，消息对消费者可见）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;事务消息的补偿流程：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Producer收到回查消息，检查回查消息对应的本地事务的状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据本地事务状态，重新Commit或RollBack&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其中，补偿阶段用于解决消息Commit或Rollback发生超时或者失败的情况。&lt;/p&gt;&lt;p&gt;事务消息状态：&lt;/p&gt;&lt;p&gt;事务消息共有三种状态：提交状态、回滚状态、中间状态：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TransactionStatus.CommitTransaction：提交事务，它允许消费者消费此消息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TransactionStatus.RollbackTransaction：回滚事务，它代表该消息将被删除，不允许被消费。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TransactionStatus.Unkonwn：中间状态，它代表需要检查消息队列来确定消息状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;RocketMQ的高可用机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;‍&lt;/span&gt;RocketMQ&lt;span&gt;‍&lt;/span&gt;是天生支持分布式的，可以配置主从以及水平扩展。&lt;/p&gt;&lt;p&gt;Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。&lt;/p&gt;&lt;p&gt;消息消费的高可用（主从）：&lt;/p&gt;&lt;p&gt;在Consumer的配置文件中，并不需要设置是从Master读还是从Slave读，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性。&lt;strong&gt;RocketMQ目前还不支持把Slave自动转成Master&lt;/strong&gt;，如果机器资源不足，需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文件，用新的配置文件启动Broker。&lt;/p&gt;&lt;p&gt;消息发送高可用（配置多个主节点）：&lt;/p&gt;&lt;p&gt;在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可用后，其他组的Master仍然可用，Producer仍然可以发送消息。&lt;/p&gt;&lt;p&gt;主从复制：&lt;/p&gt;&lt;p&gt;如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;同步复制&lt;/strong&gt;：同步复制方式是等Master和Slave均写成功后才反馈给客户端写成功状态。如果Master出故障， Slave上有全部的备份数据，容易恢复同步复制会增大数据写入延迟，降低系统吞吐量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;异步复制&lt;/strong&gt;：异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通常情况下，应该把Master和Save配置成同步刷盘方式，主从之间配置成异步的复制方式，这样即使有一台机器出故障，仍然能保证数据不丢，是个不错的选择。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Producer负载均衡：&lt;/p&gt;&lt;p&gt;Producer端，每个实例在发消息的时候，默认会&lt;strong&gt;轮询&lt;/strong&gt;所有的Message Queue发送，以达到让消息平均落在不同的Queue上。而由于Queue可以散落在不同的Broker，所以消息就发送到不同的Broker下，如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4618181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv45otc9Egau54qXVCgI6evfdBoZ9s5gCn4JDZIKevpiaQpDIEwhtHRiaAYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot;/&gt;Consumer负载均衡：&lt;/p&gt;&lt;p&gt;如果Consumer实例的数量比Message Queue的总数量还多的话，&lt;strong&gt;多出来的Consumer实例将无法分到Queue&lt;/strong&gt;，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让Queue的总数量大于等于Consumer的数量。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费者的集群模式：启动多个消费者就可以保证消费者的负载均衡（均摊队列）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;默认使用的是均摊队列&lt;/strong&gt;：会按照Queue的数量和实例的数量平均分配Queue给每个实例，这样每个消费者可以均摊消费的队列，如下图所示6个队列和三个生产者。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;另外一种平均的算法&lt;strong&gt;环状轮流分Queue&lt;/strong&gt;的形式，每个消费者，均摊不同主节点的一个消息队列，如下图所示：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于广播模式并不是负载均衡的，要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;死信队列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当一条消息消费失败，RocketMQ就会自动进行消息重试。而如果消息超过最大重试次数，RocketMQ就会认为这个消息有问题。但是此时，RocketMQ不会立刻将这个有问题的消息丢弃，而会将其发送到这个消费者组对应的一种特殊队列：死信队列。死信队列的名称是 %DLQ%+ConsumGroup 。&lt;/p&gt;&lt;p&gt;死信队列具有以下特性：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个死信队列对应一个Group ID， 而不是对应单个消费者实例。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果一个Group ID未产生死信消息，消息队列RocketMQ不会为其创建相应的死信队列。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个死信队列包含了对应Group ID产生的所有死信消息，不论该消息属于哪个Topic。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;Kafka是一个分布式、支持分区的、多副本的，&lt;strong&gt;基于ZooKeeper&lt;/strong&gt;协调的分布式消息系统。&lt;/p&gt;&lt;p&gt;它最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于Hadoop的批处理系统、低延迟的实时系统、Storm/Spark流式处理引擎，Web/Nginx日志、访问日志，消息服务等等，用&lt;strong&gt;Scala语言编写&lt;/strong&gt;。属于Apache基金会的顶级开源项目。&lt;/p&gt;&lt;p&gt;先看一下Kafka的架构图 ：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5490909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv45kvMMOEechP5WkiabadqsFS1qqqVtK1x4zyUx4l7RHk0THzEpedX9wHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;Kafka的核心概念&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在Kafka中有几个核心概念：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Broker&lt;/strong&gt;：消息中间件处理节点，一个Kafka节点就是一个Broker，一个或者多个Broker可以组成一个Kafka集群&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Topic&lt;/strong&gt;：Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Producer&lt;/strong&gt;：消息生产者，向Broker发送消息的客户端&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Consumer&lt;/strong&gt;：消息消费者，从Broker读取消息的客户端&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;ConsumerGroup&lt;/strong&gt;：每个Consumer属于一个特定的ConsumerGroup，一条消息可以被多个不同的ConsumerGroup消费，但是一个ConsumerGroup中只能有一个Consumer能够消费该消息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Partition&lt;/strong&gt;：物理上的概念，一个topic可以分为多个partition，每个partition内部消息是有序的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Leader&lt;/strong&gt;：每个Partition有多个副本，其中有且仅有一个作为Leader，Leader是负责数据读写的Partition。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Follower&lt;/strong&gt;：Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，Leader会把这个Follower从 ISR列表 中删除，重新创建一个Follower。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Offset&lt;/strong&gt;：偏移量。Kafka的存储文件都是按照offset.kafka来命名，用Offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可以这么来理解Topic，Partition和Broker：&lt;/p&gt;&lt;p&gt;一个Topic，代表逻辑上的一个业务数据集，比如订单相关操作消息放入订单Topic，用户相关操作消息放入用户Topic，对于大型网站来说，后端数据都是海量的，订单消息很可能是非常巨量的，比如有几百个G甚至达到TB级别，如果把这么多数据都放在一台机器上可定会有容量限制问题，那么就可以在Topic内部划分多个Partition来分片存储数据，不同的Partition可以位于不同的机器上，相当于&lt;strong&gt;分布式存储&lt;/strong&gt;。每台机器上都运行一个Kafka的进程Broker。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka核心总控制器Controller&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在Kafka集群中会有一个或者多个Broker，其中有一个Broker会被选举为控制器（Kafka Controller），可以理解为 Broker-Leader ，它负责管理整个 集群中所有分区和副本的状态。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Partition-Leader&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;Controller选举机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在Kafka集群启动的时候，选举的过程是集群中每个Broker都会尝试在ZooKeeper上创建一个 /controller临时节点，ZooKeeper会保证有且仅有一个Broker能创建成功，这个Broker就会成为集群的总控器Controller。&lt;/p&gt;&lt;p&gt;当这个Controller角色的Broker宕机了，此时ZooKeeper临时节点会消失，集群里其他Broker会一直监听这个临时节 点，发现临时节点消失了，就竞争再次创建临时节点，就是我们上面说的选举机制，ZooKeeper又会保证有一个Broker成为新的Controller。具备控制器身份的Broker需要比其他普通的Broker多一份职责，具体细节如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;监听Broker相关的变化&lt;/strong&gt;。为ZooKeeper中的/brokers/ids/节点添加BrokerChangeListener，用来处理Broker增减的变化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;监听Topic相关的变化&lt;/strong&gt;。为ZooKeeper中的/brokers/topics节点添加TopicChangeListener，用来处理Topic增减的变化；为ZooKeeper中的/admin/delete_topics节点添加TopicDeletionListener，用来处理删除Topic的动作。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从ZooKeeper中读取获取当前所有与Topic、Partition以及Broker有关的信息并进行相应的管理 。对于所有Topic所对应的ZooKeeper中的/brokers/topics/节点添加PartitionModificationsListener，用来监听Topic中的分区分配变化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;更新集群的元数据信息，同步到其他普通的Broker节点中&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;Partition副本选举Leader机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Controller感知到分区Leader所在的Broker挂了，Controller会从ISR列表（参数&lt;br/&gt;unclean.leader.election.enable=false的前提下）里挑第一个Broker作为Leader（第一个Broker最先放进ISR列表，可能是同步数据最多的副本），如果参数unclean.leader.election.enable为true，代表在ISR列表里所有副本都挂了的时候可以在ISR列表以外的副本中选Leader，这种设置，可以提高可用性，但是选出的新Leader有可能数据少很多。副本进入ISR列表有两个条件：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;副本节点不能产生分区，必须能与ZooKeeper保持会话以及跟Leader副本网络连通&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;副本能复制Leader上的所有写操作，并且不能落后太多。（与Leader副本同步滞后的副本，是由replica.lag.time.max.ms配置决定的，超过这个时间都没有跟Leader同步过的一次的副本会被移出ISR列表）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;消费者消费消息的Offset记录机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;每个Consumer会定期将自己消费分区的Offset提交给Kafka内部Topic：consumer_offsets，提交过去的时候，key是consumerGroupId+topic+分区号，value就是当前Offset的值，Kafka会定期清理Topic里的消息，最后就保留最新的那条数据。&lt;/p&gt;&lt;p&gt;因为__consumer_offsets可能会接收高并发的请求，Kafka默认给其分配50个分区（可以通过&lt;br/&gt;offsets.topic.num.partitions设置），这样可以通过加机器的方式抗大并发。&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费者Rebalance机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Rebalance就是说 如果消费组里的消费者数量有变化或消费的分区数有变化，Kafka会重新分配消费者与消费分区的关系 。比如consumer group中某个消费者挂了，此时会自动把分配给他的分区交给其他的消费者，如果他又重启了，那么又会把一些分区重新交还给他。&lt;/p&gt;&lt;p&gt;注意：Rebalance只针对subscribe这种不指定分区消费的情况，如果通过assign这种消费方式指定了分区，Kafka不会进行Rebalance。&lt;/p&gt;&lt;p&gt;如下情况可能会触发消费者Rebalance：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费组里的Consumer增加或减少了&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;动态给Topic增加了分区&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费组订阅了更多的Topic&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Rebalance过程中，消费者无法从Kafka消费消息，这对Kafka的TPS会有影响，如果Kafka集群内节点较多，比如数百 个，那重平衡可能会耗时极多，所以应尽量避免在系统高峰期的重平衡发生。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rebalance过程如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当有消费者加入消费组时，消费者、消费组及组协调器之间会经历以下几个阶段：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv45OmZFGrPJ9asEn42xwyzXD6iciaDfU9OoJuEqCTJh1Qhpszb9nb5YMCJw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot;/&gt;&lt;strong&gt;第一阶段：选择组协调器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;组协调器GroupCoordinator：每个consumer group都会选择一个Broker作为自己的组协调器coordinator，负责监控这个消费组里的所有消费者的心跳，以及判断是否宕机，然后开启消费者Rebalance。consumer group中的每个consumer启动时会向Kafka集群中的某个节点发送FindCoordinatorRequest请求来查找对应的组协调器GroupCoordinator，并跟其建立网络连接。组协调器选择方式：通过如下公式可以选出consumer消费的Offset要提交到__consumer_offsets的哪个分区，这个分区Leader对应的Broker就是这个consumer group的coordinator公式：&lt;/p&gt;&lt;p&gt;hash(consumer group id) % 对应主题的分区数&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二阶段：加入消费组JOIN GROUP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在成功找到消费组所对应的GroupCoordinator之后就进入加入消费组的阶段，在此阶段的消费者会向GroupCoordinator发送JoinGroupRequest请求，并处理响应。然后GroupCoordinator从一个consumer group中选择第一个加入group的consumer作为Leader（消费组协调器），把consumer group情况发送给这个Leader，接着这个Leader会负责制定分区方案。&lt;/p&gt;&lt;p&gt;第三阶段（SYNC GROUP）&lt;/p&gt;&lt;p&gt;consumer leader通过给GroupCoordinator发送SyncGroupRequest，接着GroupCoordinator就把分区方案下发给各个consumer，他们会根据指定分区的Leader Broker进行网络连接以及消息消费。&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费者Rebalance分区分配策略&lt;/span&gt;&lt;/p&gt;&lt;p&gt;主要有三种Rebalance的策略：range 、 round-robin 、 sticky 。&lt;strong&gt;默认情况为range分配策略&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;假设一个主题有10个分区（0-9），现在有三个consumer消费：&lt;/p&gt;&lt;p&gt;range策略：按照分区序号排序分配 ，假设n＝分区数／消费者数量 = 3， m＝分区数%消费者数量 = 1，那么前 m 个消 费者每个分配 n+1 个分区，后面的（消费者数量－m ）个消费者每个分配 n 个分区。比如分区0~ 3给一个consumer，分区4~ 6给一个consumer，分区7~9给一个consumer。&lt;/p&gt;&lt;p&gt;round-robin策略：轮询分配 ，比如分区0、3、6、9给一个consumer，分区1、4、7给一个consumer，分区2、5、 8给一个consumer&lt;/p&gt;&lt;p&gt;sticky策略：初始时分配策略与round-robin类似，但是在rebalance的时候，需要保证如下两个原则：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分区的分配要尽可能均匀 。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分区的分配尽可能与上次分配的保持相同。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当两者发生冲突时，第一个目标优先于第二个目标 。这样可以最大程度维持原来的分区分配的策略。比如对于第一种range情况的分配，如果第三个consumer挂了，那么重新用sticky策略分配的结果如下：consumer1除了原有的0~ 3，会再分配一个7 consumer2除了原有的4~ 6，会再分配8和9。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Producer发布消息机制剖析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、写入方式&lt;/p&gt;&lt;p&gt;producer采用push模式将消息发布到broker，每条消息都被append到patition中，属于顺序写磁盘（&lt;strong&gt;顺序写磁盘 比 随机写 效率要高，保障 kafka 吞吐率&lt;/strong&gt;）。&lt;/p&gt;&lt;p&gt;2、消息路由&lt;/p&gt;&lt;p&gt;producer发送消息到broker时，会根据分区算法选择将其存储到哪一个partition。其路由机制为：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;hash&lt;/span&gt;(key)%分区数&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、写入流程&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8072727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv45wP8dNGScJ0duw1wkUEonuat1mzV0gF3azT9sj1NMbWOHy9cKia0kRSQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;producer先从ZooKeeper的 &quot;/brokers/…/state&quot; 节点找到该partition的leader&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;producer将消息发送给该leader&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;leader将消息写入本地log&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;followers从leader pull消息，写入本地log后向leader发送ACK&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;leader收到所有ISR中的replica的ACK后，增加HW（high watermark，最后commit的offset）并向producer发送ACK&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;HW与LEO&lt;/span&gt;&lt;/p&gt;&lt;p&gt;HW俗称高水位 ，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO（log-end-offset）作为HW， consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状 态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW， 此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。对于来自内部broker的读取请求，没有HW的限制。&lt;/p&gt;&lt;p&gt;&lt;span&gt;日志分段存储&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Kafka一个分区的消息数据对应存储在一个文件夹下，以topic名称+分区号命名，消息在分区内是分段存储的， 每个段的消息都存储在不一样的log文件里，Kafka规定了一个段位的log文件最大为1G，做这个限制目的是为了方便把log文件加载到内存去操作：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;1 ### 部分消息的&lt;span&gt;offset&lt;/span&gt;索引文件，&lt;span&gt;kafka&lt;/span&gt;每次往分区发4&lt;span&gt;K&lt;/span&gt;(可配置)消息就会记录一条当前消息的&lt;span&gt;offset&lt;/span&gt;到&lt;span&gt;index&lt;/span&gt;文件， &lt;br/&gt;&lt;br/&gt;2 ### 如果要定位消息的&lt;span&gt;offset&lt;/span&gt;会先在这个文件里快速定位，再去&lt;span&gt;log&lt;/span&gt;文件里找具体消息 &lt;br/&gt;&lt;br/&gt;3 00000000000000000000&lt;span&gt;.index&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;4 ### 消息存储文件，主要存&lt;span&gt;offset&lt;/span&gt;和消息体 &lt;br/&gt;&lt;br/&gt;5 00000000000000000000&lt;span&gt;.log&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;6 ### 消息的发送时间索引文件，&lt;span&gt;kafka&lt;/span&gt;每次往分区发4&lt;span&gt;K&lt;/span&gt;(可配置)消息就会记录一条当前消息的发送时间戳与对应的&lt;span&gt;offset&lt;/span&gt;到&lt;span&gt;timeindex&lt;/span&gt;文件， &lt;br/&gt;&lt;br/&gt;7 ### 如果需要按照时间来定位消息的&lt;span&gt;offset&lt;/span&gt;，会先在这个文件里查找 &lt;br/&gt;&lt;br/&gt;8 00000000000000000000&lt;span&gt;.timeindex&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;9 &lt;br/&gt;&lt;br/&gt;10 00000000000005367851&lt;span&gt;.index&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;11 00000000000005367851&lt;span&gt;.log&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;12 00000000000005367851&lt;span&gt;.timeindex&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;13 &lt;br/&gt;&lt;br/&gt;14 00000000000009936472&lt;span&gt;.index&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;15 00000000000009936472&lt;span&gt;.log&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;16 00000000000009936472&lt;span&gt;.timeindex&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个9936472之类的数字，就是代表了这个日志段文件里包含的起始 Offset，也就说明这个分区里至少都写入了接近1000万条数据了。Kafka Broker有一个参数，log.segment.bytes，限定了每个日志段文件的大小，最大就是1GB。一个日志段文件满了，就自动开一个新的日志段文件来写入，避免单个文件过大，影响文件的读写性能，这个过程叫做log rolling，正在被写入的那个日志段文件，叫做active log segment。&lt;/p&gt;&lt;p&gt;最后附一张ZooKeeper节点数据图&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5690909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv45ggBDW0YUjVVTf8OXTibgx2WriaYyZXDTZwkzEn1WGdtoCWTh50s7PLAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;MQ带来的一些问题、及解决方案&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;如何保证顺序消费？&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;如何实现延迟消费？&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3327272727272727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv45Xll8yDcESuou8slUhS7VB6tJCAq2mmGQTZ813htxe4UFUlWbarFJMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;如何保证消息的可靠性投递&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;amp;mid=2650357391&amp;amp;idx=1&amp;amp;sn=98a68099613a0f3d22b1f75c90f27f27&amp;amp;chksm=83004a6db477c37b1cd81500be3e7a474475780d70c760804119dc841362d88bb375c47d4d70&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;RabbitMQ&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;/a&gt;：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Broker--&amp;gt;消费者：手动ACK&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;生产者--&amp;gt;Broker：两种方案&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;数据库持久化：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;.将业务订单数据和生成的&lt;span&gt;Message&lt;/span&gt;进行持久化操作（一般情况下插入数据库，这里如果分库的话可能涉及到分布式事务）&lt;br/&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;.将&lt;span&gt;Message&lt;/span&gt;发送到Broker服务器中&lt;br/&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;.通过RabbitMQ的Confirm机制，在producer端，监听服务器是否ACK。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;.如果ACK了，就将&lt;span&gt;Message&lt;/span&gt;这条数据状态更新为已发送。如果失败，修改为失败状态。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;.分布式定时任务查询数据库&lt;span&gt;3&lt;/span&gt;分钟（这个具体时间应该根据的时效性来定）之前的发送失败的消息&lt;br/&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;.重新发送消息，记录发送次数&lt;br/&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;.如果发送次数过多仍然失败，那么就需要人工排查之类的操作。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6854545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv45xicXLt3BVv5qicffQBeQyiaXicej2QJicric3spOdzJxxt2y0v397UycY1bg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;优点：能够保证消息百分百不丢失。&lt;/p&gt;&lt;p&gt;缺点：第一步会涉及到分布式事务问题。&lt;/p&gt;&lt;p&gt;消息的延迟投递：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;流程图中，颜色不同的代表不同的&lt;span&gt;message&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;1&lt;/span&gt;.将业务订单持久化&lt;br/&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;.发送一条&lt;span&gt;Message&lt;/span&gt;到broker(称之为主&lt;span&gt;Message&lt;/span&gt;)，再发送相同的一条到不同的队列或者交换机(这条称为确认&lt;span&gt;Message&lt;/span&gt;)中。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;.主&lt;span&gt;Message&lt;/span&gt;由实际业务处理端消费后，生成一条响应&lt;span&gt;Message&lt;/span&gt;。之前的确认&lt;span&gt;Message&lt;/span&gt;由&lt;span&gt;Message&lt;/span&gt; Service应用处理入库。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;~&lt;span&gt;6&lt;/span&gt;.实际业务处理端发送的确认&lt;span&gt;Message&lt;/span&gt;由&lt;span&gt;Message&lt;/span&gt; Service接收后，将原&lt;span&gt;Message&lt;/span&gt;状态修改。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;.如果该条&lt;span&gt;Message&lt;/span&gt;没有被确认，则通过rpc调用重新由producer进行全过程。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33090909090909093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv45kHqQxeUIDn263JKDzY8eIiaeHToymHRCpv2OyJfcYsw8R51cVRW8Wrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;优点：相对于持久化方案来说响应速度有所提升&lt;/p&gt;&lt;p&gt;缺点：系统复杂性有点高，万一两条消息都失败了，消息存在丢失情况，仍需Confirm机制做补偿。&lt;/p&gt;&lt;p&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;/p&gt;&lt;p&gt;生产者弄丢数据：&lt;/p&gt;&lt;p&gt;Producer在把Message发送Broker的过程中，因为网络问题等发生丢失，或者Message到了Broker，但是出了问题，没有保存下来。针对这个问题，&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;amp;mid=2650347372&amp;amp;idx=1&amp;amp;sn=97a0803defeadc67931e65dc4d754a6a&amp;amp;chksm=8300638eb477ea983563bea2f1bb226b65b77581b44eea35f12775df411ee815cd4f3b703138&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;RocketMQ&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;/a&gt;对Producer发送消息设置了3种方式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;同步发送&lt;br/&gt;异步发送&lt;br/&gt;单向发送&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Broker弄丢数据：&lt;/p&gt;&lt;p&gt;Broker接收到Message暂存到内存，Consumer还没来得及消费，Broker挂掉了。&lt;/p&gt;&lt;p&gt;可以通过 持久化 设置去解决：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;创建Queue的时候设置持久化，保证Broker持久化Queue的元数据，但是不会持久化Queue里面的消息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将Message的deliveryMode设置为2，可以将消息持久化到磁盘，这样只有Message支持化到磁盘之后才会发送通知Producer ack&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这两步过后，即使Broker挂了，Producer肯定收不到ack的，就可以进行重发。&lt;/p&gt;&lt;p&gt;消费者弄丢数据：&lt;/p&gt;&lt;p&gt;Consumer有消费到Message，但是内部出现问题，Message还没处理，Broker以为Consumer处理完了，只会把后续的消息发送。这时候，就要 关闭autoack，消息处理过后，进行手动ack , 多次消费失败的消息，会进入 死信队列 ，这时候需要人工干预。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;生产者弄丢数据&lt;/p&gt;&lt;p&gt;设置了 acks=all ，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。&lt;/p&gt;&lt;p&gt;Broker弄丢数据&lt;/p&gt;&lt;p&gt;Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。&lt;/p&gt;&lt;p&gt;此时一般是要求起码设置如下 4 个参数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;replication.factor&lt;br/&gt;min.insync.replicas&lt;br/&gt;acks=all&lt;br/&gt;retries=MAX&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。&lt;/p&gt;&lt;p&gt;消费者弄丢数据&lt;/p&gt;&lt;p&gt;你消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。&lt;/p&gt;&lt;p&gt;这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要 关闭自动提交 offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是可能会有重复消费，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;如何保证消息的幂等？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;以 RocketMQ 为例，下面列出了消息重复的场景：&lt;/p&gt;&lt;p&gt;发送时消息重复&lt;/p&gt;&lt;p&gt;当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且Message ID也相同的消息。&lt;/p&gt;&lt;p&gt;投递时消息重复&lt;/p&gt;&lt;p&gt;消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。为了保证消息至少被消费一次，消息队列&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;amp;mid=2650347372&amp;amp;idx=1&amp;amp;sn=97a0803defeadc67931e65dc4d754a6a&amp;amp;chksm=8300638eb477ea983563bea2f1bb226b65b77581b44eea35f12775df411ee815cd4f3b703138&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;RocketMQ&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;/a&gt;版的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且Message ID也相同的消息。&lt;/p&gt;&lt;p&gt;负载均衡时消息重复（包括但不限于网络抖动、Broker重启以及消费者应用重启）&lt;/p&gt;&lt;p&gt;当消息队列RocketMQ版的Broker或客户端重启、扩容或缩容时，会触发Rebalance，此时消费者可能会收到重复消息。&lt;/p&gt;&lt;p&gt;那么，有什么解决方案呢？直接上图。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1189591078066914&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv457m0jqUerbsd0yQt0Vbx1Tyr7pWWYZpJ7mAibfjg0QTpM224mHgKJoyg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1076&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;如何解决消息积压的问题？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;关于这个问题，有几个点需要考虑：&lt;/p&gt;&lt;p&gt;如何快速让积压的消息被消费掉？&lt;/p&gt;&lt;p&gt;临时写一个消息分发的消费者，把积压队列里的消息均匀分发到N个队列中，同时一个队列对应一个消费者，相当于消费速度提高了N倍。&lt;/p&gt;&lt;p&gt;修改前：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5664739884393064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv45GAcfiaStESFibSicJibtosibbXyclkU52SqtYbPGYP4ib7Y6wEWaSvduSqMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1038&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;修改后：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.68&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk55qufvUzRzyQYcrEmL4Cv457f3ibBDUDBbCyoydM9768IP9VV9CWknNnse4VbdQOticSFosRdpYREsw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;积压时间太久，导致部分消息过期，怎么处理？&lt;/p&gt;&lt;p&gt;批量重导。在业务不繁忙的时候，比如凌晨，提前准备好程序，把丢失的那批消息查出来，重新导入到MQ中。&lt;/p&gt;&lt;p&gt;消息大量积压，MQ磁盘被写满了，导致新消息进不来了，丢掉了大量消息，怎么处理？&lt;/p&gt;&lt;p&gt;这个没办法。谁让【消息分发的消费者】写的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>769091fa4633e3f08f08d05de64a12df</guid>
<title>Linux 程序编译过程详解</title>
<link>https://toutiao.io/k/o4hxpl5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;↓&lt;/span&gt;&lt;span&gt;推荐关注↓&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwNjMxMTgwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/IgylNib7ZE2L6Kv5EcGWb5mYVbzlgzP2R6qdGee7kZ03T7nia7rtkSnKvEvEOwnGxX4Zf2VVrlQNwWVrLlEhn4OQ/0?wx_fmt=png&quot; data-nickname=&quot;Go开发大全&quot; data-alias=&quot;goprogrammer&quot; data-signature=&quot;点击获取6万star的Go开源库。[ Go开发大全 ] 日常分享 Go, 云原生、k8s、Docker和微服务方面的技术文章和行业动态。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;pre&gt;&lt;pre&gt;&lt;pre&gt;&lt;h1&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h1&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;大家肯定都知道&lt;span&gt;计算机程序设计语言通常分为机器语言、汇编语言和高级语言三类。高级语言需要通过翻译成机器语言才能执行，而翻译的方式分为两种，一种是编译型，另一种是解释型，因此我们基本上将高级语言分为两大类，一种是编译型语言，例如C，C++，Java，另一种是解释型语言，例如Python、Ruby、MATLAB 、JavaScript。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文将介绍如何将高层的C/C++语言编写的程序转换成为处理器能够执行的二进制代&lt;/span&gt;&lt;span&gt;码的过程，包括四个步骤：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;预处理（Preprocessing）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;编译（Compilation）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;汇编（Assembly）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;链接（Linking）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5386904761904762&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9sNwsXcN68r9HRG8EDyr4qibWuPueTNaDIwKfibUtPJyT1WQPZzrYuW22DEiat6NvACulo7UT3s38s4oZNEVt10rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;672&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;GCC 工具链介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通常所说的GCC是GUN Compiler Collection的简称，是Linux系统上常用的编译工具。GCC工具链软件包括GCC、Binutils、C运行库等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GCC&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GCC（GNU C Compiler）是编译工具。本文所要介绍的将C/C++语言编写的程序转换成为处理器能够执行的二进制代码的过程即由编译器完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Binutils&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一组二进制程序处理工具，包括：addr2line、ar、objcopy、objdump、as、ld、ldd、readelf、size等。这一组工具是开发和调试不可缺少的工具，分别简介如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;addr2line：用来将程序地址转换成其所对应的程序源文件及所对应的代码行，也可以得到所对应的函数。该工具将帮助调试器在调试的过程中定位对应的源代码位置。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;as：主要用于汇编，有关汇编的详细介绍请参见后文。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ld：主要用于链接，有关链接的详细介绍请参见后文。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ar：主要用于创建静态库。为了便于初学者理解，在此介绍动态库与静态库的概念：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果要将多个.o目标文件生成一个库文件，则存在两种类型的库，一种是静态库，另一种是动态库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在windows中静态库是以 .lib 为后缀的文件，共享库是以 .dll 为后缀的文件。在linux中静态库是以.a为后缀的文件，共享库是以.so为后缀的文件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;静态库和动态库的不同点在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。在Linux系统中，可以用ldd命令查看一个可执行程序依赖的共享库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果一个系统中存在多个需要同时运行的程序且这些程序之间存在共享库，那么采用动态库的形式将更节省内存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ldd：可以用于查看一个可执行程序依赖的共享库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;objcopy：将一种对象文件翻译成另一种格式，譬如将.bin转换成.elf、或者将.elf转换成.bin等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;objdump：主要的作用是反汇编。有关反汇编的详细介绍，请参见后文。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;readelf：显示有关ELF文件的信息，请参见后文了解更多信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;size：列出可执行文件每个部分的尺寸和总尺寸，代码段、数据段、总大小等，请参见后文了解使用size的具体使用实例。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;C运行库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;C语言标准主要由两部分组成：一部分描述C的语法，另一部分描述C标准库。C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义，譬如常见的printf函数便是一个C标准库函数，其原型定义在stdio头文件中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;C语言标准仅仅定义了C标准库函数原型，并没有提供实现。因此，C语言编译器通常需要一个C运行时库（C Run Time Libray，CRT）的支持。C运行时库又常简称为C运行库。与C语言类似，C++也定义了自己的标准，同时提供相关支持库，称为C++运行时库。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于GCC工具链主要是在Linux环境中进行使用，因此本文也将以Linux系统作为工作环境。为了能够演示编译的整个过程，本节先准备一个C语言编写的简单Hello程序作为示例，其源代码如下所示：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt; &lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//此程序很简单，仅仅打印一个Hello World的字符串。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Hello World! \n&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;编译过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1.预处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;预处理的过程主要包括以下过程：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将所有的#define删除，并且展开所有的宏定义，并且处理所有的条件预编译指令，比如#if #ifdef #elif #else #endif等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;删除所有注释“//”和“/* */”。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;保留所有的#pragma编译器指令，后续编译过程需要使用它们。&lt;br/&gt;使用gcc进行预处理的命令如下：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; gcc -E hello.c -o hello.i // 将源文件hello.c文件预处理生成hello.i&lt;/span&gt;&lt;br/&gt;                        // GCC的选项-E使GCC在进行完预处理后即停止&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;hello.i文件可以作为普通文本文件打开进行查看，其代码片段如下所示：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// hello.i代码片段&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;funlockfile&lt;/span&gt; &lt;span&gt;(FILE *__stream)&lt;/span&gt; __&lt;span&gt;attribute__&lt;/span&gt; &lt;span&gt;((__nothrow__ , __leaf__)&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;# &lt;span&gt;942&lt;/span&gt; &lt;span&gt;&quot;/usr/include/stdio.h&quot;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;# &lt;span&gt;2&lt;/span&gt; &lt;span&gt;&quot;hello.c&quot;&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;# &lt;span&gt;3&lt;/span&gt; &lt;span&gt;&quot;hello.c&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;main(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Hello World!&quot;&lt;/span&gt; &lt;span&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.编译&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译过程就是对预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;使用gcc进行编译的命令如下：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; gcc -S hello.i -o hello.s // 将预处理生成的hello.i文件编译生成汇编程序hello.s&lt;/span&gt;&lt;br/&gt;                        // GCC的选项-S使GCC在执行完编译后停止，生成汇编程序&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;上述命令生成的汇编程序hello.s的代码片段如下所示，其全部为汇编代码。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// hello.s代码片段&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;main:&lt;br/&gt;.LFB0:&lt;br/&gt;    .cfi_startproc&lt;br/&gt;    pushq   %rbp&lt;br/&gt;    .cfi_def_cfa_offset &lt;span&gt;16&lt;/span&gt;&lt;br/&gt;    .cfi_offset &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;-16&lt;/span&gt;&lt;br/&gt;    movq    %rsp, %rbp&lt;br/&gt;    .cfi_def_cfa_register &lt;span&gt;6&lt;/span&gt;&lt;br/&gt;    movl    $.LC0, %edi&lt;br/&gt;    call    &lt;span&gt;puts&lt;/span&gt;&lt;br/&gt;    movl    $&lt;span&gt;0&lt;/span&gt;, %eax&lt;br/&gt;    popq    %rbp&lt;br/&gt;    .cfi_def_cfa &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;br/&gt;    ret&lt;br/&gt;    .cfi_endproc&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;3.汇编&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;汇编过程调用对汇编代码进行处理，生成处理器能识别的指令，保存在后缀为.o的目标文件中。由于每一个汇编语句几乎都对应一条处理器指令，因此，汇编相对于编译过程比较简单，通过调用Binutils中的汇编器as根据汇编指令和处理器指令的对照表一一翻译即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当程序由多个源代码文件构成时，每个文件都要先完成汇编工作，生成.o目标文件后，才能进入下一步的链接工作。注意：目标文件已经是最终程序的某一部分了，但是在链接之前还不能执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用gcc进行汇编的命令如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; gcc -c hello.s -o hello.o // 将编译生成的hello.s文件汇编生成目标文件hello.o&lt;/span&gt;&lt;br/&gt;                        // GCC的选项-c使GCC在执行完汇编后停止，生成目标文件&lt;br/&gt;//或者直接调用as进行汇编&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; as -c hello.s -o hello.o //使用Binutils中的as将hello.s文件汇编生成目标文件&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;注意：hello.o目标文件为ELF（Executable and Linkable Format）格式的可重定向文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.链接&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接也分为静态链接和动态链接，其要点如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。链接器将函数的代码从其所在地（不同的目标文件或静态链接库中）拷贝到最终的可执行程序中。为创建可执行文件，链接器必须要完成的主要任务是：符号解析（把目标文件中符号的定义和引用联系起来）和重定位（把符号定义和内存地址对应起来然后修改所有对符号的引用）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;动态链接则是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在Linux系统中，gcc编译链接时的动态库搜索路径的顺序通常为：首先从gcc命令的参数-L指定的路径寻找；再从环境变量LIBRARY_PATH指定的路径寻址；再从默认路径/lib、/usr/lib、/usr/local/lib寻找。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在Linux系统中，执行二进制文件时的动态库搜索路径的顺序通常为：首先搜索编译目标代码时指定的动态库搜索路径；再从环境变量LD_LIBRARY_PATH指定的路径寻址；再从配置文件/etc/ld.so.conf中指定的动态库搜索路径；再从默认路径/lib、/usr/lib寻找。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在Linux系统中，可以用ldd命令查看一个可执行程序依赖的共享库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于链接动态库和静态库的路径可能有重合，所以如果在路径中有同名的静态库文件和动态库文件，比如libtest.a和libtest.so，gcc链接时默认优先选择动态库，会链接libtest.so，如果要让gcc选择链接libtest.a则可以指定gcc选项-static，该选项会强制使用静态库进行链接。以Hello World为例：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果使用命令“gcc hello.c -o hello”则会使用动态库进行链接，生成的ELF可执行文件的大小（使用Binutils的size命令查看）和链接的动态库（使用Binutils的ldd命令查看）如下所示：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; gcc hello.c -o hello&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; size hello  //使用size查看大小&lt;/span&gt;&lt;br/&gt;   text    data     bss     dec     hex filename&lt;br/&gt;   1183     552       8    1743     6cf     hello&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ldd hello //可以看出该可执行文件链接了很多其他动态库，主要是Linux的glibc动态库&lt;/span&gt;&lt;br/&gt;        linux-vdso.so.1 =&amp;gt;  (0x00007fffefd7c000)&lt;br/&gt;        libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fadcdd82000)&lt;br/&gt;        /lib64/ld-linux-x86-64.so.2 (0x00007fadce14c000)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果使用命令“gcc -static hello.c -o hello”则会使用静态库进行链接，生成的ELF可执行文件的大小（使用Binutils的size命令查看）和链接的动态库（使用Binutils的ldd命令查看）如下所示：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; gcc -static hello.c -o hello&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; size hello //使用size查看大小&lt;/span&gt;&lt;br/&gt;     text    data     bss     dec     hex filename&lt;br/&gt; 823726    7284    6360  837370   cc6fa     hello //可以看出text的代码尺寸变得极大&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ldd hello&lt;/span&gt;&lt;br/&gt;       not a dynamic executable //说明没有链接动态库&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;链接器链接后生成的最终文件为ELF格式可执行文件，一个ELF可执行文件通常被链接为不同的段，常见的段譬如.text、.data、.rodata、.bss等段。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分析ELF文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1.ELF文件的段&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ELF文件格式如下图所示，位于ELF Header和Section Header Table之间的都是段（Section）。一个典型的ELF文件包含下面几个段：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;.text：已编译程序的指令代码段。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;.rodata：ro代表read only，即只读数据（譬如常数const）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;.data：已初始化的C程序全局变量和静态局部变量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;.bss：未初始化的C程序全局变量和静态局部变量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;.debug：调试符号表，调试器用此段的信息帮助调试。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.064&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9sNwsXcN68r9HRG8EDyr4qibWuPueTNaDEEMbDkyrgAZmfibeAvIXib52wSpHdamiaGVOqic8QPqr4WibP58aiaHAuZSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以&lt;/span&gt;&lt;span&gt;使用readelf -S查看其各个section的信息如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; readelf -S hello&lt;/span&gt;&lt;br/&gt;There are 31 section headers, starting at offset 0x19d8:&lt;br/&gt;&lt;br/&gt;Section Headers:&lt;br/&gt;  [Nr] Name              Type             Address           Offset&lt;br/&gt;       Size              EntSize          Flags  Link  Info  Align&lt;br/&gt;  [ 0]                   NULL             0000000000000000  00000000&lt;br/&gt;       0000000000000000  0000000000000000           0     0     0&lt;br/&gt;……&lt;br/&gt;  [11] .init             PROGBITS         00000000004003c8  000003c8&lt;br/&gt;       000000000000001a  0000000000000000  AX       0     0     4&lt;br/&gt;……&lt;br/&gt;  [14] .text             PROGBITS         0000000000400430  00000430&lt;br/&gt;       0000000000000182  0000000000000000  AX       0     0     16&lt;br/&gt;  [15] .fini             PROGBITS         00000000004005b4  000005b4&lt;br/&gt;……&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.反汇编ELF&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于ELF文件无法被当做普通文本文件打开，如果希望直接查看一个ELF文件包含的指令和数据，需要使用反汇编的方法。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;使用objdump -D对其进行反汇编如下：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; objdump -D hello&lt;/span&gt;&lt;br/&gt;……&lt;br/&gt;0000000000400526 &amp;lt;main&amp;gt;:  // main标签的PC地址&lt;br/&gt;//PC地址：指令编码                  指令的汇编格式&lt;br/&gt;  400526:    55                          push   %rbp &lt;br/&gt;  400527:    48 89 e5                mov    %rsp,%rbp&lt;br/&gt;  40052a:    bf c4 05 40 00          mov    $0x4005c4,%edi&lt;br/&gt;  40052f:    e8 cc fe ff ff          callq  400400 &amp;lt;puts@plt&amp;gt;&lt;br/&gt;  400534:    b8 00 00 00 00          mov    $0x0,%eax&lt;br/&gt;  400539:    5d                      pop    %rbp&lt;br/&gt;  40053a:    c3                          retq   &lt;br/&gt;  40053b:    0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)&lt;br/&gt;……&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;使用objdump -S将其反汇编并且将其C语言源代码混合显示出来：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; gcc -o hello -g hello.c //要加上-g选项&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; objdump -S hello&lt;/span&gt;&lt;br/&gt;……&lt;br/&gt;0000000000400526 &amp;lt;main&amp;gt;:&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;int&lt;br/&gt;main(void)&lt;br/&gt;{&lt;br/&gt;  400526:    55                          push   %rbp&lt;br/&gt;  400527:    48 89 e5                mov    %rsp,%rbp&lt;br/&gt;  printf(&quot;Hello World!&quot; &quot;\n&quot;);&lt;br/&gt;  40052a:    bf c4 05 40 00          mov    $0x4005c4,%edi&lt;br/&gt;  40052f:    e8 cc fe ff ff          callq  400400 &amp;lt;puts@plt&amp;gt;&lt;br/&gt;  return 0;&lt;br/&gt;  400534:    b8 00 00 00 00          mov    $0x0,%eax&lt;br/&gt;}&lt;br/&gt;  400539:    5d                          pop    %rbp&lt;br/&gt;  40053a:    c3                          retq   &lt;br/&gt;  40053b:    0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)&lt;br/&gt;&lt;/code&gt;&lt;p&gt;&lt;code&gt;……&lt;/code&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;作&lt;/span&gt;&lt;span&gt;者：仙凌阁&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/qq_39221436/article/details/125638972&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;svg&quot; data-w=&quot;150&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/SQd7RF5caa2sRkiaG4Lib8FHMVW1Ne13lrN37SiaB2ibEDF4OD31Vxh71vWXuOC2VaWME2CltDJsGdA5LnsdhdJianUR3GkoXe1Nx/640?wx_fmt=svg&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;加主页君微信，不仅Linux技能+1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;svg&quot; data-w=&quot;150&quot; class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/SQd7RF5caa2sRkiaG4Lib8FHMVW1Ne13lr4b5vuiaNBnGZKzQI3kAgC4XOZVFnBxvvrXI2GOpiaH06UjrJSc4fqoPBZDKzPVRicCN/640?wx_fmt=svg&quot;/&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8666666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzDNI6O6hCFBc2O6VZiaHtzQn9pYBAmTD9EaEHCDBLkxE8Pln85fKLpIy3sRib8FX0Lzoagbs8TYxC5aAgTubZyw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;主页君日常还会在个人微信分享&lt;span&gt;&lt;strong&gt;Linux相关&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;资源&lt;/strong&gt;&lt;/span&gt;和&lt;strong&gt;精选&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;技术文章&lt;/strong&gt;&lt;/span&gt;，不定期分享一些&lt;span&gt;&lt;strong&gt;有意思的活动&lt;/strong&gt;&lt;/span&gt;、&lt;span&gt;&lt;strong&gt;岗位内推&lt;/strong&gt;&lt;/span&gt;以及&lt;span&gt;&lt;strong&gt;如何用技术做业余项目&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;147&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;147&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb19JTKibRMq2ZEp7XsU1dfgNDoHYFn1ic1ibOHjHFlADWjicibkZgL5XG60vbokfpic28IfLUe3Lj6k2uzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span&gt;加个微信，打开一扇窗&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666564239&amp;amp;idx=2&amp;amp;sn=2b9ffe28f04c90a7619f1cf04d745563&amp;amp;chksm=80dc4e24b7abc73260e9af568ca286f8aea66fd1a0c25ff6b52ec65c795709bbcc5b2f9b880c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Linux 网络基础与性能优化&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Linux 网络基础与性能优化&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666564201&amp;amp;idx=1&amp;amp;sn=c4ac4f36da47b30eade40fe5b37782cc&amp;amp;chksm=80dc4ec2b7abc7d4ea3e6a844ecaafdeeeba5a1f1c4b1d300f214819f50ba5cd1b22c2507cc1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;微软发力 Linux，从红帽挖走 Systemd 作者&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;微软发力 Linux，从红帽挖走 Systemd 作者&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666564129&amp;amp;idx=1&amp;amp;sn=e703957057e3041af120945d13e6f867&amp;amp;chksm=80dc4e8ab7abc79c1a31631d89f5a38f60530d977256459a6cd1483cc83f8000f6fafd471ccf&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Linux 之父发话：Rust 即将出现在 Linux 内核中&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Linux 之父发话：Rust 即将出现在 Linux 内核中&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完&lt;/span&gt;&lt;span&gt;本文有收获？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;推荐关注「Linux 爱好者」，提升Linux技能&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxODI5ODMwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb3sjicd8JxDra10FRIqT54Zke2sfhibTDdtdnVhv5Qh3wLHZmKPjiaD7piahMAzIH6Cnltd1Nco17Ihjw/0?wx_fmt=png&quot; data-nickname=&quot;Linux爱好者&quot; data-alias=&quot;LinuxHub&quot; data-signature=&quot;点击获取《每天一个Linux命令》系列和精选Linux技术资源。「Linux爱好者」日常分享 Linux/Unix 相关内容，包括：工具资源、使用技巧、课程书籍等。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>