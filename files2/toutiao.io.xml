<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4ab691aabc02cf3c54796d7421f0a94a</guid>
<title>面试官：MySQL 数据库查询慢，除了索引问题还可能是什么原因？</title>
<link>https://toutiao.io/k/4ivnhwu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大家好，我是君哥。&lt;/p&gt;&lt;p&gt;mysql查询为什么会慢，关于这个问题，在实际开发经常会遇到，而面试中，也是个高频题。&lt;/p&gt;&lt;p&gt;遇到这种问题，我们一般也会想到是因为索引。&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;那除开索引之外，还有哪些因素会导致数据库查询变慢呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;有哪些操作，可以提升mysql的查询能力呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;今天这篇文章，我们就来聊聊会导致数据库查询变慢的场景有哪些，并给出原因和解决方案。&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;数据库查询流程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们先来看下，一条查询语句下来，会经历哪些流程。&lt;/p&gt;&lt;p&gt;比如我们有一张数据库表&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`user`&lt;/span&gt; (&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;主键&#x27;&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;`name`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;&#x27;&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;名字&#x27;&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;`age`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;0&#x27;&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;年龄&#x27;&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;`gender`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;0&#x27;&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;性别&#x27;&lt;/span&gt;,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  PRIMARY &lt;span&gt;KEY&lt;/span&gt; (&lt;span&gt;`id`&lt;/span&gt;),&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;`idx_age`&lt;/span&gt; (&lt;span&gt;`age`&lt;/span&gt;),&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;`idx_gender`&lt;/span&gt; (&lt;span&gt;`gender`&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=&lt;span&gt;InnoDB&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CHARSET&lt;/span&gt;=utf8;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们平常写的应用代码（go或C++之类的），这时候就叫&lt;strong mpa-from-tpl=&quot;t&quot;&gt;客户端&lt;/strong&gt;了。&lt;/p&gt;&lt;p&gt;客户端底层会带着账号密码，尝试向mysql建立一条TCP长链接。&lt;/p&gt;&lt;p&gt;mysql的&lt;strong mpa-from-tpl=&quot;t&quot;&gt;连接管理模块&lt;/strong&gt;会对这条连接进行管理。&lt;/p&gt;&lt;p&gt;建立连接后，客户端执行一条查询sql语句。比如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; gender = &lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; age = &lt;span&gt;100&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;客户端会将sql语句通过网络连接给mysql。&lt;/p&gt;&lt;p&gt;mysql收到sql语句后，会在&lt;strong mpa-from-tpl=&quot;t&quot;&gt;分析器&lt;/strong&gt;中先判断下SQL语句有没有语法错误，比如select，如果少打一个&lt;code&gt;l&lt;/code&gt;，写成&lt;code&gt;slect&lt;/code&gt;，则会报错&lt;code&gt;You have an error in your SQL syntax;&lt;/code&gt;。这个报错对于我这样的手残党来说可以说是很熟悉了。&lt;/p&gt;&lt;p&gt;接下来是&lt;strong mpa-from-tpl=&quot;t&quot;&gt;优化器&lt;/strong&gt;，在这里会&lt;strong mpa-from-tpl=&quot;t&quot;&gt;根据一定的规则选择该用什么索引&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;之后，才是通过&lt;strong mpa-from-tpl=&quot;t&quot;&gt;执行器&lt;/strong&gt;去调用&lt;strong mpa-from-tpl=&quot;t&quot;&gt;存储引擎&lt;/strong&gt;的接口函数。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK30llfbC5U0KXGEicjeVnLPkiclPicZGzc6G1MsGSrRbSaXBqAbwvTfTtuQ/640&quot; title=&quot;Mysql架构&quot; data-ratio=&quot;1.04&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;Mysql架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;存储引擎&lt;/strong&gt;类似于一个个组件，它们才是mysql真正获取一行行数据并返回数据的地方，存储引擎是可以替换更改的，既可以用不支持事务的MyISAM，也可以替换成支持事务的Innodb。这个可以在建表的时候指定。比如&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`user`&lt;/span&gt; (&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  ...&lt;br mpa-from-tpl=&quot;t&quot;/&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=&lt;span&gt;InnoDB&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在最常用的是&lt;strong mpa-from-tpl=&quot;t&quot;&gt;InnoDB&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;我们就重点说这个。&lt;/p&gt;&lt;p&gt;InnoDB中，因为直接操作磁盘会比较慢，所以加了一层内存提提速，叫&lt;strong mpa-from-tpl=&quot;t&quot;&gt;buffer pool&lt;/strong&gt;，这里面，放了很多内存页，每一页16KB，有些内存页放的是数据库表里看到的那种一行行的数据，有些则是放的索引信息。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK3AicuSMsppX9uxkibXsNicTMzsOeTib1AZTMdmQIUgjXuiavMkPS3b8FMbicg/640&quot; title=&quot;bufferPool与磁盘&quot; data-ratio=&quot;0.7&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;bufferPool与磁盘&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;查询SQL到了InnoDB中。会根据前面优化器里计算得到的索引，去&lt;strong mpa-from-tpl=&quot;t&quot;&gt;查询相应的索引页&lt;/strong&gt;，如果不在buffer pool里则从磁盘里加载索引页。&lt;strong mpa-from-tpl=&quot;t&quot;&gt;再通过索引页加速查询，得到数据页&lt;/strong&gt;的具体位置。如果这些数据页不在buffer pool中，则从磁盘里加载进来。&lt;/p&gt;&lt;p&gt;这样我们就得到了我们想要的一行行数据。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK3j17LhKgzqicwfKNrQjPff37PPhlo4yfR3zvhc2YAO6hgwtyUtG8OYuA/640&quot; title=&quot;索引页与磁盘页的关系&quot; data-ratio=&quot;1&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;索引页与磁盘页的关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;最后将得到的数据结果返回给客户端。&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;慢查询分析&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果上面的流程比较慢的话，我们可以通过开启&lt;code&gt;profiling&lt;/code&gt;看到流程慢在哪。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;set&lt;/span&gt; profiling=&lt;span&gt;ON&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;Query OK, 0 rows affected, 1 warning (0.00 sec)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;mysql&amp;gt; &lt;span&gt;show&lt;/span&gt; &lt;span&gt;variables&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;profiling&#x27;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;---------------+-------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| Variable_name | Value |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;---------------+-------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| profiling     | ON    |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;---------------+-------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后正常执行sql语句。&lt;/p&gt;&lt;p&gt;这些SQL语句的执行时间都会被记录下来，此时你想查看有哪些语句被记录下来了，可以执行 &lt;code&gt;show profiles;&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;show&lt;/span&gt; &lt;span&gt;profiles&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;----------+------------+---------------------------------------------------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| Query_ID | Duration   | Query                                             |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;----------+------------+---------------------------------------------------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;|        1 | 0.06811025 | &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; age&amp;gt;=&lt;span&gt;60&lt;/span&gt;                  |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;|        &lt;span&gt;2&lt;/span&gt; | &lt;span&gt;0.00151375&lt;/span&gt; | &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; gender = &lt;span&gt;2&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; age = &lt;span&gt;80&lt;/span&gt;  |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;|        &lt;span&gt;3&lt;/span&gt; | &lt;span&gt;0.00230425&lt;/span&gt; | &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; gender = &lt;span&gt;2&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; age = &lt;span&gt;60&lt;/span&gt;  |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;|        &lt;span&gt;4&lt;/span&gt; | &lt;span&gt;0.00070400&lt;/span&gt; | &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; gender = &lt;span&gt;2&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; age = &lt;span&gt;100&lt;/span&gt; |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;|        &lt;span&gt;5&lt;/span&gt; | &lt;span&gt;0.07797650&lt;/span&gt; | &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; age!=&lt;span&gt;60&lt;/span&gt;                  |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;----------+------------+---------------------------------------------------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;rows&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; &lt;span&gt;warning&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关注下上面的&lt;code&gt;query_id&lt;/code&gt;，比如&lt;code&gt;select * from user where age&amp;gt;=60&lt;/code&gt;对应的query_id是1，如果你想查看这条SQL语句的具体耗时，那么可以执行以下的命令。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;show&lt;/span&gt; profile &lt;span&gt;for&lt;/span&gt; &lt;span&gt;query&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;----------------------+----------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| Status               | Duration |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;----------------------+----------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| starting             | 0.000074 |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| checking permissions | 0.000010 |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| Opening tables       | 0.000034 |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| init                 | 0.000032 |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| System &lt;span&gt;lock&lt;/span&gt;          | &lt;span&gt;0.000027&lt;/span&gt; |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| optimizing           | &lt;span&gt;0.000020&lt;/span&gt; |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| &lt;span&gt;statistics&lt;/span&gt;           | &lt;span&gt;0.000058&lt;/span&gt; |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| preparing            | &lt;span&gt;0.000018&lt;/span&gt; |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| executing            | &lt;span&gt;0.000013&lt;/span&gt; |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| Sending &lt;span&gt;data&lt;/span&gt;         | &lt;span&gt;0.067701&lt;/span&gt; |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| &lt;span&gt;end&lt;/span&gt;                  | &lt;span&gt;0.000021&lt;/span&gt; |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| &lt;span&gt;query&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;            | &lt;span&gt;0.000015&lt;/span&gt; |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| closing &lt;span&gt;tables&lt;/span&gt;       | &lt;span&gt;0.000014&lt;/span&gt; |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| freeing items        | &lt;span&gt;0.000047&lt;/span&gt; |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| cleaning up          | &lt;span&gt;0.000027&lt;/span&gt; |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;----------------------+----------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;rows&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; &lt;span&gt;warning&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过上面的各个项，大家就可以看到具体耗时在哪。比如从上面可以看出Sending data的耗时最大，这个是指&lt;strong mpa-from-tpl=&quot;t&quot;&gt;执行器&lt;/strong&gt;开始查询数据并将数据发送给客户端的耗时，因为我的这张表符合条件的数据有&lt;strong mpa-from-tpl=&quot;t&quot;&gt;好几万条&lt;/strong&gt;，所以这块耗时最大，也符合预期。&lt;/p&gt;&lt;p&gt;一般情况下，我们开发过程中，耗时大部分时候都在&lt;code&gt;Sending data&lt;/code&gt;阶段，而这一阶段里如果慢的话，最容易想到的还是索引相关的原因。&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;索引相关原因&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;索引相关的问题，一般能用explain命令帮助分析。通过它能看到&lt;strong mpa-from-tpl=&quot;t&quot;&gt;用了哪些索引&lt;/strong&gt;，大概会&lt;strong mpa-from-tpl=&quot;t&quot;&gt;扫描多少行&lt;/strong&gt;之类的信息。&lt;/p&gt;&lt;p&gt;mysql会在&lt;strong mpa-from-tpl=&quot;t&quot;&gt;优化器阶段&lt;/strong&gt;里看下选择哪个索引，查询速度会更快。&lt;/p&gt;&lt;p&gt;一般主要考虑几个因素，比如：&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;回到show profile中提到的sql语句，我们使用&lt;code&gt;explain select * from user where age&amp;gt;=60&lt;/code&gt; 分析一下。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14907407407407408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK384CyKs22B0E3ORxicOAnq0mFeFaCENC3HSo4HvwGnVdREZWCh9Gfib0g/640&quot; data-w=&quot;1080&quot; title=&quot;explain sql&quot;/&gt;&lt;figcaption&gt;explain sql&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;上面的这条语句，使用的&lt;code&gt;type&lt;/code&gt;为ALL，意味着是&lt;strong mpa-from-tpl=&quot;t&quot;&gt;全表扫描&lt;/strong&gt;，&lt;code&gt;possible_keys&lt;/code&gt;是指&lt;strong mpa-from-tpl=&quot;t&quot;&gt;可能用得到的索引&lt;/strong&gt;，这里可能使用到的索引是为age建的普通索引，但实际上数据库使用的索引是在&lt;code&gt;key&lt;/code&gt;那一列，是&lt;code&gt;NULL&lt;/code&gt;。也就是说&lt;strong mpa-from-tpl=&quot;t&quot;&gt;这句sql不走索引，全表扫描&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;这个是因为数据表里，符合条件的数据行数（&lt;code&gt;rows&lt;/code&gt;）太多，如果使用age索引，那么需要将它们从age索引中读出来，并且age索引是&lt;strong mpa-from-tpl=&quot;t&quot;&gt;普通索引&lt;/strong&gt;，还需要&lt;strong mpa-from-tpl=&quot;t&quot;&gt;回表&lt;/strong&gt;找到对应的&lt;strong mpa-from-tpl=&quot;t&quot;&gt;主键&lt;/strong&gt;才能找到对应的&lt;strong mpa-from-tpl=&quot;t&quot;&gt;数据页&lt;/strong&gt;。算下来还不如直接走主键划算。于是最终选择了全表扫描。&lt;/p&gt;&lt;p&gt;当然上面只是举了个例子，实际上，mysql执行sql时，&lt;strong mpa-from-tpl=&quot;t&quot;&gt;不用索引或者用的索引不符合我们预期&lt;/strong&gt;这件事经常发生，索引失效的场景有很多，比如用了&lt;strong mpa-from-tpl=&quot;t&quot;&gt;不等号，隐式转换&lt;/strong&gt;等，这个相信大家背八股文的时候也背过不少了，我也不再赘述。&lt;/p&gt;&lt;p&gt;聊两个生产中容易遇到的问题吧。&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;索引不符合预期&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;实际开发中有些情况比较特殊，比如有些数据库表一开始数据量小，索引少，执行sql时，确实使用了符合你预期的索引。但随时时间边长，开发的人变多了，数据量也变大了，甚至还可能会加入一些其他重复多余的索引，就有可能出现用着用着，用到了不符合你预期的其他索引了。从而导致查询突然变慢。&lt;/p&gt;&lt;p&gt;这种问题，也好解决，可以通过&lt;code&gt;force index&lt;/code&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;指定索引&lt;/strong&gt;。比如&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK3hlL9hzg416jtwRJAlWhZEUZ5oM9tRRicibeHiauTg4PZTtflJnszUwepg/640&quot; title=&quot;force index指定索引&quot; data-ratio=&quot;0.14074074074074075&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;force index指定索引&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;通过&lt;code&gt;explain&lt;/code&gt;可以看出，加了force index之后，sql就选用了idx_age这个索引了。&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;走了索引还是很慢&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;有些sql，用&lt;code&gt;explain&lt;/code&gt;命令看，明明是走索引的，但还是很慢。一般是两种情况：&lt;/p&gt;&lt;p&gt;第一种是索引区分度太低，比如网页全路径的url链接，这拿来做索引，一眼看过去全都是同一个域名，如果&lt;strong mpa-from-tpl=&quot;t&quot;&gt;前缀索引&lt;/strong&gt;的长度建得不够长，那这走索引跟走&lt;strong mpa-from-tpl=&quot;t&quot;&gt;全表扫描&lt;/strong&gt;似的，正确姿势是尽量让索引的&lt;strong mpa-from-tpl=&quot;t&quot;&gt;区分度&lt;/strong&gt;更高，比如域名去掉，只拿后面URI部分去做索引。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK3EzMC7fictT9d9s3uBMja0BsPrueIuOLmeagruypRS6w9GduFwFhOPkA/640&quot; title=&quot;索引前缀区分度太低&quot; data-ratio=&quot;0.5&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;索引前缀区分度太低&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;第二种是索引中匹配到的数据太大，这时候需要关注的是explain里的&lt;strong mpa-from-tpl=&quot;t&quot;&gt;rows&lt;/strong&gt;字段了。&lt;/p&gt;&lt;p&gt;它是用于&lt;strong mpa-from-tpl=&quot;t&quot;&gt;预估&lt;/strong&gt;这个查询语句需要查的行数的，它不一定完全准确，但可以体现个大概量级。&lt;/p&gt;&lt;p&gt;当它很大时，一般常见的是下面几种情况。&lt;/p&gt;&lt;ul mpa-from-tpl=&quot;t&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;如果这个字段具有&lt;strong mpa-from-tpl=&quot;t&quot;&gt;唯一&lt;/strong&gt;的属性，比如电话号码等，一般是不应该有大量重复的，那可能是你代码逻辑出现了&lt;strong mpa-from-tpl=&quot;t&quot;&gt;大量重复插入&lt;/strong&gt;的操作，你需要检查下代码逻辑，或者需要加个&lt;strong mpa-from-tpl=&quot;t&quot;&gt;唯一索引&lt;/strong&gt;限制下。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果这个字段下的数据就是会很大，是否需要全部拿？如果不需要，加个&lt;code&gt;limit&lt;/code&gt;限制下。如果确实要拿全部，那也不能一次性全拿，今天你数据量小，可能一次取一两万都没啥压力，万一哪天涨到了十万级别，那一次性取就有点吃不消了。你可能需要&lt;strong mpa-from-tpl=&quot;t&quot;&gt;分批次取&lt;/strong&gt;，具体操作是先用&lt;code&gt;order by id&lt;/code&gt;排序一下，拿到一批数据后取&lt;code&gt;最大id&lt;/code&gt;作为下次取数据的起始位置。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;连接数过小&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;索引相关的原因我们聊完了，我们来聊聊，&lt;strong mpa-from-tpl=&quot;t&quot;&gt;除了索引之外，还有哪些因素会限制我们的查询速度的。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们可以看到，mysql的server层里有个&lt;strong mpa-from-tpl=&quot;t&quot;&gt;连接管理&lt;/strong&gt;，它的作用是管理客户端和mysql之间的长连接。&lt;/p&gt;&lt;p&gt;正常情况下，客户端与server层如果只有&lt;strong mpa-from-tpl=&quot;t&quot;&gt;一条&lt;/strong&gt;连接，那么在执行sql查询之后，只能阻塞等待结果返回，如果有大量查询同时并发请求，那么&lt;strong mpa-from-tpl=&quot;t&quot;&gt;后面的请求都需要等待前面的请求执行完成&lt;/strong&gt;后，才能开始执行。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK3c9WU7FyGe4jzn3caJWMOJPWOSPWGE6bp3TyV88ow9swXTlSFdCoczg/640&quot; data-w=&quot;1080&quot; title=&quot;连接过少会导致sql阻塞&quot;/&gt;&lt;figcaption&gt;连接过少会导致sql阻塞&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;因此很多时候我们的应用程序，比如go或java这些，&lt;strong mpa-from-tpl=&quot;t&quot;&gt;会打印出sql执行了几分钟的日志，但实际上你把这条语句单独拎出来执行，却又是毫秒级别的。&lt;/strong&gt;这都是因为这些sql语句在&lt;strong mpa-from-tpl=&quot;t&quot;&gt;等待&lt;/strong&gt;前面的sql执行完成。&lt;/p&gt;&lt;p&gt;怎么解决呢？&lt;/p&gt;&lt;p&gt;如果我们能&lt;strong mpa-from-tpl=&quot;t&quot;&gt;多建几条连接&lt;/strong&gt;，那么请求就可以并发执行，后面的连接就不用等那么久了。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43796296296296294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK36d77KUv53ibMkSkLg1b2El8qjdg0taeW2NiaLVbwvPbdNYuBzVyaIX6w/640&quot; data-w=&quot;1080&quot; title=&quot;增加连接可以加快执行sql&quot;/&gt;&lt;figcaption&gt;增加连接可以加快执行sql&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;而连接数过小的问题，&lt;strong mpa-from-tpl=&quot;t&quot;&gt;受数据库和客户端两侧同时限制&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;数据库连接数过小&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;Mysql的最大连接数默认是&lt;code&gt;100&lt;/code&gt;, 最大可以达到&lt;code&gt;16384&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;可以通过设置mysql的&lt;code&gt;max_connections&lt;/code&gt;参数，更改数据库的最大连接数。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; max_connections= &lt;span&gt;500&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;Query OK, 0 rows affected (0.00 sec)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;mysql&amp;gt; &lt;span&gt;show&lt;/span&gt; &lt;span&gt;variables&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;max_connections&#x27;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;-----------------+-------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| Variable_name   | Value |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;-----------------+-------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| max_connections | 500   |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;-----------------+-------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的操作，就把最大连接数改成了500。&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;应用侧连接数过小&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;数据库连接大小是调整过了，但貌似问题还是没有变化？还是有很多sql执行达到了几分钟，甚至超时？&lt;/p&gt;&lt;p&gt;那有可能是因为你应用侧（go，java写的应用，也就是mysql的客户端）的连接数也过小。&lt;/p&gt;&lt;p&gt;应用侧与mysql底层的连接，是&lt;strong mpa-from-tpl=&quot;t&quot;&gt;基于TCP协议的长链接&lt;/strong&gt;，而TCP协议，需要经过&lt;strong mpa-from-tpl=&quot;t&quot;&gt;三次握手和四次挥手&lt;/strong&gt;来实现建连和释放。如果我每次执行sql都重新建立一个新的连接的话，那就要不断握手和挥手，这很&lt;strong mpa-from-tpl=&quot;t&quot;&gt;耗时&lt;/strong&gt;。所以一般会建立一个&lt;strong mpa-from-tpl=&quot;t&quot;&gt;长连接池&lt;/strong&gt;，连接用完之后，塞到连接池里，下次要执行sql的时候，再从里面捞一条连接出来用，非常环保。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK3HLmE3tERpYBAzmzgpy93vn33lxBycGUgg0mZsOe5nmZTV7tluToXCw/640&quot; data-w=&quot;1080&quot; title=&quot;连接池原理&quot;/&gt;&lt;figcaption&gt;连接池原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们一般写代码的时候，都会通过第三方的&lt;strong mpa-from-tpl=&quot;t&quot;&gt;orm库&lt;/strong&gt;来对数据库进行操作，而成熟的orm库，&lt;strong mpa-from-tpl=&quot;t&quot;&gt;百分之一千万都会有个连接池。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;而这个连接池，一般会有个大小。这个大小就控制了你的连接数最大值，如果说你的连接池太小，都还没有数据库的大，那调了数据库的最大连接数也没啥作用。&lt;/p&gt;&lt;p&gt;一般情况下，可以翻下你使用的orm库的文档，看下怎么设置这个连接池的大小，就几行代码的事情，改改就好。比如go语言里的&lt;code&gt;gorm&lt;/code&gt;里是这么设置的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  db, err := gorm.Open(mysql.Open(conn), config)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    sqlDB, err := db.DB()&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// SetMaxIdleConns 设置空闲连接池中连接的最大数量&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    sqlDB.SetMaxIdleConns(&lt;span&gt;200&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// SetMaxOpenConns 设置打开数据库连接的最大数量&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    sqlDB.SetMaxOpenConns(&lt;span&gt;1000&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;buffer pool太小&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;连接数是上去了，速度也提升了。&lt;/p&gt;&lt;p&gt;曾经遇到过面试官会追问，&lt;strong mpa-from-tpl=&quot;t&quot;&gt;有没有其他办法可以让速度更快呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;那必须要眉头紧锁，假装思考，然后说：&lt;strong mpa-from-tpl=&quot;t&quot;&gt;有的&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;我们在前面的数据库查询流程里，提到了进了innodb之后，会有一层内存buffer pool，用于将磁盘数据页加载到内存页中，只要查询到buffer pool里有，就可以直接返回，否则就要走磁盘IO，那就慢了。&lt;/p&gt;&lt;p&gt;也就是说，&lt;strong mpa-from-tpl=&quot;t&quot;&gt;如果我的buffer pool 越大，那我们能放的数据页就越多，相应的，sql查询时就更可能命中buffer pool，那查询速度自然就更快了。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;可以通过下面的命令查询到buffer pool的大小，单位是&lt;code&gt;Byte&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;show&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; &lt;span&gt;variables&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;innodb_buffer_pool_size&#x27;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;-------------------------+-----------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| Variable_name           | Value     |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;-------------------------+-----------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| innodb_buffer_pool_size | 134217728 |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;-------------------------+-----------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.01&lt;/span&gt; sec)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是&lt;code&gt;128Mb&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果想要调大一点。可以执行&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; innodb_buffer_pool_size = &lt;span&gt;536870912&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;Query OK, 0 rows affected (0.01 sec)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;mysql&amp;gt; &lt;span&gt;show&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; &lt;span&gt;variables&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;innodb_buffer_pool_size&#x27;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;-------------------------+-----------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| Variable_name           | Value     |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;-------------------------+-----------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;| innodb_buffer_pool_size | 536870912 |&lt;br mpa-from-tpl=&quot;t&quot;/&gt;+&lt;span&gt;-------------------------+-----------+&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.01&lt;/span&gt; sec)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就把buffer pool增大到512Mb了。&lt;/p&gt;&lt;p&gt;但是吧，如果buffer pool大小正常，只是&lt;strong mpa-from-tpl=&quot;t&quot;&gt;别的原因&lt;/strong&gt;导致的查询变慢，那改buffer pool毫无意义。&lt;/p&gt;&lt;p&gt;但问题又来了。&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;怎么知道buffer pool是不是太小了？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;这个我们可以看&lt;strong mpa-from-tpl=&quot;t&quot;&gt;buffer pool的缓存命中率&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK398LGqItZKn636v7utoQ0pHkksTErGQqzfoBIrwXxibLxSH27WNxRkEA/640&quot; title=&quot;查看buffer pool命中率&quot; data-ratio=&quot;0.5694444444444444&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;查看buffer pool命中率&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;通过 &lt;code&gt;show status like &#x27;Innodb_buffer_pool_%&#x27;;&lt;/code&gt;可以看到跟buffer pool有关的一些信息。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Innodb_buffer_pool_read_requests&lt;/code&gt;表示读请求的次数。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Innodb_buffer_pool_reads&lt;/code&gt; 表示从物理磁盘中读取数据的请求次数。&lt;/p&gt;&lt;p&gt;所以buffer pool的命中率就可以这样得到：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;buffer pool 命中率 = 1 - (Innodb_buffer_pool_reads/Innodb_buffer_pool_read_requests) * 100%&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如我上面截图里的就是，1 - (405/2278354) = 99.98%。可以说命中率非常高了。&lt;/p&gt;&lt;p&gt;一般情况下&lt;strong mpa-from-tpl=&quot;t&quot;&gt;buffer pool命中率&lt;/strong&gt;都在&lt;code&gt;99%&lt;/code&gt;以上，如果低于这个值，才需要考虑加大innodb buffer pool的大小。&lt;/p&gt;&lt;p&gt;当然，还可以把这个命中率做到&lt;strong mpa-from-tpl=&quot;t&quot;&gt;监控&lt;/strong&gt;里，这样半夜sql变慢了，早上上班还能定位到原因，就很舒服。&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;还有哪些骚操作？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;前面提到的是在&lt;strong mpa-from-tpl=&quot;t&quot;&gt;存储引擎层&lt;/strong&gt;里加入了buffer pool用于缓存内存页，这样可以加速查询。&lt;/p&gt;&lt;p&gt;那同样的道理，&lt;strong mpa-from-tpl=&quot;t&quot;&gt;server层&lt;/strong&gt;也可以加个缓存，直接将第一次查询的结果缓存下来，这样&lt;strong mpa-from-tpl=&quot;t&quot;&gt;下次&lt;/strong&gt;查询就能立刻返回，听着挺美的。&lt;/p&gt;&lt;p&gt;按道理，如果命中缓存的话，确实是能为查询加速的。但这个功能限制很大，其中最大的问题是只要数据库表被更新过，表里面的&lt;strong mpa-from-tpl=&quot;t&quot;&gt;所有缓存都会失效&lt;/strong&gt;，数据表频繁的更新，就会带来频繁的缓存失效。所以这个功能只适合用于那些&lt;strong mpa-from-tpl=&quot;t&quot;&gt;不怎么更新的数据表。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;另外，这个功能在&lt;code&gt;8.0版本&lt;/code&gt;之后，就被&lt;strong mpa-from-tpl=&quot;t&quot;&gt;干掉&lt;/strong&gt;了。所以这功能用来聊聊天可以，没必要真的在生产中使用啊。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.762962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK3X3iag9tDib7wYsNkuOov5bX3sQWjBpZu1wGvbhlIu8j9aGxsic7GE2iapw/640&quot; data-w=&quot;1080&quot; title=&quot;查询缓存被删除&quot;/&gt;&lt;figcaption&gt;查询缓存被删除&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;ul mpa-from-tpl=&quot;t&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据查询过慢一般是索引问题，可能是因为选错索引，也可能是因为查询的行数太多。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;客户端和数据库连接数过小，会限制sql的查询并发数，增大连接数可以提升速度。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;innodb里会有一层内存buffer pool用于提升查询速度，命中率一般&amp;gt;99%，如果低于这个值，可以考虑增大buffer pool的大小，这样也可以提升速度。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查询缓存（query cache）确实能为查询提速，但一般不建议打开，因为限制比较大，并且8.0以后的Mysql里已经将这个功能干掉了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。&lt;/p&gt;&lt;p&gt;我有个不成熟的请求。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9937106918238994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK3d7A7sOTkHicgIBKubWIlvw32XxDvxajXTB5g59T1akeukibVJoAiclFFQ/640&quot; data-w=&quot;318&quot; title=&quot;&quot;/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;能帮我点下右下角的&lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;点赞和在看&lt;/strong&gt;&lt;span&gt;吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;点击&lt;/strong&gt;下方名片，关注公众号:【小白debug】&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5NDY2MDk4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianpibeb1icaNfMQWI9DibKw3EcA2nvqMtwQ1GuX5bFuupzh6LaH1AkOZggtabj6t0mXvgIGibhwUYCz4w/0?wx_fmt=png&quot; data-nickname=&quot;小白debug&quot; data-alias=&quot;xiaobaidebug&quot; data-signature=&quot;答应我，关注之后，好好学技术，别只是收藏我的表情包。。&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;figure&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。&lt;/span&gt;&lt;span&gt;就&lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;超！开！心！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img align=&quot;center&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9249512670565302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianbibkNQ7b3dWIYFDypVnpK3mx3mvopcQE1KOgSCDoMyqOnQeTalVLFz0TNRH8mYiboSupu4cWMmlxQ/640&quot; data-w=&quot;1026&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;文章推荐：&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>be1378eabcaa888b18a40c9894cc014e</guid>
<title>也许是最客观、全面的比较 Rust 与 Go：都想把 Rust 也学一下</title>
<link>https://toutiao.io/k/2u61cx8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;最近一年，将 Rust 和 Go 进行比较的不少，但不少都不公正，带感情色彩。而这篇文章客观、全面的分析对比了 Rust 和 Go，让你具体项目时选择最合适的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 还是 Go，哪个更好？你应该为下一个项目选择哪种语言，为什么？两者在性能，简单性，安全性，功能，规模和并发性等方面如何比较？它们有什么共同点，并且在根本上有何不同？来自 &lt;span&gt;For the Go of Love&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 系列图书的作者，友好而公正的比较 Rust 和 Golang。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Rust 和 Go 都很棒&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，非常重要的一点是，Go 和 Rust 都是绝对优秀的编程语言。它们是现代的，强大的，被广泛采用的，并且具有出色的性能。你可能已经阅读了一些文章和博客文章，目的是说服 Go 比 Rust 更好，反之亦然。但这确实没有道理；每种编程语言都代表一组权衡。每种语言针对不同的事物进行了优化，因此，应根据适合你的语言以及你要解决的问题来确定语言的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中，我将简要概述我认为 Go 是理想的选择，以及我认为 Rust 是更好的选择的地方。不过，理想情况下，你应该对这两种语言都有一定的了解。尽管它们的语法和样式差异很大，但 Rust 和 Go 都是用于构建软件的一流工具。话虽如此，让我们仔细看看这两种语言。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;相似之处&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 和 Go 有很多共同点，这是你经常听到他们一起被提及的原因之一。两种语言的共同目标是什么？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Rust 是一种专注于安全性和性能的低级静态类型多范式编程语言。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Gints Dreimanis&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Go 是一种开放源代码编程语言，可轻松构建简单，可靠和高效的软件。—&lt;span&gt;Golang.org&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内存安全&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 和 Rust 都属于优先考虑内存安全性的现代编程语言。数十年来，使用 C 和 C++ 等较旧的语言已经很清楚，导致错误和安全漏洞的最大原因之一是不安全或不正确地访问内存。Rust 和 Go 以不同的方式处理此问题，但是两者的目的都是要比其他有关内存管理的语言更聪明，更安全，并帮助你编写正确且性能良好的程序。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快速，紧凑的可执行文件&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们都是编译语言，这意味着你的程序直接转换为可执行的机器代码，因此你可以将程序作为单个二进制文件进行部署；与 Python 和 Ruby 等解释型语言不同，你无需随程序一起分发解释器，大量库和依赖项，这是一大优势。与解释型语言相比，这也使 Rust 和 Go 程序都非常快。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通用语言&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 和 Go 都是功能强大，可扩展的通用编程语言，你可以使用它们来开发各种现代软件，从Web应用程序到分布式微服务，或者从嵌入式微控制器到移动应用程序。两者都具有出色的标准库和蓬勃发展的第三方生态系统，以及强大的商业支持和庞大的用户群。它们都已经存在了很多年，并将在未来几年继续被广泛使用。今天学习 Go 或 Rust 将是你的时间和精力的明智投资。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;务实（Pragmatic）的编程风格&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种语言都不是纯函数式语言（例如 Scala 或 Elixir），也不是全面面向对象的语言（例如 Java 和 C#）。相反，尽管 Go 和 Rust 都具有与函数和面向对象的编程相关的功能，但它们都是务实的语言，旨在以最合适的方式解决问题，而不是强迫你采用特定的处理方式。（不过，如果你喜欢函数式编程风格，则在 Rust 中会发现更多的函数式特性，因为 Rust 的函数式功能比 Go 多得多。）&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们可以讨论什么是“面向对象”语言，但是公平地说，Go 或 Rust 中都没有 C++，Java 或 C# 用户期望的面向对象编程风格。—Jack Mott&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大规模发展&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 和 Go 都具有一些有用的特性，这使其适合于大型编程，包括大型团队，大型代码库，或两者兼而有之。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，尽管 C 程序员多年来一直在争论括号的位置，以及是否应使用制表符或空格使代码缩进，但 Rust 和 Go 都通过使用标准格式工具（gofmt 用于 Go  ，rustfmt 用于 Rust）完全消除了此类问题。它使用规范样式自动格式化你的代码。并不是说这种特殊的样式本身如此出色：而是 Rust 和 Go 程序员所欣赏的标准化。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;gofmt 的风格不是每个人的最爱，但 gofmt 是每个人的最爱。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Rob Pike&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种语言得分很高的另一个领域是构建管道（build pipeline）。两者都具有出色的内置高性能标准构建和依赖管理工具。不再需要为复杂的第三方构建系统而费力，也不必每两年学习一次新的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在我早期的职业生涯中，具有 Java 和 Ruby 背景的 Go 和 Rust 代码构建工作似乎使我无法承受。当我在 Google 时，遇到用 Go 编写的服务感到很欣慰，因为我知道它易于构建和运行。Rust 的情况也是如此，尽管我只是在较小的规模上进行了研究。我希望无限可配置的构建系统的日子已经一去不复返了，所有语言都附带了它们自己专用的构建工具，这些工具可以直接使用。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Sam Rose&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;那有什么大惊小怪的？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到所有这些，并且看到这两种语言的设计和功能如此强大，你可能想知道所有的圣战是关于什么的（我也是）。人们为什么对 “Go vs Rust” 如此大惊小怪，陷入愤怒的社交媒体争吵中，并写了很长的博客文章，内容涉及只有白痴才会使用Rust，或者 Go 不是真正的编程语言等等。它可能会让他们感觉更好，但对于试图决定要为项目使用哪种语言的人，或者应该学习哪种语言来促进编程事业的人，这并不能完全为你提供帮助。明智的人不会根据谁喊得最多而做出重要的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，让我们继续探讨一些成年人在某些方面可能会比较喜欢一种语言而不是另一种语言的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;性能&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经说过，Go 和 Rust 都能生成非常快的程序，因为它们被编译为本机代码，而无需通过解释器或虚拟机。但是，Rust 的性能特别出色，它可与 C 和 C++ 相媲美（C/C++ 通常被认为是性能最高的编译语言），但与这些较旧的语言不同，它还提供了内存安全性和并发安全性，而执行速度却基本没有任何成本。Rust 还允许你创建复杂的抽象，而无需在运行时付出性能损失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比之下，尽管 Go 程序的性能也非常好，但是 Go 的主要目的是提高开发速度（包括编译），而不是提高执行速度。Go 编译器不会花费很多时间来尝试生成尽可能高效的机器代码；它更关心快速编译大量代码。因此，Rust 通常会在运行时基准测试中击败 Go。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 的运行时性能也始终如一且可预测，因为它不使用垃圾回收。Go 的垃圾收集器非常高效，并且经过优化，可以使其 STW 的时间尽可能短（并且在每个新的 Go 版本中都变得更短）。但是垃圾回收不可避免地在程序的行为方式中引入了一些不可预测性，这在某些应用程序（例如嵌入式系统）中可能是一个严重的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Rust 旨在使程序员能够完全控制底层硬件，因此有可能将 Rust 程序优化为非常接近机器的最大理论性能。对于执行速度超过所有其他考虑因素的领域（例如游戏编程，操作系统内核，Web 浏览器组件和实时控制系统），Rust 使其成为绝佳的选择。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简单&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有人能弄清楚如何使用它，那么编程语言有多快也没关系。Go 被故意认为是对 C++ 等语言不断增长的复杂性的一种反应。它的语法很少，关键字也不多，而且功能也很少。这意味着学习 Go 语言并不需要很长时间，你可以在其中编写有用的程序。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Go 非常容易学习。我知道这是一个经常被吹捧的好处，但是我对能够这么快地提高生产力感到非常惊讶。多亏了语言，文档和工具，我实际上在两天之后就编写了有趣的，可提交的代码。— &lt;span&gt;Rust 程序员对 Go 的早期印象&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的关键词是简单。当然，简单（simple）与容易（easy）并不相同，但是简单的小型语言比复杂的大型语言更容易学习。要做的事情没有太多不同的方式，因此所有编写良好的 Go 代码看起来都一样。深入研究不熟悉的服务并了解其功能很容易。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fmt.Println(&lt;span&gt;&quot;Gopher&#x27;s Diner Breakfast Menu&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; dish, price := &lt;span&gt;range&lt;/span&gt; menu {&lt;br/&gt;    fmt.Println(dish, price)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管核心语言很小，但 Go 的标准库功能非常强大。这意味着你的学习曲线还需要包括所需的标准库部分，而不仅仅是Go语法。另一方面，将功能从语言中移出并移入标准库意味着你现在可以专注于仅学习与你相关的库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 还被设计用于具有大型代码库和大型团队的大规模软件开发。在这种情况下，重要的是，新开发人员必须尽快上手。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用 Go，你可以快速完成工作。Go 是我使用过的最具生产力的语言之一。口头禅是：解决今天的实际问题。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Matthias Endler&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;特性&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;与其他几种编程语言相比，Rust 支持更多的复杂特性，因此，你可以用它实现更多的功能。例如，它支持泛型。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Devathon&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 专门设计为包含许多强大而有用的功能，以帮助程序员以最少的代码完成最多的工作。例如，Rust 的 match 功能使你可以非常简洁地编写灵活的表达逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;is_prime&lt;/span&gt;&lt;/span&gt;(n: &lt;span&gt;u64&lt;/span&gt;) -&amp;gt; &lt;span&gt;bool&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;match&lt;/span&gt; n {&lt;br/&gt;        &lt;span&gt;0&lt;/span&gt;...&lt;span&gt;1&lt;/span&gt; =&amp;gt; &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;        _ =&amp;gt; !(&lt;span&gt;2&lt;/span&gt;..n).any(|d| n % d == &lt;span&gt;0&lt;/span&gt;),&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Rust 的功能很多，这意味着有很多东西要学习，尤其是在一开始的时候。但这没关系：在 C++ 或 Java 中也有很多东西要学习，而且你没有获得 Rust 附带的高级功能，例如内存安全性。批评 Rust 是一种复杂的语言，没有抓住重点：它被设计成具有表现力，这意味着具有许多功能，并且在许多情况下，这是编程语言所需要的。当然，这是一条学习曲线，但是一旦你开始使用它，就可以了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Rust 为准备接受更复杂的语法和语义（可能会带来更高的可读性成本）以换取最大可能的性能的程序员，与 C++ 和 D 竞争思想共享。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Dave Cheney&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并发&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数语言都对并发编程提供某种形式的支持（一次执行多项操作），但是 Go 是专为这项工作而设计的。Go 不使用操作系统线程，而是提供了一种轻量级的替代方案：goroutines。每个 goroutine 是一个独立执行的 Go 函数，Go 调度程序会将其映射到其控制下的 OS 线程之一。这意味着调度程序仅使用有限数量的 OS 线程即可非常有效地管理大量并发的goroutine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，你可以在一个程序中运行数百万个并发 goroutine，而不会造成严重的性能问题。这使 Go 成为 Web 服务器和微服务等大规模并发应用程序的理想选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 还提供了快速，安全，有效的方式，goroutine 使用 channel 进行通信和共享数据。Go 的并发支持设计良好，使用起来很愉快。通常很难对并发程序进行推理，而构建可靠，正确的并发程序对任何语言都是一个挑战。但是，由于它是从一开始就内置在语言中的，而不是事后才想到的，Go 中的并发编程简单、合理、良好的集成进语言中。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Go 使构建易于分解的应用程序变得非常容易，该应用程序在作为一组微服务部署时充分利用了并发性。Rust 也可以做这些事情，但是可以说有点困难。从某些方面来说，Rust 对防止与内存相关的安全漏洞的痴迷意味着程序员必须竭尽全力来执行使用其他语言（包括 Go）更简单的任务。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Sonya Koptyev&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比之下，Rust 中的并发是一个很新的特性，并且还有待稳定中，但是它的发展非常活跃，因此请留意这块。例如，Rust 的 &lt;span&gt;rayon&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt; 提供了一种非常优雅且轻巧的方法，可以将顺序计算转换为并行计算。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;具有轻量级 Goroutine 和 Channel 语法确实很棒。它确实显示出语法的威力，即如此小的细节使并发编程比其他语言感觉更好。— &lt;span&gt;Rust 程序员对 Go 的早期印象&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在 Rust 中实现并发程序可能会不太直接，但仍然可以实现，并且这些程序可以利用 Rust 的安全保证。标准库的 Mutex 类就是一个很好的例子：在 Go 中，你可以忘记在访问某些东西之前先获得一个互斥锁，但是 Rust 不允许你这样做。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Go 将并发作为第一类概念。这并不是说你无法在 Rust 中找到类似 Go 的并发方式，而是留给程序员练习。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Dave Cheney&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安全性&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们已经看到，Go 和 Rust 都以不同的方式来防止与内存管理有关的大量常见编程错误。但是，尤其是 Rust 会竭尽全力确保你不会做本不该做的不安全的事情。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Rust 的程序编辑器非常严格且学究（pedantic），它会检查你使用的每个变量以及引用的每个内存地址。它避免了可能的数据争用情况，并通知你有关未定义行为的信息。从根本上讲，并发和内存安全问题根本不可能进入Rust的安全子集。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Why Rust?&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这会使 Rust 中的编程成为几乎所有其他语言的不同体验，而且一开始可能具有挑战性。但对很多人来说，努力工作是值得的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对我来说，Rust 的主要优点是感觉编译器成为我的靠山，不会让任何错误漏出（有时感觉像魔术）。&lt;em&gt;—Grzegorz Nosek&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包括 Go 在内的许多语言都具有帮助程序员避免错误的功能，但是 Rust 将其提升到了一个新的高度，因此潜在的错误程序甚至无法编译。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用 Rust，库程序员可以使用很多工具来防止用户犯错误。Rust 使我们能够说我们拥有特定的数据。其他任何人都不可能拥有所有权，因此我们知道其他任何人都无法对其进行修改。我想不到曾经有过这么多工具来防止意外滥用。真是太好了。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Sam Rose&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于新手 Rust 程序员来说，“与借阅检查器（borrow checker）打架”是一个常见的症状，但是在大多数情况下，它发现的问题是代码中的真正错误（或至少是潜在的错误）。这可能会迫使你从根本上重新架构程序，以避免遇到这些问题。当正确性和可靠性是你的重中之重时，这是一件好事。语言不会改变编程方式的重点是什么？当你使用其他语言工作时，Rust 讲授的有关安全性的课程也会很有用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果选择 Rust，通常需要该语言提供的保证：防止空指针和数据竞争的安全性，可预测的运行时行为以及对硬件的完全控制。如果你不需要这些功能，Rust 对于你的下一个项目可能不是一个好的选择。这是因为这些保证要付出一定的代价：学习坡度，时间问题。你将需要学习不良习惯并学习新概念。很有可能，刚开始时，你将与借阅检查器进行很多斗争。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Matthias Endler&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你发现 Rust 的编程模型的挑战性可能取决于你以前在其他语言中所拥有的经验。Python 或 Ruby 程序员可能会发现它有限制；而其他人可能很高兴。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果你是一位花了数周时间寻找这些语言的内存安全性错误的 C 或 C++ 程序员，那么你将非常感谢 Rust。“对抗借阅检查器”变为“编译器可以检测到吗？凉！”—Grzegorz Nosek&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;规模&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当今的服务器程序包含数千万行代码，由成百上千的程序员进行处理，并且每天都会更新。Go 的设计和开发旨在提高在这种环境下的工作效率。Go 的设计考虑因素包括严格的依赖关系管理，随着系统增长的软件体系结构的适应性以及跨组件边界的鲁棒性。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Rob Pike&lt;/span&gt;&lt;sup&gt;[17]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你自己或以小组形式处理问题时，选择简单语言还是丰富语言是你的偏爱。但是随着软件变得越来越大，越来越复杂，以及团队越来越大，这种差异真正开始显现出来。对于大型应用程序和分布式系统，执行速度不如开发速度重要：像 Go 这样的故意最小化的语言减少了新开发人员的启动时间，并使他们更容易使用大型代码库。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用 Go，初级开发人员更容易提高工作效率，而中级开发人员更难引入脆弱的抽象，而抽象将导致问题。由于这些原因，Rust 在企业软件开发方面不如 Go 引人注目。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Loris Cro&lt;/span&gt;&lt;sup&gt;[18]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当涉及到大型软件开发时，清晰胜于灵活。Go 的限制性实际上使它比 Rust 等更复杂、功能更强大的语言更适合企业和大型组织。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;差异&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管 Rust 和 Go 都是流行的，现代的，广泛使用的语言，但从故意针对完全不同的用例的意义上来说，它们并不是真正的竞争对手。Go 的整个编程方法与 Rust 的方法完全不同，每种语言都适合某些人，同时又会激怒其他人。绝对很好，而且如果 Rust 和 Go 都以或多或少相同的方式或多或少地完成了相同的事情，那么我们实际上就不需要两种不同的语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，通过发现它们采取截然不同的方法的问题，我们是否能够了解 Rust 和 Go 的各自性质？让我们找出答案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;垃圾回收&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“进行垃圾收集或不进行垃圾收集”是没有正确答案的问题之一。垃圾回收和自动内存管理通常使开发可靠，高效的程序变得快速简便，对于某些人来说，这是必不可少的。但是其他人说，垃圾回收的性能开销和停顿，使程序在运行时无法正常运行，并引入了无法接受的延迟。争论不休。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Go 与 Rust 完全不同。尽管两者都可以模糊地描述为系统语言或 C 语言的替代品，但它们具有不同的目标和应用，语言设计风格以及优先级。垃圾收集确实是一个巨大的区别。在 Go 中使用 GC 可使该语言变得更加简单和小巧。&lt;/p&gt;&lt;p&gt;在 Rust 中不使用 GC 可以使它真正更快（特别是如果你需要保证的等待时间，而不仅仅是高吞吐量），并启用 Go 中无法实现的特性和编程模式（或者至少在不牺牲性能的情况下）。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;PingCAP&lt;/span&gt;&lt;sup&gt;[19]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;更接近金属（Close to the metal）&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机编程的历史一直是一个越来越复杂的抽象的故事，它使程序员能够解决问题而不必担心底层机器的实际工作原理。这使程序更易于编写，并且可能更具移植性。但是对于许多程序而言，访问硬件以及精确控制程序执行方式更为重要。Rust 的目标是让程序员拥有更多的控制权，使其“更接近金属”，但是 Go 提取了体系结构的详细信息，以使程序员更加接近问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;两种语言有不同的使用范围。Golang 对于编写微服务和典型的 “DevOps” 任务很有用，但它不是系统编程语言。对于并发性，安全性和/或性能很重要的任务，Rust 更强。但是它的学习曲线比 Go 更陡。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Matthias Endler&lt;/span&gt;&lt;sup&gt;[20]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go 发展更快&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在其他地方写过，对于大多数程序而言，&lt;span&gt;性能并不如可读性重要&lt;/span&gt;&lt;sup&gt;[21]&lt;/sup&gt;。但是，当性能确实很重要时，它真的很重要。Rust 进行了许多设计折衷，以实现最佳的执行速度。相比之下，Go 更加关注简单性，并且愿意为此牺牲一些（运行时）性能。但是 Go 的构建速度是无与伦比的，这对于大型代码库而言非常重要。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Rust 比 Go 快。在上述基准测试中，Rust 速度更快，在某些情况下还快一个数量级。但是在选择使用 Rust 编写所有内容之前，请考虑一下 Go 在许多基准测试中并没有落后很多，并且它仍然比 Java，C#，JavaScript，Python 等同类工具快得多。&lt;/p&gt;&lt;p&gt;如果你需要一流的性能，那么你可以选择这两种语言中的任一种。如果你要构建一个处理高负载的 Web 服务，并且希望能够在垂直和水平方向上进行伸缩，则两种语言都将非常适合你。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Andrew Lader&lt;/span&gt;&lt;sup&gt;[22]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;正确性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一方面，如果程序没有正常运行，则可以任意快。大多数代码不是长期编写的，但通常令人惊讶的是某些程序可以在生产环境中运行多长时间：在某些情况下需要数十年。在这种情况下，需要花一些额外的时间来开发程序，以确保程序正确，可靠并且将来不需要进行大量维护。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我的看法：明天将要发布的代码选择 Go，在未来五年内保持不变的代码选择 Rust。&lt;em&gt;—Grzegorz Nosek&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管 Go 和 Rust 对于任何严肃的项目都是不错的选择，但最好使自己对每种语言及其特征都尽可能了解。最终，其他人的想法无关紧要：只有你可以决定哪种对你和你的团队是合适的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果你想加快开发速度，也许是因为你要编写许多不同的服务，或者你有庞大的开发团队，那么 Go 是你选择的语言。Go 为你提供了一流的并发性，并且不容许不安全的内存访问（Rust 也不容忍），但不会强迫你管理每个最后的细节。Go 是快速而强大的工具，但是它避免了使开发人员陷入困境，而专注于简单性和统一性。另一方面，如果需要拧紧块性能，那么 Rust 应该是你的选择。&lt;em&gt;—&lt;/em&gt;&lt;span&gt;Andrew Lader&lt;/span&gt;&lt;sup&gt;[23]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结论&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我希望本文使你相信，Rust 和 Go 都值得你认真考虑。如果可能的话，你应该力求获得至少两种语言的某种程度的经验，因为它们对你在任何技术职业中都是非常有用的，即使你喜欢将编程作为业余爱好也是如此。如果你只有时间投入精力来学习一种语言，那么请在将 Go 和 Rust 都用于各种大小不同的程序之前，不要做出最终决定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，对编程语言的了解实际上只是成为一名成功的软件工程师的一小部分。到目前为止，您将需要的最重要的技能是设计，工程，体系结构，沟通和协作。如果您擅长这些，那么无论您选择哪种语言，您都将是一名出色的软件工程师。学习愉快！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://bitfieldconsulting.com/golang/rust-vs-go&lt;/p&gt;&lt;p&gt;原文作者：John Arundel&lt;/p&gt;&lt;p&gt;编译：polarisxu&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[1]&lt;/span&gt;&lt;p&gt;For the Go of Love: &lt;em&gt;https://bitfieldconsulting.com/books/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[2]&lt;/span&gt;&lt;p&gt;Gints Dreimanis: &lt;em&gt;https://serokell.io/blog/rust-guide&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[3]&lt;/span&gt;&lt;p&gt;Golang.org: &lt;em&gt;https://golang.org/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[4]&lt;/span&gt;&lt;p&gt;Rob Pike: &lt;em&gt;https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;amp;t=8m43s&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[5]&lt;/span&gt;&lt;p&gt;Sam Rose: &lt;em&gt;https://samwho.dev/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[6]&lt;/span&gt;&lt;p&gt;Rust 程序员对 Go 的早期印象: &lt;em&gt;https://medium.com/better-programming/early-impressions-of-go-from-a-rust-programmer-f4fd1074c410&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[7]&lt;/span&gt;&lt;p&gt;Matthias Endler: &lt;em&gt;https://endler.dev/2017/go-vs-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[8]&lt;/span&gt;&lt;p&gt;Devathon: &lt;em&gt;https://devathon.com/blog/rust-vs-go-which-programming-language-to-choose/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[9]&lt;/span&gt;&lt;p&gt;Dave Cheney: &lt;em&gt;https://dave.cheney.net/2015/07/02/why-go-and-rust-are-not-competitors&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[10]&lt;/span&gt;&lt;p&gt;Sonya Koptyev: &lt;em&gt;https://sdtimes.com/softwaredev/the-developers-dilemma-choosing-between-go-and-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[11]&lt;/span&gt;&lt;p&gt;rayon: &lt;em&gt;https://github.com/rayon-rs/rayon&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[12]&lt;/span&gt;&lt;p&gt;Rust 程序员对 Go 的早期印象: &lt;em&gt;https://medium.com/better-programming/early-impressions-of-go-from-a-rust-programmer-f4fd1074c410&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[13]&lt;/span&gt;&lt;p&gt;Dave Cheney: &lt;em&gt;https://dave.cheney.net/2015/07/02/why-go-and-rust-are-not-competitors&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[14]&lt;/span&gt;&lt;p&gt;Why Rust?: &lt;em&gt;https://bitbucket.org/blog/why-rust&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[15]&lt;/span&gt;&lt;p&gt;Sam Rose: &lt;em&gt;https://samwho.dev/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[16]&lt;/span&gt;&lt;p&gt;Matthias Endler: &lt;em&gt;https://endler.dev/2017/go-vs-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[17]&lt;/span&gt;&lt;p&gt;Rob Pike: &lt;em&gt;https://talks.golang.org/2012/splash.article&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[18]&lt;/span&gt;&lt;p&gt;Loris Cro: &lt;em&gt;https://kristoff.it/blog/why-go-and-not-rust&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[19]&lt;/span&gt;&lt;p&gt;PingCAP: &lt;em&gt;https://medium.com/better-programming/early-impressions-of-go-from-a-rust-programmer-f4fd1074c410&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[20]&lt;/span&gt;&lt;p&gt;Matthias Endler: &lt;em&gt;https://endler.dev/2017/go-vs-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[21]&lt;/span&gt;&lt;p&gt;性能并不如可读性重要: &lt;em&gt;https://bitfieldconsulting.com/golang/slower&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[22]&lt;/span&gt;&lt;p&gt;Andrew Lader: &lt;em&gt;https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span pingfang=&quot;&quot; sc=&quot;&quot; cambria=&quot;&quot; cochin=&quot;&quot; georgia=&quot;&quot; times=&quot;&quot; new=&quot;&quot; roman=&quot;&quot; serif=&quot;&quot;&gt;[23]&lt;/span&gt;&lt;p&gt;Andrew Lader: &lt;em&gt;https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>444f73a3f1a8f772722bb23b4e784aaf</guid>
<title>提高「程序员」的思维方式</title>
<link>https://toutiao.io/k/ymhzlck</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;strong&gt; 大家好，我是Tom哥。&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人和动物的最大区别就是，人具有思维能力，能将大脑里的东西实现出来。而动物则更多停留在模仿阶段，如：鹦鹉学舌。当然，这也是一种进化能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;这里着重提到了思维能力，人与人的思维能力也是有差异的。比如：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一线程序员关心的这个项目涉及到多少个接口? 接口的代码要如何实现？其他哪些接口可能会受到影响，需要重点 review&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;团队 TL 则关心的这个项目的复杂度有多少？预计多少工作量？能不能按时开发完成？整个系统的性能、稳定性、扩展性等方面有什么帮助？会不会增加整个系统的维护成本？如果挂了，对业务有什么影响。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部门老板则关心这个项目要不要做？有没有什么风险？对业务和技术团队的价值在哪里？能带来多少用户量、GMV？优先级高不高？如何让业务方满意？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;我们可以发现基层、中层、高层，不同的职级的人关心的内容也不太一样，屁股决定脑袋。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是处于哪一个层级，都是做工作。那么在面对一件任务，你是如何开展工作的？我理解大概分为三个阶段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一阶段：靠「直觉」，不管是男人女人，当面对一件事情大脑一般都会有一个初步解决方案，区别在于这个方案的完备性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二阶段：靠「项目经验」去解决问题。这个适合有一定工作年限的同学&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三阶段：靠「思维能力」去解决。我们不可能所有的事情都经历过，当面对一个陌生的、棘手的任务，我们希望有一定的方法论、工具包可以指引我们， 使我们可以有条不紊的开展工作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么如何提高我们的思维能力？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、无规矩不成方圆，首先要有流程意识&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;兵法有云，“兵马未动粮草先行”。要想提高思维能力，首先要有「流程意识」，无规矩不成方圆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们相信，这个世间任何事情都是有规律可循的。我们要善于思考、善于发现，总结规律，抽象成流程。其中「使用流程」是基础，「优化流程」是进阶，「制定流程」则是巅峰。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5497702909647779&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdnlQMWBqzC9jsydzfiaUUgyr1ibschA4qgzydFu9wPq8LOHYZA0ib50WF7YnY4h7TQBtpf73iaYnympw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1306&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为研发人员，我们就以软件项目开发为例，从客户问题收集、市场调研，产品同学分析整理成需求文档，业务和技术侧的可行性分析，到开发编码，系统发布上线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;面对这多的环节，我们在设计流程时要注意哪些问题呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先，我们要确认流程包含的所有节点。并区分出核心节点和非核心节点，每个节点在流程中的作用、关键物料输出，以及是否可以缺失等等。核心节点，要投入更多的精力把控。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其次，将这些节点串联起来，就需要了解他们的上下游关系，这个顺序还是很重要的，乱了辈分很容易影响整个流程的交付。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，流程的细化补充。可以叫上相关同学，大家一起头脑风暴，看看是否有一些异常的场景需要补充进来，将整个流程更加完善。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程模板的制定非常考验大家的思维能力，尤其是一个全新的陌生领域。刚开始，有点盲人摸象的感觉，我们不清楚边界在哪里？哪些是重要的？哪些非核心的？不过没关系，我们可以尝试着按照自己的理解，先动起来。随着对业务逐渐熟悉，再对流程的各个细节优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构是一个逐步衍化的过程，流程模板也是一样的道理，没有什么生来就是完美的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、流程是模板，说话靠数据&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“一图胜千言” ，除了图之前，人类对数字也是很敏感的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你要买房，然后你去问中介，这套房子什么价？如果对方很高，那估计你要打人，不管有多高，你肯定是想听到一个具体的数字， 600万、1000万.....&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知不知道是一回事，买不买的起是另一回事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据是理性的，具有很强的客观性，2大于1 本身就无法挑战。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们日常的工作汇报中，不论是 PPT 还是邮件，能用数字量化的尽量用数据来表达，比起苍白的语言，数据清爽又让人无法反驳，我们要学会用数据武装自己，增强自己的说服力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、定期复盘，促使自己螺旋式成长&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;论语有一句话  “吾日三省吾身”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作中你是否经常自我反省？一个项目结束，你是否会组织个复盘会，盘点哪些做的好的，哪些有待改进的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘有点类似上面的流程事件的回顾，我们对各个环节的成果、失败背后的原因深度分析总结。抽取其中有价值的经验和方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘一定要确保相关的项目人员都要参与进来，保证信息能完整的还原，容易得到一个更佳的复盘效果。我们可以采用时间为主线，梳理各个时间点的重要事件，并对事件满意度评价，促使后续能做的更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有小伙伴会问了，复盘的重要性我也知道，但是我不知道怎么复盘？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;教给你一招，你可以采用  “5W根因分析法”，每一个环节每一个事件，反问自己是否取得了最好的结果？如果没有，那有哪些可以改进的点？有哪些优化方案？哪些方案是通用性经验？哪些方案是针对具体项目的经验？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要把复盘当成是一种追责，它能帮我们认清自己的不足，短暂的痛苦是为了以后更大的成长。“如果你感到痛苦，那是因为你在成长！”&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于我：Tom哥，前阿里P7技术专家，offer收割机，参加多次淘宝双11大促活动。欢迎关注，我会持续输出更多经典原创文章，为你晋级大厂助力&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;微信8.0将好友放开到了一万，小伙伴可以加我大号了，先到先得，再满就真没了。&lt;/strong&gt;&lt;strong&gt;扫描下方二维码即可加我微信啦，&lt;code&gt;2022，抱团取暖，一起牛逼。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.092130518234165&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdaSEqIP60fNXXqd7e15vycGo75wsfR2yTDKxOpJaKG0BKzFod8CQxLtibu2vMp1GKBMDJRbk3rpLw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;521&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/h2&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8d80208848ad3788d8573b4d16aa19dd</guid>
<title>CB  Simulator，曾经统治了整个网络的论坛</title>
<link>https://toutiao.io/k/fjgw51o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;论坛是一个大家经常使用的信息工具，如现在的百度贴吧、新浪论坛、搜狐社区等等。论坛上聚集了天南海北兴趣相投的人员，大家在这里不仅仅能找到志同道合可以聊上好几天的人员和话题，或者扮演吃瓜群众起哄加塞；也可以从论坛上找到工作生活的各种意见建议。一些有影响力的论坛，甚至能够形成影响全国的舆论话题，引导舆论方向。如最近被要求整改的豆瓣，其在书籍、电影方面的影响力，能直接影响到其销量和票房。百度贴吧闹出来的各种事件，能够直接影响到百度公司的股价。虽然各种论坛已经逐步被微博、微信等社交工具所取代， 其在信息获取和社交方面的地位仍然非常重要。&lt;/p&gt;&lt;p&gt;论坛也是一个舶来品，在上个世纪80、80年代，论坛的发展造就了一个在全世界都有影响力的大公司。这里以论坛从技术萌芽到成熟的发展历程， 结合CompuServe公司的兴衰历史， 探索技术如何帮助创业公司走上巅峰，并分析CompuServe公司如何在巅峰时刻迷失自我， 导致公司迅速走向衰弱直至被收购，论坛被关闭。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;打牢基础，构建服务全球的基础设施&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;CompuServer创办过程和现在的亚马逊云有点类似。1969年， Jeffrey Wilkins 和亚利桑那大学的同学John R. Goltz一起成立了CompuServe计算机公司，购买了几台DEC公司的PDP-10小型机，为Wilkins的老丈人Harry Gard Sr.创办的Golden United金联人寿保险公司提供电算能力 。当时保险公司并不需要那么多计算能力， 于是两个年轻人就参考康大资讯公司， 把多余的算力采用分时复用的方式租赁出去给人用。很快的，Wilkins发现这个业务更具有前景，就把公司独立出来，专门提供网络服务。后面公司的快速发展也证明了这个决策的正确性，顺势而为。&lt;/p&gt;&lt;p&gt;将近10年时间，公司专注于分时复用服务的优化上，让它可以服务更多的用户。早期分时复用的网络服务，用户在拨某一个号后，被连接到和这个号关联的固定的服务器上。这会限制这个业务的扩展。CompuServe研发了分组交换网络， 将PDP小型机通过内部网络连接起来， 用户拨号后，利用包交互技术，连接到不同的服务器上。CompuServe变成了一个复杂的多层网络，网络节点遍布美国各地，甚至扩展到了欧洲。 这个突破性的复杂多层的网络架构非常重要。它 让CompuServe在基础设施上具备可扩展的能力，为其提供服务于全美国，甚至后期拓展到全世界的业务奠定了基础。1975年，CompuServe在纳斯达克上市，代号为CMPU。1977年，CompuServe董事会将公司更名为CompuServe Incorporated，开始准备转型，将重点业务从提供客户自己编写应用程序的分时服务转移到专注于打包提供应用程序服务上。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;顺势而为，提供在线服务&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;1979年， CompuServe推出世界上第一个在线服务——MicroNet。MicroNet是一个命令驱动的系统。用户拨号到CompuServe之后，会收到如下信息：&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;false&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ID: 70000，2722&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Password&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;SECRET&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Job&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;44 on MicroNET at 18:22&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;21-Oct-79&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;on TO8CLJ&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;Welcome&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;to MicroNET,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;For&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;more inforation enter: NEWS&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;OK&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候，还没有任何菜单，用户需要输入准确的命令才可以得到想要的信息。每个用户都人手一份《MicoNET 用户手册》，介绍每个命令的详细用法。当时提供的服务包括电子邮件、BBS、在线存储、客服反馈系统，以及少量的游戏。当时还只有一台主机提供服务， 注册账号大概有1200个。&lt;/p&gt;&lt;p&gt;1980年， 时任CompuServe 的 CTO 的Sandy Trevor去英国参加了可视图文大会，看到了基于菜单的系统。回来后，立即启动系统升级，并亲自确定各级菜单内容。当年8月9日，系统上线后， MicroNET也改名为CompuServe Information Service， 简称CIS。CIS极大的提升的CompuServe服务体验， 极客式的命令行，变成选择菜单后， 没有计算机背景的普通用户都可以使用。CompuServe也进入了快速发展阶段。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;714&quot; data-ratio=&quot;0.8925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z8ExnwlWwvImk7oxgQgqqoRYhYc7iaYvMTeAFuXaBgu8WhVBPDuPsOHh2iah7ZKCxdUuKgm12gsE1kibqbckruuwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-width=&quot;800&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;从聊天室（chat room）起步&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;CompuServe是根据用户在线时间来收费的，提供什么样的服务能够留住用户，是公司上上下下最关注的问题。CompuServe最初的尝试是和报社合作， 这也是大家最容易想到的途径。1980年7月， CompuServe和美联社合作，将《纽约时报》、《洛杉矶时报》等报纸放到网上供大家有偿阅读。但是效果很不理想。报纸阅读的流量仅占到5%，一份20美分的报纸，在当时网络情况下， 需要6小时，花费30美元，才可以下载下来。那真是土豪才会做的事情。此外，其他网络服务商还尝试过提供网盘服务来变现， CompuServe并没有跟进。但很快的， CompuServe一个无心插柳推出的服务， 却最终成为了时间大杀器，让CompuServe赚的盆满钵满，并在80年代中期， 成为美国最大的网络服务提供商。&lt;/p&gt;&lt;p&gt;CompuServe 使用的主机，也有即时聊天的功能。上一篇我们也介绍过， 在DEC的PDP服务器上，有TALK服务，但这个服务并未对普通用户开放。1979年， CompuServe刚刚实现了一个新的能力， 让不同的用户可以对同一块内存区域进行读写。这让Sandy Trevor产生了一个念头， 让用户可以通过这个功能来实现和其他用户之间相互打字，即让别人看到他输入的内容，以及他也能看到别人输入的内容。这有点像民用的无线电台， 大家把收音机调整到同一个频段后，就可以一起远程对话了。Trevor把这个功能命名为CB Simulator，即频道模拟器。CB（Citizen&#x27;s Band）是民用频段的意思。&lt;/p&gt;&lt;p&gt;刚开始Trevor 打算和CompuServe的开发人员一起把这个功能实现出来。后来Trevor很快发现， 这些开发人员过于追求完美，完全按照传统软件工程来，把这个功能一板一眼的实现出来，并花大量的时间来考虑怎么保证消息不丢失。这并不是Trevor想要的， 他考虑这功能就跟游戏一样，容忍不完美的通讯，但又无法说服这些古板的程序员来实现一个并不完美的产品。于是Trevor就打算自己单干。找了个周末，在家独自把这个功能开发出来。1980年2月21日， 把这个功能上线，参考CB电台，开放了40个频道。&lt;/p&gt;&lt;p&gt;这功能一上线就炸了。CB Simulator为人们呈现了一个从未体验过的虚拟世界。天南海北的陌生人都在这里聚集， 随时都找到一位素昧平生的人聊两句。人们在线时间成倍增加，只为了和各种人聊天，一个人能够同时在多个频道灌水。人们花大把时间享受这种全新的体验，在线服务的账单很快掏空了网民们的口袋。经常会发现聊天室中的某一个人突然消失了几个月后，又重新冒泡出来， 第一句话就是：终于把信用卡还完了，上个月我居然花了700多美元的网费！要知道，当时的CompuServe收费并不便宜，一小时在12～22美元之间。放到现在，仍然是一笔非常贵的开销。&lt;/p&gt;&lt;p&gt;刚开始CompuServe CEO Jeff Wilkins并不理解这些情况， 不愿意把CB Simulator放到CIS的一级菜单中，用户每次都需要输入命令G0 CB才能进入聊天室。当 Wilkins看到高居收入表榜首的CB项目时，它就立即被列入了菜单中。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;专项兴趣小组SIG只是一个中间态&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;CB Simulator刚开始提供了40个频道， 每个频道都是预先设定好的主题。很快的这些频道就不够用了，人们开始自发建立同好频道。最早的频道主要是IT人员分享计算机技术的共享信息，吸引了不少专家和技术人员。随着这个概念的流行， 越来越多的主题和爱好的频道出现了。这些频道被人们称为SIG（special-interest group，专项兴趣小组）。随后， 人们可以在网上讨论音乐、赛车、游戏、科幻小说等等，甚至更专业的法律、医学等。SIG的出现，意味着频道不再是散养的状态了：&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;首先在人员管理上，进入了有序状态。各频道开始出现准入规则和退出机制。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;资源共享。相关的文件资源被上传到网盘上供下载。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;然而这些都是非官方的。每个SIG都是自发的民间组织，大家按约定俗成的规矩来维护成员和资源。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;最终发展成为论坛（Forum）&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;CompuServe的工程师Russ Ranshaw也在密切观察着SIG的发展。Ranshaw发现，SIG是一个非常好的商业概念，它将相关的资源都打包到一个菜单中，形成了一个主题，或者称之为“品牌”。每个SIG本质上都是一个小型的、独立的CompuServer，拥有自己的菜单：公告板、资源目录和频道，以及后来加入的成员列表。于是Ranshaw为SIG开发了专用的系统，方便人们快速找到对应的小组。刚开始，这个系统被称之为SIG，很快的，有些人开始使用“论坛”（Forum）这个名称，  意味着这是一个有管理、有目标的聚集地。随后，CompuServe Forums 开始正式推出。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;614&quot; data-ratio=&quot;0.599609375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z8ExnwlWwvImk7oxgQgqqoRYhYc7iaYvMY1unUwicMpGrCcM4yibXVGFuQkcIvso5st18ceZehmb8JdBrWcME6Tkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; data-width=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;和当时所有服务不同在于，论坛是一个需要管理的服务。需要有人盯着资源区，避免被人上传大量的广告信息；需要有人盯着帖子， 避免在论坛的公告板中出现不当言论。于是，类似BBS的系统管理员sysop出现在论坛中，即“版主” 。&lt;/p&gt;&lt;p&gt;由compuserve 来运营所有论坛显然是不现实的。人手是一方面，有些论坛还是非常专业的，比如讨论某最新的摄影技术，医学信息等等，Compuserve也找不到这么多专业人才。于是这些论坛就被”承包”出去了，和版主合作分成，由版主来管理论坛。这种模式也让论坛得以可复制地,不受限制地发展起来。&lt;/p&gt;&lt;p&gt;80年代的Compuserve正处于上升期， 公司蓬勃发展，新开论坛甚至都可以成为头条新闻。到了90年代初，Compuserve的技术支持论坛高达450多个，包括IBM、微软、3Com等主要的软件开发商和计算机制造商都是用Compuserve来托管自己的论坛， 共享信息并回答问题的提问。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;眼见他起朱楼&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;CompuServe的快速发展，和其鼓励创新的企业文化密切相关。在公司使命的引导下，CompuServe开创了很多第一：&lt;/p&gt;&lt;p&gt;Our mission is to serve those people who are serious about all their activities ... work, family, and leisure and who can improve their lives with the time-saving benefits of the Internet online world.&lt;/p&gt;&lt;p&gt;我们的使命是为那些认真对待他们所有活动的人服务...工作、家庭和休闲，并且可以通过互联网在线世界节省时间的好处来改善他们的生活。&lt;/p&gt;&lt;p&gt;1979年，以InfoPlex名义第一个向商业客户提供电子邮件功能和技术支持。&lt;/p&gt;&lt;p&gt;1980年，第一场在线直播的婚礼通过CB Simulator来进行。&lt;/p&gt;&lt;p&gt;1980年左右，和Visa合作，建立了第一个信用卡拨号授权服务，一直运行到现在，没有任何竞争对手。&lt;/p&gt;&lt;p&gt;1982年， 弗吉尼亚大学学生约翰•R•泰勒（John R Taylor III）和凯尔顿•弗林（Kelton Flinn） 为CompuServe开发了《凯斯迈之岛》，这是世界上第一款商业网络游戏， 对后世的网络游戏产生了深远的影响，因此在2011年的GDC游戏开发者大会上，Taylor与Flinn被授予网游传奇奖。&lt;/p&gt;&lt;p&gt;1986年，CompuServe与&lt;span&gt;富士通&lt;/span&gt;和&lt;span&gt;岩井日商&lt;/span&gt;一起进入日本的国际舞台，并于1989年开发了&lt;span&gt;日语&lt;/span&gt;版本的CompuServe，称为&lt;em&gt;NIFTY-Serve&lt;/em&gt;。&lt;/p&gt;&lt;p&gt;1989年CompuServe 开始提供互联网接入服务， 这也是全球第一个商用互联网服务。&lt;/p&gt;&lt;p&gt;1993年，CompuServe 香港与和记电讯成立合资企业，在拨号ISP热潮之前获得了50,000名客户。&lt;/p&gt;&lt;p&gt;在20世纪80年代中期，CompuServe成为美国，也是全世界最大的信息和网络服务公司之一，也是最大的消费者信息服务公司。它在美国30多个城市经营商业分支机构，主要向美国各地的大公司销售网络服务。消费者账户可以在大多数计算机商店购买（一个装有说明书和试用账户登录的盒子），对这项服务的认识非常高。到1987年，消费者方面将占CompuServe收入的50%。Compuserver成为上千个公共领域软件的入口，就跟现今的微信一样。此外，现如今大家想当然的“创新”， 如携程的旅游票务、京东的在线购物、墨迹的天气预报、今日头条的突发新闻报道等，早在80年代的Compuserve都已经提供给用户了。&lt;/p&gt;&lt;p&gt;1994年1月14日，CompuServe迎来了高光时刻。“信息高速公路”的推动者，副总统小艾伯特·戈尔（Albert Gore，Jr.）在CompuServe进行了第一次政治人物的在线互动采访。戈尔在白宫西翼的办公室，通过CompuServe和900多个在线用户进行了45分钟的实时互动，在线回答了用户的各种提问，取得了历史性的成功。1995年12月7日， 滚石公司在CB Simulator上召开了第一个在线视频会议。&lt;/p&gt;&lt;blockquote data-type=&quot;quote_container&quot;&gt;&lt;p&gt;今年8月份美国众议长佩洛西访问台湾， 在国际上掀起轩然大波。这并不是美国政要第一次玩弄台海议题。早在25年前，同样是议长的金里奇， 也窜访过台湾，为自己的政治生命画上句号。当年金里奇访台后， 让台湾一些人欣喜若狂，还想进一步操作更大事件，就把主意打在当时的副总统AL Gore 戈尔身上。作为一个成熟的政治家，戈尔一直和台湾明智地保持距离。虽然美国副总统没有多少职权，但作为克林顿的副手， 戈尔在担任副总统期间，推动制定了《1991高性能计算法案》，这个法案被大家普遍认为是让美国引领了新一轮高科技繁荣奠定了基础。戈尔在任期间持续推进美国信息高速公路建设，本人也是亲力亲为， 经常通过互联网服务来和网民互动，推进和推广各项政策。而其中最常用的沟通方式之一，便是今天要介绍的CompuServe提供的论坛服务。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;到1996年， 鼎盛时期的CompuServe拥有将近200万用户，年收入超过7.93亿美元。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;眼见他楼塌了&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;CompuServe的成功，开始让公司的领导层飘起来了。当Wilkins提醒管理层注意对付新崛起的AOL时，管理层说：我们刚刚赚了1亿美元，他们对我们不构成威胁。Wilkins失望地走出了公司的大楼，“他们迷路了， 一旦停止创新， 你就会变得自满了。” 随着AOL（美国在线）进入网络服务提供领域， 掀起了价格战， CompuServe开始面临亏损。在和AOL的战争中， CompuServe一直疲于应付。&lt;/p&gt;&lt;p&gt;&lt;span&gt;美国在线&lt;/span&gt;于1991年进入个人电脑市场，每小时收费2.95美元，而CompuServe每小时收费5美元。美国在线使用免费的基于&lt;span&gt;图形用户界面&lt;/span&gt;的客户端；CompuServe不是免费的，它只支持系统功能的一部分。作为回应，CompuServe几次调低了小时费率，最低达到1.95美元/小时。1996年，美国在线来了招狠的， 直接改为按月订阅，而不是按小时收费，因此对于活跃用户来说，美国在线要便宜得多。用户大批量地转移到了AOL。屋漏偏逢连夜雨， 此时， CompuServe还碰到更多糟心的事情：&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;WoW失败。原先WoW是用来抵御AOL竞争的， 提供每月‘无限’费率（17.95美元）的互联网服务，即开始包月服务， 然而大量的软件错误，服务出现随机关闭，电子邮件丢失等问题，导致1997年1月31日公司不得不关闭这个业务；&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;母公司H&amp;amp;R 由于高管变动陷入动荡，财务失衡。为了弥补亏空， H&amp;amp;R准备出售CompuServe的股份。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1996年中期， CompuServe准备放弃自己专有协议和客户端， 支持用户通过浏览器来访问服务。C也就是CompuServe准备转型为互联网服务提供商。不过CompuServe选择了Netscape浏览器。而在浏览器大战中，微软通过操作系统捆绑自家的IE浏览器而占据大部分市场份额。这导致用户通过其他浏览器无法访问到CompuServe的全部功能而投诉。然而， AOL通过和微软的合作，直接选择了IE浏览器。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;1997年，CompuServe的财务状况一落千丈，公司报告亏损1.2亿美元。同年9月8日， WorldCom和AOL通过一些列复杂的交易收购了CompuServe。随后，CompuServe的论坛一直保持独立运作，直到2017年11月19日，Oath公司宣布关闭这个活跃了将近半个世纪的论坛服务。&lt;/p&gt;&lt;p&gt;尽管CompuServe已经成为过去式了，但它在计算机发展史上却拥有非常重要的一席之地。CompuServe不仅仅在商业模式上，为后续互联网经济提供了有价值的探索；在技术方面，为互联网的蓬勃发展奠定了基础设施的整体架构。而在国内，直到2003年，即CB Simulator推出的23年后，才出现了百度贴吧。与CB Simulator成为各公司可信的客服平台不同， 百度贴吧却是国内技术人员都不希望提及的话题。尽管在这个时代的网速、技术和网民的数量都碾压CompuServe，但不管在技术孵化、商务模式、人才培育等各个方面， 它的贡献和CompuServe相比，却有天壤之别。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>73976f557835154b614bed5e17bfbc5e</guid>
<title>Input标签这么牛？居然也自带颜色选择器功能？</title>
<link>https://toutiao.io/k/gotsnft</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NjY2NTcyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdjaCTEjQdxnaIlEWiaGcw9zNV7AHZGgp5q9U0zPf3cmcIgBRYG1n2ydEBHJGgl8nEA1bKiaj1fibK2EA/0?wx_fmt=png&quot; data-nickname=&quot;前端之神&quot; data-alias=&quot;Sunshine_Lin_God&quot; data-signature=&quot;一位前端小菜鸡，写过100多篇原创文章，全网有5w+个前端朋友，梦想是成为”前端之神“~&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;大家好，我是林三心，&lt;strong&gt;用最通俗易懂的话讲最难的知识点&lt;/strong&gt;是我的座右铭，&lt;strong&gt;基础是进阶的前提&lt;/strong&gt;是我的初心。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.010204081632653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhMCbc47vfn8MBcvRcL1ITOXjF21Orf5BH18S97mICN2dlwjg7E0EQ5vPxpQbcWDLSZLFaKItbicOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;196&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;颜色选择器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;大家平时在看那些UI组件库时，都会看到有&lt;code&gt;颜色选择器&lt;/code&gt;这个东西，顾名思义，其作用就是用来选择颜色的的&lt;/p&gt;&lt;p&gt;比如&lt;code&gt;ElementUI&lt;/code&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1616766467065869&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhMCbc47vfn8MBcvRcL1ITOQfPu4ibsfdvldicDcCHutWm9802icLFHC9BhIotYHNKbNnoZ4lQqhMAGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;input type=&quot;color&quot;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;其实我们熟知的&lt;code&gt;input&lt;/code&gt;标签也有这种能力，只需要把&lt;code&gt;type&lt;/code&gt;设置为&lt;code&gt;color&lt;/code&gt;即可&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;color&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请看看以下的效果&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1369863013698631&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhMCbc47vfn8MBcvRcL1ITOarIGAIYbsmJxjZelgWia6bvOjHJml9XmslagWG5AjGSoQC8MzBAwtdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;监听变化&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;只需要监听&lt;code&gt;input&lt;/code&gt;的&lt;code&gt;onchange&lt;/code&gt;事件即可&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 可以给默认value值，代表默认颜色&lt;/span&gt;&lt;br/&gt;&amp;lt;input &lt;br/&gt;  type=&lt;span&gt;&quot;color&quot;&lt;/span&gt; &lt;br/&gt;  id=&lt;span&gt;&quot;color&quot;&lt;/span&gt; &lt;br/&gt;  value=&lt;span&gt;&quot;#ff0000&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// javascript&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; c = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;color&#x27;&lt;/span&gt;)&lt;br/&gt;c.onchange = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(event.target.value)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4409448818897638&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhMCbc47vfn8MBcvRcL1ITOU8nkzQbjWRBqe1zu1iaj4CLxZt4HeFvaksdpnw6PRm2t2W4xDum8NaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;254&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;兼容性&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;总体来说，兼容性还是不错的，咱们可以来看看MDN上的浏览兼容性表，但是还是有一些属性在除了谷歌浏览器以外的浏览器中不太兼容，不过问题不大，type支持就行了哈哈哈哈哈！！！&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7114485981308412&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhMCbc47vfn8MBcvRcL1ITOncFQ9wkDQdoL0MMXAkxWcu1dEO17LmLcBSibxZabdvqOJH4MYd0vuyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1712&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;结语&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;点个【赞】和【在看】是对林三心最大的鼓励，林三心会非常开心的~~~&lt;/p&gt;&lt;p&gt;关注公众号【前端之神】，回复【加群】，即可获得加入【千人前端学习大群】的方式，交流找工作，摸鱼，吹水~&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NjY2NTcyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdjaCTEjQdxnaIlEWiaGcw9zNV7AHZGgp5q9U0zPf3cmcIgBRYG1n2ydEBHJGgl8nEA1bKiaj1fibK2EA/0?wx_fmt=png&quot; data-nickname=&quot;前端之神&quot; data-alias=&quot;Sunshine_Lin_God&quot; data-signature=&quot;一位前端小菜鸡，写过100多篇原创文章，全网有5w+个前端朋友，梦想是成为”前端之神“~&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>