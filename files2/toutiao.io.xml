<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f5c444646b3b2fab6ae633e3605aaedb</guid>
<title>如何写好日志记录？</title>
<link>https://toutiao.io/k/882beu7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;fieldset data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkyNTI5NTQ1NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/wxcY9TH8dPsYAnrjaZktBe0iahF8ic9QkF26cAw8pK6HPR1bfFEImdyJspvkQvQwmnYxP4eEVW60ewVVickcWXnrQ/0?wx_fmt=png&quot; data-nickname=&quot;架构文摘&quot; data-alias=&quot;ArchDigest&quot; data-signature=&quot;每天一篇架构领域重磅好文，涉及一线互联网公司应用架构（高可用、高性能、高稳定）、大数据、机器学习、Java架构等各个热门领域。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/fieldset&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;1 简介&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在程序中写日志是一件非常重要，但是很容易被开发人员忽视的地方。写好程序的日志可以帮助我们大大减轻后期维护压力。在实际的工作中，开发人员往往迫于巨大时间压力，而写日志又是一个非常繁琐的事情，往往没有引起足够的重视。开发人员应在一开始就养成良好的日志撰写习惯，并且应在实际的开发工作中为写日志预留足够的时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1.1 日志的作用&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般程序日志出自下面几个方面的需求：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、 记录用户操作的审计日志，甚至有的时候就是监管部门的要求；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、 快速定位问题的根源；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、 追踪程序执行的过程；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4、 追踪数据的变化；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5、 数据统计和性能分析；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;6、 采集运行环境数据；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般在程序上线之后，一旦发生异常，第一件事就是要弄清楚当时发生了什么。用户当时做了什么操作，环境有无影响，数据有什么变化，是不是反复发生等，然后再进一步的确定大致是哪个方面的问题。确定是程序的问题之后再交由开发人员去重现、研究、提出解决方案。这时，日志就给我们提供了第一手的资料。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1.2 撰写日志的要求&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;既然撰写日志是有需求，而且也能在未来帮助我们提高工作效率的事情，长远来看是非常有利的一件事情。因此我们应该在自己开发的程序中符合规范的撰写日志，在写日志时要注意以下的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.2.1 日志的可读性&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;日志时给人读的，不仅仅是让自己明白，也要让没有接触过我们源代码的其他程序员也能够一目了然。有的同事在日志中打印特殊的标识符号，例如“++++++++++”， “===========”，“—————”，这些符号令人眼花缭乱。这是一种不好的编程习惯。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，把日志分类输出到不同的文件也有利于我们排除干扰，迅速找到我们需要的信息。而且，最好在打印日志时输出英文，防止中文不支持而打印出乱码的情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.2.2 日志的性能&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;无论我们把日志写到文件还是数据库，都需要消耗IO资源。适当的控制日志的输出也有利于提高程序的性能。例如：尽量避免在在大的循环中打印意义不大的日志内容。输出日志之前最好能判断日志的级别(例如. debug前先调用isDebugEnabled()作出判断)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.2.3 占用磁盘空间&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通常，我们都是把日志写入磁盘上的日志文件中。适当的使用滚动日志并且定时清除旧文件是有好处的。我见过这样一个例子，程序运行几次后就跑不起来了，前几次都是正常的。怎么都想不明白程序有什么问题，最后才发现居然是日志文件占满了磁盘空间。在实际的应用中出现上G的日志文件也往往不少见。要在这样规模的日志文件中找出对解决问题有用的信息也是一大挑战。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.2.4 日志的时效性&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有的时候我们并不能及时的发现问题。需要追溯之前的日志。所以我们是需要保留一段时间以内的日志便于追溯。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.2.5日志级别；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通常我们在产品环境中日志的级别都在INFO以上，所以我们必须保证在这样的情况下程序仍然能够输出足够我们作出判断的信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如常见的系统具有如下的日志级别：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;define&lt;/span&gt; DRV_LOG_FATAL(fmt, ...)           hlog_format(HLOG_LEVEL_FATAL, &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;PluginDriver&quot;&lt;/span&gt;,   &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;[%s(%d)] &quot;&lt;/span&gt;fmt, __FUNCTION__,   __LINE__,__VA_ARGS__)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;define&lt;/span&gt; DRV_LOG_ERROR(fmt, ...)           hlog_format(HLOG_LEVEL_ERROR, &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;PluginDriver&quot;&lt;/span&gt;,   &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;[%s(%d)] &quot;&lt;/span&gt;fmt, __FUNCTION__,   __LINE__,__VA_ARGS__)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;define&lt;/span&gt; DRV_LOG_WARN(fmt, ...)          hlog_format(HLOG_LEVEL_WARN, &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;PluginDriver&quot;&lt;/span&gt;,   &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;[%s(%d)] &quot;&lt;/span&gt;fmt, __FUNCTION__,   __LINE__,__VA_ARGS__)  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;define&lt;/span&gt; DRV_LOG_INFO(fmt, ...)          hlog_format(HLOG_LEVEL_INFO, &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;PluginDriver&quot;&lt;/span&gt;,   &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;[%s(%d)] &quot;&lt;/span&gt;fmt, __FUNCTION__,   __LINE__,__VA_ARGS__)  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;define&lt;/span&gt; DRV_LOG_DEBUG(fmt, ...)           hlog_format(HLOG_LEVEL_DEBUG, &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;PluginDriver&quot;&lt;/span&gt;,   &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;[%s(%d)] &quot;&lt;/span&gt;fmt, __FUNCTION__,   __LINE__,__VA_ARGS__)   &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;define&lt;/span&gt; DRV_LOG_TRACE(fmt,   ...)         hlog_format(HLOG_LEVEL_TRACE, &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;PluginDriver&quot;&lt;/span&gt;,   &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;[%s(%d)] &quot;&lt;/span&gt;fmt, __FUNCTION__,   __LINE__,__VA_ARGS__)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上述的日志文件中定义了6种日志级别，不同级别的含义在下文详述，需要了解到在一个程序开发的过程中需要维护不同的分别为FATAL， ERROR， EARN， INFO， DEBUG， TRACE。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.2.6 日志内容&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在写日志的时候，需要注意输出适当的内容。首先，尽量使用业务相关的描述。我们的程序是实现某种业务的，那么就最好能描述清楚这个时候走到了业务过程的哪一步。其次，避免在日志中输出一些敏感信息，例如用户名和密码。以及，要保持编码的一致。如果不能保证就尽量使用英文而不是中文。这样当我们拿到日志之后就不会因为看到一堆乱码而不知所云了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.2.7 日志格式&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;常见的日志格式中对于每一条日志应含有的信息包括日期、时间、日志级别、代码位置、日志内容、错误码等信息。下面是一个工作中的日志文件的一部分内容：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2022&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-05-22&lt;/span&gt; 15&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:35&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:53.850&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TRACE&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZLog&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[0x00001b10]&lt;/span&gt; &amp;lt;36&amp;gt; &amp;lt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZProtocol&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::Init&lt;/span&gt;&amp;gt;,&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZProtocol&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::Init&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2022&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-05-22&lt;/span&gt; 15&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:35&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:53.850&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TRACE&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZLog&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[0x00001b10]&lt;/span&gt; &amp;lt;89&amp;gt; &amp;lt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZProtocol&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::Init&lt;/span&gt;&amp;gt;,&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;End&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;processing&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZProtocol&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::Init&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2022&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-05-22&lt;/span&gt; 15&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:35&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:53.853&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TRACE&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZLog&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[0x00001b10]&lt;/span&gt; &amp;lt;142&amp;gt;    &amp;lt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZProtocol&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::Connect&lt;/span&gt;&amp;gt;,&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Connect&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Execute&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;finish&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2022&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-05-22&lt;/span&gt; 15&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:35&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:53.853&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TRACE&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZLog&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[0x00002f10]&lt;/span&gt; &amp;lt;149&amp;gt;    &amp;lt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;GetAlarmEventPro&lt;/span&gt;&amp;gt;,&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Enter&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;GetAlarmEventPro&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;func&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2022&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-05-22&lt;/span&gt; 15&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:39&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:36.382&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;WARN&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TrackLog&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[0x000029fc]&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[ internal WARN htrace_server_convert_msgstring_to_contextintls(493) ]&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;detect&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;error&lt;/span&gt;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;trace_id&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;span_id&lt;/span&gt;,&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;may&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;tracked&lt;/span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2022&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-05-22&lt;/span&gt; 15&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:39&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:36.383&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;WARN&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TrackLog&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[0x000029fc]&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[ internal WARN htrace_server_receive(195) ]&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;can&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;detect&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;trace_id&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;context&lt;/span&gt;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;may&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;tracked&lt;/span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2022&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-05-22&lt;/span&gt; 15&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:39&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:36.383&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TRACE&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZLog&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[0x000029fc]&lt;/span&gt; &amp;lt;231&amp;gt;    &amp;lt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZProtocol&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::DisConnect&lt;/span&gt;&amp;gt;,&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZProtocol&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::DisConnect&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2022&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-05-22&lt;/span&gt; 15&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:39&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:37.502&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TRACE&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZLog&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[0x00002f10]&lt;/span&gt; &amp;lt;225&amp;gt;    &amp;lt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;GetAlarmEventPro&lt;/span&gt;&amp;gt;,&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;End&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Get&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;AlarmEventPro&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Func&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2022&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-05-22&lt;/span&gt; 15&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:39&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:37.503&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TRACE&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZLog&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[0x000029fc]&lt;/span&gt; &amp;lt;241&amp;gt;    &amp;lt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZProtocol&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::DisConnect&lt;/span&gt;&amp;gt;,&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;close&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;socket&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2022&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-05-22&lt;/span&gt; 15&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:39&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:37.503&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TRACE&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZLog&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[0x000029fc]&lt;/span&gt; &amp;lt;242&amp;gt;    &amp;lt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TDWZProtocol&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::DisConnect&lt;/span&gt;&amp;gt;,&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Execute&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;DisConnect&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;succeed&lt;/span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以从该文件中看出一般日志文件中应该含有的信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;2 日志级别和含义&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输出目的地是控制台、文件、GUI组件甚至是套接口服务器；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.1 Log4j的组成&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Log4j由三个重要的组成构成：日志记录器(Loggers)，输出端(Appenders)和日志格式化器(Layout)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.1.1 Logger&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;控制要启用或禁用哪些日志记录语句，并对日志信息进行级别限制&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.1.2 Appenders&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;指定了日志将打印到控制台还是文件中.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.1.3 Layout&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;控制日志信息的显示格式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.2 日志级别&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Log4j中将要输出的Log信息定义了6种级别，依次为TRACE、DEBUG、INFO、WARN、ERROR和FATAL，当输出时，只有级别高过配置中规定的 级别的信息才能真正的输出，这样就很方便的来配置不同情况下要输出的内容，而不需要更改代码，非常方便快捷。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.2.1 TRACE&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TRACE designates finer-grained informational events than the DEBUG.Since:1.2.12，很低的日志级别，一般不会使用。TRACE一般跟踪的是函数的调用，并且TRACE不应该含有变量参数，而仅能提示函数的调用关系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.2.2 DEBUG&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般用于细粒度级别上，对调试应用程序非常有帮助，主要用于开发过程中打印一些运行信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.2.3 INFO&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;INFO消息在粗粒度级别上突出强调应用程序的运行过程。打印一些你感兴趣的或者重要的信息，这个可以用于生产环境中输出程序运行的一些重要信息，但是不能滥用，避免打印过多的日志。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.2.4 WARN&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;WARN表示会出现潜在错误的情形，有些信息不是错误信息，但是也要给程序员一些提示。该级别表示程序会自动调整到正常的状态，类似参数未传入，使用了默认的参数，仍符合程序员预期之内的情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.2.5 ERROR&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ERROR指出虽然发生错误事件，但仍然不影响系统的继续运行。打印错误和异常信息，如果不想输出太多的日志，可以使用这个级别。一般在WARN之后的级别在打印错误时，应该同时打印错误码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.2.6 FATAL&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;FATAL指出每个严重的错误事件将会导致应用程序的退出，这个级别比较高，重大错误，程序无法恢复，必须通过重启程序来解决。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.3 日志级别大小关系&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;日志级别就像开关一样，来决定哪些日志方法被调用，哪些不被调用。在log4j中，日志级别的关系如下所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;ALL&lt;/span&gt;&amp;lt;TRACE&amp;lt;DEBUG&amp;lt;INFO&amp;lt;WARN&amp;lt;ERROR&amp;lt;FATAL&amp;lt;&lt;span class=&quot;code-snippet__literal&quot;&gt;OFF&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;设置了对应的级别之后，日志框架就只调用大于等于这个级别的方法。Log4j建议只使用如下的四个界别&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DEBUG&amp;lt;INFO&amp;lt;WARN&amp;lt;ERROR&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;3 日志规范示例&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;模仿，抄写是比较好的学习方式，借鉴前人撰写日志的良好风格以形成自己的风格是不错的方式。下面是一些不错的日志记录。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.1 TRACE日志记录示例&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;Connect &lt;span class=&quot;code-snippet__keyword&quot;&gt;Execute&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Connect&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Execute&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;finish&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;DisConnect&lt;/span&gt; func&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Execute&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DisConnect&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; succeed.&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;Enter UploadEvent Func&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;extInfo = %s&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;, Extension);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;Send a Msg &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;- &lt;span class=&quot;code-snippet__keyword&quot;&gt;Connect&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Execute&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;- &lt;span class=&quot;code-snippet__keyword&quot;&gt;Connect&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Execute&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;finish&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;- Enter GetAlarmEventPro func&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;- Receive an info&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;- &lt;span class=&quot;code-snippet__keyword&quot;&gt;End&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Get&lt;/span&gt; AlarmEventPro Func&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;- &lt;span class=&quot;code-snippet__keyword&quot;&gt;DisConnect&lt;/span&gt; func&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;- &lt;span class=&quot;code-snippet__keyword&quot;&gt;Execute&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DisConnect&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; succeed.&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;- Enter UploadEvent Func&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;- Leave UploadEvent Func&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;- ============电网报警触发&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;- ============开始发送电流电压值&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_TRACE(&quot;&lt;/span&gt;- ============间隔超过分钟再次发送电流电压值&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.2 INFO日志记录示例&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_INFO(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- UpdataEvent  nchal= %d,EventID = %d.&quot;&lt;/span&gt;,iChannelNo,nEventType);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_INFO(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- do not support doControl&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_INFO(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- channelId = %s, nStatusType = %d&quot;&lt;/span&gt;, channelId.c_str(), nStatusType);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.3 DEBUG日志记录示例&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- 输出报警情况:电网编号:%d,报警数量:%d,报警内容:%s.&quot;&lt;/span&gt;,datas.data1.chn,datas.data1.alarm_num,datas.data1.alarms);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- 输出报警情况:电网编号:%d,报警数量:%d,报警内容:%s.&quot;&lt;/span&gt;,datas.data2.chn,datas.data2.alarm_num,datas.data2.alarms);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- 输出报警情况:电网编号:%d,报警数量:%d,报警内容:%s.&quot;&lt;/span&gt;,datas.data3.chn,datas.data3.alarm_num,datas.data3.alarms);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- 输出报警情况:电网编号:%d,报警数量:%d,报警内容:%s.&quot;&lt;/span&gt;,datas.data4.chn,datas.data4.alarm_num,datas.data4.alarms);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- ============datas.data1.huab = %d&quot;&lt;/span&gt;,datas.data1.huab);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- ============datas.data1.hiab = %d&quot;&lt;/span&gt;,datas.data1.hiab);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- ============datas.data2.huab = %d&quot;&lt;/span&gt;,datas.data2.huab);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- ============datas.data2.hiab = %d&quot;&lt;/span&gt;,datas.data2.hiab);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- ============datas.data3.huab = %d&quot;&lt;/span&gt;,datas.data3.huab);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- ============datas.data3.hiab = %d&quot;&lt;/span&gt;,datas.data3.hiab);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- ============datas.data4.huab = %d&quot;&lt;/span&gt;,datas.data4.huab);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- ============datas.data4.hiab = %d&quot;&lt;/span&gt;,datas.data4.hiab);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- Alarm is : %s&quot;&lt;/span&gt;,szEvent.c_str());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- GetChannelExtInfo channelId=%s&quot;&lt;/span&gt;, channelId.c_str());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_DEBUG(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- nChan = %d, szInfo = %s&quot;&lt;/span&gt;, nChan, szInfo);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.4 WARN日志记录示例&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_WARN(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;[0x%08x] - invaild event msg,discard it&quot;&lt;/span&gt;, DRV_INVALID_ARG);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_WARN(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;[0x%08x] - Can&#x27;t find channel by channelId&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_WARN(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;[0x%08x] - [DWSdk.errorcode=0x%08x]Connect device failed&quot;&lt;/span&gt;, DRV_CONNECT_FAILED, sdkErrCode);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_WARN(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;[0x%08x] - [DWSdk.errorcode=0x%08x]dw_start_receive failed&quot;&lt;/span&gt;, DRV_ERROR, sdkErrCode);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_WARN(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;[0x%08x] - [DWSdk.errorcode=0x%08x]Communicate failed, socket recv error&quot;&lt;/span&gt;, DRV_ERROR, DW_SOCKET_RECV_ERROR);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_WARN(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;[0x%08x] - [DWSdk.errorcode=0x%08x&amp;gt;other error&quot;&lt;/span&gt;, DRV_ERROR, iGetResult);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_WARN(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;[0x%08x] - [DWSdk.errorcode=0x%08x&amp;gt;other error&quot;&lt;/span&gt;, DRV_ERROR, iGetResult);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_WARN(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;[0x%08x] - SetEventCallBack should be called first&quot;&lt;/span&gt;, DRV_ERROR);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.5 ERROR日志记录示例&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_ERROR(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Init DwSDK filded;&amp;lt;errCode=%d&amp;gt;&quot;&lt;/span&gt;, initRet); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_ERROR(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Connect device failed&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_ERROR(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Create thread failed&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_ERROR(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dw_start_receive failed&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_ERROR(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Communicate failed, socket recv error&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_ERROR(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;other error&amp;lt;errCode=%d&amp;gt;&quot;&lt;/span&gt;, iGetResult);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_ERROR(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SetEventCallBack should be called first&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_ERROR(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;[0x%08x] - [DWSdk.errorcode=0x%08x]Init DwSDK filded&quot;&lt;/span&gt;, DRV_INIT_FAILED, initRet);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DRV_LOG_ERROR(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;- [HPR.errorcode=0x%08x]Create thread failed&quot;&lt;/span&gt;, HPR_GetLastError());&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上述代码中[0x%08x]有下述作用：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;该语句出现于格式化输出时的格式字符串中。形式为&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;0x%08x&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中，0x为普通字符，输出的时候会原样输出为0x。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;%08x为整型以16进制方式输出的格式字符串，会把后续对应参数的整型数字，以16进制输出。08的含义为，输出的16进制值占8位，不足部分左侧补0。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;于是，如果执行&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;0x%08x&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0x1234&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;会输出0x00001234。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;23409&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者：思影影思&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：&lt;span&gt;blog.csdn.net/lk142500/article/details/80424945&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;版权申明：&lt;/span&gt;&lt;span&gt;内容来源网络，仅供分享学习，版权归原创者所有。&lt;/span&gt;&lt;span&gt;除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。&lt;/span&gt;&lt;span&gt;谢谢!&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;article ng-controller=&quot;EntryCtrl&quot; ui-lightbox=&quot;&quot;&gt;&lt;section ng-bind-html=&quot;postContentTrustedHtml&quot;&gt;&lt;section data-id=&quot;702&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section data-recommend-type=&quot;list-normal&quot; data-recommend-tid=&quot;2&quot; data-mpa-template=&quot;t&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501257_1&quot; data-recommend-article-time=&quot;1636251616&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/zc3KLDBfJlm8bD2WBlwbvnsktMdtfSudNaJWbHr1Iyr6HkwCxETHiaiceaWYLmq7tWmHV29U8Xv8UnoeCAOYNj9Q/0?wx_fmt=jpeg&amp;amp;amp;random=0.27521905775014543&quot; data-recommend-article-title=&quot;强势开源一款小程序！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501257&amp;amp;idx=1&amp;amp;sn=7b4e27cdb1d3146a5e7e1951b5bdc9e8&amp;amp;chksm=c1ca33f9f6bdbaefd3874fa6313e422c8fb6b2799b40d09f36620f0ceaed4fd63c820da1f3ff#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501257&amp;amp;idx=1&amp;amp;sn=7b4e27cdb1d3146a5e7e1951b5bdc9e8&amp;amp;chksm=c1ca33f9f6bdbaefd3874fa6313e422c8fb6b2799b40d09f36620f0ceaed4fd63c820da1f3ff&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;强势开源一款小程序！&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-11-07&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42592592592592593&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zc3KLDBfJlm8bD2WBlwbvnsktMdtfSudNaJWbHr1Iyr6HkwCxETHiaiceaWYLmq7tWmHV29U8Xv8UnoeCAOYNj9Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501242_1&quot; data-recommend-article-time=&quot;1634952613&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UWibGeSzVdcKHzDRdVHusb9CJicA5FdhDVPAiaicdTbibx5XoRkhKA3O7Q727cTSurBkJpciczjLrF2wkA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;强力推荐一个完善的物流（WMS）管理项目（附代码）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501242&amp;amp;idx=1&amp;amp;sn=aa2297b69874de0993f62ea404376bab&amp;amp;chksm=c1ca338af6bdba9cf3e051ff3001e1f31f9fa97350f3851c797d6486eca360df537196dbe67b#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501242&amp;amp;idx=1&amp;amp;sn=aa2297b69874de0993f62ea404376bab&amp;amp;chksm=c1ca338af6bdba9cf3e051ff3001e1f31f9fa97350f3851c797d6486eca360df537196dbe67b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;强力推荐一个完善的物流（WMS）管理项目（附代码）&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-10-23&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UWibGeSzVdcKHzDRdVHusb9CJicA5FdhDVPAiaicdTbibx5XoRkhKA3O7Q727cTSurBkJpciczjLrF2wkA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501238_1&quot; data-recommend-article-time=&quot;1634606700&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VduLA9tc9dQkaw5HWIV6pqNrOiciaE17jeIeTtoLfgLbyu67dWkRj3tjKX7AFIMrV0rKD5ic6kwicyxg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;推荐一个 Spring Boot + MyBatis + Vue 音乐网站&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501238&amp;amp;idx=1&amp;amp;sn=d7e873d752a28b582d70bc9f7a981ddb&amp;amp;chksm=c1ca3386f6bdba9031ce115e734ce04c9b6728e8e027fbcf17d8d07f1e029ea5bea04f4a6273#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501238&amp;amp;idx=1&amp;amp;sn=d7e873d752a28b582d70bc9f7a981ddb&amp;amp;chksm=c1ca3386f6bdba9031ce115e734ce04c9b6728e8e027fbcf17d8d07f1e029ea5bea04f4a6273&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;推荐一个 Spring Boot + MyBatis + Vue 音乐网站&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-10-19&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42592592592592593&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VduLA9tc9dQkaw5HWIV6pqNrOiciaE17jeIeTtoLfgLbyu67dWkRj3tjKX7AFIMrV0rKD5ic6kwicyxg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501208_1&quot; data-recommend-article-time=&quot;1632101100&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VibcP3PNgQvXGZ7UJkVeu0JZsrldvF1urHlmNwhUP89IeKHz1PfJ12es2ArTwkYibAh3Y0soOib2rjA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;分享一套家庭理财系统（附源码）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501208&amp;amp;idx=1&amp;amp;sn=44fcdfe2d7f81a26845faf33750ea9bb&amp;amp;chksm=c1ca33a8f6bdbabec8ff34719f438465adf745cbef30bfb92be53897c714d8c13bdd01989d17#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501208&amp;amp;idx=1&amp;amp;sn=44fcdfe2d7f81a26845faf33750ea9bb&amp;amp;chksm=c1ca33a8f6bdbabec8ff34719f438465adf745cbef30bfb92be53897c714d8c13bdd01989d17&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;分享一套家庭理财系统（附源码）&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-09-20&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42407407407407405&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VibcP3PNgQvXGZ7UJkVeu0JZsrldvF1urHlmNwhUP89IeKHz1PfJ12es2ArTwkYibAh3Y0soOib2rjA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501192_1&quot; data-recommend-article-time=&quot;1630718700&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UG0pYPldneUCCVsPia3Rtr9j3hlFHakhItFlOXuwLicUqQvP1PhkTM28CUU9BpRCWfWPfHYredCBiaA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;推荐一个互联网企业级别的开源支付系统&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501192&amp;amp;idx=1&amp;amp;sn=444404a565f02a8c532d291d99678a7b&amp;amp;chksm=c1ca33b8f6bdbaaeb7c65d9f6f0c399f609fb203f065b6e88a3ad5431473713dbb5ae3507b32#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501192&amp;amp;idx=1&amp;amp;sn=444404a565f02a8c532d291d99678a7b&amp;amp;chksm=c1ca33b8f6bdbaaeb7c65d9f6f0c399f609fb203f065b6e88a3ad5431473713dbb5ae3507b32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;推荐一个互联网企业级别的开源支付系统&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-09-04&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UG0pYPldneUCCVsPia3Rtr9j3hlFHakhItFlOXuwLicUqQvP1PhkTM28CUU9BpRCWfWPfHYredCBiaA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501176_1&quot; data-recommend-article-time=&quot;1629509100&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VQRwetNLhDOB2Ej0fDZK4eRXsYlRNicgmsWwmuvlhibooic3N3su1lbMQPqWD186JiaOC5yJ9iaaic8bzw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;推荐一套开源通用后台管理系统（附源码）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501176&amp;amp;idx=1&amp;amp;sn=68e3ae7a9dc33fbbd379906ddcefdf5b&amp;amp;chksm=c1ca3348f6bdba5e1774625745f5ef40081c9b8eb0189073734b6808efb872720781d25b8dc0#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501176&amp;amp;idx=1&amp;amp;sn=68e3ae7a9dc33fbbd379906ddcefdf5b&amp;amp;chksm=c1ca3348f6bdba5e1774625745f5ef40081c9b8eb0189073734b6808efb872720781d25b8dc0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;推荐一套开源通用后台管理系统（附源码）&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-08-21&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4265625&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VQRwetNLhDOB2Ej0fDZK4eRXsYlRNicgmsWwmuvlhibooic3N3su1lbMQPqWD186JiaOC5yJ9iaaic8bzw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501153_1&quot; data-recommend-article-time=&quot;1627704022&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UbyFoOMqOObokEYiahCar20LiaY8ZLGKzU7NYQQoGycgnhrmIzNJibPicGcNia3cbbXlYib6bcLJVV5aww/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;一款神仙接私活儿软件，吊到不行！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501153&amp;amp;idx=1&amp;amp;sn=bb29cffa56431b72a92709c0ae993af7&amp;amp;chksm=c1ca3351f6bdba4729c671cdcd0ee8b6af75c6ce8a7003e6c032942b849aab5bfedecd0f9d3b#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501153&amp;amp;idx=1&amp;amp;sn=bb29cffa56431b72a92709c0ae993af7&amp;amp;chksm=c1ca3351f6bdba4729c671cdcd0ee8b6af75c6ce8a7003e6c032942b849aab5bfedecd0f9d3b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;一款神仙接私活儿软件，吊到不行！&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-07-31&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4265625&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UbyFoOMqOObokEYiahCar20LiaY8ZLGKzU7NYQQoGycgnhrmIzNJibPicGcNia3cbbXlYib6bcLJVV5aww/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501139_1&quot; data-recommend-article-time=&quot;1626571500&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VGxZrbRFy96Sm9cXQzVEhiaLibUUYhYH1SJL4HUXenau3DCeq0KEOsguY4CWjaEd1BeAicJd24qFM2w/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;基于 SpringBoot 的仿豆瓣平台【源码分享】&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501139&amp;amp;idx=1&amp;amp;sn=f133e70bda8abae27459ccc4d3d6d8fd&amp;amp;chksm=c1ca3363f6bdba75b9a4145510d9b6108c56146a3146b2e2e6d660a08221618b01c815d55642#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501139&amp;amp;idx=1&amp;amp;sn=f133e70bda8abae27459ccc4d3d6d8fd&amp;amp;chksm=c1ca3363f6bdba75b9a4145510d9b6108c56146a3146b2e2e6d660a08221618b01c815d55642&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;基于 SpringBoot 的仿豆瓣平台【源码分享】&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-07-18&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42427884615384615&quot; data-type=&quot;jpeg&quot; data-w=&quot;832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VGxZrbRFy96Sm9cXQzVEhiaLibUUYhYH1SJL4HUXenau3DCeq0KEOsguY4CWjaEd1BeAicJd24qFM2w/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501105_1&quot; data-recommend-article-time=&quot;1623979500&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7Xw68Ow8vZian4lanQFAu09f4JOZlXbC85jsByb8V6StkOpibAdgPamPWoPPY3G7S3nic50QvxxuGNrg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;干掉 Wordpress！这个开源建站神器有点吊！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501105&amp;amp;idx=1&amp;amp;sn=caf01186b6d2e4a38e940ce07d822238&amp;amp;chksm=c1ca3301f6bdba17ba7127da24e28963ae40f944e587f14b57405e2a9ee9d8cdbcb835c880c8#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501105&amp;amp;idx=1&amp;amp;sn=caf01186b6d2e4a38e940ce07d822238&amp;amp;chksm=c1ca3301f6bdba17ba7127da24e28963ae40f944e587f14b57405e2a9ee9d8cdbcb835c880c8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;干掉 Wordpress！这个开源建站神器有点吊！&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-06-18&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42578125&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7Xw68Ow8vZian4lanQFAu09f4JOZlXbC85jsByb8V6StkOpibAdgPamPWoPPY3G7S3nic50QvxxuGNrg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501098_2&quot; data-recommend-article-time=&quot;1623461160&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VzIP6xibP6U8htKa7YEad1iaTE02ZbsOfvDX1D8LoTiaNsMVgdjFOdm5LahpnNXFe3ibSp8S4FJ39KkA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;从朋友那里搞了 20 个实战项目，速领！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4#rd&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;从朋友那里搞了 20 个实战项目，速领！&lt;/a&gt;&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;2021-06-12&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;200&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VzIP6xibP6U8htKa7YEad1iaTE02ZbsOfvDX1D8LoTiaNsMVgdjFOdm5LahpnNXFe3ibSp8S4FJ39KkA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Baq5lYpIw7X6YPYGQITyP8Zdk96ab7CX0Ind5E05VokoepTP9Adic0xRwiaQrAvfTeC7iafngRibhBShpVqibqNcCCA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如有收获，点个在看，诚挚感谢&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100018364&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;19&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54JM0xl7WLNGnqqwbcXQBWIOCMuOgPHRoOjMamXzrCqMS2xgOo5ibic9icPk7u3zsVgic3s1ZUYJ4xHXg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/article&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c925175d79b9e0def393817cb2f4cf99</guid>
<title>保证接口数据安全的10种方案</title>
<link>https://toutiao.io/k/iau6qc3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们日常开发中，如何保证接口数据的安全性呢？&lt;/span&gt;&lt;span&gt;个人觉得，接口数据安全的保证过程，主要体现在这几个方面：&lt;/span&gt;&lt;span&gt;一个就是&lt;/span&gt;&lt;strong&gt;数据传输&lt;/strong&gt;&lt;span&gt;过程中的安全，还有就是数据到达服务端，如何&lt;/span&gt;&lt;strong&gt;识别数据&lt;/strong&gt;&lt;span&gt;，最后一点就是&lt;/span&gt;&lt;strong&gt;数据存储的安全性&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;今天跟大家聊聊保证接口数据安全的10个方案。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7857829010566763&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpx3EvJCgacLBDjyicVxxr5eYibgLHAXtM0PldRL3vt5Ghwk1mrOBB5UjJclbdhgb239RERuF8Wr1wsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1041&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.数据加密，防止报文明文传输。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，数据在网络传输过程中，很容易被抓包。如果使用的是http协议，因为它是明文传输的，用户的数据就很容易被别人获取。所以需要对数据加密。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 数据如何加密呢？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的实现方式，就是对&lt;strong&gt;关键字段&lt;/strong&gt;加密。比如，你一个登录的接口，你可以对&lt;strong&gt;密码&lt;/strong&gt;加密。一般用什么加密算法呢？简单点可以使用&lt;strong&gt;对称加密算法&lt;/strong&gt;（如&lt;code&gt;AES&lt;/code&gt;）来加解密，或者哈希算法处理（如&lt;code&gt;MD5&lt;/code&gt;）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;什么是&lt;strong&gt;对称加密&lt;/strong&gt;：加密和解密使用相同密钥的加密算法。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28663101604278074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpx3EvJCgacLBDjyicVxxr5eYzJg55M3gzz8UWXjqt6lukiclAahia5bVwtjbfu0ASzicawBabfqXsI7sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;935&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;非对称加密&lt;/strong&gt;：非对称加密算法需要两个密钥（公开密钥和私有密钥）。&lt;strong&gt;公钥与私钥是成对存在的&lt;/strong&gt;，如果用公钥对数据进行加密，只有对应的私钥才能解密。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更安全的做法，就是用&lt;strong&gt;非对称加密算法&lt;/strong&gt;（如&lt;code&gt;RSA&lt;/code&gt;或者&lt;code&gt;SM2&lt;/code&gt;），公钥加密，私钥解密。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27947019867549666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpx3EvJCgacLBDjyicVxxr5eYubKlR07tkhdIfpsUL2dIM5FOYW08LyChwY6Ou3BrrjJBiavfibReEic5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;755&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想对所有字段都加密的话，一般都推荐使用&lt;strong&gt;https协议&lt;/strong&gt;。&lt;code&gt;https&lt;/code&gt;其实就是在&lt;code&gt;http&lt;/code&gt;和&lt;code&gt;tcp&lt;/code&gt;之间添加一层加密层SSL。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 小伙伴们，是否还记得https的原理呢？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试也经常问的，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8351851851851851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpx3EvJCgacLBDjyicVxxr5eYwO3PWiaZkJr9te6BLYT6zkRye3aov2XZJfQrA115pwmVmTXTT9aPfCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端发起Https请求，连接到服务器的443端口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器必须要有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端将公钥加密后的密钥发送到服务器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，这样子传输的数据都是密文啦。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器将加密后的密文返回到客户端。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常业务呢，数据传输加密这块的话，用&lt;strong&gt;https&lt;/strong&gt;就可以啦，如果安全性要求较高的，比如登录注册这些，需要传输密码的，密码就可以使用&lt;code&gt;RSA&lt;/code&gt;等非对称加密算法，对密码加密。如果你的业务，安全性要求很高，你可以模拟https这个流程，对报文，再做一次加解密。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 数据加签验签&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据报文加签验签，是&lt;strong&gt;保证数据传输安全的常用手段&lt;/strong&gt;，它可以保证数据在&lt;strong&gt;传输过程中不被篡改&lt;/strong&gt;。以前我做的&lt;strong&gt;企业转账系统&lt;/strong&gt;，就用了加签验签。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 什么是加签验签呢？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据加签&lt;/strong&gt;：用Hash算法（如&lt;code&gt;MD5，或者SHA-256&lt;/code&gt;）把原始请求参数生成报文摘要，然后用私钥对这个摘要进行加密，就得到这个报文对应的数字签名&lt;code&gt;sign&lt;/code&gt;（这个过程就是&lt;strong&gt;加签&lt;/strong&gt;）。通常来说呢，请求方会把&lt;strong&gt;数字签名和报文原文&lt;/strong&gt;一并发送给接收方。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24324324324324326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpx3EvJCgacLBDjyicVxxr5eYtf5BAq0h9ric2xIgrGpnLPib2RdlWvbLicZwLM2eN1bOPCNPE5ugrhMRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;验签&lt;/strong&gt;：接收方拿到原始报文和数字签名（&lt;code&gt;sign&lt;/code&gt;）后，用&lt;strong&gt;同一个Hash算法&lt;/strong&gt;(比如都用MD5)从报文中生成摘要A。另外，用对方提供的公钥对数字签名进行解密，得到摘要B，对比A和B是否相同，就可以得知报文有没有被篡改过。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5525525525525525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpx3EvJCgacLBDjyicVxxr5eYqE4SnU2P81HwqkOA2Q6yXUm5Pj8PPP6mWYcnI0jB1VicAI96kuqWQKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;strong&gt;加签&lt;/strong&gt;，我的理解的话，就是把请求参数，按照一定规则，利用&lt;code&gt;hash&lt;/code&gt;算法+加密算法生成一个&lt;strong&gt;唯一标签&lt;/strong&gt;&lt;code&gt;sign&lt;/code&gt;。&lt;strong&gt;验签的话&lt;/strong&gt;，就是把请求参数按照相同的规则处理，再用相同的&lt;code&gt;hash&lt;/code&gt;算法，和对应的密钥解密处理，以对比这个签名是否一致。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;再举个例子，有些小伙伴是这么实现的，将所有非空参数（包含一个包&lt;code&gt;AccessKey&lt;/code&gt;，&lt;strong&gt;唯一的开发者标识&lt;/strong&gt;）按照升序，然后再拼接个&lt;code&gt;SecretKey&lt;/code&gt;（这个仅作本地加密使用，不参与网络传输，它只是用作签名里面的），得到一个&lt;code&gt;stringSignTemp&lt;/code&gt;的值，最后用MD5运算，得到&lt;code&gt;sign&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;服务端收到报文后，会校验，只有拥有合法的身份&lt;code&gt;AccessKey&lt;/code&gt;和签名&lt;code&gt;Sign&lt;/code&gt;正确，才放行。这样就解决了身份验证和参数篡改问题，如果请求参数被劫持，由于劫持者获取不到&lt;code&gt;SecretKey&lt;/code&gt;（仅作本地加密使用，不参与网络传输），他就无法伪造合法的请求啦&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 有了https等加密数据，为什么还需要加签验签&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些小伙伴可能有疑问，加签验签主要是防止数据在传输过程中被篡改，那如果都用了&lt;code&gt;https&lt;/code&gt;下协议加密数据了，为什么还会被篡改呢？为什么还需要加签验签呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;数据在传输过程中被加密了，理论上，即使被抓包，数据也不会被篡改。但是&lt;strong&gt;https不是绝对安全&lt;/strong&gt;的哦。可以看下这个文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247494171&amp;amp;idx=1&amp;amp;sn=80479acae752311581258015faa41673&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;可怕，原来 HTTPS 也没用&lt;/a&gt;。还有一个点：&lt;code&gt;https&lt;/code&gt;加密的部分只是在外网，然后有很多服务是内网相互跳转的，加签也可以在&lt;strong&gt;这里保证不被中间人篡改&lt;/strong&gt;，所以一般转账类安全性要求高的接口开发，都需要&lt;strong&gt;加签验签&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.token授权认证机制&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发中，我们的网站或者APP，都是需要&lt;strong&gt;用户登录&lt;/strong&gt;的。那么如果是&lt;strong&gt;非登录接口&lt;/strong&gt;，是如何确保安全，如何确认用户身份的呢？可以使用&lt;strong&gt;token&lt;/strong&gt;授权机制。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 token的授权认证方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;token的授权认证方案&lt;/strong&gt;：用户在客户端输入用户名和密码，点击登录后，服务器会校验密码成功，会给客户端返回一个唯一值&lt;code&gt;token&lt;/code&gt;，并将&lt;code&gt;token&lt;/code&gt;以键值对的形式存放在缓存（一般是Redis）中。后续客户端对需要授权模块的所有操作都要带上这个&lt;code&gt;token&lt;/code&gt;，服务器端接收到请求后，先进行&lt;code&gt;token&lt;/code&gt;验证，如果&lt;code&gt;token&lt;/code&gt;存在，才表明是合法请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;token登录授权流程图如下：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7514677103718199&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpx3EvJCgacLBDjyicVxxr5eYelFMslIKYTT6bm5GM1468yZFsxSic34x2JIr13n7H7xia9giaEgA4qBBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1022&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户输入用户名和密码，发起登录请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端校验密码，如果校验通过，生成一个全局唯一的&lt;code&gt;token&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将&lt;code&gt;token&lt;/code&gt;存储在&lt;code&gt;redis&lt;/code&gt;中，其中&lt;code&gt;key&lt;/code&gt;是&lt;code&gt;token&lt;/code&gt;，&lt;code&gt;value&lt;/code&gt;是&lt;code&gt;userId&lt;/code&gt;或者是用户信息，设置一个过期时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把这个&lt;code&gt;token&lt;/code&gt;返回给客户端&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户发起其他业务请求时，需要带上这个&lt;code&gt;token&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后台服务会统一拦截接口请求，进行&lt;code&gt;token&lt;/code&gt;有效性校验，并从中获取用户信息，供后续业务逻辑使用。如果&lt;code&gt;token&lt;/code&gt;不存在，说明请求无效。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 如何保证token的安全？token被劫持呢？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们如何保证token的安全呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说，我如果拿到&lt;code&gt;token&lt;/code&gt;，是不是就可以调用服务器端的任何接口？可以从这几个方面出发考虑：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;token设置合理的有效期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用https协议&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;token可以再次加密&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果访问的是敏感信息，单纯加token是不够的，通常会再配置白名单&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;说到token，有些小伙伴们可能会想起jwt，即（JSON Web Token），其实它也是token的一种。有兴趣的小伙伴可以去了解一下哈。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 时间戳timestamp超时机制&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据是很容易抓包的，假设我们用了&lt;code&gt;https&lt;/code&gt;和加签，即使中间人抓到了数据报文，它也看不到真实数据。但是有些不法者，他根本不关心真实的数据，而是直接拿到抓取的数据包，进行恶意请求（比如&lt;strong&gt;DOS攻击&lt;/strong&gt;），以搞垮你的系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以引入&lt;strong&gt;时间戳超时机制&lt;/strong&gt;，来保证接口安全。就是：用户每次请求都带上当前时间的时间戳&lt;code&gt;timestamp&lt;/code&gt;，服务端接收到&lt;code&gt;timestamp&lt;/code&gt;后，解密，验签通过后，与服务器当前时间进行比对，如果时间差大于一定时间 (比如3分钟)，则认为该请求无效。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.timestamp+nonce方案防止重放攻击&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间戳超时机制也是有漏洞的，如果是在&lt;strong&gt;时间差内&lt;/strong&gt;，黑客进行的重放攻击，那就不好使了。可以使用&lt;code&gt;timestamp+nonce&lt;/code&gt;方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;nonce&lt;/code&gt;指唯一的随机字符串，用来标识每个被签名的请求。我们可以将每次请求的&lt;code&gt;nonce&lt;/code&gt;参数存储到一个“set集合”中，或者可以json格式存储到数据库或缓存中。每次处理HTTP请求时，首先判断该请求的&lt;code&gt;nonce&lt;/code&gt;参数是否在该“集合”中，如果存在则认为是非法请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而对服务器来说，永久保存&lt;code&gt;nonce&lt;/code&gt;的代价是非常大的。可以结合&lt;code&gt;timestamp&lt;/code&gt;来优化。因为&lt;code&gt;timstamp&lt;/code&gt;参数对于超过&lt;code&gt;3min&lt;/code&gt;的请求，都认为非法请求，所以我们只需要存储&lt;code&gt;3min&lt;/code&gt;的&lt;code&gt;nonce&lt;/code&gt;参数的“集合”即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 限流机制&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户本来就是就是真实用户，他恶意频繁调用接口，想搞垮你的系统呢？这种情况就需要接入限流了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;Guava&lt;/code&gt;的&lt;code&gt;RateLimiter&lt;/code&gt;单机版限流，也可以使用&lt;code&gt;Redis&lt;/code&gt;分布式限流，还可以使用阿里开源组件&lt;code&gt;sentinel&lt;/code&gt;限流。比如说，一分钟可以接受多少次请求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 黑名单机制&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发现了真实用户恶意请求,你可以搞个黑名单机制，把该用户拉黑。一般情况，会有些竞争对手，或者不怀好意的用户，想搞你的系统的。所以，为了保证安全，一般我们的业务系统，需要有个黑名单机制。对于黑名单发起的请求，直接返回错误码好了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.白名单机制&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了黑名单机制，也可以搞个白名单机制啦。以前我负责的企业转账系统，如果有外面的商户要接入我们的系统时，是需要提前申请网络白名单的。那时候运维会申请个IP网络白名单，只有白名单里面的请求，才可以访问我们的转账系统。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.数据脱敏掩码&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于密码，或者手机号、身份证这些敏感信息，一般都需要脱敏掩码再展示的，如果是密码，还需要加密再保存到数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于手机号、身份证信息这些，日常开发中，在日志排查时，看到的都应该是掩码的。目的就是尽量不泄漏这些用户信息，虽然能看日志的只是开发和运维，但是还是需要防一下，做掩码处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于密码保存到数据库，我们肯定不能直接明文保存。最简单的也需要&lt;code&gt;MD5&lt;/code&gt;处理一下再保存，&lt;code&gt;Spring Security&lt;/code&gt;中的 &lt;code&gt;BCryptPasswordEncoder&lt;/code&gt;也可以，它的底层是采用&lt;code&gt;SHA-256 +随机盐+密钥&lt;/code&gt;对密码进行加密，而&lt;code&gt;SHA和MD&lt;/code&gt;系列是一样的，都是&lt;code&gt;hash&lt;/code&gt;摘要类的算法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. 数据参数一些合法性校验。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口数据的安全性保证，还需要我们的系统，有个数据合法性校验，简单来说就是&lt;strong&gt;参数校验&lt;/strong&gt;，比如身份证长度，手机号长度，是否是数字等等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文给大家介绍了10种保证接口数据安全的方案。小伙伴们，如有还有其他方案的话，可以在留言区评论哈，一起交流学习。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8b777dbeda2db9cdfa2c05ccc631ba9c</guid>
<title>Kubernetes网络插件详解 - Calico篇 - 概述</title>
<link>https://toutiao.io/k/o1jkkib</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;巨子嘉&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;juzijia-club&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;容器，微服务及开源产品在大企业中的平台产品化建设之路&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>58e39853a717e3ae048e44b0ef524ee5</guid>
<title>MySQL索引背后的数据结构及算法原理</title>
<link>https://toutiao.io/k/5c8yrjk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;一、摘要&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章主要内容分为三个部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;二、数据结构及算法基础&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;索引的本质&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一个例子：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5051020408163265&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkMXalGYSMHMPjq6p9VfKKlRQx17YH5kmdHM1PPfiaa9fOSN0NVKibfoutQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;588&quot;/&gt;&lt;figcaption&gt;图1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在 &lt;code&gt;O(log_2n)&lt;/code&gt; 的复杂度内获取到相应数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;B-Tree和B+Tree&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;B-Tree&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;d为大于1的一个正整数，称为B-Tree的度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;h为一个正整数，称为B-Tree的高度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个非叶子节点由n-1个key和n个指针组成，其中d&amp;lt;=n&amp;lt;=2d。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有叶节点具有相同的深度，等于树高h。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key和指针互相间隔，节点两端是指针。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个节点中的key从左到右非递减排列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有节点组成树结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个指针要么为null，要么指向另外一个节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于(v(key_1))，其中(v(key_1))为node的第一个key的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于(v(key_m))，其中(v(key_m))为node的最后一个key的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某个指针在节点node的左右相邻key分别是(key_i)和(key_{i+1})且不为null，则其指向节点的所有key小于(v(key_{i+1}))且大于(v(key_i))。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图2是一个d=2的B-Tree示意图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25109170305676853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkMpcOcjDpFEuxEWSQc07xfxEdiaxLsx0eGwnKSZickibkLoQjWsXK2tER5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;458&quot;/&gt;&lt;figcaption&gt;图2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;BTree_Search(node, key) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node == null) &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;    foreach(node.key)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(node.key[i] == key) &lt;span&gt;return&lt;/span&gt; node.data[i];&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(node.key[i] &amp;gt; key) &lt;span&gt;return&lt;/span&gt; BTree_Search(point[i]-&amp;gt;node);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; BTree_Search(point[i+1]-&amp;gt;node);&lt;br/&gt;}&lt;br/&gt;data = BTree_Search(root, my_key);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为 &lt;code&gt;log_d((N+1)/2)&lt;/code&gt;，检索一个key，其查找节点个数的渐进复杂度为 &lt;code&gt;O(log_dN)&lt;/code&gt; 。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;B+Tree&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与B-Tree相比，B+Tree有以下不同点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个节点的指针上限为2d而不是2d+1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内节点不存储data，只存储key；叶子节点不存储指针。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图3是一个简单的B+Tree示意。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35174953959484345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkMMaomV70skIzoDFvrh50wicA6T5OEsAiasVZLmV6KL2YNibwgJe163AJzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;543&quot;/&gt;&lt;figcaption&gt;图3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;带有顺序访问指针的B+Tree&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35174953959484345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkMRqfNYuibwpwyzOWEjLwVeshVJZrbMv3c833jHrZ7Apx986F3GZicv53g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;543&quot;/&gt;&lt;figcaption&gt;图4&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;为什么使用B-Tree（B+Tree）&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;主存存取原理&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.599476439790576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkMqoKmz1FpUX8BqGMgHULic2qwuLU2ZmAX2X2ibic8usXE70bf2mDpL9Wibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;382&quot;/&gt;&lt;figcaption&gt;图5&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主存的存取过程如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;磁盘存取原理&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图6是磁盘的整体结构示意图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6441947565543071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkMLVKqHxGWM6BLjVpnPnuOSJSsR0UPic0VPF5cgVtIWsmY9VibicAS9FZAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;267&quot;/&gt;&lt;figcaption&gt;图6&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图7是磁盘结构的示意图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9144981412639405&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkMhePthU1ydMvYwNbTMWy0exNz5FprY3aJA1uVkBnFpax2YlibBqeoYibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;269&quot;/&gt;&lt;figcaption&gt;图7&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;局部性原理与磁盘预读&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个数据被用到时，其附近的数据也通常会马上被使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序运行期间所需要的数据通常比较集中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;B-/+Tree索引的性能分析&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里终于可以分析B-/+Tree索引的性能了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为(O(h)=O(log_dN))。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上所述，用B-Tree作为索引结构效率是非常高的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而红黑树这种结构，h明显要深得多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;d_{max}=floor(pagesize / (keysize + datasize + pointsize))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;三、MySQL索引实现&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;MyISAM索引实现&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8042168674698795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkM3gGL0r3Z0ggnNfgO7cCuz4tJqUzLhEIHPMU3nhAic8SmqHQUQ3bHkKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;figcaption&gt;图8&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8042168674698795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkM0d1vSFTdKLOUDR6icgtYPHT8YMtnpRYdMX948gMribWd7icOqs0vDxy9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;figcaption&gt;图9&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样也是一棵B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB索引实现&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4438305709023941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkMPAZ821EwCFJr60p8YdBoo0uqdeVD9rbhiczmrQd0cgXbqfDEHVsJuEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;543&quot;/&gt;&lt;figcaption&gt;图10&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4088397790055249&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkMfXRDlVWPaH4lC8wNBeGdsWfViadC80m3W5kgYahpia4yaDvv2y74B0NA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;543&quot;/&gt;&lt;figcaption&gt;图11&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下一章将具体讨论这些与索引有关的优化策略。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;四、索引使用策略及优化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;示例数据库&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7863145258103241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkMBKmz1qLDCGUiboB6dnYre0iaiat0v2wTHYNcic1dQEH1logag0Jk7SJIcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;figcaption&gt;图12&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL官方文档中关于此数据库的页面为https://dev.mysql.com/doc/employee/en/。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;最左前缀原理与相关优化&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&amp;lt;a1, a2, …, an&amp;gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以employees.titles表为例，下面先查看其上都有哪些索引：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;SHOW&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; employees.titles;&lt;br/&gt;+&lt;span&gt;--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+&lt;/span&gt;&lt;br/&gt;| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |&lt;br/&gt;+&lt;span&gt;--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+&lt;/span&gt;&lt;br/&gt;| titles |          0 | PRIMARY  |            1 | emp_no      | A         |        NULL |      | BTREE      |&lt;br/&gt;| titles |          0 | PRIMARY  |            2 | title       | A         |        NULL |      | BTREE      |&lt;br/&gt;| titles |          0 | PRIMARY  |            3 | from_date   | A         |      443308 |      | BTREE      |&lt;br/&gt;| titles |          1 | emp_no   |            1 | emp_no      | A         |      443308 |      | BTREE      |&lt;br/&gt;+&lt;span&gt;--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果中可以到titles表的主索引为&amp;lt;emp_no, title, from_date&amp;gt;，还有一个辅助索引&amp;lt;emp_no&amp;gt;。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; employees.titles &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; emp_no;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可以专心分析索引PRIMARY的行为了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;情况一：全列匹配。&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles &lt;span&gt;WHERE&lt;/span&gt; emp_no=&lt;span&gt;&#x27;10001&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; title=&lt;span&gt;&#x27;Senior Engineer&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; from_date=&lt;span&gt;&#x27;1986-06-26&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles &lt;span&gt;WHERE&lt;/span&gt; from_date=&lt;span&gt;&#x27;1986-06-26&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; emp_no=&lt;span&gt;&#x27;10001&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; title=&lt;span&gt;&#x27;Senior Engineer&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效果是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;情况二：最左前缀匹配。&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles &lt;span&gt;WHERE&lt;/span&gt; emp_no=&lt;span&gt;&#x27;10001&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+---------+---------+-------+------+-------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+---------+---------+-------+------+-------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |       |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+---------+---------+-------+------+-------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当查询条件精确匹配索引的左边连续一个或几个列时，如&amp;lt;emp_no&amp;gt;或&amp;lt;emp_no, title&amp;gt;，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles &lt;span&gt;WHERE&lt;/span&gt; emp_no=&lt;span&gt;&#x27;10001&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; from_date=&lt;span&gt;&#x27;1986-06-26&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&amp;lt;emp_no, from_date&amp;gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们看下title一共有几种不同的值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;DISTINCT&lt;/span&gt;(title) &lt;span&gt;FROM&lt;/span&gt; employees.titles;&lt;br/&gt;+&lt;span&gt;--------------------+&lt;/span&gt;&lt;br/&gt;| title              |&lt;br/&gt;+&lt;span&gt;--------------------+&lt;/span&gt;&lt;br/&gt;| Senior Engineer    |&lt;br/&gt;| Staff              |&lt;br/&gt;| Engineer           |&lt;br/&gt;| Senior Staff       |&lt;br/&gt;| Assistant Engineer |&lt;br/&gt;| Technique Leader   |&lt;br/&gt;| Manager            |&lt;br/&gt;+&lt;span&gt;--------------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles&lt;br/&gt;&lt;span&gt;WHERE&lt;/span&gt; emp_no=&lt;span&gt;&#x27;10001&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;AND&lt;/span&gt; title &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;&#x27;Senior Engineer&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Staff&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Engineer&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Senior Staff&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Assistant Engineer&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Technique Leader&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Manager&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;AND&lt;/span&gt; from_date=&lt;span&gt;&#x27;1986-06-26&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |    7 | Using where |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;SHOW&lt;/span&gt; &lt;span&gt;PROFILES&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----------+------------+-------------------------------------------------------------------------------+&lt;/span&gt;&lt;br/&gt;| Query_ID | Duration   | Query                                                                         |&lt;br/&gt;+&lt;span&gt;----------+------------+-------------------------------------------------------------------------------+&lt;/span&gt;&lt;br/&gt;|       10 | 0.00058000 | &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles &lt;span&gt;WHERE&lt;/span&gt; emp_no=&lt;span&gt;&#x27;10001&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; from_date=&lt;span&gt;&#x27;1986-06-26&#x27;&lt;/span&gt;|&lt;br/&gt;|       &lt;span&gt;11&lt;/span&gt; | &lt;span&gt;0.00052500&lt;/span&gt; | &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles &lt;span&gt;WHERE&lt;/span&gt; emp_no=&lt;span&gt;&#x27;10001&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; title &lt;span&gt;IN&lt;/span&gt; ...          |&lt;br/&gt;+&lt;span&gt;----------+------------+-------------------------------------------------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;情况四：查询条件没有指定索引第一列。&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles &lt;span&gt;WHERE&lt;/span&gt; from_date=&lt;span&gt;&#x27;1986-06-26&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+------+---------+------+--------+-------------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+------+---------+------+--------+-------------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+------+---------+------+--------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于不是最左前缀，索引这样的查询显然用不到索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;情况五：匹配某列的前缀字符串。&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles &lt;span&gt;WHERE&lt;/span&gt; emp_no=&lt;span&gt;&#x27;10001&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; title &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;&#x27;Senior%&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 56      | NULL |    1 | Using where |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时可以用到索引，但是如果通配符不是只出现在末尾，则无法使用索引。（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;情况六：范围查询。&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles &lt;span&gt;WHERE&lt;/span&gt; emp_no &amp;lt; &lt;span&gt;&#x27;10010&#x27;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; title=&lt;span&gt;&#x27;Senior Engineer&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles&lt;br/&gt;&lt;span&gt;WHERE&lt;/span&gt; emp_no &amp;lt; &lt;span&gt;&#x27;10010&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;AND&lt;/span&gt; title=&lt;span&gt;&#x27;Senior Engineer&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;AND&lt;/span&gt; from_date &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;&#x27;1986-01-01&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;&#x27;1986-12-31&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles&lt;br/&gt;&lt;span&gt;WHERE&lt;/span&gt; emp_no &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;&#x27;10001&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;&#x27;10010&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;AND&lt;/span&gt; title=&lt;span&gt;&#x27;Senior Engineer&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;AND&lt;/span&gt; from_date &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;&#x27;1986-01-01&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;&#x27;1986-12-31&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |   16 | Using where |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;情况七：查询条件中含有函数或表达式。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles &lt;span&gt;WHERE&lt;/span&gt; emp_no=&lt;span&gt;&#x27;10001&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;left&lt;/span&gt;(title, &lt;span&gt;6&lt;/span&gt;)=&lt;span&gt;&#x27;Senior&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.titles &lt;span&gt;WHERE&lt;/span&gt; emp_no - &lt;span&gt;1&lt;/span&gt;=&lt;span&gt;&#x27;10000&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+------+---------+------+--------+-------------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+------+---------+------+--------+-------------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |&lt;br/&gt;+&lt;span&gt;----+-------------+--------+------+---------------+------+---------+------+--------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工撕下代数运算，转换为无表达式的查询语句。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;索引选择性与前缀索引&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Index Selectivity = Cardinality / #T&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;DISTINCT&lt;/span&gt;(title))/&lt;span&gt;count&lt;/span&gt;(*) &lt;span&gt;AS&lt;/span&gt; Selectivity &lt;span&gt;FROM&lt;/span&gt; employees.titles;&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;| Selectivity |&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;|      0.0000 |&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图12可以看到employees表只有一个索引&amp;lt;emp_no&amp;gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.employees &lt;span&gt;WHERE&lt;/span&gt; first_name=&lt;span&gt;&#x27;Eric&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; last_name=&lt;span&gt;&#x27;Anido&#x27;&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+&lt;/span&gt;&lt;br/&gt;| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |&lt;br/&gt;+&lt;span&gt;----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+&lt;/span&gt;&lt;br/&gt;|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |&lt;br/&gt;+&lt;span&gt;----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建&amp;lt;first_name&amp;gt;或&amp;lt;first_name, last_name&amp;gt;，看下两个索引的选择性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;DISTINCT&lt;/span&gt;(first_name))/&lt;span&gt;count&lt;/span&gt;(*) &lt;span&gt;AS&lt;/span&gt; Selectivity &lt;span&gt;FROM&lt;/span&gt; employees.employees;&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;| Selectivity |&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;|      0.0042 |&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;DISTINCT&lt;/span&gt;(&lt;span&gt;concat&lt;/span&gt;(first_name, last_name)))/&lt;span&gt;count&lt;/span&gt;(*) &lt;span&gt;AS&lt;/span&gt; Selectivity &lt;span&gt;FROM&lt;/span&gt; employees.employees;&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;| Selectivity |&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;|      0.9313 |&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&amp;lt;first_name&amp;gt;显然选择性太低，&amp;lt;first_name, last_name&amp;gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&amp;lt;first_name, left(last_name, 3)&amp;gt;，看看其选择性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;DISTINCT&lt;/span&gt;(&lt;span&gt;concat&lt;/span&gt;(first_name, &lt;span&gt;left&lt;/span&gt;(last_name, &lt;span&gt;3&lt;/span&gt;))))/&lt;span&gt;count&lt;/span&gt;(*) &lt;span&gt;AS&lt;/span&gt; Selectivity &lt;span&gt;FROM&lt;/span&gt; employees.employees;&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;| Selectivity |&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;|      0.7879 |&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;DISTINCT&lt;/span&gt;(&lt;span&gt;concat&lt;/span&gt;(first_name, &lt;span&gt;left&lt;/span&gt;(last_name, &lt;span&gt;4&lt;/span&gt;))))/&lt;span&gt;count&lt;/span&gt;(*) &lt;span&gt;AS&lt;/span&gt; Selectivity &lt;span&gt;FROM&lt;/span&gt; employees.employees;&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;| Selectivity |&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;|      0.9007 |&lt;br/&gt;+&lt;span&gt;-------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时选择性已经很理想了，而这个索引的长度只有18，比&amp;lt;first_name, last_name&amp;gt;短了接近一半，我们把这个前缀索引 建上：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; employees.employees&lt;br/&gt;&lt;span&gt;ADD&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; &lt;span&gt;`first_name_last_name4`&lt;/span&gt; (first_name, last_name(&lt;span&gt;4&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时再执行一遍按名字查询，比较分析一下与建索引前的结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;SHOW&lt;/span&gt; &lt;span&gt;PROFILES&lt;/span&gt;;&lt;br/&gt;+&lt;span&gt;----------+------------+---------------------------------------------------------------------------------+&lt;/span&gt;&lt;br/&gt;| Query_ID | Duration   | Query                                                                           |&lt;br/&gt;+&lt;span&gt;----------+------------+---------------------------------------------------------------------------------+&lt;/span&gt;&lt;br/&gt;|       87 | 0.11941700 | &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.employees &lt;span&gt;WHERE&lt;/span&gt; first_name=&lt;span&gt;&#x27;Eric&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; last_name=&lt;span&gt;&#x27;Anido&#x27;&lt;/span&gt; |&lt;br/&gt;|       &lt;span&gt;90&lt;/span&gt; | &lt;span&gt;0.00092400&lt;/span&gt; | &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; employees.employees &lt;span&gt;WHERE&lt;/span&gt; first_name=&lt;span&gt;&#x27;Eric&#x27;&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; last_name=&lt;span&gt;&#x27;Anido&#x27;&lt;/span&gt; |&lt;br/&gt;+&lt;span&gt;----------+------------+---------------------------------------------------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能的提升是显著的，查询速度提高了120多倍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB的主键选择与插入优化&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一棵B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40045766590389015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkMDCMXfNx5ibCIH7hPF4suxz363sAsQLAiakg81ZwrAU0dQpUW2fFn0NtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;437&quot;/&gt;&lt;figcaption&gt;图13&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新记录都要被插到现有索引页的中间某个位置：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7641921397379913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2uKjNbrKmY7xicgs1lLGZkMf3SyXDw606IicFNUbn8HhOGUVGF3wibagTERo9AMnmRoAZ2KCQRYLDRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;229&quot;/&gt;&lt;figcaption&gt;图14&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，只要可以，请尽量在InnoDB上采用自增字段做主键。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;五、后记&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章断断续续写了半个月，主要内容就是上面这些了。不可否认，这篇文章在一定程度上有纸上谈兵之嫌，因为我本人对MySQL的使用属于菜鸟级别，更没有太多数据库调优的经验，在这里大谈数据库索引调优有点大言不惭。就当是我个人的一篇学习笔记了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实数据库索引调优是一项技术活，不能仅仅靠理论，因为实际情况千变万化，而且MySQL本身存在很复杂的机制，如查询优化策略和各种引擎的实现差异等都会使情况变得更加复杂。但同时这些理论是索引调优的基础，只有在明白理论的基础上，才能对调优策略进行合理推断并了解其背后的机制，然后结合实践中不断的实验和摸索，从而真正达到高效使用MySQL索引的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，MySQL索引及其优化涵盖范围非常广，本文只是涉及到其中一部分。如与排序（ORDER BY）相关的索引优化及覆盖索引（Covering index）的话题本文并未涉及，同时除B-Tree索引外MySQL还根据不同引擎支持的哈希索引、全文索引等等本文也并未涉及。如果有机会，希望再对本文未涉及的部分进行补充吧。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;六、参考文献&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[1] Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[2] Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[3] 姜承尧 著；MySQL技术内幕-InnoDB存储引擎；机械工业出版社，2011&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[4] D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[5] Codd, E. F. (1970). &quot;A relational model of data for large shared data banks&quot;. Communications of the ACM, , Vol. 13, No. 6, pp. 377-387&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[6] MySQL5.6参考手册 - https://dev.mysql.com/doc/refman/5.6/en/&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1263d33f2a3bac34bba45454a01b9b54</guid>
<title>kLoop：直通Linux内核的高性能asyncio</title>
<link>https://toutiao.io/k/jdbwm17</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;来源 | OSCHINA 社区&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者 | Fantix&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;本文适合有一定编程基础的同学阅读，但不要求有任何专业方向的经验。写作目的，一是撺掇各路英豪一起做开源，二是记录一下新项目的选型设计和概念验证过程。全文小一万字（知乎那个字数统计……），阅读时间大概一下午（连同摆弄代码的时间）。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;之前介绍 EdgeDB 历史的那篇文章里有提到，EdgeDB 的 I/O 目前十分依赖 Python asyncio。为了提升 EdgeDB 的速度，Yury 基于 libuv（就是 Node.js 底层的 I/O 库）搞出了人气颇高的 uvloop，最近能预见的几个 EdgeDB 版本都还是会用 uvloop。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与此同时，我们一直在探索进一步提升 I/O 性能的方法，比如用 Linux 内核的 TLS 支持（kTLS）来承接 SSL 连接、用多进程加共享内存来优化多核 I/O，甚至于是用 Rust 重写 EdgeDB 的 I/O 部分等等。我在研究的过程中发现了新的宝藏 io_uring，并用几个周末的时间简单写了点概念验证，于是就有了今天的新坑：kLoop。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://gitee.com/fantix/kloop&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;kLoop 与 uvloop 对仗，k 表示 Linux 内核（Kernel），主要想法是用内核的 io_uring 和 kTLS 功能来直接实现一个高效率的 asyncio 事件循环，因为我琢磨着这两个人应该是一对儿非常完美的搭档，理论上应该可以把 asyncio 的效率再提升一个档次。接下来我就稍微展开说说，欢迎有兴趣的同学一起跳坑。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术选型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;io_uring：免系统调用的 I/O&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;熟悉 io_uring 的同学可以放心跳过这一节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的应用程序通常会对磁盘和网络进行操作，而这些 I/O 操作都需要操作系统的配合才能完成，这就需要应用程序去调用操作系统的相应接口，而这类调用就叫做&lt;strong&gt;系统调用&lt;/strong&gt;（syscall），比如用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;read()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来读取文件，或者用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;send()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来发送网络数据。不管你用的什么编程语言，这些操作在底层基本上都是要做系统调用的。以 Linux 为例，如果仔细观察进程 CPU 的占用率，就能看到每个进程都有 user 占比和 system 占比，这个 system 占比就是该进程花在系统调用上的时间。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;fantix@fantix-jammy:~$&lt;/span&gt; &lt;span&gt;time&lt;/span&gt; &lt;span&gt;curl&lt;/span&gt; &lt;span&gt;https://gitee.com&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;/dev/null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;%&lt;/span&gt; &lt;span&gt;Total&lt;/span&gt;    &lt;span&gt;%&lt;/span&gt; &lt;span&gt;Received&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;Xferd&lt;/span&gt;  &lt;span&gt;Average&lt;/span&gt; &lt;span&gt;Speed&lt;/span&gt;   &lt;span&gt;Time&lt;/span&gt;    &lt;span&gt;Time&lt;/span&gt;     &lt;span&gt;Time&lt;/span&gt;  &lt;span&gt;Current&lt;/span&gt;&lt;br/&gt;                                 &lt;span&gt;Dload&lt;/span&gt;  &lt;span&gt;Upload&lt;/span&gt;   &lt;span&gt;Total&lt;/span&gt;   &lt;span&gt;Spent&lt;/span&gt;    &lt;span&gt;Left&lt;/span&gt;  &lt;span&gt;Speed&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;35991&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt; &lt;span&gt;35991&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;     &lt;span&gt;0&lt;/span&gt;  &lt;span&gt;23711&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;--:--:--&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:00:01&lt;/span&gt; &lt;span&gt;--:--:--&lt;/span&gt; &lt;span&gt;23709&lt;/span&gt;&lt;span&gt;real&lt;/span&gt;&lt;span&gt;0m1.527suser&lt;/span&gt;&lt;span&gt;0m0.070ssys&lt;/span&gt;&lt;span&gt;0m0.005s&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24813631522896698&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRcTvrw96R9vzzovb6Tbxe3c3NgicSfESAWCwlI0ic1RaNEHY2YKI4C6Pqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;939&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Munin 记录下的 CPU 使用率&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然系统调用可能会非常频繁，但这种调用并不是没有性能开销的 —— 除了操作系统花在实际执行一次系统调用所需的时间外，在 user 和 system 模式之间切换也是需要时间的。这个开销虽然单次仅有约几百到上千纳秒，但架不住多啊 —— 比如 asyncio 的事件循环每一次至少要 &lt;/span&gt;&lt;code&gt;&lt;span&gt;epoll()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 一次吧，有进展的 socket 各自又有一次读或写，万一没成功下回还得重试。高并发下，一秒几百次的事件循环，每次循环几十上百次 I/O，光系统调用的额外开销就要占到毫秒级别了。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;epoll() 是 Linux 上的高性能事件通知设施，可以同时监视多个文件描述符（比如 socket）的事件状态，如某个 TCP 连接成功了，或者某个 socket 收到消息了等等。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果能把这些系统调用都放在操作系统里一并完成，不仅能够省去 user 和 system 来回切换的时间，更是抛开了接口封装的枷锁，在内核中直接完成许多之前不好搞的骚操作（比如异步磁盘 I/O），岂不美哉？这就是 io_uring 诞生的原因。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;io_uring 是脸书的一个同学开发的，从 5.1 就进 Linux 内核主线了，但陆续改进到 5.11 才有了 kLoop 需要的全部功能，并且仍在持续改进中。笼统来讲，应用程序用内存映射（mmap）的方式拿到两条与内核共享的环状队列，通过其中一条队列（SQ）给内核源源不断的布置任务，然后从另外一条队列（CQ）获取结果；内核则按需进行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;epoll()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，并在一个线程池中执行就绪的任务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9149377593360996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRcgzRNfdz7hibFtMubQtDyWwr3EePjtXd4bnMrKtcZkia5hI1yxcec4E3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;io_uring 大致架构&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一些常见的系统调用，如打开文件、读写文件、socket 操作等等，都可以通过 io_uring 来完成。而应用程序所需要做的，只是一些内存操作，告诉内核要做什么，读写缓冲区在哪里。这里仍然有少量的一些系统调用来控制 io_uring 本身，但都是实现细节了。一些初步的测评显示，io_uring 能比普通 epoll 快出 5% 至 40%。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;kTLS：内核和网卡参与计算&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;我们再来看一个现代网络编程里的大头开销 ——TLS（也叫 SSL）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;包括 EdgeDB 在内的许多数据库都会建议或要求启用 TLS；HTTP 就更不用说了，你要是后面不带个 S 都不好意思跟别人打招呼；就连 DNS 也有加密版的了，所以 TLS 已经成为了一种公共网络基础设施。而信息的可逆熵增是需要花费能量的，加密解密的运算仍是一笔不小的开销。以 EdgeDB 为例，在 uvloop 已经大幅优化了其 TLS 实现的前提下，TLS 仍然带来了比明文流量高 15%～20% 的额外开销。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TLS 的加密算法分为两部分：集中在连接建立的握手阶段的非对称加密，和集中在数据传输阶段的对称加密。自然地，非对称加密主要影响 TLS 连接的建立速度，对称加密则对实际数据的传输速度有影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自 Linux 4.13 起，部分对称加密运算可以在内核中直接完成。这又是脸书小伙伴们的作品，并且在硬件支持的情况下，可以直接把运算工作扔给网卡来做，彻底解放 CPU。这个功能官方叫做 Kernel TLS，我们随大众的叫法，简称为 kTLS。常见 Linux 发行版似乎都构建了这一模块，就叫 tls，只需 modprobe 加载后即可使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5155601659751037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRct7PicMtGnE127wSflNRRPYzsoyQtUe18FmkaonPnMoSBp4tvd0GNkOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;kTLS 可以在 io_uring 的线程池中运行，也可以代工给网卡&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从这张图就能看出来，为什么 io_uring 和 kTLS 是天生一对了 —— 如果网卡不支持加密运算，那么 io_uring 的线程池正好可以给 kTLS 用来做运算池！这就意味着，你的应用程序哪怕只有一个线程，理论上也可以舔着脸去抢多核 CPU 的资源。GIL 手动打出了一个狗头……&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;CPython 的全局解释器锁（GIL）是一种用来保证 Python 代码在多线程环境中正确执行的同步机制，任何线程只要运行 Python 代码就得先获取这把锁，除非只有一个线程，或者某些函数的底层实现会主动释放 GIL 一段时间。GIL 带来的副作用就是，多线程的 Python 程序往往很难有效地利用多核 CPU 资源。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;集成 OpenSSL&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;对称加密基本上解决了，接下来还需要看看非对称加密怎么办。因为与 TLS certificate 交互包含了许多用户应用逻辑，并不像对称加密那么直截了当，因此内核并不支持 TLS 非对称加密部分，需要由用户自己完成 TLS 握手， 然后把协商出来的对称密钥交给内核，内核才能接管连接加解密。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为 kLoop 终究是 Python 库，所以 TLS 握手自然要用到 CPython 最常搭配的 OpenSSL。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;OpenSSL 自 3.0 起开始支持 kTLS 发包代工，收包代工则需要最新的 3.1 开发版本。按照 NGINX 的说法，单是发包代工就已经能提供约 30% 的性能提升了（配合了原生 &lt;/span&gt;&lt;code&gt;&lt;span&gt;sendfile()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，io_uring 也可以通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;splice()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 实现）。其实，我们完全可以用 OpenSSL 1.1 进行 TLS 握手， 只不过 OpenSSL 封装的比较死，取对称密钥和序列号的手法比较脏（靠 key log 和内存指针偏移量）。再加上无法向 OpenSSL 1.1 直接提供明文数据，所以一旦内核接管了对称加密，所有的 TLS 控制消息就都废了，要么就得你自己编码解析；rekeying/renegotiation 就更别想了，更别说 TLS 1.3 还有 early data 什么的，握手都不一定能握完整，对安全性还是有挺大不确定性的。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;TLS 的消息（Record）有多种类型，kTLS 将其分为应用数据消息（application data）和控制消息（control data，包括 TLS 的 alert、handshake 等非 application_data 的 Record）。&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;索性我们就选择 OpenSSL 3.0 吧，毕竟刚刚发布的 Ubuntu 22.04 就是 OpenSSL 3.0，加上 Linux 5.15 和 Python 3.10，够了。实现细节上，我们需要实现一个定制的 BIO，把里面的 I/O 部分拿出来自己搞，让 OpenSSL 3.0 去协调什么时候是明文、什么时候需要自己加解密就好了。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BIO 全称为基本输入输出，是 OpenSSL 对各种输入输出流封装出来的一个接口，比如 socket 有 socket BIO，文件有文件 BIO，OpenSSL 也允许我们提供自定义的 BIO 实现。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;直接接驳 OpenSSL 并不意味着我们要抛弃 Python 的 SSL 实现。我们可以通过一个简单的头文件，把 Python &lt;/span&gt;&lt;code&gt;&lt;span&gt;SSLSocket&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象中的 OpenSSL &lt;/span&gt;&lt;code&gt;&lt;span&gt;SSL*&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指针暴露出来（这里用的是 Cython 语法）：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;cdef extern &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;openssl/ssl.h&quot;&lt;/span&gt; nogil:&lt;br/&gt;    ctypedef struct SSL:        &lt;span&gt;pass&lt;/span&gt;cdef extern &lt;span&gt;from&lt;/span&gt; *:    &lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;    typedef struct {&lt;br/&gt;        PyObject_HEAD&lt;br/&gt;        PyObject *Socket; /* weakref to socket on which we&#x27;re layered */&lt;br/&gt;        SSL *ssl;&lt;br/&gt;    } PySSLSocket;&lt;br/&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    ctypedef struct PySSLSocket:&lt;br/&gt;        SSL* ssl&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;有了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SSL*&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指针，就可以调用 OpenSSL 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SSL_set_options()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数来启用 kTLS 了。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Cython：胶水语言的胶水&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;如果说 Python 是用来粘合多元宇宙的胶水语言，那么 Cython 就是胶水中的胶水 —— 它与 C 语言的互操作性无可比拟。uvloop、asyncpg 和 EdgeDB 都大量用到了 Cython 编码，kLoop 也做出了同样的选择。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Cython 代码有着类似 Python 的语法，但是却会被编译成 C 代码，最终编译出可供 Python 导入的原生扩展模块。这些模块就可以动态（或者静态！）链接一些需要用到的 C 语言的库，比如链接 OpenSSL 来完成 kTLS 的握手，再比如链接 libc 来实现通往 Linux 内核的系统调用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以自定义 OpenSSL BIO 为例，我们首先把 OpenSSL 的头文件中需要用到的部分用 Cython 重新定义出来：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;cdef &lt;span&gt;extern&lt;/span&gt; from &lt;span&gt;&quot;openssl/bio.h&quot;&lt;/span&gt; nogil:&lt;br/&gt;    ctypedef &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Method&lt;/span&gt; &quot;&lt;span&gt;BIO_METHOD&lt;/span&gt;&quot;:&lt;/span&gt;&lt;br/&gt;        pass&lt;br/&gt;&lt;br/&gt;    ctypedef &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;BIO&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        pass    &lt;span&gt;int&lt;/span&gt; get_new_index &lt;span&gt;&quot;BIO_get_new_index&quot;&lt;/span&gt; ()&lt;br/&gt;&lt;br/&gt;    Method* meth_new &lt;span&gt;&quot;BIO_meth_new&quot;&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; type, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* name)    &lt;span&gt;int&lt;/span&gt; meth_set_write_ex &lt;span&gt;&quot;BIO_meth_set_write_ex&quot;&lt;/span&gt; (&lt;br/&gt;        Method* biom,        &lt;span&gt;int&lt;/span&gt; (*bwrite)(BIO*, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*, &lt;span&gt;size_t&lt;/span&gt;, &lt;span&gt;size_t&lt;/span&gt;*),&lt;br/&gt;    )&lt;br/&gt;&lt;br/&gt;    BIO* &lt;span&gt;new&lt;/span&gt; &lt;span&gt;&quot;BIO_new&quot;&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; Method* type)    &lt;span&gt;void&lt;/span&gt; set_retry_write &lt;span&gt;&quot;BIO_set_retry_write&quot;&lt;/span&gt; (BIO *b)&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这里我们引入了两个结构体和 5 个函数。C 语言没有命名空间的概念，所以 OpenSSL 为了避免重复，为 BIO 相关的名称添加了 BIO_ 的前缀；但我们用的是 Cython，可以把这个文件保存为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;openssl/bio.pxd&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，这样就可以通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;from openssl cimport bio&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的方式，自然地拿到一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;bio.&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的命名空间，因此在定义中我们进行了重命名，使其更符合 Python 的行为方式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随后我们就可以开始自定义 BIO 了。首先需要一个新的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;BIO_METHOD*&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 空间：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;openssl cimport bio&lt;/span&gt;&lt;span&gt;cdef&lt;/span&gt; &lt;span&gt;bio.Method* KTLS_BIO_METHOD = bio.meth_new(&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;bio.get_new_index(),&lt;/span&gt; &lt;span&gt;&quot;kTLS BIO&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;然后实现 BIO 的各个函数，并且设置到这个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;BIO_METHOD*&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 上。以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;write_ex()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为例：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt; &lt;section&gt;&lt;span&gt;cdef &lt;span&gt;int&lt;/span&gt; &lt;span&gt;bio_write_ex&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    bio.BIO* b, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* data, size_t datal, size_t* written&lt;br/&gt;)&lt;/span&gt; nogil:&lt;br/&gt;    with gil:        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&#x27;bio_write&#x27;&lt;/span&gt;, data[:datal], &amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;data)&lt;/span&gt;&lt;br/&gt;    bio.&lt;span&gt;set_retry_write&lt;/span&gt;&lt;span&gt;(b)&lt;/span&gt;&lt;br/&gt;    written[0] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;bio.meth_set_write_ex(KTLS_BIO_METHOD, bio_write_ex)&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;因为我们还没有开始真正实现 kLoop 的功能，所以这里暂时只是虚晃一 Q (???)，告诉 OpenSSL 这次啥也没写进去，还得重试。然而真正值得注意的是这里 &lt;/span&gt;&lt;code&gt;&lt;span&gt;nogil&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;with gil&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的用法：&lt;/span&gt;&lt;code&gt;&lt;span&gt;nogil&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 用在方法签名上，标志着这个函数可以安全地用在 C 语言环境中，比如被设置成为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;BIO_METHOD*&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的一个回调函数。nogil 的函数也同时意味着，这个函数执行时不保证拿到了 Python 的 GIL，因此内部不能有任何的 Python 结构，除非在一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;with gil&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 上下文中。这也是为什么我们在用 Python 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;print()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的时候，需要先用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;with gil&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来获取 Python GIL 的原因。你问我为什么要用 Python 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;print()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而不是用 C 语言的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;printf()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;？因为 Python 好用啊！&lt;/span&gt;&lt;code&gt;&lt;span&gt;data[:datal]&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 就直接把数据显示出来了， &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;int&amp;gt;data&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 还能看地址，用来调试代码再方便不过了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后就可以用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;bio.new(KTLS_BIO_METHOD)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来创建自定义的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;BIO*&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象，做任何喜欢做的事情了。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开始制作 kLoop&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;有了前面的概念验证，我们选出了四种技术：Linux 5.11 的 io_uring、kTLS、OpenSSL 3.0 和 Cython。接下来就是把他们真正放到一起，制作出 kLoop 来了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先是作为事件循环基础的 io_uring（文档：《I/O 指环王》）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;io_uring 的接口其实十分简单，只有三个系统调用：setup、enter 和 register。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;io_uring_setup&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：顾名思义，用来设置一个新的 io_uring。每个应用程序都可以申请（多个）自己的 io_uring 实例，只需给定环形队列长度，setup 就会返回一个文件描述符，用以后续操作这个 io_uring 实例。setup 同时会给出几个指针，用来将环形队列 mmap 到用户空间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;io_uring_enter&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：这个系统调用会让 io_uring 实例开始工作，并一直阻塞到指定数量的任务完成后，或累计到指定的时间为止。io_uring 还有另外一种运行模式叫 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SQPOLL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，可以在 setup 的时候进行设置；在这种模式下，内核会单开一个线程来主动执行任务，而不需要 enter 来触发；只不过为了节省资源，这个线程会在空闲指定的时间后挂起，需要 enter 才能唤醒。这种模式尽管多开了一个线程，但性能更好，因此 kLoop 会启用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SQPOLL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;io_uring_register&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：register 是用来向内核注册常用文件或缓冲区的，据说能够提高效率，但是我目前还没有研究到。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;除了这三个系统调用之外，就是如何 mmap 出两个环形队列，以及如何使用 Linux 的头文件所定义的结构体，在内存中填充和使用这两个队列了。为了简化使用，io_uring 的作者还特意开发了一个 C 语言的封装库 liburing。但 kLoop 用到的部分其实非常简单直接，如果使用 liburing 反而会不方便，依赖链接也会是一个麻烦事。因此，kLoop 就选择了用 Cython 直接与内核通讯（用 libc 做系统调用，然后就是基于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;linux/io_uring.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 操作共享内存），一些关键逻辑和结构体就仿照 liburing 来做就好了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;io_uring 用到了一个很有趣的 C11 的无锁多线程同步支持，也就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;stdatomic.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 里的功能（需要 GCC 4.9）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 io_uring 来说，就是用户应用程序的线程和内核线程有可能同时操作环形队列，当竞争发生时，我们必须保证结果是完整的，不能出现数据丢失或重复的情况。多线程同步通常要上锁，但会牺牲部分性能，而 C11 正式引入的原子性操作不需要上锁，可以更高效地完成这一工作。具体来说，编译器会在处理原子性操作时，在 CPU 指令级别保证，不同的原子性操作不会同时发生 —— 哪怕是发生在不同 CPU 上面 —— 除非操作的内存对象不同，因此这种多线程同步的效率是非常高的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更重要的是，原子性操作可以按需阻止编译器的优化对多线程的影响。我们通常认为，按顺序写的代码也会按顺序执行；但其实，编译器和 CPU 有很大概率会把没有依赖关系的指令 “打乱”，在保证结果与顺序执行一样的前提下，优化指令顺序以达到更高的效率。这对于单线程应用来说是好事，但却是多线程的噩梦 —— 尤其多个线程还要访问共享的内存。原子指令则会告诉编译器，在该指令以前的代码必须不能被优化到该指令之后再执行，在该指令之后的代码同样需要等到该指令完成之后才能执行，这就是原子性操作内存顺序中最严格的 “顺序一致”（seq_cst）模式。除此之外，还有 acquire（后面的代码不能提前做）、release（前面的代码必须先完成）和 relaxed（编译器可随意优化，但原子性操作本身要保证不同时发生）。具体的例子就不展开讲了，在 kLoop 中的用法也都是参考 liburing 的，有兴趣看的同学可以开启英文模式阅读 GCC 的这一篇文档。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;asyncio 的基础循环&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;kLoop 的事件循环仿照了 asyncio 的默认实现，除了 I/O 部分用 io_uring 替代了之外，“就绪队列” 和 “计时队列” 的用法都是一样的。“就绪队列” 是一个普通的链表，表示下一次循环马上可以执行的任务；“计时队列” 是一个用最小二叉堆实现的优先队列，表示最近要执行的计时任务。每次循环的逻辑如下：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先计算这次循环能等待的最长时间 —— 如果就绪队列里有东西，那么我们就是 “一刻也不想多等”；否则的话，就是最多可以等到最近的计时任务必须开始执行时为止；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;然后进 I/O—— 调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;io_uring_enter()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，一直等到有就绪的任务，或者超时为止。就绪任务进就绪队列；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接着检查计时队列 —— 到时的任务就出计时队列，进就绪队列；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后就绪队列全部出列，然后一次性全部执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;asyncio 默认实现中，就绪队列用的是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;collections.deque&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，计时序列则是用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;heapq&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来操作一个普通的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;list&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。这些数据结构的执行效率都是非常高的，但是我们既然已经用 Cython 了，不如就把效率推到极致，用 Cython 来写不包含 Python 结构（&lt;/span&gt;&lt;code&gt;&lt;span&gt;nogil&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）的纯 C 代码，实现与 &lt;/span&gt;&lt;code&gt;&lt;span&gt;deque&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;heapq&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类似的功能。对于链表，我用数组做了一个环状队列，二叉堆则是直接仿照 CPython 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;heapq&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，用 Cython 实现了一个 C 的版本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，循环第二步的 “调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;io_uring_enter()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;” 并不是每次都执行，因为 kLoop 默认启用了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SQPOLL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，只要持续不断的提交 I/O 任务，内核线程就会一直工作，自动执行流水线上的任务；而 kLoop 只需从 CQ 上不断获取结果即可。那什么时候调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;io_uring_enter()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 呢？一，内核线程暂停了，而我们又提交了新的 I/O 任务；二，CQ 和就绪队列都空了，而我们又有时间可以等待 I/O。当满负荷工作时，这两个条件都不满足的概率还是相当大的，因此 kLoop 可以（偶尔）做到 “零系统调用” 运转。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后值得说明的是，在每次循环的这四个步骤中，前三个都是完全不需要 Python 参与的，所以不需要获取 GIL，完全在 C 的模式下跑，只有第四步才会获取一次 GIL，并一次性把就绪的任务都执行完。这么做可以最大程度地保证，关键路径上的代码都是 C 级别的速度（虽然单线程 GIL 都是 no-op），而且理论上可以让 Python 多线程稍微开心一点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;把所有东西放在一起就是这样的：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.0395010395010393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRcBuUqrwct96gaj7O84wvaHPD1dvzU9rmRSVRwTKEhibb53pickNUQcdYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;kLoop 架构图，Aaron 说像 Lucky Charms 卡通麦片的工厂&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;异步 DNS 解析&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;细心的同学可能发现了，上面的架构图里藏了一个到目前为止都没有提到过的东西 ——trust-dns。是的，为了实现异步 DNS 解析，kLoop 封装了一个 Rust 写的 trust-dns 解析器。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;选择 trust-dns 的原因主要是，别的高性能异步解析器对于异步运行时的支持都比较固定，只有 trust-dns 可以完全用 io_uring 来提供运行时，而且不仅是 TCP 和 UDP 连接可以自定义，连 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/etc/resolv.conf&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/etc/hosts&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件内容都可以自行提供。别的解析库像 c-ares 就只能给你一个文件描述符去 poll，而 libc 里的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getaddrinfo_a()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 则似乎是用多线程来实现的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为 DNS 解析属于实现细节，所以我没有用 Rust 和 Python 相互调用，而是直接使用了（我认为更简单的）Rust 和 C/Cython 的接口。毕竟，kLoop 的核心循环并不需要 GIL，把不需要 Python 参与的 DNS 解析放在此处也最为合适。解析请求就是一个域名的字符串，而解析结果则是一个 C 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SockAddr&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 结构体数组，这样一来 io_uring 就可以直接拿过来用在 socket 上了。恰巧，Rust 中的解析结果就是 C 结构体的封装，所以并不需要太麻烦的转换，就可以生成我们需要的结果。C 与 Rust 之间的互相调用就更简单了，就是互相调用对方定义的外部函数，只要注意参数类型转换就好了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最有趣的地方还是在于用基于 C 的 io_uring 来为 Rust 中的异步 trust-dns-resolver 提供一个定制化的运行时环境，换句话说，trust-dns-resolver 定义了一套异步 I/O 接口，解耦了像如何创建一个 TCP 连接、如何发送一个 UDP 数据包等操作，它自己则使用这套接口实现了 DNS 解析的功能，而任何人都可以提供一个不同的接口实现，以不同的方式完成底层的 I/O 操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust 的异步编程是另外一个话题了，虽然也是很有趣，但是这里就不展开说了，总之就是与 asyncio 大差不差，原理都是一样的。对于 kLoop，io_uring 的主循环自然不由 Rust 这边来控制，所以我们需要一个简单的 Executor 来跑 trust-dns-resolver 创建的 Task，这些 Task 会调用我们提供的运行时来创建 io_uring 的任务，这些任务完成之后又会 “唤醒” Rust 中的 Task，并在后续循环中继续执行，直到拿到我们需要的结果为止。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9210950080515298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRcUYOj3Dk0aX4Y6iaRsGfIdlO0wCVZtCsYfMCZZ0jNY6wkTB5WIc3RfHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1242&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Cython 混编 Rust 进行异步 DNS 解析&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;TCP 客户端和服务器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;回到 kLoop 本身，我们下一步要具体来实现 asyncio 的各种功能了，下面主要以 TCP 客户端为例来说明大体实现思路。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;asyncio 对 I/O 操作解耦提供了一对儿基本的概念：transport 由 asyncio 的实现来提供，代表了对 I/O 底层的最终封装；protocol 的实例由用户提供，指定了 I/O 事件发生时应该执行的用户代码。用户可以在 protocol 里写回调代码，然后调用 transport 的方法来操作 I/O。比如说用 asyncio 创建一个 TCP 客户端，用户需要提供目标地址和端口，以及一个用来创建 protocol 实例的工厂函数；asyncio 的实现则会实际创建一个 TCP 连接，返回一个封装了该 TCP 连接的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TCPTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 实例，以及一个通过给定工厂产生的、与该 transport 绑定的 protocol 实例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在制作 kLoop 时要实现的，就是这个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TCPTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，以及适时地调用 protocol 中的方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 io_uring 来说，一条 TCP 连接就是一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类型的文件描述符，所以我们的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TCPTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 定义就特别简单了：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;cdef&lt;/span&gt; &lt;span&gt;class TCPTransport:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;cdef&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; &lt;span&gt;fd&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;object&lt;/span&gt; &lt;span&gt;protocol&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;连接的过程就不详细展开了，无非就是调用前面的 DNS 解析，拿到一堆 IP 地址，然后挨个儿试。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关键在于发送和接收数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;io_uring 会在一个线程池中执行提交上来的任务，所以任务执行的顺序未必会同提交的顺序一致，甚至于先后提交的两个任务有可能会被同时执行。Linux 中，虽然 socket 数据的发送和接收操作本身是原子性的 —— 也就是说在一个 socket 上，多个线程同时发送或者多个线程同时接收并不会报错 —— 但这不代表数据不会乱。对于 TCP 来说，数据是有严格顺序的，因此底层代码在将多个并发 &lt;/span&gt;&lt;code&gt;&lt;span&gt;send()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的数据合并成一股时，大家通常认为数据有可能会乱掉，对于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;recv()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 也是一样，并且更没有道理并行接收。（UDP 是一个例外，发送的数据报文都是有固定大小限制的，再加上本身就没有顺序要求，因此多线程发送完全没有问题，接收也行但意义不大。）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此对于 kLoop 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TCPTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，我们需要一个自己搞一个发送队列，当目前已经提交了一个发送任务时，把数据临时放在这个发送队列里，上一个发送任务结束后再提交一个新的去发送剩下的。为了避免内存复制，我们自然是要把用户给我们的数据对象原封不动地放在队列里，但在创建发送任务时，我们可以用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;sendmsg()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的数据阵列（Vectored I/O）来一次性将全部积压的数据都发送出去，以节省任务数量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;相比较而言，接收数据就容易的多了。在连接创建之后，首先提交一个接收数据的任务。任务完成，拿到数据，紧接着再提交一个新的接收任务就好了，一直反复直到连接断开为止。因为用户代码处理数据 &lt;/span&gt;&lt;code&gt;&lt;span&gt;data_received()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是在 Python 中进行的，所以我们可以用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;call_soon()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 将其放在下一次循环里，而抓紧时间先创建下一个接收任务，以求吞吐量的最大化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42643391521197005&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRcF2ViaiaKoG7866zVSWAr2EaUM6xBXbgviaVxJn7CfYvm71BSrr5iamXPCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1604&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;kLoop 的 TCPTransport&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后聊一下流量控制。比如说，&lt;/span&gt;&lt;code&gt;&lt;span&gt;TCPTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;send()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数是非阻塞的，也就是说，用户可以卯足了劲儿一顿发，发到网卡都反应不过来，结果我们的发送队列就会占用大量内存。此时，我们的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TCPTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 应该及时看到缓冲区已经漾了，并且尽快通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Protocol&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;pause_writing()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数来通知用户：“别再发啦，歇会儿吧。”。虽然此时用户可以蛮不讲理地继续填鸭，但我们假设用户还是友善地给了我们喘息的机会。等到 io_uring 把该发的发得差不多了的时候，我们在通知用户 &lt;/span&gt;&lt;code&gt;&lt;span&gt;resume_writing()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 可以继续发了。这里缓冲区有一个警戒线（漾了）和一个安全线（缓过来了），用户可以通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TCPTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;set_write_buffer_limits()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数进行设置，我们在实现的时候则会记录下来，作为盯梢的目标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;反过来对于接收端，流量控制也是必要的，只不过不由我们的 TCPTransport 来控制。因为接收下来的数据是给用户处理的，所以用户有可能会遇到处理不过来的情况，或者压根儿这会儿就不想处理任何数据。此时，用户可以主动调用我们的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TCPTransport.pause_reading()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数来告知这一诉求，而我们只需要把当前的接收任务取消就可以打破这个接收循环了，等到用户调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;resume_reading()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 时， 再重新创建接收任务，重启循环。简单直接。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;实现 TLS&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;有了前面的基础，我们就可以开始上 TLS 了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，我们需要支持 Python 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SSLContext&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，因为这是 asyncio 使用 TLS 的唯一方式。从 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SSLContext&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 创建 TLS 连接有两种方式，一种是通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;wrap_socket()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 将一个普通的 Python socket 升级为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SSLSocket&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，另一种则是用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;wrap_bio()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来封装两个 OpenSSL 的 BIO（上层理论上须为 Python 自己封装的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;MemoryBIO&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象，但封装很简单，可以替换成任意 BIO）。前面选型的时候已经说过了，我们需要自定义一个用 io_uring 实现的 BIO，所以这里我们就用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;wrap_bio()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的方式来实现：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;from&lt;/span&gt; .includes.openssl cimport ssl &lt;span&gt;as&lt;/span&gt; ssl_h&lt;span&gt;from&lt;/span&gt; .includes.openssl.bio cimport BIO&lt;br/&gt;&lt;br/&gt;cdef extern &lt;span&gt;from&lt;/span&gt; *:    &lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;    typedef struct {&lt;br/&gt;        PyObject_HEAD&lt;br/&gt;        BIO *bio;&lt;br/&gt;        int eof_written;&lt;br/&gt;    } PySSLMemoryBIO;&lt;br/&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    ctypedef struct PySSLMemoryBIO:&lt;br/&gt;        BIO* bio&lt;br/&gt;        &lt;br/&gt;cdef object wrap_bio(ssl_context, bio.BIO* b, ...):&lt;br/&gt;    cdef pyssl.PySSLMemoryBIO* c_bio&lt;br/&gt;    py_bio = ssl.MemoryBIO()&lt;br/&gt;    c_bio = &amp;lt;pyssl.PySSLMemoryBIO*&amp;gt;py_bio&lt;br/&gt;    c_bio.bio, b = b, c_bio.bio    &lt;span&gt;try&lt;/span&gt;:&lt;br/&gt;        rv = ssl_context.wrap_bio(py_bio, py_bio, ...)&lt;br/&gt;        ssl_h.set_options(&lt;br/&gt;            (&amp;lt;pyssl.PySSLSocket*&amp;gt;rv._sslobj).ssl, ssl_h.OP_ENABLE_KTLS&lt;br/&gt;        )        &lt;span&gt;return&lt;/span&gt; rv    &lt;span&gt;finally&lt;/span&gt;:&lt;br/&gt;        c_bio.bio, b = b, c_bio.bio&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这里我们还是用类似的办法，把 Python &lt;/span&gt;&lt;code&gt;&lt;span&gt;MemoryBIO&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象中的 BIO 指针，换成我们自己的实现，然后通知 OpenSSL 启用 kTLS。在 kLoop 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TLSTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 里，我们就会先用这个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;wrap_bio()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数创建一个含有我们自己 BIO 实现的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SSLObject&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象，然后后续的 TLS 握手、数据收发和断开连接等操作就都通过这个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SSLObject&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来完成了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3620689655172414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRc1BBIiaIYOQHOgeAic3EYgrekKZd4nOVTS8o5htiauiaCdX6wIRalG55KIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1392&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TLSTransport 大致架构&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如说握手，我们就调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;do_handshake()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，底层从 Python 到 OpenSSL 会最终调用到我们的 BIO 来发送或接收数据，我们的 BIO 则会创建相应的 io_uring 任务并告诉 OpenSSL：“你得等等”，并且一路返回到我们的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TLSTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，抛出一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SSLWantReadError&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或者 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SSLWantWriteError&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。我们抓到这个异常，忽略掉，正常返回主循环即可。因为 io_uring 的任务完成时，会重新回到这个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TLSTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的握手流程，然后重试 &lt;/span&gt;&lt;code&gt;&lt;span&gt;do_handshake()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。那个时候，该发的已经发出去了，该收的也应该已经收到了，所以握手得以继续，直到完成为止。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同样的操作对于接收和发送数据也是一样的，只不过需要确保重试发送和接收时，缓冲区还得是同一个，因为 io_uring 的任务已经创建了，你不能过河拆桥，偷摸儿把缓冲区换掉就不地道了，人家那边还用着呢。所以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TLSTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的发送队列大体上与 TCP 类似，但发送时只能一个一个的发，并且只有在成功之后才能出列，不能批量处理了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;剩下的重点就在于 BIO 如何实现了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，每个 BIO 也得存一个文件描述符，代表了底层的 TCP 连接，收发数据全靠它。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其次，我们需要实现 BIO 的控制回调，尤其是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;BIO_CTRL_SET_KTLS&lt;/span&gt;&lt;/code&gt;&lt;span&gt;—— 这就是前面 &lt;/span&gt;&lt;code&gt;&lt;span&gt;OP_ENABLE_KTLS&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 I/O 实现。此时握手已经结束了或者即将结束，OpenSSL 会把启用 kTLS 所需的密钥啦、初始向量啦、读写序列号什么的都帮我们准备好，我们只需要调用 Linux 的接口启用 kTLS 即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后实现数据收发。最简单的自然是第一次收发，创建一个对应的 io_uring 任务然后返回 “得重试” 即可。但是这个任务不能就这么忘却了，它的回调需要至少做两件事：一，更新 BIO 的状态，记得说该任务已完成，下次重试记得返回成功；二，安排重试。所以呢，BIO 创建的 io_uring 任务得记得这个 BIO，还得记得上层的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TLSTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。BIO 也得保存两个状态，一个是当前是不是发送中，另一个是当前是不是接收中。重试时，给进来的缓冲区得与保存的状态一致，然后根据状态对应返回 “还得重试” 或者 “已经完成”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0855920114122681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRc0lHc9mdp1W4IhoDz9dUK1pG6zH1hPLHZaicMxFsFDbTlvcicDhxKKsyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1402&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;kLoop 的 TLS 握手流程&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“启用 kTLS 之后，接收到的数据不用再解密了，发送的数据也不用先加密了，这事儿谁管？” 反正不是 BIO 管。这就是 BIO 抽象的好处 —— 我只管 I/O，至于数据该怎么处理，那是 TLS 实现的事儿。因为 OpenSSL 3.0 已经搞定了这一块儿了，所以我们最初选 OpenSSL 3.0 也是为了偷这一个懒儿。另外，因为 OpenSSL 自己不会复制内存，所以只要我们老老实实地用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;recv_into()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;memoryview&lt;/span&gt;&lt;/code&gt;&lt;span&gt;， 那么不管是 kTLS 启用之前还是之后，都不会出现内存复制的额外开销。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;剩下还有一些边边角角的，比如 TLS 1.3 early data、rekeying 什么的 Python 暂不支持，再比如优雅断开连接或者降级为明文 TCP 倒是都能实现，篇幅所限就不深究了。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;任务拆分及下一步&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;这篇文章零零散散写了得两个多月了吧 —— 代码倒是没写几行 —— 到这里算是有了一个大概的蓝图了。先总结一下接下来要做的，都是可以直接认领的独立任务：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;把 TCP 连接的部分从 transport 里抽离出来，在 nogil 的 Cython 里实现 happy eyeballs 什么的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;完成 TCP 的客户端实现；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;完成 TCP 的服务器实现；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;完成 TLS 的实现；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;性能评测！看看到底能快多少；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DNS 部分还有很多 &lt;/span&gt;&lt;code&gt;&lt;span&gt;todo!()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，不实现的话会崩溃；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;加测试，把 uvloop 的测试套件搬过来；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;以上基本的功能有了就可以发个 0.1 版了，然后就可以胡搞乱搞了（有些也可以提前认领来做）：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TLS &lt;/span&gt;&lt;code&gt;&lt;span&gt;sendfile()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 王炸！写完了可以去跟 NGINX 比速度；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;UNIX domain socket？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;UDP？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持管道和子进程？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;系统信号、进程 fork 和多线程什么的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用 Rust 的各种 HTTP/1/2/3 库搞一个高性能 ASGI 服务器？…… 以及捎带手搞一个 WSGI 服务器？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持 Trio 的运行时？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;想到再加！&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;原文链接：https://my.oschina.net/fantix/blog/5538389&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97125&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;福利&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;369:391&quot;&gt;包邮送书&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;点击下方文章链接，查看活动详情~↓↓↓&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3232876712328767&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRK895Enrswh3w5yOcrlOaEeQ9Zz9XJQ52UdNnrsDybNaa2NGGQaE9oCy4sZfIWax0lU2Ribq2ib1MHVw/640?wx_fmt=png&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9978858350951374&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRK895Enrswh3w5yOcrlOaEeQMRtsY5GNjvylu7gLzOJvbCZia7ZmgWSFF5JPLa3QSRf77KI2W74ibOnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;473&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里有最新开源资讯、软件更新、技术干货等内容&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点这里 ↓↓↓ 记得 关注✔ 标星⭐ 哦~&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NzM0MjcyMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibFSaFOxzVguEFp6FiaPYUpGzFgCDzntuS0V3Z7aWqgs8a2aVAiaGNticiapKQczicXqW5HicAGTrIXphbA/0?wx_fmt=png&quot; data-nickname=&quot;OSC开源社区&quot; data-alias=&quot;oschina2013&quot; data-signature=&quot;开源中国，为开发者服务&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot; wah-hotarea=&quot;click&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>