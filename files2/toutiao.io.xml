<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b837c7e0e553f94a27a6d957fb16df3a</guid>
<title>Docker 使用过程中的一些技巧（1）</title>
<link>https://toutiao.io/k/zyfjqrp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mp-common-profile&quot; data-from=&quot;0&quot; data-id=&quot;MzAwOTU4NzM5Ng==&quot; data-alias=&quot;yudadanwx&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/5Wib5Wh04ugwID68icb2oFcuc8rPmySWAHaWnQsQD8ax6PxocJ6nruWaMfxoarXh1eicga9ENlQrUPFTh8LFeEX7w/0?wx_fmt=png&quot; data-nickname=&quot;虞大胆的叽叽喳喳&quot; data-signature=&quot;《深入浅出HTTPS：从原理到实战》作者。&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;p&gt;分享最近docker使用过程中的一些技巧，绝对是干货。&lt;/p&gt;&lt;p&gt;1：镜像下载加速&lt;/p&gt;&lt;p&gt;很多镜像加速地址可能会失效，这个需要甄别下，阿里云是每个用户一个地址，相对可能靠谱点：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&#x27;EOF&#x27;&lt;br/&gt;{&lt;br/&gt;  &quot;registry-mirrors&quot;: [&quot;https://**.mirror.aliyuncs.com&quot;]&lt;br/&gt;}&lt;br/&gt;EOF&lt;br/&gt;$ sudo systemctl daemon-reload&lt;br/&gt;$ sudo systemctl restart docker&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后校验：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ docker info&lt;br/&gt; Registry Mirrors:&lt;br/&gt;  https://**.mirror.aliyuncs.com/&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，如果阿里云加速站没有对应的镜像，还是会去官方下载，比如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ ss -ntp | grep dockerd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发现最终还是去cloudflare下载。&lt;/p&gt;&lt;p&gt;2：以非root账户构建镜像&lt;/p&gt;&lt;p&gt;自己的习惯，dockerd以root的方式运行，构建镜像则以非root用户，但默认会遇到权限问题，具体怎么解决呢？&lt;/p&gt;&lt;p&gt;让dockerd以docker用户组运行，而docker client的运行用户也属于docker用户组，这样就能解决，下面以centos说明。&lt;/p&gt;&lt;p&gt;添加docker用户组，将对应的用户加入到用户组，然后激活用户组，或者退出中断。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ sudo groupadd docker&lt;br/&gt;$ usermod -aG docker 用户&lt;br/&gt;$ newgrp docker&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 /usr/lib/systemd/system/docker.service文件中添加：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[Service]&lt;br/&gt;Group=docker&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重新启动dockerd：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ systemctl restart docker.service&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3：Dockerfile 构建的时候如何避免cache&lt;/p&gt;&lt;p&gt;在Dockerfile中构建，一些命令会cached，但有些命令是不希望这样的，比如git拉取最新代码，怎么解决呢？&lt;/p&gt;&lt;p&gt;在Dockerfile文件中加入：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ARG CACHEBUST=1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后构建的时候输入：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ docker build --build-arg CACHEBUST=$(date +%s)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就能解决了。&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6270f1a86ac5d2fab720ea0e3f480d2d</guid>
<title>golang 中如何实现带超时时间的锁？</title>
<link>https://toutiao.io/k/4lgyj3k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;fmt&quot;&gt;
          &lt;h1 id=&quot;heading&quot;&gt;开源实现推荐&lt;/h1&gt;
&lt;p&gt;go-lock是一个 Golang 库，使用以下内置机制实现高效的读写锁：&lt;/p&gt;
&lt;p&gt;具有超时机制的互斥量&lt;br/&gt;
锁扣&lt;br/&gt;
不饿的读写解决方案&lt;br/&gt;
本机sync/Mutex，sync/RWMutex非常强大和可靠。但是，如果没有按预期释放锁，那就成了一场灾难。或者，有人在高峰时间持有锁的时间过长导致整个系统被阻塞。处理这些情况，go-lock除了 Lock 和 Unlock 之外还实现TryLock和功能TryLockWithTimeout。TryLockWithContext它提供了控制资源的灵活性。&lt;/p&gt;
&lt;h2 id=&quot;heading-1&quot;&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;go get github.com/viney-shih/go-lock
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;demo&quot;&gt;demo&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
&quot;fmt&quot;
&quot;sync/atomic&quot;
&quot;time&quot;

lock &quot;github.com/viney-shih/go-lock&quot;
)

func main() {
// set RWMutex with CAS mechanism (CASMutex).
var rwMut lock.RWMutex = lock.NewCASMutex()
// set default value
count := int32(0)

// block here
rwMut.Lock()
go func() {
time.Sleep(50 * time.Millisecond)
fmt.Println(&quot;Now is&quot;, atomic.AddInt32(&amp;amp;count, 1)) // Now is 1
rwMut.Unlock()
}()

// waiting for previous goroutine releasing the lock, and locking it again
rwMut.Lock()
fmt.Println(&quot;Now is&quot;, atomic.AddInt32(&amp;amp;count, 2)) // Now is 3

// TryLock without blocking
// Return false, because the lock is not released.
fmt.Println(&quot;Return&quot;, rwMut.TryLock())

// RTryLockWithTimeout without blocking
// Return false, because the lock is not released.
fmt.Println(&quot;Return&quot;, rwMut.RTryLockWithTimeout(50*time.Millisecond))

// TryLockWithContext without blocking
ctx, cancel := context.WithTimeout(context.TODO(), 50*time.Millisecond)
defer cancel()
// Return false, because the lock is not released.
fmt.Println(&quot;Return&quot;, rwMut.TryLockWithContext(ctx))

// release the lock in the end.
rwMut.Unlock()

// Output:
// Now is 1
// Now is 3
// Return false
// Return false
// Return false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;heading-2&quot;&gt;地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/viney-shih/go-lock&quot;&gt;https://github.com/viney-shih/go-lock&lt;/a&gt;&lt;/p&gt;

        &lt;/article&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>56656313ac2edd64e972b95929283cd6</guid>
<title>一文看懂分布式链路监控系统</title>
<link>https://toutiao.io/k/t3mjds0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;blockquote data-first-child=&quot;&quot; data-pid=&quot;Twv5PYHv&quot;&gt;本文通过阿里的Eagleeye（鹰眼）和开源的Skywalking，从数据模型、数据埋点以及数据存储三个方面介绍分布式链路监控系统的实现细节，其中将重点介绍Skywalking字节码增强的实现方案。&lt;/blockquote&gt;&lt;p data-pid=&quot;U-33nFPE&quot;&gt;作者 | 张亦驰(怀潜)&lt;/p&gt;&lt;p data-pid=&quot;N2efWhwT&quot;&gt;来源 | 阿里开发者公众号&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p data-pid=&quot;KwXut6UZ&quot;&gt;传统的大型单体系统随着业务体量的增大已经很难满足市场对技术的需求，通过对将整块业务系统拆分为多个互联依赖的子系统并针对子系统进行独立优化，能够有效提升整个系统的吞吐量。在进行系统拆分之后，完整的业务事务逻辑所对应的功能会部署在多个子系统上，此时用户的一次点击请求会触发若干子系统之间的相互功能调用，如何分析一次用户请求所触发的多次跨系统的调用过程、如何定位存在响应问题的调用链路等等问题是链路追踪技术所要解决的问题。&lt;/p&gt;&lt;p data-pid=&quot;4jXwrqEG&quot;&gt;举一个网络搜索的示例，来说明这样一个链路监控系统需要解决的一些挑战。当用户在搜索引擎中输入一个关键词后，一个前端服务可能会将这次查询分发给数百个查询服务，每个查询服务在其自己的索引中进行搜索。该查询还可以被发送到许多其他子系统，这些子系统可以处理敏感词汇、检查拼写、用户画像分析或寻找特定领域的结果，包括图像、视频、新闻等。所有这些服务的结果有选择地组合在一起，最终展示在搜索结果页面中，我们将这个模型称为一次完整的搜索过程。&lt;/p&gt;&lt;p data-pid=&quot;1NJlYGZI&quot;&gt;在这样一次搜索过程中，总共可能需要数千台机器和许多不同的服务来处理一个通用搜索查询。此外，在网络搜索场景中，用户的体验和延迟紧密相关，一次搜索延时可能是由于任何子系统的性能不佳造成的。开发人员仅考虑延迟可能知道整个系统存在问题，但却无法猜测哪个服务有问题，也无法猜测其行为不良的原因。首先，开发人员可能无法准确知道正在使用哪些服务，随时都可能加入新服务和修改部分服务，以增加用户可见的功能，并改进性能和安全性等其他方面；其次，开发人员不可能是庞大系统中每个内部微服务的专家，每一个微服务可能有不同团队构建和维护；另外，服务和机器可以由许多不同的客户端同时共享，因此性能问题可能是由于另一个应用的行为引起。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;Dapper简介&lt;/h2&gt;&lt;p data-pid=&quot;-Q4K7tOQ&quot;&gt;在分布式链路追踪方面，Google早在2010年针对其内部的分布式链路跟踪系统&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Dapper&lt;/a&gt;，发表了相关论文对分布式链路跟踪技术进行了介绍（强烈推荐阅读）。其中提出了两个基本要求。第一，拥有广泛的覆盖面。针对庞大的分布式系统，其中每个服务都需要被监控系统覆盖，即使是整个系统的一小部分没有被监控到，该链路追踪系统也可能是不可靠的。第二，提供持续的监控服务。对于链路监控系统，需要7*24小时持续保障业务系统的健康运行，保证任何时刻都可以及时发现系统出现的问题，并且通常情况下很多问题是难以复现的。根据这两个基本要求，分布式链路监控系统的有如下几个设计目标：&lt;/p&gt;&lt;p data-pid=&quot;iUTt6IEB&quot;&gt;链路监控组件应该以基础通用组件的方式提供给用户，以提高稳定性，应用开发者不需要关心它们。对于Java语言来说，方法可以说是调用的最小单位，想要实现对调用链的监控埋点势必对方法进行增强。Java中对方法增强的方式有很多，比如直接硬编码、动态代理、字节码增强等等。应用级透明其实是一个比较相对的概念，透明度越高意味着难度越大，对于不同的场景可以采用不同的方式。&lt;/p&gt;&lt;p data-pid=&quot;ENKENEG0&quot;&gt;低开销是链路监控系统最重要的关注点，分布式系统对于资源和性能的要求本身就很苛刻，因此监控组件必须对原服务的影响足够小，将对业务主链路的影响降到最低。链路监控组件对于资源的消耗主除了体现在增强方法的消耗上，其次还有网络传输和数据存储的消耗，因为对于链路监控系统来说，想要监控一次请求势必会产生出请求本身外的额外数据，并且在请求过程中，这些额外的数据不仅会暂时保存在内存中，在分布式场景中还会伴随着该请求从上游服务传输至下游服务，这就要求产生的额外数据尽可能地少，并且在伴随请求进行网络传输的时候只保留少量必要的数据。&lt;/p&gt;&lt;p data-pid=&quot;vD_-ib21&quot;&gt;无论是何种软件系统，可扩展性和开放性都是衡量其质量优劣的重要标准。对于链路监控系统这样的基础服务系统来说，上游业务系统对于链路监控系统来说是透明的，在一个规模较大的企业中，一个基础服务系统往往会承载成千上万个上游业务系统。每个业务系统由不同的团队和开发人员负责，虽然使用的框架和中间件在同一个企业中有大致的规范和要求，但是在各方面还是存在差异的。因此作为一个基础设施，链路监控系统需要具有非常好的可扩展性，除了对企业中常用中间件和框架的支撑外，还要能够方便开发人员针对特殊的业务场景进行定制化的开发。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;数据模型&lt;/h2&gt;&lt;h2&gt;OpenTracing规范&lt;/h2&gt;&lt;p data-pid=&quot;yVk2M7BC&quot;&gt;Dapper将请求按照三个维度划分为&lt;b&gt;Trace、Segment、Span&lt;/b&gt;三种模型，该模型已经形成了&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/opentracing-contrib/opentracing-specification-zh/blob/master/specification.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;OpenTracing&lt;/a&gt;规范。OpenTracing是为了描述分布式系统中事务的语义，而与特定下游跟踪或监控系统的具体实现细节无关，因此描述这些事务不应受到任何特定后端数据展示或者处理的影响。大的概念就不多介绍了，重点看一下Trace、Segment、Span这三种模型到底是什么。&lt;/p&gt;&lt;p data-pid=&quot;zN8Wi8bK&quot;&gt;表示一整条调用链，包括跨进程、跨线程的所有Segment的集合。&lt;/p&gt;&lt;p data-pid=&quot;Ey9rcmta&quot;&gt;表示一个进程（JVM）或线程内的所有操作的集合，即包含若干个Span&lt;/p&gt;&lt;p data-pid=&quot;HrvAlJTE&quot;&gt;表示一个具体的操作。Span在不同的实现里可能有不同的划分方式，这里介绍一个比较容易理解的定义方式：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;R3pcPsEz&quot;&gt;Entry Span：入栈Span。Segment的入口，一个Segment有且仅有一个Entry Span，比如HTTP或者RPC的入口，或者MQ消费端的入口等。&lt;/li&gt;&lt;li data-pid=&quot;X5ANiyou&quot;&gt;Local Span：通常用于记录一个本地方法的调用。&lt;/li&gt;&lt;li data-pid=&quot;M-rUOlTv&quot;&gt;Exit Span：出栈Span。Segment的出口，一个Segment可以有若干个Exit Span，比如HTTP或者RPC的出口，MQ生产端，或者DB、Cache的调用等。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;SyOLggjK&quot;&gt;按照上面的模型定义，一次用户请求的调用链路图如下所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-522474034c681efb5cf00d69e7c53321_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1794&quot; data-rawheight=&quot;1122&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-522474034c681efb5cf00d69e7c53321_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1794&quot; data-rawheight=&quot;1122&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-522474034c681efb5cf00d69e7c53321_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-522474034c681efb5cf00d69e7c53321_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;唯一id&lt;/h2&gt;&lt;p data-pid=&quot;io7R1vZh&quot;&gt;每个请求有唯一的id还是很必要的，那么在海量的请求下如何保证id的唯一性并且能够包含请求的信息？Eagleeye的traceId设计如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-43e51910be34eeb0a4e235a2e6ba4be7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1800&quot; data-rawheight=&quot;548&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-43e51910be34eeb0a4e235a2e6ba4be7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1800&quot; data-rawheight=&quot;548&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-43e51910be34eeb0a4e235a2e6ba4be7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-43e51910be34eeb0a4e235a2e6ba4be7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;oU4ACRtq&quot;&gt;根据这个id，我们可以知道这个请求在2022-10-18 10:10:40发出，被11.15.148.83机器上进程号为14031的Nginx（对应标识位e）接收到。其中的四位原子递增数从0-9999，目的是为了防止单机并发造成traceId碰撞。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;关系描述&lt;/h2&gt;&lt;p data-pid=&quot;kFCgD5-a&quot;&gt;将请求划分为Trace、Segment、Span三个层次的模型后，如何描述他们之间的关系？&lt;/p&gt;&lt;p data-pid=&quot;F9MZUpSI&quot;&gt;从【OpenTracing规范】一节的调用链路图中可以看出，Trace、Segment可以作为整个调用链路中的逻辑结构，而Span才是真正串联起整个链路的单元，系统可以通过若干个Span串联起整个调用链路。&lt;/p&gt;&lt;p data-pid=&quot;4qkYUaUv&quot;&gt;在Java中，方法是以入栈、出栈的形式进行调用，那么系统在记录Span的时候就可以通过模拟出栈、入栈的动作来记录Span的调用顺序，不难发现最终一个链路中的所有Span呈现树形关系，那么如何描述这棵Span树？Eagleeye中的设计很巧妙，EagleEye设计了RpcId来区别同一个调用链下多个网络调用的顺序和嵌套层次。 如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a85b715909215ecd99b4ef6f924db048_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1686&quot; data-rawheight=&quot;1322&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-a85b715909215ecd99b4ef6f924db048_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1686&quot; data-rawheight=&quot;1322&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-a85b715909215ecd99b4ef6f924db048_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a85b715909215ecd99b4ef6f924db048_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;7BlEQKST&quot;&gt;RpcId用0.X1.X2.X3.....Xi来表示，根节点的RpcId固定从0开始，id的位数（&quot;.&quot;的数量）表示了Span在这棵树中的层级，Id最后一位表示了Span在这一层级中的顺序。那么给定同一个Trace中的所有RpcId，便可以很容易还原出一个完成的调用链：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;- 0
  - 0.1
    - 0.1.1
    - 0.1.2
      - 0.1.2.1
  - 0.2
    - 0.2.1
  - 0.3
    - 0.3.1
      - 0.3.1.1
    - 0.3.2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;跨进程传输&lt;/h2&gt;&lt;p data-pid=&quot;o49a65tw&quot;&gt;再进一步，在整个调用链的收集过程中，不可能将整个Trace信息随着请求携带到下个应用中，为了将跨进程传输的trace信息减少到最小，每个应用（Segment）中的数据一定是分段收集的，这样在Eagleeye的实现下跨Segment的过程只需要携带traceId和rpcid两个简短的信息即可。在服务端收集数据时，数据自然也是分段到达服务端的，但由于种种原因分段数据可能存在乱序和丢失的情况：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bdf84cf956b7326092f4ad43473f021a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1736&quot; data-rawheight=&quot;1148&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-bdf84cf956b7326092f4ad43473f021a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1736&quot; data-rawheight=&quot;1148&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-bdf84cf956b7326092f4ad43473f021a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bdf84cf956b7326092f4ad43473f021a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;7gaAMAM1&quot;&gt;如上图所示，收集到一个Trace的数据后，通过rpcid即可还原出一棵调用树，当出现某个Segment数据缺失时，可以用第一个子节点替代。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;数据埋点&lt;/h2&gt;&lt;p data-pid=&quot;-KHP8-fG&quot;&gt;如何进行方法增强（埋点）是分布式链路追系统的关键因素，在Dapper提出的要求中可以看出，方法增强同时要满足应用级透明和低开销这两个要求。之前我们提到应用级透明其实是一个比较相对的概念，透明度越高意味着难度越大，对于不同的场景可以采用不同的方式。本文我们介绍阿里的Eagleye和开源的SkyWalking来比较两种埋点方式的优劣。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;编码&lt;/h2&gt;&lt;p data-pid=&quot;vaSHmRis&quot;&gt;阿里Eagleeye的埋点方式是直接编码的方式，通过中间件预留的扩展点实现。但是按照我们通常的理解来说，编码对于Dapper提出的扩展性和开放性似乎并不友好，那为什Eagleye么要采用这样的方式？个人认为有以下几点：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;r2TMA9tT&quot;&gt;阿里有中间件的使用规范，不是想用什么就用什么，因此对于埋点的覆盖范围是有限的；&lt;/li&gt;&lt;li data-pid=&quot;a1i1EBdX&quot;&gt;阿里有给力的中间件团队专门负责中间件的维护，中间件的埋点对于上层应用来说也是应用级透明的，对于埋点的覆盖是全面的；&lt;/li&gt;&lt;li data-pid=&quot;djSVVd8s&quot;&gt;阿里应用有接入Eagleye监控系统的要求，因此对于可插拔的诉求并没有非常强烈。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;KGRRbMu0&quot;&gt;从上面几点来说，编码方式的埋点完全可以满足Eagleye的需要，并且直接编码的方式在维护、性能消耗方面也是非常有优势的。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;字节码增强&lt;/h2&gt;&lt;p data-pid=&quot;9QYxgM8_&quot;&gt;相比于Eagleye，SkyWalking这样开源的分布式链路监控系统，在开源环境下就没有这么好做了。开源环境下面临的问题其实和阿里集团内部的环境正好相反：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;V8ezwCUq&quot;&gt;开源环境下每个开发者使用的中间件可能都不一样，想用什么就用什么，因此对于埋点的覆盖范围几乎是无限的；&lt;/li&gt;&lt;li data-pid=&quot;tyzx5GTW&quot;&gt;开源环境下，各种中间件都由不同组织或个人进行维护，甚至开发者还可以进行二次开发，不可能说服他们在代码中加入链路监控的埋点；&lt;/li&gt;&lt;li data-pid=&quot;LrHtZL2H&quot;&gt;开源环境下，并不一定要接入链路监控体系，大多数个人开发者由于资源有限或其他原因没有接入链路监控系统的需求。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;XvatmV1D&quot;&gt;从上面几点来说，编码方式的埋点肯定是无法满足SkyWalking的需求的。针对这样的情况，Skywalking采用如下的开发模式：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-83291d71ef86293e28e43abbbe94121b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1708&quot; data-rawheight=&quot;1230&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-83291d71ef86293e28e43abbbe94121b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1708&quot; data-rawheight=&quot;1230&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-83291d71ef86293e28e43abbbe94121b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-83291d71ef86293e28e43abbbe94121b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Y2kFUdWF&quot;&gt;Skywalking提供了核心的&lt;b&gt;字节码增强&lt;/b&gt;能力和相关的扩展接口，对于系统中使用到的中间件可以使用官方或社区提供的插件打包后植入应用进行埋点，如果没有的话甚至可以自己开发插件实现埋点。Skywalking采用字节码增强的方式进行埋点，下面简单介绍字节码增强的相关知识和Skywalking的相关实现。&lt;/p&gt;&lt;p data-pid=&quot;outCf4tN&quot;&gt;对Java应用实现字节码增强的方式有Attach和Javaagent两种，本文做一个简单的介绍。&lt;/p&gt;&lt;p data-pid=&quot;D7_fp7TI&quot;&gt;Attach是一种相对动态的方式，在阿尔萨斯（Arthas）这样的诊断系统中广泛使用，利用JVM提供的Attach API可以实现一个JVM对另一个运行中的JVM的通信。用一个具体的场景举例：我们要实现Attach JVM对一个运行中JVM的监控。如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3867eaa482389b208b2594e1a69bbb52_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1726&quot; data-rawheight=&quot;710&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-3867eaa482389b208b2594e1a69bbb52_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1726&quot; data-rawheight=&quot;710&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-3867eaa482389b208b2594e1a69bbb52_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3867eaa482389b208b2594e1a69bbb52_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ol&gt;&lt;li data-pid=&quot;sR1wtqYE&quot;&gt;Attach JVM利用Attach API获取目标JVM的实例，底层会通过socketFile建立两个JVM间的通信；&lt;/li&gt;&lt;li data-pid=&quot;aqR2ubAD&quot;&gt;Attach JVM指定目标JVM需要挂载的agent.jar包，挂载成功后会执行agent包中的&lt;b&gt;agentmain&lt;/b&gt;方法，此时就可以对目标JVM中类的字节码进行修改；&lt;/li&gt;&lt;li data-pid=&quot;xaZpL7Ux&quot;&gt;Attach JVM通过Socket向目标JVM发送命令，目标JVM收到后会进行响应，以达到监控的目的。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;A9qGA30h&quot;&gt;虽然Attach可以灵活地对正在运行中的JVM进行字节码修改，但在修改时也会受到一些限制，比如不能增减父类、不能增加接口、不能调整字段等。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;PYSem8ml&quot;&gt;Javaagent大家应该相对熟悉，他的启动方式是在启动命令中加入javaagent参数，指定需要挂载的agent：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;java -javaagent:/path/agent.jar=key1=value1,key2=value2 -jar myJar.jar&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;P75ZELSY&quot;&gt;Javaagent在IDE的Debug模式、链路监控系统等场景中广泛使用。它的核心是在目标JVM执行main方法前执行agent的premain方法，以插入前置逻辑：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bcf48056567686b4ef9839e68b89327e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1666&quot; data-rawheight=&quot;742&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-bcf48056567686b4ef9839e68b89327e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1666&quot; data-rawheight=&quot;742&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-bcf48056567686b4ef9839e68b89327e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bcf48056567686b4ef9839e68b89327e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ol&gt;&lt;li data-pid=&quot;TNC8etAk&quot;&gt;目标JVM通过javaagent参数启动后找到指定的agent，执行agent的premain方法；&lt;/li&gt;&lt;li data-pid=&quot;PYWG7bHX&quot;&gt;agent中通过JVM暴露的接口添加一个Transformer，顾名思义它可以Transform字节码；&lt;/li&gt;&lt;li data-pid=&quot;8SsxZixh&quot;&gt;目标JVM在类加载的时候会触发JVM内置的事件，回调Transformer以实现字节码的增强。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;rlwWvqS9&quot;&gt;和Attach方式相比，Javaagent只能在main方法之前执行。但是在修改字节码时较为灵活，甚至可以修改JDK的核心类库。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;NJbcO4xt&quot;&gt;Java提供了很多字节码增强类库，比如大家耳熟能详的cglib、Javassist，原生的Jdk Proxy还有底层的ASM等。在2014年，一款名为&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//bytebuddy.net/%23/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Byte Buddy&lt;/a&gt;的字节码增强类库横空出世，并在2015年获得Duke&#x27;s Choice award。Byte Buddy兼顾&lt;b&gt;高性能、易用、功能强大&lt;/b&gt;3个方面，下面是摘自其官网的一张常见字节码增强类库性能比较图（单位: 纳秒）：&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td/&gt;&lt;td&gt;基线&lt;/td&gt;&lt;td&gt;Byte Buddy&lt;/td&gt;&lt;td&gt;cglib&lt;/td&gt;&lt;td&gt;Javassist&lt;/td&gt;&lt;td&gt;Jdk Proxy&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;简单类创建&lt;/td&gt;&lt;td&gt;0.003±0.001&lt;/td&gt;&lt;td&gt;142.772±1.390&lt;/td&gt;&lt;td&gt;515.174±26.753&lt;/td&gt;&lt;td&gt;193.733±4.430&lt;/td&gt;&lt;td&gt;70.712±0.645&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;接口实现&lt;/td&gt;&lt;td&gt;0.004±0.001&lt;/td&gt;&lt;td&gt;1126.364±10.328&lt;/td&gt;&lt;td&gt;960.527±11.788&lt;/td&gt;&lt;td&gt;1070.766±59.865&lt;/td&gt;&lt;td&gt;1060.766±12.231&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;方法调用&lt;/td&gt;&lt;td&gt;0.002±0.001&lt;/td&gt;&lt;td&gt;0.002±0.001&lt;/td&gt;&lt;td&gt;0.003±0.001&lt;/td&gt;&lt;td&gt;0.011±0.001&lt;/td&gt;&lt;td&gt;0.008±0.001&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;类型扩展&lt;/td&gt;&lt;td&gt;0.004±0.001&lt;/td&gt;&lt;td&gt;885.983±7.901&lt;/td&gt;&lt;td&gt;1632.730±52.737&lt;/td&gt;&lt;td&gt;683.478±6.735&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;父类方法调用&lt;/td&gt;&lt;td&gt;0.004±0.001&lt;/td&gt;&lt;td&gt;0.004±0.001&lt;/td&gt;&lt;td&gt;0.021±0.001&lt;/td&gt;&lt;td&gt;0.025±0.001&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;2UQ-7_pQ&quot;&gt;上图中的对比项我们可以大致分为两个方面：&lt;b&gt;生成快速代码&lt;/b&gt;（方法调用、父类方法调用）和&lt;b&gt;快速生成代码&lt;/b&gt;（简单类创建、接口实现、类型扩展），我们理所应当要优先选择前者。从数据可以看出Byte Buddy在纳秒级的精度下，在方法调用和父类方法调用上和基线基本没有差距，而位于其后的是cglib。&lt;/p&gt;&lt;p data-pid=&quot;MOtQYRh2&quot;&gt;Byte Buddy和cglib有较为出色的性能得益于它们底层都是基于ASM构建，如果将ASM也加入对比那么它的性能一定是最高的。但是用过ASM的同学虽然不一定能感受到它的高性能，但一定能感受到它噩梦般的开发体验：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
mv.visitLdcInsn(&quot;begin of sayhello().&quot;);
mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;Skywalking案例分析&lt;/h2&gt;&lt;p data-pid=&quot;-qOEe1Ib&quot;&gt;介绍了这么多，下面结合Skywalking中使用Byte Buddy的案例和大家一起体验下字节码增强的开发过程，其中只简单介绍相关主流程代码，各种细节就不介绍了。Skywalking为开发者提供了简单易用的插件接口，对于开发者来说不需要知道怎么增强方法的字节码，只需要关心以下几点：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;shdpT1iq&quot;&gt;Skywalking提供了ClassMatch，支持各种类、方法的匹配方式。包括类名、前缀、正则、注解等方式的匹配，除此之外还提供了与、或、非逻辑链接，以支持用户通过各种方式精确定位到一个具体的方法。我们看一个插件中的代码：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0b9887ddce7223a0181e6280514cf8c5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1742&quot; data-rawheight=&quot;166&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-0b9887ddce7223a0181e6280514cf8c5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1742&quot; data-rawheight=&quot;166&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-0b9887ddce7223a0181e6280514cf8c5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0b9887ddce7223a0181e6280514cf8c5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;jRuxand-&quot;&gt;这段逻辑表示需要增强不带annotation1注解，并且带有annotaion2注解或annotaion3注解的方法的字节码。ClassMatch通过Builder模式提供用户流式编程的方式，最终Skywalking会将用户提供的一串ClassMatch构建出一个内部使用的类匹配逻辑。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;9HUfamLr&quot;&gt;知道了需要增强哪个类的哪个方法，那下一步就是如何增强。Java中的方法可以分为静态方法、实例方法和构造方法三类方法，Skywalking对于这三种方法的增强逻辑为用户提供了不同的扩展点：&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td/&gt;&lt;td&gt;实例方法&lt;/td&gt;&lt;td&gt;构造方法&lt;/td&gt;&lt;td&gt;静态方法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;前置&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;td&gt;不支持&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;后置&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;异常时&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;td&gt;不支持&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;参数重写&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;td&gt;不支持&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;其他扩展&lt;/td&gt;&lt;td&gt;让原Class实现EnhancedInstance接口，并且添加一个名为_$EnhancedClassField_ws的字段，可通过getSkyWalkingDynamicField和setSkyWalkingDynamicField方法进行访问。&lt;/td&gt;&lt;td/&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;_fpD9xA1&quot;&gt;以实例方法为例，Skywalking提供了如下实例方法拦截器：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public interface InstanceMethodsAroundInterceptor {
    // 方法执行前置扩展点
    void beforeMethod(EnhancedInstance objInst, Method method, Object[] allArguments, Class&amp;lt;?&amp;gt;[] argumentsTypes,
                      MethodInterceptResult result) throws Throwable;
    // 方法执行后置扩展点
    Object afterMethod(EnhancedInstance objInst, Method method, Object[] allArguments, Class&amp;lt;?&amp;gt;[] argumentsTypes,
                       Object ret) throws Throwable;
    // 方法抛出异常时扩展点
    void handleMethodException(EnhancedInstance objInst, Method method, Object[] allArguments,
                               Class&amp;lt;?&amp;gt;[] argumentsTypes, Throwable t);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;QsskH8iU&quot;&gt;开发者通过实现该接口即可对一个实例方法进行逻辑扩展（字节码增强）。方法参数列表中的第一个类型为&lt;b&gt;EnhancedInstance&lt;/b&gt;的参数其实就是当前对象（this），Skywalking中所有实例方法或构造方法被增强的类都会实现EnhancedInstance接口。&lt;/p&gt;&lt;p data-pid=&quot;Q-Ko_g1z&quot;&gt;假设我们有一个Controller，里面只有一个sayHello方法返回&quot;Hello&quot;，经过Skywalking增强后，反编译一下它被增强后的字节码文件：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9d2e696e2b13082c90b90d133f9c2129_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2272&quot; data-rawheight=&quot;1268&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-9d2e696e2b13082c90b90d133f9c2129_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2272&quot; data-rawheight=&quot;1268&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-9d2e696e2b13082c90b90d133f9c2129_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9d2e696e2b13082c90b90d133f9c2129_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;6hs3qZE8&quot;&gt;可以看到：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;Xekemrdu&quot;&gt;Skywalking在其中插入了一个名为_$EnhancedClassField_ws的字段，开发者在某些场合可以合理利用该字段存储一些信息。比如存储Spring MVC中Controller的跟路径，或者Jedis、HttpClient链接中对端信息等。&lt;/li&gt;&lt;li data-pid=&quot;R08BTlDz&quot;&gt;原来的syHello方法名被修改了但仍保存下来，并且新生成了一个增强后的sayHello方法，静态代码块里将经过字节码增强后的sayHello方法存入缓存字段。&lt;/li&gt;&lt;/ol&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;q9ifRm6I&quot;&gt;在某些时候，并不是只要引入了对应插件就一定会对相关的代码进行字节码增强。比如我们想对Spring MVC的Controller进行埋点，我们使用的是Spring 4.x版本，但是插件却是 5.x 版本的，如果直接对源码进行增强可能会因为版本的差别带来意料之外的问题。Skywalking提供了一种witness机制，简单来说就是当我们的代码中存在指定的类或方式时，当前插件才会进行字节码增强。比如Spring 4.x版本中需要witness这两个类：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6bc24ba167eff85bc03ec0c9dcabe838_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1606&quot; data-rawheight=&quot;384&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-6bc24ba167eff85bc03ec0c9dcabe838_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1606&quot; data-rawheight=&quot;384&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-6bc24ba167eff85bc03ec0c9dcabe838_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-6bc24ba167eff85bc03ec0c9dcabe838_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;LfUHyrZO&quot;&gt;如果粒度不够，还可以对方法进行witness。比如Elastic Search 6.x版本中witness了这个方法：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-46a6ccef178f69ba568e0a9a7c24aff7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1738&quot; data-rawheight=&quot;332&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-46a6ccef178f69ba568e0a9a7c24aff7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1738&quot; data-rawheight=&quot;332&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-46a6ccef178f69ba568e0a9a7c24aff7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-46a6ccef178f69ba568e0a9a7c24aff7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;k7WCrpTx&quot;&gt;意思就是SearchHits类中必须有名为getTotalHits、参数列表为空并且返回long的方法。&lt;/p&gt;&lt;p data-pid=&quot;csv6If5l&quot;&gt;除了上面的扩展点外，Skywalking还支持对jdk核心类库的字节码增强，比如对Callable和Runnable进行增强已支持异步模式下的埋点透传。这就需要和BootstrapClassLoader打交道了，Skywalking帮我们完成了这些复杂的逻辑。Skywalking Agent部分整体的模型如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-53d399169a27588daa245e03c0a0174a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1766&quot; data-rawheight=&quot;1060&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-53d399169a27588daa245e03c0a0174a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1766&quot; data-rawheight=&quot;1060&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-53d399169a27588daa245e03c0a0174a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-53d399169a27588daa245e03c0a0174a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;G0GeGZ3r&quot;&gt;左侧SPI部分是Skywalking暴露的插件规范接口，开发者根据这些接口实现插件。右侧Core部分负责加载插件并且利用Byte Buddy提供的字节码增强逻辑对应用中指定类和方法的字节码进行增强。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;u7dMGGgV&quot;&gt;介绍了Skywalking的插件模型后，下面从Javaagent的入口premain开始介绍下主要的流程：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public static void premain(String agentArgs, Instrumentation instrumentation) throws PluginException {
    // 1. 加载所有的Skywalking插件 
    // 插件实现了Skywalking接口规范，包括需要增强哪个类、需要怎么增强这两个要素
    final PluginFinder  = new PluginFinder(new PluginBootstrap().loadPlugins());

    // 2. 构建ByteBuddy
    // ByteBuddy提供了流式的API来指定ByteBuddy类库的行为（用于各种配置）
    final ByteBuddy byteBuddy = new ByteBuddy().with(TypeValidation.of(Config.Agent.IS_OPEN_DEBUGGING_CLASS));

    // 3. 构建AgentBuilder实例，需要忽略的类
    AgentBuilder agentBuilder = new AgentBuilder.Default(byteBuddy).ignore(
        nameStartsWith(&quot;net.bytebuddy.&quot;)
        .or(nameStartsWith(&quot;org.slf4j.&quot;))
        .or(nameStartsWith(&quot;org.groovy.&quot;))
        .or(nameContains(&quot;javassist&quot;))
        .or(nameContains(&quot;.asm.&quot;))
        .or(nameContains(&quot;.reflectasm.&quot;))
        .or(nameStartsWith(&quot;sun.reflect&quot;))
        .or(nameStartsWith(&quot;org.apache.skywalking.&quot;)
            .and(not(nameStartsWith(&quot;org.apache.skywalking.apm.toolkit.&quot;))))
        // 忽略Java中的【Synthetic】
        // Synthetic指所有存在于字节码文件中，但是不存在于源代码中的【构造】，即JVM帮我们生产的东西
        // 比如内部类指向外部类实例的this$0字段；外部类访问内部类的私有变量时JDK帮我们生产的方法等等
        // JDK11后引入了NBAC机制，引入了新的嵌套类组织方式，不再生成Synthetic方法
        .or(ElementMatchers.isSynthetic()));

    // 4. 处理JDK9的module特性，解决跨模块类访问的问题

    // 5. 将AgentBuilder插桩在Instrumentation上
    agentBuilder
        // 根据插件的内容构建需要增强类的匹配器
        .type(pluginFinder.buildMatch())
        // Transformer就是字节码增强逻辑的主要入口
        .transform(new Transformer(pluginFinder))
        // Retransform模式：保留被修改的字节码
        // Redifine模式：覆盖被修改的字节码
        .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
        // 一些监听器
        .with(new RedefinitionListener())
        .with(new Listener())
        // 将AgentBuilder插桩在JVM提供的Instrumentation上
        .installOn(instrumentation);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;m1JZh7ib&quot;&gt;上面的流程主要做了两件事：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;nwC_wNUj&quot;&gt;从指定的目录加载所有插件到内存中；&lt;/li&gt;&lt;li data-pid=&quot;R9GCf6jD&quot;&gt;构建Byte Buddy核心的AgentBuilder插桩到JVM的Instrumentation API上，包括需要增强哪些类以及核心的增强逻辑Transformer。&lt;/li&gt;&lt;/ol&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;private static class Transformer implements AgentBuilder.Transformer {
    private PluginFinder pluginFinder;

    Transformer(PluginFinder pluginFinder) {
        this.pluginFinder = pluginFinder;
    }

    /**
     * 这个方法在类加载的过程中会由JVM调用（Byte Buddy做了封装）
     * @param builder          原始类的字节码构建器
     * @param typeDescription  类描述信息
     * @param classLoader      这个类的类加载器
     * @param module           jdk9中模块信息
     * @return                 修改后的类的字节码构建器
     */
    @Override
    public DynamicType.Builder&amp;lt;?&amp;gt; transform(final DynamicType.Builder&amp;lt;?&amp;gt; builder,
                                            final TypeDescription typeDescription,
                                            final ClassLoader classLoader,
                                            final JavaModule module) {
        LoadedLibraryCollector.registerURLClassLoader(classLoader);
        // 根据类信息找到针对这个类进行字节码增强的插件，可能有多个
        List&amp;lt;AbstractClassEnhancePluginDefine&amp;gt; pluginDefines = pluginFinder.find(typeDescription);
        if (pluginDefines.size() &amp;gt; 0) {
            DynamicType.Builder&amp;lt;?&amp;gt; newBuilder = builder;
            EnhanceContext context = new EnhanceContext();
            for (AbstractClassEnhancePluginDefine define : pluginDefines) {
                // 调用插件的define方法得到新的字节码
                DynamicType.Builder&amp;lt;?&amp;gt; possibleNewBuilder = define.define(
                    typeDescription, newBuilder, classLoader, context);
                if (possibleNewBuilder != null) {
                    newBuilder = possibleNewBuilder;
                }
            }
            // 返回增强后的字节码给JVM，完成字节码增强
            return newBuilder;
        }
        return builder;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;t8xE7m5q&quot;&gt;JVM在类加载的时候会触发JVM内置事件，回调Transformer传入原始类的字节码、类加载器等信息，从而实现对字节码的增强。其中的AbstractClassEnhancePluginDefine就是一个插件的抽象。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public abstract class AbstractClassEnhancePluginDefine {
    public DynamicType.Builder&amp;lt;?&amp;gt; define(TypeDescription typeDescription, DynamicType.Builder&amp;lt;?&amp;gt; builder,
                                         ClassLoader classLoader, EnhanceContext context) throws PluginException {
        // witness机制
        WitnessFinder finder = WitnessFinder.INSTANCE;

        //通过类加载器找witness类，没有就直接返回，不进行字节码的改造
        String[] witnessClasses = witnessClasses();
        if (witnessClasses != null) {
            for (String witnessClass : witnessClasses) {
                if (!finder.exist(witnessClass, classLoader)) {
                    return null;
                }
            }
        }

        //通过类加载器找witness方法，没有就直接返回，不进行字节码的改造
        List&amp;lt;WitnessMethod&amp;gt; witnessMethods = witnessMethods();
        if (!CollectionUtil.isEmpty(witnessMethods)) {
            for (WitnessMethod witnessMethod : witnessMethods) {
                if (!finder.exist(witnessMethod, classLoader)) {
                    return null;
                }
            }
        }

        // enhance开始修改字节码
        DynamicType.Builder&amp;lt;?&amp;gt; newClassBuilder = this.enhance(typeDescription, builder, classLoader, context);

        // 修改完成，返回新的字节码
        context.initializationStageCompleted();
        return newClassBuilder;
    }

    protected DynamicType.Builder&amp;lt;?&amp;gt; enhance(TypeDescription typeDescription, DynamicType.Builder&amp;lt;?&amp;gt; newClassBuilder,
                                             ClassLoader classLoader, EnhanceContext context) throws PluginException {
        // 增强静态方法
        newClassBuilder = this.enhanceClass(typeDescription, newClassBuilder, classLoader);
        // 增强实例方法&amp;amp; 构造方法
        newClassBuilder = this.enhanceInstance(typeDescription, newClassBuilder, classLoader, context);
        return newClassBuilder;
    }
}       &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;_Z2_2PWC&quot;&gt;通过witness机制检测满足条件后，对静态方法、实例方法和构造方法进行字节码增强。我们以实例方法和构造方法为例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public abstract class ClassEnhancePluginDefine extends AbstractClassEnhancePluginDefine {
    protected DynamicType.Builder&amp;lt;?&amp;gt; enhanceInstance(TypeDescription typeDescription,
                                                     DynamicType.Builder&amp;lt;?&amp;gt; newClassBuilder, ClassLoader classLoader,
                                                     EnhanceContext context) throws PluginException {
        // 获取插件定义的构造方法拦截点ConstructorInterceptPoint
        ConstructorInterceptPoint[] constructorInterceptPoints = getConstructorsInterceptPoints();
        // 获取插件定义的实例方法拦截点InstanceMethodsInterceptPoint
        InstanceMethodsInterceptPoint[] instanceMethodsInterceptPoints = getInstanceMethodsInterceptPoints();
        String enhanceOriginClassName = typeDescription.getTypeName();
        // 非空校验
        boolean existedConstructorInterceptPoint = false;
        if (constructorInterceptPoints != null &amp;amp;&amp;amp; constructorInterceptPoints.length &amp;gt; 0) {
            existedConstructorInterceptPoint = true;
        }
        boolean existedMethodsInterceptPoints = false;
        if (instanceMethodsInterceptPoints != null &amp;amp;&amp;amp; instanceMethodsInterceptPoints.length &amp;gt; 0) {
            existedMethodsInterceptPoints = true;
        }
        if (!existedConstructorInterceptPoint &amp;amp;&amp;amp; !existedMethodsInterceptPoints) {
            return newClassBuilder;
        }

        // 这里就是之前提到的让类实现EnhancedInstance接口，并添加_$EnhancedClassField_ws字段
        if (!typeDescription.isAssignableTo(EnhancedInstance.class)) {
            if (!context.isObjectExtended()) {
                // Object类型、private volatie修饰符、提供方法进行访问
                newClassBuilder = newClassBuilder.defineField(
                    &quot;_$EnhancedClassField_ws&quot;, Object.class, ACC_PRIVATE | ACC_VOLATILE)
                    .implement(EnhancedInstance.class)
                    .intercept(FieldAccessor.ofField(&quot;_$EnhancedClassField_ws&quot;));
                context.extendObjectCompleted();
            }
        }

        // 构造方法增强
        if (existedConstructorInterceptPoint) {
            for (ConstructorInterceptPoint constructorInterceptPoint : constructorInterceptPoints) {
                // jdk核心类
                if (isBootstrapInstrumentation()) {
                    newClassBuilder = newClassBuilder.constructor(constructorInterceptPoint.getConstructorMatcher())
                        .intercept(SuperMethodCall.INSTANCE.andThen(MethodDelegation.withDefaultConfiguration()
                                                                    .to(BootstrapInstrumentBoost
                                                                    .forInternalDelegateClass(constructorInterceptPoint
                                                                                              // 非jdk核心类                                                                                                         .getConstructorInterceptor()))));
                } else {
                    // 找到对应的构造方法，并通过插件自定义的InstanceConstructorInterceptor进行增强
                    newClassBuilder = newClassBuilder.constructor(constructorInterceptPoint.getConstructorMatcher())
                        .intercept(SuperMethodCall.INSTANCE.andThen(MethodDelegation.withDefaultConfiguration()
                                                                    .to(new ConstructorInter(constructorInterceptPoint
                                                                                             .getConstructorInterceptor(), classLoader))));
                }
            }
        }

        // 实例方法增强
        if (existedMethodsInterceptPoints) {
            for (InstanceMethodsInterceptPoint instanceMethodsInterceptPoint : instanceMethodsInterceptPoints) {
                // 找到插件自定义的实例方法拦截器InstanceMethodsAroundInterceptor
                String interceptor = instanceMethodsInterceptPoint.getMethodsInterceptor();
                // 这里在插件自定义的匹配条件上加了一个【不为静态方法】的条件
                ElementMatcher.Junction&amp;lt;MethodDescription&amp;gt; junction = not(isStatic()).and(instanceMethodsInterceptPoint.getMethodsMatcher());

                // 需要重写入参
                if (instanceMethodsInterceptPoint.isOverrideArgs()) {
                    // jdk核心类
                    if (isBootstrapInstrumentation()) {
                        newClassBuilder = newClassBuilder.method(junction)
                            .intercept(MethodDelegation.withDefaultConfiguration()
                                       .withBinders(Morph.Binder.install(OverrideCallable.class))
                                       .to(BootstrapInstrumentBoost.forInternalDelegateClass(interceptor)));
                    // 非jdk核心类 
                    } else {
                            newClassBuilder = newClassBuilder.method(junction)
                                .intercept(MethodDelegation.withDefaultConfiguration()
                                           .withBinders(Morph.Binder.install(OverrideCallable.class))
                                           .to(new InstMethodsInterWithOverrideArgs(interceptor, classLoader)));
                    }
                // 不需要重写入参
                } else {
                    // jdk核心类    
                    if (isBootstrapInstrumentation()) {
                            newClassBuilder = newClassBuilder.method(junction)
                                .intercept(MethodDelegation.withDefaultConfiguration()
                                           .to(BootstrapInstrumentBoost.forInternalDelegateClass(interceptor)));
                    // 非jdk核心类                                                                  
                    } else {
                        // 找到对应的实例方法，并通过插件自定义的InstanceMethodsAroundInterceptor进行增强
                        newClassBuilder = newClassBuilder.method(junction)
                                .intercept(MethodDelegation.withDefaultConfiguration()
                                           .to(new InstMethodsInter(interceptor, classLoader)));
                    }
                }
            }
        }

        return newClassBuilder;
    }
}    &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;kHSpOyF2&quot;&gt;根据是否要重写入参、是否是核心类走到不同的逻辑分支，大致的增强逻辑大差不差，就是根据用户自定义的插件找到需要增强的方法和增强逻辑，利用Byte Buddy类库进行增强。&lt;/p&gt;&lt;p data-pid=&quot;mPKVmSdE&quot;&gt;用户通过方法拦截器实现增强逻辑，但是它是面向用户的，并不能直接用来进行字节码增强，Skywalking加了一个中间层来连接用户逻辑和Byte Buddy类库。上述代码中的XXXInter便是中间层，比如针对实例方法的InstMethodsInter：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7059cfaf9bed1071bba0f3a59117e06b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2484&quot; data-rawheight=&quot;1074&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-7059cfaf9bed1071bba0f3a59117e06b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2484&quot; data-rawheight=&quot;1074&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-7059cfaf9bed1071bba0f3a59117e06b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-7059cfaf9bed1071bba0f3a59117e06b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;2iVKnP-6&quot;&gt;InstMethodsInter封装用户自定义的逻辑，并且对接ByteBuddy的核心类库，当执行到被字节码增强的方法时会执行InstMethodsInter的intercept方法（可以和上面反编译被增强后类的字节码文件进行对比）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public class InstMethodsInter {
    private static final ILog LOGGER = LogManager.getLogger(InstMethodsInter.class);

    // 用户在插件中定义的实例方法拦截器
    private InstanceMethodsAroundInterceptor interceptor;

    public InstMethodsInter(String instanceMethodsAroundInterceptorClassName, ClassLoader classLoader) {
        try {
            // 加载用户在插件中定义的实例方法拦截器
            interceptor = InterceptorInstanceLoader.load(instanceMethodsAroundInterceptorClassName, classLoader);
        } catch (Throwable t) {
            throw new PluginException(&quot;Can&#x27;t create InstanceMethodsAroundInterceptor.&quot;, t);
        }
    }

    /**
     * 当执行被增强方法时，会执行该intercept方法
     *
     * @param obj          实例对象（this）
     * @param allArguments 方法入参
     * @param method       参数描述
     * @param zuper        原方法调用的句柄
    *  @param method       被增强后的方法的引用 
     * @return             方法返回值
     */
    @RuntimeType
    public Object intercept(@This Object obj, @AllArguments Object[] allArguments, @SuperCall Callable&amp;lt;?&amp;gt; zuper,
        @Origin Method method) throws Throwable {
        EnhancedInstance targetObject = (EnhancedInstance) obj;

        MethodInterceptResult result = new MethodInterceptResult();
        try {
            // 拦截器前置逻辑
            interceptor.beforeMethod(targetObject, method, allArguments, method.getParameterTypes(), result);
        } catch (Throwable t) {
            LOGGER.error(t, &quot;class[{}] before method[{}] intercept failure&quot;, obj.getClass(), method.getName());
        }

        Object ret = null;
        try {
            // 是否中断方法执行
            if (!result.isContinue()) {
                ret = result._ret();
            } else {
                // 执行原方法
                ret = zuper.call();
                // 为什么不能走method.invoke？因为method已经是被增强后方法，调用就死循环了！
                // 可以回到之前的字节码文件查看原因，看一下该intercept执行的时机
            }
        } catch (Throwable t) {
            try {
                 // 拦截器异常时逻辑
                interceptor.handleMethodException(targetObject, method, allArguments, method.getParameterTypes(), t);
            } catch (Throwable t2) {
                LOGGER.error(t2, &quot;class[{}] handle method[{}] exception failure&quot;, obj.getClass(), method.getName());
            }
            throw t;
        } finally {
            try {
                // 拦截器后置逻辑
                ret = interceptor.afterMethod(targetObject, method, allArguments, method.getParameterTypes(), ret);
            } catch (Throwable t) {
                LOGGER.error(t, &quot;class[{}] after method[{}] intercept failure&quot;, obj.getClass(), method.getName());
            }
        }
        return ret;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;6FG0nHMc&quot;&gt;上述逻辑其实就是下图中红框中的逻辑：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b43db529daa8313d2357759e617619f0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2486&quot; data-rawheight=&quot;166&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-b43db529daa8313d2357759e617619f0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2486&quot; data-rawheight=&quot;166&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-b43db529daa8313d2357759e617619f0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b43db529daa8313d2357759e617619f0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Iam22alU&quot;&gt;Byte Buddy提供了声明式方式，通过几个注解就可以实现字节码增强逻辑。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;数据收集&lt;/h2&gt;&lt;p data-pid=&quot;5pY6a_AV&quot;&gt;下一步就是将收集到的Trace数据发送到服务端。为了将对主链路的影响降到最小，一般都采用先存本地、再异步采集的方式。Skywalking和Eagleeye的实现有所不同，我们分别介绍：&lt;/p&gt;&lt;h2&gt;存储&lt;/h2&gt;&lt;p data-pid=&quot;HPmCPiSD&quot;&gt;鹰眼采用并发环形队列存储Trace数据，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b462d75db25c32300dc88eba335d5301_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1770&quot; data-rawheight=&quot;1264&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-b462d75db25c32300dc88eba335d5301_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1770&quot; data-rawheight=&quot;1264&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-b462d75db25c32300dc88eba335d5301_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b462d75db25c32300dc88eba335d5301_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;vl6c8rwY&quot;&gt;环形队列在很多日志框架的异步写入过程中很常见，其中主要包括读指针take，指向队列中的最后一条数据；写指针put，指向队列中下一个数据将存放的位置，并且支持原子读、写数据。take和put指针朝一个时钟方向移动，当生产数据的速度超过消费速度时，会出现put指针“追上”take指针的情况（套圈），此时根据不同的策略可以丢弃即将写入的数据或将老数据覆盖。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;hWda5quj&quot;&gt;Skywalking在实现上有所区别，采用分区的QueueBuffer存储Trace数据，多个消费线程通过Driver平均分配到各个QueueBuffer上进行数据消费：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-690bfc54583b7a5b281c53787a97e48b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1896&quot; data-rawheight=&quot;1262&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-690bfc54583b7a5b281c53787a97e48b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1896&quot; data-rawheight=&quot;1262&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-690bfc54583b7a5b281c53787a97e48b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-690bfc54583b7a5b281c53787a97e48b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;Lm5Kv69L&quot;&gt;QueueBuffer有两种实现，除了基于JDK的阻塞队列外，还有一种普通数组+原子下标的方式。Skywalking对于这两种实现有不同的使用场景：基于JDK阻塞队列的实现用在服务端，而普通数组+原子下标的方式用在Agent端，因为后者更加轻量，性能更高。对于后者这里介绍一下其中比较有趣的地方。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;f_Auy9gx&quot;&gt;普通的Oject数组是无法支持并发的，但只要保证每个线程获取下标的过程是原子的，即可保证数组的线程安全。这需要保证：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;E4mvqkLQ&quot;&gt;多线程获取的下标是依次递增的，从0开始到数组容量-1；&lt;/li&gt;&lt;li data-pid=&quot;WqB6XMpa&quot;&gt;当某个线程获取的下标超过数组容量，需要从0开始重新获取。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;ZKCLnkMZ&quot;&gt;这其实并不难实现，通过一个&lt;b&gt;原子数和取模操作&lt;/b&gt;一行代码就能完成上面的两个功能。但我们看Skywalking是如何实现这个功能的：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 提供原子下标的类
public class AtomicRangeInteger {
    // JDK提供的原子数组
    private AtomicIntegerArray values;

    // 固定值15
    private static final int VALUE_OFFSET = 15;

    // 数组开始下标，固定为0
    private int startValue;

    // 数组最后一个元素的下标，固定为数组的最大长度-1
    private int endValue;

    public AtomicRangeInteger(int startValue, int maxValue) {
        // 创建一个长度为31的原子数组
        this.values = new AtomicIntegerArray(31);
        // 将第15位设置为初始值0
        this.values.set(VALUE_OFFSET, startValue);
        this.startValue = startValue;
        this.endValue = maxValue - 1;
    }

    // 核心方法，获取数组的下一个下标
    public final int getAndIncrement() {
        int next;
        do {
            // 原子递增
            next = this.values.incrementAndGet(VALUE_OFFSET);
            // 如果超过了数组范围，CAS重制到0
            if (next &amp;gt; endValue &amp;amp;&amp;amp; this.values.compareAndSet(VALUE_OFFSET, next, startValue)) {
                return endValue;
            }
        } while (next &amp;gt; endValue);
        return next - 1;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;LSOq_ZlI&quot;&gt;Skywalking用了一个长度固定为31的JDK原子数组的固定第15位进行相关原子操作，JDK8中的原子数组利用Unsafe通过偏移量直接对数组中的元素进行内存操作，那为什么要这么做呢？我们先将其称为V1版本，再来看看V2版本，这是Skywalking早期版本使用的代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public class AtomicRangeInteger {

    private AtomicInteger value;
    private int startValue;
    private int endValue;

    public AtomicRangeInteger(int startValue, int maxValue) {
        this.value = new AtomicInteger(startValue);
        this.startValue = startValue;
        this.endValue = maxValue - 1;
    }

    public final int getAndIncrement() {
        int current;
        int next;
        do {
            // 获取当前下标
            current = this.value.get();
            // 如果超过最大范围则从0开始
            next = current &amp;gt;= this.endValue ? this.startValue : current + 1;
            // CAS更新下标，失败则循环重试
        } while (!this.value.compareAndSet(current, next));

        return current;
    }
}    &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;JeLFEvIo&quot;&gt;肉眼可见这段V2版本的代码逻辑不如V1版本，因为在V2中获取当前值和CAS更新这两个步骤是分开的，并不具备原子性，因此并发冲突的可能性更高，从而导致循环次数增加；而使用JDK提供的incrementAndGet方法效率更高。再看下V3版本：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public class AtomicRangeInteger extends Number implements Serializable {
    // 用原子整型替代V1版本的原子数组
    private AtomicInteger value;
    private int startValue;
    private int endValue;

    public AtomicRangeInteger(int startValue, int maxValue) {
        this.value = new AtomicInteger(startValue);
        this.startValue = startValue;
        this.endValue = maxValue - 1;
    }

    public final int getAndIncrement() {
        int next;
        do {
            next = this.value.incrementAndGet();
            if (next &amp;gt; endValue &amp;amp;&amp;amp; this.value.compareAndSet(next, startValue)) {
                return endValue;
            }
        }
        while (next &amp;gt; endValue);
        return next - 1;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;7j4KjxCb&quot;&gt;这个版本唯一的区别就是使用AtomicInteger代替原来的AtomicIntegerArray的第15位。还有最后一个最简单的V4版本，通过一个原子数和取模操作完成：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public class AtomicRangeInteger {

    private AtomicLong value;
    private int mask;

    public AtomicRangeInteger(int startValue, int maxValue) {
        this.value = new AtomicLong(startValue);
        this.mask = maxValue - 1;
    }

    public final int getAndIncrement() {
        return (int)(value.incrementAndGet() % mask);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;qmtLAQLw&quot;&gt;通过Benchmark压测数据来看看这几个版本的性能有什么差别，固定128线程，3轮预热、5轮正式，每轮10s。&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;版本&lt;/td&gt;&lt;td&gt;得分&lt;/td&gt;&lt;td&gt;描述&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;V1&lt;/td&gt;&lt;td&gt;45832615.061 ± 2987464.163  ops/s&lt;/td&gt;&lt;td&gt;原子数组第15位操作&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;V2&lt;/td&gt;&lt;td&gt;13496720.554 ±  240134.803  ops/s&lt;/td&gt;&lt;td&gt;老版本&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;V3&lt;/td&gt;&lt;td&gt;39201251.850 ± 1005866.969  ops/s&lt;/td&gt;&lt;td&gt;原子整数代替原子数组第15位&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;版本&lt;/td&gt;&lt;td&gt;得分&lt;/td&gt;&lt;td&gt;描述&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;V1&lt;/td&gt;&lt;td&gt;37368086.272 ± 2702764.084  ops/s&lt;/td&gt;&lt;td&gt;原子数组第15位操作&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;V2&lt;/td&gt;&lt;td&gt;8066661.954 ± 1165851.129  ops/s&lt;/td&gt;&lt;td&gt;老版本&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;V3&lt;/td&gt;&lt;td&gt;26124150.437 ±  684039.516  ops/s&lt;/td&gt;&lt;td&gt;原子整数代替原子数组第15位&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;V4&lt;/td&gt;&lt;td&gt;51063216.834 ± 7775168.064 ops/s&lt;/td&gt;&lt;td&gt;原子数取模&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;版本&lt;/td&gt;&lt;td&gt;得分&lt;/td&gt;&lt;td&gt;描述&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;V1&lt;/td&gt;&lt;td&gt;29452469.035 ± 1853738.513  ops/s&lt;/td&gt;&lt;td&gt;原子数组第15位操作&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;V2&lt;/td&gt;&lt;td&gt;7998178.059 ±  148894.535  ops/s&lt;/td&gt;&lt;td&gt;老版本&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;V3&lt;/td&gt;&lt;td&gt;39011356.081 ± 3603737.004  ops/s&lt;/td&gt;&lt;td&gt;原子整数代替原子数组第15位&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;V4&lt;/td&gt;&lt;td&gt;61012525.493 ± 6054137.447  ops/s&lt;/td&gt;&lt;td&gt;原子数取模&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-pid=&quot;8EpQdzOf&quot;&gt;Skywalking官方显示通过原子数组的固定第15位操作的V1版本表现最好，而在我自己本机环境测试中V3版本通过原子整数代替的方式和V1版本有高有低，而原子数取模的性能是最高的。个人猜测Skywalking通过原子数组的固定第15位操作是为了进行缓存填充，测试结果和环境有比较大的关系；而不使用原子数取模的原因是原子数的大小会无限递增。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;传输&lt;/h2&gt;&lt;p data-pid=&quot;gFfggWK7&quot;&gt;最后一步就是数据的传输，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-56b8230aa1d128cff455c49cebe48b0b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2482&quot; data-rawheight=&quot;902&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-56b8230aa1d128cff455c49cebe48b0b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2482&quot; data-rawheight=&quot;902&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-56b8230aa1d128cff455c49cebe48b0b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-56b8230aa1d128cff455c49cebe48b0b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;07xLAMaq&quot;&gt;Skywalking提供了GRPC和Kafka两种数据传输方式，而鹰眼则先将数据存入本地日志中，再通过agent将数据采集到服务端。和Skywalking相比，用户可以直接在机器上查看trace日志，而Skywalking提供了日志插件以提供可插拔的本地trace存储功能。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote data-pid=&quot;HOTcct7x&quot;&gt;&lt;i&gt;从整体上来看，Skywalking采取了埋点和中间件代码分离的方式，在某种意义上实现了应用级透明，但是在后期维护的过程中中间件版本的升级需要配合插件版本的升级，在维护方面带来了一些问题。而Eagleeye编码方式的埋点由中间件团队维护，对于上层的应用也是透明的，更加适合阿里集团内部的环境。&lt;/i&gt;&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote data-pid=&quot;f9FQ7Go_&quot;&gt;&lt;b&gt;版权声明：&lt;/b&gt;本文内容由阿里云实名注册用户自发贡献，版权归原作者所有，阿里云开发者社区不拥有其著作权，亦不承担相应法律责任。具体规则请查看《&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/768092&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;阿里云开发者社区用户服务协议&lt;/a&gt;》和《&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/768093&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;阿里云开发者社区知识产权保护指引&lt;/a&gt;》。如果您发现本社区中有涉嫌抄袭的内容，填写&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//yida.alibaba-inc.com/o/right&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;侵权投诉表单&lt;/a&gt;进行举报，一经查实，本社区将立刻删除涉嫌侵权内容。&lt;/blockquote&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5a808bc6d8660cf4ef2ac3e698f8a28a</guid>
<title>一文让你搞懂 Zookeeper</title>
<link>https://toutiao.io/k/aws2b6z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content  old_list_style             autoTypeSetting24psection&quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsEIKicpyQduAZAUmuof3PGN65fMW8Z45de2yHqKObrORgRI1I8QEcxaFTMoIeex6EgoBhrcyd3jslw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;什么是 zookeeper&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;zookeeper是Apache开源的一个顶级项目，目的是为分布式应用提供协调服务，当然 zookeeper 本身也是分布式的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而从设计模式的角度来理解：zookeeper 是一个基于观察者模式设计的分布式服务管理框架，它&lt;/span&gt;&lt;span&gt;负责存储和管理大家都关心的数据&lt;/span&gt;&lt;span&gt;，然后&lt;/span&gt;&lt;span&gt;接收观察者的注册&lt;/span&gt;&lt;span&gt;。一旦数据的状态发生变化，zookeeper 就会通知那些已经注册的观察者，以便它们能够及时做出反应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7388888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsHZoDmowhIPt7N3nDR2RS5sGTqE0QhGVssgxVjrObGvyWMbvXhFkXb8s6KgQbrbmAsYibRMFSCYOqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以 zookeeper 可以看作是一个&lt;/span&gt;&lt;span&gt;文件系统 + 通知机制&lt;/span&gt;&lt;span&gt;。文件系统指的是 zookeeper 可以存储数据，尽管数据量比较少，但还是像文件一样可以存储的；而通知机制指的是当数据有变化，会立即通知观察者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;那么 zookeeper 都有哪些特点呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）zookeeper 本身也是分布式的，可以组成集群。zookeeper 集群由一个领导者节点（Leader）和多个追随者节点（Follower）组成，Leader 负责接收写请求，Follower 负责和 Leader 之间进行数据同步并接收读请求。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）集群中只要有半数以上的节点存活，zookeeper 集群就能正常服务，所以集群内部的节点数量最好是奇数个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）zookeeper 是 CP 模型，在一致性和可用性之间选择了一致性，因此集群里面的数据是全局一致的，每个 Server 都保存了一份相同的数据副本。客户端无论连接到哪一个 Server，数据都是一致的。这也意味着 Leader 只有将新数据同步给所有的 Follower 之后，整个 zookeeper 集群才能对外提供服务，否则客户端就有可能读到旧数据。因为根据 CAP 理论，在保证 P 的前提下，C 和 A 是不可兼顾的，至于选择哪一个则看是否对数据有强一致性的要求。而 zookeeper 存储的数据一般都不大，所以选择了一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）写请求顺序进行，来自同一个 client 的写请求按其发送顺序依次执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5）&lt;/span&gt;&lt;span&gt;实时性，client 可以很快地读到最新数据。虽然 Leader 和 Follower 之间的数据同步需要一定时间，但 zookeeper 保存的数据量很小，因此同步速度非常快。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8863636363636364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/AibH5t526Kx33CC6gLCn4TAhK0epFVyGp66Gh8ibjqTc96S7dwgkjdJ4FkPQar6AyasopbcAh0xfyFpMeV5PX06w/640?wx_fmt=gif&quot; data-w=&quot;132&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;zookeeper 的数据结构&lt;/p&gt;&lt;span data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;zookeeper 数据结构和 UNIX 文件系统很类似，整体上可以看做是一棵树，节点被称为 ZNode。每个 ZNode 默认能够存储 1MB 的数据，因为 zookeeper 是 CP 模型，所以它不适合存储大量的数据，只适合存储一些简单的配置信息。此外，每个节点都可以通过路径进行唯一标识，我们通过 ZNode 的路径即可获取某个 ZNode 存储的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6188725490196079&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsHZoDmowhIPt7N3nDR2RS5s2vxbnrYciaibicF1fib0qvYN9pUp4NGlJF2JA6Uj1Yt7M1HNtiaPYKh3oTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体还是很好理解的，但是要明白，ZNode 能够存储的数据量比较少，不应该超过 1MB。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.8863636363636364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/AibH5t526Kx33CC6gLCn4TAhK0epFVyGp66Gh8ibjqTc96S7dwgkjdJ4FkPQar6AyasopbcAh0xfyFpMeV5PX06w/640?wx_fmt=gif&quot; data-w=&quot;132&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;zookeeper 的应用场景&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;zookeeper 在生产上都能解决哪些问题呢？其实能解决的问题还蛮多的，比如统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等等。下面一个一个介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;统一命名服务:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在分布式环境下，经常需要对&lt;/span&gt;&lt;span&gt;应用/服务&lt;/span&gt;&lt;span&gt;进行统一命名，便于识别。例如：IP 不容易记住，但是域名容易记住。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0310734463276836&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGAiauweNNW9fDlGlewKN8Swju4UUl1UevmlMYcu4HsHHmNDSGg3xZgnB3Yuj0ibuU0ZiaqyBpqXGsBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当访问域名的时候，会自动转发到某个服务器当中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;统一配置管理:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式环境下，配置文件同步非常常见。一个集群中，所有节点的配置信息是一致的，对配置文件修改之后，希望能够快速同步到各个节点上。比如 kafka 集群，当然 kafka 自带 zookeeper，但是我们一般不用自带的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.794074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGAiauweNNW9fDlGlewKN8Swul6rKRSVova9Tfg3hTzD7ice5aaC0GURaELCNB4QxjRQ6HmUicDicmGibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;675&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;配置管理可交由 zookeeper 实现，可将配置信息写入 zookeeper 的一个 ZNode，各个客户端监听这个 ZNode。一旦 ZNode 中的数据被修改，zookeeper 将通知各个客户端，这样一来每个客户端读到的配置信息都是一致的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;统一集群管理:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式环境中，实时掌握每个节点的状态是必要的，这样便可根据节点的实时状态做出一些调整。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而 zookeeper 可以实现实时监控节点的变化，通过将节点信息写入 zookeeper 的一个 ZNode，监听这个 ZNode 便可获取它的实时状态变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外每一个客户端的状态也可以写到节点上面，只要状态发生变化，就会更新节点上客户端的数据。只要数据发生更新，会立刻同步到其他的节点上，从而通知其他的客户端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务器动态上下线:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端能实时洞察到服务器上线的情况，还是最开始说的，如果某台服务器宕机，比如 server3。那么客户端就会被 zookeeper 通知，之后就不会再请求 server3 了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然这只是宕机的情况，如果 server3 修好了重新上线，那么 zookeeper 也要通知客户端。客户端会再次重新注册监听，之后仍然可以访问 server3。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;软负载均衡:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 zookeeper 中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0272988505747127&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGAiauweNNW9fDlGlewKN8Sw9ibCVQdknOjdbuBiakX1OJB9k9rIkknQQ1DaDSe1jBocg1fhP8WQ04UA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当新的客户端来访问的时候，会自动分发到访问次数比较少的服务器上。也就是类似 Nginx 负载均衡的效果，让每一台服务器的压力都不会那么大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;安装 zookeeper 单机版&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面安装 zookeeper，由于它是Apache的一个顶级项目，所以域名是 &lt;/span&gt;&lt;span&gt;zookeeper.apache.org&lt;/span&gt;&lt;span&gt;，所有 Apache 的顶级项目的官网都是以&lt;/span&gt;&lt;span&gt;项目名.apache.org&lt;/span&gt;&lt;span&gt;来命名的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8573551263001485&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGAiauweNNW9fDlGlewKN8SwiaPK5KfoUyzRLW83o4hotY0MY7tjqiah2eAKdeSibp9zwSLdyKES7ibvxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击 Download 即可下载，这里我们选择的版本是 3.5.10，下载之后扔到服务器上。由于 zookeeper 是基于 Java 语言编写的，所以还需要安装 JDK，这里我使用的是 JDK1.8，都已经已经安装好了，并配置了环境变量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3262411347517731&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGAiauweNNW9fDlGlewKN8SwhcKFjqa13EVQUTEKdmAuOQtQnvU3sTrMmvTWRCkibIx3Bm5LibfOFN1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1128&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们安装完毕之后不能直接用，还需要修改一下 zookeeper 的配置文件。在安装目录的 conf 目录下，里面有一个 zoo_sample.cfg，我们将其重命名为 zoo.cfg，然后打开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8682042833607908&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGAiauweNNW9fDlGlewKN8SwibuhYviaeD36KcczM7QWIibXyGw05CsicC6Jmn9xj06uOyrlf68Ima8q2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1214&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;里面有一个 dataDir 参数，表示数据的存储目录，数据在持久化之后会存储在该目录中，以防止数据丢失。但该目录默认位于临时目录 /tmp 下面，这样当节点重启之后数据就没了，所以需要换一个目录（要提前创建好），至于目录名无所谓，我这里叫 zkData。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于配置文件里的其他参数，我们之后会解读，下面先来启动服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5005917159763313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGAiauweNNW9fDlGlewKN8SwGb3U4lvjEfZwpuysMy81ic8qtqp6TSxBdzo9ia4yYpvPKxZ0f3yAUlwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1690&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;bin 目录下有很多脚本，其中 .cmd 文件是在 Windows 上使用的，不用管。然后我们看到有一个 zkServer.sh，它就是负责启动 zookeeper 服务的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22702702702702704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGAiauweNNW9fDlGlewKN8Sw5HbyVNurmD1GNTibqpmavbbChUoavFdQicRpN6ChpryNvrKNffrCiajiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1480&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启动成功，我们调用 jps 查看进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35602094240837695&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGAiauweNNW9fDlGlewKN8SwnLRuzrX6lofX0X8vd0AW4SEoWFSwL9gF0NMp8mhnbI0sb8wryZuEfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;凡是基于 Java 语言编写的框架，在启动之后，都可以通过 jps 查看相应的进程。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;要是看到输出了 QuorumPeerMain 就代表 zookeeper 启动成功了，如果想停止服务，可以通过 &lt;/span&gt;&lt;span&gt;zkServer.sh stop&lt;/span&gt;&lt;span&gt;，重启则是 &lt;/span&gt;&lt;span&gt;zkServer.sh restart&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启动之后，我们也可以查看状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23232323232323232&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGAiauweNNW9fDlGlewKN8SwWAZ6zGdRqPo1YtHicWVw7IlAHJrHf01RY42Uryia3pXNm2pfnU94WC0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1584&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时的模式是 standalone 模式，表示单机，当然后面我们也会搭建集群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然有了服务端，那么是不是也要有客户端呢，对的，类似于 Redis。下面启动客户端，直接 zkCli.sh 即可，不需要 start，出现如下表示启动成功。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34890510948905107&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGAiauweNNW9fDlGlewKN8Swp1cctGRlfqIGNC5tW8Qzg9F8AxWNZ1iaCGEophbQ6MeT8FAmUWkKhog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1370&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于 zookeeper 客户端的命令，一会儿详细介绍，我们来解读一下 zookeeper 的配置文件。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;tickTime=2000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;initLimit=10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;syncLimit=5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;dataDir=/opt/apache-zookeeper-3.5.10-bin/zkData&lt;/span&gt;&lt;br/&gt;&lt;span&gt;clientPort=2181&lt;/span&gt;&lt;br/&gt;&lt;span&gt;maxClientCnxns=60&lt;/span&gt;&lt;br/&gt;&lt;span&gt;autopurge.snapRetainCount=3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;autopurge.purgeInterval=1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;配置项还是比较少的，解释一下它们的含义。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;tickTime：服务端与客户端的心跳时间，默认 2000 毫秒。表示客户端每隔 2 秒会向服务端发送一个心跳信息，表示自己还活着，服务端不要断开连接。当然，它还表示集群内多个节点之间的心跳时间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;initLimit：领导者和追随者第一次建立连接时的最大通信时限，默认是 10 个 tickTime。如果超时，则表示连接建立失败；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;syncLimit：&lt;/span&gt;&lt;span&gt;领导者和追随者之间响应的最大时限（连接建立之后)，单位同样是 tickTime。如果领导者在超过 syncLimit * tickTime 之后没有收到追随者的响应，那么领导者会认为该追随者已经死掉，从而将其从服务器列表中删除；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;dataDir：&lt;/span&gt;&lt;span&gt;数据文件目录+数据持久化路径，主要用于保存 zookeeper 中的数据，我们刚刚已经修改了；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;clientPort：客户端和服务端通信的端口；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;maxClientCnxns：服务端最多支持和多少个客户端建立连接，默认是 60；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;autopurge.snapRetainCount：在 dataDir 中要保存的快照数量，多余的要被清除；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;autopurge.purgeInterval：自动触发清除任务的时间间隔，单位小时；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;admin.serverPort&lt;/span&gt;：这个参数没有写在配置文件中，但有必要说一下。zookeeper 从 3.5 开始，启动之后会占用 8080 端口，因为内嵌了一个管理控制台。而 8080 端口很常见，如果启动时发现该端口被占用，那么 zookeeper 会启动失败，此时便可通过该参数将端口改成其它的，比如 8081；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;配置文件还是非常简单的，以上我们就完成了 zookeeper 单机版的安装。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;搭建 zookeeper 集群&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们之前说了，zookeeper 集群是由一个领导者和多个追随者组成，但这个领导者是怎么选出来的呢？我们貌似没有在配置文件中看到有关领导者和追随者的参数啊。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在此之前先来看看 zookeeper 内部的一些机制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么领导者到底是怎么选出来的呢？很简单，每台服务器都有一个 id（这里的 id 后面说），当启动的服务器超过半数的时候，就会选择 id 最大的 server 成为领导者。比如有五台服务器，&lt;span&gt;半数就是 2.5，因此当启动三台的时候就可以选出领导者。至于剩余的两台，启动之后只能成为追随者，因为领导者已经选出来了。关于这里的细节，一会儿再详细聊。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么怎么指定服务器的 id 呢？还记得配置文件中的 dataDir 参数吗，在该参数指定的目录下创建一个 myid 文件（文件必须叫这个名字），然后在里面写上服务器的 id 即可。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;[root@satori zkData]&lt;span&gt;# echo 2 &amp;gt; myid&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这里给 id 设置为 2，因为一会要搭建由三个节点组成的集群，而我希望当前节点成为 Leader，所以它的 id 应该为 2，其它的两个节点的 id 显然分别为 1 和 3。这样按着 id 从小到大的顺序启动时，该节点就会成为 Leader。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面来我们来搭建 zookeeper 集群，总共三个节点：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;IP：82.157.146.194，主机名：satori；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;IP：121.37.165.252，主机名：koishi；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;IP：123.60.7.226，主机名：marisa；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;satori 节点就是当前一直在用的节点，剩余的两个节点的 zookeeper 也已经安装完毕。那么问题来了，我们要如何将这三个节点组成一个集群呢？显然还需要修改配置文件，先在 satori 节点进行修改。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# koishi 节点&lt;/span&gt;&lt;br/&gt;server&lt;span&gt;.1&lt;/span&gt;=&lt;span&gt;121.37.165.252&lt;/span&gt;:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# satori 节点&lt;/span&gt;&lt;br/&gt;server&lt;span&gt;.2&lt;/span&gt;=&lt;span&gt;0.0.0.0&lt;/span&gt;:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# marisa 节点&lt;/span&gt;&lt;br/&gt;server&lt;span&gt;.3&lt;/span&gt;=&lt;span&gt;123.60.7.226&lt;/span&gt;:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;将集群中都有哪些节点写在 zoo.cfg 中，解释一下具体含义，首先两个冒号把等号右边分成了三部分，第一部分就不用说了，IP 地址或者主机名，用于定位节点；2888 是 Leader 和 Follower 交换信息的端口，因为副本要进行同步；3888 是交换选举信息的端口，因为要选出 Leader。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后我们注意到 satori 节点的 IP 设置成了 0.0.0.0，这是因为当前的三个节点不在同一个网段，IP 用的都是公网 IP，而公网 IP 在绑定服务的时候会失败。所以在绑定的时候，其它节点的 IP 要写成公网 IP，自身节点的 IP 要写成 0.0.0.0。因此其它两个节点的 zoo.cfg 文件就应该这么改：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;########## koishi 节点配置 ##########&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# koishi 节点&lt;/span&gt;&lt;br/&gt;server&lt;span&gt;.1&lt;/span&gt;=&lt;span&gt;0.0.0.0&lt;/span&gt;:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# satori 节点&lt;/span&gt;&lt;br/&gt;server&lt;span&gt;.2&lt;/span&gt;=&lt;span&gt;82.157.146.194&lt;/span&gt;:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# marisa 节点&lt;/span&gt;&lt;br/&gt;server&lt;span&gt;.3&lt;/span&gt;=&lt;span&gt;123.60.7.226&lt;/span&gt;:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;########## marisa 节点配置 ##########&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# koishi 节点&lt;/span&gt;&lt;br/&gt;server&lt;span&gt;.1&lt;/span&gt;=&lt;span&gt;121.37.165.252&lt;/span&gt;:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# satori 节点&lt;/span&gt;&lt;br/&gt;server&lt;span&gt;.2&lt;/span&gt;=&lt;span&gt;82.157.146.194&lt;/span&gt;:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# marisa 节点&lt;/span&gt;&lt;br/&gt;server&lt;span&gt;.3&lt;/span&gt;=&lt;span&gt;0.0.0.0&lt;/span&gt;:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;但是在生产中，一个集群内的节点应该都位于同一网段，然后将配置文件中的 IP 全部换成内网 IP 即可。这样彼此之间可以通过内网访问，而内网的访问速度要远远快于公网，并且还不需要走公网的流量。但我当前的三台云服务器不在同一个网段，所以只能用公网 IP，并且绑定的时候，将节点自身的 IP 换成 0.0.0.0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至于等号左边的 &lt;/span&gt;&lt;span&gt;server. &lt;/span&gt;&lt;span&gt;是固定的，后面的数字表示节点的 id，而节点 id 我们说了，通过在 myid 文件中进行指定。而节点 id 决定了，最终由谁担任领导者。&lt;/span&gt;&lt;span&gt;其中 satori 节点的 id 为 2，刚刚已经改过了，然后将 koishi 和 marisa 两个节点的 id 分别改为 1 和 3，然后就大功告成了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后我们来启动 zookeeper，由于 satori 节点的 zookeeper 已经启动了，我们在修改完配置文件之后，需要重新启动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25663716814159293&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGlAmLDciaaLjpxOFE8Ak5FelSPHyIIygr2jOPx9oNXlXYRIWLbckRLgpfTDkE5qtIbl8sgGibq7USA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是我们查看状态的时候，发现出错了，相信原因很好想。因为配置文件中指定了三个节点，而剩余两个节点的 zookeeper 还没启动。下面我们来启动一下，然后再次查看状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.27629911280101394&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGlAmLDciaaLjpxOFE8Ak5FeVU3YR0k0BF8B68Hbt1PFq2mWD6jYRiaGE583NMd7j9SsKElDN8MicPbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1578&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当剩余的两个节点启动之后，再次查看状态，发现 Mode 变成了 Leader。显然集群已经启动成功，至于剩余的两个节点，显然就是 Follower。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4679860302677532&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGlAmLDciaaLjpxOFE8Ak5Feht8Z8viarzOV8mqfXYBgfbc7F6nCZhtVrTqUaNVcJNCicySW4Vd7Dbhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1718&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时集群就启动成功了，但是关于领导者和追随者的选举问题，我们还得再说一说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;领导者是怎么选出来的&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;领导者选举分为两种情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来看第一种情况，假设集群当中有 5 个节点，id 分别为 1 到 5，来看看选举过程是怎样的？这里 5 个节点按照 id 从小到大顺序启动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8738115816767502&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGlAmLDciaaLjpxOFE8Ak5FewOlbpnNYeRv8W5mYibFf0jribcZ9lQf4TtN9DUic3WG0kdqFYjibHE5YDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4628&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以 5 个节点，启动 3 个之后就能选择出 Leader。然后 server4 又启动了，于是也发起一次选举，并把票投给自己。但 server1,2,3 已经不是 LOOKING 状态，所以它们不会更改自己的选票信息，最终结果 server3 仍有 3 票，server4 只有 1 票。少数服从多数，于是会再将自己的选票交给 server3，成为 Follower，状态改为 FOLLOWING。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同理，最后 server5 启动，结果就是 server3 有 4 票，自己只有 1 票。少数服从多数，于是将自己的选票交给 server3，成为 Follower。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以整个过程，关键点有两个：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上就是集群第一次启动的时候，选举领导者。但如果在运行过程中，领导者挂了该怎么办呢？显然要再选举出一个新的领导者。所以当集群中的追随者发现自己连接不上领导者的时候，就会开始进入 Leader 选举，但此时是存在两种可能的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来解释第二种情况，server5 认为 server3 挂了之后，便会发起 Leader 选举，呼吁其它追随者进行投票。但是其它追随者发现领导者并没有挂，于是会拒绝 server5 的选举申请，并告知它当前已存在的领导者信息。对于 server5 而言，只需要和已存在的领导者重新建立连接，并进行数据同步即可。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;server3：老子还没挂呢，莫要造反。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;但如果是第一种情况，领导者真的挂了，该怎么办？比如这里的领导者 server3，在运行的时候，节点突然宕机了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要解释这个问题，我们需要引入一些新的概念。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;sid：就是我们一直说的服务器 id，用于唯一标识集群中的节点；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;zxid：事务 id，客户端在发起一次写请求的时候，都会带有 zxid，用于标识一次服务器状态的变更。所以 zookeeper 也是有事务的，保证每次写数据的时候，要么全部写完，要么不写，不会出现只写一半的情况。另外每个节点都有自己的 zxid，它们的值也不一定相同；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;epoch：Leader 任期的编号，就好比古代皇帝，每个皇帝在当政的时候都有自己的年号。并且每投完一次票，这个编号就会增加；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;现在假设 server3 挂了，那么要重新选举 Leader，而选举规则如下。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先比较节点之间的 epoch，epoch 大的直接当选；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;epoch 相同，再比较 zxid，zxid 大的当选；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;epoch 和 zxid 都相同，则比较 sid，sid 大的当选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;关于这么做背后的原理，我们先暂且不表，等到后面介绍 Paxos 协议的时候再细说。而且这里的 epoch 具体是干什么用的，估计也有人不太清楚，这些我们也留到后面再说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;客户端命令行操作&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们已经搭建好了 zookeeper 集群，接下来就是启动客户端，在里面输入增删改查相关的命令，然后发送给服务端执行，就类似于 Redis 一样。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 输入 zkCli.sh 即可启动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 会自动连接本地的 zookeeper 服务端&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 如果想连接其它节点的端，那么需要加上 -server 参数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 比如 zkCli.sh -server ip:2181&lt;/span&gt;&lt;br/&gt;[root@satori ~]&lt;/span&gt;&lt;span&gt;# zkCli.sh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;回车之后，客户端便可连接至 Leader 节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.26178861788617885&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGlAmLDciaaLjpxOFE8Ak5FeGzRgxhKpthAqh4g7icZ9sB7oZAabBEnh5AicEDaBGH9laW67joadeOLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1230&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后来看看命令都有哪些？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）ls：显示某个路径下的所有节点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4156545209176788&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGlAmLDciaaLjpxOFE8Ak5FewC8Bg5UCODUaYLjMp0etOFfCk7dERr3zGfibwibc9s7MP5EmMmYQ80xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1482&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）ls2：显示某个路径下的所有节点，以及当前节点的详细信息。但是该参数已经废弃，推荐使用 ls -s&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6753623188405797&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGlAmLDciaaLjpxOFE8Ak5Fe1auJR0ic8GCyY5nmnp56Nia12n7ibwpu1TCQn3t0HOxnbe32E3EgKwFvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不但显示根节点下面的所有节点，还显示了当前根节点的详细信息，就是绿色框框内的部分。那么它们都代表啥含义呢，来解释一下。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;cZxid：创建节点时的事务 ID，每次向 zookeeper 写入或者修改数据时都会产生一个事务 ID。它是 zookeeper 中所有修改的次序，如果 zxid1 小于 zxid2，那么 zxid1 对应的修改操作在 zxid2 之前发生；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ctime：当前节点的创建时间，时间戳形式，单位毫秒；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;mZxid：当前节点最后一次更新的事务 ID；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;mtime：当前节点最后一次更新的时间，时间戳形式，单位毫秒；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;pZxid：当前节点的子节点最后一次更新的事务 ID；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;cversion：当前节点的子节点变化了多少次；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;dataVersion：当前节点的数据变化了多少次；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;aclVersion：当前节点访问控制列表多少次；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ephemeralOwner：如果节点是临时节点，则表示节点拥有的 Session ID，如果不是则为 0。关于这里的临时节点，一会儿说。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;dataLength：节点可以存储数据，所以它表示数据的长度；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;numChildren：当前节点的子节点数量；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）create：创建节点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如 / 下面只有 zookeeper 这一个节点，我们再创建一个新的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39477977161500816&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGpHuVGIPpHBGTiaJgUWOJxsCVNx5HdghkRiboOhx5KuIiah9FicDeIib1d0cfLc5whKMyscJt3FEO1lDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1226&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为节点是用来存储数据的，所以创建节点的时候也应该指定相应的值，正如 Redis 在 set 一个 key 的时候也要指定 value 一样。当然不指定也可以，只不过不指定的话相当于值为 null。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过 create 创建的节点默认是持久节点，那么什么是持久节点呢？首先 zookeeper 的节点是有类型的，可以分为持久节点和临时节点：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外节点还可以带编号和不带编号，如果带编号的话，zookeeper 会自动在节点的末尾加上一串数字。比如上面的 /ow，它默认是不带编号的，如果我们创建的是带编号的，那么节点创建之后就会变成 /ow001。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;编号会依次递增，因此带编号的节点也叫做顺序节点。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;因此组合起来，zookeeper 的节点类型总共有 4 种。其中使用 zookeeper 作为分布式锁，便是基于&lt;/span&gt;&lt;span&gt;临时顺序&lt;/span&gt;&lt;span&gt;节点实现的。多个客户端同时往 zookeeper 上面创建临时顺序节点，谁的编号最小，那么谁就先创建成功，我们就认为它拿到了分布式锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当客户端操作完共享数据需要释放锁的时候，只需要断开连接即可，这样该客户端创建的临时节点就会自动删除。一旦节点删除，那么它的下一个顺序节点就成了编号最小的节点，从而拿到分布式锁，因此这个机制就避免了因客户端挂掉而导致的死锁问题。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;顺序节点非常有用，特别是在分布式系统中，编号可以用于为所有事件进行全局排序，这样客户端通过顺序号就能推断事件的顺序。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;使用 create 创建的节点默认是&lt;/span&gt;&lt;span&gt;持久非顺序&lt;/span&gt;&lt;span&gt;节点，那么其它类型的节点怎么创建呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）create -e：创建临时节点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.24731182795698925&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGpHuVGIPpHBGTiaJgUWOJxsskYKyhVtqdtTXUQ4D2icZlP6eF8vs0cRlP57Lpdqq3OK2icsfgOiamib8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1302&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;临时节点创建完毕，如果此时客户端断开连接，临时节点就会被删除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2189655172413793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGpHuVGIPpHBGTiaJgUWOJxsoQGHM4knpq1l9v9oITA4NTDo3aKgzesMjKUQr5MBib8loOYnicxky73Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们重启客户端，再次查看，发现临时节点已经被删除了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5&lt;strong&gt;）create -s：创建顺序（带编号）节点&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3904923599320883&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGpHuVGIPpHBGTiaJgUWOJxsbmqOAz0VaGvC7evicibrEVib8DAmt7JRB0LiayBnW12MA6ZmYsYiaVKHZmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;创建的时候，自动在结尾加上编号。我这里之前创建过几个，现在编号是从 11 开始，总之顺序节点的编号是递增的，只会增大，不会减小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以 -e 表示临时节点，-s 表示顺序节点，那如果创建临时顺序节点呢？很简单，两个参数一块指定即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.18883415435139572&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGpHuVGIPpHBGTiaJgUWOJxs6Xj6PASo61U9eVS9pplGDsSfTXCccEQfOFsJjnxYicz3syDCLVT4icfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端退出之后，这个临时节点就会消失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2903225806451613&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGpHuVGIPpHBGTiaJgUWOJxsiacDvcLLDltN0uLKmcTCqWlQf5oaib4VjgicC8nZ18KJOibEpib2jicP0txw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后再次创建，发现编号从 14 开始，因为顺序节点的编号只会依次增加。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6）get：获取节点内容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2631578947368421&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsHDLbwADr3NqXU0AxmnyuyQzfex0oOeVeYpsdg4WyxmzLjB27SHjhIHIMXrFeVmhrjWrgeCXmdeOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1292&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果加上 -s 参数，还可以获取节点的详细信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6619915848527349&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsHDLbwADr3NqXU0AxmnyuyQKuLQMWriaaCo8TpIiakYMJR0VN5iaycxiaXNicCPUCsdrctxzQlNXmKdKKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1426&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;/china 节点存储的值是 &lt;/span&gt;&lt;span&gt;beijing&lt;/span&gt;&lt;span&gt;，/china/henan 节点存储的值是 &lt;/span&gt;&lt;span&gt;zhengzhou&lt;/span&gt;&lt;span&gt;。所以 zookeeper 的数据结构就类似一个树，树上的每一个节点都可以存储具体的值，并且节点之间具有父子关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;7）set：修改节点内容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3081664098613251&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsHDLbwADr3NqXU0AxmnyuyQhX0WV9iaHBTNpgibEiaaWw3fmZCuwe0vibajSeHK7myUST6ObhZ6AOx7bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1298&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;create 表示创建一个新的节点，每个节点会存储一个值，get 表示获取节点存储的值，set 表示修改节点存储的值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意的是，节点不能重复，所以我们不能这么做：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1703056768558952&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsHDLbwADr3NqXU0AxmnyuyQPavP55TRHp9wydU3VItBQHegniaNfB0ib3icwD2aolATD4QmydibxWU0Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1374&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为 /china/henan 这个节点已经存在了，我们不能重复 create，所以要修改节点的值的话，应该使用 set。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8）get -w：监听某个节点的值的变化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设现在有两个客户端同时连接至 zookeeper 集群，客户端 A 执行 &lt;/span&gt;&lt;span&gt;get -w /china &lt;/span&gt;&lt;span&gt;就表示监听 &lt;/span&gt;&lt;span&gt;/china &lt;/span&gt;&lt;span&gt;这个节点。然后在客户端 B 上面对 &lt;/span&gt;&lt;span&gt;/china &lt;/span&gt;&lt;span&gt;这个节点进行 set，那么 A 机器上就会收到提示，提示我们监听的节点被修改了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9111111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsHDLbwADr3NqXU0AxmnyuyQwo56YHt1dEBwPyY5k9u88jQiayC2skSBb33jR4gNUxbW4fh5rTmx79w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：监听是一次性的，如果再次 set 的话，那么 A 机器就不会再提示了，除非再次 watch。另外除了节点的值被修改之外会提示，当节点被删除时也会提示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么这背后的原理是怎么实现的呢？首先监听的时候，客户端会创建两个子线程，一个负责网络通信（connector），另一个负责监听（listener）。通过 connector 将注册的监听事件发送给服务端，服务端&lt;/span&gt;&lt;span&gt;将注册的监听事件添加进注册监听器列表中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当服务端监听到有数据变化，就会将这个消息发送给 listener 线程，然后 listener 线程将消息输出出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;9）ls -w：监听某个节点的子节点变化&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4251655629139073&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsHDLbwADr3NqXU0AxmnyuyQ3mMH9dzicM5QjBnkYBqIZpFv6BA0ib9jzeMUqwkcDOvyq9GDJ3snLzow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1510&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;当新建一个子节点、或者删除一个子节点的时候，&lt;/span&gt;&lt;span&gt;就会收到提示，但是修改不会，所以这里监听的变化指的是子节点数量的变化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：这里只监听子节点的变化，子节点的子节点则不在范围之内。至于实现原理，和 get -w 相同，并且执行 ls -w 之后也只会监听一次。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;10）delete：删除节点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3362573099415205&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsHDLbwADr3NqXU0AxmnyuyQAaweC2JCEKsHvicvzbnNB3jmIlszUaCGtfT4zMGe0mVce5cbv93ud4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：delete 只能删除叶子节点，而非叶子节点、比如这里的 /china 就无法删除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.43802816901408453&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsHDLbwADr3NqXU0AxmnyuyQmun5GibibflLpXRzzM1mFbvR5R9964yzRS7pkc7GuibTvicL9ia14xGrnHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1420&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 3.5.0 之前删除非叶子节点使用的命令是 rmr，当然现在也可以使用，只不过废弃了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23255813953488372&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsHDLbwADr3NqXU0AxmnyuyQ6DOd1RSSGyRkpjSaKF6dvl8tSxSSITtXT8SmgnC2cxEx49su5d0z7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11）stat：查看节点状态&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5992647058823529&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsHDLbwADr3NqXU0AxmnyuyQpfRUlXDXgYf9EZXuhLc1lxp4hLDdv9pCJd049NYMX6LZ8f4VAvEJmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1088&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些字段的含义我们已经介绍过了，还可以通过&lt;/span&gt;&lt;span&gt; ls -s &lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt; get -s&lt;/span&gt;&lt;span&gt; 获取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;Python 连接 zookeeper&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面来看看如何用 Python 充当客户端，连接 zookeeper，之所以要介绍 Python 是因为笔者是 Python 系的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Python 连接 zookeeper 的话，需要安装第三方模块，模块名叫 kazoo，直接pip 安装即可。其实连接 zookeeper 还有一个模块，也叫 zookeeper，但是个人更推荐 kazoo，因为它是纯 Python 实现的，使用起来更方便。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt; kazoo.client &lt;span&gt;import&lt;/span&gt; KazooClient&lt;br/&gt;&lt;br/&gt;hosts = [&lt;br/&gt;    &lt;span&gt;&quot;82.157.146.194:2181&quot;&lt;/span&gt;,  &lt;span&gt;# satori 节点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;121.37.165.252:2181&quot;&lt;/span&gt;,  &lt;span&gt;# koishi 节点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;123.60.7.226:2181&quot;&lt;/span&gt;,    &lt;span&gt;# marisa 节点&lt;/span&gt;&lt;br/&gt;]&lt;br/&gt;&lt;span&gt;&lt;span&gt;# &lt;span&gt;输&lt;/span&gt;&lt;span&gt;入 ip:port，创建 zookeeper 客户端&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;span&gt;# 多个节点之间，使用逗号分&lt;/span&gt;隔&lt;/span&gt;&lt;br/&gt;client = KazooClient(&lt;span&gt;&quot;,&quot;&lt;/span&gt;.join(hosts))&lt;br/&gt;&lt;span&gt;# 和 zookeeper 集群建立连接&lt;/span&gt;&lt;br/&gt;client.start()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;start 函数里面接收一个 timeout，默认是 15 秒&lt;br/&gt;如果服务没有启动(目标计算机积极拒绝)&lt;br/&gt;那么会不断地尝试连接，直到超时&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;并且连接一旦建立，无论是连接丢失、还是会话过期，KazooClient 都会不断地尝试连接。&lt;/span&gt;&lt;span&gt;另外当客户端不需要再使用的时候，还可以调用 stop 方法，显式地中断连接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面来看看相关的 API。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# ls&lt;/span&gt;&lt;br/&gt;print(client.get_children(&lt;span&gt;&quot;/&quot;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;[&#x27;xyz&#x27;, &#x27;zookeeper&#x27;, &#x27;china&#x27;]&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 查询某个节点是否存在&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 不存在返回 None，存在则返回节点的信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 相当于 stat&lt;/span&gt;&lt;br/&gt;print(client.exists(&lt;span&gt;&quot;/abc&quot;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;None&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;print(client.exists(&lt;span&gt;&quot;/china&quot;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;ZnodeStat(czxid=17179869187, mzxid=17179869193, &lt;br/&gt;          ctime=1664981696194, mtime=1664981963644, &lt;br/&gt;          version=4, cversion=1, aversion=0, &lt;br/&gt;          ephemeralOwner=0, dataLength=6, numChildren=1,&lt;br/&gt;          pzxid=17179869188)&lt;br/&gt;&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 创建节点（可以递归创建）&lt;/span&gt;&lt;br/&gt;client.ensure_path(&lt;span&gt;&quot;/中国/四川/成都&quot;&lt;/span&gt;)&lt;br/&gt;print(client.get_children(&lt;span&gt;&quot;/&quot;&lt;/span&gt;))&lt;br/&gt;print(client.get_children(&lt;span&gt;&quot;/中国&quot;&lt;/span&gt;))&lt;br/&gt;print(client.get_children(&lt;span&gt;&quot;/中国/四川&quot;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;[&#x27;xyz&#x27;, &#x27;中国&#x27;, &#x27;zookeeper&#x27;, &#x27;china&#x27;]&lt;br/&gt;[&#x27;四川&#x27;]&lt;br/&gt;[&#x27;成都&#x27;]&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# ensure_path 只能创建节点，不能添加数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 如果想添加数据，需要使用 set 修改&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 但是有一点需要注意，set 的值，必须是 bytes 类型&lt;/span&gt;&lt;br/&gt;client.set(&lt;span&gt;&quot;/中国&quot;&lt;/span&gt;, &lt;span&gt;b&quot;CHINA&quot;&lt;/span&gt;)&lt;br/&gt;client.set(&lt;span&gt;&quot;/中国/四川&quot;&lt;/span&gt;, &lt;span&gt;b&quot;SICHUAN&quot;&lt;/span&gt;)&lt;br/&gt;client.set(&lt;span&gt;&quot;/中国/四川/成都&quot;&lt;/span&gt;, &lt;span&gt;b&quot;CHENGDU&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;# 使用 set 修改，get 获取&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 这个 zkCli.sh 的 API 是一致的&lt;/span&gt;&lt;br/&gt;print(client.get(&lt;span&gt;&quot;/中国&quot;&lt;/span&gt;))&lt;br/&gt;print(client.get(&lt;span&gt;&quot;/中国/四川&quot;&lt;/span&gt;))&lt;br/&gt;print(client.get(&lt;span&gt;&quot;/中国/四川/成都&quot;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;(b&#x27;CHINA&#x27;, ZnodeStat(czxid=17179869208, ...))&lt;br/&gt;(b&#x27;SICHUAN&#x27;, ZnodeStat(czxid=17179869209, ...))&lt;br/&gt;(b&#x27;CHENGDU&#x27;, ZnodeStat(czxid=17179869210, ...))&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 会将值和节点状态一起返回&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 创建节点除了使用 ensure_path，还可以使用 create&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# ensure_path 在创建节点的时候，不要求上一级必须存在，会递归创建&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 但是 create 创建的时候，要求上一级必须存在&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 并且 ensure_path 创建节点时不可以指定数据，只能后续set修改&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 但是 create 在创建节点时可以指定数据&lt;/span&gt;&lt;br/&gt;client.create(&lt;span&gt;&quot;/中国/上海&quot;&lt;/span&gt;, &lt;span&gt;b&quot;shanghai&quot;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;# 是否是顺序节点，默认为 False&lt;/span&gt;&lt;br/&gt;              sequence=&lt;span&gt;False&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;# 是否是临时节点，默认为 False&lt;/span&gt;&lt;br/&gt;              ephemeral=&lt;span&gt;False&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;# 查看 /中国 的子节点，会多出一个 &quot;上海&quot;&lt;/span&gt;&lt;br/&gt;print(client.get_children(&lt;span&gt;&quot;/中国&quot;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;[&#x27;四川&#x27;, &#x27;上海&#x27;]&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;print(client.get(&lt;span&gt;&quot;/中国/上海&quot;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;(b&#x27;shanghai&#x27;, ZnodeStat(czxid=17179869233, ...))&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 删除节点&lt;/span&gt;&lt;br/&gt;print(client.get_children(&lt;span&gt;&quot;/中国&quot;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;[&#x27;四川&#x27;, &#x27;上海&#x27;]&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;client.delete(&lt;span&gt;&quot;/中国/上海&quot;&lt;/span&gt;)&lt;br/&gt;print(client.get_children(&lt;span&gt;&quot;/中国&quot;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;[&#x27;四川&#x27;]&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# delete 方法默认只能删除叶子节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 如果想递归删除非叶子节点，需要多指定一个参数&lt;/span&gt;&lt;br/&gt;client.delete(&lt;span&gt;&quot;/中国&quot;&lt;/span&gt;, recursive=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;print(client.get_children(&lt;span&gt;&quot;/&quot;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;[&#x27;xyz&#x27;, &#x27;zookeeper&#x27;, &#x27;china&#x27;]&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;然后还有监听，监听的话，可以监听节点存储的数据的变化，也可以监听节点下面的子节点数量的变化。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;watch&lt;/span&gt;&lt;span&gt;(event)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    print(&lt;span&gt;&quot;观察者发现变化了&quot;&lt;/span&gt;)&lt;br/&gt;    print(event)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 执行 watch=True，即可开启监听&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 相当于 get -w&lt;/span&gt;&lt;br/&gt;client.get(&lt;span&gt;&quot;/xyz&quot;&lt;/span&gt;, watch=watch)&lt;br/&gt;&lt;span&gt;# 相当于 ls -w&lt;/span&gt;&lt;br/&gt;client.get_children(&lt;span&gt;&quot;/xyz&quot;&lt;/span&gt;, watch=watch)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 此时程序不会阻塞，如果在客户端退出之前&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 节点变化了，则触发 watch 函数的执行&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 或者还可以使用装饰器的方式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@client.DataWatch(&quot;/xyz&quot;)  &lt;span&gt;# get -w&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;watch1&lt;/span&gt;&lt;span&gt;(event)&lt;/span&gt;:&lt;/span&gt; &lt;span&gt;pass&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@client.ChildrenWatch&lt;span&gt;(&quot;/xyz&quot;)&lt;/span&gt;  &lt;span&gt;# ls -w&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;watch2&lt;/span&gt;&lt;span&gt;(event)&lt;/span&gt;:&lt;/span&gt; &lt;span&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;以上就是 Python 连接 zookeeper 的一些操作，还是很简单的。因为使用 zookeeper 本身也不会做太多复杂的操作，就是把它当成是一个配置中心，用于简单地数据存储以及数据监听。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;数据是怎么写入的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无论是 zookeeper 自带的客户端 zkCli.sh，还是使用 Python（或者其它语言）实现的客户端，本质上都是连接至集群，然后往里面读写数据。那么问题来了，集群在收到来自客户端的写请求时，是怎么写入数据的呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外客户端在访问集群的时候，本质上是访问集群内的某一个节点，而根据访问的节点是领导者还是追随者，写入数据的过程也会有所不同。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来看看当访问的节点是领导者的情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5400213447171825&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsEIKicpyQduAZAUmuof3PGN67fynEF94NnE5T1kCCecm4TykNlNB5lsrpbibgxL5jPGoOKe0e2KkotQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;937&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里面有一个关键的地方，就是 Leader 不会等到所有的 Follower 都写完，只要有一半的 Follower 写完，就会告知客户端。还是半数机制，一半的 Follower 加上 Leader 正好刚过半数。而这么做的原因也很简单，就是为了快速响应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再来看另一种情况，如果客户端访问的节点是追随者，情况会怎么样呢？其实很简单，由于追随者没有写权限，那么会先将写请求转发给领导者，然后接下来的步骤和上面类似，只是最后一步不同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当 Leader 发现有半数的 Follower 写完，就认为写数据成功，于是返回 ack。但这个 ack 不会返回给客户端，因为客户端访问的不是领导者，最终领导者会将 ack 返回给&lt;/span&gt;&lt;span&gt;客户端访问的追随者&lt;/span&gt;&lt;span&gt;，再由这个追随者将 ack 返回给客户端，告知写请求已执行完毕。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;基于 zookeeper 实现分布式锁&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于分布式锁，我之前介绍过&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NTczMDU2Mg==&amp;amp;mid=2247514814&amp;amp;idx=1&amp;amp;sn=61bf8611a69841da0b51669dc2bafbb5&amp;amp;chksm=cf3ff953f8487045a9b5b6cff3d2a7f924fe2ac23b02745d92541d712f2b28f7f01eca20a92d&amp;amp;token=1820488966&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如何基于 Redis 实现分布式锁&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;如何基于 Redis 实现分布式锁&lt;/a&gt;，里面对分布式锁做了比较详细的解析。如果你还不清楚分布式锁的相关概念，可以先看这篇文章，下面来聊一聊如何基于 zookeeper 实现分布式锁。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来说一下原理，当客户端需要操作共享资源时，需要先往 zookeeper 集群中创建一个临时顺序节点。然后查看对应的编号，如果没有比它小的，说明最先创建，我们就认为客户端拿到了分布式锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果客户端发现节点的编号不是最小的，说明已经有人先创建了，也就是锁已经被别的客户端拿走了。那么该客户端会对前一个节点进行监听，等待释放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6231481481481481&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsEIKicpyQduAZAUmuof3PGN6EzmriaPmk3ibvY2ibCKoyPT4r3ogRhoibgibey0JfHwRyVuNjFpiau0ghUng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以从概念上还是很好理解的，然后我们来编程实现一下。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt; typing &lt;span&gt;import&lt;/span&gt; List&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; queue&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; kazoo.client &lt;span&gt;import&lt;/span&gt; KazooClient&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DistributedLock&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, hosts: List[str])&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;        :param hosts: &#x27;ip1:port1,...&#x27;&lt;br/&gt;        &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;        self.client = KazooClient(&lt;span&gt;&quot;,&quot;&lt;/span&gt;.join(hosts))&lt;br/&gt;        self.client.start()&lt;br/&gt;        &lt;span&gt;# 要在 /lock 节点下面创建临时顺序节点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 所以先保证 /lock 节点存在&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; self.client.exists(&lt;span&gt;&quot;/lock&quot;&lt;/span&gt;):&lt;br/&gt;            self.client.create(&lt;span&gt;&quot;/lock&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 要创建的临时顺序节点&lt;/span&gt;&lt;br/&gt;        self.cur_node = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 要监听的节点（也就是上一个节点）&lt;/span&gt;&lt;br/&gt;        self.prev_node = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 本地队列&lt;/span&gt;&lt;br/&gt;        self.q = queue.Queue()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;acquire&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;        获取锁&lt;br/&gt;        :return:&lt;br/&gt;        &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;        self.cur_node = self.client.create(&lt;br/&gt;            &lt;span&gt;&quot;/lock/seq-&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;# 临时顺序节点&lt;/span&gt;&lt;br/&gt;            ephemeral=&lt;span&gt;True&lt;/span&gt;,&lt;br/&gt;            sequence=&lt;span&gt;True&lt;/span&gt;&lt;br/&gt;        )&lt;br/&gt;        &lt;span&gt;# create 方法会返回创建的节点名称&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 需要判断编号是不是最小的&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 因此要拿到所有的节点&lt;/span&gt;&lt;br/&gt;        nodes = self.client.get_children(&lt;span&gt;&quot;/lock&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# nodes: [&quot;seq-000..0&quot;, &quot;seq-000...1&quot;]&lt;/span&gt;&lt;br/&gt;        nodes.sort()&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; len(nodes) == &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;elif&lt;/span&gt; &lt;span&gt;&quot;/lock/&quot;&lt;/span&gt; + nodes[&lt;span&gt;0&lt;/span&gt;] == self.cur_node:&lt;br/&gt;            &lt;span&gt;# 如果 nodes 里面的最小值和 node 相等&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 说明该客户端创建的节点的编号最小&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 于是我们就认为它拿到了分布式锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 否则说明不是最小，因此要找到它的上一个节点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 也就是要监听的节点&lt;/span&gt;&lt;br/&gt;        index = nodes.index(self.cur_node.split(&lt;span&gt;&quot;/&quot;&lt;/span&gt;)[&lt;span&gt;-1&lt;/span&gt;])&lt;br/&gt;        self.prev_node = &lt;span&gt;&quot;/lock/&quot;&lt;/span&gt; + nodes[index - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;        &lt;span&gt;# 对上一个节点进行监听&lt;/span&gt;&lt;br/&gt;        self.client.get(self.prev_node, watch=self.watch)&lt;br/&gt;        &lt;span&gt;# 这一步不是阻塞的，但程序必须要拿到锁之后才可以执行&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 所以我们要显式地让程序阻塞在这里&lt;/span&gt;&lt;br/&gt;        self.q.get()&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;release&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;        释放锁&lt;br/&gt;        :return:&lt;br/&gt;        &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;        self.client.delete(self.cur_node)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;watch&lt;/span&gt;&lt;span&gt;(self, event)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;        监听函数，参数 event 是一个 namedtuple&lt;br/&gt;        kazoo.protocol.states.WatchedEvent&lt;br/&gt;        里面有三个字段：type、state、path&lt;br/&gt;&lt;br/&gt;        监听节点的值被改变时，type 为 &quot;CHANGED&quot;&lt;br/&gt;        监听节点被删除时，type 为 &quot;DELETED&quot;&lt;br/&gt;&lt;br/&gt;        path 就是监听的节点本身&lt;br/&gt;&lt;br/&gt;        state 表示客户端和服务端之间的连接状态&lt;br/&gt;        建立连接时，状态为 LOST&lt;br/&gt;        连接建立成功，状态为 CONNECTED&lt;br/&gt;        如果在整个会话的生命周期里，伴随着网络闪断、服务端异常&lt;br/&gt;        或者其他什么原因导致客户端和服务端连接断开，状态为 SUSPENDED&lt;br/&gt;        与此同时，KazooClient 会不断尝试与服务端建立连接，直至超时&lt;br/&gt;        如果连接建立成功了，那么状态会再次切换到 CONNECTED&lt;br/&gt;        &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; event.type == &lt;span&gt;&quot;DELETED&quot;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; \&lt;br/&gt;            self.prev_node == event.path:&lt;br/&gt;            &lt;span&gt;# 往队列里面扔一个元素&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 让下一个节点解除阻塞&lt;/span&gt;&lt;br/&gt;            self.q.put(&lt;span&gt;None&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 测试函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(lock, name)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    lock.acquire()&lt;br/&gt;    print(&lt;span&gt;f&quot;&lt;span&gt;{name}&lt;/span&gt;获得锁，其它人等着吧&quot;&lt;/span&gt;)&lt;br/&gt;    print(&lt;span&gt;f&quot;&lt;span&gt;{name}&lt;/span&gt;处理业务······&quot;&lt;/span&gt;)&lt;br/&gt;    print(&lt;span&gt;f&quot;&lt;span&gt;{name}&lt;/span&gt;处理完毕，释放锁&quot;&lt;/span&gt;)&lt;br/&gt;    lock.release()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;import&lt;/span&gt; threading&lt;br/&gt;    hosts = [&lt;br/&gt;        &lt;span&gt;&quot;82.157.146.194:2181&quot;&lt;/span&gt;,  &lt;br/&gt;        &lt;span&gt;&quot;121.37.165.252:2181&quot;&lt;/span&gt;,  &lt;br/&gt;        &lt;span&gt;&quot;123.60.7.226:2181&quot;&lt;/span&gt;,    &lt;br/&gt;    ]&lt;br/&gt;    &lt;span&gt;# 创建三把锁&lt;/span&gt;&lt;br/&gt;    lock1 = DistributedLock(hosts)&lt;br/&gt;    lock2 = DistributedLock(hosts)&lt;br/&gt;    lock3 = DistributedLock(hosts)&lt;br/&gt;    threading.Thread(&lt;br/&gt;        target=test, args=(lock1, &lt;span&gt;&quot;客户端1&quot;&lt;/span&gt;)&lt;br/&gt;    ).start()&lt;br/&gt;    threading.Thread(&lt;br/&gt;        target=test, args=(lock2, &lt;span&gt;&quot;客户端2&quot;&lt;/span&gt;)&lt;br/&gt;    ).start()&lt;br/&gt;    threading.Thread(&lt;br/&gt;        target=test, args=(lock3, &lt;span&gt;&quot;客户端3&quot;&lt;/span&gt;)&lt;br/&gt;    ).start()&lt;br/&gt;&lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;客户端1获得锁，其它人等着吧&lt;br/&gt;客户端1处理业务······&lt;br/&gt;客户端1处理完毕，释放锁&lt;br/&gt;客户端3获得锁，其它人等着吧&lt;br/&gt;客户端3处理业务······&lt;br/&gt;客户端3处理完毕，释放锁&lt;br/&gt;客户端2获得锁，其它人等着吧&lt;br/&gt;客户端2处理业务······&lt;br/&gt;客户端2处理完毕，释放锁&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;实现起来不是很难，并且使用 zookeeper 的好处就是，我们不需要担心死锁的问题。因为客户端宕掉之后，临时节点会自动删除，但缺点是性能没有 Redis 高。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外值得一提的是，kazoo 已经帮我们实现好了分布式锁，开箱即用，我们就不需要再手动实现了。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 创建客户端&lt;/span&gt;&lt;br/&gt;client = KazooClient(&lt;span&gt;&quot;,&quot;&lt;/span&gt;.join(hosts))&lt;br/&gt;client.start()&lt;br/&gt;&lt;span&gt;# 此时需要自己手动给一个唯一标识&lt;/span&gt;&lt;br/&gt;lock = client.Lock(&lt;span&gt;&quot;/lock&quot;&lt;/span&gt;, &lt;span&gt;&quot;unique-identifier&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;# 获取锁&lt;/span&gt;&lt;br/&gt;lock.acquire()&lt;br/&gt;&lt;span&gt;# 处理业务逻辑&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;# 释放锁&lt;/span&gt;&lt;br/&gt;lock.release()&lt;br/&gt;&lt;span&gt;# 或者也可以使用上下文管理器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;with&lt;/span&gt; lock:&lt;br/&gt;    ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;显然就优雅多了，借助于 kazoo 实现好的分布式锁，可以减轻我们的心智负担。此外 kazoo 还提供了读锁和写锁：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;client.ReadLock&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;client.Write&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;oc&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;我们一般使用 client.Lock 就行，可以自己测试一下。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于 zookeeper 的基础内容就介绍到这里，但伴随着 zookeeper 还有一系列的协议，比如 Paxos 协议、ZAB 协议、CAP 定理等等，这些可谓是分布式系统的重中之重。我们后续来逐一介绍。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;本文来自于：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>771d4048c27a1704c24b283ac04b63bc</guid>
<title>TypeScript 与 JavaScript：你应该知道的区别</title>
<link>https://toutiao.io/k/qiuy444</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;作者：京东零售 杨冰&lt;/p&gt;

&lt;p&gt;译自Radix网站的文章，原文链接：&lt;a href=&quot;https://radixweb.com/blog/typescript-vs-javascript%EF%BC%8C%E5%8E%9F%E6%96%87%E4%BD%9C%E8%80%85%EF%BC%9ANihar&quot;&gt;https://radixweb.com/blog/typescript-vs-javascript，原文作者：Nihar&lt;/a&gt; Raval&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-28-21-11tImaXS9lFBuG927E.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;正在寻找经验丰富的 JavaScript 开发团队来将您的应用创意变为现实？作为一名开发人员，如果您有机会参与 Web 开发项目，您一定了解 JavaScript 的工作原理。JavaScript 上市多年，已成为开发者社区中流行的脚本语言。&lt;/p&gt;

&lt;p&gt;但正如我们所知，如果一种技术或语言正在崛起，总会有另一种选择进入市场并与领先者展开激烈竞争。这里有一个新的竞争对手 ——TypeScript。随着 TypeScript 的日益普及，我们可以将其视为具有额外功能的 JavaScript 增强版。&lt;/p&gt;

&lt;p&gt;谈到 TypeScript，它是一种用于开发大型复杂应用程序的开源编程语言。TypeScript 由科技巨头之一——微软——于 2012 年开发，其创建背后的真正原因是处理大型应用程序。&lt;/p&gt;

&lt;p&gt;此外，Angular 还使用 TypeScript 进行 Web 开发服务。根据这项研究，TypeScript 和 JavaScript 分别是开发人员希望使用的第二和第三大流行语言。你知道为什么吗？&lt;/p&gt;

&lt;p&gt;实际上，JavaScript 被认为是应用程序和网页的主要脚本语言。因此，现在，我们可以将 JavaScript 用于TezJS 、React等前端框架，以及 Node.Js 和 Deno 框架的后端。&lt;/p&gt;

&lt;p&gt;但现在真正的问题是，JavaScript 是为创建大型复杂的 Web 应用程序而开发的吗？我想答案是否定的！&lt;/p&gt;

&lt;p&gt;在本文中，我们将比较这两种编程语言——TypeScript 与 JavaScript，它们之间的关系，它们的区别，并概述每种语言的优点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但在此之前，在此视频中快速了解 TypeScript 和 JavaScript 之间的差异。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/mDO92vysVkY&quot;&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-28-21-07jIKLkHGJY7Fu2pF.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;TypeScript 与 JavaScript：真正的区别&lt;/h1&gt;

&lt;p&gt;如果我们同时考虑两者——TypeScript 与 JavaScript，那么每个 JavaScript 代码在 TypeScript 中都是有效的。这意味着 TypeScript 是 JavaScript 的超集。&lt;/p&gt;

&lt;p&gt;换句话说，我们可以说，&lt;/p&gt;

&lt;p&gt;JavaScript + 更多功能 = TypeScript&lt;/p&gt;

&lt;p&gt;因此，如果您将 JavaScript 编程文件 (.js) 保存为 TypeScript (.ts) 扩展名，它将执行得非常好。但这并不意味着这两种语言——TypeScript 和 JavaScript 是一样的。&lt;/p&gt;

&lt;p&gt;因此，在进一步深入之前，让我们先了解一下每种语言的基本定义。以下是来自 Google Trends 的数据，显示了这两种前端语言过去一年的搜索趋势。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-28-21-10mgms2Iu8E2GIgLc.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;为什么在有 JavaScript 的情况下开发 TypeScript？&lt;/h1&gt;

&lt;p&gt;JavaScript 语言是作为客户端编程语言引入的。但是随着 JavaScript 在 Web 开发中的使用，开发人员了解到它也可以被视为一种服务器端编程语言。&lt;/p&gt;

&lt;p&gt;然而，JavaScript 代码也变得相当复杂和沉重。因此，JavaScript 无法满足面向对象编程语言的期望。因此，JavaScript 永远不会作为服务器端技术在业界蓬勃发展。这就是为什么 TypeScript 语言诞生来弥合这一差距的原因。&lt;/p&gt;

&lt;h1&gt;什么是TypeScript？&lt;/h1&gt;

&lt;p&gt;如果被问到“什么比 JavaScript 更好？”，您一定会得到答案——TypeScript。&lt;/p&gt;

&lt;p&gt;TypeScript 由 Microsoft 开发和维护，是一种面向对象的开源编程语言。它是 JavaScript 的超集，包含可选类型。此外，它还可以编译为纯 JavaScript。&lt;/p&gt;

&lt;p&gt;简而言之，TypeScript 是一种静态编译的编程语言，用于编写清晰简洁的 JavaScript 代码。它实现与 JavaScript 相同的目的，可用于客户端和服务器端应用程序。此外，JavaScript 的库也兼容 TypeScript。&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-28-21-12LegGeYAZEB7Q6ey.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
TypeScript 是一种同时支持动态类型和静态类型的编程语言。它提供类、可见性范围、命名空间、继承、联合、接口和许多其他特性。此外，它还提供注释、变量、语句、表达式、模块和函数。&lt;/p&gt;

&lt;p&gt;您可以在 Node.Js 或任何其他支持 ECMAScript 3 或其最新版本的浏览器上执行它。&lt;/p&gt;

&lt;p&gt;由于 TypeScript 是 JavaScript 的增强版本，因此 JavaScript 的所有代码在语法上都是有效的 TypeScript。但是，这并不意味着 TypeScript 编译器可以处理所有 JavaScript：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let a = &#x27;a&#x27;; a = 1; // throws: error TS2322: Type &#x27;1&#x27; is not assignable to type &#x27;string&#x27;.


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TypeScript 提供的文件可以包含来自当前目标文件的类型数据，类似于 C++ 头文件如何定义当前目标文件的创建。因此，其他应用程序可以使用文件中定义的值，就像使用静态类型值的 TypeScript 实体一样。&lt;/p&gt;

&lt;p&gt;您还会找到流行库（如 jQuery、D3.js 和 MongoDB）的第三方头文件。还有用于 NodeJs 基本模块的 TypeScript 标头，允许在 TypeScript 中进行 Node.Js 开发。&lt;/p&gt;

&lt;p&gt;TypeScript 的编译器是在 JavaScript 中组装并用 TypeScript 编写的。它在 Apache License 2.0 下注册。&lt;/p&gt;

&lt;p&gt;看完 TypeScript 介绍后，您一定想知道将静态类型添加到 JavaScript 的目的是什么？&lt;/p&gt;

&lt;p&gt;好吧，我们可以用给定的陈述来澄清你的疑虑：&lt;/p&gt;



&lt;p&gt;根据这项研究，TypeScript 识别出大约 15% 的 JavaScript 错误。&lt;/p&gt;

&lt;p&gt;动态类型的自由性经常导致错误，这不仅降低了开发人员的效率，而且由于添加新代码行的开销增加而使开发变得很费劲。&lt;/p&gt;

&lt;p&gt;因此，由于缺乏类型和编译时错误检查，JavaScript 对于组织和大型代码库中的服务器端代码来说是一个糟糕的选择。&lt;/p&gt;

&lt;p&gt;正如他们的标语所暗示的那样，TypeScript 是可扩展的 JavaScript。&lt;/p&gt;

&lt;h1&gt;为什么我们需要使用 TypeScript？&lt;/h1&gt;

&lt;p&gt;正如我们之前所说，TypeScript 是 JavaScript 的增强版。因此，在将它与 CoffeeScript（添加了语法糖）或 PureScript（与 JavaScript 完全不相似）等其他语言进行比较时，编写 TypeScript 代码需要学习很多东西。&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-28-21-15ODz7T9915qMKBWl9.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在 TypeScript 中，类型是可选的，任何 JavaScript 文件都是有效的 TypeScript 文件。虽然如果您的任何初始文件存在类型问题，编译器会通知您，但它仍会提供一个有效的 JavaScript 文件。TypeScript 将不负众望，随着时间的推移提高您的技能也很简单。&lt;/p&gt;

&lt;h1&gt;TypeScript 适合前端还是后端？&lt;/h1&gt;

&lt;p&gt;由于 TypeScript 被编译为 JavaScript，因此它适用于应用程序开发的前端和后端。&lt;/p&gt;

&lt;p&gt;此外，JavaScript 是网页和应用程序前端的首选编程语言。因此，出于同样的原因，可能会使用 TypeScript，但它在服务器端也适用于复杂的大型企业项目。&lt;/p&gt;

&lt;p&gt;但是，您也可以使用其他&lt;a href=&quot;https://radixweb.com/blog/top-front-end-frameworks-for-web-development&quot;&gt;顶级前端框架&lt;/a&gt;（如 React、Angular、Vue）来构建下一代应用程序。&lt;/p&gt;

&lt;h1&gt;TypeScript 的类型&lt;/h1&gt;

&lt;p&gt;TypeScript 包含各种基本类型，例如 Number、Array、Tuple、Boolean、String 等等。好吧，其中一些类型在 JavaScript 中不可用。&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html&quot;&gt;但是，您可以在TypeScript 文档&lt;/a&gt;中了解有关它们的更多信息。&lt;/p&gt;

&lt;p&gt;此外，下面是一些其他类型，它们是 TypeScript 的表现力：&lt;/p&gt;

&lt;h2&gt;Any &amp;amp; Unknown&lt;/h2&gt;

&lt;p&gt;一个名为 Any（任何你想要的）的类型可以覆盖 unknown 是它的类型安全系统。在这里，any 允许您在想要转义类型系统时分配和 JavaScript 变量。它广泛用于描述尚未验证且类型未知的传入变量（例如，来自第三方 API）。&lt;/p&gt;

&lt;p&gt;Unknown 类似于 Any，但它不允许您对它执行任何操作，除非它已明确进行类型检查。&lt;/p&gt;

&lt;h2&gt;Void&lt;/h2&gt;

&lt;p&gt;当没有返回值时，使用 Void。一般用于不返回任何函数的返回类型。&lt;/p&gt;

&lt;h2&gt;Never&lt;/h2&gt;

&lt;p&gt;Never 是不应该发生的事情的返回类型，例如异常抛出函数。&lt;/p&gt;

&lt;h2&gt;Intersection &amp;amp; Union Types(交集和并集类型)&lt;/h2&gt;

&lt;p&gt;这些类型允许您根据逻辑创建自定义类型。&lt;/p&gt;

&lt;p&gt;交集类型让您可以将几种基本类型组合成一种类型。例如，如果我们创建一个自定义类型 Person，它包含&lt;code&gt;first_name:string&lt;/code&gt;一个&lt;code&gt;last_name:string&lt;/code&gt;. 好吧，你可以这样说：我希望我的类型&lt;strong&gt;是这样且那样的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;联合类型允许您输入各种基本类型之一。例如，如果有一个返回&lt;code&gt;result:string&lt;/code&gt;or&lt;code&gt;undefined&lt;/code&gt;，您可以这样说：我希望我的类型&lt;strong&gt;是这个或那个&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当您将它们视为空间时，所有这些类型都有意义。&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-28-21-24FPod9KEAThDKI2m.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;TypeScript 同时支持隐式和显式类型。如果您不显式编写类型，编译器将启用类型推断来识别您正在使用的类型。&lt;/p&gt;

&lt;p&gt;另一方面，明确编写它们会带来好处，例如协助其他团队成员阅读您的代码并验证您所看到的是编译器所看到的。&lt;/p&gt;

&lt;h1&gt;TypeScript 的特点&lt;/h1&gt;

&lt;p&gt;借助 TypeScript 的高级特性，它支持 JavaScript 的附加特性，例如面向对象的编程概念、JS 库、平台无关性等。&lt;/p&gt;

&lt;h2&gt;Compatibility（兼容性）&lt;/h2&gt;

&lt;p&gt;TypeScript 也支持旧的和新的附加功能。但是，它兼容所有版本的 JavaScript，例如 ES7 和 ES12。它可以将 ES7 中的完整代码编译回 ES5，反之亦然。这确保了平稳过渡和语言可移植性。&lt;/p&gt;

&lt;h2&gt;Static Typing（静态类型）&lt;/h2&gt;

&lt;p&gt;静态类型意味着开发人员必须声明变量类型。&lt;/p&gt;

&lt;p&gt;假设我们取变量名 str。代码将不会运行，直到您给它一个类型，例如 Integer、Float、List 或任何其他类型。而 TypeScript 是静态类型的。&lt;/p&gt;

&lt;p&gt;静态类型可以帮助您及早检测错误、更快地完成代码等等。&lt;/p&gt;

&lt;p&gt;现在，让我们在这里为您提供其他突出的特点：&lt;/p&gt;



&lt;h1&gt;TypeScript 的优点&lt;/h1&gt;

&lt;p&gt;TypeScript 提供了多种优势，可以帮助您为 Web 开发编写更好的编程语言。&lt;/p&gt;

&lt;h2&gt;Language Features（语言特性）&lt;/h2&gt;

&lt;p&gt;以下是 TypeScript 支持的其他功能。&lt;/p&gt;



&lt;h2&gt;Optional Parameters（可选参数）&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// -- TypeScript -- //
function log(message: string = null) { }
// -- TypeScript compiled output -- //
function log(message) {
if (message === void 0) { message = null; }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// -- JavaScript with Babel -- //
function Log(message = null) { }
// -- Babel compiled output -- //
&quot;use strict&quot;;
function Log() {
var message = arguments.length &amp;gt; 0 &amp;amp;&amp;amp; arguments[0] !== undefined ? arguments[0] : null;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Classes Class方式&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// -- TypeScript -- //
class Article {
name: string;
constructor(name: string) {
this.name = name;
}
}
// -- TypeScript compiled output -- //
var Article = /** @class */ (function () {
function Article(name) {
this.name = name;
}
return Article;
}());


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// -- JavaScript with Babel -- //
class Article {
constructor(name) {
this.name = name;
}
}
// -- Babel compiled output -- //
&quot;use strict&quot;;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }
var Article = function Article(name) {
_classCallCheck(this, Article);
this.name = name;
};


&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;什么是 JavaScript？&lt;/h1&gt;

&lt;p&gt;JavaScript – 一种脚本语言，用于开发交互式网页。它遵守客户端编程规则；因此，它可以在用户的​​网络浏览器中无缝执行。但是，您可以将 JavaScript 与其他技术（如 XML 和 REST API）结合使用。&lt;/p&gt;

&lt;p&gt;JS 的主要目的是使其成为一种互补的脚本语言，类似于 Visual Basic 之于 C++。但是，JavaScript 不适合大型复杂应用程序。它旨在为一个应用程序只编写几百行代码。&lt;/p&gt;

&lt;p&gt;以下是 JavaScript 提供的一些独特功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;灵活、动态和跨平台&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它可以用于客户端和服务器端&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;轻量化解读&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有浏览器都支持&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;弱类型&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;即时编译&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;TypeScript 和 JavaScript 之间的区别&lt;/h1&gt;

&lt;p&gt;TypeScript 和 JavaScript 之间的区别&lt;br/&gt;
在比较两种编程语言——TypeScript 和 JavaScript 时，我们必须考虑许多因素，如下所示：&lt;/p&gt;

&lt;h2&gt;1) 学习曲线&lt;/h2&gt;

&lt;p&gt;TypeScript 是 JavaScript 的超集。要编写 TypeScript 代码，您应该对 JavaScript 有基本的了解和知识。此外，您还应该清楚 OOPS 的概念。&lt;/p&gt;

&lt;p&gt;另一方面，JavaScript 是一种流行且易于学习的脚本语言。许多开发人员将 JavaScript 与 CSS 和 HTML 结合使用来创建 Web 应用程序。然而，HTML 很难，因为它包含事件处理、Web 行为、动画和脚本。&lt;/p&gt;

&lt;h2&gt;2）开发者社区&lt;/h2&gt;

&lt;p&gt;TypeScript 在短时间内流行起来，并被许多企业实施。您会在 Internet 上找到许多学习 TypeScript 的教程和指南。但是，它有一个非常活跃和支持的社区。&lt;/p&gt;

&lt;p&gt;另一方面，与 TypeScript 相比，JavaScript 没有庞大的社区。JavaScript 提供了许多库、框架和代码实践。因此，建议您了解最适合您的业务需求的&lt;a href=&quot;https://radixweb.com/blog/guide-to-build-web-development-team-structure&quot;&gt;Web 开发团队结构，以获得整体团队绩效。&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;3）性能&lt;/h2&gt;

&lt;p&gt;众所周知，创建 TypeScript 是为了克服 JavaScript 对大型复杂应用程序的挑战。因此，TypeScript 节省了开发时间并让开发人员变得更有效率。&lt;/p&gt;

&lt;p&gt;TypeScript 和 JavaScript 之间的唯一区别是 TypeScript 代码在执行之前被编译成 JavaScript。&lt;/p&gt;

&lt;h2&gt;4) 语法&lt;/h2&gt;

&lt;p&gt;TypeScript 提供了 JavaScript 不提供的变量声明、函数范式和类型系统。它在语法方面类似于 JScript 和 .Net，支持 ECMAScript 2015 标准功能，包括模块、箭头函数语法和类。&lt;/p&gt;

&lt;p&gt;JavaScript 也遵循 ECMAScript 定义。但是，它不是像 TypeScript 这样的类型化语言。它使用许多来自 C 语言的结构化编程术语，例如 if 语句、switch 语句、do-while 循环等等。它提供事件驱动风格、函数式和命令式编程。&lt;/p&gt;

&lt;h2&gt;5）工具和框架&lt;/h2&gt;

&lt;p&gt;由于微软支持 TypeScript，它拥有许多领先的框架和编辑器。通过与编辑器的紧密集成，它提供了编译期间的错误处理，以避免在运行时出错。&lt;/p&gt;

&lt;p&gt;另一方面，市场上有许多&lt;a href=&quot;https://radixweb.com/blog/best-javascript-frameworks-for-web-development&quot;&gt;JavaScript 框架可用于 Web 开发项目需求。&lt;/a&gt;这是一个非常受程序员欢迎的巨大生态系统。您可以快速找到精通 ReactJS、VueJS、Angular 和其他框架的开发人员。&lt;/p&gt;

&lt;h2&gt;6）代码&lt;/h2&gt;

&lt;p&gt;对于TypeScript：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person
{
private name: string;
constructor (private name: string)
{
this.name = name;
}
name()
{
return “name is “ + this.name;
}
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 JavaScript：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Person = (function()
{
function Person(personName)
{
this.name = personName;
}
Person.prototype.name= function()
{
return &quot;My name is &quot; + this.name;
}
return Person;
})();


&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;TypeScript 与 JavaScript 有何不同？&lt;/h1&gt;

&lt;p&gt;我们知道 TypeScript 提供的功能比 JavaScript 多。简而言之，TypeScript 是一种面向对象的编程语言，而 JavaScript 是一种脚本语言。因此，TypeScript 通过 ES6 特性提供接口和模块；另一方面，JavaScript 不提供此类功能。&lt;/p&gt;

&lt;p&gt;实际上，一些开发人员可能会混淆面向对象和函数式编程语言。但是，您可以在这里区分&lt;a href=&quot;https://radixweb.com/blog/functional-programming-vs-oop&quot;&gt;函数式编程与面向对象的编程语言&lt;/a&gt;，并了解它们之间的区别。&lt;/p&gt;

&lt;h1&gt;为什么要将您的项目迁移到 TypeScript？&lt;/h1&gt;

&lt;p&gt;如果您有一个庞大而复杂的代码库，则发生错误的可能性更高。但是，如果能在编译期间解决了一些错误，那就太好了。这时你可以使用 TypeScript 来减少编译时的错误。最好的部分是完整的 Java （此处应该是作者笔误，应该是JavaScript）代码库可以按原样重用。&lt;/p&gt;

&lt;h1&gt;何时选择：JavaScript 和 TypeScript 的区别&lt;/h1&gt;

&lt;h2&gt;TypeScript&lt;/h2&gt;

&lt;p&gt;| 编译时类型检查 | 使用 Vanilla JavaScript，类型验证在运行时执行。然而，这会增加运行时开销，这可以通过进行编译时验证来避免。 | | 大型项目或多个开发人员 | TypeScript 可以在大型项目或许多开发人员一起工作时无缝运行。 | | 易于使用新库或框架 | 假设，如果你正在使用 React 进行开发并且不熟悉它的 API，你可以获得 语法提示来帮助你识别和导航新界面。但是，它们都提供类型定义 |&lt;/p&gt;

&lt;h2&gt;JavaScript&lt;/h2&gt;

&lt;p&gt;| 小项目 | 对于代码较少的小型项目，TypeScript 可能有点矫枉过正。 | | 框架支持 | 如果 TypeScript 不支持您选择的框架 – 例如EmberJS，那么您可能无法利用它的功能。 | | 构建工具 | 要生成能运行的最终 JavaScript，TypeScript 需要有一个构建的步骤。不过，在不使用任何构建工具的情况下开发 JavaScript 应用正变得越来越少。 | | 测试工作流程 | 如果您优秀的 JavaScript 开发人员已经在使用测试驱动开发，那么切换到 TypeScript 的好处可能不足以证明迁移成本是合理的。 |&lt;/p&gt;

&lt;h1&gt;我应该学习 JavaScript 还是 TypeScript？&lt;/h1&gt;

&lt;p&gt;如果你了解 JavaScript，那么你就很容易理解 TypeScript。它们两种语言共享相同的语法和运行时行为。&lt;/p&gt;

&lt;p&gt;作为最流行的语言，JavaScript 提供了许多资源和庞大的开发人员社区。由于两种语言在很多情况下都以相同的方式执行，因此TypeScript 开发人员也可以从这些资源中受益。&lt;/p&gt;

&lt;h1&gt;TypeScript 相对于 JavaScript 的优势&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;TypeScript 支持静态类型。这意味着静态类型允许在构建时检查类型的准确性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在开发时，TypeScript 会识别编译错误。因此，运行时评估错误的范围非常小。另一方面，JavaScript 是一种解释型语言。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TypeScript 只是具有一些额外功能的 JS，即 ES6 功能。TS 编译器可以将 .ts 文件编译成 ECMAScript，尽管它可能不会保存在您选择的 Web 浏览器中。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;TypeScript 会取代 JavaScript 吗？&lt;/h1&gt;

&lt;p&gt;那么，上述问题的最短答案是否定的！&lt;/p&gt;

&lt;p&gt;在谈论 TypeScript 时，它是一种完全不同的语言，只是它继承了 JavaScript 的基本性质。因此，JavaScript 永远也不会被取代。&lt;/p&gt;

&lt;p&gt;JavaScript 是软件开发行业中流行的基础技术之一，被大量开发人员用于客户端和服务器端。&lt;/p&gt;

&lt;p&gt;另一方面，TypeScript 不直接在 Web 浏览器中执行。它转译为 JavaScript。JavaScript 更容易调试和编译，因为它直接在 Web 浏览器中执行。然而，TypeScript 并不是为所有类型的项目开发的。因此，两种编程语言都有其优点和缺点以及一组特征。为了顺应企业 Web 发展趋势，您必须采用新技术或框架来获得更好的业务流程和客户体验。&lt;/p&gt;

&lt;h1&gt;正面比较：TypeScript 与 JavaScript&lt;/h1&gt;

&lt;p&gt;TypeScript 和 JavaScript 在开发交互式网页方面有许多相似之处。在提供 TypeScript 与 JavaScript 的直接比较时，我们可以说 JavaScript 是一种轻量级的解释型动态语言，用于增强 HTML 网页。另一方面，TypeScript 是 JavaScript 的增强版。这意味着 TypeScript 是 JavaScript 和其他一些特性的组合。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;TypeScript是由 Microsoft Corporation 开发的一种面向对象的编程语言，而JavaScript是用于 Web 的编程语言。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TypeScript是一种用于构建大型 Web 应用程序的开源语言，而JavaScript是一种有助于开发交互式网页的服务器端编程语言。&lt;br/&gt;
另一方面，TypeScript 是 JavaScript 的增强版。这意味着 TypeScript 是 JavaScript 和其他一些特性的组合。&lt;br/&gt;
&lt;strong&gt;让我们了解下表中 TypeScript 与 JavaScript 的重要区别。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;范围&lt;/th&gt;
&lt;th&gt;Typescript&lt;/th&gt;
&lt;th&gt;JavaScript&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;开发者&lt;/td&gt;
&lt;td&gt;Microsoft in 2012&lt;/td&gt;
&lt;td&gt;Brendan Eich (Netscape)，1995 年&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;定义&lt;/td&gt;
&lt;td&gt;TypeScript 是一种强大的面向对象语言，作为 JavaScript 的超集，具有泛型和 JS 特性来解决 JS 的复杂问题。&lt;/td&gt;
&lt;td&gt;JavaScript 是一种脚本语言，具有创建动态网页的一流功能。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;强类型。TypeScript 支持静态类型和动态类型。&lt;/td&gt;
&lt;td&gt;弱类型 。JavaScript 仅支持动态类型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;生态&lt;/td&gt;
&lt;td&gt;TypeScript 更像是一种支持静态类型的强大而直观的语言。&lt;/td&gt;
&lt;td&gt;JavaScript 是一种简单的语言，它优化了代码的兼容性，易于阅读和编写。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;编译&lt;/td&gt;
&lt;td&gt;TypeScript 需要编译。&lt;/td&gt;
&lt;td&gt;JavaScript 不需要编译。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据绑定&lt;/td&gt;
&lt;td&gt;TypeScript 利用接口和类型等概念来定义所使用的数据。&lt;/td&gt;
&lt;td&gt;JavaScript 中没有这样的概念。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;学习曲线&lt;/td&gt;
&lt;td&gt;TypeScript 有一条不友好的学习曲线。此外，它需要JavaScript知识。&lt;/td&gt;
&lt;td&gt;它易于学习并且是一种用于编写 Web 脚本的灵活语言。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Npm 包&lt;/td&gt;
&lt;td&gt;使用Typescript，许多npm包要么有静态类型定义，要么有一个更容易安装的外部类型定义。&lt;/td&gt;
&lt;td&gt;JavaScript提供了不需要任何构建步骤就可以搜索和生成代码的替代方案。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;客户端或服务器端&lt;/td&gt;
&lt;td&gt;TypeScript 专门用于客户端。&lt;/td&gt;
&lt;td&gt;JavaScript 用于服务器端和客户端。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件扩展名&lt;/td&gt;
&lt;td&gt;.tsx 和 .ts&lt;/td&gt;
&lt;td&gt;.js&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;社区&lt;/td&gt;
&lt;td&gt;TypeScript 有一个较小的软件开发者社区。&lt;/td&gt;
&lt;td&gt;JavaScript 拥有庞大的软件开发人员社区。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;原型设计&lt;/td&gt;
&lt;td&gt;原型设计特性在 TypeScript 中可用。&lt;/td&gt;
&lt;td&gt;JS 不支持原型设计。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;公司和网站&lt;/td&gt;
&lt;td&gt;Asana, Clever, Screen award&lt;/td&gt;
&lt;td&gt;Airbnb、Codecademy、Instagram&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;代码示例&lt;/td&gt;
&lt;td&gt;&lt;code&gt;function multiply (a, b){ return a*b;}var result = multiply(a, b);console.log(&#x27;答案是 - &#x27; + result);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;script&amp;gt;function multiply (a, b){ return a\*b;}var result = multiply(a, b);document.write (‘The answer is – ’ + result);&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h1&gt;结论&lt;/h1&gt;

&lt;p&gt;最后，在阅读了我们在本文中整理的所有见解之后，我们可以说这两种语言各有利弊。&lt;/p&gt;

&lt;p&gt;TypeScript 适合想要创建整洁干净的可读代码的开发人员。好吧，我们没有提到 TypeScript 提供了什么，包括各种实时错误检查和静态类型。&lt;/p&gt;

&lt;p&gt;虽然 JavaScript 不是一种综合性的编程语言，但它可以与 HTML 一起使用来提高网页的质量。甚至，您会发现许多精通 JavaScript 编码的经验丰富的开发人员。&lt;/p&gt;

&lt;p&gt;但是，与 JavaScript 一样，并非所有 Web 浏览器都支持 TypeScript。所以，如果你在 TypeScript 和 JavaScript 之间纠结，可以参考上面的文章。&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;初次翻译，个人水平有限，有翻译不恰当的地方欢迎大佬们指正。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>