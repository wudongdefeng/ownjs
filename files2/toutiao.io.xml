<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>daf5606db97de013af77038a6ca42af3</guid>
<title>想要做好代码质量，如何破局？</title>
<link>https://toutiao.io/k/s9s8hub</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：苗现方&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想要做好代码质量，我们不得不提什么是代码质量？本文中讨论的代码质量一般是指代码的风格、重复率和复杂度等，代码是技术团队的价值产物，是宝贵的财富，同样代码质量的好坏可以直接体现出团队的重视程度和技术管理水平。&lt;/p&gt;

&lt;p&gt;代码质量的下降是内在原因，通常会恶性循环，&lt;strong&gt;主要表现出以下两个特性：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;感染性：坏代码总能在部门渲染着只要业务交付达成，代码质量不重要的负面气氛，严重减低了研发人员的技术热情，破坏工作氛围，导致更多的坏代码出现。&lt;/p&gt;

&lt;p&gt;心理暗示性：在坏代码基础上继续生产坏代码的&quot;罪过&quot;减轻。&lt;/p&gt;

&lt;p&gt;为什么会产生这样的结果，这里我与你举个生活中的栗子，我在上个周日收拾房间，发现一个房间衣柜中的衣服很乱，花了很长时间才叠放好，过两天晚上下班回家，我发现客厅沙发上也很乱，衣服、电脑、背包、零食几乎日常的小物件都会有，两件事情合在一起想，这确实是一个很有趣的思考，为什么会是这样的？在一个相对封闭的空间中，任其无意识地随着时间的发展，房间和沙发也一定很乱，注意，这里我说的是无意识，也就是我并没有刻意放，或者去刻意整理。带着这个思考的结果，我又观察了大家的工位、园区内景观，一段时间内一定会出现乱象，不过通过一顿治理之后很快恢复到有秩序，好，大家可以猜到这是什么定律，就是熵增定律，不了解的可以自行网络科普，那么在质量域中依然存在这样的定律，不然熵增定律也不会被古今中外的物理学家所推崇备至，它的定义是：在一个孤立系统里，如果没有外力做功，其总混乱度（即熵）会不断增大。&lt;/p&gt;

&lt;p&gt;代码质量在软件项目是一种有序的状态，自然总是向着无序发展的，要想保持这种有序，需要主动投入资源，就像整理房间，花草修剪一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;回到我们的多数开发工作中，我们面临的现状是这样的：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、业务交付压力大，需求优先上线，业务逻辑实现优先级最高，没时间没精力关注代码质量，甚至终极目标就是需求上线，导致坏代码产生，开发效率逐步下降，随着后续版本的迭代，业务交付压力越来越大。&lt;/p&gt;

&lt;p&gt;2、出现了1的情况后，我们意识到压力越来越大，为了应付这种交付压力，常见的手段就是增加人力，但是一味的增加人数，沟通成本及风格的一致性无法得到保障，这将进一步产生更多的坏代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;针对以上2个现状，我们该怎么着手解决。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我的建议方案是多渠道，系统性解决问题，首先控制人力的大量投入，主动发起对代码质量进行管控，其次持续提升技术升级。但是，从减轻业务交付压力的结果来看，人们往往倾向于增加人力来快速解决问题，技术升级需要靠长期的投入才能有所收获，所以，我们需要在质量方面增加强有力的管控。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果做好代码质量管控？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代码质量管控首先应解决两个问题，库存坏代码和增量坏代码。&lt;/p&gt;

&lt;p&gt;想解决这两个问题，我们要对现有的系统、人员、工具、流程整合形成一套体系化的方案。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/1a7c49ea15824e3db2cf7737f306588d%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1669790825&amp;amp;x-signature=pSyRWdOXChxXhYsyqT8aYwmrH0g%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对代码质量管控，通过在部门内工程实践，我认为需要经历以下这四个过程，部门内建立代码规范制度（EOS）、检查代码问题的自动化工具（bamboo平台）、代码质量检查与代码流动过程绑定（质量门禁）、部门视角下，集中管理代码规范和质量状况的透明（代码质量评测系统）。&lt;/p&gt;

&lt;p&gt;过程一：代码质量的基础是规范，包括代码风格的规范、长期一线代码实践规范、与业务需求相关的特殊规范，例如风控文案、异常托底文案等。&lt;/p&gt;

&lt;p&gt;过程二：实现自动化的检查能力是在规范基础之上，通过自动化工具进行检查，包括对代码重复率、圈复杂度、单测case通过率、静态规则扫描等。&lt;/p&gt;

&lt;p&gt;过程三：实现质量检查与代码流动过程绑定，在编辑-构建-提交-发布各个时段部署检查能力保障上线代码必须经过机器和人工的多环节检查。&lt;/p&gt;

&lt;p&gt;过程四：团队规模逐步扩大，各业务线项目快速发展，实现规范管理统一、项目要求一致、各项目质量状况透明、对比，建立统一的评测体系。&lt;/p&gt;

&lt;p&gt;为了让你有一个很直观的认识，我在下面画了一个张图，希望可以帮助快速理解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/c4205dbd8cc34e0bb884de4f25028196%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1669790825&amp;amp;x-signature=AkQGG9%2FqByBy3x1rJnGUK%2FWJff4%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在日常开发工作中，大家都会想到通过增加人手来缓解项目交付的压力，这是可以理解，但是从整体角度看，人员的增加会产生越来越多的坏代码，使整体的效率下降，这又进而加剧了后续项目交付的压力，在这种压力下，又通过增加人手缓解......让代码质量变的越来越差，这也是房间为什么会越来越乱，是熵增定律在软件质量域的生动体现。&lt;/p&gt;

&lt;p&gt;为了抑制这种恶性循环，我们意识到了通过有效的手段和资源投入进行各项工程实践，逐步完善代码质量的管控体系，积累很多方法和工具。&lt;/p&gt;

&lt;p&gt;目前，我也在积极探索对统一代码质量评测体系的实践，希望逐步建立一套中心化的代码质量评测系统，在这个系统中让工匠精神、专家文化借住平台进一步传播、让系统的质量更加透明。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>acb88ce4204a51433f6bd8134a539de1</guid>
<title>异常检测算法分类总结（含常用开源数据集）</title>
<link>https://toutiao.io/k/klv044a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;em&gt;作者：云智慧算法工程师 Chris Hu&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;异常检测是识别与正常数据不同的数据，与预期行为差异大的数据。本文详细介绍了异常检测的应用领域以及总结梳理了异常检测的算法模型分类。文章最后更是介绍了常用的异常算法数据集。&lt;/p&gt;

&lt;h2&gt;异常的概念与类型&lt;/h2&gt;

&lt;p&gt;目前异常检测主要是基于Hawkins对异常的定义：(Hawkins defines an outlier as an observation that deviates so significantly from other observations as to arouse suspicion that it was generated by a different mechanism.)。异常（anomaly/outlier）指的是远离其他观测数据而疑为不同机制产生的观测数据。根据概率理论对异常的形式化定义如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ac5edd2b65541d9b165b8e753be021d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;异常主要分为以下三种类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;point anomalies（点异常）&lt;/p&gt;

&lt;p&gt;点异常是单个异常数据点 ，将数据集中每个数据映射到高维空间中，其中孤立的点被称为点异常。这种异常点与其他数据点具有明显差异，这种异常分类是异常数据中最为简单的一种，也是异常检测研究中最常研究的异常类型。
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec9a2b0c06b249dfa9c88bebd4b6fccb%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;conditional anomalies/contextual anomalies（条件异常/上下文异常）&lt;/p&gt;

&lt;p&gt;一个数据本身来看属于正常点，但在特定的条件下又与一般情况有差异，这类数据称为条件异常或上下文异常。其中上下文指数据集间的结构和关系，每个数据均由上下文特征( contextual attributes) 及行为特征( behavioral attributes) 来定义，即条件异常需要考虑的不仅仅是数据的取值，还需考虑数据出现的环境，也就是说某一数据在特定数据环境下被判断为异常，而在其他数据集中则可能是正常的。
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b624246e027d41c89ad0cb7bdcc985f1%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;collective anomalies/group anomalies（群体异常/序列异常）&lt;/p&gt;

&lt;p&gt;数据属性在正常范围内，且从上下文环境角度判断也属于正常的数据仍有可能是异常数据。如图3所示，在脑电图中虚线圆圈部分与脑电图整体图形不一致模式称之为聚集异常( 或称集合异常)。异常数据集中单个点可能并不异常，但这些相互关联的数据点聚集在一起时变为异常的情况。聚集异常不仅需要考虑数据的取值、上下文环境，还考虑数据集是否符合整体模式。聚集异常检测常用于时间序列、空 间数据以及图形式的数据中。
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d63175fd873a409d804e27e84054320c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实际的运维场景中，以上三种异常都会出现，比如资源使用率突然上升造成Point Anomalies，又如CPU使用过程中的突然卡顿形成Contextual anomaly，再如某指标使用率连续一段时间处于“满格”状态而呈现出Collective or group anomalies。后两者异常通常需要和业务紧密结合，单纯从数据本身出发具有一定的辨识难度，再加上运维领域中大比例情况下出现的是Point Anomalies，客户多关注于此，因而通常情况下我们更关注Point Anomalies。&lt;/p&gt;

&lt;h2&gt;异常检测的应用领域&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;入侵检测（Intrusion detection）：通过从计算机网络或计算机系统中的若干关键点收集信息并对其进行分析，从中发觉网络或系统中有没有违反安全策略的行为和遭到袭击的迹象，并对此做出适当反应的流程。最普遍的两种入侵检测系统包括基于主机的入侵检测系统（HIDS）、网络入侵检测系统（NIDS）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;欺诈检测（Fraud detection）：主要是不同领域的非法活动检测，主要应用领域包括银行欺诈、移动蜂窝网络故障、保险欺诈、医疗欺诈。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;恶意软件检测（Malware Detection）：主要分为静态分析检测技术与动态分析与检测技术。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;医疗异常检测（Medical Anomaly Detection）：通过X光片、核磁共振、CT等医学图像检测疾病或量化异常，也可以通过EEG、ECG等时序信号进行疾病检测或异常预警。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;深度学习用于社交网络中的异常检测（Deep learning for Anomaly detection in Social Networks）： 社交网络中的异常通常是指个人的不正常甚至违法的行为，如垃圾邮件发送者、性侵者、在线欺诈者、虚假用户或谣言散布者等。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志异常检测（Log Anomaly Detection）：日志异常检测是指找到异常日志，从而判断系统故障原因与性质，通常将日志数据建模为自然语言序列进行异常检测。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;物联网大数据异常检测（Internet of things (IoT) Big Data Anomaly Detection）：通过监控数据流信息检测异常设备和系统行为。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工业异常检测（Industrial Anomalies Detection）: 检测风力涡轮机、发电厂、高温能源系统、存储设备和旋转机械部件组成的工业系统中设备的损坏情况， 该领域中异常检测的挑战是数据量与数据的动态特性，因为故障通常是由多种因素引起的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;时间序列中的异常检测（Anomaly Detection in TimeSeries）：包括单变量时间序列异常检测与多变量时间序列异常检测。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;视频监控（Video Surveillance）：检测视频中的异常场景。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;异常检测思路与方法总结&lt;/h2&gt;

&lt;p&gt;现如今，异常检测主要面临以下困难与挑战：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;未知性：异常与许多未知因素有关，例如，具有未知的突发行为、数据结构和分布的实例。它们直到真正发生时才为人所知，比如恐怖袭击、诈骗和网络入侵等应用；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异常类的异构性： 异常是不规则的，一类异常可能表现出与另一类异常完全不同的异常特征。例如，在视频监控中，抢劫、交通事故和盗窃等异常事件在视觉上有很大差异；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类别不均衡：异常通常是罕见的数据实例，而正常实例通常占数据的绝大部分。因此，收集大量标了标签的异常实例是困难的，甚至是不可能的。这导致在大多数应用程序中无法获得大规模的标记数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;基于标签的异常检测算法分类&lt;/h3&gt;



&lt;p&gt;有监督异常检测算法是指在训练集中的正常实例和异常实例都有标签，训练二类或多类分类器。有监督异常检测方法主要面临两个问题，一方面是在训练数据中，相对于正常时间序列来讲，异常的数据量太小，会对检测效果产生影响；另一方面是在实际操作中很难精确地标注数据是正常或异常，而且异常的情况也难以全部覆盖。基于以上原因，在实际异常检测中，有监督异常检测算法在实际应用中较少。&lt;/p&gt;



&lt;p&gt;半监督异常检测算法是指在训练集中只有单一类别（正常实例）的实例，没有异常实例参与训练。半监督异常检测技术的一种典型方法是基于训练数据集为正常时间序列数据建立模型，然后利用该模型识别待检测数据中的异常。半监督异常检测学习正常数据的判别边界，不属于正常类的数据被判断为异常。由于训练中不需标注异常序列，因此半监督式异常检测方法的应用相对更加广泛。&lt;/p&gt;



&lt;p&gt;无监督异常检测算法在训练集中既有正常实例也可能存在异常实例，但假设数据的比例是正常实例远大于异常实例，模型训练过程中没有标签进行校正。此类技术的核心思想在于异常的情况相对于正常的情况而言是很少的，且其与正常情况存在较大的差异，这种差异可以体现在数据之间的距离远近、分布密度、偏离程度等方面。无监督异常检测算法仅根据数据的内在属性（如距离、密度等）检测数据的异常值，自编码器是所有无监督深度异常检测模型的核心。&lt;/p&gt;

&lt;h3&gt;基于模型的异常检测算法分类&lt;/h3&gt;

&lt;p&gt;基于模型的异常算法分类基于传统方法的异常检测模型和基于深度学习的异常检测模型两大类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e8b8c0d2b149f2b1c1af8b1cc1720a%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;基于传统方法的异常检测模型&lt;/h4&gt;



&lt;p&gt;使用这类方法基于的基本假设是正常的数据是遵循特定分布形式的，并且占了很大比例，而异常点的位置和正常点相比存在比较大的偏移。比如高斯分布，在平均值加减3倍标准差以外的部分仅占了0.2%左右的比例，一般我们把这部分数据就标记为异常数据。&lt;/p&gt;

&lt;p&gt;基于统计的异常检测一般需要充分的数据基础和相应的先验知识，此时检测效果可能是非常有效的。然而，此类检测方法一般是针对单个属性或低维数据的，而对于高纬度的时间序列数据就难以估计其真实的分布。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df7a46b7d6554913880734623b3f3d9c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;假设异常点是不可被压缩的或不能从低维映射空间有效地被重构的。常见的方法有PCA、Robust PCA、random projection等降维方法。 PCA提取了数据的主要特征，如果一个数据样本不容易被重构出来，表示这个数据样本的特征跟整体数据样本的特征不一致，那么它显然就是一个异常的样本。&lt;/p&gt;

&lt;p&gt;对于数据样本X_i, 假设其基于 k 维特征向量重构的样本为X_ik^&#x27; , 则该数据样本的异常得分可以用如下的公式计算：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1705a3c16c4243698539bff6998cb9d5%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;此类方法利用聚类算法（如K-means、_x0008_DBSCAN等）对待检测数据进行聚类，通过聚类的结果来分辨正常与异常的数据，是一种典型的非监督式异常检测技术。通常来讲，基于聚类的异常检测可基于三种假设来分辨异常数据：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不属于任何簇（Cluster）的数据即为异常；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;距离簇中心很远的数据即为异常；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;归属于数据点少或稀疏簇的数据即为异常。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用聚类算法进行异常检测，可利用大量已有的聚类研究成果。但是，聚类与异常检测还是有较大差异的，异常检测的目标在于寻找不正常的数据，而聚类的目的在于确定数据归属的类别。而且，很多聚类算法并未针对时间序列数据做优化，算法执行效率往往不高。&lt;/p&gt;



&lt;p&gt;对正常数据建立区分性边界，异常点被划分到边界外。常见的方法有OC-SVM、SVDD等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6db3a34f6f034bb5a703d28281fbcc23%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;基于深度学习的异常检测模型&lt;/h4&gt;



&lt;p&gt;该类的典型方法为：Deep SVDD [11] 、OC-NN [20]。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb1edf5f21814f98a32fa027e42fd4f4%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ee3ba33d46041bdb46cddc03437a8df%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;采用深度学习的聚类方法一般是用神经网络对输入数据进行编码，然后认为最后的编码序列可以代表神经网络的很多特征，然后我们对编码序列进行聚类就可以达成聚类的目的。该类方法被用于异常检测的包括：CAE-l2 cluster 、DAE-DBC。&lt;/p&gt;

&lt;p&gt;CAE-l2 cluster：在autoencoder中间加入了L2标准化以及k-means。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2b8f5400ef449978c49af58f39c9f94%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;DAE-DBC：先利用autoencoder降维，然后通过聚类方法判别异常值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5627b8a432954010878513cb372337d4%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;一个通用的自动编码器由编码器和解码器组成，编码器将原始数据映射到低维特征空间，而解码器试图从投影的低维空间恢复数据。这两种网络的参数通过重构损失函数来学习。为了使整体重构误差最小化，保留的信息必须尽可能与输入实例(如正常实例)相关。&lt;/p&gt;

&lt;p&gt;典型案例有稀疏自动编码器（sparse AE）、去噪自动编码器（denoising AE）、收缩自动编码器（contractive AE）、鲁邦自动编码器（Robust Deep AE）等，基本原理都较为简单。&lt;/p&gt;

&lt;p&gt;该类方法的优点是能够通过非线性方法捕捉复杂特征，试图找到正常实例的一种通用模式，缺点是如何选择正确的压缩程度，以及如何解决“过拟合”的问题（网络拟合的太好以至于异常实例也“潜伏”在低维特征空间中）。为了解决这个缺点，有研究者使用正则化或者记忆矩阵等等方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52f0e6e10de84ec1b0bb8e22db14c5d7%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4764d35607504c90986b297002b2a582%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;这种方法通常旨在学习生成网络G的潜在特征空间，使潜在空间能够很好地捕捉到给定数据背后的常态。将生成模型用于异常检测是基于在生成网络的潜在特征空间中正常实例比异常实例能够更准确地被产生这一假设。 实际实例和生成实例之间的残差被定义为异常分数。&lt;/p&gt;

&lt;p&gt;典型案例有AnoGAN、GANomaly、Wasserstein GAN、 Cycle GAN、VAE等。该类方法的关键问题是如何设计合适的生成器和目标函数。&lt;/p&gt;

&lt;h3&gt;异常检测数据集&lt;/h3&gt;

&lt;h4&gt;异常检测数据类型&lt;/h4&gt;

&lt;p&gt;用于异常检测的数据通常可分为两类：&lt;/p&gt;

&lt;p&gt;序列数据：如voice, text, music, time series, protein sequences；&lt;/p&gt;

&lt;p&gt;非序列数据：如images, other data。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d12cfd6f8424d63a318e606374d3a3c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;异常检测开源数据集&lt;/h4&gt;

&lt;p&gt;下方链接为常用的异常检测数据集，该git仓库中维护了多种通用的异常检测数据集。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/GuansongPang/ADRepository-Anomaly-detection-datasets&quot;&gt;https://github.com/GuansongPang/ADRepository-Anomaly-detection-datasets&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b8014047e3b4b62a62489e8b9b76b18%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下方链接为时间序列异常检测数据集，该git仓库中维护了时间序列异常检测算法相关的软件、包、数据集等。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rob-med/awesome-TS-anomaly-detection&quot;&gt;https://github.com/rob-med/awesome-TS-anomaly-detection&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2dd53f340aa4b1a9c30da6841e2bc25%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;开源项目推荐&lt;/h2&gt;

&lt;p&gt;云智慧已开源数据可视化编排平台 FlyFish 。通过配置数据模型为用户提供上百种可视化图形组件，零编码即可实现符合自己业务需求的炫酷可视化大屏。 同时，飞鱼也提供了灵活的拓展能力，支持组件开发、自定义函数与全局事件等配置， 面向复杂需求场景能够保证高效开发与交付。&lt;/p&gt;

&lt;p&gt;如果喜欢我们的项目，请不要忘记点击下方代码仓库地址，在 &lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCloudWise-OpenSource%2FFlyFish&quot;&gt;GitHub&lt;/a&gt;&lt;/strong&gt; &lt;strong&gt;/&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://gitee.com/CloudWise/fly-fish&quot;&gt;Gitee&lt;/a&gt;&lt;/strong&gt; 仓库上点个 Star，我们需要您的鼓励与支持。此外，即刻参与 FlyFish 项目贡献成为 FlyFish Contributor 的同时更有万元现金等你来拿。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GitHub 地址：&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCloudWise-OpenSource%2FFlyFish&quot;&gt;https://github.com/CloudWise-OpenSource/FlyFish&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gitee 地址：&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://gitee.com/CloudWise/fly-fish&quot;&gt;https://gitee.com/CloudWise/fly-fish&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微信扫描识别下方二维码，备注【飞鱼】加入 AIOps 社区飞鱼开发者交流群，与 FlyFish 项目 PMC 面对面交流～&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/018b9a988f5d4945896d91995eb620f8%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c745edee102ffb7f72792d1fef8149af</guid>
<title>零信任实战架构总结</title>
<link>https://toutiao.io/k/u9v4cma</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;此报告主要参考了《零信任实战白皮书》，结合自己对零信任的理解，做了一个精简的总结，做参考。&lt;/p&gt;&lt;h2 mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;一、零信任认识&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;零信任解决的是由于传统边界模型过度信任造成的安全问题，重点是Trust Area 内过度信任的问题，零信任打破了信任和网络位置默认的绑定关系，不像传统信任关系是静态不变的，而是动态持续监测各参与对象的安全状态、并对其重建信任评估，然后进行动态调整权限、降权、阻断等强管控手段。我自己认为，动态持续监控、根据对象安全状态进行调整权限，&lt;/p&gt;&lt;p&gt;这个是零信任非常重要的功能，也是传统边界模型做不到的。&lt;/p&gt;&lt;h2 mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;二、零信任实现架构&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;目前有零信任实践的公司，大多都是采用SDP架构（software define perimeter）,SDP架构主要包括三大组件：SDP控制器（SDP Controler）、SDP发起客户端、 SDP服务提供者。&lt;/p&gt;&lt;p&gt;控制层与数据层保持分离，以便实现完全可扩展。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7053364269141531&quot; data-type=&quot;jpeg&quot; data-w=&quot;431&quot; class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qq5rfBadR3ic1sgXESZsXtvtXYdvkUhicUvzwgZ0J9f5xIv1hLQGxduiaO7HhPKFBrViar8X6R8yrEh2WibS7HwKdsw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2 mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;三、零信任实现方案&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;有两种实现方案，一是用户对资源访问的方案，如办公网访问公司应用，大多数采用此种对零信任架构进行实践摸索；二是生产服务之间相互调用的方案，由于涉及生产、&lt;/p&gt;&lt;p&gt;及各种复杂访问关系，很少有公司对此种进行实践。&lt;/p&gt;&lt;h3 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;strong mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;3.1、用户对资源访问模式方案&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;此种方案涉及到的对象有：用户、终端、资源、链路。&lt;/p&gt;&lt;p&gt;此方案，对架构进行抽象后的架构示意图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3333333333333333&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qq5rfBadR3ic1sgXESZsXtvtXYdvkUhicUmvK8asesJjibHUpARZelW6Qbxu0B9W58IkN2JibUoxD6mYuknlBBSz1Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;认证不再只是人的认证，授权、信任不再是静态不变，而是：人（双因素、OTP）+终端（是否符合安全基线，安全状态是否符合）+软件（是否有漏洞）=认证（持续动态认证）—→认证通过—-→授权（基于对各对象动态安全监测和信任评估，动态授权、降权、阻断等）——-→资源&lt;/p&gt;&lt;p&gt;零信任在技术实现分类上，根据零信任网关的类型总结为两种：&lt;/p&gt;&lt;p&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;&gt;3.1.1、反向代理/应用层web协议网关：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;应用层代理模式指的是在零信任网关实现上，通过七层应用代理方式，将对后端应用的访问通过本地应用 ，层代理配置，将应用层请求发至应用层代理网关中，&lt;/p&gt;&lt;p&gt;由应用层代理网关进行拦截、转发，架构如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36666666666666664&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qq5rfBadR3ic1sgXESZsXtvtXYdvkUhicUIeKHib5D37rjf2neW2PQh0HqL4xTKyO9E6Gc6Dz4DItBVVuPMvlNlIg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;实现原理如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5072886297376094&quot; data-type=&quot;jpeg&quot; data-w=&quot;686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qq5rfBadR3ic1sgXESZsXtvtXYdvkUhicU4csKWIm17qsUHj8MAPLZMSo7MAJkL8WyknFH7ZxDU2TqhXowug64cA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;该模式下的简化访问过程如下（有agent）：&lt;/p&gt;&lt;blockquote mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;p&gt;a）用户通过零信任终端Agent进行设备注册和授权；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;b）终端Agent进行安全基线加固，以及上传终端设备安全状态；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;c）用户通过零信任终端Agent（或可信集成的浏览器），来设置本地应用层代理配置，指定特定资源的访&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;问由应用层代理发至应用层代理网关中；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;d）应用层代理网关通过安全控制中心，进行认证和鉴权；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;e）应用层代理网关鉴权通过后，将请求转发给应用系统，获取请求资源；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;f）应用层代理网关将资源转发给零信任终端，完成资源请求。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;优点：由于是应用层代理，因此可以基于应用进行细颗粒的授权控制，可以深入到对特定应用，特定资源的 控制；&lt;/p&gt;&lt;p&gt;缺点：对于非HTTP的业务，部分开放设置能力的CS应用客户端可以支持配置，大部分CS架构的客户端都是 不支持的，满足不了全场景的办公需求。&lt;/p&gt;&lt;p&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;&gt;3.1.2、流量代理网关方式，即四层代理方式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;流量代理方式在实现上，终端有agengt情况下，可通过hook、虚拟网卡、网络过滤驱动等方式，将本地流 量转发给零信任网关，零信任网关负责流量的拦截和转发，如下图：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.41304347826086957&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qq5rfBadR3ic1sgXESZsXtvtXYdvkUhicUXYLTfRTjFbd54NYTXPGfXia6sOxh2oSXq9W2NUB1aLIjzlCM0hh2fSA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果终端没有agent，只要零信任流量代理网关部署在网络链路中，能够劫持流量即可充当代理网关。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;a）由于是四层流量代理，因此可以实现全局代理，无论是B/S应用，还是C/S应用都可以通过流量代理网 关进行控制和授权。支持全办公场景；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;b）此外该模式下，C/S应用不需要改造，可以直接接入进零信任体系中，对业务干扰较小；&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;a）由于是四层流量代理，因此对于加密的请求，解密成本较高。&lt;/p&gt;&lt;p&gt;b) 不易实现精细化的权限控制，例如 针对垂直的WEB流量，不能基于HTTP协议层做对应更加细化的访问控制，需要额外用垂直的WEB流量网关，。&lt;/p&gt;&lt;p&gt;c）另外全流量代理模式下，容易出现和其他安全类流量劫持软件冲突，需要对应修复支持工具&lt;/p&gt;&lt;p&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;&gt;3.1.3、混合网关方式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;单一的实现方式都有其弊端和优势，例如用了全流量代理可能导致无法识 别内容，无法对特定应用进行解析和精细的权限控制，因此也可以将技术实现方式进行融合，融合点主要是在网关对上述多个能力进行整合，用全流量代理网关作为统一入口，对特定应用的控制由应用代理模块进行控 制，在实现上同时拥有全流量代理、Web应用反向代理、应用层代理（其他RDP、SSH、IOT等）能力，&lt;/p&gt;&lt;p&gt;如下 图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6652173913043479&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qq5rfBadR3ic1sgXESZsXtvtXYdvkUhicUiaFXKz2ibWUOiblFcribJRRTEJAzMQI4dsN0JT98bugiczrEv1M5ajFQd5Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;该模式下的简化访问过程如下：&lt;/p&gt;&lt;p&gt;a）用户在访问资源时，根据所访问的资源类型，将请求转发到流量代理网关上；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;b）流量代理网关通过安全控制中心对用户进行认证和鉴权；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;c）流量网关根据请求的资源类型，鉴权通过后将请求转发，向后转发中分为以下情景：&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;直接转发：如果没有特定应用代理模块，请求将直接转发到应用中，例如C/S应用；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;转发到应用代理模块：有特定应用控制的模块时，将请求转发到应用代理模块中，由应用代理模块进&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;一步进行更细粒度的鉴权，例如对SSH服务进行零信任控制和授权，对Web应用进行零信任控制和授&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;权，或是更特定业务协议的场景，IOT的零信任控制授权。&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;d）流量代理网关将资源转发给终端，完成资源请求响应。&lt;/p&gt;&lt;p&gt;混合实践举例：有Agent和无Agent的场景，满足不同的权限控制需要：&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;a）提供一套流量网关服务器和Agent，提供给企业内部职员终端安全访问，实现强终端安全防护和管控目 标；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;b）同时部署一套对外提供反向代理网关，通过DNS解析将部分业务代理出去，提供给合作商，针对一些 敏感数据泄漏风险较低的系统，用户可以不用安装客户端直接由WEB Portal方式，经身份认证鉴权后访问。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;a) 由于混合代理方式，如果业务要求全部场景，可以使用全流量代理模式，处理C/S和B/S系统的终端应 用；&lt;/p&gt;&lt;p&gt;b) 如业务方需要对特定业务实现更精细对权限控制，可以使用应用代理的应用解析能力，因此可以基于应用进行细颗粒的授权控制；&lt;/p&gt;&lt;p&gt;缺点：混合模式架构较为复杂，实现起来较为麻烦&lt;/p&gt;&lt;p&gt;3.1.4、部署方式&lt;/p&gt;&lt;p&gt;在用户对资源访问的零信任实现上，具体到落地部署中，可以根据企业特点有多种部署方式，下面列举常 见的几类部署模式：&lt;/p&gt;&lt;p&gt;1）企业内部部署 (办公场景)&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;在企业内部部署模式中，零信任网关主要用于企业内部服务保护，因此部署位置将零信任网关放置到服务 器网络前，&lt;/p&gt;&lt;p&gt;如下图：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5318840579710145&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qq5rfBadR3ic1sgXESZsXtvtXYdvkUhicU1VtOPCSgy3f59Cic6lnDZ7CbicQaVWPuo7Ob7na9mC4gZTvIcngLtMng/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;此种，通过零信任系统提供统一的业务安全访问通道，关闭职场内部终端直连内部业务系统的网络策略，尽可能 避免企业内部服务全部暴露在办公网络（内网中过多的默认信任）。所有的终端访问都要进过终端身份校验（人的安全可信），终端/系统/应用的可信确认（终端设备的安全 可信），还有细粒度的权限访问校验，然后才可以通过加密安全网关访问具体的业务（链路的安全可信），这 样能极大的降低和减少内部业务资产被恶意扫描和攻击的行为。&lt;/p&gt;&lt;p&gt;2） 集团多分支部署&lt;/p&gt;&lt;p&gt;集团公司，其全国/全球的多个分支子公司、办事处、并购公司、外部合作（协作）公司等员工需要安全 访问集团内部系统，该需求模式下可以采用以下部署模式，实现多分支的访问：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6652173913043479&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qq5rfBadR3ic1sgXESZsXtvtXYdvkUhicUClbZibFLLYq7Cjx8yxWYN4wzceZic8mWasCjWCeia0CXhsxodYicstluYw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;该部署模式中可以针对集团、子公司的组织架构（用户群组）或者具体人员（用户）设置访问策略，员工&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;访问可达的集体内部系统仅限于指定的业务（细粒度授权），不可越界。应保障访问过来的人员身份、设备、链路的安全，同时子公司的终端或者账户如果有异常可以及时阻断访问。&lt;/p&gt;&lt;h3 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;strong mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;3.2 、 生产服务之间相互调用的零信任方案&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;此种方案有几个核心元素：&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;a）工作负载：workload，承载业务的主机，可以是物理服务器、虚拟机或容器。&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;b）访问者：发起访问一方的工作负载。&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;c）提供者：提供服务一方的工作负载。在数据中心中，任意一个工作负载都可能本身即是提供者，也是 其他工作负载的访问者&lt;/p&gt;&lt;p&gt;d) 服务：即根据业务需要所开放的供其他工作负载或用户访问的服务&lt;/p&gt;&lt;p&gt;基于工作负载的零信任架构：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.551594746716698&quot; data-type=&quot;jpeg&quot; data-w=&quot;533&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qq5rfBadR3ic1sgXESZsXtvtXYdvkUhicUibYVOAOC6psRsBfchxbpvL94ibtzG1n495q1MKibL5vjnpjB8yQyKSjAw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;由于很少有公司在生产服务之间尝试零信任架构，此种方式不过多介绍&lt;/p&gt;&lt;h2 mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;四、零信任应用场景&lt;/strong&gt;&lt;/h2&gt;&lt;h3 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;strong mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;4.1、办公安全（目前实践较多的）&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;包含远程办公需求、集团性多分支机构办公安全、传统网络架构，无非就是通过vp，专线直接访问公司或者集团资源。总结来说零信任架构从安全层面不在区分内外网、是否为远程、是否为分支，统一通过零信任网关接入、零信任网关代理、隐藏后端服务&lt;/p&gt;&lt;p&gt;只不过办公区可以通过内网访问零信任网关、远程用户、分支机构，可通过公网、专线等访问零信任网关，无论哪种方式，都要经过，认证、鉴权/授权、这一套流程。&lt;/p&gt;&lt;p&gt;办公安全零信任架构：&lt;/p&gt;&lt;p&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6463768115942029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qq5rfBadR3ic1sgXESZsXtvtXYdvkUhicUwljibzY7C2zoaJLvFUXhwdIQXLbdxLVQ8zRAiaAN2ib2c2MYg4ibUicHicXg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6463768115942029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qq5rfBadR3ic1sgXESZsXtvtXYdvkUhicUUwfksOXu9oyQO8tEhtEORtSHzpQ8CV2GqLf3jm0IIqvZUxWaE9MOhA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;远程办公需求零信任实现：&lt;/p&gt;&lt;p&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48840579710144927&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qq5rfBadR3ic1sgXESZsXtvtXYdvkUhicUWJcz0NdCv1Me1X9qmTAqezt3bn2ibgW6LlIGJeJYribHR9cy9xWCLghA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;远程办公场景下正确的实施零信任方案后可以带来如下好处：&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;a）可快速扩容：零信任网关可以通过负载均衡实现快速的横向扩展，来满足突发的远程办公需求；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;b）安全控制能力强：零信任把安全架构延伸到用户终端上，有更强的控制和感知能力；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;c）安全攻击面小：零信任远程办公方案中，唯一可被访问的只有零信任网关，所有内部资源全部被隐藏 在网关后，即便资源存在0day也难以被攻击到；&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;d）易使用：用户一旦完成认证后，整个使用过程对用户不会有打扰，用户和在公司内部的权限维持一 致，有较好用户体验&lt;/p&gt;&lt;h3 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;strong mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;4.2、数据中心内部访问&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;基本都是采用微隔离架构进行网络层、主机层、应用层的细粒度隔离，此种方式不过多介绍&lt;/p&gt;&lt;h2 mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;五、零信任落地经验&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;零信任安全理念在企业的落地不会是一蹴而就，也绝非仅靠采购一些零信任安全产品或者部署一些零信任&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;安全组件就能够简单实现。需要企业根据自身业务系统建设阶段、人员和设备管理情况、现有网络环境、企业&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;网络安全威胁、现有安全机制、预算情况、安全团队人员能力等因素综合考虑，制定零信任安全目标和实施计&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;划，分阶段的逐步落地，持续提升企业零信任安全能力，是一个不断完善、持续优化的过程。&lt;/p&gt;&lt;p&gt;落地建设可分为：全新建设零信任架构网络、在已有网络架构上改造升级，两种情况。&lt;/p&gt;&lt;p&gt;无论是全新搭建还是已有网络架构升级，实施过程应考虑以下因素：&lt;/p&gt;&lt;blockquote mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;p&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;&gt;1）有专门的安全团队和人员牵头和推进实施；&lt;/strong&gt;&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;&gt;2）领导的重视（往往决定了落地的难易程度）；&lt;/strong&gt;&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;&gt;3）有明确的安全目标（以及阶段性目标）;&lt;/strong&gt;&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;&gt;4）有适配达到安全目标的足够预算；&lt;/strong&gt;&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;&gt;5）业务团队的充分理解和配合；&lt;/strong&gt;&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;&gt;6）第三方厂商的配合&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;无论是全新搭建还是已有网络架构升级，实施过程可以参考以下方法和步骤：&lt;/p&gt;&lt;p&gt;1）明确范围&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;全面梳理和确认过程中涉及的人员、设备、业务系统、数据资产等保护对象，并考虑到实施过程中可能涉&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;及的网络位置（集团总部、分支机构、云环境等）等因素。从应用场景进行梳理可能是比较好的一种方式。&lt;/p&gt;&lt;p&gt;2）确定安全目标&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;根据零信任网络保护对象的重要程度，以及企业可能面临的安全风险、企业安全现状、团队能力、可投入的资源等因素，确定零信任网络需要建设的安全能力，以及能力实现的强弱程度（并非一定要把所有最高级别的安全能力手段都加于企业身上，而是应根据企业实际需求适配，但需要保障零信任基本能力的建设）。&lt;/p&gt;&lt;p&gt;3）制定实施计划&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;根据已确定的安全目标、企业现状，制定实施计划，明确各实施阶段的实施目标和里程碑标志（能够验证&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;目标已达成的事项）&lt;/p&gt;&lt;p&gt;4）分阶段实施&lt;/p&gt;&lt;p&gt;根据制定的实施计划，推动相关人员实施。并按照项目管理的模式，按时推进，跟踪进展，适时调整，逐 个阶段的实现。&lt;/p&gt;&lt;p&gt;5）持续完善和优化&lt;br mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;27&quot;/&gt;在完成零信任网络的基本建设后，应该不断和提升丰富企业的零信任安全能力（包括持续加强零信任组件的自身安全防护、持续提升企业的零信任网络安全运营能力等），最终从安全技术、安全意识、安全运营、组织建设等方面持续完善和优化&lt;/p&gt;&lt;h2 mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;六、零信任和现有安全产品的关系&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;自认为零信任只是一种新的安全理念，也不过只是一种新的安全架构，并不能取代现有安全产品，不过在零信任架构中，可以把现有安全产品更紧密结合在一起，&lt;/p&gt;&lt;p&gt;形成更立体联动的效应，比如现有的一些检测告警类、防护类安全产品可以辅助实现零信任架构中 “动态持续检测各对象安全状态，动态调整权限、降级、甚至阻断”这一特点&lt;/p&gt;&lt;p&gt;解决传统一些架构中，弱管控、动态处置效率不高等缺点，真正实现全过程持续“零信任”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;strong&gt;版权申明：内容来源网络，版权归原创者所有。除非无法确认，都会标明作者及出处，如有侵权，烦请告知，我们会立即删除!&lt;/strong&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;侵权请私聊公众号删文&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt; &lt;strong&gt;热文推荐 &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;欢迎关注LemonSec&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable js_wx_tap_highlight&quot; data-id=&quot;MzUyMTA0MjQ4NA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/p5qELRDe5icnialF1VdKgia6dHCTs6nWORdYm76pgel8zZYJuxDeEMInDM1RArONKsYyHFC8yeczibs5ny0HeXnJlg/0?wx_fmt=png&quot; data-nickname=&quot;LemonSec&quot; data-alias=&quot;lemon-sec&quot; data-signature=&quot;每日发布安全资讯～&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot; has-insert-preloading=&quot;1&quot; data-index=&quot;0&quot; data-origin_num=&quot;88&quot; data-isban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;觉得不错点个&lt;strong&gt;&lt;span&gt;“赞”&lt;/span&gt;&lt;/strong&gt;、“在看“&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dd31cb279ba0e36795a78066ee7ee067</guid>
<title>现代化 C 使用体验</title>
<link>https://toutiao.io/k/nz0xzfo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;outline-text-headline-6&quot; class=&quot;outline-text-3&quot;&gt;&lt;p&gt;指针作为 C 中最重要的一类型，往往会给初学者造成较大困扰，不仅仅是使用上，光是解读指针定义就不是件容易的事情。比如：&lt;/p&gt;&lt;div class=&quot;src src-c&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;&lt;pre tabindex=&quot;0&quot; class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot; id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;2&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;lntd&quot;&gt;&lt;pre tabindex=&quot;0&quot; class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;ptr&lt;/code&gt; 比较好理解，是指向 int 类型的指针，那 &lt;code class=&quot;verbatim&quot;&gt;ptr2&lt;/code&gt; 呢？是指向数组的指针，还是元素为指针的数组？&lt;/p&gt;&lt;p&gt;其实这个问题在 K&amp;amp;R C 这本书有一点睛之笔，即：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The syntax of the declaration for a variable mimics the syntax of expressions in which the variable might appear.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;也就是说，变量的声明语法，阐明了该变量在表达式中的类型。翻译过来比较绕，看几个例子就明白了：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;*ptr&lt;/code&gt; 是一个类型为 int 的表达式，因此 ptr 必须是指针，指向 int&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;arr[i]&lt;/code&gt; 是一个类型为 int 的表达式，因此 arr 必须是数组，数组元素为 int&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;*arr[i]&lt;/code&gt; 是一个类型为 int 的表达式，因此 &lt;code class=&quot;verbatim&quot;&gt;arr[i]&lt;/code&gt; 必须是指针，因此 arr 必须是数组，元素是 int 的指针。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;(*ptr)[100]&lt;/code&gt; 是一个类型为 int 的表达式，因此 &lt;code class=&quot;verbatim&quot;&gt;ptr&lt;/code&gt; 必须是指针，指向一个 int 类型数组&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;*comp()&lt;/code&gt; 是一个类型为 int 的表达式，因此 &lt;code class=&quot;verbatim&quot;&gt;comp()&lt;/code&gt; 必须返回一个 int 指针，因此 comp 是一个函数，返回值是 int 的指针&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;(*comp)()&lt;/code&gt; 是一个类型为 int 的表达式，因此 &lt;code class=&quot;verbatim&quot;&gt;*comp&lt;/code&gt; 必须是一个函数，因此 comp 是一个函数指针&lt;/p&gt;&lt;p&gt;通过上面的解释，如果读者一时没有理解也不要紧，平时写代码用到时再来揣摩其中的奥妙。对于复杂的声明，一般推荐用 typedef 的方式。比如：&lt;/p&gt;&lt;div class=&quot;src src-c&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;&lt;pre tabindex=&quot;0&quot; class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot; id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;2&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;3&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;4&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;5&quot;&gt;&lt;a href=&quot;#5&quot;&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;lntd&quot;&gt;&lt;pre tabindex=&quot;0&quot; class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int_ptr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array_of_ten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;n&quot;&gt;array_of_ten&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;通过这种方式定义的 &lt;code class=&quot;verbatim&quot;&gt;a1&lt;/code&gt; 理解起来就没什么难度了，它首先是一数组，数组的元素是指向 int 的指针。K&amp;amp;R C 有一个程序，可以将复杂声明转为文字描述：&lt;a href=&quot;https://stackoverflow.com/questions/40388241/kr-recursive-descent-parser-strcat&quot;&gt;K&amp;amp;R - Recursive descent parser&lt;/a&gt;。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2206a4b87f97b39548c95214aef4ab98</guid>
<title>总结一些 Spark 处理小 trick</title>
<link>https://toutiao.io/k/fbsn4e5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img data-s=&quot;300,640&quot; class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nW2ZPfuYqSJuK8UUBxdZXj1c20hUg374YPgXibgDGytAy87YxvVk4WCRFWrdKJPshStrlPJp4vGEGUQodxt7ibOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.40404040404040403&quot; data-w=&quot;990&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近做了很多数据清洗以及摸底的工作，由于处理的数据很大，所以采用了spark进行辅助处理，期间遇到了很多问题，特此记录一下，供大家学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于比较熟悉python, 所以笔者采用的是pyspark，所以下面给的demo都是基于pyspark，其实其他语言脚本一样，重在学习思想，具体实现改改对应的API即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里尽可能的把一些坑以及实现技巧以demo的形式直白的提供出来，顺序不分先后。有了这些demo，大家在实现自己各种各样需求尤其是一些有难度需求的时候，就可以参考了，当然了有时间笔者后续还会更新一些demo，感兴趣的同学可以关注下。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;trick&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先说一个最基本思想：&lt;em&gt;&lt;strong&gt;能map绝不reduce&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说当在实现某一需求时，要尽可能得用map类的算子，这是相当快的。但是聚合类的算子通常来说是相对较慢，如果我们最后不得不用聚合类算子的时候，我们也要把这一步逻辑看看能不能尽可能的往后放，而把一些诸如过滤什么的逻辑往前放，这样最后的数据量就会越来越少，再进行聚合的时候就会快很多。如果反过来，那就得不偿失了，虽然最后实现的效果是一样的，但是时间差却是数量级的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里列一下我们最常用的算子&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;rdd = rdd.filter(lambda x: fun(x))&lt;br/&gt;rdd = rdd.map(lambda x: fun(x))&lt;br/&gt;rdd = rdd.flatMap(lambda x: fun(x))&lt;br/&gt;rdd = rdd.reduceByKey(lambda a, b: a + b)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;filter: 过滤，满足条件的返回True, 需要过滤的返回False。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;map: 每条样本做一些共同的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;flatMap: 一条拆分成多条返回，具体的是list。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;reduceByKey: 根据key进行聚合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个最常见的场景就是需要对某一个字段进行聚合：假设现在我们有一份流水表，其每一行数据就是一个用户的一次点击行为，那现在我们想统计一下每个用户一共点击了多少次，更甚至我们想拿到每个用户点击过的所有item集合。伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;def get_key_value(x):&lt;br/&gt;  user = x[0]&lt;br/&gt;  item = x[1]&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (user, [item])&lt;br/&gt;rdd = rdd.map(lambda x: get_key_value(x))&lt;br/&gt;rdd = rdd.reduceByKey(lambda a, b: a + b)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们先通过get_key_value函数将每条数据转化成(key, value)的形式，然后通过reduceByKey聚合算子进行聚合，它就会把相同key的数据聚合在一起，说到这里，大家可能不觉得有什么？这算什么trick！其实笔者这里想展示的是get_key_value函数返回形式：&lt;em&gt;&lt;strong&gt;[item]&lt;/strong&gt;&lt;/em&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了对比，这里笔者再列一下两者的区别：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;def get_key_value(x):&lt;br/&gt;  user = x[0]&lt;br/&gt;  item = x[1]&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (user, [item])&lt;br/&gt;&lt;br/&gt;def get_key_value(x):&lt;br/&gt;  user = x[0]&lt;br/&gt;  item = x[1]&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (user, item)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到第一个的value是一个列表，而第二个就是单纯的item，我们看reduceByKey这里我们用的具体聚合形式是相加，列表相加就是得到一个更大的列表即:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;[1,2,3]+[4,5]=[1,2,3,4,5]&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 12336.7 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;5B&quot; d=&quot;M118 -250V750H255V710H158V-210H255V-250H118Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(278, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(778, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1222.7, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1722.7, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2167.3, 0)&quot;&gt;&lt;path data-c=&quot;33&quot; d=&quot;M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2667.3, 0)&quot;&gt;&lt;path data-c=&quot;5D&quot; d=&quot;M22 710V750H159V-250H22V-210H119V710H22Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3167.6, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4167.8, 0)&quot;&gt;&lt;path data-c=&quot;5B&quot; d=&quot;M118 -250V750H255V710H158V-210H255V-250H118Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(4445.8, 0)&quot;&gt;&lt;path data-c=&quot;34&quot; d=&quot;M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4945.8, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(5390.4, 0)&quot;&gt;&lt;path data-c=&quot;35&quot; d=&quot;M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5890.4, 0)&quot;&gt;&lt;path data-c=&quot;5D&quot; d=&quot;M22 710V750H159V-250H22V-210H119V710H22Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(6446.2, 0)&quot;&gt;&lt;path data-c=&quot;3D&quot; d=&quot;M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(7502, 0)&quot;&gt;&lt;path data-c=&quot;5B&quot; d=&quot;M118 -250V750H255V710H158V-210H255V-250H118Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(7780, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(8280, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(8724.7, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(9224.7, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(9669.3, 0)&quot;&gt;&lt;path data-c=&quot;33&quot; d=&quot;M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(10169.3, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(10614, 0)&quot;&gt;&lt;path data-c=&quot;34&quot; d=&quot;M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(11114, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(11558.7, 0)&quot;&gt;&lt;path data-c=&quot;35&quot; d=&quot;M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(12058.7, 0)&quot;&gt;&lt;path data-c=&quot;5D&quot; d=&quot;M22 710V750H159V-250H22V-210H119V710H22Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以最后我们就拿到了：每个用户点击过的所有item集合，具体的是一个列表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常中我们需要抽样出一部分数据进行数据分析或者实验，甚至我们需要将数据等分成多少份，一份一份用（后面会说），这个时候怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了spark也有类似sample这样的抽样算子&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那其实我们也可以实现，而且可以灵活控制等分等等且速度非常快，如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;def get_prefix(x, num):&lt;br/&gt;    prefix = random.randint(1, num)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; [x, num]&lt;br/&gt;&lt;br/&gt;def get_sample(x):&lt;br/&gt;    prefix = x[1]&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; prefix == 1:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; True&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; False&lt;br/&gt;rdd = rdd.map(lambda x: get_prefix(x, num))&lt;br/&gt;rdd = rdd.filter(lambda x: get_sample(x))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们需要抽取1/10的数据出来，总的思路就是先给每个样本打上一个[1,10]的随机数，然后只过滤出打上1的数据即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以此类推，我们还可以得到3/10的数据出来，那就是在过滤的时候，取出打上[1,2,3]的即可，当然了[4,5,6]也行，只要取三个就行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的时候需要在两个集合之间做笛卡尔积，假设这两个集合是A和B即两个rdd。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先spark已经提供了对应的API即cartesian，具体如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;rdd_cartesian = rdd_A.cartesian(rdd_B)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其更具体的用法和返回形式大家可以找找相关博客，很多，笔者这里不再累述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;&lt;strong&gt;但是其速度非常慢&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其当rdd_A和rdd_B比较大的时候，这个时候怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候我们可以借助广播机制，其实已经有人也用了这个trick:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;http://xiaoyu.world/spark/spark-cartesian/&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先说一下spark中的广播机制，假设一个变量被申请为了广播机制，那么其实是缓存了一个只读的变量在每台机器上，假设当前rdd_A比较小，rdd_B比较大，那么我可以把rdd_A转化为广播变量，然后用这个广播变量和每个rdd_B中的每个元素都去做一个操作，进而实现笛卡尔积的效果，好了，笔者给一下pyspark的实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;def ops(A, B):&lt;br/&gt;    pass&lt;br/&gt;    &lt;br/&gt;def fun(A_list, B):&lt;br/&gt;    result = []&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; cur_A &lt;span&gt;in&lt;/span&gt; A_list:&lt;br/&gt;        result.append(cur_A + B)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;        &lt;br/&gt;rdd_A = sc.broadcast(rdd_A.collect())&lt;br/&gt;rdd_cartesian = rdd_B.flatMap(lambda x: fun(rdd_A.value, x))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到我们先把rdd_A转化为广播变量，然后通过flatMap，将rdd_A和所有rdd_B中的单个元素进行操作，具体是什么操作大家可以在ops函数中自己定义自己的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于spark的广播机制更多讲解，大家也可以找找文档，很多的，比如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;https://www.cnblogs.com/Lee-yl/p/9777857.html&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但目前为止，其实还没有真真结束，从上面我们可以看到，rdd_A被转化为了广播变量，但是其有一个重要的前提：那就是rdd_A比较小。但是当rdd_A比较大的时候，我们在转化的过程中，就会报内存错误，当然了可以通过增加配置:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;spark.driver.maxResultSize=10g&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果rdd_A还是极其大呢？换句话说rdd_A和rdd_B都是非常大的，哪一个做广播变量都是不合适的，怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我们一部分一部分的做。假设我们把rdd_A拆分成10份，这样的话，每一份的量级就降下来了，然后把每一份转化为广播变量且都去和rdd_B做笛卡尔积，最后再汇总一下就可以啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了想法，那么怎么实现呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分批大家都会了，如上。但是这里面会有另外一个问题，那就是这个广播变量名会被重复利用，在进行下一批广播变量的时候，需要先销毁，再创建，demo如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;def ops(A, B):&lt;br/&gt;    pass&lt;br/&gt;    &lt;br/&gt;def fun(A_list, B):&lt;br/&gt;    result = []&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; cur_A &lt;span&gt;in&lt;/span&gt; A_list:&lt;br/&gt;        result.append(cur_A + B)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;    &lt;br/&gt;def get_rdd_cartesian(rdd_A, rdd_B):   &lt;br/&gt;    rdd_cartesian = rdd_B.flatMap(lambda x: fun(rdd_A.value, x))&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; rdd_cartesian&lt;br/&gt;    &lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(rdd_A_batch))&lt;br/&gt;    qb_rdd_temp = rdd_A_batch[i]&lt;br/&gt;    qb_rdd_temp = sc.broadcast(qb_rdd_temp.collect())&lt;br/&gt;    rdd_cartesian_batch = get_rdd_cartesian(qb_rdd_temp, rdd_B)&lt;br/&gt;    dw.saveToTable(rdd_cartesian_batch, tdw_table, &lt;span&gt;&quot;p_&quot;&lt;/span&gt; + ds, overwrite=False)&lt;br/&gt;    qb_rdd_temp.unpersist()&lt;br/&gt;    &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，最主要的就是unpersist()&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到广播机制，这里就再介绍一个稍微复杂的demo，乘热打铁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做算法的同学，可能经常会遇到向量索引这一场景：即每一个item被表征成一个embedding，然后两个item的相似度便可以基于embedding的余弦相似度进行量化。向量索引是指假设来了一个query，候选池子里面假设有几百万的doc，最终目的就是要从候选池子中挑选出与query最相似的n个topk个doc。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于做大规模数量级的索引已经有很多现成好的API可以用，最常见的包比如有faiss。如果还不熟悉faiss的同学，可以先简单搜一下其基本用法，看看demo，很简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好啦，假设现在query的量级是10w，doc的量级是100w，面对这么大的量级，我们当然是想通过spark来并行处理，加快计算流程。那么该怎么做呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我们便可以使用spark的广播机制进行处理啦，而且很显然doc应该是广播变量，因为每一个query都要和全部的doc做计算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说，直接看实现&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先建立doc索引：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 获取index embedding，并collect，方便后续建立索引&lt;/span&gt;&lt;br/&gt;index_embedding_list = index_embedding_rdd.collect()&lt;br/&gt;all_ids = np.array([row[1] &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; index_embedding_list], np.str)&lt;br/&gt;all_vectors = np.array([str_to_vec(row[2]) &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; index_embedding_list], np.float32)&lt;br/&gt;del(index_embedding_list)&lt;br/&gt;&lt;span&gt;#faiss.normalize_L2(all_vectors)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(all_ids[:2])&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(all_vectors[:2])&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;all id size: {}, all vec shape: {}&quot;&lt;/span&gt;.format(len(all_ids), all_vectors.shape))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 建立index索引，并转化为广播变量&lt;/span&gt;&lt;br/&gt;faiss_index = FaissIndex(all_ids, all_vectors, self.args.fast_mode, self.args.nlist, self.args.nprobe)&lt;br/&gt;del(all_vectors)&lt;br/&gt;del(all_ids)&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;broadcast start&quot;&lt;/span&gt;)&lt;br/&gt;bc_faiss_index = self.sc.broadcast(faiss_index)&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;broadcast done&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的index_embedding_rdd就是doc的embedding，可以看到先要collect，然后建立索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建立完索引后，就可以开始计算了，但是这里会有一个问题就是query的量级也是比较大的，如果一起计算可能会OM，所以我们分批次进行即batch：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 开始检索&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# https://blog.csdn.net/wx1528159409/article/details/125879542&lt;/span&gt;&lt;br/&gt;query_embedding_rdd = query_embedding_rdd.repartition(300)&lt;br/&gt;top_n = 5&lt;br/&gt;batch_size = 1000&lt;br/&gt;query_sim_rdd = query_embedding_rdd.mapPartitions(&lt;br/&gt;              lambda iters: batch_get_nearest_ids(&lt;br/&gt;                iters, bc_faiss_index, top_n, batch_size&lt;br/&gt;                )&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设query_embedding_rdd是全部query的embedding，为了实现batch，我们先将query_embedding_rdd进行分区repartition，然后每个batch进行，可以看到核心就是batch_get_nearest_ids这个函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;def batch_get_nearest_ids(iters, bc_faiss_index, top_n, batch_size):&lt;br/&gt;    import mkl&lt;br/&gt;    mkl.get_max_threads()&lt;br/&gt;    res = list()&lt;br/&gt;    rows = list()&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; it &lt;span&gt;in&lt;/span&gt; iters:&lt;br/&gt;        rows.append(it)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; len(rows) &amp;gt;= batch_size:&lt;br/&gt;            batch_res = __batch_get_nearest_ids(rows, bc_faiss_index, top_n)&lt;br/&gt;            res.extend(batch_res)&lt;br/&gt;            rows = list()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; rows:&lt;br/&gt;        batch_res = __batch_get_nearest_ids(rows, bc_faiss_index, top_n)&lt;br/&gt;        res.extend(batch_res)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这里可以清楚的看到就是组batch，组够一个batch后就可以给当前这个batch内的query进行计算最相似的候选啦即__batch_get_nearest_ids这个核心函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;def __batch_get_nearest_ids(rows, bc_faiss_index, top_n):&lt;br/&gt;    import mkl&lt;br/&gt;    mkl.get_max_threads()&lt;br/&gt;    import faiss&lt;br/&gt;    embs = [str_to_vec(row[3]) &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; rows]&lt;br/&gt;    vec = np.array(embs, np.float32)&lt;br/&gt;    &lt;span&gt;#faiss.normalize_L2(vec)&lt;/span&gt;&lt;br/&gt;    similarities, dst_ids = bc_faiss_index.value.batch_search(vec, top_n)&lt;br/&gt;    batch_res = list()&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(rows)):&lt;br/&gt;        batch_res.append([str(&lt;span&gt;&quot;\\t&quot;&lt;/span&gt;.join([rows[i][1], rows[i][2]])), &lt;span&gt;&quot;$$$&quot;&lt;/span&gt;.join([&lt;span&gt;&quot;\\t&quot;&lt;/span&gt;.join(dst.split(&lt;span&gt;&quot;\\t&quot;&lt;/span&gt;)+[str(round(sim, 2))]) &lt;span&gt;for&lt;/span&gt; dst, sim &lt;span&gt;in&lt;/span&gt; zip(dst_ids[i], similarities[i])])])&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; batch_res&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就是真真的调用faiss的索引API进行召回啦，当然了batch_res这个就是结果，自己可以想怎么定义都行，笔者这里不仅返回了召回的item，还返回了query自身的一些信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在map的时候，不论是self的类成员还是类方法都要放到外面，不要放到类里面，不然会报错&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，在用spark做任何需求之前，一定要牢记能map就map，尽量不要聚合算子，实在不行就尽可能放到最后。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODkzMzMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/nW2ZPfuYqSKAnqcViaIWJ40GKChb8uoLoichr44nhO2OSPBzMxhdosvv3Ljc695woogSyoIMlsiaIRuk8ur4jpHZg/0?wx_fmt=png&quot; data-nickname=&quot;AINLP&quot; data-alias=&quot;nlpjob&quot; data-signature=&quot;一个有趣有AI的自然语言处理公众号：关注AI、NLP、机器学习、推荐系统、计算广告等相关技术。公众号可直接对话双语聊天机器人，尝试自动对联、作诗机、藏头诗生成器，调戏夸夸机器人、彩虹屁生成器，使用中英翻译，查询相似词，测试NLP相关工具包。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;进技术交流群请添加AINLP小助手微信（id: ainlp2)&lt;/strong&gt;&lt;/p&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;请备注&lt;span&gt;具体方向+所用到的相关技术点&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502943405&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nW2ZPfuYqSJADkmZ2IX6Z23znAibuEevotDMq9iaMxiapK7jfMibiauGFkycicAJEs6x5U9SGyDJZ0S1tRed9TPNUUDQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关于AINLP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;AINLP 是一个有趣有AI的自然语言处理社区，专注于 AI、NLP、机器学习、深度学习、推荐算法等相关技术的分享，主题包括文本摘要、智能问答、聊天机器人、机器翻译、自动生成、知识图谱、预训练模型、推荐系统、计算广告、招聘信息、求职经验分享等，欢迎关注！加技术交流群请添加AINLP小助手微信(id：ainlp2)，备注工作/研究方向+加群目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;225&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;225&quot; data-fileid=&quot;502943404&quot; data-ratio=&quot;0.40404040404040403&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;990&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nW2ZPfuYqSKABHCqVVQkVYPrM4XY1vsd0iaeuXzyJnoFc8cibd5mYb4wdA3WMQtiaPVmr0XLZHMuVibqWncibpnTSnQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;阅读至此了，分享、点赞、在看三选一吧🙏&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>