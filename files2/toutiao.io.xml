<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>81b7065974f063cf297fee3b99142919</guid>
<title>JVM 说：直接内存的使用</title>
<link>https://toutiao.io/k/rhlsm4e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：京东物流 刘作龙 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;br/&gt;
学习底层原理有的时候不一定你是要用到他，而是学习他的设计思想和思路。再或者，当你在日常工作中遇到棘手的问题时候，可以多一条解决问题的方式  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分享大纲：&lt;/strong&gt;&lt;br/&gt;
本次分享主要由io与nio读取文件速度差异的情况，去了解nio为什么读取大文件的时候效率较高，查看nio是如何使用直接内存的,再深入到如何使用直接内存&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65415848fa8143cd8ea89b6d8bc5d4b4%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;1 nio与io读写文件的效率比对&lt;/h1&gt;

&lt;p&gt;首先上代码，有兴趣的同学可以将代码拿下来进行调试查看  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.lzl.netty.study.jvm;

import lombok.extern.slf4j.Slf4j;
import org.springframework.util.StopWatch;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

/**
 * java对于直接内存使用的测试类
 *
 * @author liuzuolong
 * @date 2022/6/29
 **/
@Slf4j
public class DirectBufferTest {


    private static final int SIZE_10MB = 10 * 1024 * 1024;


    public static void main(String[] args) throws InterruptedException {
        //读取和写入不同的文件,保证互不影响
        String filePath1 = &quot;/Users/liuzuolong/CODE/OWN/netty-study/src/main/resources/ioInputFile.zip&quot;;
        String filePath2 = &quot;/Users/liuzuolong/CODE/OWN/netty-study/src/main/resources/nioDirectInputFile.zip&quot;;
        String filePath3 = &quot;/Users/liuzuolong/CODE/OWN/netty-study/src/main/resources/nioHeapInputFile.zip&quot;;
        String toPath1 = &quot;/Users/liuzuolong/CODE/OWN/netty-study/src/main/resources/ioOutputFile.zip&quot;;
        String toPath2 = &quot;/Users/liuzuolong/CODE/OWN/netty-study/src/main/resources/nioDirectOutputFile.zip&quot;;
        String toPath3 = &quot;/Users/liuzuolong/CODE/OWN/netty-study/src/main/resources/nioHeapOutputFile.zip&quot;;
        Integer fileByteLength = SIZE_10MB;
        //新建io读取文件的线程
        Thread commonIo = new Thread(() -&amp;gt; {
            commonIo(filePath1, fileByteLength, toPath1);
        });
        //新建nio使用直接内存读取文件的线程
        Thread nioWithDirectBuffer = new Thread(() -&amp;gt; {
            nioWithDirectBuffer(filePath2, fileByteLength, toPath2);
        });
        //新建nio使用堆内存读取文件的线程
        Thread nioWithHeapBuffer = new Thread(() -&amp;gt; {
            nioWithHeapBuffer(filePath3, fileByteLength, toPath3);
        });
        nioWithDirectBuffer.start();
        commonIo.start();
        nioWithHeapBuffer.start();
    }

    public static void commonIo(String filePath, Integer byteLength, String toPath) {
        //进行时间监控
        StopWatch ioTimeWatch = new StopWatch();
        ioTimeWatch.start(&quot;ioTimeWatch&quot;);
        try (FileInputStream fis = new FileInputStream(filePath);
             FileOutputStream fos = new FileOutputStream(toPath);
        ) {
            byte[] readByte = new byte[byteLength];
            int readCount = 0;
            while ((readCount = fis.read(readByte)) != -1) {
                // 读取了多少个字节，转换多少个。
                fos.write(readByte, 0, readCount);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        ioTimeWatch.stop();
        log.info(ioTimeWatch.prettyPrint());
    }





    public static void nioWithDirectBuffer(String filePath, Integer byteLength, String toPath) {
        StopWatch nioTimeWatch = new StopWatch();
        nioTimeWatch.start(&quot;nioDirectTimeWatch&quot;);
        try (FileChannel fci = new RandomAccessFile(filePath, &quot;rw&quot;).getChannel();
             FileChannel fco = new RandomAccessFile(toPath, &quot;rw&quot;).getChannel();
        ) {
            // 读写的缓冲区（分配一块儿直接内存）
            //要与allocate进行区分
            //进入到函数中
            ByteBuffer bb = ByteBuffer.allocateDirect(byteLength);
            while (true) {
                int len = fci.read(bb);
                if (len == -1) {
                    break;
                }
                bb.flip();
                fco.write(bb);
                bb.clear();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
        nioTimeWatch.stop();
        log.info(nioTimeWatch.prettyPrint());
    }




    public static void nioWithHeapBuffer(String filePath, Integer byteLength, String toPath) {
        StopWatch nioTimeWatch = new StopWatch();
        nioTimeWatch.start(&quot;nioHeapTimeWatch&quot;);
        try (FileChannel fci = new RandomAccessFile(filePath, &quot;rw&quot;).getChannel();
             FileChannel fco = new RandomAccessFile(toPath, &quot;rw&quot;).getChannel();
        ) {
            // 读写的缓冲区（分配一块儿直接内存）
            //要与allocate进行区分
            ByteBuffer bb = ByteBuffer.allocate(byteLength);
            while (true) {
                int len = fci.read(bb);
                if (len == -1) {
                    break;
                }
                bb.flip();
                fco.write(bb);
                bb.clear();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
        nioTimeWatch.stop();
        log.info(nioTimeWatch.prettyPrint());
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.主函数调用&lt;br/&gt;
为排除当前环境不同导致的文件读写效率不同问题，使用多线程分别调用io方法和nio方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/098b428412e94b44b5c93a95baec747d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.分别进行IO调用和NIO调用&lt;br/&gt;
通过nio和io的读取写入文件方式进行操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab994366de954c1dbb02764cf6617fd7%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.结果&lt;br/&gt;
经过多次测试后，发现nio读取文件的效率是高于io的，尤其是读取大文件的时候&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;11:12:26.606 [Thread-1] INFO com.lzl.netty.study.jvm.DirectBufferTest - StopWatch &#x27;&#x27;: running time (millis) = 1157-----------------------------------------ms     %     Task name-----------------------------------------01157  100%  nioDirectTimeWatch11:12:27.146 [Thread-0] INFO com.lzl.netty.study.jvm.DirectBufferTest - StopWatch &#x27;&#x27;: running time (millis) = 1704-----------------------------------------ms     %     Task name-----------------------------------------01704  100%  ioTimeWatch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4 提出疑问&lt;br/&gt;
那到底为什么nio的速度要快于普通的io呢，结合源码查看以及网上的资料，核心原因是：&lt;br/&gt;
nio读取文件的时候，使用直接内存进行读取，那么，如果在nio中也不使用直接内存的话，会是什么情况呢？&lt;/p&gt;

&lt;p&gt;5.再次验证&lt;br/&gt;
新增使用堆内存读取文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33385d7a8d0f47149f6f9aef479f9564%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;执行时间验证如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;11:30:35.050 [Thread-1] INFO com.lzl.netty.study.jvm.DirectBufferTest - StopWatch &#x27;&#x27;: running time (millis) = 2653-----------------------------------------ms     %     Task name-----------------------------------------02653  100%  nioDirectTimeWatch11:30:35.399 [Thread-2] INFO com.lzl.netty.study.jvm.DirectBufferTest - StopWatch &#x27;&#x27;: running time (millis) = 3038-----------------------------------------ms     %     Task name-----------------------------------------03038  100%  nioHeapTimeWatch11:30:35.457 [Thread-0] INFO com.lzl.netty.study.jvm.DirectBufferTest - StopWatch &#x27;&#x27;: running time (millis) = 3096-----------------------------------------ms     %     Task name-----------------------------------------03096  100%  ioTimeWatch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据上述的实际验证，nio读写文件比较快的主要原因还是在于使用了直接内存，那么为什么会出现这种情况呢？&lt;/p&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;2 直接内存的读写性能强的原理&lt;/h1&gt;

&lt;p&gt;直接上图说明&lt;br/&gt;
1.堆内存读写文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc973155e8774be7a603247ae8e16d81%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;堆内存读写文件的步骤：&lt;br/&gt;
当JVM想要去和磁盘进行交互的时候，因为JVM和操作系统之间存在读写屏障，所以在进行数据交互的时候需要进行频繁的复制&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  先由操作系统进行磁盘的读取，将读取数据放入系统内存缓冲区中&lt;/li&gt;
&lt;li&gt;  JVM与系统内存缓冲区进行数据拷贝&lt;/li&gt;
&lt;li&gt;  应用程序再到JVM的堆内存空间中进行数据的获取&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.直接内存读写文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26b4f1a786b642419150ba4ec821984a%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;直接内存读写文件的步骤&lt;br/&gt;
如果使用直接内存进行文件读取的时候，步骤如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  会直接调用native方法allocateMemory进行直接内存的分配&lt;/li&gt;
&lt;li&gt;  操作系统将文件读取到这部分的直接内存中&lt;/li&gt;
&lt;li&gt;  应用程序可以通过JVM堆空间的DirectByteBuffer进行读取&lt;br/&gt;
与使用对堆内存读写文件的步骤相比减少了数据拷贝的过程，避免了不必要的性能开销，因此NIO中使用了直接内存，对于性能提升很多&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，直接内存的使用方式是什么样的呢？&lt;/p&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;3 nio使用直接内存的源码解读&lt;/h1&gt;

&lt;p&gt;在阅读源码之前呢，我们首先对于两个知识进行补充&lt;/p&gt;

&lt;p&gt;1.虚引用Cleaner sun.misc.Cleaner&lt;/p&gt;

&lt;p&gt;什么是虚引用&lt;br/&gt;
虚引用所引用的对象，永远不会被回收，除非指向这个对象的所有虚引用都调用了clean函数，或者所有这些虚引用都不可达&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;必须关联一个引用队列&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cleaner继承自虚引用PhantomReference，关联引用队列ReferenceQueue&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fbf737f1cb244c99dc7fcba1e425a5c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;概述的说一下，他的作用就是，JVM会将其对应的Cleaner加入到pending-Reference链表中，同时通知ReferenceHandler线程处理，ReferenceHandler收到通知后，会调用Cleaner#clean方法&lt;/p&gt;

&lt;p&gt;2.Unsafesun misc.Unsafe&lt;br/&gt;
位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。&lt;/p&gt;

&lt;p&gt;3.直接内存是如何进行申请的 java.nio.DirectByteBuffer&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba82a5466ed14e04855a29c9ef9c9274%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ec7e93faf97435c9961fa7bb409020b%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进入到DirectBuffer中进行查看&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e893671790764e01bc928228153df120%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;源码解读&lt;br/&gt;
PS:只需要读核心的划红框的位置的源码，其他内容按个人兴趣阅读&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  直接调用ByteBuffer.allocateDirect方法&lt;/li&gt;
&lt;li&gt;  声明一个一个DirectByteBuffer对象&lt;/li&gt;
&lt;li&gt;  在DirectByteBuffer的构造方法中主要进行三个步骤&lt;br/&gt;
步骤1：调用Unsafe的native方法allocateMemory进行缓存空间的申请,获取到的base为内存的地址&lt;br/&gt;
步骤2：设置内存空间需要和步骤1联合进行使用&lt;br/&gt;
步骤3：使用虚引用Cleaner类型，创建一个缓存的释放的虚引用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;直接缓存是如何释放的&lt;/strong&gt;&lt;br/&gt;
我们前面说的了Cleaner的使用方式，那么cleaner在直接内存的释放中的流程是什么样的呢？&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;3.1 新建虚引用&lt;/h2&gt;

&lt;p&gt;java.nio.DirectByteBuffer&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aee64c8c029242a1b83870759fe54a42%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;步骤如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  调用Cleaner.create()方法&lt;/li&gt;
&lt;li&gt;  将当前新建的Cleaner加入到链表中&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;3.2 声明清理缓存任务&lt;/h2&gt;

&lt;p&gt;查看java.nio.DirectByteBuffer.Deallocator的方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1214cead592f41a2bda70e3d1118d8f8%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  实现了Runnable接口&lt;/li&gt;
&lt;li&gt;  run方法中调用了unsafe的native方法freeMemory()进行内存的释放&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;3.3 ReferenceHandler进行调用&lt;/h2&gt;

&lt;p&gt;首先进入：java.lang.ref.Reference.ReferenceHandler&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80041ec6821a408eb3aa90621b25b1c3%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当前线程优先级最高，调用方法tryHandlePending&lt;/p&gt;

&lt;p&gt;进入方法中，会调用c.clean c—&amp;gt;(Cleaner)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36801648880544f9a9e687b55f9d8df5%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;clean方法为Cleaner中声明的Runnable，调用其run()方法&lt;br/&gt;
Cleaner中的声明：private final Runnable thunk;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c883562179c4264b048dbbfa654dee5%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;回到《声明清理缓存任务》这一节，查看Deallocator，使用unsafe的native方法freeMemory进行缓存的释放&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5787c9bac164b229bd58995e37e92e2%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;4 直接内存的使用方式&lt;/h1&gt;

&lt;p&gt;直接内存特性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  nio中比较经常使用，用于数据缓冲区ByteBuffer&lt;/li&gt;
&lt;li&gt;  因为其不受JVM的垃圾回收管理，故分配和回收的成本较高&lt;/li&gt;
&lt;li&gt;  使用直接内存的读写性能非常高&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;直接内存是否会内存溢出&lt;br/&gt;
直接内存是跟系统内存相关的，如果不做控制的话，走的是当前系统的内存，当然JVM中也可以对其使用的大小进行控制，设置JVM参数-XX:MaxDirectMemorySize=5M，再执行的时候就会出现内存溢出&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9671e2ef10fb455687f1cb35c5179110%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;直接内存是否会被JVM的GC影响&lt;br/&gt;
如果在直接内存声明的下面调用System.gc();因为会触发一次FullGC，则对象会被回收，则ReferenceHandler中的会被调用，直接内存会被释放。&lt;/p&gt;

&lt;p&gt;我想使用直接内存，怎么办&lt;br/&gt;
如果你很想使用直接内存，又想让直接内存尽快的释放，是不是我直接调用System.gc();就行？&lt;br/&gt;
答案是不行的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  首先调用System.gc();会触发FullGC，造成stop the world，影响系统性能&lt;/li&gt;
&lt;li&gt;  系统怕有初级研发显式调用System.gc();会配置JVM参数：-XX:+DisableExplicitGC，禁止显式调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果还想调用的话，自己使用Unsafe进行操作，以下为示例代码&lt;br/&gt;
PS:仅为建议，如果没有对于Unsafe有很高的理解，请勿尝试&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4801c3205804aa0b27c5a2e6bf6bff1%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;代码.png&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;5 总结&lt;/h1&gt;

&lt;p&gt;JVM相关知识是中高级研发人员必备的知识，学习他的一些运行原理，对我们的日常工作会有很大的帮助&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>595c06a2cea1a05a3cd30ca8280a2ef5</guid>
<title>别再折腾 ChatGpt 的微信机器人了，你看到的全是假的</title>
<link>https://toutiao.io/k/fmepfiv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;h1&gt;别再折腾ChatGpt的微信机器人了，你看到的全是假的&lt;/h1&gt;&lt;p&gt;ChatGPT去年先是在程序员圈子里小众出圈，当时本拐还写了两篇文章：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3OTI5MzU3Mw==&amp;amp;mid=2247484021&amp;amp;idx=1&amp;amp;sn=28b7d78fca4007dfdb5a7dbee2ed6480&amp;amp;chksm=eb48b99fdc3f30899896a50dea6d8db55c4727b281147876b96b9402f33ee94c18425e4347b9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;跟着ChatGPT手把实现一个websocket连接管理器！ 毛骨悚然&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;跟着ChatGPT手把实现一个websocket连接管理器！毛骨悚然&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3OTI5MzU3Mw==&amp;amp;mid=2247484025&amp;amp;idx=1&amp;amp;sn=0fc03ed9ae32d786c620653f0c0cea9d&amp;amp;chksm=eb48b993dc3f3085afd10837530886b6ffd1f621d347c3a044eecaeedb4a96134b5ffe2b8451&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我当PM,把ChatGPT玩冒(bà)烟(gōng)了&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;我当PM,把ChatGPT玩冒(bà)烟(gōng)了&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2023年后，被各路资本，各种官圈带动以后，各种出圈。&lt;/p&gt;&lt;h2&gt;关于微信机器人&lt;/h2&gt;&lt;p&gt;很多人想要体验一下这种牛逼的AI到底有多牛逼，由于众所周知的原因，国内没办法直接使用，于是出现了很多微信机器人和H5的聊天。&lt;/p&gt;&lt;p&gt;不能免俗，本拐也架设过，除了不稳定以外，回答也总是感觉怪怪，总和web上直接使用有区别，经过研究后，有如下的结论：&lt;/p&gt;&lt;p&gt;微信机器人或H5桥接chatGPT的原理，有两种：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. 扒chatGPT的网页上的cookie，然后使用网页api调用，作为对外提供的服务，这种形式显然是不稳定的。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;2.调用openai的API，实现相应对话，显然这种是更可取的。&lt;/p&gt;&lt;p&gt;但是我们调用API时，总感觉与web上返回的有些区别：&lt;/p&gt;&lt;p&gt;比如。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;提问&lt;/strong&gt; 白灼大虾怎么做?&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;API回答&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. 将大虾洗净，去除虾黄。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 用刀背将虾身轻轻剥开，去除虾线。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3. 将虾身放入盘中，加入生抽、盐、料酒、姜片腌制。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4. 起锅烧水，放入虾身焯水后捞起。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5. 把葱姜切成小块，放入锅中炒香。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6. 倒入虾身，翻炒均匀。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;7. 倒入适量清水，加入盐、白糖、醋调味。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;8. 小火焖煮至水收干即可。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;网页回答&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;白灼大虾是一道经典的中国菜式，非常受欢迎。下面是一份做白灼大虾的基本步骤。&lt;/p&gt;&lt;p&gt;材料：&lt;/p&gt;&lt;p&gt;1 只大虾（去壳）&lt;br/&gt;2 大勺生姜（切碎）&lt;br/&gt;2 大勺生蒜（切碎）&lt;br/&gt;2 茶勺生抽&lt;br/&gt;2 茶勺玉米淀粉&lt;br/&gt;2 茶勺料酒&lt;br/&gt;适量盐&lt;br/&gt;适量白胡椒粉&lt;br/&gt;适量葱花&lt;br/&gt;适量熟油&lt;br/&gt;适量生粉&lt;br/&gt;步骤：&lt;/p&gt;&lt;p&gt;将大虾洗净，加入料酒、生抽、盐、白胡椒粉腌制 15 分钟。&lt;br/&gt;热锅，加入熟油，放入姜蒜碎炒香。&lt;br/&gt;加入大虾煎至两面变红。&lt;br/&gt;加入生抽、玉米淀粉、盐调味，翻煎均匀。&lt;br/&gt;加入适量的水，搅拌均匀，煮沸后熄火。&lt;br/&gt;加入葱花，翻炒均匀。&lt;br/&gt;倒入盘中，撒上生粉，即可享用。&lt;br/&gt;希望这份白灼大虾的做法对您有所帮助！&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;虽然&lt;code&gt;1只大虾&lt;/code&gt;这种说法很扯淡，但是可以看出来，从文案组织上，网页版的要远好于API的结果的，而且在提问的过程中，网页版还有所纠正。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.540197461212976&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/399sxLagOt9nSNfVbE4UtCADibYTDibQBNknZ0ubiaINF4DwwLCicn8tm7BrjbvygfLanPZbFYpGvGRbc7k3ewexpw/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1418&quot;/&gt;&lt;/p&gt;&lt;p&gt;本着寻根问底的精神，本拐仔细看了机器人的源码以及openai的说明，发现，调用用对话的API时，会有一个传参，&lt;code&gt;model&lt;/code&gt;，在api中，这个model的选项&lt;span&gt;如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6695544554455446&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/399sxLagOt9nSNfVbE4UtCADibYTDibQBNk11icVkNwEx4cVwyZMicHDricBZwNWn6YHnBkl7nhZ1b6pv2VmR4TFz1w/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;/p&gt;&lt;p&gt;而在网页中，这个model的参数如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30452261306532663&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/399sxLagOt9nSNfVbE4UtCADibYTDibQBNHDJJZ8G1bLpSZiaRSbB9LDaqfKjGcvgxRMVXDXdCwl03qHiav0qHSb6Q/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;p&gt;可以看出区别了吧，api的最多只能使&lt;code&gt;text-davinci-003&lt;/code&gt;这个模型，而这个模型也是剪枝版本，通过测试，发现&lt;code&gt;text-davinci-002&lt;/code&gt;这个模型也可以调用通，关于两个模型的区别，&lt;code&gt;ChatGPT&lt;/code&gt;的回答如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6149914821124361&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/399sxLagOt9nSNfVbE4UtCADibYTDibQBNWrO0c3rUvN80etd0oHCCYFicojD6Mia1CicgicfSsQpx07x7RdLbd1gGicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1174&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;而网页使用的模型是&lt;/span&gt;&lt;/code&gt;&lt;code&gt;text-davinci-002-render&lt;/code&gt;&lt;span&gt;&lt;span&gt; ,关于这个模型，则是如下回答：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5244865718799369&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/399sxLagOt9nSNfVbE4UtCADibYTDibQBNRy3yJic4MNYictkia2qQaYD9UrleOGAd0bYXP4SlH48ViahLrte3KEz3Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;因此，可以看出来，由于调用的模型不同，我们没办法在微信机器人上达到与网页一致的对话效果。&lt;/p&gt;&lt;p&gt;最终，在各种测试后，本拐不得不放弃了相应的努力 。&lt;/p&gt;&lt;h2&gt;关于费用&lt;/h2&gt;&lt;p&gt;我一开始天真的以为api调用是免费的，直到看到了这个页面。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6455266138165345&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/399sxLagOt9nSNfVbE4UtCADibYTDibQBNAWSwmGdNdt6G7jV5fv2c5j7w9DBqib9pfmMq1KyJ445UGVWacic7e2xQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1766&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. 原来api调用是有费用的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 对于新注册的开发者，有18美元的试用额度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3. 他们用了一种复杂的模式来计算调用费用，基本上要看每个请求的 prompt和completion ，这两个值具体是什么本拐没有去细研究，但是，在两天的测试时间里，我在2022.2.8调用189次api(即189个request),费用是1.33美元，我在2023.2.9调用116次，费用是0.98美元。计算成下表：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;时间&lt;/td&gt;&lt;td&gt;requests&lt;/td&gt;&lt;td&gt;费用&lt;/td&gt;&lt;td&gt;平均每次请求&lt;br/&gt;费用(美元)&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2023-2-8&lt;/td&gt;&lt;td&gt;189&lt;/td&gt;&lt;td&gt;1.33&lt;/td&gt;&lt;td&gt;0.007037037&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2023-2-9&lt;/td&gt;&lt;td&gt;119&lt;/td&gt;&lt;td&gt;0.98&lt;/td&gt;&lt;td&gt;0.008235294&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;合计&lt;/td&gt;&lt;td&gt;308&lt;/td&gt;&lt;td&gt;2.31&lt;/td&gt;&lt;td&gt;0.0075&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;每问一个问题应该算是一次request&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;0.0075美元一次的请求，我觉得这个费用是大多数国内公司以及开发者承受不起的，所以即便是缩减版的chatGPT ，估计也会很快下线。&lt;/p&gt;&lt;h2&gt;结论&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. 折腾机器人和使用机器人的兄弟姐妹们，可以歇一歇了。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;2.有条件的同学还是可以自己在网页上真正体验一下。3.即使真正模型供调用了，对于国内开发商也承受不起。&lt;/p&gt;&lt;p&gt;至于国内宣布的一众跟进的各个巨头，能不能做出与之比肩的产品，拭目以待吧。&lt;/p&gt;&lt;h2&gt;关于老拐瘦&lt;/h2&gt;&lt;p&gt;中年争取不油不丧积极向上的码农一名&lt;/p&gt;&lt;p&gt;咖啡，摄影，骑行，音乐&lt;/p&gt;&lt;p&gt;样样通，样样松&lt;/p&gt;&lt;p&gt;喜欢可以关注一下公众号 &lt;strong&gt;IT老拐瘦&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI3OTI5MzU3Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/399sxLagOticTGIGeRVDb75NJlMGNKdib48BYHS0t3kiaV3Q5q984FGb2ZvTVIwib5d6x1AlkDoMibA1vibArg9WDMCw/0?wx_fmt=png&quot; data-nickname=&quot;IT老拐瘦&quot; data-alias=&quot;CODELGS&quot; data-signature=&quot;代码，摄影，咖啡，以及各种不搭&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ef47c688c5f13c5864b2a273cfcd9935</guid>
<title>Kubernetes：分享一个可以展示资源视图的 K8s开源 Web/桌面 客户端工具 Octant</title>
<link>https://toutiao.io/k/n8sj39z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot;/&gt;&lt;h3&gt;写在前面&lt;/h3&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li data-pid=&quot;mIT5mEAk&quot;&gt;博文内容主要为 &lt;code&gt;Octant&lt;/code&gt; 介绍以及 &lt;code&gt;桌面/Web&lt;/code&gt; 端的安装教程&lt;/li&gt;&lt;li data-pid=&quot;mOiYaW9j&quot;&gt;涉及 &lt;code&gt;Linux/Windows&lt;/code&gt; 的安装。&lt;/li&gt;&lt;li data-pid=&quot;TQoCKK2M&quot;&gt;理解不足小伙伴帮忙指正&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;1Sl0WZNE&quot;&gt;&lt;b&gt;其实当你什么都经历了，会发现，人生无论你怎么精心策划都抵不过一场命运的安排。&lt;/b&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-pid=&quot;xHrrqJAp&quot;&gt;Octant 不是仪表板，Octant 是一个带有仪表板视图的平台， 需要说明的时，这个项目有近 10 个月没有维护，不过对于 k8s 工具来讲，我认为它是不次于 Lens 的项目，并且它开源，Lens 要收费了，如果考虑费用问题，我认为这是一个不错的选择。 Octant 可以展示 当前资源的 依赖视图，这对于可以直观的看到 API 资源的依赖关系是很有帮助的。&lt;/p&gt;&lt;p data-pid=&quot;7VehnAWo&quot;&gt;Octant 提供了一种理解复杂 Kubernetes 环境的新方法。它可以部署为 Web ，通过浏览器客户端访问，也可以以桌面的方法来安装，你需要的仅仅是一个做了授权的 &lt;code&gt;kubeconfig&lt;/code&gt; 文件.&lt;/p&gt;&lt;p data-pid=&quot;7pcnUJtz&quot;&gt;对于类似的 k8s 工具，在生产中， &lt;code&gt;Octant&lt;/code&gt; 结合 &lt;code&gt;Rancher&lt;/code&gt; 可以满足大部分需求。  如果你的访问权限受限，只有一个终端，推荐使用 &lt;code&gt;kubebox&lt;/code&gt; 或者 &lt;code&gt;k8s&lt;/code&gt; .&lt;/p&gt;&lt;h3&gt;特征:&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;febeAEZS&quot;&gt;&lt;code&gt;资源查看器&lt;/code&gt; ： 以图形方式可视化 Kubernetes 集群中对象之间的关系。各个对象的状态用颜色表示以显示工作负载性能。&lt;/li&gt;&lt;li data-pid=&quot;DQJiaRKE&quot;&gt;&lt;code&gt;摘要视图&lt;/code&gt; ： 从通常使用多个 kubectl 命令找到的输出中聚合的单个页面中的合并状态和配置信息。&lt;/li&gt;&lt;li data-pid=&quot;U7V4DnV1&quot;&gt;&lt;code&gt;端口转发&lt;/code&gt;: 使用用于调试应用程序的单个按钮将本地端口转发到正在运行的 pod，甚至跨命名空间端口转发多个 pod。&lt;/li&gt;&lt;li data-pid=&quot;HWrJy7ul&quot;&gt;&lt;code&gt;日志流&lt;/code&gt;: 查看 Pod 和容器活动的日志流，以便在不打开多个终端的情况下进行故障排除或监控。&lt;/li&gt;&lt;li data-pid=&quot;JRD_lK7d&quot;&gt;&lt;code&gt;标签过滤器&lt;/code&gt;: 使用标签过滤组织工作负载，以检查命名空间中包含大量对象的集群。&lt;/li&gt;&lt;li data-pid=&quot;T_TyK9VK&quot;&gt;&lt;code&gt;集群导航&lt;/code&gt;:在不同集群的命名空间或上下文之间轻松更改。还支持多个 kubeconfig 文件。&lt;/li&gt;&lt;li data-pid=&quot;oCR5ltv-&quot;&gt;&lt;code&gt;插件系统&lt;/code&gt;: 高度可扩展的插件系统，供用户通过 gRPC 提供额外的功能。插件作者可以在现有视图之上添加组件。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;桌面端安装&lt;/h3&gt;&lt;h3&gt;window安装&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;PS C:&lt;span class=&quot;se&quot;&gt;\U&lt;/span&gt;sers&lt;span class=&quot;se&quot;&gt;\山&lt;/span&gt;河已无恙&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;ownloads&amp;gt; curl -o Octant.Setup.0.25.1.exe  https://github.com/vmware-tanzu/octant/releases/download/v0.25.1/Octant.Setup.0.25.1.exe&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;_UnNlXt9&quot;&gt;下载好之后安装，之后桌面上会有一个图标&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8f3348788cfc727ce5e084809ddd2745_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;541&quot; data-rawheight=&quot;377&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-8f3348788cfc727ce5e084809ddd2745_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;541&quot; data-rawheight=&quot;377&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-8f3348788cfc727ce5e084809ddd2745_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8f3348788cfc727ce5e084809ddd2745_b.jpg&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;5GsIuAbv&quot;&gt;点击启动它，第一次打开会提示输入 kubeconfig 文件。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d6c7af9812cfce9b3ffa9c471d596d0a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1234&quot; data-rawheight=&quot;750&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-d6c7af9812cfce9b3ffa9c471d596d0a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1234&quot; data-rawheight=&quot;750&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-d6c7af9812cfce9b3ffa9c471d596d0a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d6c7af9812cfce9b3ffa9c471d596d0a_b.jpg&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;┌──&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@vms81.liruilongs.github.io&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;-&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/var/run&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
└─&lt;span class=&quot;nv&quot;&gt;$cat&lt;/span&gt; ~/.kube/config&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;jmqfgh6z&quot;&gt;然后点击加载，就可以查看集群信息&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7d21d4a2738e92ad6b7bec5f42361318_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1541&quot; data-rawheight=&quot;710&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-7d21d4a2738e92ad6b7bec5f42361318_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1541&quot; data-rawheight=&quot;710&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-7d21d4a2738e92ad6b7bec5f42361318_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-7d21d4a2738e92ad6b7bec5f42361318_b.jpg&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;pweORVxP&quot;&gt;哈，可能我机器 CPU 不行，感觉桌面端很耗资源。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3dfb1947a9defab5c889ae8807c270e4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1161&quot; data-rawheight=&quot;461&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-3dfb1947a9defab5c889ae8807c270e4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1161&quot; data-rawheight=&quot;461&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-3dfb1947a9defab5c889ae8807c270e4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-3dfb1947a9defab5c889ae8807c270e4_b.jpg&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3&gt;web 端安装&lt;/h3&gt;&lt;h3&gt;window安装&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;PS C:&lt;span class=&quot;se&quot;&gt;\U&lt;/span&gt;sers&lt;span class=&quot;se&quot;&gt;\山&lt;/span&gt;河已无恙&amp;gt; choco install octant --confirm --force
Chocolatey v1.1.0
Installing the following packages:
octant
By installing, you accept licenses &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; the packages.
octant v0.25.1 already installed. Forcing reinstall of version &lt;span class=&quot;s1&quot;&gt;&#x27;0.25.1&#x27;&lt;/span&gt;.
 Please use upgrade &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; you meant to upgrade to a new version.

octant v0.25.1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;forced&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Approved&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
octant package files install completed. Performing other installation steps.
Using system proxy server &lt;span class=&quot;s1&quot;&gt;&#x27;127.0.0.1:49739&#x27;&lt;/span&gt;.
Downloading octant &lt;span class=&quot;m&quot;&gt;64&lt;/span&gt; bit
  from &lt;span class=&quot;s1&quot;&gt;&#x27;https://github.com/vmware-tanzu/octant/releases/download/v0.25.1/octant_0.25.1_Windows-64bit.zip&#x27;&lt;/span&gt;
Using system proxy server &lt;span class=&quot;s1&quot;&gt;&#x27;127.0.0.1:49739&#x27;&lt;/span&gt;.
Progress: 100% - Completed download of C:&lt;span class=&quot;se&quot;&gt;\U&lt;/span&gt;sers&lt;span class=&quot;se&quot;&gt;\山&lt;/span&gt;河已无恙&lt;span class=&quot;se&quot;&gt;\A&lt;/span&gt;ppData&lt;span class=&quot;se&quot;&gt;\L&lt;/span&gt;ocal&lt;span class=&quot;se&quot;&gt;\T&lt;/span&gt;emp&lt;span class=&quot;se&quot;&gt;\c&lt;/span&gt;hocolatey&lt;span class=&quot;se&quot;&gt;\o&lt;/span&gt;ctant&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;.25.1&lt;span class=&quot;se&quot;&gt;\o&lt;/span&gt;ctant_0.25.1_Windows-64bit.zip &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;54.37 MB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.
Download of octant_0.25.1_Windows-64bit.zip &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;54.37 MB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; completed.
Hashes match.
Extracting C:&lt;span class=&quot;se&quot;&gt;\U&lt;/span&gt;sers&lt;span class=&quot;se&quot;&gt;\山&lt;/span&gt;河已无恙&lt;span class=&quot;se&quot;&gt;\A&lt;/span&gt;ppData&lt;span class=&quot;se&quot;&gt;\L&lt;/span&gt;ocal&lt;span class=&quot;se&quot;&gt;\T&lt;/span&gt;emp&lt;span class=&quot;se&quot;&gt;\c&lt;/span&gt;hocolatey&lt;span class=&quot;se&quot;&gt;\o&lt;/span&gt;ctant&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;.25.1&lt;span class=&quot;se&quot;&gt;\o&lt;/span&gt;ctant_0.25.1_Windows-64bit.zip to C:&lt;span class=&quot;se&quot;&gt;\P&lt;/span&gt;rogramData&lt;span class=&quot;se&quot;&gt;\c&lt;/span&gt;hocolatey&lt;span class=&quot;se&quot;&gt;\l&lt;/span&gt;ib&lt;span class=&quot;se&quot;&gt;\o&lt;/span&gt;ctant&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;ools...
C:&lt;span class=&quot;se&quot;&gt;\P&lt;/span&gt;rogramData&lt;span class=&quot;se&quot;&gt;\c&lt;/span&gt;hocolatey&lt;span class=&quot;se&quot;&gt;\l&lt;/span&gt;ib&lt;span class=&quot;se&quot;&gt;\o&lt;/span&gt;ctant&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;ools
 ShimGen has successfully created a shim &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; octant.exe
 The install of octant was successful.
  Software installed to &lt;span class=&quot;s1&quot;&gt;&#x27;C:\ProgramData\chocolatey\lib\octant\tools&#x27;&lt;/span&gt;

Chocolatey installed 1/1 packages.
 See the log &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; details &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;C:&lt;span class=&quot;se&quot;&gt;\P&lt;/span&gt;rogramData&lt;span class=&quot;se&quot;&gt;\c&lt;/span&gt;hocolatey&lt;span class=&quot;se&quot;&gt;\l&lt;/span&gt;ogs&lt;span class=&quot;se&quot;&gt;\c&lt;/span&gt;hocolatey.log&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.

Enjoy using Chocolatey? Explore more amazing features to take your
experience to the next level at
 https://chocolatey.org/compare
PS C:&lt;span class=&quot;se&quot;&gt;\U&lt;/span&gt;sers&lt;span class=&quot;se&quot;&gt;\山&lt;/span&gt;河已无恙&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;PXAgtZqC&quot;&gt;启动运行&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;PS C:&lt;span class=&quot;se&quot;&gt;\P&lt;/span&gt;rogramData&lt;span class=&quot;se&quot;&gt;\c&lt;/span&gt;hocolatey&lt;span class=&quot;se&quot;&gt;\l&lt;/span&gt;ib&lt;span class=&quot;se&quot;&gt;\o&lt;/span&gt;ctant&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;ools&lt;span class=&quot;se&quot;&gt;\o&lt;/span&gt;ctant_0.25.1_Windows-64bit&amp;gt; .&lt;span class=&quot;se&quot;&gt;\o&lt;/span&gt;ctant.exe
2023-01-14T06:12:55.534-0500    INFO    dash/dash.go:637        cannot find kube config: C:&lt;span class=&quot;se&quot;&gt;\U&lt;/span&gt;sers&lt;span class=&quot;se&quot;&gt;\山&lt;/span&gt;河
已无恙&lt;span class=&quot;se&quot;&gt;\.&lt;/span&gt;kube&lt;span class=&quot;se&quot;&gt;\c&lt;/span&gt;onfig
2023-01-14T06:12:55.534-0500    INFO    dash/dash.go:134        no valid kube config found, initializing loading API
2023-01-14T06:12:55.536-0500    INFO    dash/dash.go:154        waiting &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; kube config ...
2023-01-14T06:12:55.577-0500    INFO    dash/dash.go:546        Dashboard is available at http://127.0.0.1:7777&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-25df237e13be8ed4bde8219ab39bc2d9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1380&quot; data-rawheight=&quot;886&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-25df237e13be8ed4bde8219ab39bc2d9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1380&quot; data-rawheight=&quot;886&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-25df237e13be8ed4bde8219ab39bc2d9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-25df237e13be8ed4bde8219ab39bc2d9_b.jpg&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;7qlCgxs4&quot;&gt;输入 kubeconfig 文件信息&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f8fcd87ddc3d5c9befa23a1b02257e93_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1381&quot; data-rawheight=&quot;1024&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-f8fcd87ddc3d5c9befa23a1b02257e93_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1381&quot; data-rawheight=&quot;1024&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-f8fcd87ddc3d5c9befa23a1b02257e93_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-f8fcd87ddc3d5c9befa23a1b02257e93_b.jpg&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;fqprUtSB&quot;&gt;可以更换主题，查看集群信息。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8bfd42648fb181e5b9d3ccfc86fd698d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1380&quot; data-rawheight=&quot;754&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-8bfd42648fb181e5b9d3ccfc86fd698d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1380&quot; data-rawheight=&quot;754&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-8bfd42648fb181e5b9d3ccfc86fd698d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8bfd42648fb181e5b9d3ccfc86fd698d_b.jpg&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3&gt;Linux 下安装&lt;/h3&gt;&lt;p data-pid=&quot;JNkrd2V6&quot;&gt;下载安装包&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;curl -o octant_0.25.1_Linux-64bit.tar.gz  https://github.com/vmware-tanzu/octant/releases/download/v0.25.1/octant_0.25.1_Linux-64bit.tar.gz&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;I11mveDb&quot;&gt;解压查看版本信息。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;┌──&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@vms81.liruilongs.github.io&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;-&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;~/ansible/octant&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
└─&lt;span class=&quot;nv&quot;&gt;$tar&lt;/span&gt; -zxvf octant_0.25.1_Linux-64bit.tar.gz
octant_0.25.1_Linux-64bit/README.md
octant_0.25.1_Linux-64bit/octant
┌──&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@vms81.liruilongs.github.io&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;-&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;~/ansible/octant&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
└─&lt;span class=&quot;nv&quot;&gt;$octant_0&lt;/span&gt;.25.1_Linux-64bit/octant version
Version:  0.25.1
Git commit:  f16cbb951905f1f8549469dfc116ca16cf679d46
Built:  2022-02-24T23:02:15Z&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Vkd09McG&quot;&gt;查看帮助文档了解启动信息&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;┌──&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@vms81.liruilongs.github.io&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;-&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;~/ansible/octant&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
└─&lt;span class=&quot;nv&quot;&gt;$octant_0&lt;/span&gt;.25.1_Linux-64bit/octant --help
octant is a dashboard &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; high bandwidth cluster analysis operations

Usage:
  octant &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;flags&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  octant &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;command&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

Available Commands:
  completion  generate the autocompletion script &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; the specified shell
  &lt;span class=&quot;nb&quot;&gt;help&lt;/span&gt;        Help about any &lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt;
  version     Show version

Flags:
      --context string                 initial context
      --disable-cluster-overview       disable cluster overview
      --enable-feature-applications    &lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt; applications feature
      --kubeconfig string              absolute path to kubeConfig file
  -n, --namespace string               initial namespace
      --namespace-list strings         a list of namespaces to use on start
      --plugin-path string             plugin path
  -v, --verbose                        turn on debug logging
      --client-max-recv-msg-size int   client max receiver message size &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default 16777216&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      --accepted-hosts string          accepted hosts list &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DEV&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
      --client-qps float32             maximum QPS &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; client &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DEV&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default 200&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      --client-burst int               maximum burst &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; client throttle &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DEV&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default 400&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      --disable-open-browser           disable automatic launching of the browser &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DEV&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
      --disable-origin-check           disable cross origin resource check
  -c, --enable-opencensus              &lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt; open census &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DEV&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
      --klog-verbosity int             klog verbosity level &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DEV&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
      --listener-addr string           listener address &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; the octant frontend &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DEV&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
      --local-content string           &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt; content path &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DEV&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
      --proxy-frontend string          url to send frontend request to &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DEV&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
      --ui-url string                  dashboard url &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DEV&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
      --browser-path string            the browser path to open the browser on
      --memstats string                log memory usage to this file
      --meminterval string             interval to poll memory usage &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;requires --memstats&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, valid &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt; units are &lt;span class=&quot;s2&quot;&gt;&quot;ns&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;us&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;or &lt;span class=&quot;s2&quot;&gt;&quot;µs&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;ms&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;s&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;m&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;h&quot;&lt;/span&gt;. &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default &lt;span class=&quot;s2&quot;&gt;&quot;100ms&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  -h, --help                           &lt;span class=&quot;nb&quot;&gt;help&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; octant

Use &lt;span class=&quot;s2&quot;&gt;&quot;octant [command] --help&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; more information about a command.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;k1uGm62P&quot;&gt;这里在启动的时候需要注意一下，如果终端没有浏览器，需要指定 &lt;code&gt;--disable-open-browser&lt;/code&gt;,同时如果是 其他机器通过IP访问，需要添加监听的任意IP对端口的访问 &lt;code&gt;--listener-addr 0.0.0.0:7777&lt;/code&gt;， 默认情况下， Octant 会在启动时候自动打开默认浏览器，并且只监听本地对 指定端口的访问。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;┌──&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@vms81.liruilongs.github.io&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;-&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;~/ansible/octant/octant_0.25.1_Linux-64bit&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
└─$./octant --kubeconfig ~/.kube/config --disable-open-browser --disable-origin-check --listener-addr 0.0.0.0:7777
2023-01-14T20:05:20.673+0800    INFO    dash/watcher.go:117     watching config file    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;component&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;config-watcher&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;config&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;/root/.kube/config&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
.............
2023-01-14T20:05:20.677+0800    INFO    module/manager.go:87    registering action      &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;component&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;module-manager&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;actionPath&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;action.octant.dev/deleteObject&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;module-name&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;configuration&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
2023-01-14T20:05:20.677+0800    WARN    plugin/manager.go:405   Unable to add /root/.config/octant/plugins to the plugin watcher. Error: no such file or directory

github.com/vmware-tanzu/octant/pkg/plugin.&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;*Manager&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.watchPluginFiles
        /__w/octant/octant/pkg/plugin/manager.go:405
2023-01-14T20:05:20.691+0800    INFO    dash/dash.go:546        Dashboard is available at http://&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;::&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;:7777&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;AAk9qHSJ&quot;&gt;其他机器测试。可以直接进入当前 pod  的内部环境&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-245aaae50c9ebbcdc06502c7718e65dc_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1393&quot; data-rawheight=&quot;1032&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-245aaae50c9ebbcdc06502c7718e65dc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1393&quot; data-rawheight=&quot;1032&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-245aaae50c9ebbcdc06502c7718e65dc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-245aaae50c9ebbcdc06502c7718e65dc_b.jpg&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;V8cSb3PK&quot;&gt;查看日志信息&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bf1a85ab5be1816fda3f447673579588_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1393&quot; data-rawheight=&quot;1032&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-bf1a85ab5be1816fda3f447673579588_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1393&quot; data-rawheight=&quot;1032&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-bf1a85ab5be1816fda3f447673579588_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-bf1a85ab5be1816fda3f447673579588_b.jpg&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;_GMDZyEb&quot;&gt;查看资源依赖关系&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-089c5280a772f3e7ec7f8295d634b9b6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1377&quot; data-rawheight=&quot;1025&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-089c5280a772f3e7ec7f8295d634b9b6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1377&quot; data-rawheight=&quot;1025&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-089c5280a772f3e7ec7f8295d634b9b6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-089c5280a772f3e7ec7f8295d634b9b6_b.jpg&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;PDpyzTRw&quot;&gt;不对不说，octant 很消耗资源，尤其是对CPU，所以不太建议部署到集群相关的节点。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-faabeaaf4ebaaeeb3734ffa76eccaac3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1167&quot; data-rawheight=&quot;397&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-faabeaaf4ebaaeeb3734ffa76eccaac3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1167&quot; data-rawheight=&quot;397&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-faabeaaf4ebaaeeb3734ffa76eccaac3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-faabeaaf4ebaaeeb3734ffa76eccaac3_b.jpg&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;EgrqbAJW&quot;&gt;关于 octant 和小伙伴分享到这里，安装很简单，赶快去尝试吧。&lt;/p&gt;&lt;h3&gt;博文参考&lt;/h3&gt;&lt;hr/&gt;&lt;p data-pid=&quot;5aldV5-F&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//octant.dev/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;octant.dev/&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-pid=&quot;RcVfvftp&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/vmware-tanzu/octant&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/vmware-tanzu&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/octant&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-pid=&quot;st6qiUNF&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//reference.octant.dev/%3Fpath%3D/story/docs-intro--page&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;reference.octant.dev/?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;path=/story/docs-intro--page&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d2365cdd5ddda546b36cd9832a1fe709</guid>
<title>测试左移之需求质量</title>
<link>https://toutiao.io/k/f9yh0up</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;h2&gt;测试左移的由来&lt;/h2&gt;
&lt;h3&gt;缺陷的修复成本逐步升高&lt;/h3&gt;
&lt;p&gt;下面是质量领域司空见惯的一张图，看图说话，容易得出：大部分缺陷都是早期引入的，同时大部分缺陷都是中晚期发现的，而缺陷发现的越晚，其修复成本就越高。因此，为了降低缺陷修复成本，我们期望在更早的时间发现缺陷。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/02/shift-left-testing-1.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/02/shift-left-testing-1.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么上图是否完全没问题呢？不是的，这张图来源于1996年的一本书《&lt;a href=&quot;https://www.amazon.com/Applied-Software-Measurement-Analysis-Productivity/dp/0071502440&quot;&gt;Applied Software Measurement&lt;/a&gt;》，这张图画成的时候，&lt;a href=&quot;https://insights.thoughtworks.cn/how-many-words-in-agile-manifesto/&quot;&gt;敏捷宣言&lt;/a&gt;还没诞生呢（敏捷宣言诞生于2001年）。在传统背景下，需求是明确且相对固定的，需求产生的缺陷可以忽略不计。同时，在需求阶段产生的问题可能会引起整体方案的返工，因此，需求产生的问题不太会以软件缺陷的形式来体现。&lt;/p&gt;
&lt;h3&gt;需求质量呼唤测试左移&lt;/h3&gt;
&lt;p&gt;随着软件生态的发展，软件需求越来越复杂多变，需求的有效性和传递效率也备受挑战。受大环境影响，需求阶段引入的缺陷就对软件的研发成本造成了影响。同时，软件的研发过程越来越成为一个需要高效协作的整体，各角色之间的界限也变得相对模糊。&lt;/p&gt;
&lt;p&gt;为了让质量理念更早的介入软件研发过程，也为了降低缺陷修复的成本、减少不必要的返工，需求的质量变得尤为重要。&lt;a href=&quot;https://insights.thoughtworks.cn/agile-testing-manifesto/&quot;&gt;测试左移&lt;/a&gt;因此而生，需求分析人员与测试人员需要协同工作，共同保证需求的质量。&lt;/p&gt;
&lt;p&gt;加上需求阶段重画一下上面的图，理想情况下，我们容易得出以下结论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缺陷的引入从需求阶段就开始持续，到研发阶段达到峰值，然后趋于平缓&lt;/li&gt;
&lt;li&gt;缺陷从需求阶段就开始陆续被发现，到测试阶段达到峰值，然后趋于平缓&lt;/li&gt;
&lt;li&gt;从需求阶段到研发初期，缺陷修复的成本极低&lt;/li&gt;
&lt;li&gt;开发后期到上线，缺陷修复成本一路攀升至高点&lt;/li&gt;
&lt;li&gt;缺陷发现的数量少于引入的数量，但在上线前后，缺陷发现数量大于引入数量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/02/shift-left-testing-2.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/02/shift-left-testing-2.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因此，为了获得更经济的资源投入产出比，我们认为应该在需求阶段和编码初期更多的发现缺陷，从而减少修复成本和返工，这也正是测试左移的价值所在。&lt;/p&gt;
&lt;p&gt;那么，该如何保证需求的质量呢？我们在不同的时期面临的需求，其形态是有差异的，所以需要深刻理解这些差异，并有针对性的设计质量活动加以验证。&lt;/p&gt;
&lt;h2&gt;需求的几个层次&lt;/h2&gt;
&lt;h3&gt;一个很现实的例子&lt;/h3&gt;
&lt;p&gt;一天，大老板说：“微信小程序不错，我们内部OA流程得做一个，你们安排一下，年内发布就行。” 这就是一个来自大老板的一句话需求。&lt;/p&gt;
&lt;p&gt;项目经理拿到这个需求，看到“年内发布”，需求管理看板上就可以多一张卡，只有几个字“OA小程序”，排期可能暂时安排在第三季度。&lt;/p&gt;
&lt;p&gt;过了俩月，送走了一批艰难的需求，暂时松口气的项目经理扫到这张卡，瞬间头皮发麻，这还有一个老板亲生的大坑呢，得尽快填上。喊来产品经理，快出一版方案，再找技术经理大致估一下工作量。&lt;/p&gt;
&lt;p&gt;只有一句话显然是没法出方案的，产品经理和技术经理各自焦头烂额的研究了两天，又花了半天暂时碰出了OA小程序的初版方案。一周后，方案通过评审。这时，根据既定方案，产品经理细化了一些需求：用户管理，组织管理，流程管理，表单配置，权限配置，审批配置，微信登录等。&lt;/p&gt;
&lt;p&gt;即将进入研发阶段，需求又会被再次细化。以用户提交请假单的场景为例，需求可被细化如下图。进入研发后，开发以一定的优先级顺序来领取需求进行研发。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/02/shift-left-testing-3.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/02/shift-left-testing-3.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;需求的三种粒度&lt;/h3&gt;
&lt;p&gt;在上面的故事中，为了服务产品规划和不同的管理诉求，需求呈现出以下三个粒度：&lt;/p&gt;
&lt;p&gt;史诗故事 &amp;gt; 特性故事 &amp;gt; 用户故事&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;史诗故事 Epic：粗粒度的描述需求，通常需要多个迭代才能完成，主要用于版本规划时记录和跟踪该功能&lt;/li&gt;
&lt;li&gt;特性故事 Feature：也叫主题故事，是一系列相同主题用户故事的集合，主要用于迭代规划、优先级排序和整体估算&lt;/li&gt;
&lt;li&gt;用户故事 Story：迭代开发的最小单元，是较细粒度的需求描述，主要用于迭代交付过程中的估算、跟踪和管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/02/shift-left-testing-4.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/02/shift-left-testing-4.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;不同粒度需求的质量保障&lt;/h2&gt;
&lt;h3&gt;史诗故事：方案验证 &amp;amp; 测试设计&lt;/h3&gt;
&lt;p&gt;在产品演进过程中，当面临的需求还是一句话时，测试人员能做的事情并不多。当史诗故事即将进入迭代规划，进行方案设计时，测试人员就可以参与进来了。&lt;/p&gt;
&lt;p&gt;方案成型初期，测试人员可以参与方案讨论和技术可行性研究，贡献既有业务流程或潜在业务逻辑，针对有较大质量风险的方案，测试人员有责任提出质疑，并给出建议。&lt;/p&gt;
&lt;p&gt;方案确定后，测试人员就可以着手进行测试设计了，测试设计包括但不限于：针对该功能的质量预期，大致的测试规划，现有的测试资源评估，主要的质量风险及响应方式等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/02/shift-left-testing-5.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/02/shift-left-testing-5.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;特性故事：需求评审 &amp;amp; 测试计划&lt;/h3&gt;
&lt;p&gt;临近迭代，需求会以特性的形式体现，此时测试人员可以参与需求评审：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对功能需求，测试人员先验证需求是否有效，包括需求价值确认，需求涉及场景是否完备，与现有业务逻辑是否有冲突&lt;/li&gt;
&lt;li&gt;针对功能需求背后的支撑性需求进行澄清，确认支撑性需求的范围、验收标准、测试方式等；此外还需要考虑用户体验&lt;/li&gt;
&lt;li&gt;考虑需求的拆分是否合理，是否便于估算和迭代管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;质量活动方面，测试人员可以落实测试计划了，如各种测试活动的安排，测试效果的评价，测试的重点和难点，测试阶段的输入和输出等，在这个阶段都可以确认了。&lt;/p&gt;
&lt;h3&gt;用户故事：需求验收 &amp;amp; 测试执行&lt;/h3&gt;
&lt;p&gt;故事启动时，测试人员需要补充需求验收的用例，以及需求影响范围内的回归用例等。在这以后测试人员主要关注在需求验收和测试执行上，按照测试设计和计划进行测试，确保最终的实现质量。而在此阶段，测试人员尤其需要关注投入产出比，把有限的精力用在刀刃上。行之有效的做法是在测试计划阶段就明确好各功能的质量标准和资源投入，并在测试执行阶段时刻回顾。但计划是死的，人是活的，万一在测试过程中，我们发现计划赶不上变化，就需要随时跟团队沟通并进行灵活调整了。&lt;/p&gt;
&lt;p&gt;当然，质量活动并不是以功能测完上线为结束，而是需要完成一个完整的闭环。测试阶段以后的质量活动不在本文讨论的范围内，在此就不做过多展开了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/02/shift-left-testing-6.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/02/shift-left-testing-6.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;测试左移之所以重要，是因为我们要在缺陷引入的最初阶段就发现它，把缺陷扼杀在摇篮里，而不是等着它像雪球一样越滚越大。而这里的误区在于，测试左移要求的测试活动尽早介入，而不仅仅是把测试人员进行左移。因此，团队里的每个成员，都需要有测试左移的思想，都可以从一开始就绷紧质量这根弦，确保每个人的工件质量。&lt;/p&gt;
&lt;p&gt;而在需求的质量保证活动中，测试人员也需要时不时换帽子，有时可能是终端用户，有时可能是产品经理，也有时可能是产品负责人。不管戴什么帽子，保证各个工件的质量，以及各工件的顺畅集成，都是测试人员可以关注的事。质量相关，我们责无旁贷。&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f738e5628d5c12c93b4215a4b41b7f33</guid>
<title>如何简单理解  Redis 的缓存穿透、击穿和雪崩？</title>
<link>https://toutiao.io/k/430l5ox</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;span class=&quot;RichText ztext CopyrightRichText-richText css-1g0fqss&quot; options=&quot;[object Object]&quot; itemprop=&quot;text&quot;&gt;&lt;blockquote data-first-child=&quot;&quot; data-pid=&quot;2RwyLl_K&quot;&gt;作者：小林coding&lt;br/&gt;来源原创文章：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/cluster/cache_problem.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;什么是缓存雪崩、击穿、穿透？&lt;/a&gt;&lt;/blockquote&gt;&lt;p data-pid=&quot;thA0eXn9&quot;&gt;用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里最慢的硬件了。&lt;/p&gt;&lt;p data-pid=&quot;XQSmlPiC&quot;&gt;当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就奔溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层。&lt;/p&gt;&lt;p data-pid=&quot;WliVI3nB&quot;&gt;因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-dbd36b96694a311dc6a80c030d6f0348_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;377&quot; data-rawheight=&quot;686&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-6600a7c87eef20e8dc7623340a91ae37_720w.jpg?source=1940ef5c&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;377&quot; data-rawheight=&quot;686&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-6600a7c87eef20e8dc7623340a91ae37_720w.jpg?source=1940ef5c&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-dbd36b96694a311dc6a80c030d6f0348_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;Jw6tZN_X&quot;&gt;引入了缓存层，就会有缓存异常的三个问题，分别是&lt;b&gt;缓存雪崩、缓存击穿、缓存穿透&lt;/b&gt;。&lt;/p&gt;&lt;p data-pid=&quot;L69eV4Xw&quot;&gt;这三个问题也是面试中很常考察的问题，我们不光要清楚地知道它们是怎么发生，还需要知道如何解决它们。&lt;/p&gt;&lt;p data-pid=&quot;SyMOl7ed&quot;&gt;话不多说，&lt;b&gt;发车！&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-e6c2599cdcddd5a9ee3e6e66bec512f8_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;527&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-808ca62cc578e2f683f2804fe9dc8d97_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-e6c2599cdcddd5a9ee3e6e66bec512f8_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;527&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-808ca62cc578e2f683f2804fe9dc8d97_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-e6c2599cdcddd5a9ee3e6e66bec512f8_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-e6c2599cdcddd5a9ee3e6e66bec512f8_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/cluster/cache_problem.html%23%25E7%25BC%2593%25E5%25AD%2598%25E9%259B%25AA%25E5%25B4%25A9&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;#&lt;/a&gt;缓存雪崩&lt;/h2&gt;&lt;p data-pid=&quot;t2ik_iPw&quot;&gt;通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-b41ae95e11e7b916edd3298dcef3a060_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;692&quot; data-rawheight=&quot;438&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-8b50d9a80a39047fc23a87a3b6cb5d9b_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-b41ae95e11e7b916edd3298dcef3a060_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;692&quot; data-rawheight=&quot;438&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-8b50d9a80a39047fc23a87a3b6cb5d9b_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-b41ae95e11e7b916edd3298dcef3a060_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-b41ae95e11e7b916edd3298dcef3a060_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;hAmPe5e_&quot;&gt;那么，当&lt;b&gt;大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机&lt;/b&gt;时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是&lt;b&gt;缓存雪崩&lt;/b&gt;的问题。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-a735a6a9a599057515db7731ecdeea1e_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;660&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-e548f6e3a3be30616e3715841e4e5a9d_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-a735a6a9a599057515db7731ecdeea1e_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;660&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-e548f6e3a3be30616e3715841e4e5a9d_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-a735a6a9a599057515db7731ecdeea1e_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-a735a6a9a599057515db7731ecdeea1e_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;I-O4zfGl&quot;&gt;可以看到，发生缓存雪崩有两个原因：&lt;/p&gt;&lt;p data-pid=&quot;sGVQQ_HQ&quot;&gt;不同的诱因，应对的策略也会不同。&lt;/p&gt;&lt;h3&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/cluster/cache_problem.html%23%25E5%25A4%25A7%25E9%2587%258F%25E6%2595%25B0%25E6%258D%25AE%25E5%2590%258C%25E6%2597%25B6%25E8%25BF%2587%25E6%259C%259F&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;#&lt;/a&gt;大量数据同时过期&lt;/h3&gt;&lt;p data-pid=&quot;pB3ATzeo&quot;&gt;针对大量数据同时过期而引发的缓存雪崩问题，常见的应对方法有下面这几种：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;VJjyPHwl&quot;&gt;均匀设置过期时间；&lt;/li&gt;&lt;li data-pid=&quot;pnrpXiFz&quot;&gt;互斥锁；&lt;/li&gt;&lt;li data-pid=&quot;eTRiXBUz&quot;&gt;双 key 策略；&lt;/li&gt;&lt;li data-pid=&quot;vE7xSJh3&quot;&gt;后台更新缓存；&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;BneFlCW7&quot;&gt;&lt;i&gt;1. 均匀设置过期时间&lt;/i&gt;&lt;/p&gt;&lt;p data-pid=&quot;DbgIypjr&quot;&gt;如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，&lt;b&gt;给这些数据的过期时间加上一个随机数&lt;/b&gt;，这样就保证数据不会在同一时间过期。&lt;/p&gt;&lt;p data-pid=&quot;t1vj3dqc&quot;&gt;&lt;i&gt;2. 互斥锁&lt;/i&gt;&lt;/p&gt;&lt;p data-pid=&quot;_L4hpQtr&quot;&gt;当业务线程在处理用户请求时，&lt;b&gt;如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存&lt;/b&gt;（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。&lt;/p&gt;&lt;p data-pid=&quot;gzOzF2HN&quot;&gt;实现互斥锁的时候，最好设置&lt;b&gt;超时时间&lt;/b&gt;，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。&lt;/p&gt;&lt;p data-pid=&quot;-sbmE_25&quot;&gt;&lt;i&gt;3. 双 key 策略&lt;/i&gt;&lt;/p&gt;&lt;p data-pid=&quot;UASjcIpg&quot;&gt;我们对缓存数据可以使用两个 key，一个是&lt;b&gt;主 key，会设置过期时间&lt;/b&gt;，一个是&lt;b&gt;备 key，不会设置过期&lt;/b&gt;，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。&lt;/p&gt;&lt;p data-pid=&quot;MbFdV4Z8&quot;&gt;当业务线程访问不到「主 key 」的缓存数据时，就直接返回「备 key 」的缓存数据，然后在更新缓存的时候，&lt;b&gt;同时更新「主 key 」和「备 key 」的数据。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;R5PNJiuA&quot;&gt;&lt;i&gt;4. 后台更新缓存&lt;/i&gt;&lt;/p&gt;&lt;p data-pid=&quot;BLayIES2&quot;&gt;业务线程不再负责更新缓存，缓存也不设置有效期，而是&lt;b&gt;让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新&lt;/b&gt;。&lt;/p&gt;&lt;p data-pid=&quot;L06RiMTi&quot;&gt;事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为&lt;b&gt;当系统内存紧张的时候，有些缓存数据会被“淘汰”&lt;/b&gt;，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。&lt;/p&gt;&lt;p data-pid=&quot;AcDEBcHI&quot;&gt;解决上面的问题的方式有两种。&lt;/p&gt;&lt;p data-pid=&quot;wKpIoBcM&quot;&gt;第一种方式，后台线程不仅负责定时更新缓存，而且也负责&lt;b&gt;频繁地检测缓存是否有效&lt;/b&gt;，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。&lt;/p&gt;&lt;p data-pid=&quot;EVCMufrL&quot;&gt;这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。&lt;/p&gt;&lt;p data-pid=&quot;Nhq1QY2n&quot;&gt;第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），&lt;b&gt;通过消息队列发送一条消息通知后台线程更新缓存&lt;/b&gt;，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。&lt;/p&gt;&lt;p data-pid=&quot;fFZ-ljMf&quot;&gt;在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的&lt;b&gt;缓存预热&lt;/b&gt;，后台更新缓存的机制刚好也适合干这个事情。&lt;/p&gt;&lt;h3&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/cluster/cache_problem.html%23redis-%25E6%2595%2585%25E9%259A%259C%25E5%25AE%2595%25E6%259C%25BA&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;#&lt;/a&gt;Redis 故障宕机&lt;/h3&gt;&lt;p data-pid=&quot;WMZ8TvtP&quot;&gt;针对 Redis 故障宕机而引发的缓存雪崩问题，常见的应对方法有下面这几种：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;JAuGca3C&quot;&gt;服务熔断或请求限流机制；&lt;/li&gt;&lt;li data-pid=&quot;zPZM6PiY&quot;&gt;构建 Redis 缓存高可靠集群；&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;MQVsYjJ4&quot;&gt;&lt;i&gt;1. 服务熔断或请求限流机制&lt;/i&gt;&lt;/p&gt;&lt;p data-pid=&quot;HXhu9d-u&quot;&gt;因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动&lt;b&gt;服务熔断&lt;/b&gt;机制，&lt;b&gt;暂停业务应用对缓存服务的访问，直接返回错误&lt;/b&gt;，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。&lt;/p&gt;&lt;p data-pid=&quot;d5HTg4ux&quot;&gt;服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作&lt;/p&gt;&lt;p data-pid=&quot;U_Z6kkw5&quot;&gt;为了减少对业务的影响，我们可以启用&lt;b&gt;请求限流&lt;/b&gt;机制，&lt;b&gt;只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务&lt;/b&gt;，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。&lt;/p&gt;&lt;p data-pid=&quot;YU-QOQdg&quot;&gt;&lt;i&gt;2. 构建 Redis 缓存高可靠集群&lt;/i&gt;&lt;/p&gt;&lt;p data-pid=&quot;yve4FRvj&quot;&gt;服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过&lt;b&gt;主从节点的方式构建 Redis 缓存高可靠集群&lt;/b&gt;。&lt;/p&gt;&lt;p data-pid=&quot;QGdHkPHt&quot;&gt;如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/cluster/cache_problem.html%23%25E7%25BC%2593%25E5%25AD%2598%25E5%2587%25BB%25E7%25A9%25BF&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;#&lt;/a&gt;缓存击穿&lt;/h2&gt;&lt;p data-pid=&quot;QreneL7O&quot;&gt;我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。&lt;/p&gt;&lt;p data-pid=&quot;TsuePx4P&quot;&gt;如果缓存中的&lt;b&gt;某个热点数据过期&lt;/b&gt;了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是&lt;b&gt;缓存击穿&lt;/b&gt;的问题。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pica.zhimg.com/50/v2-3e230c327a90289676767efd9a573d4f_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;707&quot; data-rawheight=&quot;836&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-2db086f310e20a06d3495812a7fe0a6e_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-3e230c327a90289676767efd9a573d4f_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;707&quot; data-rawheight=&quot;836&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-2db086f310e20a06d3495812a7fe0a6e_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-3e230c327a90289676767efd9a573d4f_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pica.zhimg.com/50/v2-3e230c327a90289676767efd9a573d4f_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;_-1HmdRu&quot;&gt;可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。&lt;/p&gt;&lt;p data-pid=&quot;gq7F93BF&quot;&gt;应对缓存击穿可以采取前面说到两种方案：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;DmZciOpG&quot;&gt;互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。&lt;/li&gt;&lt;li data-pid=&quot;Y-pQ_FUU&quot;&gt;不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h2&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/cluster/cache_problem.html%23%25E7%25BC%2593%25E5%25AD%2598%25E7%25A9%25BF%25E9%2580%258F&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;#&lt;/a&gt;缓存穿透&lt;/h2&gt;&lt;p data-pid=&quot;Cj-JsZMP&quot;&gt;当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。&lt;/p&gt;&lt;p data-pid=&quot;Qv5Cw49E&quot;&gt;当用户访问的数据，&lt;b&gt;既不在缓存中，也不在数据库中&lt;/b&gt;，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是&lt;b&gt;缓存穿透&lt;/b&gt;的问题。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-4fcfdb8a60dce0d6e99792261afeab14_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;576&quot; data-rawheight=&quot;836&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-7b8922a464f761d4497feb375da7828c_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-4fcfdb8a60dce0d6e99792261afeab14_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;576&quot; data-rawheight=&quot;836&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-7b8922a464f761d4497feb375da7828c_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-4fcfdb8a60dce0d6e99792261afeab14_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-4fcfdb8a60dce0d6e99792261afeab14_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;xKr_Sznb&quot;&gt;缓存穿透的发生一般有这两种情况：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;3hF-RyTG&quot;&gt;业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；&lt;/li&gt;&lt;li data-pid=&quot;cRKywy2m&quot;&gt;黑客恶意攻击，故意大量访问某些读取不存在数据的业务；&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;RjCqSuoC&quot;&gt;应对缓存穿透的方案，常见的方案有三种。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;P_f-luuQ&quot;&gt;第一种方案，非法请求的限制；&lt;/li&gt;&lt;li data-pid=&quot;dMOmPQYK&quot;&gt;第二种方案，缓存空值或者默认值；&lt;/li&gt;&lt;li data-pid=&quot;BszX0vWG&quot;&gt;第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;VAFp_xfT&quot;&gt;第一种方案，非法请求的限制&lt;/p&gt;&lt;p data-pid=&quot;pzTvx17M&quot;&gt;当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。&lt;/p&gt;&lt;p data-pid=&quot;xtQn4qTA&quot;&gt;第二种方案，缓存空值或者默认值&lt;/p&gt;&lt;p data-pid=&quot;0VdNGHGD&quot;&gt;当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。&lt;/p&gt;&lt;p data-pid=&quot;colYt8VW&quot;&gt;&lt;i&gt;第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。&lt;/i&gt;&lt;/p&gt;&lt;p data-pid=&quot;HcEtA3ac&quot;&gt;我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。&lt;/p&gt;&lt;p data-pid=&quot;tG5t4Bkp&quot;&gt;即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。&lt;/p&gt;&lt;p data-pid=&quot;c97RKmIt&quot;&gt;那问题来了，布隆过滤器是如何工作的呢？接下来，我介绍下。&lt;/p&gt;&lt;p data-pid=&quot;4ZuXvxTz&quot;&gt;布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。&lt;/p&gt;&lt;p data-pid=&quot;C7tfYke6&quot;&gt;布隆过滤器会通过 3 个操作完成标记：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;DvzsP3cw&quot;&gt;第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；&lt;/li&gt;&lt;li data-pid=&quot;h78SDH6G&quot;&gt;第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。&lt;/li&gt;&lt;li data-pid=&quot;P7HV2M0b&quot;&gt;第三步，将每个哈希值在位图数组的对应位置的值设置为 1；&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;pJ_Q0WgZ&quot;&gt;举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-32058be7324f355398304501c433125b_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;977&quot; data-rawheight=&quot;287&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-2cf00fa9d6c7abf2dc9027daeb15b6de_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-32058be7324f355398304501c433125b_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;977&quot; data-rawheight=&quot;287&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-2cf00fa9d6c7abf2dc9027daeb15b6de_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-32058be7324f355398304501c433125b_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-32058be7324f355398304501c433125b_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;0dHpojEQ&quot;&gt;在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。&lt;b&gt;当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中&lt;/b&gt;。&lt;/p&gt;&lt;p data-pid=&quot;r9nsuJ8I&quot;&gt;布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时&lt;b&gt;存在哈希冲突的可能性&lt;/b&gt;，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。&lt;/p&gt;&lt;p data-pid=&quot;NxGeEAne&quot;&gt;所以，&lt;b&gt;查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据&lt;/b&gt;。&lt;/p&gt;&lt;hr/&gt;&lt;p data-pid=&quot;NPP8p3X_&quot;&gt;缓存异常会面临的三个问题：缓存雪崩、击穿和穿透。&lt;/p&gt;&lt;p data-pid=&quot;-fkOowh7&quot;&gt;其中，缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。因此，缓存雪崩和缓存击穿应对的方案比较类似。&lt;/p&gt;&lt;p data-pid=&quot;ta9SzQUx&quot;&gt;而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。&lt;/p&gt;&lt;p data-pid=&quot;G6fbBkbZ&quot;&gt;我这里整理了表格，你可以从下面这张表格很好的知道缓存雪崩、击穿和穿透的区别以及应对方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-6fc868db09db5b408204f64f88705296_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;622&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-908a812f5953fd8f7c0d495f33a61361_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pica.zhimg.com/v2-6fc868db09db5b408204f64f88705296_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;622&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-908a812f5953fd8f7c0d495f33a61361_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pica.zhimg.com/v2-6fc868db09db5b408204f64f88705296_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-6fc868db09db5b408204f64f88705296_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;-b5ilCjC&quot;&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-b059f82b3aa851a0a40d14d15713d5ee_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2828&quot; data-rawheight=&quot;1442&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-b059f82b3aa851a0a40d14d15713d5ee_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2828&quot; data-rawheight=&quot;1442&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-b059f82b3aa851a0a40d14d15713d5ee_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-b059f82b3aa851a0a40d14d15713d5ee_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;G250TOPo&quot;&gt;&lt;b&gt;数据类型篇&lt;/b&gt;&lt;/p&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>