<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>74320b1392b88ba40f06523095e56e74</guid>
<title>解读Go语言的2022：泛型时代开启</title>
<link>https://toutiao.io/k/sk10uze</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;作者 | 郝林&lt;/section&gt;&lt;section&gt;
编辑 | 蔡芳芳&lt;/section&gt;&lt;section&gt;
本文是 “2022 InfoQ 年度技术盘点与展望” 系列文章之一，由 InfoQ 编辑部制作呈现，重点聚焦 Go 语言在 2022 年的重要进展、动态，希望能帮助你准确把握 2022 年 Go 语言的核心发展脉络，在行业内始终保持足够的技术敏锐度。&lt;br/&gt;&lt;br/&gt;“InfoQ 年度技术盘点与展望”是 InfoQ 全年最重要的内容选题之一，将涵盖操作系统、数据库、AI、大数据、云原生、架构、大前端、编程语言、开源安全、数字化十大方向，后续将聚合延展成专题、迷你书、直播周、合集页面，在 InfoQ 媒体矩阵陆续放出，欢迎大家持续关注。&lt;/section&gt;&lt;p&gt;之所以在这样一篇年度解读文章的标题直接提到“泛型”，是因为 Go 语言的泛型在 2022 年终于浮出了水面！并且，它在功能方面已经大致完整了。圈内的开发者们都知道，这是 Go 社区（当然包括中国的 Go 社区）多年请愿的结果。&lt;/p&gt;&lt;p&gt;虽然 Go 语言是 Google 公司出品并主导开发的，但它毫无疑问也是广大 Go 语言爱好者的心头肉。可以说，对于 Go 语言泛型的正式登场，至少有一半功劳属于 Go 语言的爱好者们。&lt;/p&gt;&lt;p&gt;肯定会有一些程序员，尤其是那些不以 Go 为主要语言的程序员会说“Go 语言的进展太慢了，其他众多新的编程语言甚至那些较老的编程语言早就支持泛型了，可 Go 语言墨迹了这么多年才搞出泛型”。确实，单就泛型这方面来说，Go 语言的脚步确实很慢，可这主要是因为 Go 语言想要做到完全向后兼容，并力求让 Go 语言的泛型完美契合其自身的精炼的编程哲学和简约的编码风格。要知道，做加法容易，而做减法却很难。不过不管怎样，Go 语言的泛型终于落地了！就连现如今清心寡欲的作者也忍不住心中的喜悦！&lt;/p&gt;&lt;p&gt;好了，感慨完毕，我们还是回归正题吧。下面，我们就一起从头至尾捋一捋 Go 语言在 2022 年的发展和变化，以及它将会在 2023 年如何继续前行。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;趋势概览&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;Go 在今年的 11 月 10 日刚满 13 岁。它已经长大并进入了少年期，不算是一门新的编程语言了。但 Go 依然保持着非常好地向后兼容。很显然，这是一件很不容易的事。&lt;/p&gt;&lt;p&gt;从业界知名的编程语言排行榜 TIOBE Index 绘制的折线图来看，Go 语言的采用趋势在过去三年间基本上保持平稳。&lt;/p&gt;&lt;p&gt;更具体地说，根据使用情况统计，在 2020 年下半年到 2021 年上半年的这段时间里，Go 语言的使用率有略微提升，但时至今日又差不多回到了 2019 年的水平。与其在 2016 年到 2017 年间的大爆发相比，如今 Go 语言的使用率已经基本上稳定下来了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.49140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNJgWST10lQjibpfzuVmOCybVTalKF7lbgbGhnicSGqQBMzD1Te2MgJfqNMCKhr6msfMk7Hw8lcfX0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 1 - TIOBE Index 之 Go 语言趋势&lt;/span&gt;&lt;/p&gt;&lt;p&gt;不过，就作者个人而言，感觉是有些奇怪的。按理说，Go 语言泛型的落地应该能够引起一波采用 Go 语言的小高潮，但事实上这一情况并没有出现。这可能就是“波澜不惊”的最佳诠释吧？可能因为大家都等得太久了，真到了重大的新特性来临之时却不太能兴奋得起来了。&lt;/p&gt;&lt;p&gt;当然了，这也可能是因为 Go 语言在应用领域方面的攻城掠地已经基本完成，而且在其优势领域的使用率已经趋于饱和。而对于那些新兴领域，比如机器学习、人工智能、机器人、元宇宙等，Go 语言还没有显著的优势，尤其是还没有杀手级框架或工具出现。在这种情况下，Go 语言在使用统计上的平稳趋势也是一种必然。&lt;/p&gt;&lt;p&gt;现在换一个维度，我们横向来看，Go 语言的排名相较于前两年有比较明显的提升。如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5114263199369582&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNJgWST10lQjibpfzuVmOCybYYuIrmibP7BZeHB5VfITAgqKIqoibPb0a1KkibFW5jx3rxvI8BkQPzAHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1269&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 2 - TIOBE Index（2022 年 11 月）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们可以看到，Go 语言在 2021 年年底的 TIOBE Index 排名中位于第 18 位。这低于它在 2020 年年底的排名（第 16 位），以及它在 2019 年年底的排名（第 15 位），也算是一个小谷底了。然而，在今年的年底，Go 语言的排名却大幅提升了，甚至，它已经摸到了 Top10 的边界！如果作者没记错的话，Go 语言最近一次进入 Top10 是在 2018 年的年底。如今，4 年过去了，Go 语言终于又有希望重回 Top10 了。&lt;/p&gt;&lt;p&gt;我们还可以看到，至今常年占据 Top10 的依然是那些老生常谈，甚至是那些老得不能再老的编程语言。相比之下，Go 语言真真切切算是年轻一派的优秀编程语言了。当然，除了 Go 语言之外，还有图形化的儿童编程语言 Scratch、Apple 公司出品的编程语言 Swift，以及近年来出尽风头的系统级编程语言 Rust。它们都很年轻，却都已经进入了 Top20，也是非常优秀的。作者也很看好它们。&lt;/p&gt;&lt;p&gt;在简单分析了 Go 语言在 TIOBE Index 中的排名之后，我们再来看看新晋出炉的 StackOverflow Developer Survey 2022 吧。众所周知，StackOverflow 是全球最大的编程社区和专业问答网站。它的 Developer Survey 报告属于年度总结性报告，已经有好多年的历史了，并且深受全球软件开发者的关注和喜爱。&lt;/p&gt;&lt;p&gt;我们下面重点说说其中与 Go 语言强相关的内容。至于其他的内容，大家如果有兴趣的话，可以点开前面的超链接仔细阅读完整报告。&lt;/p&gt;&lt;p&gt;在“使用率最高的编程语言（专业组）”这一栏中，Go 语言的排名是第 13 位（如下图）。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7665615141955836&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNJgWST10lQjibpfzuVmOCybVAStHzGbGQibINFxGmd0ibEGVuMDPcGDUtibEN0n7hYH5TMOLDMhF3Nnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 3 – Stackoverflow Developer Survey 2022 之使用率最高的编程语言（专业组）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果只考虑通用的跨平台编程语言的话，Go 语言仅次于 Python、Java、C++ 和 C。这与它在 TIOBE Index 中的情况是相同的。有的程序员可能会说“JavaScript 和 TypeScript 现如今也可以算是通用的跨平台编程语言”。当然，从某种角度看，我们可以这样说。但是，它们终归不是原生的通用编程语言，都需要额外的工具或框架才能够实现“通用”。因此，我们稍微严格一点，暂且不把它们计算在内。&lt;/p&gt;&lt;p&gt;在应用级框架和工具栏目中，作者发现 Docker 和 Kubernetes 今年依然非常火爆。作为常用的基础工具，它们深受广大软件开发者的追捧。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3438485804416404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNJgWST10lQjibpfzuVmOCybQ3HmPzicVr4v66jmybSic6zYrIAcMDHv50RBP4QpJYrRLwPsZBY2dXpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 4 – Stackoverflow Developer Survey 2022 之最受欢迎的基础工具（全体组）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从上面这幅截图我们可以看出，Docker 和 Kubernetes 在当前的排名中都已经进入了 Top5。甚至，如果只考虑专业的软件开发者的话，Docker 甚至超越了 npm，拔得头筹！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3509463722397476&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNJgWST10lQjibpfzuVmOCyb8749SyOwFHnQvjzHh1ZyBNr8lYfvAgGz9hUuaJzD6v3GdMOzGUYDxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 5 – Stackoverflow Developer Survey 2022 之最受欢迎的基础工具（专业组）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;毫无疑问，npm 是 JavaScript 世界中 Top1 的工具，其应用是相当相当广泛的。更何况，在全世界的软件开发者当中，不论是专业的开发者还是业余的开发者，使用 JavaScript 语言的人都是最多的。所以，Docker 能够超越它真的是一件非常值得骄傲的事！&lt;/p&gt;&lt;p&gt;大家应该都知道，Docker 和 Kubernetes 都是使用 Go 语言开发出来的。在云计算领域，尤其是容器技术领域，它们都是绝对的王者！因此，如果你想进入云计算领域，或者想使用 Go 语言开发基于云的应用程序，那么最起码应该学会甚至熟练使用 Docker。&lt;/p&gt;&lt;p&gt;好啦，以上算是一个令人激动的小插曲。现在，让我们把焦点再转回到编程语言的排名上来。&lt;/p&gt;&lt;p&gt;在 Stackoverflow Developer Survey 的报告中，有一个非常有特色的栏目。我们经常戏称它为“爱恨交织”栏目，其原名是“Most loved, dreaded, and wanted”。&lt;/p&gt;&lt;p&gt;在这个栏目里，共有七万一千多名开发者回答了相应的问题。在他们当中，有 64.58% 的人喜爱 Go 语言，而有另外的 35.43% 的人憎恨 Go 语言（或者说对 Go 语言有恐惧感）。在所有为大众所熟知的编程语言当中，Go 语言排在了第 8 位。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5023696682464455&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNJgWST10lQjibpfzuVmOCybFMSJyVt7QApx0Q0K3dnRk4iaz04zPOMPwPdb1WTV9SG8FiaicSFvcsfHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 6 – Stackoverflow Developer Survey 2022 之让人“爱恨交织”的编程语言&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在这份排名中的 Rust、TypeScript 和 Julia 作为更加年轻的编程语言后来居上。不过，如果我们查看相邻的“最想学习的编程语言”排名的话，就会发现 Go 语言的位置靠前了很多，处于第 4 位，仅次于 Rust、Python 和 TypeScript，并且从百分比数值上来看相差无几。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.556872037914692&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNJgWST10lQjibpfzuVmOCybeu5CribyMOjs4yyIhicrNeKumyjkpzp5YoAmiclAQWiadDnwULHY07ibu3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 7 – Stackoverflow Developer Survey 2022 之大家最想学习的编程语言&lt;/span&gt;&lt;/p&gt;&lt;p&gt;看起来，程序员们应该都很喜欢追新，不是吗？这起码与作者的所见所闻是比较吻合的。当然了，只有那些优秀的新兴编程语言才有进入 Top10 的机会。&lt;/p&gt;&lt;p&gt;可以想象，Docker 和 Kubernetes 在这个“爱恨交织”栏目中肯定是名列前茅的。事实也确实如此，它们分列“Loved vs. Dreaded”一栏中的前两位。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5272296764009471&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNJgWST10lQjibpfzuVmOCybFhp3RBLMpX7nm9TIfKg1E3mrpJzleT39BRXMP91phOnzGlMDSjh58g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 8 – Stackoverflow Developer Survey 2022 之让人“爱恨交织”的基础工具&lt;/span&gt;&lt;/p&gt;&lt;p&gt;而且，在“Want”一栏，它们拥有着一骑绝尘的态势。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5602836879432624&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNJgWST10lQjibpfzuVmOCybe8KsHchrafHRibnREbfUD8Gia1JjxnIJfibyTqE4jHWTmgicicibgKcb7tkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1269&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 9 – Stackoverflow Developer Survey 2022 之大家最想学习的基础工具&lt;/span&gt;&lt;/p&gt;&lt;p&gt;顺便说一句，在“爱恨交织”栏目里，同样拥有“一骑绝尘”态势的还有 Visual Studio Code（以下简称 VSCode）。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5603788476716653&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNJgWST10lQjibpfzuVmOCyb1AnBDDZhKjQ3G8ibzID1fvHPOuNJDsKB8hAwJAQhSKiaVMhNI5cd8FDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 10 – Stackoverflow Developer Survey 2022 之大家最想学习的集成开发环境&lt;/span&gt;&lt;/p&gt;&lt;p&gt;作者为什么会在这里提到 VSCode 呢？因为，在 2022 年订阅我的技术专栏的读者当中，非 gopher（gopher 的意思是 Go 语言粉丝）的人明显增多。他们问的最多的一个问题就是：“要是使用 Go 语言开发程序的话，有哪些好用的代码编辑器或者 IDE 吗？”&lt;/p&gt;&lt;p&gt;我的回答一般都是 VSCode 和 GoLand。&lt;/p&gt;&lt;p&gt;微软公司出品的 VSCode 是 Go 语言爱好者最常用的免费代码编辑器。我们使用它时，外加 Go 语言官方团队出品的 vscode-go 插件就基本上可以满足平常的需求了。&lt;/p&gt;&lt;p&gt;而 GoLand 是 JetBrains 公司出品的，但它收费而且价格不菲。作者在这里绝不是给 JetBrains 公司做广告，但是 GoLand 真的很贵、很好用。如果你对于配置编程工具非常不耐烦，并且预算很充足的话，那么我会强烈推荐你使用 GoLand。&lt;/p&gt;&lt;p&gt;顺便说一句，如果你是 Vim 那一派的话，Go 社区中也有相应的 vim-go 插件。&lt;/p&gt;&lt;p&gt;好了，关于 Go 语言发展趋势的整体解读，我们就暂告一段落吧。下面，我们从更新迭代的角度来看看 Go 语言在 2022 年都有哪些进展。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;年度回顾&lt;/span&gt;
&lt;/section&gt;&lt;section&gt;
&lt;span&gt;2.1 支持泛型&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;Go 语言在 2022 年最大的变化莫过于添加了对泛型（generics）的支持。这对于 Go 语言的广大使用者来说，也是感受最明显的变化。&lt;/p&gt;&lt;p&gt;早在 2022 年 2 月正式发布的 1.18 版本，Go 语言就包含了类型参数提案（即 Type Parameters Proposal）中描述的通用功能的实现。这包括了需要对 Go 语言本身进行的主要的更改。注意，这些更改是完全向后兼容的。这也是 Go 语言官方对于 Go 1.x 版本更新的一贯原则和保证。&lt;/p&gt;&lt;p&gt;Go 语言官方团队为此编写和修改了大量的代码。虽然这些代码并未经过超大规模的验证，但是 Go 语言团队对它们的质量和功效是非常有信心的。不过，也不排除这种可能：一些使用泛型的代码适用于 1.18 版本，但在以后的版本中会变得无效，或者说需要稍加修改才能使其有效。因为，这次为了支持泛型的改动实在是太大了。按照 Go 官方的说法，这种不完全兼容的可能性会被尽可能减小，但是无法对此做出 100% 保证。&lt;/p&gt;&lt;p&gt;虽然我们都喜欢 100% 确定的东西，但是万事万物都不可能有 100% 的稳定性和可预测性。尤其是，对软件开发有一定理解的朋友们肯定都知道，没有哪一个软件是没有 bug 的，也没有哪一个软件功能可以保证 100% 的正确。所以，我们需要用更加宽容的心态来看待 Go 语言的这次超大级别的更新。&lt;/p&gt;&lt;p&gt;实际上我们也不用太过担心。因为从 Go 语言的 issue 列表上看，泛型相关的 bug 如今也已经发现和修复得差不多了。Go 语言的泛型已经趋于稳定，我们已经可以放心地将其用在生产级代码上了。&lt;/p&gt;&lt;p&gt;从语法上说，Go 语言的类型参数（可以理解为“泛型”的另一种称谓）并未使用那个在其他编程语言中常见的尖括号（即“&amp;lt;”和“&amp;gt;”），而用的是方括号（即“[”和“]”）。这也是程序员们感受的最大一点不同。&lt;/p&gt;&lt;p&gt;请注意，我们在这里所说的“对泛型的支持”实际上是“对自定义泛型的支持”。因为 Go 语言内置的一些数据类型从一开始就是支持泛型的，比如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; map1 = &lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;或者&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; slice1 = []&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;然而，在 Go 1.18 之前，使用者们自己编写的函数或者类型是无法添加泛型定义的。&lt;/p&gt;&lt;p&gt;下面重点来了。在 Go 1.18 中，对泛型的具体支持都有哪些呢？请看下文。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
1. 自定义的函数声明或类型声明都可以包含类型参数。&lt;/section&gt;&lt;p&gt;请看如下代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type Pair[K ~&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;, E ~&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;] &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Key  K    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Elem E&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;所谓的类型参数声明，其实就是对一个类型所涉及到的关联类型的泛化定义。例如，对于结构体类型中的每个字段，我们都必须分别定义其类型。这些字段的类型就是它们所属的结构体类型的关联类型。&lt;/p&gt;&lt;p&gt;这里的泛化定义的意思是，我们在声明一个类型的时候，并不指定它的关联类型具体是哪一个或哪几个，而只定义相应的范围。等到这个类型被实例化的时候，再由那个编写实例化代码的程序员去设定类型参数的具体信息。这样的话，我们就可以定义出更加抽象的类型，而把具体化的工作留给使用它的人。&lt;/p&gt;&lt;p&gt;这与“声明接口类型，并把其作为某些函数参数或变量的类型”的编程手法有着异曲同工之妙，都是为了提升代码的灵活性，并增强其扩展的能力。不过需要注意的是，类型参数的值与函数参数的值或变量的值是不同的。一个类型参数的值必须是代表了某个已存在类型的标识符（或者说类型字面量）。另外，类型参数值代表的既可以是结构体这样的具体类型，也可以是接口那样的抽象类型。而函数参数或变量的值，则必须是某个具体类型的确切值。&lt;/p&gt;&lt;p&gt;另一方面，Go 语言的类型参数声明与它的函数参数声明是类似的。在上述代码的方括号中，K 和 E 分别是两个类型参数的标识符，类似于函数参数的名称。而～int 和～string 则分别是两个类型参数的类型约束（type constraint），类似于函数参数的类型声明。至于在 int 和 string 的前面为什么会有“～”这个符号，我们稍后再说。&lt;/p&gt;&lt;p&gt;正因为结构体类型 Pair 的声明里包含了类型参数 K 和 E 的声明，所以在它的主体当中，我们自然可以自由地使用 K 和 E。如代码所示，我们把 Pair 的字段 Key 的类型声明为 K，并把字段 Elem 的类型声明为 E。这样一来，Pair 的类型参数就与其主体实现了联动。这种联动将会在我们对 Pair 类型进行实例化的时候得以体现。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
2. 对于带有类型参数的函数或类型，可以通过在它们的名称后面追加方括号并指定相应的类型参数值来进行实例化。&lt;/section&gt;&lt;p&gt;示例如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; pair1 Pair[&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;] = Pair[&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;]{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Key: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Elem: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;我们在这里声明了一个 Pair[int, string] 类型的变量 pair1，并把一个 Pair[int, string] 类型的值赋给了它。请注意，我们在对一个带有类型参数的类型进行实例化的时候，也必须对它的类型参数进行实例化。在这里，Pair[int, string] 中的 int 和 string 就是分别对 Pair 的类型参数 K 和 E 的实例化。&lt;/p&gt;&lt;p&gt;还记得吗？我们当初在声明 Pair 类型的时候，把它的类型参数列表编写成 [K ~int, E ~string]。其中，~int 是类型参数 K 的类型约束，而~string 则是类型参数 E 的类型约束。那么，这里的 Pair[int, string] 中的 int 和 string，分别作为 K 和 E 的值就是合法的，可以通过编译。至于为什么，我们马上就会说到。&lt;/p&gt;&lt;p&gt;先接着看其余的代码。因为在 Pair 类型的声明当中，字段 Key 的类型声明是 K，字段 Elem 的类型声明是 E。所以，在实例化 Pair[int, string] 的时候，我们自然就可以把某个 int 类型的值（这里是 1）赋给 Key，并把某个 string 类型的值（这里是&quot;a&quot;）赋给 Elem。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
3. 新符号“~”已被添加到了运算符和标点符号的集合中。&lt;/section&gt;&lt;p&gt;我们再看 Pair 类型的声明：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type Pair[K ~&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;, E ~&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;] &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Key  K    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Elem E&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;我们大可以把这里的符号“～”理解为“潜在”。代码“K ~int”的意思是，只要一个类型（假定为 A）的潜在类型是 int，那么就可以满足我们在这段代码中对 K 所做的类型约束，这就意味着 A 类型的字面量可以作为类型参数 K 的值。同样的道理，代码“E ~string”的意思是，只要一个类型（假定为 B）的潜在类型是 string，那么就可以满足我们在这段代码中对 E 所做的类型约束，这就意味着 B 类型的字面量可以作为类型参数 E 的值。也正因为如此，类型 Pair[int, string] 才是合乎语法规则的，它的类型参数都已通过了有效的实例化。&lt;/p&gt;&lt;p&gt;至于什么是“潜在类型”，Go 语言规范对此有明确的解释。具体内容是：每个类型 T 都有一个潜在类型。如果 T 是 Go 语言内置的布尔类型、数字类型、字符串类型之一，或者是某个类型字面量，那么相应的潜在类型就是 T 本身。否则，T 的潜在类型就是 T 在其声明中引用的类型的潜在类型。&lt;/p&gt;&lt;p&gt;下面举个例子。如果我们又编写了如下代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; MyInt &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; MyStr &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;那么，对于当前的 Pair 类型声明来说，下面的代码也是合法的：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;pair2 Pair[MyInt, MyStr] = Pair[MyInt, MyStr]{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;Key&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;2,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;Elem&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;b&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;更确切的说，类型 Pair[MyInt, MyStr] 是合乎语法规则的。因为，从前面的说明和代码可知，MyInt 的潜在类型是 int，而 MyStr 的潜在类型是 string。它们分别符合 Pair 类型的声明里对类型参数 K 和 E 的定义。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
4. 接口类型的声明中现已允许嵌入任意类型，以及由符号“｜”联结的联合类型和由~T 代表的类型元素，而不只是之前允许的其他接口类型。不过，这样的接口只能用于泛型中的类型约束。&lt;/section&gt;&lt;p&gt;这段话是什么意思呢？我们来详细解析一下。&lt;/p&gt;&lt;p&gt;为了配合 Go 语言对泛型的支持，官方团队对接口类型的声明语法做了很多的增强。&lt;/p&gt;&lt;p&gt;使用 Go 语言的程序员们都知道，以前的接口声明只能像下面这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type Reader &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Read(p []&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;) (n &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;或者这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; ReadCloser &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Reader &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Close() error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;也就是说，在接口类型声明的主体中，我们可以嵌入任意数量的非重复的方法声明，也可以嵌入任何其他非重复的接口类型（用接口名称来代表）。我们称这两者为合法的接口元素。但除此之外，我们就不能添加任何东西了。&lt;/p&gt;&lt;p&gt;然而，从 Go 1.18 开始，合法的接口元素又多了一种。Go 官方把这种接口元素称为类型集合（type set）。&lt;/p&gt;&lt;p&gt;一个类型集合可以仅包含单独的类型（由类型的名称代表，如：T），也可以包含代表了某个潜在类型的～T，还可以是联合类型（如：T1｜T2｜T3，其中的符号“｜”可以被理解为“并集”），甚至可以是它们的混合（如：T1｜～T2｜～T3）。而且，对此我们可以分多行来写，只要它们所代表的类型是具体的且不存在重复即可。&lt;/p&gt;&lt;p&gt;不过要注意，包含了类型集合的接口类型只能被用在泛型相关的类型约束当中。例如，有如下代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; FloatUnion &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; ~float32 | ~float64&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; FloatMaker &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; FloatUnion&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; MakeZero()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;可以看到，含有类型集合的接口 FloatUnion 是可以被嵌入到其他接口类型的声明里面的（或者说，其他的接口类型可以扩展 FloatUnion 接口）。但如此一来，不但 FloatUnion 接口不能被用作任何值、变量、字段、参数、结果的类型，而且 FloatMaker 接口也会是这样。换句话说，对这种接口的用途限制具有传递性。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
5. 新的内置标识符 any 是空接口的别名。它可以代替 interface{}。&lt;/section&gt;&lt;p&gt;这一条说得很直白。单词 any 现在属于关键字了。它代表了空接口，也就是 interface{}。但是，空接口本身的含义却因泛型支持的出现而增多了。&lt;/p&gt;&lt;p&gt;从 Go 1.18 开始，空接口自带类型集合，并且它的类型集合包含了所有的非接口类型。注意，这里的“所有”不但代表当前已存在的所有非接口类型，而且还囊括了将来会在程序中出现的所有非接口类型。也就是说，空接口的类型集合拥有无限多的非接口类型。&lt;/p&gt;&lt;p&gt;这与空接口的设立初衷是一致的，即：空接口是包罗万象的，也是类型之树的唯一树根。在 Go 语言中，任何接口都是空接口的扩展接口，任何类型都是空接口的实现类型。这样来看，任何类型，不论是抽象类型还是具体类型，都是对空接口所代表的类型空间的进一步圈定。&lt;/p&gt;&lt;p&gt;对于类型参数中的类型约束来说也是这样。空接口的类型集合包括了无限多的非接口类型，这使得任何类型约束所代表的类型集合都将是空接口的类型集合的一个子集。这是“进一步圈定”的另一种表现形式。因此，空接口在 Go 语言全面支持泛型之后，依然能够作为其类型系统的根基。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
6. 新的内置标识符 comparable 也代表一个接口类型。&lt;/section&gt;&lt;p&gt;顾名思义，comparable 接口的含义是“可比较的”。只要一个类型符合以下两种情况中的一种，我们就可以断定它实现了 comparable 接口：&lt;/p&gt;&lt;p&gt;比如，像 int、float32、rune、string 这样的基本类型肯定都实现了 comparable 接口，而切片（slice）类型、字典（map）类型以及任何的函数类型肯定就不是 comparable 接口的实现类型。&lt;/p&gt;&lt;p&gt;再比如，我们在前面声明过的 FloatUnion：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; FloatUnion &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; ~&lt;span class=&quot;code-snippet__keyword&quot;&gt;float32&lt;/span&gt; | ~&lt;span class=&quot;code-snippet__keyword&quot;&gt;float64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;可以确定它肯定实现了 comparable 接口。但如果我们把其中的~float64 替换为~[]float64，那么它就不再是 comparable 接口的扩展接口了。&lt;/p&gt;&lt;p&gt;请注意，comparable 接口，以及任何直接或间接地嵌入了（或者说扩展了）comparable 的接口都只能被用于类型约束。它们不能被用作任何值、变量、字段、参数、结果的类型。&lt;/p&gt;&lt;p&gt;显而易见，与 any 接口一样，comparable 接口也是专门为了类型参数（或者说泛型）才引入的。同样的，comparable 接口也自带了类型集合。它的类型集合包含了所有可以被比较的类型。这样的类型既可以是已经存在的，也可以是尚未出现的。&lt;/p&gt;&lt;p&gt;除了上述 6 个很重要的改动之外，Go 团队还为使用者们准备了 3 个实验性质的代码包。这些代码包并不在 Go 标准库当中，而是位于 Go 语言官方专门设立的实验包 golang.org/x/exp 里。这意味着，它们的 API 并不在 Go 1.x 的兼容性保证范围之内。并且，随着 Go 团队对泛型支持的进一步深入，这些代码包也可能会发生非向后兼容的变化。具体如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;代码包 golang.org/x/exp/constraints：其中包含了对泛型编程非常有用的一些类型约束，如 constraints.Ordered 接口等等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码包 golang.org/x/exp/slices：其包含了不少对于切片操作非常有用的函数。而且，对于这些函数所操作的切片，其元素类型可以是任意的。比如，泛型函数 func BinarySearch(x []E, target E) (int, bool)、func CompactS ~[]E, E comparable S、func SortE constraints.Ordered 等等。从这些函数的签名上我们就可以看出，它们的通用性都得益于泛型。这样的通用性在 Go 语言支持泛型之前都是不可能存在的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码包 golang.org/x/exp/maps：与 golang.org/x/exp/slices 包类似，其中包含了一些针对字典的非常通用的泛型函数，如：func ClearM ~map[K]V, K comparable, V any、func CloneM ~map[K]V, K comparable, V any M、func KeysM ~map[K]V, K comparable, V any []K 等。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;真正了解 Go 语言的程序员们肯定都知道，Go 团队经常会向 golang.org/x/exp 包中放入一些实验性的代码。他们往往会通过这种方式来实现一些或新鲜或激进的想法。如果某些代码在这里通过了使用者们的检验，并被认为已经足够成熟，那么它们就有希望被添加到 Go 语言的标准库当中。Go 团队正是依靠这种渐进式升级的方式，在保证标准库稳定的同时，使其创新性得以延续。&lt;/p&gt;&lt;p&gt;再说回泛型。尽管 Go 语言团队为了泛型做了如此多的工作，但到目前为止，Go 语言的泛型实现仍然存在一些小限制（主要体现更加细致的编程语法、值成员访问等方面）。不过，这些小限制在大多数情况下并不会妨碍我们在应用程序中使用泛型。而且，Go 语言团队也已经预告将在未来的版本中对此进行改进。所以，作者就不在这里一一列举了。&lt;/p&gt;&lt;p&gt;到这里，相信大家已经有所体会，“&lt;strong&gt;支持泛型”可以说是 Go 语言正式发布以来最大、最复杂且最重要的一项变化了&lt;/strong&gt;。很显然，Go 语言本身的泛型支持工作离彻底完成还有一小段距离。而&lt;strong&gt;对于 Go 语言的技术社区来讲，更加重要的是，这项变化将意味着 Go 语言生态系统的大规模翻新&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;到目前为止，Go 语言的生态系统已经非常庞大。因此，Go 语言的这项变化将会给 Go 社区带来很可观的压力。那些 Go 程序员们常用的第三方开发框架和工具必然需要一定的时间才能够跟进这项变化，而完美契合这项变化也许还需要更多的时间。这其实也是 Go 团队当初在考虑“是否添加泛型支持”的时候，涉及到的一个很重要的负面因素。&lt;/p&gt;&lt;p&gt;但无论如何，Go 语言在这件事情上的第一步（也是非常重要的一步）已经迈出并平稳落地了。我们现在只希望，Go 语言以及 Go 语言技术社区能够在这个良好的基础之上继续稳步前行、平滑过渡。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;2.2 模糊测试&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;我们都知道，Go 语言原生支持的测试已有三种，即：功能测试、基准测试（或称性能测试），以及示例测试。而从 1.18 版本开始，Go 语言本身支持的测试又多了一种，那就是模糊测试（fuzz test）。&lt;/p&gt;&lt;p&gt;所谓模糊测试是一种自动化测试技术，这种测试可以通过不断地调整应用程序的输入值来试图查找应用程序内部可能存在的错误，尤其是那些我们平常不太能注意到（或称边缘情况）的错误。正因为不太能注意到，所以在编写测试代码的时候，我们往往会有意或无意地忽视掉它们。这个时候，模糊测试就可以被用来查缺补漏了。而且，这种查缺补漏也是非常重要的，特别是在面向安全的测试当中。&lt;/p&gt;&lt;p&gt;这里所说的模糊，其含义是对应用程序的输入值（或者说参数值）的模糊。更确切地讲，模糊测试程序会对应用代码（如函数、结构体、接口方法等）进行若干次调用。而每一次调用都会在预先准备好的语料库（corpus，此为模糊测试的专用术语）当中随机地挑选出一个条目（corpus entry），并把该条目作为参数值输入给应用代码。&lt;/p&gt;&lt;p&gt;请注意，模糊测试的语料库与我们熟知的普通单元测试（如功能测试、基准测试等）的测试用例在生成方面有一个很大的不同。在普通的单元测试中，测试用例都是需要我们专门去准备的。这也算是普通单元测试的一种局限性。因为测试用例的规模与我们的测试工作量是成正比的，而且起码是线性的关系。我们越想全面地测试应用代码，我们的工作量就越大。由于我们的精力和时间是有限的，而且也不可能无限期地测试下去，因此普通的单元测试在测试覆盖度方面就会存在天然的限制，而且很难突破。&lt;/p&gt;&lt;p&gt;而在模糊测试中，语料库的生成是自动化完成的。模糊测试程序会自动生成一定规模的语料库。而我们只需事先向它提供一个规模非常小的种子语料库（seed corpus），甚至只包含一两个条目就可以。&lt;/p&gt;&lt;p&gt;这个种子语料库存在的目的，只是为了指导模糊测试引擎对语料库的自动生成，比如，单个语料库条目里需要包含几个输入值，以及每个输入值都是什么类型的，诸如此类。假设，作为测试目标的函数 A 只有一个参数，那么种子语料库中的每个条目只包含一个值即可。如果作为测试目标的函数 B 有两个参数，那么种子语料库里的单个条目就应该包含两个值。以此类推。&lt;/p&gt;&lt;p&gt;当然了，没有任何一个工具是完美的。虽然模糊测试可以大大地节省我们的测试工作量，但它也有一个小缺点，那就是：我们无法对语料库提供的参数值进行精细的控制。更确切地说，在模糊测试的过程中，我们不能确定应用代码每次被调用时接收到的输入值具体是什么。在某些情况下，这可能会妨碍我们对应用代码返回的输出值（或者说结果值）的正确性判断。倘若确实需要，我们可能就要额外添加一些测试代码来做专门的判断了。如果这样的情况很多，那么我们可能还需要重新权衡是否一定要使用模糊测试，而不是用普通的功能测试或基准测试。&lt;/p&gt;&lt;p&gt;好了，到了这里，想必大家已经大致了解模糊测试是什么，以及我们大概应该如何运用它。至于具体怎样给 Go 程序做模糊测试，其实还是很简单的。它与之前已经存在的功能测试和基准测试的编写方式大同小异，我们稍微迁移一下以前的测试经验就基本上可以搞定。因此，作者在这里就不再赘述了。如果你想对此做深入了解，那么可以去访问 fuzzing landing page 以及 the fuzzing proposal。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;2.3 工作区模式&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;Go 语言的工作区模式（go workspace）是建立在 Go 模块模式（go module）之上的一种项目管理模式，主要体现在 go 标准命令之中。&lt;/p&gt;&lt;p&gt;Go 模块模式在 2021 年发布的 Go 1.17 中已经完全稳定下来了。我们可以通过 go mod 命令来创建和管理我们的 Go 模块。如果我们开发的 Go 项目已经达到了一定的规模，那么往往就需要把它拆分成多个模块，以便让它继续保持高内聚、低耦合的状态。这对于代码和项目的维护都是相当有利的。&lt;/p&gt;&lt;p&gt;比如，我们有一个名叫 MyProject 的 Go 项目（同时也是一个 Go 模块）。它的存放路径是 /path/go /haolin/Demo/MyProject。现在，我们想把其中的一些基础代码分离出来，以便进行独立的开发和维护。我们仔细地抽出那些基础代码，并它们放入到了一个名叫 MyLib 的模块中，并同样存放在 /path/go/haolin/Demo 目录之下。&lt;/p&gt;&lt;p&gt;这两个模块分别有自己的 go.mod 文件。MyProject 模块在它的 go.mod 文件中的名称为 github.com/hyper0x/MyProject，而 MyLib 模块在它的 go.mod 文件中的名称为 github.com/hyper0x/MyLib。不过请注意，这两个模块并不实际存在于网址 https://github.com/hyper0x 之下。这里只是作为示意而已。&lt;/p&gt;&lt;p&gt;在这之后，我们在 MyProject 模块里导入并使用 MyLib 中的代码包。但当我们想编译 MyProject 模块的时候却发现，go 命令无法正确编译 MyProject，提示找不到 MyLib 里的那个代码包。碰到这种情况，我们需要在 MyProject 所在的路径下运行：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; go mod edit -replace github.com/hyper0x/MyLib=../MyLib&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这条命令的主要功能是，在 MyProject 模块的 go.mod 文件中加入如下内容：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;replace github.com/hyper0x/&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;MyLib&lt;/span&gt; =&amp;gt;&lt;/span&gt; ../MyLib&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;其含义是，将本模块中的源码文件里的 github.com/hyper0x/MyLib 定位到本地的路径（即 /path/go/haolin/Demo/MyLib）之上。&lt;/p&gt;&lt;p&gt;做好以上准备工作后，我们再在同样的路径下运行：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; go get github.com/hyper0x/MyLib&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;其功能是，在对应的 go.mod 文件中添加相应的依赖包信息。&lt;/p&gt;&lt;p&gt;好了，现在我们再次编译 MyProject 模块就不会有问题了。因为我们已经把本地的 MyLib 模块正确地设置为了 MyProject 模块的依赖包。&lt;/p&gt;&lt;p&gt;不过，这里有一个问题，上述的 replace 指令中存在一个本地的路径。如果开发这两个模块的人不止我一个，也就是说需要通过多人协作来开发项目，那么，我这里的本地路径在别人那里就是不正确的了。因为不同的开发者几乎不可能确保把同一个项目存放在自己的计算机中的相同路径之下。我们常常称这类问题为“本地路径问题”。&lt;/p&gt;&lt;p&gt;这个时候，Go 语言的 workspace 模式（也就是工作区模式）就派上用场了。具体的做法是，我们在 /path/go/haolin/Demo 这个路径（也就是 MyProject 模块和 MyLib 模块的上一级目录的路径）之下运行：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ go work init&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ go work use ./MyLib&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这里的第一条命令的功能是，把路径 /path/go/haolin/Demo 所代表的目录设置为 Go 工作区。它会在这个路径下添加一个名为 go.work 的文件。第二条命令的功能是，让子目录./MyLib 所代表的模块成为该工作区的一个共用模块。如此一来，该工作区中的其他 Go 模块就可以直接导入并使用 MyLib 模块中的代码包了。&lt;/p&gt;&lt;p&gt;此外，我们还需要在 MyProject 模块所在的路径下运行命令：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ &lt;span class=&quot;code-snippet__attribute&quot;&gt;go&lt;/span&gt; mod edit -dropreplace=github.com/hyper0x/MyLib&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;并以此删除掉对应的 go.mod 文件中包含的那个带有本地路径的 replace 指令。由于我们前面针对（/path/go/haolin/Demo 路径所代表的）相应 Go 工作区的设置，这里的这个 replace 指令的消失并不会造成任何问题。MyProject 模块依然可以通过编译。&lt;/p&gt;&lt;p&gt;至此我们可以看到，由于 Go 工作区模式的出现，我们的 Go 项目无论包含有多少个模块，也无论需要多少人进行怎样的协作调试和开发，都不用担心出现“本地路径问题”。这给团队级别的项目开发，尤其是大规模的协作开发，带来了非常大的便利。我们终于不用再为此频繁地修改 go.mod 文件了。这个 Go 项目管理上的痛点终于被消除了！&lt;/p&gt;&lt;section&gt;
&lt;span&gt;2.4 内存模型更新&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;在 1.19 版本中，Go 语言的内存模型已经过了修改（详见 the Go memory model）。这使得它与其他编程语言如 C、C++、Java、JavaScript、Rust 和 Swift 使用的内存模型保持了一致。&lt;/p&gt;&lt;p&gt;Go 语言只提供可以保证访问顺序一致性的原子操作，而不是像其他编程语言那样使用更加宽松的形式。更确切地说，在 Go 语言中，除非直接或间接地使用了相应的原子操作，否则并发地读写共享的数据必会引发数据竞争（data race）。顺便说一句，从根本上讲，Go 语言标准库中提供的其他同步或异步的数据访问工具基于的其实都是原子操作。&lt;/p&gt;&lt;p&gt;随着内存模型的更新，Go 1.19 在 sync/atomic 包中加入了一些新的类型，如 atomic.Bool、atomic.Int32、atomic.Int64、atomic.Uint32、atomic.Uint64，以及 atomic.Uintptr 和 atomic.Pointer[T]。很显然，与 sync/atomic 包中原有的诸如 AddXXX、CompareAndSwapXXX、LoadXXX 之类的原子函数相比，新的原子类型可以帮助我们更加方便和彻底地运用原子操作，同时也可以避免很多容易发生的编程失误。不得不说，我们已经等待这些原子类型很久了。&lt;/p&gt;&lt;p&gt;到这里，作者已经对 Go 语言在 2022 年的重大更新进行了相应的说明。这其中的重中之重肯定是泛型，所以作者对此的着墨也明显更多。至于那些在作者看来不那么重要或相对较小的更新，大家可以去浏览 Go 语言官方出具的版本说明（Go 1.18 Release Notes 和 Go 1.19 Release Notes），这里就不一一列出了。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;未来展望&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;实际上，与 Go 1.18 相比，Go 1.19 算是一个更新量很小的版本迭代。这主要是因为，在影响巨大的特性加入之后，Go 语言及其团队和社区确实需要一段时间去消化它。这里其实有很多的工作要做，比如：进一步评估和验证、功能调整和修补、社区推广和反馈收集、代码优化和改进、文档补全和细化，等等。&lt;/p&gt;&lt;p&gt;不过，在明年即将发布的 Go 1.20 当中，随着上述工作的稳步推进和趋于完善，还是有一些值得关注的新东西的。下面只列举作者认为最喜闻乐见且可能最常用的几个更新：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;支持同时囊括多个其他错误值的单个错误值&lt;/strong&gt;：届时 errors 包中会提供一个新的函数 Join，用来把多个错误值包装成一个单一的错误值。另外 fmt.Errorf 函数也将允许在其模版字符串（即第一个参数值）中出现多个（用于包装错误值的占位动词）%w。函数 errors.Unwrap 到时候也会以 []error（即 error 的切片）作为结果值的类型，而不是之前的 error，以便一次性地返回所有被包装的错误值。这无疑大大增加了错误包装代码的灵活性，并间接地加强了错误判断代码的功能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;sync.Map 的增强&lt;/strong&gt;：sync.Map 类型里将会出现几个新方法，如 Swap、CompareAndSwap、CompareAndDelete 等。这些方法将如 sync/atomic 包里的相应函数那样，可以让单一的原子操作中包含多个动作。在 sync.Map 的场景下，这将支持针对键值对的更加复杂的原子操作，如上述方法所对应的比较并更新、比较并删除等。使用过 sync.Map 的程序员们应该都知道，对于这种操作，我们在之前不得不使用额外的同步工具来保证其并发的安全性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;支持从切片到数组的转换&lt;/strong&gt;：我们都知道，把数组转换成切片很容易，只要在一个数组上执行切片操作就可以得到一个指向那个数组的切片。这样的切片就相当于一个架设在数组之上的窗口。然而，现在的 Go 语言却不支持对应的反向操作。虽然我们通过少许的魔法代码就可以实现这样的操作，但是它肯定没有“array2 := [5]int(slice1)”这样的代码方便。后者正是将会在 Go 1.20 中合法化的代码，只一行就能完成从切片到数组的转换。不过要注意，上面这小段代码只会返回 slice1 的底层数组的副本，而不是这个底层数组本身。所以，我们之后对 slice1 中元素的修改将不会影响到 array2（但肯定会继续影响到 slice1 的底层数组）。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;顺便提一下。已经在 Go 社区中引发热议的代码包 arena 及其配套代码可能会在 1.20 版本中以实验特性的方式出现。作者很看好 arena，因为它可以在某些情况下大大地减少内存分配和释放的次数，从而显著减轻 GC 的压力。&lt;/p&gt;&lt;p&gt;在作者看来，arena 包的功能类似于 Zig 编程语言中的内存分配器（allocator）。不过相比之下，Go 语言的实现肯定是大大简化的，因为它在 Go 语言中只需起到一定的辅助作用即可。整体来看，其做法是，在需要使用大块内存时先通过 arena 包中的 API 进行显式的内存空间申请，然后再根据实时的需要对其中的子空间进行取用，最后当无需再使用这块内存的时候再利用 arana 中的 API 进行整体释放。简单来说，这属于一种“整体化分配、碎片化使用、整体化释放”的内存空间使用范式。关于它更详细的说明可参看&lt;span&gt; Proposal: arena: new package providing memory arenas。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;除了上述这些，Go 1.20 还会对编译器、标准工具、标准库等方面进行诸多的改进，详情可查看 Go 1.20 Release Notes(DRAFT)。如果在你阅读这篇文章的时候，Go 1.20 已经正式发布了，那么就可以直接去看 Go 1.20 Release Notes。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;总  结&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;好了，我们现在来快速地总结一下。&lt;/p&gt;&lt;p&gt;Go 语言在 2022 年的最大更新莫过于对自定义泛型类型和泛型函数的支持。新增的模糊测试 API 和工具将显著减少程序员们的测试工作量。工作区模式让我们在同时开发多个 Go 模块，尤其是多人协作开发的时候方便了许多（解决了一个很明显的痛点）。而在内存模型方面的修改则进一步增强了 Go 语言在数据访问方面的一致性保证。&lt;/p&gt;&lt;p&gt;在 2023 年，Go 语言将继续全方位地优化和改进其在各个方面的功能和性能。我们在前面已经列举了 Go 官方团队在错误处理、并发编程、便捷语法、内存管理方面的计划。作者相信，这些计划将会有条不紊地进行，并在将来让 Go 语言成为更加优秀、更加流行的编程语言。&lt;/p&gt;&lt;p&gt;希望大家继续关注 Go 语言和 Go 技术社区，尤其是国内的 Go 技术社区。同时，作者也希望能有更多的小伙伴参与到 Go 社区的建设甚至 Go 语言本身的改进当中去。如果正在阅读本文的你还没有尝试过 Go 语言，那么别再犹豫了，赶快到这里下载 Go 语言，并开始尝试编写 Go 程序吧！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bc901435b0f57c79033ca9cf62080cb8</guid>
<title>【权限设计系列】「认证授权专题」微服务常见安全认证方案_洛神灬殇的博客-CSDN博客</title>
<link>https://toutiao.io/k/7g84o3u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;
        
        
                &lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h3&gt;&lt;a id=&quot;HTTP__1&quot;/&gt;HTTP 基本认证&lt;/h3&gt; 
&lt;p&gt;HTTP Basic Authentication（HTTP 基本认证）是 HTTP 1.0 提出的一种认证机制，这个想必大家都很熟悉了，不再赘述。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;HTTP__5&quot;/&gt;HTTP 基本认证的过程如下&lt;/h4&gt; 
&lt;ol&gt;&lt;li&gt;客户端发送HTTP Request给服务器。&lt;/li&gt;&lt;li&gt;因为Request中没有包含 Authorization header，服务器会返回一个 401 Unauthozied 给客户端，并且在 Response 的 Header “WWW-Authenticate” 中添加信息。&lt;/li&gt;&lt;li&gt;客户端把用户名和密码用BASE64加密后，放在Authorization Header中发送给服务器， 认证成功。&lt;/li&gt;&lt;li&gt;服务器将Authorization Header中的用户名密码取出，进行验证，如果验证通过，将根据请求，发送资源给客户端。&lt;/li&gt;&lt;/ol&gt; 
&lt;h4&gt;&lt;a id=&quot;_Session__12&quot;/&gt;基于 Session 的认证&lt;/h4&gt; 
&lt;p&gt;基于Session的认证应该是最常用的一种认证机制了。用户登录认证成功后，将用户相关数据存储到Session中。&lt;/p&gt; 
 
&lt;h5&gt;&lt;a id=&quot;Session_20&quot;/&gt;Session的复制机制&lt;/h5&gt; 
&lt;p&gt;Session 复制依赖于应用服务器，需要应用服务器有 Session 复制能力，不过现在大部分应用服务器如 Tomcat、JBoss、WebSphere 等都已经提供了这个能力。除此之外，Session 复制的一大缺陷在于当节点数比较多时，大量的 Session 数据复制会占用较多网络资源。&lt;/p&gt; 
&lt;p&gt;Session 粘滞是通过负载均衡器，将统一用户的请求都分发到固定的服务器节点上，这样就保证了对某一用户而言，Session 数据始终是正确的。&lt;/p&gt; 
&lt;p&gt;不过这种方案依赖于负载均衡器，并且只能满足水平扩展的集群场景，无法满足应用分割后的分布式场景。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;_28&quot;/&gt;微服务架构的认证能力&lt;/h4&gt; 
&lt;p&gt;在微服务架构下，每个微服务拆分的粒度会很细，并且不只有用户和微服务打交道，更多还有微服务间的调用。这个时候上述两个方案都无法满足，就要求必须要将 Session 从应用服务器中剥离出来，存放在外部进行集中管理。可以是数据库，也可以是分布式缓存，如 Memchached、Redis 等。这正是 David Borsos 建议的第二种方案，分布式 Session 方案。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f4f035aa08902ab4997070985f066cd0.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;_Token__34&quot;/&gt;基于 Token 的认证&lt;/h4&gt; 
&lt;p&gt;随着 Restful API、微服务的兴起，基于 Token 的认证现在已经越来越普遍。Token 和 Session ID 不同，并非只是一个 key。&lt;/p&gt; 
&lt;p&gt;Token 一般会包含用户的相关信息，通过验证 Token 就可以完成身份校验。像 Twitter、微信、QQ、GitHub 等公有服务的 API 都是基于这种方式进行认证的，一些开发框架如 OpenStack、Kubernetes 内部 API 调用也是基于 Token 的认证。基于 Token 认证的一个典型流程如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/893bfe7e3470012ec0d4748911d5521a.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;用户输入登录信息（或者调用 Token 接口，传入用户信息），发送到身份认证服务进行认证（身份认证服务可以和服务端在一起，也可以分离，看微服务拆分情况了）。&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt; &lt;p&gt;身份验证服务验证登录信息是否正确，返回接口（一般接口中会包含用户基础信息、权限范围、有效时间等信息），客户端存储接口，可以存储在 Session 或者数据库中。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;用户将Token放在 HTTP 请求头中，发起相关 API 调用。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;被调用的微服务，验证 Token 权限。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;服务端返回相关资源和数据。&lt;/p&gt; &lt;/li&gt;&lt;/ol&gt; 
&lt;h5&gt;&lt;a id=&quot;_Token__52&quot;/&gt;基于 Token 认证的好处如下&lt;/h5&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;服务端无状态：Token 机制在服务端不需要存储 session 信息，因为 Token 自身包含了所有用户的相关信息。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;性能较好，因为在验证 Token 时不用再去访问数据库或者远程服务进行权限校验，自然可以提升不少性能。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;支持移动设备。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;支持跨程序调用，Cookie 是不允许垮域访问的，而 Token 则不存在这个问题。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aa60cdb55399cd4cb61cc0855bb7372f</guid>
<title>Go实现基于磁盘的存储</title>
<link>https://toutiao.io/k/hfgmeyp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article&gt;&lt;p&gt;I&#x27;d been mulling around reading a computer science paper and implementing a project based on it. Distributed systems, Networking and Databases are some of the things that fascinate me a lot. However, I had been looking to implement a more approachable project to avoid getting inundated initially. And I happened to chance upon the &lt;a href=&quot;https://riak.com/assets/bitcask-intro.pdf&quot;&gt;Bitcask paper&lt;/a&gt; through Avinash&#x27;s project: &lt;a href=&quot;https://github.com/avinassh/py-caskdb&quot;&gt;CaskDB&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After giving a quick read of this reasonably short paper, I decided to write a Golang implementation of the same, as it looked like an exciting project. If you&#x27;re interested in checking out the complete project, checkout &lt;a href=&quot;https://github.com/mr-karan/barreldb/&quot;&gt;BarrelDB&lt;/a&gt;.&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Bitcask is a disk-based key-value storage engine designed for fast read and write operations. It is mainly in production use by Riak (which is a distributed database) as one of the &lt;a href=&quot;https://docs.riak.com/riak/kv/2.2.3/setup/planning/backend/bitcask/index.html&quot;&gt;storage engines&lt;/a&gt;. Bitcask under the hood has a straightforward yet clever design. It writes to the file in an append-only mode. This means that writes are performed only by appending to the end of the file, thus avoiding the need to perform any random disk I/O seek.&lt;/p&gt;
&lt;p&gt;Let&#x27;s look at various components of Bitcask:&lt;/p&gt;
&lt;h2 id=&quot;format-of-the-record&quot;&gt;Format of the record&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/barreldb_record.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CRC: Stores the checksum of the value to ensure data consistency&lt;/li&gt;
&lt;li&gt;Timestamp: Timestamp in UNIX format, stored as int32.&lt;/li&gt;
&lt;li&gt;Expiry: If the record has an expiry defined, then the timestamp, in UNIX format, is stored as int32.&lt;/li&gt;
&lt;li&gt;Key Size: Size of the key in bytes&lt;/li&gt;
&lt;li&gt;Value Size: Size of the value in bytes&lt;/li&gt;
&lt;li&gt;Key&lt;/li&gt;
&lt;li&gt;Value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This additional metadata stored alongside the key/value is represented with a fixed-width header. Each field is represented as &lt;code&gt;int32&lt;/code&gt;, so the total size of the header is 4*5 = 20 bytes. Here&#x27;s the code which encodes and decodes this record:&lt;/p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type &lt;/span&gt;&lt;span&gt;Record &lt;/span&gt;&lt;span&gt;struct &lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;Header &lt;/span&gt;&lt;span&gt;Header
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;Key    &lt;/span&gt;&lt;span&gt;string
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;Value  &lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt;byte
&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;// Header represents the fixed width fields present at the start of every record.
&lt;/span&gt;&lt;span&gt;type &lt;/span&gt;&lt;span&gt;Header &lt;/span&gt;&lt;span&gt;struct &lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;Checksum  &lt;/span&gt;&lt;span&gt;uint32
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;Timestamp &lt;/span&gt;&lt;span&gt;uint32
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;Expiry    &lt;/span&gt;&lt;span&gt;uint32
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;KeySize   &lt;/span&gt;&lt;span&gt;uint32
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;ValSize   &lt;/span&gt;&lt;span&gt;uint32
&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;// Encode takes a byte buffer, encodes the value of header and writes to the buffer.
&lt;/span&gt;&lt;span&gt;func &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;h &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;Header&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;encode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;buf &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;bytes&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Buffer&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;error &lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return &lt;/span&gt;&lt;span&gt;binary&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;buf&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;binary&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;LittleEndian&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;// Decode takes a record object decodes the binary value the buffer.
&lt;/span&gt;&lt;span&gt;func &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;h &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;Header&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;decode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;record &lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;error &lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return &lt;/span&gt;&lt;span&gt;binary&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;bytes&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;NewReader&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;record&lt;/span&gt;&lt;span&gt;), &lt;/span&gt;&lt;span&gt;binary&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;LittleEndian&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The record is encoded in the binary format before storing it on the disk. &lt;/p&gt;
&lt;h2 id=&quot;datafile&quot;&gt;Datafile&lt;/h2&gt;
&lt;p&gt;A &quot;datafile&quot; (term used for the DB file on disk) is an append-only record of all the write operations. An instance of Bitcask can have several datafiles. However, there&#x27;s only one &quot;active&quot; datafile. In BarrelDB, a goroutine runs in the background at regular intervals to check if the size of the active DB file has crossed the threshold and then rotates the active file. It appends this DB file to the list of &quot;stale&quot; data files. All the new writes only happen to the &quot;active&quot; data file, and the stale files are merged as a part of the &quot;compaction&quot; process (described later in the post).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/barreldb_data_dir.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Here&#x27;s how a &lt;code&gt;datafile&lt;/code&gt; is represented:&lt;/p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type &lt;/span&gt;&lt;span&gt;DataFile &lt;/span&gt;&lt;span&gt;struct &lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;sync&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;RWMutex
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;writer &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;os&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;File
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;reader &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;os&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;File
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;id     &lt;/span&gt;&lt;span&gt;int
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;offset &lt;/span&gt;&lt;span&gt;int
&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It contains different handlers for writing and reading the file. The reason we have 2 file handlers instead of re-using the same one is that the &lt;code&gt;writer&lt;/code&gt; is only opened in an &quot;append-only&quot; mode. In addition, since the active file can be rotated, the writer can be set to &lt;code&gt;nil&lt;/code&gt;, ensuring no new writes ever happen on that file.&lt;/p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;writer&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;err &lt;/span&gt;&lt;span&gt;:= &lt;/span&gt;&lt;span&gt;os&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;OpenFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;os&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;O_APPEND&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;os&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;O_CREATE&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;os&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;O_WRONLY&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;0644&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;err &lt;/span&gt;&lt;span&gt;!= nil {
&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return &lt;/span&gt;&lt;span&gt;nil, &lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Errorf&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error opening file for writing db: &lt;/span&gt;&lt;span&gt;%w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;err&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;// Create a reader for reading the db file.
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;reader&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;err &lt;/span&gt;&lt;span&gt;:= &lt;/span&gt;&lt;span&gt;os&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;err &lt;/span&gt;&lt;span&gt;!= nil {
&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return &lt;/span&gt;&lt;span&gt;nil, &lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Errorf&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error opening file for reading db: &lt;/span&gt;&lt;span&gt;%w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;err&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;keydir&quot;&gt;KeyDir&lt;/h2&gt;
&lt;p&gt;In addition to storing the file on disk, Bitcask also stores additional metadata, which defines how to retrieve the record. This hashtable is a map of keys with this metadata and is referred to as &lt;code&gt;KeyDir&lt;/code&gt;. An important point to note here is that the &lt;code&gt;value&lt;/code&gt; is &lt;em&gt;never&lt;/em&gt; stored in this map. This makes it possible for Bitcask to handle datasets more significant than what the RAM can hold.&lt;/p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// KeyDir represents an in-memory hash for faster lookups of the key.
&lt;/span&gt;&lt;span&gt;// Once the key is found in the map, the additional metadata, like the offset record
&lt;/span&gt;&lt;span&gt;// and the file ID is used to extract the underlying record from the disk.
&lt;/span&gt;&lt;span&gt;// Advantage is that this approach only requires a single disk seek of the db file
&lt;/span&gt;&lt;span&gt;// since the position offset (in bytes) is already stored.
&lt;/span&gt;&lt;span&gt;type &lt;/span&gt;&lt;span&gt;KeyDir &lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;Meta
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;// Meta represents some additional properties for the given key.
&lt;/span&gt;&lt;span&gt;// The actual value of the key is not stored in the in-memory hashtable.
&lt;/span&gt;&lt;span&gt;type &lt;/span&gt;&lt;span&gt;Meta &lt;/span&gt;&lt;span&gt;struct &lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;Timestamp  &lt;/span&gt;&lt;span&gt;int
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;RecordSize &lt;/span&gt;&lt;span&gt;int
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;RecordPos  &lt;/span&gt;&lt;span&gt;int
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;FileID     &lt;/span&gt;&lt;span&gt;int
&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, &lt;code&gt;RecordPos&lt;/code&gt; tells the record&#x27;s position offset (in bytes) in the entire file. Since the position of the record is stored in memory along with the key, the retrieval of the key doesn&#x27;t require more than a &lt;em&gt;single&lt;/em&gt; disk seek. Bitcask achieves really low latency even with many keys in the database. A file system read-ahead cache also helps boost the performance and comes for free - no need to design a separate caching mechanism.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/barreldb_key_lookup.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;compaction&quot;&gt;Compaction&lt;/h2&gt;
&lt;p&gt;As we looked at previously, a datafile is simply an append-only sequence of writes. Any modification of the key is merely a new record appended to the datafile. KeyDir overwrites the entry of the key with the new metadata, which contains the new location of the record. Thus all reads will automatically return the updated value.&lt;/p&gt;
&lt;p&gt;Deletes are handled similarly by writing a &quot;tombstone&quot; record for the key. When the user requests the key after it&#x27;s been deleted, BarrelDB can check whether that value equals the tombstone value and return an appropriate error.&lt;/p&gt;
&lt;p&gt;As you would have guessed, our database will grow unbounded if we don&#x27;t perform any garbage cleanup. The datafiles need to be pruned for deleting expired/deleted records and merging all stale files in a single active file - to keep the number of opened files in check. All of these processes are together called &quot;Compaction&quot;.&lt;/p&gt;
&lt;p&gt;Let&#x27;s take a look at how each of these compaction routine works under the hood:&lt;/p&gt;
&lt;h3 id=&quot;merge&quot;&gt;Merge&lt;/h3&gt;
&lt;p&gt;The merge process iterates over all the keys inside KeyDir and fetches their value. The value could come from a stale file as well. Once the new keys/values are updated, it writes them to a new active file. All the old file handlers are closed, and the stale files are deleted from the disk. The KeyDir is updated similarly since the new records live in a different position/file.&lt;/p&gt;
&lt;h3 id=&quot;hints-file&quot;&gt;Hints File&lt;/h3&gt;
&lt;p&gt;Bitcask paper describes a way of creating a &quot;hints&quot; file initially loaded in the database for faster startup time. This file is essential to bootstrap KeyDir after a cold startup. This avoids iterating over all data files and reading their values sequentially. In BarrelDB, &lt;code&gt;gob&lt;/code&gt; encoding is used to dump the &lt;code&gt;KeyDir&lt;/code&gt; map as a &lt;code&gt;gob&lt;/code&gt; dump.&lt;/p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// generateHints encodes the contents of the in-memory hashtable
&lt;/span&gt;&lt;span&gt;// as `gob` and writes the data to a hints file.
&lt;/span&gt;&lt;span&gt;func &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;b &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;Barrel&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;generateHints&lt;/span&gt;&lt;span&gt;() &lt;/span&gt;&lt;span&gt;error &lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;path &lt;/span&gt;&lt;span&gt;:= &lt;/span&gt;&lt;span&gt;filepath&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Join&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;opts&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;dir&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;HINTS_FILE&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;err &lt;/span&gt;&lt;span&gt;:= &lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;keydir&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Encode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;span&gt;err &lt;/span&gt;&lt;span&gt;!= nil {
&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return &lt;/span&gt;&lt;span&gt;err
&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return &lt;/span&gt;&lt;span&gt;nil
&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;During the startup, BarrelDB checks the presence of a &lt;code&gt;.hints&lt;/code&gt; file, decodes this gob dump, and loads the data in &lt;code&gt;KeyDir&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;removing-expired-keys&quot;&gt;Removing expired keys&lt;/h3&gt;
&lt;p&gt;A goroutine runs at a configurable interval to check if the value of the key has expired. If it has, it deletes the entry from KeyDir. During the following merge process, since this entry won&#x27;t be present in KeyDir, it&#x27;ll automatically be removed when the new datafile is created.&lt;/p&gt;
&lt;p&gt;To check if the key has expired, a simple check, like comparing their timestamps in UNIX epoch format, is enough: &lt;code&gt;time.Now().Unix() &amp;gt; int64(r.Header.Expiry)&lt;/code&gt;.&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;redis-server&quot;&gt;Redis Server&lt;/h2&gt;
&lt;p&gt;In addition to using BarrelDB as a Go library, I also implemented a redis-compatible server. I found &lt;a href=&quot;https://github.com/tidwall/redcon&quot;&gt;tidwall/redcon&lt;/a&gt; as an easy-to-use library to create a Redis-compatible server for Go applications. All I&#x27;d do was wrap BarrelDB API methods and define handlers for &lt;code&gt;SET&lt;/code&gt; / &lt;code&gt;GET&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I was able to use &lt;code&gt;redis-cli&lt;/code&gt; and connect to the BarrelDB server:&lt;/p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;127.0.0.1:6379&lt;/span&gt;&lt;span&gt;&amp;gt; set hello world
&lt;/span&gt;&lt;span&gt;OK
&lt;/span&gt;&lt;span&gt;127.0.0.1:6379&lt;/span&gt;&lt;span&gt;&amp;gt; get hello
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;benchmarks&quot;&gt;Benchmarks&lt;/h2&gt;
&lt;p&gt;You can check the &lt;a href=&quot;https://github.com/mr-karan/barreldb/#benchmarks&quot;&gt;repo&lt;/a&gt; for the actual benchmarks. However, I&#x27;d like to point out some inferences of the results from &lt;code&gt;redis-benchmark&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;First, let&#x27;s send 100000 requests to the server using 50 parallel clients. This command creates a unique key for each &lt;code&gt;SET&lt;/code&gt; operation.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span&gt;redis-benchmark -p 6379 -c 50 -t set -n 100000 -r 100000000
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;Summary:
&lt;/span&gt;&lt;span&gt;  throughput summary: 145985.41 requests per second
&lt;/span&gt;&lt;span&gt;  latency summary (msec):
&lt;/span&gt;&lt;span&gt;          avg       min       p50       p95       p99       max
&lt;/span&gt;&lt;span&gt;        0.179     0.016     0.183     0.207     0.399     1.727
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, 140k requests per second is not bad at all for a disk-based KV. But the exciting thing to note here is that the performance is predictable even if you increase the load by increasing clients:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span&gt;redis-benchmark -p 6379 -c 200 -t set -n 100000 -r 100000000
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;Summary:
&lt;/span&gt;&lt;span&gt;  throughput summary: 140845.08 requests per second
&lt;/span&gt;&lt;span&gt;  latency summary (msec):
&lt;/span&gt;&lt;span&gt;          avg       min       p50       p95       p99       max
&lt;/span&gt;&lt;span&gt;        0.718     0.224     0.711     0.927     1.183     5.775
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we increase the number of requests (by 5x) as well, the throughput looks almost the same:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span&gt;redis-benchmark -p 6379 -c 200 -t set -n 500000 -r 100000000
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;Summary:
&lt;/span&gt;&lt;span&gt;  throughput summary: 138350.86 requests per second
&lt;/span&gt;&lt;span&gt;  latency summary (msec):
&lt;/span&gt;&lt;span&gt;          avg       min       p50       p95       p99       max
&lt;/span&gt;&lt;span&gt;        0.748     0.056     0.711     0.879     1.135    63.135
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This magic is all because of the way Bitcask uses Log structured hash table (just append-only records for writing data). Even with a lot of records, all it has to do is to write to the end of the file, which avoids any expensive I/O operations.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Overall, I am happy with &lt;code&gt;BarrelDB&lt;/code&gt; implementation as I covered everything described in the paper. This project had excellent learning outcomes for me. I spent a lot of time coming up with a design for structuring different components and their API methods and handling all the edge scenarios during the compaction process. Although, full credit to Bitcask as it kept its design so elegant and minimal yet achieved some significant numbers in the benchmarks. This is also a reminder that simple need not necessarily mean less powerful.&lt;/p&gt;
&lt;p&gt;I look forward to implementing a distributed KV store by adding support for multiple BarrelDB nodes connected via Raft. For now, gonna enjoy some chai and release this project to the WWW :) &lt;/p&gt;
&lt;p&gt;Fin!&lt;/p&gt;
&lt;/article&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4ea076563f056605dcd7c5f861525530</guid>
<title>日志的艺术</title>
<link>https://toutiao.io/k/rw81b80</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;em&gt;良好的日志是运维、开发人员排查问题的好工具，本文建议定义JSON格式的结构化日志格式，从而有效优化人工以及机器排查日志的效能，并能方便创建机器索引。原文: &lt;span&gt;The Art of Logging&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6642512077294686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0W84B5AtJtbCAHibVicetDfXlQsZ4TOYxwqeo1yTN5GKibVcCicq3nqypFwGSquqCicFDK7XzqXFrmGZTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;Viktor Talashuk@Unsplash&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从历史上看，日志对于诊断应用程序和基础设施性能非常重要，被广泛应用于业务仪表板的可视化和性能分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对日志文件中的数据进行结构化，以便能够有效提取、操作和分析数据(除了便于人类理解，也便于机器分析)的重要性正在迅速上升。此外，微服务的兴起也带来了另一个挑战，即怎样在整个系统中跟踪请求的传播。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将介绍便于人和机器解析、理解的日志结构的最佳格式，特别是跟用户登录有关的关键信息及数据结构的建议，并将尝试提供一些重要的注意事项。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;为什么日志应该是人类可读的?&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管日志最初是由机器来解析、处理和存储的，但现在正越来越多的由人类来读取、理解和诊断。日志是我们调查凶杀现场的最佳指标，而凶手正是我们的死敌: Bug!🐛&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0W84B5AtJtbCAHibVicetDfXl4j24ia6icZAzynXdxtAVeIODraicibmRwfnz5H8CS54OvFmpbrch3gXBvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;Elsa Ventur@Unsplash&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没什么比试图理解冗长而且非结构化的日志线中丢失的信息更令人沮丧和耗时的了。日志必须有有意义，并且人们应该可以很容易理解和深入挖掘与他们有关的内容。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;66.249.65.159 - - [06/Nov/2014:19:10:38 +0000] &lt;span&gt;&quot;GET /news/53f8d72920ba2744fe873ebc.html HTTP/1.1&quot;&lt;/span&gt; 404 177 &lt;span&gt;&quot;-&quot;&lt;/span&gt; &lt;span&gt;&quot;Debian APT-HTTP/1.3 (0.8.16~exp12ubuntu10.16)&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管我们已经习惯了默认的Nginx格式，但上面的示例仍然很难阅读和处理。例如，这是为了再现生产bug而提取的巨大日志文件的一部分，很难理解其背后含义是什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JSON相对于其他数据交换格式(如XML)的优势非常明显，这是一种在数组中有序嵌套的键值对的简单语法，对人类来说很容易读、写和理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，用JSON编写的日志消息是什么样子的呢？以下是与之前相同的JSON格式的Nginx web服务器日志示例:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;&lt;span&gt;&quot;time&quot;&lt;/span&gt;: &lt;span&gt;&quot;06/May/2022:19:10:38 +0100&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;remote_ip&quot;&lt;/span&gt;: &lt;span&gt;&quot;66.249.65.159&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;remote_user&quot;&lt;/span&gt;: &lt;span&gt;&quot;-&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;request&quot;&lt;/span&gt;: &lt;span&gt;&quot;GET /news/53f8d72920ba2744fe873ebc.html HTTP/1.1&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;response&quot;&lt;/span&gt;: &lt;span&gt;404&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;bytes&quot;&lt;/span&gt;: &lt;span&gt;177&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;referrer&quot;&lt;/span&gt;: &lt;span&gt;&quot;-&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;&quot;agent&quot;&lt;/span&gt;: &lt;span&gt;&quot;Debian APT-HTTP/1.3 (0.8.16~exp12ubuntu10.16)&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;为什么日志应该是对机器友好的?&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次考虑上面的日志线示例:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;66.249.65.159 - - [06/Nov/2014:19:10:38 +0000] &lt;span&gt;&quot;GET /news/53f8d72920ba2744fe873ebc.html HTTP/1.1&quot;&lt;/span&gt; 404 177 &lt;span&gt;&quot;-&quot;&lt;/span&gt; &lt;span&gt;&quot;Debian APT-HTTP/1.3 (0.8.16~exp12ubuntu10.16)&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了理解，我们需要:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不幸的是，这种逻辑很脆弱，如果日志格式发生了更改(比如开发人员添加了一个新字段或更改了字段顺序)，那么解析器就会崩溃，相信任何人都有面对或经历类似问题的时候。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这就是像JSON这样的结构化格式可以提供帮助的地方。键值对使提取特定值和跨数据集筛选和搜索变得容易，如果添加了新的键值对，解析日志消息的软件将只是忽略那些非期望的键，而不会完全失效。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0W84B5AtJtbCAHibVicetDfXlHibM9K2xWsxOuSbMpOqDoIjTltyJzvj3muCm45iaibnyfFfKTG5hibYVOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;Alex Knight@Unsplash&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在机器上使用JSON日志的好处是:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;具有结构化的格式，因此便于分析日志和查询每个字段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每种编程语言都可以对其进行解析。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，我们可以在日志解析系统(ELK、newRelic、Datadog等)中聚合JSON数据，从而为我们提供强大的报告、搜索和对数据的洞察能力。这些工具使索引某些字段变得更容易，从而解决在微服务环境下跟踪请求的问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;应该包含哪些信息?&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里列举了应该包含在日志中的信息列表，有些元素是可选的，字段名前面的(o)表示可选字段。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;message &amp;lt;string&amp;gt;&lt;/code&gt;: 用于描述情况的人类可读的信息，在过滤时易于阅读，以获得对内容的概述。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;level &amp;lt;integer&amp;gt;&lt;/code&gt;: 优先级级别的数值表示(下一节将详细介绍)，对于将消息按不同优先级排序或生成包含系统概述的仪表板非常有用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;level_name &amp;lt;string&amp;gt;&lt;/code&gt;: 优先级级别的字符串表示(更多细节将在下一节中介绍)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;datetime_iso &amp;lt;DateTime&amp;gt;&lt;/code&gt;: &lt;span&gt;iso8601格式&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;的日期，因为我们需要将时间与其他事件相关联，因此是必填项。尽管可以使用服务器的日期-时间，但可能会产生误导，因为服务器的时间可能并不一致，甚至可能位于不同的时区。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;correlation_id &amp;lt;string(uuidv4)&amp;gt;&lt;/code&gt;: 这是微服务环境的一个重要字段，我们将基于解析后的消息/请求的correlation id来跟踪服务之间整个链路的请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(o)&lt;code&gt;hostname &amp;lt;string&amp;gt;&lt;/code&gt;: 用于确定是哪台机器生成了此日志，建议在微服务环境中使用。当服务器日志已经从docker的服务名映射到原始主机时，可能是多余的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(o)&lt;code&gt;build_id &amp;lt;string&amp;gt;&lt;/code&gt;: 记录信息的软件版本，可以帮助跟踪不兼容问题，特别是那些在服务器端软件部署期间发生的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(o)&lt;code&gt;application&amp;lt;string&amp;gt;&lt;/code&gt;: 用于识别哪个设备或应用程序生成了此日志。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(o)&lt;code&gt;owner_id &amp;lt;string(uuidv4)/null&amp;gt;&lt;/code&gt;: 报告用户id或API key id(如果有的话)，可以追踪用户执行了哪些步骤来再现他的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(o)&lt;code&gt;tenant_id &amp;lt;string(uuidv4)/null&amp;gt;&lt;/code&gt;: 报告可用的租户id，对于多租户系统非常有用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(o)&lt;code&gt;tags &amp;lt;string[]&amp;gt;&lt;/code&gt;: 可以是一个元素数组，包含关于请求的元信息，如类型、使用的协议等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(o)&lt;code&gt;stacktrace: &amp;lt;string/null&amp;gt;&lt;/code&gt;: 有stack trace时以字符串格式显示stack trace。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(o)&lt;code&gt;exception: &amp;lt;string/null&amp;gt;&lt;/code&gt;: 有异常消息时显示异常消息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;日志级别和相关日志码&lt;/h5&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;日志级别&lt;/th&gt;&lt;th&gt;日志码&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Debug&lt;/td&gt;&lt;td&gt;100&lt;/td&gt;&lt;td&gt;详细的调试信息。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Info&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;td&gt;感兴趣的事件。例如: 用户登录或SQL日志。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Notice&lt;/td&gt;&lt;td&gt;250&lt;/td&gt;&lt;td&gt;正常但重要的事件。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Warning&lt;/td&gt;&lt;td&gt;300&lt;/td&gt;&lt;td&gt;不是错误的异常事件。示例: 使用已弃用的API; API使用不当。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Error&lt;/td&gt;&lt;td&gt;400&lt;/td&gt;&lt;td&gt;不需要立即处理的运行时错误，但通常应该记录和监控。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Critical&lt;/td&gt;&lt;td&gt;500&lt;/td&gt;&lt;td&gt;严重事件。示例: 应用组件不可用; 意想不到的异常。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Alert&lt;/td&gt;&lt;td&gt;550&lt;/td&gt;&lt;td&gt;必须立即采取行动。例如: 整个网站瘫痪。应该会触发SMS告警。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Emergency&lt;/td&gt;&lt;td&gt;600&lt;/td&gt;&lt;td&gt;紧急情况: 系统不可用。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;建议格式&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，用JSON编写的日志消息是什么样的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是示例建议的日志概念格式:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6304347826086957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0W84B5AtJtbCAHibVicetDfXlKbwFUkzXWh46ZiaApR32CqlhHicqFTKYzevNVkEJ56vypTdVIjyUicDcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;使用carbon生成的示例消息&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;观察&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在日志服务器中，应该为以下元素建立索引，以便更快搜索: &lt;code&gt;owner_id&lt;/code&gt;、&lt;code&gt;tenant_id&lt;/code&gt;、&lt;code&gt;correlation_id&lt;/code&gt;、&lt;code&gt;level&lt;/code&gt;、&lt;code&gt;level_name&lt;/code&gt;和&lt;code&gt;application&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当可选字段可用时，应该添加到日志中，只能在没有的时候将其忽略，而在调试系统时，它们的值将是可见的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;context元素可以包含其他有用的字段(比如传入请求的打印)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;出于安全性或合规性原因(个人信息保护)，日志应该对请求中可能出现的关键字段(比如密码)设置一些过滤器，以便在输出内容之前匿名化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个服务都应该转发收到的&lt;code&gt;correlation_id&lt;/code&gt;，如果这个值不存在，应该生成一个新值并将其传递给下一个服务。API网关(如果有的话)应该始终关注该字段是否存在、是否需要生成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;花时间设计日志结构，使格式满足我们的需要，并且可以很容易复制。然而，有些团队可能需要不同的版本，还要考虑适合需求的粒度级别。通常，公司内部的&quot;日志概念&quot;文档可以让所有团队遵循同一种模式，并且有新的开发人员加入时会非常有用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽可能多的记录日志。在发生致命异常时知道模块和行号，或者在遇到安全漏洞时知道IP/用户名，对于更快、更准确解决问题是非常宝贵的。如果想避免一些不必要的噪音，仍然可以调整级别，通过经验可以知道什么级别最适合当前项目！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保持一致性是每个人的首要任务。JSON消息中适当的键和准确的值使调试更容易、更有效。Correlation Id和日志级别可以明确证明这一点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;编写代码的同时记录日志，像编写单元测试一样，尝试保持相同的风格并记录系统交互。为了避免丢失函数的上下文和边缘情况，当场完成比稍后添加更容易。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最后&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;本文不是要推动标准，而是要尝试创建一种逻辑化组织的日志格式，以优化如newRelic或ELK等日志解析系统。这一格式将帮助我们生成有用的仪表板、指标和事件通知(例如，在错误百分比超过5%时触发警报)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在应用程序中实现标准化日志系统将花费一定的时间和金钱，调试也需要付出代价，特别是有关关键边界条件信息的情况下。在做出决定的时候应该权衡考虑。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日志记录是一个公说公有理、婆说婆有理的话题，有时还会引起分歧。但是，无论使用哪种格式，总是比完全不用日志要好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建议使用异步日志记录来避免性能问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/em&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;The Art of Logging: &lt;em&gt;https://betterprogramming.pub/creating-a-human-and-machine-freindly-logging-format-bb6d4bb01dca&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;iso8601格式: &lt;em&gt;https://en.wikipedia.org/wiki/ISO_8601&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>efa6a10e18d3e8ece4d185f232ae5262</guid>
<title>2022年安全架构总结以及2023安全方向展望</title>
<link>https://toutiao.io/k/k0ksiht</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-msg__text-area&quot;&gt;
                    &lt;p class=&quot;weui-msg__title warn&quot;&gt;The content has been deleted by the author.&lt;/p&gt;
            &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>