<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>81bb4c646ef7b92af0af3a65e7dd85a2</guid>
<title>Spring 如何解决循环依赖问题？</title>
<link>https://toutiao.io/k/uyax3pb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg4NjYyODc4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J4jTHmo8Xh6qM32ASOtVbXNoiaegrI26qLRw6r6FTI7dZw6TMT7vecvnjd1O8xSsM5MiajIuQZicxSC6KFK8TMpbg/0?wx_fmt=png&quot; data-nickname=&quot;java突击队&quot; data-alias=&quot;&quot; data-signature=&quot;技术经验分享&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是楼仔！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Spring 如何解决循环依赖，网上的资料很多，但是感觉写得好的极少，特别是源码解读方面，我就自己单独出一篇，&lt;/span&gt;&lt;strong&gt;这篇文章绝对肝！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不 BB，上文章目录。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6021409455842998&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNO1bBHac1mGCxEHO35Xv8HLlc7wTQ7TJQJgFgP3sTkgUOmZjNYfbXQqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1121&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 基础知识&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 什么是循环依赖 ？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个或多个对象之间存在直接或间接的依赖关系，这种依赖关系构成一个环形调用，有下面 3 种方式。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3935309973045822&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOCUk9DAyeeice7mC1Az8NHOCX2Hic3AcYZZEd4ZmjeTNhzH5Rd6lv02yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一个简单的 Demo，对标“情况 2”。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Louzai1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Louzai2 louzai2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Louzai2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Louzai1 louzai1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个经典的循环依赖，它能正常运行，后面我们会通过源码的角度，解读整体的执行流程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 三级缓存&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解读源码流程之前，spring 内部的三级缓存逻辑必须了解，要不然后面看代码会蒙圈。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;第一级缓存&lt;/strong&gt;：singletonObjects，用于保存实例化、注入、初始化完成的 bean 实例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;第二级缓存&lt;/strong&gt;：earlySingletonObjects，用于保存实例化完成的 bean 实例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;第三级缓存&lt;/strong&gt;：singletonFactories，用于保存 bean 创建工厂，以便后面有机会创建代理对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是最核心，我们直接上源码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6916354556803995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOvk3AiaCDWY8JN7rwGJvRQ8HMpOo41J3ibJbaRGB3105qyeQNmAzcLSyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;801&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行逻辑：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先从“第一级缓存”找对象，有就返回，没有就找“二级缓存”；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找“二级缓存”，有就返回，没有就找“三级缓存”；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找“三级缓存”，找到了，就获取对象，放到“二级缓存”，从“三级缓存”移除。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 原理执行流程&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把“情况 2”执行的流程分解为下面 3 步，是不是和“套娃”很像 ？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5404624277456648&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOQZgjQPEQ1hwh03fiaibvicukAp8QiaAj2ofz9uOsWFmRd1SZ9YayrkCnWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1038&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个执行逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在第一层中，先去获取 A 的 Bean，发现没有就准备去创建一个，然后将 A 的代理工厂放入“三级缓存”（&lt;strong&gt;这个 A 其实是一个半成品，还没有对里面的属性进行注入&lt;/strong&gt;），但是 A 依赖 B 的创建，就必须先去创建 B；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在第二层中，准备创建 B，发现 B 又依赖 A，需要先去创建 A；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在第三层中，去创建 A，因为第一层已经创建了 A 的代理工厂，&lt;strong&gt;直接从“三级缓存”中拿到 A 的代理工厂，获取 A 的代理对象，放入“二级缓存”&lt;/strong&gt;，并清除“三级缓存”；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回到第二层，现在有了 A 的代理对象，对 A 的依赖完美解决（&lt;strong&gt;这里的 A 仍然是个半成品&lt;/strong&gt;），B 初始化成功；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回到第一层，现在 B 初始化成功，完成 A 对象的属性注入，然后再填充 A 的其它属性，以及 A 的其它步骤（包括 AOP），完成对 A 完整的初始化功能（&lt;strong&gt;这里的 A 才是完整的 Bean&lt;/strong&gt;）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;将 A 放入“一级缓存”。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要用 3 级缓存 ？我们先看源码执行流程，后面我会给出答案。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 源码解读&lt;/h1&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：Spring 的版本是 &lt;strong&gt;5.2.15.RELEASE&lt;/strong&gt;，否则和我的代码不一样！！！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的知识，网上其实都有，下面才是我们的重头戏，让你跟着楼仔，走一遍代码流程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 代码入口&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0429594272076372&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOoCr5rjzaficibg7TicZ1gm8b8kR8u4HJyB1ABRtmH0icbbnqCslxZtIQYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7092651757188498&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOribwkzRb9Zyy8XicicyPHJlSO1AGaFLdSYmiaDD9k9WXo6m5WibWcDKl7jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;939&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要多跑几次，把前面的 beanName 跳过去，只看 louzai1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9205103042198234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOicWQQQckoiaDnu2xBtLe2XMnQwslx2sstS18OiczfP6UiaNic3ib1LFmkv1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1019&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11724137931034483&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOlLXkAbQickHqSevBt03Jtud05gCtpvPS9mesicCTwmz0j8qJT97yibacw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 第一层&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2490118577075099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNODOytdibzgpUXNpSMDXp9iazlqwDMaqicxrCT315miajFsApWmtIiaDSX1KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入 doGetBean()，从 getSingleton() 没有找到对象，进入创建 Bean 的逻辑。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38477580813347234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOLSwPYmzD0ic1I33ZPISBUm9aXDPWklLP1nibLAFoS3ZsoE61NcGF81TQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;959&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0844390832328106&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOhCia75vp68b1syrIF5KggFicotRqV9YWEjgTo7EwoLE1k4WRs1PjLkew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;829&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入 doCreateBean() 后，调用 addSingletonFactory()。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0824622531939605&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNO9tx6jk4cLlTibhiax6dB67cQkArxyzspw3Wq12yvwORzP8jicB0sPC7rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;往三级缓存 singletonFactories 塞入 louzai1 的工厂对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.478584729981378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOY35CnbLdL7p2QmoyUcc0RTljdc5XUSHCc89UDibjah7Gmn3nSwlmDsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1074&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5518814139110604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNO4RibGWBk6C4KO5f61Bhm1F1ZwHjL4M9FtSs9shEneCib8IftiaibkbQQKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入到 populateBean()，执行 postProcessProperties()，这里是一个策略模式，找到下图的策略对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.409250175192712&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOFYpibXKiawoibkYFH7QLUWs51elYkPA013efmDTj8AbvrIic96VldrM7Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1427&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正式进入该策略对应的方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.554932735426009&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOibX5MOdF9p8Nhk2Eq0e3hd5OIMbSUIZ0RglMKiaibxI37SoaymamqlPtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面都是为了获取 louzai1 的成员对象，然后进行注入。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2819593787335723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOl9A6NV70She9icl5WZqsvtiblAw2ZdqZCrNGHwdd1a8ZT2Iv54rx1FnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6040868454661558&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOPS5wsCT5BP1XibqAugQynytiaic0Zng5fRjHFLoVxtbBe66ZkZx4W0xew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;783&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34579439252336447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNO7YhbX6SlqCU6KyaZLdQlwc7GY4SKyR6U9SEvia6L0HsptIOVquwZqrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;963&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOSwmZegYMEzicxpGw5ZgkVW8vWOTAokbgWNK2ZpfXagZfc7tsMSsGDYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;994&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入 doResolveDependency()，找到 louzai1 依赖的对象名 louzai2&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24548049476688868&quot; data-type=&quot;png&quot; data-w=&quot;1051&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNON6wldlCCdf6AaTXcDbcsSiaGOZDxGibp1gNEWVjpZBrJvso1PDfPv3bg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要获取 louzai2 的 bean，是 AbstractBeanFactory 的方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34022988505747126&quot; data-type=&quot;png&quot; data-w=&quot;870&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNO9yW8MRkae4lQqnZLjnWnJ6AA1dbh6BoMFrEx1licVHA1RibMic8eggP4w/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正式获取 louzai2 的 bean。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1444723618090452&quot; data-type=&quot;png&quot; data-w=&quot;796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOqtv8E8CX8O4MB830hMoSK2YqvIYI7wDlsdYxic7jsnyPnooSn6JebhA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;到这里，第一层套娃基本结束，因为 louzai1 依赖 louzai2，下面我们进入第二层套娃。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 第二层&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09919839679358718&quot; data-type=&quot;png&quot; data-w=&quot;998&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOpfvYbyxOvVlwvzxv94CtniaQzibXLK1G7HfM3PcPygUr3RgkXdKE2h0g/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取 louzai2 的 bean，从 doGetBean()，到 doResolveDependency()，和第一层的逻辑完全一样，找到 louzai2 依赖的对象名 louzai1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的流程全部省略，直接到 doResolveDependency()。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5810945273631841&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOvKMaqFvSKo0qahT78icU1Uf4T70F54bRqk7hdqhorqW6r6efibwkwqHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1005&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正式获取 louzai1 的 bean。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3952772073921971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNO13vQDjUKscx8Rg7wExCQN0m7ic298kfXXg4grLoia0BfhHjgS7SMiadeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;到这里，第二层套娃结束，因为 louzai2 依赖 louzai1，所以我们进入第三层套娃。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 第三层&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1619631901840491&quot; data-type=&quot;png&quot; data-w=&quot;815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOI01icQAGFZWCibO1fFRz9ta32icwObTp0EkJiaVYuXCgm6G10OzK5nyibWQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取 louzai1 的 bean，在第一层和第二层中，我们每次都会从 getSingleton() 获取对象，但是由于之前没有初始化 louzai1 和 louzai2 的三级缓存，所以获取对象为空。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35911602209944754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOiah5c2Z1hjtHoibMeFJXM37cuf7tHOnfjblJQwU1OPKc0yicBW7fibtHrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;905&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15081967213114755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOxKSlncPw1azxuls349583gZsC1L88jTcE6sDpia4eCIyNOYF2N9RFbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;915&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲重点！敲重点！！敲重点！！！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到了第三层，由于第三级缓存有 louzai1 数据，这里使用三级缓存中的工厂，为 louzai1 创建一个代理对象，塞入二级缓存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7829145728643216&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOZZNM1sBrrH0juatDb5IQfYUHicgsuJV7SYxCWia9AskoQ0Kkw4CgNhuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;995&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就拿到了 louzai1 的代理对象，解决了 louzai2 的依赖关系，返回到第二层。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 返回第二层&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回第二层后，louzai2 初始化结束，这里就结束了么？二级缓存的数据，啥时候会给到一级呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;甭着急，看这里，还记得在 doGetBean() 中，我们会通过 createBean() 创建一个 louzai2 的 bean，当 louzai2 的 bean 创建成功后，我们会执行 getSingleton()，它会对 louzai2 的结果进行处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33444816053511706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOW1eibGicxv7f0ThvM1hXdp0GeMA0BaY5KCRZIZZQr0F7LxJJdmZ0GWcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;897&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们进入 getSingleton()，会看到下面这个方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3785140562248996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOIDF4icrhq4Iao8gQJrDfeIHz0MNjUBS7ZAEPZjl1CH9dloYX56pr5JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;996&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就是处理 louzai2 的 一、二级缓存的逻辑，将二级缓存清除，放入一级缓存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.368006993006993&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOpT8PriaWibiaAdPP5ODaO47FM3cVyfL8NWvSSs1dQAnfnSuKMa6sKxllg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6 返回第一层&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同 2.5，louzai1 初始化完毕后，会把 louzai1 的二级缓存清除，将对象放入一级缓存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3647912885662432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNO0RMJoTP25eOrA3r2FRKnJib0jtTTAglW2ibFTGygD0QgExl3zNFbDiaOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，所有的流程结束，我们返回 louzai1 对象。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 原理深度解读&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 什么要有 3 级缓存 ？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一道非常经典的面试题，前面已经告诉大家详细的执行流程，包括源码解读，但是没有告诉大家为什么要用 3 级缓存？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里是重点！敲黑板！！！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先说“一级缓存”的作用，变量命名为 singletonObjects，结构是 Map&amp;lt;String, Object&amp;gt;，它就是一个单例池，将初始化好的对象放到里面，给其它线程使用，&lt;strong&gt;如果没有第一级缓存，程序不能保证 Spring 的单例属性。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“二级缓存”先放放，我们直接看“三级缓存”的作用，变量命名为 singletonFactories，结构是 Map&amp;lt;String, ObjectFactory&amp;lt;?&amp;gt;&amp;gt;，Map 的 Value 是一个对象的代理工厂，所以“三级缓存”的作用，其实就是用来存放对象的代理工厂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那这个对象的代理工厂有什么作用呢，我先给出答案，&lt;strong&gt;它的主要作用是存放半成品的单例 Bean，目的是为了“打破循环”&lt;/strong&gt;，可能大家还是不太懂，这里我再稍微解释一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们回到文章开头的例子，创建 A 对象时，会把实例化的 A 对象存入“三级缓存”，这个 A 其实是个半成品，因为没有完成 A 的依赖属性 B 的注入，所以后面当初始化 B 时，B 又要去找 A，这时就需要从“三级缓存”中拿到这个半成品的 A（这里描述，其实也不完全准确，因为不是直接拿，为了让大家好理解，我就先这样描述），打破循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我再问一个问题，&lt;strong&gt;为什么“三级缓存”不直接存半成品的 A，而是要存一个代理工厂呢 ？答案是因为 AOP。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在解释这个问题前，我们看一下这个代理工厂的源码，让大家有一个更清晰的认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接找到创建 A 对象时，把实例化的 A 对象存入“三级缓存”的代码，直接用前面的两幅截图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0824622531939605&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNO9tx6jk4cLlTibhiax6dB67cQkArxyzspw3Wq12yvwORzP8jicB0sPC7rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.478584729981378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOY35CnbLdL7p2QmoyUcc0RTljdc5XUSHCc89UDibjah7Gmn3nSwlmDsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1074&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们主要看这个对象工厂是如何得到的，进入 getEarlyBeanReference() 方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30063291139240506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOxq2eMicDbZibKcXTChXZOT8BB0gS32m6yhhehKzhI3oESHLYOfFhu4RA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;948&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2850194552529183&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNObvFJr4iaatfQ3dmG85qHfpGSTnBE0XCBiaxZ1Htakl1QDwR403SAicdJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14558979808714134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOr1aMYsBoBib2qzI9uhhtvvjAey7P63KhOdqSelcRhlqgLiaMITJaGqAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;941&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6501079913606912&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHqKibakH9hO9wuncU5q2bNOCN3LKbGzmQqWaQ5Oj3bbsIsHXfiankZkBKYcyozYgicOmcWJia8q2paiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一幅图太重要了，我们知道这个对象工厂的作用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果 A 有 AOP，就创建一个代理对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 A 没有 AOP，就返回原对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那“二级缓存”的作用就清楚了，就是用来存放对象工厂生成的对象，这个对象可能是原对象，也可能是个代理对象。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我再问一个问题，为什么要这样设计呢？把二级缓存干掉不行么 ？我们继续往下看。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 能干掉第 2 级缓存么 ？&lt;/h1&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; B b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; C c;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; A a;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;C&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; A a;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据上面的套娃逻辑，A 需要找 B 和 C，但是 B 需要找 A，C 也需要找 A。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;假如 A 需要进行 AOP&lt;/strong&gt;，因为代理对象每次都是生成不同的对象，如果干掉第二级缓存，只有第一、三级缓存：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;B 找到 A 时，直接通过三级缓存的工厂的代理对象，生成对象 A1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C 找到 A 时，直接通过三级缓存的工厂的代理对象，生成对象 A2。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到问题没？&lt;strong&gt;你通过 A 的工厂的代理对象，生成了两个不同的对象 A1 和 A2&lt;/strong&gt;，所以为了避免这种问题的出现，我们搞个二级缓存，把 A1 存下来，下次再获取时，直接从二级缓存获取，无需再生成新的代理对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以“二级缓存”的目的是为了避免因为 AOP 创建多个对象，其中存储的是半成品的 AOP 的单例 bean。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有 AOP 的话，我们其实只要 1、3 级缓存，就可以满足要求。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 写在最后&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再回顾一下 3 级缓存的作用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一级缓存：&lt;strong&gt;为“Spring 的单例属性”而生&lt;/strong&gt;，就是个单例池，用来存放已经初始化完成的单例 Bean；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二级缓存：&lt;strong&gt;为“解决 AOP”而生&lt;/strong&gt;，存放的是半成品的 AOP 的单例 Bean；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;三级缓存：&lt;strong&gt;为“打破循环”而生&lt;/strong&gt;，存放的是生成半成品单例 Bean 的工厂方法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你能理解上面我说的三条，恭喜你，你对 Spring 的循环依赖理解得非常透彻！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于循环依赖的知识，其实还有，因为篇幅原因，我就不再写了，&lt;strong&gt;这篇文章的重点，一方面是告诉大家循环依赖的核心原理，另一方面是让大家自己去 debug 代码&lt;/strong&gt;，跑跑流程，挺有意思的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里也简单说一下我看源码的心得：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;需要掌握基本的设计模式；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;看源码前，最好能找一些理论知识先看看；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;学会读英文注释，不会的话就百度翻译；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;debug 时，&lt;strong&gt;要克制自己，不要陷入无用的细节&lt;/strong&gt;，这个最重要。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中最难的是第 4 步，因为很多同学看 Spring 源码，每看一个方法，就想多研究研究，这样很容易被绕进去了，这个&lt;strong&gt;要学会克制，有大局观，并能分辨哪里是核心逻辑&lt;/strong&gt;，至于如何分辨，可以在网上先找些资料，如果没有的话，就只能多看代码了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的源码解析就到这，Spring 相关的源码，还有哪些是大家想学习的呢，可以给楼仔留言。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近苏三的知识星球&lt;span&gt;【&lt;/span&gt;&lt;strong&gt;Java突击队&lt;/strong&gt;&lt;span&gt;】&lt;/span&gt;，每天都会更新很多干货内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很多独家的干货内容，比如：Java后端学习路线，分享实战项目，源码分析，百万级系统设计，系统上线的一些坑，MQ专题，真实面试题，每天都会回答大家提出的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几天星球开通了3个优质专栏：痛点问题、高频面试题 和 性能优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个专栏都是大家非常关心，和非常有价值的话题，我相信在专栏中你会学到很多东西，值回票价。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7395498392282959&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaPxc765sjP7TcEYkDRJbLiaEIzibSG6n0w5wcoZichIW3qRndfp7PuKMpM3d5JLAllZmqCNa3tqEtrw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;622&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7615894039735098&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaPxc765sjP7TcEYkDRJbLiaSEibZt9Z2nAeibNxed5wISI48LtfSWWHf3K6wKXmF3Q4l3YLkjTyAanw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;604&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1194539249146758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaPxc765sjP7TcEYkDRJbLia8dck1h5FMgUaabq86Nbz8m3Rln43Jad9VsfGnnbxNmj2TicbOqNnO0g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;586&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我最近申请了新的一批优惠券，目前还剩十几张，估计今天就会抢完，需要加入星球的小伙伴，直接扫码即可。（快，快，快）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.215625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5iaPxc765sjP7TcEYkDRJbLiaibyx8vKqwfBQbWPhGNjJwczTvDvgmBwBzILj3WiaNPkibibeLCS9eERibAA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d8f2c021e5b588e50e62a235fbb6fb7d</guid>
<title>八万字《高并发的哲学原理》第四章：隐藏在语言背后的魔鬼——运行架构为何会成为性能瓶颈</title>
<link>https://toutiao.io/k/xlmc73o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;本文共 4200 字，阅读大约需要 14 分钟。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;编程语言的性能差异是程序员社区经久不衰的话题，但当你对各种技术的了解越深入，就越能感受到各种语言的本质区别：不同语言的设计方向不同，就像时间换空间、空间换时间，他们只是选择了一种优势找信息之神换成了另一种优势罢了。&lt;/section&gt;&lt;p&gt;没有任何编程语言是单纯的“语法集合”，每一种语言都是它背后“运行架构”的体现，语言之间的差异本质上就运行架构设计方向的差异。&lt;/p&gt;&lt;h2&gt;web 系统规模发展史&lt;/h2&gt;&lt;p&gt;web 1.0 时代，各种静态、动态、解释型、编译型、虚拟机型语言百花齐放，因为当时系统规模和系统用户都比较少，而资源则大多以静态 HTML 页面的形式显示，技术上大家都熟悉哪个用哪个，这些后端技术也大多能满足需求。&lt;/p&gt;&lt;p&gt;web 2.0 时代，真正的高并发系统出现了，一分钟内需要写入数据的用户数超过了百万，这个时代，最终锤炼出了 Java 和 PHP 两种技术：PHP 擅长简单 CURD，而 Java 擅长事务处理（例如电商下单）。这个时代发展到顶峰，就是手机 APP 和大前端的时代：界面由前端完全掌控，后端团队提供稳定高性能的 API 即可。&lt;/p&gt;&lt;p&gt;在 web 生态发展的过程中，也催生出了如 Python、Ruby、Scala、Node.js 这样的后端技术之花，但他们在冲向顶峰后也迅速落幕，现在连 PHP 也在逐步退场，只有 Java 由于拥有完善的微服务基础设施，暂时看起来还安全。&lt;/p&gt;&lt;p&gt;web 2.0 后期，乔布斯将人类拉入了移动互联网时代。今天的互联网巨头们，同时在线用户量动辄上亿，对系统性能的需求发生了爆炸性的增长，也催生出了 PHP 的接班人：go 语言。十多年前我第一次写 go 的时候就认识到，它就是 C with net，自带网络库的万能底层语言，可以让普通开发者轻松写出超高性能的应用。&lt;/p&gt;&lt;h3&gt;语言特性如何决定性能&lt;/h3&gt;&lt;p&gt;PHP 语言是一种单线程全阻塞语言：在每个 HTTP/FastCGI 请求中，PHP 解释器会启动一个 进程/线程 来运行一段 PHP 代码，在运行的时候，无论是读写磁盘（磁盘 IO）还是读写数据库（网络 IO），PHP 线程都会&lt;code&gt;停下来等待&lt;/code&gt;：此时并不消耗 CPU 资源，但是 TCP 和线程资源都还在持续等待，如果这个请求不结束，那该线程将会一直保持运行，持续消耗着 TCP 和内存资源。&lt;/p&gt;&lt;p&gt;由于语言本身的运行架构一致，所以 php-fpm 和 Apache 执行 PHP 的性能是一致的。在 2 vCore 4G 内存的情况下，PHP 200QPS 的性能极限是无法通过把 Apache 换成 php-fpm 来解决的。&lt;/p&gt;&lt;p&gt;那么阻塞式运行架构的性能瓶颈应该怎么突破呢？轮到 Node.js 登场了。&lt;/p&gt;&lt;h3&gt;Node.js 的非阻塞 IO&lt;/h3&gt;&lt;p&gt;在阻塞式语言中，所有的 IO 操作都是需要停下来等待的，例如磁盘 IO，数据库网络 IO 等，而真正用于计算的 CPU 资源反而大多数时候在浪费：绝大多数 API 不需要多少复杂的数据转换，更多的时间花在了和各种数据库的通信上。而世界上绝大多数语言都是阻塞式运行的，因为这样做虽然性能不高，但却最符合人类大脑的习惯，编码也更加容易。在当时，高性能大多是用多核+多进程/线程来实现的。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Ryan Dahl&lt;/code&gt; 敏锐地发现了 IO 浪费时间这个问题，并且挑选了一个为浏览器创造的单线程语言 JavaScript 来实现他的抱负：将所有 IO 操作全部异步化，并利用 js 的单线程排队特性，创造了一种高性能且稳定的后端技术：Node.js。&lt;/p&gt;&lt;p&gt;不过，计算机的世界没有银弹，Node.js 虽然性能强，但是代码编写起来更加困难，需要多付出一些异步编程的思考时间，debug 也更加地困难。&lt;/p&gt;&lt;p&gt;Node.js 是一种非常神奇的单线程异步非阻塞架构，以 Google v8 引擎作为 JavaScript 解释器，利用事件驱动技术，大幅提升了单机能够处理的 QPS 极限，而它“只是完整利用了单核 CPU”而已。&lt;/p&gt;&lt;p&gt;此外，Node.js 还具备一个 Nginx 的优势：可以单机处理海量用户的 TCP 连接。&lt;/p&gt;&lt;p&gt;你看，背后的哲学原理都连上了吧。&lt;/p&gt;&lt;p&gt;Node.js 可以完整利用单核 CPU 了，那现在的服务器 CPU 已经做到了单颗 96 核 192 线程，该如何利用这么多的 CPU 核心呢？该 golang 登场了。&lt;/p&gt;&lt;h3&gt;go 语言的协程&lt;/h3&gt;&lt;p&gt;为了更好地“直接利用全部 CPU”，Java 诞生了线程池技术，至今还在发光发热；而 golang 选择釜底抽薪：在语言层面打造一个完善的“超并发”工具：goroutine（协程）。&lt;/p&gt;&lt;p&gt;我之所以将 goroutine 称为“超并发”工具，是因为它是语言提供的一个 线程池+协程 的综合解决方案，并使用 channel 管道思想来传递数据，为使用者提供了一个无需手动管理的高性能并发控制 runtime，可以保证完全榨干每一个 CPU 时间片。&lt;/p&gt;&lt;p&gt;golang 的协程本质上来讲就是 &lt;code&gt;在一个线程内不断地 goto&lt;/code&gt;，就像 DPDK 完全在用户态运行由于避免了上下文切换而大幅提升了网络性能一样，golang 在线程内主动 goto 也可以轻松将 CPU 利用率顶到 100%，实现硬件资源利用的最大化。&lt;/p&gt;&lt;p&gt;当然，&lt;code&gt;不断地 goto&lt;/code&gt;只是一种形象的类比方法，实际上 golang 的协程技术经历了好几次迭代，具体实现大家可以看灯塔 draveness 的书：《Go 语言设计与实现》¹。&lt;/p&gt;&lt;p&gt;实际上“吃完多核服务器上的每一个 CPU 核心”也是各种新形态 MySQL 兼容数据库的主要价值，这个我们在倒数第二篇文章讨论数据库架构时会进行详细分析。&lt;/p&gt;&lt;h4&gt;goroutine 的弱点&lt;/h4&gt;&lt;p&gt;就像性能优化的核心是空间换时间、时间换空间一样，goroutine 也不是银弹，也是牺牲了一些东西的。根据我的实践，这个东西就是“极其昂贵的内存同步开销”，而且 goroutine 引发的这个问题比 Java 的线程池内存同步问题严重的多。&lt;/p&gt;&lt;p&gt;一旦你想在单个 golang 进程内部的海量协程之间做“数据同步”，那你面临的就不只是 CPU 资源浪费那么简单了，你会发现，CPU 依然吃完了，但是并发量还是好低：多线程的内存同步开销已经摧毁了无数根 Java 程序员的头发，goroutine &lt;code&gt;线程 * 协程&lt;/code&gt; 的内存同步性能堪称灾难:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6669921875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA0Wne5kN5NnksBHL8oT5P44SH8S8s1KpEh8UmUDziaOHf8GHD860kcoedIYoRoaK5z4ia1kAex48nJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;center&gt;&lt;code&gt;sync.Map&lt;/code&gt;受害者请高举你们的双手！&lt;/center&gt;&lt;p&gt;那如果我们需要在海量协程之间做实时数据同步该怎么办呢？这个时候，高并发哲学思维又要出动了：找出单点，进行拆分！&lt;/p&gt;&lt;p&gt;等等，好像除了唯一的这个 golang 进程找不出单点啊？&lt;/p&gt;&lt;p&gt;没错，这个唯一进程申请的这段内存就是单点，想解决这个问题需要出大招：找外援。&lt;/p&gt;&lt;h4&gt;Redis 是 golang 协程最亲密的伙伴，就像 MySQL 之于 PHP&lt;/h4&gt;&lt;p&gt;网络栈是一种贯彻了 linux 一切皆文件思维的优秀工具，此时可以帮上大忙：找另一个单线程性能之王 Redis 打辅助，即可帮助海量协程排队：此时一旦某个协程进入网络 IO 状态，则会立即让出 CPU 时间片：goto 到下一个协程，不浪费 CPU 资源。&lt;/p&gt;&lt;p&gt;当然，你也可以选择自己用 golang 写一个类似 Redis 的单线程内存数据库，和你的业务进程进行网络通信，也可以解决这个问题。&lt;/p&gt;&lt;p&gt;一旦解决了协程之间内存同步的问题，golang 就开始胡吃海塞，大杀四方，榨干 CPU 的全部性能潜力。&lt;/p&gt;&lt;h3&gt;Java 技术的优势&lt;/h3&gt;&lt;p&gt;Java 是一整套基于运行时虚拟机技术的解决方案。总体来看，它选择了“空间换时间”：Java 应用对内存的需求量显著超过其它技术，而经过了这么多年的优化，Java 的“时间性能”在绝大多数场景下都已经做到了无限接近 C++ 的水平。&lt;/p&gt;&lt;p&gt;Java 虽然是虚拟机技术，但它是常驻内存的，并且这个技术非常的灵活。对，你没有看错，Java 技术确实非常灵活。spring 框架对写代码程序员的约束确实很强，但这是对使用者的繁琐，Java 本身是非常灵活的。&lt;/p&gt;&lt;p&gt;经过了这么多年的发展，Java 其实一直都能跟上时代：JDBC、RMI、反射、JIT、数字签名、JWS、断言、链式异常、泛型、注解、lambda、类型推断等等等等。我们知道，传统的 Java 大多采用线程做并行，但是在今年（2022）它甚至发展出了协程 &lt;code&gt;Fiber&lt;/code&gt;！&lt;/p&gt;&lt;p&gt;21 世纪头十年，JVM 在很多公司内都变成了代替虚拟机技术的存在，成为了事实上的“标准服务端运行环境”，以至于诞生了 JPython、JRuby、JPHP 等颇具邪典气质的技术：把动态语言的解释器内置到 JVM 内，再把代码和解释器打包成一个 jar/war，让 JVM 可以直接运行 Python、Ruby、PHP 项目。&lt;/p&gt;&lt;p&gt;这是什么，这就是容器技术啊！&lt;/p&gt;&lt;h3&gt;总结一下&lt;/h3&gt;&lt;p&gt;PHP 的模型最原始，鲁棒性最强，对垃圾代码的兼容性更强，甚至可以看做一种“半微服务”技术（因为多文件），但是性能也最差。&lt;/p&gt;&lt;p&gt;Node.js 实现了非阻塞 IO，但是只能利用一个 CPU 核心，这导致它的高性能还需要依赖基础架构（进程管理器/虚拟机/k8s）才能够发挥出来。&lt;/p&gt;&lt;p&gt;而 golang 自带“线程+协程”的超并发解决方案，让只拥有一台笔记本的大学生也能随时对一个网站发起 5000QPS 的 DOS 攻击。让一个没有完善运维团队的小公司程序员，在不依赖并行基础架构的情况下，能够在裸金属服务器上用一个进程直接吃完全部的 CPU 资源，支撑起可观的用户量。&lt;/p&gt;&lt;h3&gt;还记得我们的目标吗？一百万 QPS&lt;/h3&gt;&lt;p&gt;通过使用 golang，我们依然使用前面那台双路 E5-2682 V4 64 vCore，在数据库性能足够的情况下，我们可以把单个系统的 QPS 从 5000 提升到 50000，并且可以在裸金属服务器上直接部署，不需要虚拟机/k8s 并发基础设施，甚至都不需要前置一个负载均衡器。&lt;/p&gt;&lt;p&gt;当然，现实中 50000 QPS 的系统几乎必然拥有负载均衡器，即便每个接口只返回 20KB，那网络带宽也已经达到了 976MB/S，即 7.8Gbit，单机带宽都快干到 10G 了，肯定是不会只用单台服务器硬抗的，即使单机性能能达到，那单机也无法保证这么大规模系统的稳定性。这个时候我们就需要负载均衡器的介入，接下来两篇文章我们会详细讨论。&lt;/p&gt;&lt;h3&gt;接下来&lt;/h3&gt;&lt;p&gt;下一篇文章，我们将着手拆分“监听 HTTPS 443 端口的进程”这个单点，探寻负载均衡技术的发展历程，普及应用网关、负载均衡、LVS、网关和交换机的性能特点，并在再后面一篇文章讨论 200 Gbps 带宽的负载均衡集群该怎么搭建。&lt;/p&gt;&lt;h3&gt;参考资料&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;《Go 语言设计与实现》 https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#651-%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5b3e152b991520c78d0b3e35ea851fcb</guid>
<title>前有 45 亿数据被扒，现在 Go 工具链想要我的使用数据，你愿意吗？</title>
<link>https://toutiao.io/k/zxgzygk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前两天有读者提醒我关注 Go 大当家 Russ Cox 发起的 Go 工具链中的遥测（&lt;span&gt;telemetry in the Go toolchain&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;）讨论。不看不知道，一看下一跳。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4hUFU6qSm5ib5w0g2X3BSFia3iajKWzkJVibqyIIoyEK1f2w1N2hL6jFWvMTekCSeG6lMbBFS7ZF77ZVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天来分享一些看法和信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么要收集数据&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Russ Cox（下称 rsc）发起的背景是 Go 开源项目的开发者（例如：Go 核心团队）在没有遥测的情况下，会遇到如下的场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;需要依赖外部的错误报告（例如：GitHub issues）来了解他们自己写的软件如何在意料之外发生异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调研&lt;/span&gt;&lt;span/&gt;用户是如何使用自己写的开源项目，是否符合预期，又或是创造出了新的用法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么一听，好像和我们平时的认知也差不多。换位思考一下，Go 核心开发者就比较头疼了。认为这两种方式作用都很有限，达不到他们想要的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此想要抽样收集用户的使用数据，便于 Go 团队更好的开发和调研。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;被局限的例子&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;错误报告&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们会提交错误报告，一般只会出现在类似 ”我们预期这事应该能正常跑起来，但你居然没有跑起来“ 的场景下。在现有的情况下，如果程序在不影响正确性的情况下出现了错误行为，用户就不可能注意到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反之，如果实施了遥测（收集数据），开发者就可以通过 Go 工具链收集上来的统计数据发现异常。（有抓手了）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体案例，rsc 说明了在 Go 1.14 版本的发布中，对 macOS Go 发行版的构建方式进行了更改，造成使用 net 包（使用 cgo ）编译任何程序都需要安装 Xcode。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不是他们所预期的，是意外之外的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在发生这问题的三年内，没有任何人报告过这个错误。用户只是简单地接受了这是必要的安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直至近期，Go 核心团队排查其他问题，才发现有这个坑。如果有遥测收集使用数据，那这个问题完全可以被避免。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调查用户&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 开发团队想知道 ”用户想用 Go 做什么“，或是想基于数据用于做一些新老功能版本的决策。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但现在开源项目普遍都很难，他们只能发调查报告，就像我们每年填的 Go 开发者调查报告，就是这个目的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4hUFU6qSm5ib5w0g2X3BSFia3Dic8g8hWRbuLAA0pb7QaIuPNVly0BCKxsaKYfQeqCibcY6T49eCiaPM8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;figcaption&gt;Go Developer Survey 2022 Q2 Results&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 rsc 对调查报告也是不满足的。因为只是一个小样本，效果有限。且需要大量的用户选项和回复才能得到相对准确的测量结果，比较浪费时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体案例，rsc 举例 go 开源项目，经常会在新版本增加开关，再逐步去掉的做法。像最近宣布 Go 1.21 起将不再支持 macOS1.13/1.14，马上就收到了用户的反馈，要求保留。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有遥测收集使用数据，这个问题将有具体的数据作为决策支撑。就跟我们平时前端同学，会收集用户端的操作系统和版本作为是否支持 IE 的依据等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;想收集什么数据&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说要收集，会在哪收集，具体要收集什么呢？会收集的地方主要是 Go 工具链，例如：Go 命令、Go 编译器、Gopls 等地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收集的数据，将至少包含工具链的基本信息，例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Go 工具链版本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是什么操作系统和架构构建的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主机操作系统版本（例如：Windows8）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 工具链使用的其他工具的粗略信息，例如本地 C 编译器（例如：gcc 2.95）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不会包含任何形式的身份信息，例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;没有用户登录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有机器 ID。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有 MAC 地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有 IP 地址，没有 IP 地址前缀。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有地理位置信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有随机生成的伪 ID，没有其他种类的标识符。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收集的数据会在 Go 网站上公布，定时展示统计图表等，便于所有 Go 开发者审阅和查看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;社区争议满满&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;绝大部分开发者是没有直接同意 rsc 这么干的，主流的回复分成了三派。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;直接拒绝，觉得这是在侵犯个人隐私。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建议做成可选项，例如：限时选择上报、选择上报（使用 Go 时弹出 Cookie 弹窗、抛出异常时弹出弹窗）等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接抵制，认为 Go 重蹈 Google 后路。用词强烈，要求 rsc 公开道歉，表示这是推下悬崖的选择，降低了信任。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体来看，参与讨论的 Go 开发者都非常关注 ”隐私“ 的问题。更建议做成可选项，也就是用户选择上报。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果以后写 Go 的时候弹出 Cookie 弹窗还是很 ”有趣“的吧（doge。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 核心团队本身的出发点是好的，他们在维护 Go 开源项目时，经常拿不到一些关键数据和信息，导致在做决策时很纠结。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这在业务应用中，比较常见的是在前端埋探针，获取你的客户端信息等。但这是闭源的，整体风险没有那么大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但对于开源项目来讲，这是开源的，受到所有人的检阅。这类隐私数据收集，在台面上直接默认上报肯定是不可行的，争议会比较大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果来看，由于没有更多新的内容，比较情绪化，这个讨论已经被中止。未来如果做，我猜更大概率是做成可选项，询问式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后的最后，对于 Go 工具链收集使用数据，欢迎投出你关键的一票：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;vote_area&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐阅读&lt;span/&gt;&lt;/h4&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;telemetry in the Go toolchain: &lt;em&gt;https://github.com/golang/go/discussions/58409&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注和加煎鱼微信，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一手消息和知识，拉你进技术交流群&lt;span&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9988738738738738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jVkzHVvaqjo3O0BIqDRJKkEyib7SJsryxHBFGsvek0FkdiczfJP6AdbWnK25DvlX3dY8wRObPbVJQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;888&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07106598984771574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/486RHs1WbcgGib6o96dHbvGUGGwPicd8wusUGH1cXR29tM4bO0lNzialzkQhvU6m5ZUdaKibmcF2OQayjMe9Bia6iaXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是煎鱼，&lt;span&gt;出版过 Go 畅销书《Go 语言编程之旅》，再到获得 GOP（Go 领域最有观点专家）荣誉，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247483854&amp;amp;idx=1&amp;amp;sn=ec422fbf4d846975f2930ddeb5e81373&amp;amp;chksm=f9041493ce739d85a4b987eece14da627206cdad798f645cc770868312e4a22b6df24804f186&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击蓝字查看我的出书之路&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点击蓝字查看我的出书之路&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日常分享高质量文章，输出 Go 面试、工作经验、架构设计，&lt;span&gt;加微信拉读者交流群，和大家交流！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa01fc25eed7d870e772ca1b05763eef</guid>
<title>提高 IT 运维效率，深度解读京东云 AIOps 落地实践（异常检测篇（二））</title>
<link>https://toutiao.io/k/y9too8t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h3&gt;&lt;strong&gt;作者：张宪波、张静、李东江&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;如何提高IT运维效率是众多运维人员的难题，这不仅是对内容繁杂、持续变化、支持不同的业务需求加以描述、加载和维护，更要对运维和业务运维需求、过程、结果的管控，以及对整个管理信息系统运行状态的管控。京东云AIOps的时间序列异常检测识别故障对系统效率大大提升。它能基于深度学习对运维时序单指标和多指标指标进行异常检测，快速发现线上业务问题，为运维人员降本增效。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;基于深度学习对运维时序单指标和多指标指标进行异常检测，快速发现线上业务问题&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;时间序列异常检测识别故障对系统的正常运行颇为重要，准确率高的异常检测对系统的稳定性具有重要意义。时间序列的异常检测已经研究了几十年，业界提出了各种有效检测方法。我们提出了一种基于深度学习的时间序列异常检测模型。该模型由三条并行管道组成，每条管道包含一个卷积单元，该卷积单元与改进的注意力机制串联，负责时间和空间特征提取。在京东内部多个数据集对所提出的模型进行评估，结果证明了所提出模型的有效性，所改进的注意力机制的在运维多指标异常检测上有较好的表现。&lt;/p&gt;

&lt;p&gt;为了确保系统稳定运行，需要用一个或者多个指标来评价系统是否在正常运行，常用的评价指标有单变量时间序列(UTS)和多变量时间序列(MTS)。例如，交易量和网络流量是关于在线支付的两个常用监测指标。挖掘时间序列的异常值对于系统的稳定性以及根因分析都具有重要意义，及时发现这些异常值，可以有效的降低故障的发生的概率。&lt;/p&gt;

&lt;p&gt;现有的时间序列异常检测分析方法大致可分为基于深度学习的方法、基于非深度学习的方法和传统方法。自回归移动(AR)及其变量如自回归平均模型(ARMA)和自回归求和滑动平均模型模型(ARIMA)是分析时间序列的一些基本方法。动态时间规整(DTW)是另一种基于距离的经典异常检测方法，其变种如 DTW-I、 DTW-D 和 DTW-A为常用的baseline方法。异常检测也可以简单看成二分类问题，所以机器学习算法，如隐马尔可夫模型(HMM) ，k 最近邻(k-NN)和支持向量机(SVM) ，也是用于异常检测的常用算法。&lt;/p&gt;

&lt;p&gt;上述方法为时间序列分析打下了基础，然而，为了更好地适应特定的实际领域，非深度学习方法不能适应计算机系统复杂和动态的变化,这也是非深度学习方法的一个局限性。深度学习具有强大的特征提取和行为预测能力，这使得深度学习可以很好的适应异常检测，特别是对于有大量输入信息和动态特征的情况。&lt;/p&gt;

&lt;p&gt;卷积神经网络(CNN)是实现深度学习的最常使用的框架之一，并逐渐成为图像处理方面的主流技术。除了卷积神经网络(CNN)之外，递归神经网络(RNN)因其对历史信息的记忆能力而在时间序列的异常检测有着很好的表现能力。基于类似的 RNN 设计，其变种长短期记忆人工神经网络(LSTM)和门控递归单元(GRU)在时间序列异常检测问题上具有更好的性能。&lt;/p&gt;

&lt;p&gt;基于 DL的时间序列异常检测模型，如 MC-DCNN ，ALSTM-FCN ，C-LSTM ，TapNet 等在业界被频繁使用。与基于非深度学习的方法相比，这些模型需要很少的先验知识，但能够获得更好的检测结果，特别是当涉及到复杂和传统方法难以解决的情况时，深度学习方法能够很好的处理。&lt;/p&gt;

&lt;p&gt;注意力机制已成为业界算法同学的一个广泛选择，基于深度学习的框架结合注意机制往往获得更好的性能。它也被用于异常检测任务，我们对现有的时间序列分析注意机制进行了细微的改进，以更好地适应实际应用。&lt;/p&gt;

&lt;p&gt;我们提出了多注意综合卷积网络(Mac-net)异常检测模型。时间序列以快照的形式存储输入到 Mac-net模型中，Mac-net模型由三条平行的卷积注意管道和一个全连接组成。卷积注意管道包括 CNN 单元和改进注意力单元。CNN 单元负责空间特征提取，注意单元负责时间特征提取。我们改进的注意力机制将大部分权重分配给重要的历史输入，同时抑制其他较不重要的输入，从而优化权重分配。&lt;/p&gt;

&lt;p&gt;模型要检测的时间序列可以是 UTS 或 MTS，这三个并行管道设计为多尺度感知器。我们设计的注意力机制可以很好地捕捉时间序列异常序列的内在特征，通过更多地关注与当前序列严重偏离的历史序列来进行预测，主要是因为这些序列在识别异常与否时比其他序列贡献更大。&lt;/p&gt;

&lt;p&gt;我们的模型创新点主要体现在以下两个方面: 提出了一种新的基于深度学习的网络结构 Mac-net，并设计了一种专门用于时间序列分析的放大注意机制，使用公共数据集和京东数据集进行了实验评估，证明了 Mac-net 的有效性和可扩展性。详细模型技术细节如下：&lt;/p&gt;

&lt;p&gt;我们首先简要介绍时间序列的异常检测，然后详细说明了 Mac-net 模型的设计细节，以及我们所提出的放大注意机制的算法实现。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;时间序列的异常检测&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;假设一个时间序列的周期为X = (x0,x1,...,xt-1,xt)，其中t是当前序列的时间戳，而元素 xi，i ∈[0，t] 是在时间戳 i 处的 m 维观测值，因此，X 是一个矩阵X∈Rmxn。具体来说，如果 m = 1，X 是 UTS，如果 m &amp;gt; 1，则是 MTS。异常检测是确定当前序列 xt 是否异常。我们采用时间序列的快照图像作为输入，为 CNN 处理提供了方便。简单来说，我们检测的是包含 xt 的子序列，而不是单个点。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;Mac-net模型&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;Mac-net 模型的总体架构，包括两个主要块，即三个平行的管道和全连接(FC)层。其中，并行管道负责特征提取，CNN 单元提取空间特征，注意力单元提取时间信息，实现权重分配。每个 CNN 单元包括卷积层、批归一化层、激活层和Dropout层。这三条管道的卷积层都有16个内核，它们的步长为1。这三个管道的内核大小分别为2x2、3x3和5x5。除了内核大小之外，所有其他设置在三个管道中保持不变，我们使用 ReLU 作为激活函数，Dropout率为0.4。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7428b7fbe4664fee92b035814f6473ed%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图1 Mac-net 的体系结构示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;输入为 h + 1快照图片，包括一个当前序列和 h 历史序列，并同时输入到三个并行管道中。每个通道地输出相加并取平均值以进行最终检测。并行管道具有不同的内核大小，因而具有不同的感知域。时间序列的快照照片不同于一般的人像照片。尽管在快照图片中有多条曲线(UTS 的一条曲线) ，但图片的大部分区域是空白的，这意味着图片值矩阵中的大多数数字为零，如下图2所示，在这种情况下，单一大小的卷积内核可能无法获得全面的洞察力。三条平行管道的混合可以很好地克服这一问题。不同大小的卷积核可以互补地工作，并提供全面的感知。根据我们的实验结果可得， 2x2、3x3和5x5的组合效果最好。每个 CNN 单元后面跟着一个注意力单元。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f30c2614596442bb6e3625e176b417a%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图2 (a) UTS 输入序列，(b)值矩阵&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;﻿
最后将每个管道的注意力输出的结果输入到后面的全连接层中。由于每个管道的卷积核大小不一致，所有管道输出的结果直接求和是不行的。在注意力机制后面加个全连接层，以统一输出形状，从而使求和成为可能。总和的平均值最终输入到统一的全连接层。后面包括两个全连接层，分别是32个和2个神经元。最终输出结果是当前时间序列是否为异常。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;放大注意力机制&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;注意机制最初被提出用于机器翻译，并很快成为集成在深度学习体系结构中的主要设计方法。注意机制的基本思想是模仿生物系统，即使感知到大量的信息，它们也会有意识地关注感知的某些部分。常用的注意机制如加性注意机制、放缩点积注意机制等需要额外的查询参数和关键矩阵计算，这肯定会增加计算开销。此外，这些注意机制计算出的权重被简单地分配给每个元素。为了进一步加强重要因素对注意的影响，同时抑制那些不相关的片段，在深入研究内在时间序列的基础上，我们提出了一种放大注意机制。&lt;/p&gt;

&lt;p&gt;注意力机制最常用的形式之一，如(1)所示，是缩放点的产生。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5b4c39b53104bd4bae4bd6e6eba099c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a84210afccb84c7bb1ef09de0f496a6b%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;缩放后的点生成，“柔和”地最大化了那些具有较大相似性的元素所产生的效果。对于时间序列而言，与待检测时间序列偏差最大的历史序列对最终决策的贡献最大。以下图3中的UTS输入为例。红色虚线框是要检测的序列，蓝色虚线框为所需的历史序列。显然xt-2与xt的偏差最大。根据实际经验，与xt-1和xt-3相比，xt-2被认为是识别xt异常状态的优先参考。鉴于这种先验知识，在抑制分配给其他权重的同时，放大分配给xt-2的权重是非常必要的。因此，我们试图减少分配给那些不太重要的部分的权重。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eeeffe2b4174a46af04c5e7bfc63371%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图3 UTS输入样例&lt;/p&gt;

&lt;p&gt;红色段xt将被检测，蓝色段xt-1、xt-2和xt-3是作为辅助参考的历史数据段。&lt;/p&gt;

&lt;p&gt;实现放大注意力机制有三个主要步骤。首先得到表示历史片段 xt-h ~ xt-1与当前片段 xt 相似性的相似向量 S = (st-h，st-h+1，... ，st-1)。所需的历史片段数 h，可以根据异常模式确定，通常可以通过试验确定。在我们的示例中，h 被设置为10，这意味着当前检测需要过去的10张历史快照照片。相似度计算方法有很多种，我们选择了余弦距离，如(3)所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d828fcb522ea4343a50c214f5a79db8d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如上所述，我们的目标是挑选出偏离 xt 最多的片段，即相似向量的最小元素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c04613e27c604802aa60df8466e5336c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其次，根据相似性结果得到权重向量w。与直接将相似性结果 放softmax运算的缩放点生成不同，我们使用log代替exp运算，并将权重向量分成两部分。正如我们所提到的，我们加大了重要历史片段对模型结果所产生的影响。我们使用log操作，因为当输入在[0,1]内时，值的变化比exp严重得多。&lt;/p&gt;

&lt;p&gt;基于以上公式（4），smin是最终识别的最有价值的信息。同时，[st-h，smin-1]和[smin+1，st-1]不那么重要。为了扩大对重要序列片段的关注，我们将权重计算范围缩小到[smin，sh-1]，因为这一子时段包括xt的最近相邻的序列。[st-h，smin-1]被赋值为一个很小的值，因为它们远离xt。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3569156a8ee647b3a21914f64ad007b8%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注意力机制的最后一步是得到结果的乘积乘以权重矩阵并归约，即注意力输出＝reduce_sum（x’· w） 表I给出了注意机制的算法过程。&lt;/p&gt;

&lt;p&gt;表一 放大注意机制算法&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fd421d158f6450cbed02e3642256c23%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于在 Mac-net 中有三个管道，我们得到三个独立的注意力输出，即 、 和。这三个注意力输出的平均值作为并行管道的最终输出，输入到全连接中进行最终输出。&lt;/p&gt;

&lt;p&gt;通过我们京东内部数据和公共数据集实验评估来证明 Mac-net 在异常检测任务中的有效性。我们首先在两个 UTS 公共数据集和两个 MTS 公共数据集上评估模型。为了进一步说明该方法在实践中有良好的扩展性和有效性，我们还使用了我们京东内部两个数据集作为测试集。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;数据集&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;我们使用两个 UTS 公共数据集和两个 MTS 公共数据集来演示 Mac-net 的异常检测性能。注意，一些公共数据集最初并非用于异常检测，而是用于时间序列的二分类。尽管如此，异常检测基本上是一项二分类的任务。因此，进行这些实验具有一定的有效性。&lt;/p&gt;

&lt;p&gt;两个 UTS 数据集是从 Numenta Anomaly Benchmark (NAB)数据集中选择的。这两个 MTS 数据集收集来自不同领域的各种 MTS。我们选择了SelfRegulationSCP2和Wafer，因为它们的维数和类别与我们的实际情况相似。除了公共数据集，我们选取了两个京东内部模型落地的数据集 A 和 B。下图4显示了两个数据集的正常序列(标有 a 的蓝框)和异常序列(标有 b 的红框)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c78b2014b6e9422897717a68d86f2a94%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图4 数据集 A 和 B 的(a)正常和(b)异常序列的显示&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;模型评估&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;Mac-net模型 首先在上述六个数据集上进行了测试，来证明我们提出的放大注意力机制具有效果提升作用。检测结果见表二。我们选取精确度，召回率，以及 F1-score(F1)作为评估指标，公式如下，其中 tp、 fp 和 fn 代表真正的阳性、假阳性和假阴性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f78c171c1c94145a6c8e7cc65ea49a8%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从表二中我们可以看出，Mac-net 在所有测试数据集上获得了最佳性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;表二 MAC-NET 在六种数据集上的评价结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae856b778df74032835ce614637a62e0%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过模型评估证明了我们的注意机制对现有方法的有一定的提升。同时我们构造了两个比较模型 Abl-mdl-1和 Abl-mdl-2。Abl-mdl-1和 Abl-mdl-2都与 Mac-net 共享相同的架构，只是注意力单元不同。Abl-mdl-1用缩放点产生取代 Mac-net 中的扩大注意机制，Abl-mdl-2用 LSTM 层(16个单元)取代扩大注意机制。从结果可以看出，我们的注意机制优于常用的注意机制和 LSTM 操作。放大注意力机制是基于时间序列的内在特征设计的，并试图以最优方式分配权重。&lt;/p&gt;

&lt;p&gt;除了更好的检测精确度外，我们还评估了我们的模型与两个模型（Abl-mdl-1和Abl-mdl-2）的收敛速度，如下图5所示。两个基于注意力的模型，即Mac-net和Abl-mdl-1，都实现了最快的收敛，而Abl-mdl-2则较慢。与其他两个模型相比，在15-20个时期的训练期间，Mac-net震动更少，即到了更稳定的状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ea417849e7141bc890446f7c49a350d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图5 Mac网络、Abl-mdl-1和Abl-mdl-2的收敛速度&lt;/p&gt;

&lt;p&gt;• &lt;a href=&quot;https://aiops-themis.jd.com/publication/9762449/&quot;&gt;Multi-Attention Integrated Convolutional Network for Anomaly Detection of Time Series&lt;/a&gt;. ICCAE.&lt;/p&gt;

&lt;p&gt;•&lt;strong&gt;ieeexplore检索：&lt;/strong&gt; &lt;a href=&quot;https://ieeexplore.ieee.org/document/9762449&quot;&gt;https://ieeexplore.ieee.org/document/9762449&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05c881afbe7a480da57520cc40f69dec%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;•&lt;strong&gt;团队介绍：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;京东科技从2018年开始建设智能运维，基于京东多年一线运维经验，以大数据和人工智能技术为抓手，形成以应用为中心的一体化智能运维解决方案。利用京东内部历年大促场景的数据积累，对算法进行不断的优化训练，在监控、数据库、网络、资源调度等多个纵向场景取得突破，可移植性强，自研通用化智能基线算法学件10+，自研通用化异常检测算法学件10+，场景化异常检测算法方案5+，具备多种自研通用化根因定位算法学件，可以自动触发多维实时根因定位 ，从上万维度属性值中定位到根因维度，自研5种以上增量式学习模板提取与相关分析算法学件，运维知识图谱内涵盖节点30W+，以应用为中心向外延伸出的图谱关系达90W+，赋能根因分析快速精准查询调用。发表IEEE国际会议论文（AIOps方向）8篇，申请40余项智能运维专利。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>42d50daf13778f33590c047d1986a94c</guid>
<title>我们如何进行 Alibaba.com 买家性能优化？</title>
<link>https://toutiao.io/k/ld6ke0q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJcsSeCtC29A4iaz5pxq31hbxWknDicDPNXKib6eDVIKlz6zWqTGaG1UQNfGauicadFf6P17dyNxlhyiaw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;背景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么要做性能优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对绝大多数网站来说，从宏观视角上看主要有两个因素影响最终的网站业务效益：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户的整体规模&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户在网站内的转化率&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;业务效益 = 用户规模 * 转化率&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以为了提升业务效益，需要提升用户规模以及转化率。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;用户规模&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;用户主要由新用户和老用户组成，新老用户也有各自的流量组成，但无论新老用户进入网站，都要经过从用户的客户端也就是站外落地到我们网站也就是站内这个过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;尤其我们 Alibaba.com 是一个全球化的网站，从网络设施发达的欧美到欠发达的第三世界国家，都有我们的用户通过电脑或者手机等设备访问我们的网站。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而复杂网络状况以及技术现状，会导致网页加载的缓慢，用户很可能无法忍受漫长的白屏等待而选择关闭网站，造成用户流失。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多案例也说明了加载性能对用户规模的影响：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;At the BBC we’ve noticed that, for every additional second a page takes to load, 10 per cent of users leave.[1]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;The result of rebuilding our pages for performance led to a 40 percent decrease in Pinner wait time, a 15 percent increase in SEO traffic and a 15 percent increase in conversion rate to signup.[2]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;所以网站的加载性能会直接影响到最终落地站内的用户规模。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;转化率&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;影响转化率的因素非常多：网站提供的价值、用户的意愿度以及页面的用户体验都是重要的影响因素。而网站的交互性能，则是用户体验的一大影响因素。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果一个网站打开过程中，页面元素各种抖动、滚动页面时卡顿掉帧，或者鼠标点击一个按钮时需要一秒钟才能响应用户的交互，都会极大地损害用户体验，直接影响用户的点击率和蹦失率，最终对转化率造成影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们要做性能优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么总是做性能优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每隔一段时间就要重新提性能优化，为什么：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于这些原因，我们现有的页面性能并不是很理想。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;目标&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们将性能优化的目标定为买家前台核心浏览链路页面满足 Core Web Vitials 衡量指标下的 Good Url 标准。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是 Core Web Vitials&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Core Web Vitials&lt;/span&gt;&lt;span&gt;(后面简称为 cwv) [3]是 Google 为了衡量页面性能而提出的有多个指标组成的一套页面体验衡量标准，目前主要包含三个指标：LCP, FID, CLS。&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LCP: 最大内容绘制，测量加载性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;FID: 首次输入延迟，测量交互性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CLS: 累计布局偏移，测量视觉稳定性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么采用 Core Web Vitials 衡量指标&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从上面对 cwv 的解释可以看到，核心指标从页面加载速度、用户输入性能以及页面的视觉稳定性三个方向衡量了一个好的页面性能应该具备的特点，这三个指标也是用户体验的核心要素。相较于我们以前的衡量方式 hero element time ，即由每个业务线的开发自己定义一个关键页面元素,以它的渲染完成时间来衡量页面的性能，cwv 的指标明显要更加全面，而且更加通用，不易作弊且经受了整个行业的考验。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面是 Google 官方对于真实网站在 cwv 指标优化下的性能提升情况的统计：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;Why page performance matters Studies show that better Core Web Vitals improves user engagement and business metrics. For example:&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;When a site meets the Core Web Vitals thresholds, research showed that users were 24% less likely to abandon page load.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;With each 100ms reduction in Largest Contentful Paint (LCP), web conversion rate for Farfetch increased by 1.3%.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Reducing Cumulative Layout Shift (CLS) by 0.2 led Yahoo! JAPAN to a 15% increase in page views per session, 13% longer session durations, and a 1.72 percentage point decrease in bounce rate.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Netzwelt improved Core Web Vitals and saw advertising revenues increase by 18% and page views by 27%.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Reducing CLS from 1.65 to 0 significantly uplifted domain rankings globally for redBus.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;可以看到无论是 LCP，FID 还是 CLS ，他们的提升都能实实在在的带来业务的提升，这也是我们要做性能优化的原因以及选择 cwv 作为衡量指标的原因。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更多选择 cwv 作为衡量指标的原因，可以参考：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们将性能的衡量指标定为 Core Web Vitials，并将目标定为满足 Good Url 标准，即：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LCP &amp;lt; 2500ms&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;FID &amp;lt; 100ms&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CLS &amp;lt; 0.1&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;优化方法&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;性能优化是一个老生常谈的课题，网上有很多现成的方案和方法。当我们直接照搬这些方案或方法时，可能并不一定能快速达到我们的目标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如著名的雅虎军规里面说：静态资源尽量分散在多个域名下，以提高浏览器并发请求的数量。但随着技术的发展 HTTP2 的普及，这条方案已经并不适用了。又比如有文章说 js 里面的数组遍历方法 for 比 forEach 要快很多，所以为了更好的性能我们要用 for 来代替 forEach，你花了几天时间把所有 for 改成了 forEach 结果 cwv 指标根本没有任何变化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们要做性能优化，不能单纯的照搬别人的方案，而是要掌握性能优化的方法，正所谓理论指导实践。对于性能优化来说，方法就是：度量、分析和验证。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;度量&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果我们不能衡量页面现状，那么优化也就无从谈起。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以性能优化的首要事情就是要有度量页面的性能现状的方案，为后面的分析和优化提供数据支持。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面提到我们选择 cwv 作为我们的性能衡量指标，Google 提供了很多 cwv 的检测方式，包括 PageSpeed Insights、Chrome 开发者工具、搜索控制台、web.dev 测量工具等测试工具和平台。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但它们都有一个问题，不能够&lt;strong&gt;实时检测&lt;/strong&gt;线上实际用户的总体统计值，要么是只能本地单次通过类似 PSI（PageSpeed Insights）的测试来看单次评估结果，要么是类似 Google Search Console 这样只能在滞后一段时间以后才能看到大量用户的实际统计值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而实时的性能数据对我们非常重要，如果没有实时数据，那么会有一下问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们必须有一套实时观测性能数据的方案，来指导我们优化的策略或者优化方向是否正确。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最终我们选择 &lt;/span&gt;&lt;span&gt;web-vitals[6]&lt;/span&gt;&lt;span&gt;来获取 cwv 的值，并在 ICBU 统一性能监控脚本 big-brother 中添加了相应的打点来上报每个用户的性能数据并建立了相应的性能监控和报表来实时观测页面的性能数据，详细可以参考：&lt;/span&gt;&lt;span&gt;Google Core Web-Vitals 统计&amp;amp;监控&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;PS：现在可以直接接入 &lt;/span&gt;&lt;span&gt;agado[8]&lt;/span&gt;&lt;span&gt;来快速获取更加详细的性能数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;结合上一步获取的性能数据，我们可以系统性的分析当前每一个页面的性能现状。知道它现在到底慢不慢，为什么慢，具体哪里慢，这样的话我们也可以针对性的进行优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;拿一个典型的前后端分离的页面来看，LCP 的组成部分如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22336182336182336&quot; data-type=&quot;png&quot; data-w=&quot;1755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJx1objcQDnhfTHiatp9nlo5jyeTYjM6UrZsPGUrjmmEe3HkvPFXsVJkTl4DLtMiaBicDuARp2faibibOw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到，从用户打开浏览器到页面的 LCP 出现需要经过：建联、后端响应，HTML 传输下载，前端资源下载再到最后的解析渲染，链路非常长，导致最终的 LCP 往往离 2500ms 相去甚远。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如何减少 LCP 的时间，不考虑技术细节的情况下我们不难想到，就是缩短每个耗时组成或者尽可能让他们并行，这也就是我们优化 LCP 的核心宗旨：&lt;strong&gt;能减少的减少，不能减少的并行。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从 LCP 的组成上来看，其中重定向、DNS 解析以及建联和网络传输的时间主要受三方或者用户自身的网络状况限制，我们能做的并不多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以核心的优化方向应该聚焦在我们能控制的网络耗时以外的地方，即：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LCP 的时间线组成排布优化：即在现有的 LCP 时间线中，哪些可以去掉，哪些可以并行；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LCP 的时间线组成中每一个步骤本身的耗时优化：即除了网络耗时以外，后端 RT 以及前端资源下载解析执行时间的优化；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;对这两个方向的优化我们分别通过：渲染架构优化和关键渲染路径优化来进行分析优化，对于后端 RT 的优化本文暂不涉及。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;渲染架构上的优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从宏观视角上来看，渲染架构的选择是非常重要的，合理的架构选择可以提高系统的性能下限，为后续进一步优化打下基础。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;按照 LCP 优化的核心宗旨：能减少的减少，不能减少的并行。从前面 LCP 构成图上不难看出：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这两个优化方向对应了我们渲染架构上的优化方案：同构改造以及流式渲染。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;同构改造&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;渲染架构下性价比最高的优化就是同构改造，在有基建支持的情况下可以以较少的人力投入获取有确定性的比较大的性能提升，一般来说，同构改造可以带来 500~800ms 的性能提升。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面提到，我们现在绝大部分业务都是前后端分离的架构。这种架构的优势是降低了前后端沟通以及发布维护的成本，两端可以并行开发独立维护自己的代码库，稳定性也更高。但这种架构的问题是，由于前后端分离了，后端输出的 HTML 中只有骨架而没有内容，到了前端需要再进行一次渲染，这次前端渲染又依赖 js 的下载以及首屏数据的获取，导致渲染链路变长。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;能不能把这次额外的渲染的时间省掉呢？答案是可以的，同构直出就是为了解决这个问题。同样是前后端分离的架构，可以在不损失开发效率以及合作效率的情况下，通过一套 js 代码同时跑在前端和后端来实现页面的直出。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22336182336182336&quot; data-type=&quot;png&quot; data-w=&quot;1755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJx1objcQDnhfTHiatp9nlo58tgfY26tswl3gSujxhsHUgRCPDDNzmhvGZwYs1AQ5a0SicsXeNz5XXg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样就可以省去前端额外的 js 下载以及解析执行渲染的时间，节省下来的时间一般是 500~800ms ，但它的代价就是需要额外维护一个同构服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同构服务的话，现在主要有通用同构服务 silkworm-engine（内部自建服务），店铺自建的同构服务，以及营销导购的接入集团天马平台所提供的同构服务。对于一般业务来说，对接 silkworm-engine 就可以了，对接本身成本也不高。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;流式渲染&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;早在 2010 年，Facebook 的工程师就提出了 &lt;/span&gt;&lt;span&gt;bigpipe&lt;/span&gt;&lt;span&gt; [9]的页面渲染方案。通过将一个大的页面划分为多个 pagelet 来将渐进式的完成页面的渲染，核心是为了解决一次性渲染一个大的页面后端耗时过长的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个方案思路非常超前，但有一个缺点就是侵入性较大，以我们现有的技术架构下来说不太可能做这样的改造。但它背后的原理即：&lt;/span&gt;&lt;span&gt;http1.1&lt;/span&gt;&lt;span&gt; 的&lt;strong&gt;分块传输编码&lt;/strong&gt;的特性，可以指导我们来进行成本更低的优化，也就是流式渲染，将后端一次性的业务处理 vm 模板渲染并返回分为两步：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先返回是不依赖任何业务逻辑的 HTML &amp;lt;head&amp;gt; 部分，浏览器拿到后可以先开始进行静态资源的下载；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在返回第一段后，同步的去做业务逻辑处理，比如商品数据请求计算等，然后渲染 vm 并返回 HTML 剩余的 &amp;lt;body&amp;gt; 部分；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3268206039076376&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJx1objcQDnhfTHiatp9nlo5icGhUQolAKY2qCPxeIF8qaUb21oBHib8F5FpFYBAYHnTFFtq5KeWvt6w/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到在流式渲染的方案下，蓝框中 &lt;/span&gt;&lt;span&gt;&amp;lt;head&amp;gt;&lt;/span&gt;&lt;span&gt; 的下载解析以及首屏 css 等资源的下载和后端的取数计算并行了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么我们就可以节省 Min(前端首屏资源下载时间，后端 RT) 的时间，一般情况下可以有 300~500ms 左右的优化，优化后的时间线如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4498502994011976&quot; data-type=&quot;png&quot; data-w=&quot;1336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJx1objcQDnhfTHiatp9nlo5rn8ROgGyfORVxENic3AQMVbFAAZubGlg6FAz6j6y1YuE5icOb8NqAIBw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;流式渲染的对接也有了工程化的方案:&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;渲染架构总结&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;通过同构改造和流式渲染两个渲染架构的上优化，一般情况下都能有 1s 以上的提升。而且不挑业务场景，只要按部就班的做，几乎所有页面都可以进行这两项改造并获得肉眼可见的增益。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时除非做了其他渲染架构上的优化，一般情况下这 1s 以上的提升不会随着页面所在项目的功能迭代而腐化，确保了性能下限。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;关键渲染路径优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;引用 MDN 上对关键渲染路径（Critical rendering path, 后文简称 CRP）的定义：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen. Optimizing the critical render path improves render performance. The critical rendering path includes the Document Object Model (DOM), CSS Object Model (CSSOM), render tree and layout.&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;简单来说就是浏览器将 HTML，CSS 和 JavaScript 转换为屏幕上的像素所经历的步骤序列，优化包含文档对象模型(DOM)，CSS 对象模型 (CSSOM)，渲染树和布局在内的这些步骤可以提高首屏渲染性能。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;CRP 的优化涉及到浏览器的渲染原理：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当 DOM 或者 CSSOM 发生变化时，比如通过 js 操作了 DOM 节点或者动态插入了 style 标签等，浏览器会重新执行上述步骤。理解了 CRP 的原理，可以看到影响 CRP 的几个因素：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;HTML 文件的下载和解析时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CSS 文件下载和解析时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同步 js 文件的下载和解析&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DOM 和 CSSOM 的大小&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;以及布局和绘制的时间&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;其中 HTML、CSS 以及同步 js 资源，我们称其为关键资源，因为它们的下载和解析时间会影响到 CRP 的各个阶段，这样我们只要优化关键资源的下载解析以及 DOM 和 CSSOM 的大小就好了。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;可以通过静态资源缓存的方式来减少资源的下载时间，缩短关键路径长度，提高页面的渲染速度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的方案：&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;静态资源缓存配置&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;HTTP 缓存[12]&lt;/span&gt;&lt;span&gt;的具体规范定义本文不过多赘述，简单讲可以将缓存分为两类：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于一般的 Assets 应用来说，可以通过在项目根目录下添加 &lt;/span&gt;&lt;span&gt;.assetsmetafile&lt;/span&gt;&lt;span&gt; 文件，来自己指定资源的缓存时间，下面的示例是让浏览器以及 CDN (特定厂商)都缓存 1 年的配置：&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;html&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;cache&lt;/span&gt;-control:&lt;span class=&quot;code-snippet__keyword&quot;&gt;max&lt;/span&gt;-age=&lt;span class=&quot;code-snippet__number&quot;&gt;31536000&lt;/span&gt;,s-maxage=&lt;span class=&quot;code-snippet__number&quot;&gt;31536000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这样，只要资源所在的应用没有发布（仅针对非覆盖式发布资源，链接没有发生变化），那么一年的请求都直接走缓存的内容。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;上 CDN&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;众所周知 CDN 可以通过自己强大的网络和服务器，将静态资源缓存到离用户最近的节点上，从而减少资源的下载时间。&lt;/span&gt;&lt;/section&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;CDN 静态加速&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;虽然静态资源上 CDN 是一个常规操作，但本文依然要把静态资源上 CDN 提出来是因为我们网站仍然有一些类似 &lt;/span&gt;&lt;span&gt;&amp;lt;img src=&quot;//icbu-cpv-image.oss-us-west-1.aliyuncs.com/Had9f38eda3d942aa9e65ee9198b0660fU.jpg_300x300.jpg&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;的资源并没有走 CDN 分发，而是需要用户每次从源站请求下载资源。&lt;/span&gt;&lt;/section&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;CDN 动态加速&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;CDN 动态加速这个概念可能不是很常见，它的“动态”是相较于静态加速中“静态”来说的，也就是作用的对象的不同。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;原理上简单来说，就是利用 CDN 天然的优势：有距离用户近的边缘节点，并且分布广泛。通过 CDN 厂商专门的优化，从 CDN 的节点机器中来寻找一条从用户到源站的更优线路，避免走外网的层层网关。从而缩短 CDN 节点于源站之间的网络耗时，用户的动态请求走 CDN 节点来回源到服务器，会比用户自己访问源服务器要快很多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据我们的统计，动态加速的收益在 200ms+ 。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;提高缓存命中率&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;如果发布频率过高，由于版本号的变化导致资源对应的 url 频繁发生变化，那么本地的缓存除了占用本地的存储资源外已经失去了它原本的作用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们需要提高页面静态资源的缓存命中率，一般提高缓存命中率的方法就是动静分离。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以通过对页面依赖的 js，css 进行分层，将公共的依赖比如 React、ReactDOM、Fusion 等打包成一个公共的 bundle 我们称其为静态资源，将业务相关的依赖打包成一个业务相关的 bundle 我们称其为动态资源。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于静态资源的发布频率是远远低于动态资源的发布频率的，在绝大多数功能迭代的时候，只会发布上层业务应用。对于用户来说就只需要下载动态资源即可，而静态资源由于没有变动，所以可以直接从缓存中读取，加快资源加载速度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样就可以提高整体的资源缓存命中率，避免整个页面打一个 js 或者 css bundle 导致的哪怕是一行代码的发布，也需要用户重新下载整个 js, css bundle 包的问题。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;建联&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;前面提到著名的雅虎军规里面说：静态资源尽量分散在多个域名下，以提高浏览器并发请求的数量。这是由于浏览器限制同一个域名下的请求数量，受限于当时 HTTP1.x 下一个 TCP 连接只能处理一个 http 请求的原因，为了能让浏览器能在同一时间对并行请求多个资源而提出的优化方案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;到了 &lt;/span&gt;&lt;span&gt;HTTP2&lt;/span&gt;&lt;span&gt; [13]时代，一个 TCP 连接就可以并行进行多个请求了，配合 HTTP1.1 的 Connection: Keep-Alive 来进行连接的复用，之前的优化方案已经没有太大的意义了。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;域名收拢&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;甚至由于将资源分布在了不同的域名下，每个域名的都需要重新进行 DNS 解析、建联等过程，原本的优化手段已经变成了负向优化了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为此需要将分布在多个不同域名下的地址收敛到一个域名下，减少 DNS 解析的次数并通过连接复用和并发请求获得更好的效果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于更多 HTTP2 的特性，可以参考：&lt;/span&gt;&lt;span&gt;HTTP/2 – A protocol for greater performance[14]&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;提前建连&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;前面提到 DNS 的解析以及建联都是非常耗时的操作，为此浏览器提供了提前进行 DNS 解析以及建联的方法，分别是：&lt;/span&gt;&lt;span&gt;dns-prefetch[15]&lt;/span&gt;&lt;span&gt; 以及 &lt;/span&gt;&lt;span&gt;preconnect[16]&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dns-prefetch 是 HTML5 新增的一个属性，用于告诉浏览器提前解析某个域名，这样在浏览器需要解析这个域名的时候就不需要再去解析了，可以直接使用缓存中的结果。DNS-Prefetch 可以通过两种方式使用：&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;html&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dns-prefetch&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://s.alicdn.com/&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;preconnect：告诉浏览器提前建立 TCP 连接，DNS 解析以及 TLS 握手等操作，这样在浏览器需要使用这个域名的时候就不需要再去做这些操作了，可以直接使用缓存中的结果。在 head 标签添加如下的 meta 标签就可以了:&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;html&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;preconnect&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://s.alicdn.com&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;PS: 需要注意，preconnet 真实建立了连接，属于比较重的操作，所以仅在关键资源对应的域名上使用，否则提前建立过多的连接可能会对页面造成负向作用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于 dns-prefetch 有着比 preconnet 更好的浏览器兼容性，建议组合 dns-prefetch 以及 preconnet 使用：&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;html&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;preconnect&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://s.alicdn.com/&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;crossorigin&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dns-prefetch&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://s.alicdn.com/&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;预加载&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;对于页面依赖的核心资源，我们可以通过资源预加载的方式来提前下载关键资源，从而缩短 CRP 所需时间。效果如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45739910313901344&quot; data-type=&quot;png&quot; data-w=&quot;892&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJx1objcQDnhfTHiatp9nlo5f2lEibgcIaEUBHYouXpMRLrw6VVQT2YaoeMyMycaAHS2dOQJPQC3icFA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过在 html head 中添加 &lt;/span&gt;&lt;span&gt;preload[17]&lt;/span&gt;&lt;span&gt;的 meta 标签实现：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;后续需要加载对应的已经预载过的资源的时候就不需要从网络上重新获取了。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;非核心内容异步&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;我们网站的内容非常丰富，这意味着功能复杂代码体量大。如果一定要在整个首屏加载完毕之后才能使用，那么用户体验就会很差。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了解决这个问题，我们可以将非核心内容异步加载，这样用户可以在首屏加载完毕之后就可以使用网站的核心功能，而非核心内容则可以在后续加载完毕之后再使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方案上，对于使用 webpack 构建代码的用户，可以直接通过 &lt;/span&gt;&lt;span&gt;dynamic import&lt;/span&gt;&lt;span&gt; [18]来实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如 PPC 的 PC 页面，我们把左侧的筛选进行了异步加载，以让用户能够更早的看到更为核心的商品 List ：&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;jsx&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; React, { lazy } &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;react&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; SSRCompatibleSuspense &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;../../component/ssr-suspense&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; { Icon } &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;@alifd/next&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;LeftFilterAsync&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;{ data }: { data: PPCSearchResult.PageData }&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; TrafficLeftFilter = lazy(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt;( &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;@alife/traffic-left-filter&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; handleChange = &lt;span class=&quot;code-snippet__function&quot;&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;link: string&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    xxx;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;SSRCompatibleSuspense&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fallback={&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &amp;lt;Icon type=&quot;loading&quot; /&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &amp;lt;TrafficLeftFilter&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        data={data?.snData}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        i18n={data?.i18nText}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        handleChange={handleChange}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      /&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;/SSRCompatibleSuspense&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;export default LeftFilterAsync;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;选择性渲染&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;当代码不能进一步分割，但是渲染的内容有非常多，DOM 节点数量巨大，意味 CRP 的时间。那么在首屏可以选择性的渲染一部分更为关键的内容，这样可以减少首屏渲染的时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如 showroom 的无线页面，首屏后端返回 48 个品的数量，而无线端的手机大部分首屏只能展示 4 个品，所以我们在首屏只渲染前 8 个品，后续的品则在 js ready 后进行二次渲染。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样，对于同步直出的页面，即减少了 html 体积，可以加快下载 html 的速度，同时又减少了首屏 DOM 节点的数量，降低了浏览器生成 DOM Tree 的时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最终减少 CRP 所需要的时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;FID 以及 CLS 的优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面大端的篇幅提到的都是 LCP 相关的优化，因为对于面向买家的页面来说，主要是纯展示型页面，一般没有非常复杂的交互，所以 FID 和 CLS 的问题不是很凸显，开发同学在意识上注意一下就好了。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;FID&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;FID: First Input Delay , 从用户第一次与您的网站交互直到浏览器实际能够对交互作出响应的时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个时间主要是由 js 的执行时间决定的，当浏览器的主线程执行 js 时，就无法相应用户的操作，最终影响 FID。那么优化的方向就是：&lt;/span&gt;&lt;/section&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;减少 js 的执行时长&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;限制页面依赖的 js 总体积，可以非常直观的降低执行时长。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于页面的主 js ，通过代码分割的方式延迟加载非首屏核心功能的代码，只有在代码真正要被使用，或者空闲的时候再去加载，将主线程空闲出来，从而减少 js 的执行时长。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于页面依赖的二方包，一定要严格审查，避免同样的包、依赖比如 React、Fusion 等被重复引入，这样会导致 js 的体积增大，从而增加执行时长。比如我们某个场景中引入的一个二方 SDK，体积足足 1.6MB，比我们宿主页面代码的 300kb 还大，这里就有很大的优化空间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;控制第三方脚本的引入，或者尽可能延迟他们的加载，有些投放页面里面依赖了很多三方的统计脚本，这些脚本的加载会阻塞页面的渲染，从而影响 FID。&lt;/span&gt;&lt;/section&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;分割 js 中繁重计算任务&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;多余繁重的计算任务，可以通过 requestAnimationFrame 的方式，将计算任务分割到多个帧中执行，从而减少 js 的执行时长，给浏览器留出更多的空闲时间可以响应用户的操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果是无法分割的计算任务，可以考虑使用 web worker 的方式，将计算任务放到 worker 中执行，从而不会阻塞主线程。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;CLS&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;CLS: Cumulative Layout Shift , 通过计算未在用户输入 500 毫秒内发生的布局偏移的偏移分数总和来测量内容的不稳定性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;导致 CLS 较差的原因：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在国际站场景，核心需要注意的是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基本上做到这些，那么 CLS 就可以达到标准。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;策略沉淀&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在我们这一年的优化过程中，沉淀了一些工具和经验来帮助我们快速的进行性能优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;工具或系统沉淀&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;agado[19]&lt;/span&gt;&lt;span&gt;： 端架构团队打造的全球化性能度量平台，几行代码即可高效接入全面的性能度量系统；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;silkworm engine[20]&lt;/span&gt;&lt;span&gt;：买家基础技术在五年前左右开始搭建的一套通用同构渲染服务，满足除特定解决方案下（店铺、天马等）的页面快速接入同构能力的诉求；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;流式渲染二方库[21]&lt;/span&gt;&lt;span&gt;：快速接入流式渲染的解决方案，并在前期打通了各层代理，后端接入成本可以从3人日减少到小时级别；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;取得的成果&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;SEO 性能优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Google Search Console 后台的 GoodUrl 比例增长：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PC：&lt;strong&gt;0 -&amp;gt; 85.9%&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无线：&lt;strong&gt;0-&amp;gt; 95.1%&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;具体性能指标（箭头指向优化后的结果）：多个场景下页面的性能都有非常大的提升，CLS 和 FID 全部达到 cwv Good Url 标准，我们着重优化的两个场景中 LCP 也达到 Good Url 标准。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 SEO 场景，由于性能提升带来的搜索引擎加权，以及更好的到达率，在多个场景下都有 10%~20% 的 uv 增长，大幅提升了用户规模。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;付费页面优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Wap DPA 页面：LCP 降低了 500ms 左右，业务指标：uv 提升 9% 左右，其他业务指标如点击率、跨端等相关指标也有非常大的提升；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PC PLA 页面：LCP 降低了 900ms 左右，业务指标：核心点击上升 16.1%，uv 增长 4.6%；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;以及其他很多还在实验中的项目，都可以看到业务数据有不同程度的增长；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;实际案例&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面说了非常多的理论知识，接下来结合一个实际的例子 —— 无线 showroom （一个 SEO 承接页）的优化，来验证我们如何根据上面的方法来将一个LCP、FID 以及 CLS 都不达标的页面优化为 Good Url 的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;现状分析&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当我们接手 showroom 的时候，只知道性能很差，因为业务反馈说 Google Search Console 后台看到我们网站的 Good Url 的达标率为 0%，也就是说 LCP、CLS 以及 FID 都不及格。但具体差到什么样子，哪里差，一无所知。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化的诉求非常迫切，但连现状是个什么样子都不知道，那自然是没有办法优化的。所以首先要有度量现状的方案，经过分析和调研，采用了 Google web-vitals 的库来获取用户数据，使用 ICBU 之前就对接 big-brother 来上报采集到的数据，同时通过配置 xflush 来实时展示数据的变动趋势。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是最终的性能汇总大盘监控：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5377777777777778&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJx1objcQDnhfTHiatp9nlo5thrtcYVhiaAQS8M2IBM3njVa18S5cLtrtddJ5L5xr3BibLia68NibQlC0Q/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有了度量方案以后，我们得到了性能的现状：数据比较差，LCP、CLS 以及 FID 都需要进行优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有了性能数据以后，再来看一下 showroom 的技术架构：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;rax 是当时集团的类 react ui 库&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;dx 是一个能够解决跨端开发问题的解决方案，主要用于端内 Android 和 iOS 的动态配置，Web 端也有兼容展示的方案&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;由于使用 dx， 需要从后端数据中获取 dx 模板的字符串，然后前端把字符串 evel 后作为通过 dx-h5 库转化为 rax 组件，再由 rax 渲染到页面上&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;样式文件：由于采用 rax 和 dx ，最终都是通过内联样式实现样式布局，没有独立的 css 文件供浏览器缓存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;第一次同构改造&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先看 LCP 的组成：&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09855521155830753&quot; data-type=&quot;png&quot; data-w=&quot;1938&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJx1objcQDnhfTHiatp9nlo5d4AQicyicCGUKwsHlqDJbA14j93QDjhArBQxHqCTHE7gS67FRMnwSbvw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于页面异步渲染的原因，即使 html 上了 CDN 也没有太大的帮助，整个渲染链路拉得非常长，我们接手后先做了同构改造。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于原本页面是 rax + dx ，rax 只是空壳，主要内容都是通过 dx 来渲染的， 所以需要对接 dx 的同构。刚好隔壁团队有一个 dx 的同构服务，我们尝试对了一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先我们和 Akamai 的同学沟通，将 showroom 的 html 静态化方案从 CDN 上下了下来，然后前端层面做了一些改造对接了 DX 的同构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对接完成后，虽然能够 dx 的同构也能实现直出，但是存在一个很严重的问题：服务端数据的 html 结构和前端渲染出来的结构不一样。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这导致前端 js 的二次渲染页面会闪动，毕竟 html 结构不一样，做不到像 react 那样的 hydrate ，LCP 的时间也变成了二次渲染完成后的时间，同时页面 FID、CLS 也没有太大的优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;第二次同构改造&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dx 的优势是一套配置，三端使用。但是在 Web 端实际的操作使用情况下，端内的配置用到 Web 端各种适配问题，最终发展成了一个组件，端内一套 dx 模板配置，端外另一套。也就是说端内外依然是各自独立维护模板，那么它的优势已经没有了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时由于使用了 dx，带了很多额外的问题：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6637298091042585&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJx1objcQDnhfTHiatp9nlo5RzsDRZT4dyvC7nR84Ll83HGzjKXjwClxQzXcrA3TmJjdaicLfuD1hsg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在这些问题下， 我们最终选择了对 showroom 进行重构，将原本 dx、rax 的方案推到，用 react 进行了重写。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;react 下各种技术方案都相对成熟，重构完成后对接了跑了很多年的 silkworm 的同构服务。react 的同构解决方案非常成熟了，不会出现 dx 下二次渲染页面需要闪动的问题，由于也没有胶水层，渲染效率相较于 dx 有了很大的提升。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.11094674556213018&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;676&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJx1objcQDnhfTHiatp9nlo5gcWqUa3HrBUeQDTXoUejvFScF9jibYDowU9mlkEq9WsibXasBpv0ezUw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;可以看到渲染链路简单了非常多，从监控上看 LCP 降低了 900ms 左右，FID 直接降到了 Good 的标准 100ms 以下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41133333333333333&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJx1objcQDnhfTHiatp9nlo5G2rGFcFSrYAvibAuxusxicGSqvJyDdqcGPv5yGzpbWzYyVRVhOTasAgQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;关键渲染路径优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;应用拆分&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;对原本的 showroom 应用进行了拆分，从一个大应用拆分为两个应用：基础公共包 traffic-base 以及上层业务应用 traffic-free-wap。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;平时的发布基本都是 traffic-free-wap 的发布，traffic-base 的发布频率很低，提高缓存命中率，同时也降低了发布风险。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是由于缓存的效果是一个长期的影响，短期内看不到 LCP 的变化。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;aplus 异步改造&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;aplus 是集团打点方案，需要对接一个 aplus.js 的脚本来实现各种打点尤其是 pv 的上报。原本页面的 aplus.js 是同步加载和执行的，会阻塞页面的渲染，所以我们将其改造为异步加载。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;需要修改的是后端服务中的 beacon 模块，在 beacon 模块中的给其中的 script 标签加上 async 就可以了:&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;plain&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[aplus]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aplusKeyUrl=.com&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aplusKeyUrl=.net&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aplusKeyUrl=.org&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aplusKeyUrl=.cn&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aplusKeyUrl=.hk&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aplusKeyUrl=.vipserver&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aplusLocation=header&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aplusCmpType=find&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aplusFilter=find&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;iframe_delete=true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aplusFilter=find&quot;&lt;/span&gt;at_iframe=1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aplusFilter=find&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/wangwang/update&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aplusUrl=&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;id=&quot;&lt;/span&gt;beacon-aplus&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;async&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;src=&quot;&lt;/span&gt;//assets.alicdn.com/g/alilog/??aplus_plugin_icbufront/index.js,mlog/aplus_v2.js&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;exparams=&quot;&lt;/span&gt;userid=\&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;aplus 异步改造上线后，从监控看获得了 50ms 的 LCP 提升。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;预建联、预加载以及域名收拢&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;按照我们的优化策略，对 showroom 整个页面的静态资源域名都收敛到了 s.alicdn.com 下面。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时对域名进行了 DNS 预解析和建联：&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;html&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;preconnect&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://s.alicdn.com&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;crossorigin&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dns-prefetch&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://s.alicdn.com&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;对于首屏的几个商品图，进行了预加载：&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;html&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;link&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  rel=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;preload&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  href=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://s.alicdn.com/@sc04/kf/H2df0c8cbb22d49a1b1a2ebdd29cedf05y.jpg_200x200.jpg&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  as=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;link&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  rel=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;preload&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  href=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://s.alicdn.com/@sc04/kf/H423ae0f4cf494848bb5c874632270299J.jpg_200x200.jpg&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  as=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;link&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  rel=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;preload&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  href=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://s.alicdn.com/@sc04/kf/Hdf15b5c8a7c544c2aee0b2616b2715e3K.jpg_200x200.jpg&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  as=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上线后， 从监控上看 LCP 有了 200ms 左右的提升，稳定在了 Good Url LCP 的边缘，即将达标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;流式渲染改造&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;做完以上优化后，我们开始进行流式渲染的改造，前后端一起打通了流式渲染的方案，预发测试效果非常好。但是上线后一直不生效，一直排查也排查不出来为什么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后想起来我们走了 Akamai 的动态加速，这意味着用户的请求还是先打到了 Akamai 的 CDN 上，然后再打到我们的后端服务上。而我们的流式渲染是在后端服务上进行的，所以有可能是 CDN 这里做了什么导致我们不生效。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;和 CDN 的同学沟通后，发现需要加一个 &lt;/span&gt;&lt;span&gt;chunked response streaming&lt;/span&gt;&lt;span&gt; 的配置，加上后重新上线测试，流式渲染终于生效了，上线后 LCP 直接降低了 500ms，达到了 CWV Good Url 标准。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;CLS 优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;LCP 和 CLS 达标以后，只剩下 CLS 还差一点。对于 showroom 来说，导致 cls 的问题主要是 header 的高度不固定，以及商品卡片中图标的位置不固定。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;优化总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;showroom 的优化过程就是根据我们前端提到的优化方法，度量-&amp;gt;分析-&amp;gt;实验，一步步推进，最终达到了 cwv Good Url 标准，search console 后台显示的 good rate 稳定在 90% 以上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时由于达到了 Google Good Url 的要求，获得了 Google 的搜索权重的加权。按照和 Google 对接的同学提供的衡量方法，wap showroom 的 Clicks +10.6%，Impression +8.8%，相当于额外带来 10% 左右的 uv。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果没有系统性的理论指导，性能优化很容易变成一件非常琐碎的事情，发现 A 解决 A ，发现 B 解决 B，随着业务迭代也会逐渐腐化，而且如果方向错误的话，很容易浪费大量的时间却拿不到想要的结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文从性能优化的理论出发，从度量、分析、验证三个方面，介绍了我们在性能优化中的一些实践，希望能够帮助到大家。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然目前取得了一些性能和业务上的成果，但是很多页面比如付费承接依然有很大的优化空间，需要持续的优化和推进。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;[1]:https://www.creativebloq.com/features/how-the-bbc-builds-websites-that-scale&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;[2]:https://medium.com/pinterest-engineering/driving-user-growth-with-performance-improvements-cfc50dafadd7&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;[3]:https://web.dev/vitals/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;[4]:https://webmasters.googleblog.com/2020/05/evaluating-page-experience.html&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[6]:https://github.com/GoogleChrome/web-vitals&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;]:https://agado.alibaba-inc.com/overview&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;]:https://engineering.fb.com/2010/06/04/web/bigpipe-pipelining-web-pages-for-high-performance/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;]:https://yuque.antfin.com/b2b-shop/omy4bn/fm3a1m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[12]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#private_caches&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[13]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP#http2_–_a_protocol_for_greater_performance&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[14]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP#http2_–_a_protocol_for_greater_performance&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[15]:https://developer.mozilla.org/en-US/docs/Web/Performance/dns-prefetch&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[16]:https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preconnect&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[17]:https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preload&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[18]:https://webpack.js.org/guides/code-splitting/#dynamic-imports&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[19]:https://agado.alibaba-inc.com/overview&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[20]:https://yuque.antfin.com/ks3gwb/cswbx6&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[21]:https://yuque.antfin.com/b2b-shop/omy4bn&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;[22]&lt;/span&gt;MDN:https://developer.mozilla.org/en-US/&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[23]Web Vitals:https://web.dev/vitals/&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;参与即有奖，算法领域主题征文开始啦！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;以“算法”为主题，欢迎前往社区分享您的技术干货，包括但不限于传统算法解读、框架使用、深度学习以及前沿趋势。您将有机会获得音响、云小宝定制抱枕等奖品，快来参加吧！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;点击阅读原文查看详情。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>