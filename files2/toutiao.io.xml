<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bd56318523ecab3224c9f342ed266c19</guid>
<title>Spring Boot 生产中 16 条最佳实践，建议收藏</title>
<link>https://toutiao.io/k/30pmyuh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;👆&lt;/span&gt;点击左上角&lt;/span&gt;&lt;span&gt;蓝字&lt;/span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;，&lt;/span&gt;&lt;strong&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;关注&lt;/span&gt;&lt;/strong&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;此公众号👆&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;技术干货，及时送达！&lt;/span&gt;&lt;/p&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Spring Boot是最流行的用于开发微服务的Java框架。在本文中，我将与你分享自2016年以来我在专业开发中使用Spring Boot所采用的最佳实践。这些内容是基于我的个人经验和一些熟知的Spring Boot专家的文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在本文中，我将重点介绍Spring Boot特有的实践（大多数时候，也适用于Spring项目）。以下依次列出了最佳实践，排名不分先后。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;1&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用自定义BOM来维护第三方依赖&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这条实践是我根据实际项目中的经历总结出的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring Boot项目本身使用和集成了大量的开源项目，它帮助我们维护了这些第三方依赖。但是也有一部分在实际项目使用中并没有包括进来，这就需要我们在项目中自己维护版本。如果在一个大型的项目中，包括了很多未开发模块，那么维护起来就非常的繁琐。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎么办呢？事实上，Spring IO Platform就是做的这个事情，它本身就是Spring Boot的子项目，同时维护了其他第三方开源库。我们可以借鉴Spring IO Platform来编写自己的基础项目platform-bom，所有的业务模块项目应该以BOM的方式引入。这样在升级第三方依赖时，就只需要升级这一个依赖的版本而已。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependencyManagement&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;       &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.spring.platform&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;platform-bom&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;Cairo-SR3&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;       &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependencyManagement&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用自动配置&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring Boot的一个主要特性是使用自动配置。这是Spring Boot的一部分，它可以简化你的代码并使之工作。当在类路径上检测到特定的jar文件时，自动配置就会被激活。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用它的最简单方法是依赖Spring Boot Starters。因此，如果你想与Redis进行集成，你可以首先包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你想与MongoDB进行集成，需要这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-mongodb&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;借助于这些starters，这些繁琐的配置就可以很好地集成起来并协同工作，而且它们都是经过测试和验证的。这非常有助于避免可怕的Jar地狱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;http&lt;span&gt;s:&lt;/span&gt;//dzone.&lt;span&gt;com&lt;/span&gt;/articles/what-&lt;span&gt;is&lt;/span&gt;-jar-hell&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过使用以下注解属性，可以从自动配置中排除某些配置类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;@&lt;span&gt;EnableAutoConfiguration&lt;/span&gt;（&lt;span&gt;exclude&lt;/span&gt; = {&lt;span&gt;ClassNotToAutoconfigure&lt;/span&gt;&lt;span&gt;.class&lt;/span&gt;}）&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但只有在绝对必要时才应该这样做。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有关自动配置的官方文档可在此处找到：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;https&lt;/span&gt;:&lt;span&gt;//docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用Spring Initializr来开始一个新的Spring Boot项目&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;49&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;这一条最佳实践来自Josh Long （Spring Advocate，@starbuxman）。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring Initializr 提供了一个超级简单的方法来创建一个新的Spring Boot项目，并根据你的需要来加载可能使用到的依赖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;24&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;https://start.spring.io/&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用Initializr创建应用程序可确保你获得经过测试和验证的依赖项，这些依赖项适用于Spring自动配置。你甚至可能会发现一些新的集成，但你可能并没有意识到这些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;4&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;考虑为常见的组织问题创建自己的自动配置&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一条也来自Josh Long（Spring Advocate，@starbuxman）——这个实践是针对高级用户的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你在一个严重依赖Spring Boot的公司或团队中工作，并且有共同的问题需要解决，那么你可以创建自己的自动配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这项任务涉及较多工作，因此你需要考虑何时获益是值得投入的。与多个略有不同的定制配置相比，维护单个自动配置更容易。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果将这个提供Spring Boot配置以开源库的形式发布出去，那么将极大地简化数千个用户的配置工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;5&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正确设计代码目录结构&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽管允许你有很大的自由，但是有一些基本规则值得遵守来设计你的源代码结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;避免使用默认包。确保所有内容（包括你的入口点）都位于一个名称很好的包中，这样就可以避免与装配和组件扫描相关的意外情况；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将Application.java（应用的入口类）保留在顶级源代码目录中；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我建议将控制器和服务放在以功能为导向的模块中，但这是可选的。一些非常好的开发人员建议将所有控制器放在一起。不论怎样，坚持一种风格！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;6&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;保持@Controller的简洁和专注&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Controller应该非常简单。你可以在此处阅读有关GRASP中有关控制器模式部分的说明。你希望控制器作为协调和委派的角色，而不是执行实际的业务逻辑。以下是主要做法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;http&lt;span&gt;s:&lt;/span&gt;//&lt;span&gt;en&lt;/span&gt;.wikipedia.org/wiki/GRASP_(object-oriented_design)#Controller&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要深入这个内容，需要进一步地了解设计REST API的最佳实践。无论你是否想要使用Spring Boot，都是值得学习的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;7&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;围绕业务功能构建@Service&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Service是Spring Boot的另一个核心概念。我发现最好围绕业务功能/领域/用例（无论你怎么称呼都行）来构建服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在应用中设计名称类似AccountService, UserService, PaymentService这样的服务，比起像DatabaseService、ValidationService、CalculationService这样的会更合适一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可以决定使用Controler和Service之间的一对一映射，那将是理想的情况。但这并不意味着，Service之间不能互相调用！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;8&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使数据库独立于核心业务逻辑之外&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我之前还不确定如何在Spring Boot中最好地处理数据库交互。在阅读了罗伯特·C·马丁的“Clear Architecture”之后，对我来说就清晰多了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你希望你的数据库逻辑于服务分离出来。理想情况下，你不希望服务知道它正在与哪个数据库通信，这需要一些抽象来封装对象的持久性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;95&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;罗伯特C.马丁强烈地说明，你的数据库是一个“细节”，这意味着不将你的应用程序与特定数据库耦合。过去很少有人会切换数据库，我注意到，使用Spring Boot和现代微服务开发会让事情变得更快。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;9&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;保持业务逻辑不受Spring Boot代码的影响&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;考虑到“Clear Architecture”的教训，你还应该保护你的业务逻辑。将各种Spring Boot代码混合在一起是非常诱人的……不要这样做。如果你能抵制诱惑，你将保持你的业务逻辑可重用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;部分服务通常成为库。如果不从代码中删除大量Spring注解，则更容易创建。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;10&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;推荐使用构造函数注入&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一条实践来自Phil Webb（Spring Boot的项目负责人, @phillip_webb）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;保持业务逻辑免受Spring Boot代码侵入的一种方法是使用构造函数注入。不仅是因为@Autowired注解在构造函数上是可选的，而且还可以在没有Spring的情况下轻松实例化bean。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;11&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;熟悉并发模型&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;我写过的最受欢迎的文章之一是“介绍Spring Boot中的并发”。我认为这样做的原因是这个领域经常被误解和忽视。如果使用不当，就会出现问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;82&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://www.e4developer.com/2018/03/30/introduction-to-concurrency-in-spring-boot/&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Spring Boot中，Controller和Service是默认是单例。如果你不小心，这会引入可能的并发问题。你通常也在处理有限的线程池。请熟悉这些概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你正在使用新的WebFlux风格的Spring Boot应用程序，我已经解释了它在“Spring’s WebFlux/Reactor Parallelism and Backpressure”中是如何工作的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;12&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;加强配置管理的外部化&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一点超出了Spring Boot，虽然这是人们开始创建多个类似服务时常见的问题……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可以手动处理Spring应用程序的配置。如果你正在处理多个Spring Boot应用程序，则需要使配置管理能力更加强大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我推荐两种主要方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些选项中的任何一个（第二个选项多一些）都要求你在DevOps更少工作量，但这在微服务领域是很常见的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;13&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;提供全局异常处理&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;你真的需要一种处理异常的一致方法。Spring Boot提供了两种主要方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这与Spring中的几乎相同，并且Baeldung有一篇关于REST与Spring的错误处理的详细文章，非常值得一读。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;http&lt;span&gt;s:&lt;/span&gt;//www.baeldung.&lt;span&gt;com&lt;/span&gt;/exception-handling-&lt;span&gt;for&lt;/span&gt;-rest-with-spring&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;14&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用日志框架&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可能已经意识到这一点，但你应该使用Logger进行日志记录，而不是使用System.out.println()手动执行。这很容易在Spring Boot中完成，几乎没有配置。只需获取该类的记录器实例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;Logger logger = LoggerFactory.getLogger(MyClass.&lt;span&gt;class&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这很重要，因为它可以让你根据需要设置不同的日志记录级别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;15&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;测试你的代码&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这不是Spring Boot特有的，但它需要提醒——测试你的代码！如果你没有编写测试，那么你将从一开始就编写遗留代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果有其他人使用你的代码库，那边改变任何东西将会变得危险。当你有多个服务相互依赖时，这甚至可能更具风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于存在Spring Boot最佳实践，因此你应该考虑将Spring Cloud Contract用于你的消费者驱动契约，它将使你与其他服务的集成更容易使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;16&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用测试切片让测试更容易，并且更专注&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一条实践来自Madhura Bhave（Spring 开发者, @madhurabhave23）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用Spring Boot测试代码可能很棘手——你需要初始化数据层，连接大量服务，模拟事物……实际上并不是那么难！答案是使用测试切片。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用测试切片，你可以根据需要仅连接部分应用程序。这可以为你节省大量时间，并确保你的测试不会与未使用的内容相关联。来自spring.io的一篇名为Custom test slice with Spring test 1.4的博客文章解释了这种技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;72&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://spring.io/blog/2016/08/30/custom-test-slice-with-spring-boot-1-4&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;17&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感谢Spring Boot，编写基于Spring的微服务正变得前所未有的简单。我希望通过这些最佳实践，你的实施过程不仅会变得很快，而且从长远来看也会更加强大和成功。祝你好运！&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;/p&gt;&lt;blockquote mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;来源：&lt;/span&gt;&lt;span&gt;&amp;lt;网络&amp;gt;&lt;/span&gt;&lt;/blockquote&gt;&lt;blockquote mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span&gt;版权声明：此内容来源网络，版权归原作者所有。我们转载的内容，都会注明来源，除非无法确认。若有侵权，烦请告知，我们会立即删除并表示歉意。谢谢！&lt;/span&gt;&lt;/blockquote&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;PS：文章若对您有用，请帮助 &lt;strong&gt;点赞、在看、转发&lt;/strong&gt; 吧！&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;公众号：Java精选&quot; data-id=&quot;91842&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;点击卡片关注我们，更多技术干货，及时为您送达！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzU0ODk2MzE3MA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib178LnVu9br0VUuI4OKYwvXKpZnaGseFG3vyFJShp2VFcwVodS88CkUsNYcLDrglYLHPFoic6MJD4A/0?wx_fmt=png&quot; data-nickname=&quot;逻魔代码&quot; data-alias=&quot;lomagicode&quot; data-signature=&quot;逻魔代码，分享架构技术干货，打造有价值的经验分享社群，帮助后继者以前人的肩膀为基，建造更精妙的技术殿堂！&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;20&quot;&gt;&lt;p mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;20&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485286&amp;amp;idx=1&amp;amp;sn=4e9419cbc1fcbf82b37c40318667d282&amp;amp;chksm=fbb6516bccc1d87d8588e9b7d19ddf35ffcfdc027529514f5a5d8231870d0ec4ed96361bcd38&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【实战】SpringBoot零侵入全局记录RabbitMQ消息发送和消费状态&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【实战】SpringBoot零侵入全局记录RabbitMQ消息发送和消费状态&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485286&amp;amp;idx=2&amp;amp;sn=cfd655eaa33e278eb83c6dc565fe5be3&amp;amp;chksm=fbb6516bccc1d87df92ddb198b7a21899b96db177b88f148e8156e571347a7ab0dba56102ad2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;几个数据持久化框架（Hibernate、JPA、Mybatis、JOOQ、JDBC Template）的比较&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;几个数据持久化框架（Hibernate、JPA、Mybatis、JOOQ、JDBC Template）的比较&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485246&amp;amp;idx=1&amp;amp;sn=4deca9c75a6aa9de9883e388916496f4&amp;amp;chksm=fbb65133ccc1d8257ae41dd8fe710d7cea93a312e6aa0f2079f4a140416dbf17f9a03866c895&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如何设计一个短链接系统？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;如何设计一个短链接系统？&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485184&amp;amp;idx=1&amp;amp;sn=3ba295e248bd8e6fae451d241e8f30b1&amp;amp;chksm=fbb6510dccc1d81b32f7e05ba07ae9c010f9a9b9bd1c79b36d3cebbb918e48d2a2ada828d310&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;JWT 实现登录认证 + Token 自动续期方案，正确的使用姿势！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;JWT 实现登录认证 + Token 自动续期方案，正确的使用姿势！&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ddd711eac5760656ff4b76d304618c68</guid>
<title>分布式 ID 生成服务的技术原理和项目实战</title>
<link>https://toutiao.io/k/9v68f9o</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;&lt;p name=&quot;global_header&quot; data-traceid=&quot;global_header&quot; data-tracepid=&quot;global_header&quot;&gt;
                &amp;#13;
&amp;#13;

            &lt;/p&gt;
            

        &lt;val data-name=&quot;site_url&quot; data-value=&quot;https://www.oschina.net&quot;/&gt;      &lt;val data-name=&quot;space_user_url&quot; data-value=&quot;https://my.oschina.net/u/4939618&quot;/&gt;      &lt;val data-name=&quot;space_user_id&quot; data-value=&quot;4939618&quot;/&gt;      &lt;val data-name=&quot;g_user_url&quot; data-value=&quot;&quot;/&gt;      &lt;val data-name=&quot;api_prefix&quot; data-value=&quot;/action&quot;/&gt;      &lt;val data-name=&quot;g_user_code&quot; data-value=&quot;&quot;/&gt;     &lt;val data-name=&quot;g_user_id&quot; data-value=&quot;&quot;/&gt;     &lt;val data-name=&quot;g_user_bind_phone&quot; data-value=&quot;false&quot;/&gt;     &lt;val data-name=&quot;g_user_name&quot; data-value=&quot;&quot;/&gt;     &lt;val data-name=&quot;g_user_small_portrait&quot; data-value=&quot;https://www.oschina.net/new-osc/img/portrait.gif&quot;/&gt;     &lt;val data-name=&quot;g_user_large_portrait&quot; data-value=&quot;https://www.oschina.net/new-osc/img/portrait.gif&quot;/&gt;     &lt;val data-name=&quot;g_user_osc_staff&quot; data-value=&quot;false&quot;/&gt;     &lt;val data-name=&quot;login_page&quot; data-value=&quot;https://www.oschina.net/home/login?goto_page=https%3A%2F%2Fmy.oschina.net%2Fu%2F4939618%2Fblog%2F5585451%3Fhmsr%3Dtoutiao.io%26utm_campaign%3Dtoutiao.io%26utm_medium%3Dtoutiao.io%26utm_source%3Dtoutiao.io&quot;/&gt; 
                &lt;val data-name=&quot;weixinAppId&quot; data-value=&quot;wx880def15e694b905&quot;/&gt;
        &lt;val data-name=&quot;weixinTimestamp&quot; data-value=&quot;1667209486009&quot;/&gt;
        &lt;val data-name=&quot;weixinNonceStr&quot; data-value=&quot;86087361-c985-4534-9952-c20f7d6babc5&quot;/&gt;
        &lt;val data-name=&quot;weixinSignature&quot; data-value=&quot;801f5a130f044ea96cb4204cfd26d47c756f26bf&quot;/&gt;
        &lt;val data-name=&quot;weixinShareUrl&quot; data-value=&quot;https://my.oschina.net/u/4939618/blog/5585451?hmsr=toutiao.io&amp;amp;utm_campaign=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&quot;/&gt;                             
                &lt;val data-name=&quot;is_detail_page&quot; data-value=&quot;true&quot;/&gt;

        &lt;val data-name=&quot;fixedHeaderHeight&quot; data-value=&quot;45&quot;/&gt;
        &lt;val data-name=&quot;secondaryHeaderEnable&quot; data-value=&quot;true&quot;/&gt;

        &lt;val data-name=&quot;rocommendGrayStatus&quot; data-value=&quot;true&quot;/&gt; 
        
    &lt;div class=&quot;pusher&quot;&gt;
                        
                                                                &lt;div class=&quot;small-header-box small-header-box--fixed small-header-box--default-simple&quot;&gt;
                &lt;div class=&quot;small-header-box__wrapper&quot;&gt;
                    &lt;div class=&quot;small-header-box__inner&quot;&gt;
                        
                        &lt;div class=&quot;user-bar&quot;&gt;
                            &lt;ul class=&quot;user-bar__links&quot;&gt;
                                                                &lt;a class=&quot;item icon app-download btnDownloadTop&quot; title=&quot;OSC小程序&quot;&gt;&lt;i class=&quot;oicon oicon-phone&quot;/&gt;&lt;/a&gt;
                                &lt;div class=&quot;ui popup top left transition btnDownloadTopContent hidden&quot;&gt;
                                    &lt;h3 class=&quot;header&quot;&gt;OSCHINA 小程序 —— &lt;br/&gt;关注技术领域的头条文章&lt;/h3&gt;
                                    &lt;p&gt;聚合全网技术文章，根据你的阅读喜好进行个性推荐&lt;/p&gt;
                                    &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-91f008637a179c217fdec464b7bad202844.jpg&quot; alt=&quot;OSC小程序&quot;/&gt;
                                &lt;/div&gt;

                                                                    &lt;a class=&quot;item&quot; href=&quot;https://www.oschina.net/home/login?goto_page=https%3A%2F%2Fmy.oschina.net%2Fu%2F4939618%2Fblog%2F5585451%3Fhmsr%3Dtoutiao.io%26utm_campaign%3Dtoutiao.io%26utm_medium%3Dtoutiao.io%26utm_source%3Dtoutiao.io&quot;&gt;登录&lt;/a&gt;
                                                                &lt;a class=&quot;item&quot; href=&quot;https://www.oschina.net/home/reg?goto_page=https%3A%2F%2Fmy.oschina.net%2Fu%2F4939618%2Fblog%2F5585451%3Fhmsr%3Dtoutiao.io%26utm_campaign%3Dtoutiao.io%26utm_medium%3Dtoutiao.io%26utm_source%3Dtoutiao.io&quot;&gt;注册&lt;/a&gt;
                                                                        &lt;/ul&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        
                
                
        
                &lt;/div&gt;&lt;/body&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7b5c63668bd5b4698caf7f9102d6e6b9</guid>
<title>精进 JavaScript ｜ 这些手写你都会吗 ？</title>
<link>https://toutiao.io/k/d7k5x0f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxNzk1MjQ0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YBFV3Da0Nwvv72YkFO0qPibDKicOCsfltiaE9070DOu4iahXnicYwRIHcxe9VBicAy45MkPqy8nZzLTVibugOtV0ORFcg/0?wx_fmt=png&quot; data-nickname=&quot;程序员成长指北&quot; data-alias=&quot;coder_growth&quot; data-signature=&quot;专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大厂技术&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;高级前端&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;Node进阶&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;程序员成长指北&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，加入高级Node交流群&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道今年大家有没有感受到来自互联网的“寒气”，至少我是感受到了，面试的时候手写代码时很常见很常见的事情了。有时候没遇到过还真一时半会写不出来，企业招聘的要求也是越来越高，尤其是一些大厂会对 JS 的功底有着更加苛刻的要求，所以学会手写常见的 JS 模块好像已经快变为一个基本技能了，也慢慢变为我们手写 webpack 手写 mini-vue 的一个 &lt;code&gt;coding&lt;/code&gt; 基础 了。当然我们也不完全是为了去准备面试而去学习这些常见模块。死磕这些难啃的骨头之后，你会从中学到很多优秀的思想，对你的职业生涯也是很有帮助的。而且阅读代码本身就是一个很好的习惯，读懂并且理解写代码人的思维逻辑更加重要。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文中涉及到的手写模块，大多数都是从网上的博客、面筋、牛客网以及自己的面试经验借鉴而来的。希望能对你有个帮助。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基础手写&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;全排列（力扣原题）&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要求以数组的形式返回字符串参数的所有排列组合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;字符串参数中的字符无重复且仅包含小写字母&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;返回的排列组合数组不区分顺序&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;const _permute = &lt;span&gt;string&lt;/span&gt; =&amp;gt; {&lt;br/&gt;  const result = []&lt;br/&gt;  const map = new Map()&lt;br/&gt;  const dfs = (&lt;span&gt;path&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;path&lt;/span&gt;.length === &lt;span&gt;string&lt;/span&gt;.length) {&lt;br/&gt;      result.push(&lt;span&gt;path&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (let i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;string&lt;/span&gt;.length; i++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (map.get(&lt;span&gt;string&lt;/span&gt;[i])) continue&lt;br/&gt;      map.set(&lt;span&gt;string&lt;/span&gt;[i], &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;path&lt;/span&gt; += &lt;span&gt;string&lt;/span&gt;[i]&lt;br/&gt;      dfs(&lt;span&gt;path&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;path&lt;/span&gt; = &lt;span&gt;path&lt;/span&gt;.substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;path&lt;/span&gt;.length - &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;      map.set(&lt;span&gt;string&lt;/span&gt;[i], &lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  dfs(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;console.&lt;span&gt;log&lt;/span&gt;(_permute(&lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;)) // [ &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;acb&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;bac&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;bca&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;cab&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;cba&#x27;&lt;/span&gt; ]&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果 target 为基本数据类型直接返回 false&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断 Fn.prototype 是否在 target 的隐式原型链上&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; _instanceof = &lt;span&gt;(&lt;span&gt;target, Fn&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;typeof&lt;/span&gt; target !== &lt;span&gt;&#x27;object&#x27;&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; target !== &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) || target === &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; proto = target.__proto__&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (proto === &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (proto === Fn.prototype) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    proto = proto.__proto__&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;() &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt; A()&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(_instanceof(a, A)) &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(_instanceof(&lt;span&gt;1&lt;/span&gt;, A)) &lt;span&gt;// false&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Array.prototype.map&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;map 中的 exc 接受三个参数，分别是: 元素值、元素下标和原数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;map 返回的是一个新的数组，地址不一样&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 这里不能直接使用箭头函数，否则无法访问到 this&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Array&lt;/span&gt;.prototype._map = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;exc&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; result = []&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.forEach(&lt;span&gt;(&lt;span&gt;item, index, arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    result[index] = exc(item, index, arr)&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;).fill(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a.map(&lt;span&gt;(&lt;span&gt;item, index, arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; item * index + &lt;span&gt;1&lt;/span&gt;)) &lt;span&gt;// [1,3]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a._map(&lt;span&gt;(&lt;span&gt;item, index, arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; item * index + &lt;span&gt;1&lt;/span&gt;))&lt;span&gt;// [1,3]&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Array.prototype.filter&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;filter 中的 exc 接受三个参数，与map一致，主要实现的是数组的过滤功能，会根据 exc 函数的返回值来判断是否“留下”该值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;filter 返回的是一个新的数组，地址不一致。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Array&lt;/span&gt;.prototype._filter = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;exc&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; result = []&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.forEach(&lt;span&gt;(&lt;span&gt;item, index, arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (exc(item, index, arr)) {&lt;br/&gt;      result.push(item)&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; b = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(b._filter(&lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; item % &lt;span&gt;2&lt;/span&gt; === &lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;// [ 4, 6, 2, 8, 20 ]&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Array.prototype.reduce&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;reduce 接受两个参数，第一个为 exc 函数，第二个为初始值，如果不传默认为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;reduce 最终会返回一个值，当然不一定是 Number 类型的，取决于你是怎么计算的，每次的计算结果都会作为下次 exc 中的第一个参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Array&lt;/span&gt;.prototype._reduce = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;exc, initial = &lt;span&gt;0&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; result = initial&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.forEach(&lt;span&gt;(&lt;span&gt;item&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    result = exc(result, item)&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(b.reduce(&lt;span&gt;(&lt;span&gt;pre, cur&lt;/span&gt;) =&amp;gt;&lt;/span&gt; pre + cur, &lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;// 55&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(b._reduce(&lt;span&gt;(&lt;span&gt;pre, cur&lt;/span&gt;) =&amp;gt;&lt;/span&gt; pre + cur, &lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;// 55&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Object.create&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MDN&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; Object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;.prototype._create = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;proto&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; Fn = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; () &lt;/span&gt;{ }&lt;br/&gt;  Fn.prototype = proto&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Fn()&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;() &lt;/span&gt;{ }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj = &lt;span&gt;Object&lt;/span&gt;.create(A)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj2 = &lt;span&gt;Object&lt;/span&gt;._create(A)&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(obj.__proto__ === A) &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(obj.__proto__ === A) &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Function.prototype.call&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Function&lt;/span&gt;.prototype._call = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;ctx, ...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 如果不为空，则需要进行对象包装&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; o = ctx == &lt;span&gt;undefined&lt;/span&gt; ? &lt;span&gt;window&lt;/span&gt; : &lt;span&gt;Object&lt;/span&gt;(ctx)&lt;br/&gt;  &lt;span&gt;// 给 ctx 添加独一无二的属性&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; key = &lt;span&gt;Symbol&lt;/span&gt;()&lt;br/&gt;  o[key] = &lt;span&gt;this&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 执行函数，得到返回结果&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; result = o[key](...args)&lt;br/&gt;  &lt;span&gt;// 删除该属性&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;delete&lt;/span&gt; o[key]&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj = {&lt;br/&gt;  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;11&#x27;&lt;/span&gt;,&lt;br/&gt;  fun() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;.name)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj2 = { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;22&#x27;&lt;/span&gt; }&lt;br/&gt;obj.fun() &lt;span&gt;// 11&lt;/span&gt;&lt;br/&gt;obj.fun.call(obj2) &lt;span&gt;// 22&lt;/span&gt;&lt;br/&gt;obj.fun._call(obj2) &lt;span&gt;// 22&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Function.prototype.bind&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; obj = {&lt;br/&gt;  name: &lt;span&gt;&#x27;11&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    console.log(&lt;span&gt;this&lt;/span&gt;.name)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;Function.prototype._bind = function (ctx, ...args) {&lt;br/&gt;  &lt;span&gt;// 获取函数体&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; _self = &lt;span&gt;this&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 用一个新函数包裹，避免立即执行&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; bindFn = (...reset) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; _self.call(ctx, ...args, ...reset)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; bindFn&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj2 = { name: &lt;span&gt;&#x27;22&#x27;&lt;/span&gt; }&lt;br/&gt;obj&lt;span&gt;.&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; &lt;span&gt;// 11&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; fn = obj&lt;span&gt;.&lt;span&gt;fun&lt;/span&gt;.&lt;span&gt;bind&lt;/span&gt;&lt;span&gt;(obj2)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; fn2 = obj&lt;span&gt;.&lt;span&gt;fun&lt;/span&gt;.&lt;span&gt;_bind&lt;/span&gt;&lt;span&gt;(obj2)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;fn() &lt;span&gt;// 22&lt;/span&gt;&lt;br/&gt;fn2() &lt;span&gt;// 22&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;New 关键字&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; _new = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;constructor&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 创建一个空对象&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; obj = {}&lt;br/&gt;  &lt;span&gt;// 原型链挂载&lt;/span&gt;&lt;br/&gt;  obj.__proto__ = &lt;span&gt;constructor&lt;/span&gt;.prototype;&lt;br/&gt;  // 将obj 复制给构造体中的 this，并且返回结果&lt;br/&gt;  const result = &lt;span&gt;constructor&lt;/span&gt;.call(obj)&lt;br/&gt;  // 如果返回对象不为一个对象则直接返回刚才创建的对象&lt;br/&gt;  return typeof result === &#x27;object&#x27; &amp;amp;&amp;amp; result !== null ? : result : obj&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;浅拷贝&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; _shallowClone = target =&amp;gt; {&lt;br/&gt;  &lt;span&gt;// 基本数据类型直接返回&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (typeof target === &lt;span&gt;&#x27;object&#x27;&lt;/span&gt; &amp;amp;&amp;amp; target !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// 获取target 的构造体&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;constructor&lt;/span&gt; = target.&lt;span&gt;constructor&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果构造体为以下几种类型直接返回&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (/^(Function|RegExp|Date|Map|Set)$/i.test(&lt;span&gt;constructor&lt;/span&gt;.name)) &lt;span&gt;return&lt;/span&gt; target&lt;br/&gt;    &lt;span&gt;// 判断是否是一个数组&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; cloneTarget = Array.isArray(target) ? [] : {}&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (prop &lt;span&gt;in&lt;/span&gt; target) {&lt;br/&gt;      &lt;span&gt;// 只拷贝其自身的属性&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (target.hasOwnProperty(prop)) {&lt;br/&gt;        cloneTarget[prop] = target[prop]&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; cloneTarget&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; target&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;深拷贝&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现思路和浅拷贝一致，只不过需要注意几点&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;函数 正则 日期 ES6新对象 等不是直接返回其地址，而是重新创建&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;需要避免出现循环引用的情况&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; _completeDeepClone = &lt;span&gt;(&lt;span&gt;target, map = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;WeakMap&lt;/span&gt;(&lt;/span&gt;)) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 基本数据类型，直接返回&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; target !== &lt;span&gt;&#x27;object&#x27;&lt;/span&gt; || target === &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; target&lt;br/&gt;  &lt;span&gt;// 函数 正则 日期 ES6新对象,执行构造题，返回新的对象&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;constructor&lt;/span&gt; = target.&lt;span&gt;constructor&lt;/span&gt;&lt;br/&gt;  if (/^(Function|RegExp|Date|Map|Set)$/i.test(&lt;span&gt;constructor&lt;/span&gt;.name)) return new &lt;span&gt;constructor&lt;/span&gt;(target)&lt;br/&gt;  // map标记每一个出现过的属性，避免循环引用&lt;br/&gt;  if (map.&lt;span&gt;get&lt;/span&gt;(target)) return map.&lt;span&gt;get&lt;/span&gt;(target)&lt;br/&gt;  map.&lt;span&gt;set&lt;/span&gt;(target, true)&lt;br/&gt;  const cloneTarget = Array.isArray(target) ? [] : {}&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (prop &lt;span&gt;in&lt;/span&gt; target) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (target.hasOwnProperty(prop)) {&lt;br/&gt;      cloneTarget[prop] = _completeDeepClone(target[prop], map)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; cloneTarget&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;寄生组合式继承&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一图胜千言&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7189655172413794&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKntlVGVJwYjMwuP4ss6icD5ia5Fp3CiaRSV2rf79bMkoISz8sL76jAEopxbdfdicjKaWXrwTIGuFdhk5A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;580&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.name = name&lt;br/&gt;}&lt;br/&gt;Parent.prototype.getName = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; () &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.name&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Son&lt;/span&gt;(&lt;span&gt;name, age&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 这里其实就等于 this.name = name&lt;/span&gt;&lt;br/&gt;  Parent.call(&lt;span&gt;this&lt;/span&gt;, name)&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.age = age&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;Son.prototype.getAge = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; () &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.age&lt;br/&gt;}&lt;br/&gt;Son.prototype.__proto__ = &lt;span&gt;Object&lt;/span&gt;.create(Parent.prototype)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; son1 = &lt;span&gt;new&lt;/span&gt; Son(&lt;span&gt;&#x27;shao&#x27;&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(son1.getName()) &lt;span&gt;// shao&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(son1.getAge()) &lt;span&gt;// 20&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;发布订阅者模式&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;EventEmitter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// key: 事件名&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// value: callback [] 回调数组&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.events = {}&lt;br/&gt;  }&lt;br/&gt;  on(name, callback) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.events[name]) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.events[name].push(callback)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.events[name] = [callback]&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  off(name, callback) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.message[name]) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!callback) {&lt;br/&gt;      &lt;span&gt;// 如果没有callback,就删掉整个事件&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.message[name] = undefined;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.message[name] = &lt;span&gt;this&lt;/span&gt;.message[name].filter((item) =&amp;gt; item !== callback);&lt;br/&gt;&lt;br/&gt;  }&lt;br/&gt;  emit(name, ...args) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.events[name]) &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.events[name].forEach(cb =&amp;gt; cb(...args))&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;观察者模式&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Observerd&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// 我要看看到底有多少人在观察俺&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.observerList = []&lt;br/&gt;  }&lt;br/&gt;  addObserver(observer) {&lt;br/&gt;    &lt;span&gt;// 添加一个观察俺的人&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.observerList.push(observer)&lt;br/&gt;  }&lt;br/&gt;  notify() {&lt;br/&gt;    &lt;span&gt;// 我要闹点动静，所有观察者都会知道这个信息，具体怎么做就是他们自己的事情了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.observerList.forEach(&lt;span&gt;&lt;span&gt;observer&lt;/span&gt; =&amp;gt;&lt;/span&gt; observer.update())&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Observer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(doSome) {&lt;br/&gt;    &lt;span&gt;// 观察到小白鼠有动静之后，观察者做的事情&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.doSome = doSome&lt;br/&gt;  }&lt;br/&gt;  update() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;.doSome)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; ob1 = &lt;span&gt;new&lt;/span&gt; Observer(&lt;span&gt;&#x27;我是ob1，我观察到小白鼠有反应了，太饿了，我得去吃个饭了&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; ob2 = &lt;span&gt;new&lt;/span&gt; Observer(&lt;span&gt;&#x27;我是ob2，我观察到小白鼠有反应了，我要继续工作！&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; xiaoBaiShu = &lt;span&gt;new&lt;/span&gt; Observerd()&lt;br/&gt;xiaoBaiShu.addObserver(ob1)&lt;br/&gt;xiaoBaiShu.addObserver(ob2)&lt;br/&gt;xiaoBaiShu.notify() &lt;span&gt;// .... .... &lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多说一句：怎么理解发布订阅者和观察者的区别呢 ？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实发布订阅者模式只有一个中间者，好像啥事情都需要它亲自来做。而且仔细观察的话，发布订阅者模式会存在一个事件名和事件的对应关系，今天可以发布天气预报，只有订阅了天气预报的才会被通知，订阅了 KFC疯狂星期四闹钟事件 的不会被提醒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;而观察者模式，等被观察者发出了一点动静（执行notify），所有观察者都会被通知。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;节流&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节流函数（throttle）就是让事件处理函数（handler）在大于等于执行周期时才能执行，周期之内不执行，即事件一直被触发，那么事件将会按每小段固定时间一次的频率执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;throttle&lt;/span&gt;(&lt;span&gt;fn, delay = &lt;span&gt;300&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 这里始终记得字节二面的时候，建议我不写 flag 好家伙&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; isThrottling = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 核心思路，函数多次执行只有当 isThrottling 为 false 时才会进入函数体&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!isThrottling) {&lt;br/&gt;      isThrottling = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        isThrottling = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;        fn.apply(&lt;span&gt;this&lt;/span&gt;, args)&lt;br/&gt;      }, delay)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;防抖&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事件响应函数在一段时间后才执行，如果这段时间内再次调用，则重新计算执行时间&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;debounce&lt;/span&gt;(&lt;span&gt;fn, delay = &lt;span&gt;300&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; timer = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 每次进来都会清空定时器，所以在 delay 事件中重复执行之后执行最后一次&lt;/span&gt;&lt;br/&gt;    clearInterval(timer)&lt;br/&gt;    timer = setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      fn.apply(&lt;span&gt;this&lt;/span&gt;, args)&lt;br/&gt;    }, delay)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;once 函数&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数返回结果会被缓存下来，只会计算一次。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;const f = (x) =&amp;gt; x;&lt;br/&gt;const onceF = once(f);&lt;br/&gt;//=&amp;gt; 3&lt;br/&gt;onceF(3);&lt;br/&gt;//=&amp;gt; 3&lt;br/&gt;onceF(4);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; once = &lt;span&gt;(&lt;span&gt;fn&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; res, isFirst = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!isFirst) &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;    res = fn.call(&lt;span&gt;this&lt;/span&gt;, ...args)&lt;br/&gt;    isFirst = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;累加函数应用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现一个累加函数，下面的几种情况都能正确的调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;console.log(sum(1, 2)(3)()) // 6&lt;br/&gt;console.log(sum(1)(2)(3)()) // 6&lt;br/&gt;console.log(sum(1, 2, 4)(4)()) // 11&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;function &lt;span&gt;sum&lt;/span&gt;(&lt;span&gt;...args&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; &lt;span&gt;params&lt;/span&gt; = args&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; _sum = (...newArgs) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (newArgs.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;params&lt;/span&gt;.reduce((pre, cur) =&amp;gt; pre + cur, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;params&lt;/span&gt; = [...&lt;span&gt;params&lt;/span&gt;, ...newArgs]&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; _sum&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; _sum&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进阶&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实现 repeat 方法&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;repeat&lt;/span&gt;(&lt;span&gt;fn, times, delay&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; times; i++) {&lt;br/&gt;      &lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          fn.call(&lt;span&gt;this&lt;/span&gt;, ...args)&lt;br/&gt;          resolve()&lt;br/&gt;        }, delay)&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; repeatFn = repeat(&lt;span&gt;console&lt;/span&gt;.log, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// 函数调用四次，每次间隔 1s 打印 hello&lt;/span&gt;&lt;br/&gt;repeatFn(&lt;span&gt;&#x27;hello&#x27;&lt;/span&gt;)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实现 Promise.all/race/allSettled/any&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Promise 身上的这些方法返回的都是一个 Promise&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Promise.resolve 接受一个 Promise，若非 promise 则将其变成功状态的 Promise&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 有一个失败则返回失败的结果，全部成功返回全成功的数组&lt;br/&gt;Promise.all = function (promiseList = []) {&lt;br/&gt;  return new Promise((resolve, reject) =&amp;gt; {&lt;br/&gt;    const result = []&lt;br/&gt;    let count = 0&lt;br/&gt;    if (promiseList.length === 0) {&lt;br/&gt;      resolve(result)&lt;br/&gt;      return&lt;br/&gt;    }&lt;br/&gt;    for (let i = 0; i &amp;lt; promiseList.length; i++) {&lt;br/&gt;      Promise.resolve(promiseList[i]).then(res =&amp;gt; {&lt;br/&gt;        result[i] = res&lt;br/&gt;        count++&lt;br/&gt;        // 不能直接通过 result.length 进行比较，因为 会存在下标大的先赋值&lt;br/&gt;        // 例如 i = 3 第一个返回结果，此时数组变为[empty,empty,empty,res]&lt;br/&gt;        if (count === promiseList.length) {&lt;br/&gt;          resolve(result)&lt;br/&gt;        }&lt;br/&gt;      }).catch(e =&amp;gt; {&lt;br/&gt;        reject(e)&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;// 返回第一个成功或失败的结果&lt;br/&gt;Promise.race = function (promiseList = []) {&lt;br/&gt;  return new Promise((resolve, reject) =&amp;gt; {&lt;br/&gt;    if (promiseList.length === 0) {&lt;br/&gt;      return resolve([])&lt;br/&gt;    }&lt;br/&gt;    for (let i = 0; i &amp;lt; promiseList.length; i++) {&lt;br/&gt;      Promise.resolve(promiseList[i]).then(res =&amp;gt; {&lt;br/&gt;        resolve(res)&lt;br/&gt;      }).catch(e =&amp;gt; {&lt;br/&gt;        reject(e)&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;// 无论成功约否都返回，但是会添加一个 status 字段用于标记成功/失败&lt;br/&gt;Promise.allSettled = function (promiseList = []) {&lt;br/&gt;  return new Promise((resolve, reject) =&amp;gt; {&lt;br/&gt;    const result = []&lt;br/&gt;    let count = 0&lt;br/&gt;&lt;br/&gt;    const addRes = (i, data) =&amp;gt; {&lt;br/&gt;      result[i] = data&lt;br/&gt;      count++&lt;br/&gt;      if (count === promiseList.length) {&lt;br/&gt;        resolve(result)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    if (promiseList.length === 0) return resolve(result)&lt;br/&gt;    for (let i = 0; i &amp;lt; promiseList.length; i++) {&lt;br/&gt;      Promise.resolve(promiseList[i]).then(res =&amp;gt; {&lt;br/&gt;        addRes(i, { status: &#x27;fulfilled&#x27;, data: res })&lt;br/&gt;      }).catch(e =&amp;gt; {&lt;br/&gt;        addRes(i, { status: &#x27;rejected&#x27;, data: e })&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;// AggregateError，当多个错误需要包装在一个错误中时，该对象表示一个错误。&lt;br/&gt;// 和 Promise.all 相反，全部失败返回失败的结果数组，有一个成功则返回成功结果&lt;br/&gt;Promise.any = function (promiseList = []) {&lt;br/&gt;  return new Promise((resolve, reject) =&amp;gt; {&lt;br/&gt;    if (promiseList.length === 0) return resolve([])&lt;br/&gt;    let count = 0&lt;br/&gt;    const result = []&lt;br/&gt;    for (let i = 0; i &amp;lt; promiseList.length; i++) {&lt;br/&gt;      Promise.resolve(promiseList[i]).then(res =&amp;gt; {&lt;br/&gt;        resolve(res)&lt;br/&gt;      }).catch(e =&amp;gt; {&lt;br/&gt;        count++&lt;br/&gt;        result[i] = e&lt;br/&gt;        if (count === promiseList.length) {&lt;br/&gt;          reject(new AggregateError(result))&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整数千分位加逗号&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;1234567&lt;/span&gt; -&amp;gt; &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;234&lt;/span&gt;,&lt;span&gt;567&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;function toThousands(num) {&lt;br/&gt;  num = num.toString()&lt;br/&gt;  let result = &#x27;&#x27;&lt;br/&gt;  while (num.length &amp;gt; 3) {&lt;br/&gt;    result = &#x27;,&#x27; + num.substring(num.length - 3) + result&lt;br/&gt;    num = num.substring(0, num.length - 3)&lt;br/&gt;  }&lt;br/&gt;  result = num + result&lt;br/&gt;  return result&lt;br/&gt;}&lt;br/&gt;console.log(toThousands(1234567)) // 1,234,567&lt;br/&gt;console.log(toThousands(123456)) // 123,456&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;洗牌函数&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有几张牌张牌，用 js 来进行乱序排列，要保持公平性&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;const shuffle = (arr) =&amp;gt; {&lt;br/&gt;  // 不影响原来的数组&lt;br/&gt;  const result = [...arr]&lt;br/&gt;  for (let i = result.length; i &amp;gt; 0; i--) {&lt;br/&gt;    // 随机从 [0,i - 1] 产生一个 index, 将 i - 1 于 index 对应数组的值进行交换&lt;br/&gt;    const index = Math.floor(Math.random() * i);&lt;br/&gt;    [result[index], result[i - 1]] = [result[i - 1], result[index]]&lt;br/&gt;  }&lt;br/&gt;  return result&lt;br/&gt;}&lt;br/&gt;const arr = [1, 2, 3, 4, 5]&lt;br/&gt;console.log(shuffle(arr)) // [ 3, 1, 2, 5, 4 ]&lt;br/&gt;console.log(shuffle(arr)) // [ 2, 3, 5, 1, 4 ]&lt;br/&gt;console.log(shuffle(arr)) // [ 4, 2, 3, 1, 5 ]&lt;br/&gt;console.log(shuffle(arr)) // [ 5, 4, 2, 3, 1 ]&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;手写LRU&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的&lt;span&gt;页面置换算法&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，选择最近最久未使用的页面予以淘汰。该算法赋予每个&lt;span&gt;页面&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;力扣地址&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; {number} capacity&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; LRUCache = function(capacity) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.map = new Map()&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.capacity = capacity&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** &lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; {number} key&lt;br/&gt; * &lt;span&gt;@return&lt;/span&gt; {number}&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;LRUCache.prototype.&lt;span&gt;get&lt;/span&gt; = function(key) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.map.has(key)){&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; value = &lt;span&gt;this&lt;/span&gt;.map.&lt;span&gt;get&lt;/span&gt;(key)&lt;br/&gt;        &lt;span&gt;// 更新存储位置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.map.delete(key)&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.map.&lt;span&gt;set&lt;/span&gt;(key,value)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; value&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** &lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; {number} key &lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; {number} value&lt;br/&gt; * &lt;span&gt;@return&lt;/span&gt; {void}&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;LRUCache.prototype.put = function(key, value) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.map.has(key)){&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.map.delete(key)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.map.&lt;span&gt;set&lt;/span&gt;(key,value)&lt;br/&gt;    &lt;span&gt;// 如果此时超过了最长可存储范围&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.map.size &amp;gt; &lt;span&gt;this&lt;/span&gt;.capacity){&lt;br/&gt;        &lt;span&gt;// 删除 map 中最久未使用的元素&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.map.delete(&lt;span&gt;this&lt;/span&gt;.map.keys().next().value)&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更上一层楼&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Generator&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看下面输出的内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getResult&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            resolve(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            resolve(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            resolve(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;getResult()&lt;br/&gt;&lt;span&gt;// 1 2 3 &lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何使用 Es6 中的 generator 实现类似的效果呢 ？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt;* &lt;span&gt;getResult&lt;/span&gt;(&lt;span&gt;params&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            resolve(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            resolve(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            resolve(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; gen = getResult()&lt;br/&gt;&lt;span&gt;// gen.next().value 就是每一次 yield 之后返回的 Promise&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// gen.next() = {value: yeild 返回的数据,done: 迭代器是否走完}&lt;/span&gt;&lt;br/&gt;gen.next().value.then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    gen.next().value.then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        gen.next();&lt;br/&gt;    });&lt;br/&gt;});&lt;span&gt;// 依次打印 1 2 3&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将 gen.next() 封装一层，让其自己能够实现递归调用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;const gen = getResult()&lt;br/&gt;function co(g) {&lt;br/&gt;  const nextObj = g.next();&lt;br/&gt;  // 递归停止条件：当迭代器迭代到最后一个 yeild &lt;br/&gt;  if (nextObj.done) {&lt;br/&gt;    return;&lt;br/&gt;  }&lt;br/&gt;  nextObj.value.then(()=&amp;gt;{&lt;br/&gt;    co(g)&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;co(gen)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;async-pool&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JS 控制并发请求， 参考文章 &lt;span&gt;mp.weixin.qq.com/s/yWOPoef9i…&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0262068965517241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKntlVGVJwYjMwuP4ss6icD5ia8fEuO4KawprmdxJ40dVib2OibM1aOez5b0pgykrYdHIpThwaPyNRXztw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1450&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;aysnc-pool 的基本使用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; timeout = &lt;span&gt;&lt;span&gt;i&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;resolve&lt;/span&gt; =&amp;gt;&lt;/span&gt; setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; resolve(i), i));&lt;br/&gt;&lt;span&gt;await&lt;/span&gt; asyncPool(&lt;span&gt;2&lt;/span&gt;, [&lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;5000&lt;/span&gt;, &lt;span&gt;3000&lt;/span&gt;, &lt;span&gt;2000&lt;/span&gt;], timeout);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;asyncPool 这个函数接受三个参数&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;poolLimit（数字类型）：表示限制的并发数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;array（数组类型）：表示任务数组；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iteratorFn（函数类型）：表示迭代函数，用于实现对每个任务项进行处理，该函数会返回一个 Promise 对象或异步函数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里提醒一下，promise.then 中的函数执行是一异步的，而赋值是同步的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; a = &lt;span&gt;Promise&lt;/span&gt;.resolve().then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;console&lt;/span&gt;.log(a))&lt;br/&gt;&lt;span&gt;// 等价于 此时 a 等于一个 pending 状态的 promise&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; a = &lt;span&gt;Promise&lt;/span&gt;.resolve().then()&lt;br/&gt;a.then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(a)&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手写实现，这部分可能会多花点时间。可以拷贝代码多调试几次就知道了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;async function asyncPool(poolLimit, array, iteratorFn) {&lt;br/&gt;  const ret = []; // 存储所有的异步任务&lt;br/&gt;  const executing = []; // 存储正在执行的异步任务&lt;br/&gt;  for (const item of array) {&lt;br/&gt;    // 调用iteratorFn函数创建异步任务&lt;br/&gt;    const p = Promise.resolve().then(() =&amp;gt; iteratorFn(item, array));&lt;br/&gt;    ret.push(p); // 保存新的异步任务&lt;br/&gt;&lt;br/&gt;    // 当poolLimit值小于或等于总任务个数时，进行并发控制&lt;br/&gt;    if (poolLimit &amp;lt;= array.length) {&lt;br/&gt;      // 当任务完成后，从正在执行的任务数组中移除已完成的任务&lt;br/&gt;      const e = p.then(() =&amp;gt; executing.splice(executing.indexOf(e), 1));&lt;br/&gt;      executing.push(e); // 保存正在执行的异步任务&lt;br/&gt;      if (executing.length &amp;gt;= poolLimit) {&lt;br/&gt;        await Promise.race(executing); // 等待较快的任务执行完成&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  return Promise.all(ret);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const timeout = i =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; { console.log(i); resolve(i) }, i));&lt;br/&gt;// 当然,limit &amp;lt;= 0 的时候 我们可以理解为只允许一个请求存在 &lt;br/&gt;asyncPool(2, [1000, 5000, 3000, 2000], timeout).then(res =&amp;gt; {&lt;br/&gt;  console.log(res)&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总共花费 6 s 时间，符合预期&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3256880733944954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKntlVGVJwYjMwuP4ss6icD5iaA9Su0TAlFl34CLT5Yxn7GSMibNYk6pcPQk1ia9GahlNOBjBFmsbjeZgw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;872&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收集这些手写的时候,自己也学到了很多东西，其实也是一个查漏补缺的过程。感谢你看到这里，点赞收藏 &lt;code&gt;offer ++&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>420ad5751925a7bd91211c86dd59783d</guid>
<title>秒杀系统设计套路，一套带走</title>
<link>https://toutiao.io/k/xtptia2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;你好，我是yes。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天来看看秒杀设计的套路，然后文末再送一波书~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;曾经有一家巨头公司和我们公司进行战略合作，经过双方的不懈努力及精诚合作，双方公司决定共同举办一场秒杀活动，我们公司提供优质商品和强有力的吸引价格以及使用场景，对方公司提供巨大的用户流量，再加上我们公司自己的用户流量，粗略估算下来有5000万的用户流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，当时我们的架构是完全支撑不了千万级流量的瞬时冲击的，但是双方老板已经达成协议就要快速干起来，而且给了一个基本无法完成的时间期限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于时间紧急，我们公司技术部召开了紧急会议，最终得出结论就是在原有架构基础上增加秒杀的相关接口，增加两个H5页面作为前端秒杀活动的承接页面，然后等待洪水般流量的到来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当秒杀活动真正开始时，流量远超过我们的估算，很快就卡住不动了，后台服务器内存、CPU、数据库负载等全满负荷了。期间，正常下单的用户也不能正常访问公司App以及下单。不难猜出，这个结果老板肯定是不满意的，要求必须解决，不能终止本次活动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最后的解决办法是：使用金钱来砸——立刻增加120多台云服务器来承载当时的秒杀活动。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;那次活动对于技术部门来讲无疑是一个痛苦的经历，也是一个“不光彩”的经历。于是，后面增加了针对秒杀架构的设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;225:661&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;需求分析&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;“秒杀”这个词在电商行业中出现的频率较高，如京东或者淘宝平台的各种“秒杀”活动，最典型的就是“双11抢购”。&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;“秒杀”是指在有限的时间内对有限的商品数量进行抢购的一种行为，这是商家以“低价量少”的商品来获取用户的一种营销手段。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01. 功能性需求&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;其实，整个秒杀的业务场景并不复杂，可即查看参与秒杀的商品信息，加上购买和支付的动作，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8692307692307693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLcxDhv8SGcCGiaYrpVcxy0XtVdCtl9OwFKUaxak8IeTiczgYNFmszedsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;秒杀业务最大的挑战在于3点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;瞬时：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;持续时间极短，对于热门且具备极强竞争力的商品通常只有一秒。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;流量巨大：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;因为价格低廉，商品性价比高，而且正常买是需要很高的价格，所以才会吸引大量的用户来争抢。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数量有限：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;因为商品的低价且性价比高，所以只有很有限的商品数量参与秒杀。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;同时，在保证高并发流量承接的前提下，为了增强用户的体验和活动规则的公平性，以及防止遭到恶意破坏等，特此增加如下需求：&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;（1）用户在秒杀页面无需一直刷新“抢购”按钮，待秒杀活动开始时，按钮自动点亮。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）在公平以及防止恶意破坏的原则下，在下单之前增加验证码的录入，或者答题的相关环节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）库存不能出现问题，即不多扣也不少扣。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（4）整个秒杀活动过程持续10分钟。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02. 性能指标预估&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;通过秒杀的需求描述可得出，当前秒杀活动主要需要预估三块的性能指标：存储容量、并发量、网络带宽。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1）存储容量&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;由于是秒杀活动，且参与的商品基本都是低价高性价比的，数量是非常有限的。所以，在订单存储上基本不用去过多考虑。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;2）并发量&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;针对5000万用户平均每人访问2次，则并发量为每秒16.7万左右（5000w*2/10*60）,在预留一部分，可以预估到每秒25万左右（也可以进行double下）。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;3）网络带宽&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在带宽方面，需要进行相关优化，采取数据传输越少越好，假设单条传输在0.5KB，则根据并发量预估网络带宽为：977Mb左右（25w*0.5KB=122MB*8bit=977Mb）。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03. 非功能性需求&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;做任何系统都要考虑非功能性需求，特别是公司的核心系统，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当前秒杀业务系统非功能性需求主要体现在如下几点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高可用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，在秒杀活动的整个持续期间内，都能对用户提供服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高性能&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，让每个用户都能感受到极快的秒杀响应，不能出现大批量用户延迟较高的现象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;可扩展&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，当流量比预期更高时，有平滑扩展的策略（也有部分产品设计成友好的拒绝策略）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;213:645&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;概要设计&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;通过对秒杀业务的本身认知以及上面提到的秒杀业务需求，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本次秒杀系统需要着重设计如下几点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;（1）动静分离：如何保证用户在不刷新页面的情况下，依然能进行秒杀相关数据的获取且不会耽误秒杀活动的开始。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）流量分层，针对巨大流量，如何进行有效的防控，以免造成后台服务的不堪重负，以及如何避免前端页面的卡死。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）高可用：如何确保后台持续提供服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（4）扣减库存：如何有效扣减库存。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01. 动静分离&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;动静分离是指，将静态页面与动态页面（或者静态数据与动态数据）解耦分离，用不同系统承载对应流量。这样可以提升整个服务访问性能和可维护性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商品秒杀页面的静态数据以及动态数据，均是不同的地方提供，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2601851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLWZQel9jBAc51WoLGMsibGgiclCNn33mEvXcFXaShuhI9uhELcicWmIziaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;静态数据是指，页面中几乎不怎么变化的数据（即不依据用户的Cookie、基本信息、地域，及时间等各种属性来生成的数据），例如：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CSS和JavaScript中的静态文件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;活动页中的HTML静态文件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;图片等相关资源文件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;其他与用户信息无关的静态数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;对于这种分离出来的静态数据可以进行缓存。在缓存之后，这些静态数据的访问效率就提高了，系统也更快了。可以使用代理服务器进行静态数据的缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;动态数据是指，依据当前用户属性动态生成的数据，在浏览淘宝首页时，每个用户所看到的商品都是不一样的，这就是淘宝的“千人千面”——针对不同用户做不同的推荐；在百度搜索中是依据不同用户的输入条件，以及用户的习惯给出不同的结果页。这其中的数据就是动态数据。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02. 流量分层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在“秒杀”业务中，商品价格具有强大的吸引力，所以会受到很多用户的关注，但是商品数量是有限的。所以，在千万的用户中可能只有100人能得到商品，对于系统来说，有90%以上的流量属于无效流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“秒杀”业务希望有大量的用户来关注“秒杀”活动，但是在用户真正下单时又不能将这些流量全部放过，所以，需要设计一套高效的流量管控方案，来有效地控制请求流量，过滤掉没必要的流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于瞬时流量洪峰可以采用倒三角的分层级逐层控制方式，共分为CDN、反向代理（Nginx）、后端服务及DB这四个层级。接下来，就来看看每一层级是怎么控制流量的，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7956521739130434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFL3TSO3icBGtribdu06owmFicQax3yKbBCzT8aStQe7RXnRtZ6dMHsdZ7Yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03. 高可用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;要想在整个“秒杀”活动持续期间内，依然能对用户提供良好的体验，则秒杀系统架构在设计时不能设计成单节点的架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;单节点是所有系统设计中的大忌，因为单节点系统意味着系统的不稳定性较高，可能会出现不可用的情况，会给企业带来直接的损失。在系统设计（特别是“秒杀”这类对高并发要求极高的系统）时，必须保证系统的高可用，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.526431718061674&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLYLjNnTBrmtHeSzk2YkW5qibKtHPBZRibaEJicAMRH1qdfGwmC3M2mMibtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04. 扣减库存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;对于“秒杀”活动，通常，公司是不允许商品超卖（即下单成功的数量不能大于商品存存数量）的。一旦超卖，则会给公司造成损失。如果被恶意流量利用，则损失是巨大的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;库存对于电商平台来说是一个重要的业务指标，所以在技术上需要合理设计扣减库存，不能出现“超卖”现象。通常，扣减库存常有以下3种方式：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;05. 系统架构设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;根据上面讨论，针对当前秒杀架构如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0804162724692525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLVX8uPpwthndkOjNCiaIzPyPds84BELbKYBWaHBs13XVHnJn1VSdpTgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1057&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如上架构比较简洁，主要分为以下5层。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;其部署架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4965437788018433&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFL6LDhP9qBd0XAReRWTiaYJEJtXJRIYGqMiaiceQ67DricHEY07iaibQT6VtZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;868&quot;/&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;3&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;240:536&quot;&gt;&lt;span&gt;&lt;strong&gt;详细设计&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01. 动静分离设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实施动静分离架构可以采用“分而治之”的办法，即将动态数据和静态数据解耦，分别使用各自的架构系统来承载对应的流量：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;静态数据访问速度很快，而动态数据访问速度较慢。那么试想下，可以将需要动态获取的数据给提前生成好，然后使用静态页面加速技术来访问吗？如果这样可以，那动态数据访问的速度就变快了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样是可以的，需要用到比较流行的“页面静态化”技术。页面静态化技术是指，直接缓存HTTP连接，而不仅是缓存数据。如下图所示，代理服务器根据请求的URL直接将HTTP对应的响应头及响应消息体返回，流程简洁且高效。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49428208386277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLB5xyODNed3r6T3KGsBreof9dsvs5VXWvEzMhHpWj0YRJtqC8eodUEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;787&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02. 流量分层设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;流量分层主要体现在对于CDN层、反向代理层、后端服务层以及数据层流量进行控制。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1）CDN层流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;由动静分离技术可以想到：&lt;/span&gt;&lt;span&gt;应尽量将尽可能多的数据提前生成，然后将其放入CDN节点缓存中（因为CDN层在物理架构上离用户比较近）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，如果绝大部分的流量都在这一层获取数据，则到达后端的流量会减少很多，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6380165289256199&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLgicNGP1MsKA4BA9t5IVKrW74X71oMictTONgxS3icdQbtOb9icj37XoRvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;605&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;2）反向代理层流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在动静分离方案中，讲到通过“页面静态化技术”加速动态数据的获取，即提前将动态数据生成好，然后对其进行静态化处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，这里就可以依据页面静态化加速技术，通过后端服务Job的方式定时提前生成前端需要静态的数据；然后，将其发送到内容分发服务上；最后，分发服务会将这些静态化页面数据分发到所有的反向代理服务器上，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25031446540880503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLLUMPLMThXl7GASxtPOqRSVZZL4WJ5TMV13CA85h4hVOxFudU2iaw69g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;795&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在“秒杀”业务中，活动详情页上有一个倒计时的模块，用户可以看到当前“秒杀”活动还剩余多少时间开始。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种逻辑简单的功能可以直接使用Nginx来实现：&lt;/span&gt;&lt;span&gt;利用nginx-lua插件，使用lua脚本获取当前Nginx服务器的时间进行计算倒计时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，商品库存数据也可以通过Nginx直接访问分布式缓存来获取，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23796033994334279&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLLwvtCia28ibUnucz7AMJNAumxyWwL54ibJTomKjejxYS1WMIkYTGkcgZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1059&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“秒杀”业务中的商品价格很低，对于用户有很大的吸引力，所以可能会有人利用“秒杀器”进行不公平竞争，且有可能存在竞争对手恶意刷请求的情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果存在这样的情况，那本次活动就是有风险的，万一被恶意流量独占了库存，则会导致正常用户不能抢购商品，也有可能这种恶意的请求会对后端系统造成严重冲击，甚至造成后端系统瘫痪。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于这种恶意请求，最好有一套机制能提前感知，并将恶意请求提前封存。&lt;/span&gt;&lt;span&gt;可以在Nginx层中控制；也可以在Nginx中配置用户的访问频率（例如每分钟只能访问10次）；还可以使用Lua脚本编写一些简单业务逻辑的接口，例如，通过调用接口直接封掉指定IP地址或UserAgent的请求。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;3）后端服务层流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;对于服务层的流量控制，有以下几点建议：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;当“到达系统中的请求数”明显大于“系统能够处理的最大请求数”时，可以直接拒绝这些多余的请求，直接返回“秒杀”活动结束的信息。例如，活动开始时的商品库存是100，目前库存只剩50了，如果“每台服务器待处理的请求数”已经超过“商品总库存数（100）”了，则可以直接终止掉多余的请求。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;4）数据库层流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;对于请求到数据中的流量，写入的流量就是真正下单成功的流量，即需要扣减库存的动作。有如下建议：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;对于数据库行锁的优化，可以通过将商品进行拆分来实现——增加ID，如下图所示。对于单一的“秒杀”活动这会得到显著效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7359307359307359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLOXuDChq3P3tFv9TEArpJsiclrqOXo43Mp3pa3QU6xgVvvf1d359VYRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从流量分层控制方案可看出，瞬时流量就像被漏斗过滤了似的，应尽量将数据和请求量一层一层地过滤掉。这种流量分层控制核心思想：在不同的层级中尽可能地过滤掉无效的请求，到达“倒三角”最末端的请求才是有效的请求。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;5）高可用&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在系统设计时想要做到高可用，避免单节点的一个小妙招：将服务无状态化。如果无法完全无状态化（如存储系统），则可以通过冗余多个备份节点的方案来避免单节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于篇幅原因，高可用此处就不再赘述，大家可以查看&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《高并发系统实战派》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一书里面针对高并发系统的真实设计案例，毫无保留的分享出了企业级高并发系统实战。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03. 扣减库存设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;由于在“秒杀”场景中商品一般优惠力度很大，对用户很具有吸引力，所以，在这种场景中使用“下单扣库存”方式更为合适。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在“秒杀”场景中，大部分用户抱着“抢到就是赚到”的想法，基本都会去付款的，但如果真有竞争对手恶意下单不付款，那我们该怎么办？前面在流量管控中已经说到，可以对请求日志进行实时分析，让风控系统选择出恶意用户，然后将其封停。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在“秒杀”场景中，通过流量分层控制可以分层管控大量的“读”请求。但是，依然会有很大的流量进入真正的下单逻辑。对于这么大的流量，除前面说的数据库隔离外，还需要进一步优化库存，否则数据库读/写依然是系统的瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来看看如何优化大流量“秒杀”场景中的库存数量扣减操作。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1）利用缓存技术&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在“秒杀”场景中，如果只是一个扣减库存数量这样的简单流程，则可以先将库存数量直接放在缓存中，然后用分布式缓存（如Redis）的超高性能去应对这种瞬时流量洪峰下的系统挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用缓存是存在一定风险的，比如，缓存节点出现了异常，那库存数量该怎么算？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用缓存，不仅要考虑分布式缓存高可用（如何设计可以查看我的新书“高并发系统实战派”），还要考虑各种限流容错机制，以确保分布式缓存对外提供服务。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;2）异步处理技术&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;如果是复杂的扣减库存（如涉及商品信息本身或牵连其他系统），则建议使用数据库进行库存数量的扣减，可以使用异步的方式来应对这种高并发的库存的更新。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;①在用户下单时，不立刻生成订单，而是将所有订单依次放入队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②下单模块依据自身的处理速度，从队列中依次获取订单进行“下单扣库存”操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③在订单生成成功后，用户即可进行支付操作了。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这种方式是针对“秒杀”场景的，依据“先到先得”原则来保证公平公正，所有用户都可以抢购，然后等待订单处理，最后生成订单（如果库存不足，则生成订单失败）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的逻辑，对用户来说体验不是很差。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体排队逻辑如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15458015267175573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLa41cdph5dv6871PMwNrzg8YnCUZFdGWBqAe4VECnYiaBdeHQOhFia8icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFL5M3d8ACOXe4GkRba44HU9hqWJAdmuFOnKScozdvic5T1s457aZOwiaPg/640?wx_fmt=jpeg&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;4&quot;&gt;4&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;239:554&quot;&gt;&lt;strong&gt;&lt;span&gt;搭建千万级流量“秒杀”系统需要哪些技术&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;前面介绍了千万级流量“秒杀”系统的基本架构、“秒杀”系统的设计原则、如何做动静分离方案和流量控制，以及扣减库存方面内容。这些都是设计高并发“秒杀”系统必须要考虑的。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;“秒杀”系统的流程并不复杂——只是一个“下单扣库存”的动作，但由于其独特的业务特点，所以在进行系统设计时不能大意。对于瞬时流量洪峰的高并发“秒杀”系统，我们需要什么技术呢？下面来总结一下。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;（1）数据的静态化的技术&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;用来应对高并发读的请求，主要涉及以下内容，这些在&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《高并发系统实战派》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一书中详细分享了真实使用场景已经技术方案：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;各层级缓存的处理（即多级缓存的技术）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分布式缓存技术&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;（2）负载均衡反向代理技术&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;（3）异步处理技术&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;（4）系统架构设计技术&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;（5）系统监控技术&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;section data-id=&quot;89894&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section hm_fix=&quot;276:458&quot; data-width=&quot;100%&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/fgnkxfGnnkTkJIfWr9IueKsXFibaLaicJkRxJibPxKsxQFia5bylsyH1fdOBgDd11ibnth10uSKyNh4zdIMSmu09N7Q/640?wx_fmt=gif&quot; data-w=&quot;100&quot;/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;好嘞，今天的内容就到这。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更多相关内容可以看下&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《高并发系统实战派：集群、Redis缓存、海量存储、Elasticsearch、RocketMQ、微服务、持续集成等》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一书！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-templateid=&quot;list&quot; data-traceid=&quot;aaa6c183-f442-4dc1-92db-54580b1bdb07&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;101_13430165&quot; data-appuin=&quot;3915176470&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:10,&amp;quot;pid&amp;quot;:&amp;quot;101_13430165&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3915176470&amp;quot;,&amp;quot;trace_id&amp;quot;:&amp;quot;aaa6c183-f442-4dc1-92db-54580b1bdb07&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;101_13430165&amp;quot;,&amp;quot;source_id&amp;quot;:2,&amp;quot;source_name&amp;quot;:&amp;quot;京东&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://pcm-img.zhls.qq.com/productcenter-0ad8d80e--1018824-623404592840175064/95602431520102022/53c7cf63a4faeafbc0c67b35134f7de0.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;高并发系统实战派：集群、Redis缓存、海量存储、Elasticsearch、RocketMQ、微服务、持续集成等&amp;quot;,&amp;quot;current_price&amp;quot;:10900,&amp;quot;first_category_id&amp;quot;:&amp;quot;10&amp;quot;,&amp;quot;product_label_name_list&amp;quot;:[&amp;quot;京东配送&amp;quot;],&amp;quot;appuin&amp;quot;:&amp;quot;3915176470&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1,&amp;quot;templateId&amp;quot;:&amp;quot;list&amp;quot;}&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFL5M3d8ACOXe4GkRba44HU9hqWJAdmuFOnKScozdvic5T1s457aZOwiaPg/640?wx_fmt=jpeg&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot;/&gt;&lt;span draggable=&quot;true&quot;&gt; 限时下单立减50！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFL5M3d8ACOXe4GkRba44HU9hqWJAdmuFOnKScozdvic5T1s457aZOwiaPg/640?wx_fmt=jpeg&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot;/&gt;&lt;span&gt;送书规则&lt;/span&gt;：&lt;/p&gt;&lt;p&gt;截止10.30日晚上20点，留言点赞排名前四名，各得一本，包邮~&lt;/p&gt;&lt;p&gt;中奖者加我微信 yes_oba，私发我收件信息即可。&lt;/p&gt;&lt;p&gt;&lt;span&gt;刷赞或非此行业从事者，不予资格&lt;/span&gt;，最终解释权归我所有&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFg1q2t7lb585CJWMxKLPPicBRCtrNt5keaQZQ96K1nBngXkhUPq6x70tCNbgicepqtpRuwsic4nUGUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;br/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3NjQ3MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEf5LN3Y4UErfNUkiaMseJPkdXA4xPD6Uicl8EqAJAEKVIKalU19xS41TO3aPmHK5bqbzGTwu3z92Kg/0?wx_fmt=png&quot; data-nickname=&quot;yes的练级攻略&quot; data-alias=&quot;yes_java&quot; data-signature=&quot;用接地气的话来分享一些后端技术或写一些想写的。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>391d8f351bdf7f26ec048d850ba7215f</guid>
<title>微服务之服务监控和治理、容错隔离与 Docker 部署</title>
<link>https://toutiao.io/k/26dq3a7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1 什么是监控系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;一旦请求服务出现异常，我们必须得知道是在哪个服务环节出了故障，就需要对每一个服务，以及各个指标都进行全面的监控；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;监控系统能为我们提供具体的指标数据进行追踪和跟进。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在微服务架构中，监控系统按照原理和作用大致可以分为三类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;日志监控（Log）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;调用链调用监控（Tracing）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;度量监控（Metrics）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.2 日志监控&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日志类比较常见，我们的框架代码、系统环境、以及业务逻辑中一般都会产出一些日志，这些日志我们通常把它记录后统一收集起来，方便在跟踪和丁文问题的需要时进行查询；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日志类记录的信息一般是一些事件、非结构化的一些文本内容；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日志的输出和处理的解决方案常用的有 ELK Stack 方案，用于实时搜索，分析和可视化日志数据；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开源实时日志分析 ELK 平台能够完美的解决我们上述的问题，ELK 由ElasticSearch、Logstash和Kiabana 三个开源工具组成。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4252386002120891&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPdfrTg6PRamDyaM5pSUpg5ibMu87evnOZ3RUib5MhVrBNRpqfsKjMHLQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;943&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;组件介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Elasticsearch 是个开源分布式搜索引擎，它具备分布式、零配置、自动发现、索引自动分片、索引副本机制、RESTful 风格接口、多数据源、自动搜索负载等特性；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Logstash 是一个完全开源的工具，它可以对你的日志进行收集、过滤，并将其存储供以后使用（如搜索）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Kibana 也是一个开源和免费的工具，可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Kafka 用来接收用户日志的消息队列。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;工作流程图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.498&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPYoADtfyER11ZEhxzRliaRHkNeFxUVicULNoxNib4AL2boySVW9uUAqsxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Logstash 收集 AppServer 产生的日志记录 Log；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将日志 log 存放到 ElasticSearch 集群中，而 Kibana 则从 ES 集群中查询数据生成图表；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;生成的日志图表返回给 Browser 进行渲染显示，分别支持各种终端进行显示。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.3 调用链监控&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.3.1 什么是调用链监控&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;调用链监控是用来追踪微服务之前依赖的路径和问题定位；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;主要原理就是子节点会记录父节点的 id 信息。例如阿里的鹰眼系统就是一个调用链监控系统；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一个请求从开始进入，在微服务中调用不同的服务节点后，再返回给客户端，在这个过程中通过调用链参数来追寻全链路的调用行程。通过这个方式可以很方便的知道请求在哪个环节出了故障，系统的瓶颈出现在哪一个环节，定位出优化点。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.3.2 为什么需要调用链监控&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5601092896174863&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxWIUrlcKAFooL9xB732RaZB3ShZ5GCPakXICMlqY0K468ib0WnGibRCffDTr8xqiaT64VtaIqeWU5sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1464&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.3.3 调用链监控的作用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;生成项目网络拓扑图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据「调用链监控」中记录的链路信息，给项目生成一张网络调用的拓扑图；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过这张图，我们就可以知道系统中的各个服务之间的调用关系是怎样的，以及系统依赖了哪些服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以让架构师监控全局服务状态，便于架构师掌握系统的调用结构。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;快速定位问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;优化系统&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;通过记录了请求在调用链上每一个环节的信息，可以通过得出的服务信息找出系统的瓶颈，做出针对性的优化；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;还可以分析这个调用路径是否合理，是否调用了不必要的服务节点，是否有更近、响应更快的服务节点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过对调用链路的分析，我们就可以找出最优质的调用路径，从而提高系统的性能。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.3.4 调用链监控的原理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要原理就是子节点会记录父节点的 id 信息，要理解好三个核心的概念 Trace、Span 和 Annotation。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Trace&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Trace 是指一次请求调用的链路过程，trace id 是指这次请求调用的 ID；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在一次请求中，会在网络的最开始生成一个全局唯一的用于标识此次请求的 trace id。这个 trace id 在这次请求调用过程中无论经过多少个节点都会保持不变，并且在随着每一层的调用不停的传递；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最终，可以通过 trace id 将这一次用户请求在系统中的路径全部串起来。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Annotation&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;指附属信息，可以用于附属在每一个 Span 上自定义的数据。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体流程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38449111470113084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPmc0aOzGiaia37Wyl8XBc0emwSf4mhTjMssHBibicp4amN563O8S7vxEydA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;619&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;从图中可见，一次请求只有一个唯一的 trace id=12345，在请求过程中的任何环节都不会改变；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在这个请求的调用链中，Span A 调用了 Span B，然后 Span B 又调用了 Span C 和 Span D，每一次 Span 调用都会生成一个自己的 span id，并且还会记录自己的上级 span id 是谁；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过这些 id，整个链路基本上就都能标识出来，记录了调用过程。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.3.5 调用链监控开源应用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CAT&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;CAT 是由大众点评开源的一款调用链监控系统，基于JAVA开发，有很多互联网企业在使用，热度非常高；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;它有一个非常强大和丰富的可视化报表界面，这一点其实对于一款调用链监控系统而来非常的重要；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在 CAT 提供的报表界面中有非常多的功能，几乎能看到你想要的任何维度的报表数据；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CAT 有个很大的优势就是处理的实时性，CAT 里大部分系统是分钟级统计。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Open Zipkin&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Pinpoint&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Pinpoint 中的服务关系依赖图做得非常棒，超出市面上任何一款产品；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Pinpoint 运用 JavaAgent 字节码增强技术，只需要加启动参数即可。因为采用字节码增强方式去埋点，所以在埋点的时候是不需要修改业务代码的，是非侵入式的。非常适合项目已经完成之后再增加调用链监控的时候去使用的方案；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;但是也是由于采用字节码增强的方式，所以它目前仅支持 Java 语言。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案选型比较&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPDA77iaKxIH8xiafkbVP2nKSJYmJtxlGTwn5ZaYGHMC7fcIlrzrhPJibIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.4 度量监控&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.4.1 什么是度量监控&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;度量类监控主要采用时序数据库的解决方案；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;它是以事件发生时间以及当前数值的角度来记录的监控信息，是可以聚合运算的，用于查看一些指标数据和指标趋势；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;所以这类监控主要不是用来查问题的，主要是用来看趋势的,基于时间序列数据库的监控系统是非常适合做监控告警使用的。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Metrics 一般有 5 种基本的度量类型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Gauges（度量）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Counters（计数器）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Histograms（直方图）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Meters（TPS计算器）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Timers（计时器）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.4.2 时序数据库有哪些&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Prometheus&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.597&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMP2DnmpovKRzlib6fXv0DjPECgltCRKwicvHcFLkM8RxibdEpw1vaic6mjzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;从图的左下角可以看到，Prometheus 可以通过在应用里进行埋点后 Pull 到 Prometheus Server 里。如果应用不支持埋点，也可以采用 exporter 方式进行数据采集。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从图的左上角可以看到，对于一些定时任务模块，因为是周期性运行的，所以采用拉的方式无法获取数据，那么 Prometheus 也提供了一种推数据的方式，但是并不是推送到 Prometheus Server 中，而是中间搭建一个 Pushgateway。定时任务模块将 metrics 信息推送到这个 Pushgateway 中，然后 Prometheus Server 再依然采用拉的方式从 Pushgateway 中获取数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要拉取的数据既可以采用静态方式配置在 Prometheus Server 中，也可以采用服务发现的方式（即图的中间上面的 Service discovery 所示）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PromQL 是 Prometheus 自带的查询语法，通过编写 PromQL 语句可以查询 Prometheus 里面的数据。&lt;/span&gt;&lt;span&gt;Alertmanager 是用于数据的预警模块，支持通过多种方式去发送预警。&lt;/span&gt;&lt;span&gt;WebU 用来展示数据和图形，但是一般大多数是与 Grafana 结合，采用 Grafana 来展示。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;OpenTSDB&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OpenTSDB 是在 2010 年开源的一款分布式时序数据库，当然其主要用于监控方案中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OpenTSDB 采用的是 Hbase 的分布式存储，它获取数据的模式与 Prometheus 不同，它采用的是推模式（Push）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在展示层，OpenTSDB 自带有 WebUI 视图，也可以与 Grafana 很好的集成，提供丰富的展示界面；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;但 OpenTSDB 并没有自带预警模块，需要自己去开发或者与第三方组件结合使用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6417004048582996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPBrQXrF0J4MbRZ1OYhuXe8ex0qia7FkGBywZMuKTEku0ENiaQKyged5icw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;494&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;InfluxDB&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32231404958677684&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPkJ9Hnsoo0ATibibejuz8hH3ibiclQhTN4uFYcWMCngnEJlqFIQN9Z2jAEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;605&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.5 微服务监控体系&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;监控是微服务治理的重要环节,架构采用分层监控，一般分为以下监控层次。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;fancybox&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5609375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMP0gCtZRibLEBd8coSarxrILcnHolDkOic4smlve553wUFU23iadib0NDlqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/fancybox&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;系统层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统层主要是指 CPU、磁盘、内存、网络等服务器层面的监控，这些一般也是运维同学比较关注的对象。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;应用层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用层指的是服务角度的监控，比如接口、框架、某个服务的健康状态等，一般是服务开发或框架开发人员关注的对象。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;用户层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;这一层主要是与用户、与业务相关的一些监控，属于功能层面的，大多数是项目经理或产品经理会比较关注的对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;监控指标&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;延迟时间&lt;/strong&gt;：主要是响应一个请求所消耗的延迟，比如某接口的 HTTP 请求平均响应时间为 100ms；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;请求量&lt;/strong&gt;：是指系统的容量吞吐能力，例如每秒处理多少次请求（QPS）作为指标。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;错误率&lt;/strong&gt;：主要是用来监控错误发生的比例，比如将某接口一段时间内调用时失败的比例作为指标。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 微服务容错隔离&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 什么是容错隔离&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;单体应用的架构下一旦程序发生了故障，那么整个应用可能就没法使用了，所以我们要把单体应用拆分成具有多个服务的微服务架构，来减少故障的影响范围。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是在微服务架构下，有一个新的问题就是，由于服务数变多了，假设单个服务的故障率是不变的，那么整体微服务系统的故障率其实是提高了的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设单个服务的故障率是 0.01%，也就是可用性是 99.99%，如果我们总共有 10 个微服务，那么我们整体的可用性就是 99.99% 的十次方，得到的就是 99.90% 的可用性（也就是故障率为 0.1%）。可见，相对于之前的单体应用，整个系统可能发生故障的风险大幅提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当某个服务出现故障，我们要做的就是最大限度的隔离单个服务的风险，也就是「 容错隔离 」的方法。不仅保证了微服务架构的正常运行，也保证了系统的可用性和健壮性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.2 常见的可用性风险有哪些&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;单机可用性风险&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;单机可用性风险指的是微服务部署所在的某一台机器出现了故障，造成的可用性风险；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;这种风险发生率很高，因为单机器在运维中本身就容易发生各种故障，例如硬盘坏了、机器电源故障等等，这些都是时有发生的事情；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不过虽然这种风险发生率高，但危害有限，因为我们大多数服务并不只部署在一台机器上，可能多台都有，因此只需要做好监控，发现故障之后，及时的将这台故障机器从服务集群中剔除即可，等修复后再重新上线到集群里。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;单机房可用性风险&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这种风险的概率比单机器的要低很多，但是也不是完全不可能发生，在实际情况中，还是有一定概率的。比如最为常见的就是通往机房的光纤被挖断，造成机房提供不了服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果我们的服务全部都部署在单个机房，而机房又出故障了，但是现在大多数中大型项目都会采用多机房部署的方案，比如同城双活、异地多活等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一旦某个机房出现了故障不可用了，立即采用切换路由的方式，把这个机房的流量切到其它机房里就能正常提供服务了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;跨机房集群可用性风险&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.3 容错隔离的方案有哪些&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;超时&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;限流&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;顾名思义，就是限制最大流量。系统能提供的最大并发有限，同时来的请求又太多，服务无法处理请求，就只好排队限流；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;类比就跟生活中去景点排队买票、去商场吃饭排队等号的道理；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;常见的限流算法有：计算器限流、漏桶算法、令牌漏桶算法、集群限流算法。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;降级&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;与限流类似，一样是流量太多，系统服务不过来。这个时候可将不是那么重要的功能模块进行降级处理，停止服务，这样可以释放出更多的资源供给核心功能的去用；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同时还可以对用户分层处理，优先处理重要用户的请求，比如 VIP 收费用户等；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;例如淘宝双十一活动会对订单查询服务降级来保证购买下单服务的可用性。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;延迟异步处理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;熔断&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;可以理解成就像电闸的保险丝一样，当流量过大或者错误率过大的时候，保险丝就熔断了，链路就断开了，不提供服务了；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当流量恢复正常，或者后端服务稳定了，保险丝会自动街上（熔断闭合），服务又可以正常提供了。这是一种很好的保护后端微服务的一种方式；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;熔断技术中有个很重要的概念就是：断路器，可以参考下图：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;fancybox&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47217235188509876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPJKQEk4GWtssxJafRs56EhGkjIv0zmat4SWxtz8B9kZhHrDB4NrEHEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;557&quot;/&gt;&lt;/fancybox&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;断路器其实就是一个状态机原理，有三种状态：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.4 开源容错隔离应用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Hystrix 原理图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;fancybox&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4750499001996008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPNiaicrQ4ozXWv7SFTxr0nacaWKJoVezQuQywz6ibwNfZAFtn2jIh7A5bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;/fancybox&gt;&lt;/p&gt;&lt;p&gt;&lt;fancybox&gt;&lt;br/&gt;&lt;/fancybox&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;当我们使用了 Hystrix 之后，请求会被封装到 HystrixCommand 中，这也就是第一步；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第二步就是开始执行请求，Hystrix 支持同步执行（图中 .execute 方法）、异步执行（图中 .queue 方法）和响应式执行（图中 .observer）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第三步判断缓存，如果存在与缓存中，则直接返回缓存结果；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果不在缓存中，则走第四步，判断断路器的状态是否为开启，如果是开启状态，也就是短路了，那就进行失败返回，跳到第八步；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第八步需要对失败返回的处理也需要再做一次判断，要么正常失败返回，返回相应信息，要么根本没有实现失败返回的处理逻辑，就直接报错；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果断路器不是开启状态，那请求就继续走，进行第五步，判断线程、队列是否满了。如果满了，那么同样跳到第八步；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果线程没满，则走到第六步，执行远程调用逻辑，然后判断远程调用是否成功。调用发生异常了就挑到第八步，调用正常就挑到第九步正常返回信息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;图中的第七步，非常牛逼的一个模块，是来收集 Hystrix 流程中的各种信息来对系统做监控判断的。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Hystrix 断路器的原理图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;fancybox&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.808&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPTftNqsUxpUn2iayTe3icoEAWsQqNtO7PiahwT60xNiaWLyqicVwM1Tv58Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/fancybox&gt;&lt;/p&gt;&lt;p&gt;&lt;fancybox&gt;&lt;br/&gt;&lt;/fancybox&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 微服务的访问安全&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1 什么是访问安全&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2 传统单机服务的访问安全机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统单体应用的访问示意图:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4662721893491124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPxfnv8T0D1PEliaEJzn6kwicI4g0F64aoL6mia180IGGwIj7BBWbZHiaWlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;845&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;在应用服务器里面，会有一个 auth 模块（一般采用过滤器来实现）。当有客户端请求进来时，所有的请求都必须首先经过这个 auth 来做身份验证，验证通过后，才将请求发到后面的业务逻辑；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通常客户端在第一次请求的时候会带上身份校验信息（用户名和密码），auth 模块在验证信息无误后，就会返回 Cookie 存到客户端，之后每次客户端只需要在请求中携带 Cookie 来访问，而 auth 模块也只需要校验 Cookie 的合法性后决定是否放行；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可见，在传统单体应用中的安全架构还是蛮简单的，对外也只有一个入口，通过 auth 校验后，内部的用户信息都是内存、线程传递，逻辑并不是复杂，所以风险也在可控范围内。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.3 微服务如何实现访问安全&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在微服务架构下，一般有以下三种方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;网关鉴权模式（API Gateway）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务自主鉴权模式&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;API Token模式（OAuth2.0）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.3.1 网关鉴权模式（API Gateway）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44755244755244755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPOkE72NgHYOyW6dc5OZjt4GnBd0y3PJGibhslMTUGLnYfmiaym1bXBGvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1001&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;通过上图可见，因为在微服务的最前端一般会有一个 API 网关模块（API Gateway）。所有外部请求访问微服务集群时，都会首先通过这个API Gateway。可以在这个模块里部署 auth 逻辑，实现统一集中鉴权。鉴权通过后，再把请求转发给后端各个服务；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;这种模式的优点就是，由 API Gateway 集中处理了鉴权的逻辑，使得后端各微服务节点自身逻辑就简单了，只需要关注业务逻辑，无需关注安全性事宜；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;这个模式的问题就是，API Gateway 适用于身份验证和简单的路径授权（基于 URL），对于复杂数据、角色的授权访问权限，通过 API Gateway 很难去灵活的控制。毕竟这些逻辑都是存在后端服务上的，并非存储在 API Gateway 里。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.3.2 服务自主鉴权模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4529058116232465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPfCGsTZNzA4vtLPKgfM86Uqy9KsrZnNe1BHjn6icDBPaFdLWzcvAypdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;998&quot;/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;服务自主鉴权就是指不通过前端的 API Gateway 来控制，而是由后端的每一个微服务节点自己去鉴权；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;它的优点就是可以由更为灵活的访问授权策略，并且相当于微服务节点完全无状态化了。同时还可以避免 API Gateway 中 auth 模块的性能瓶颈；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缺点就是由于每一个微服务都自主鉴权，当一个请求要经过多个微服务节点时，会进行重复鉴权，增加了很多额外的性能开销。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.3.3 API Token 模式（OAuth2.0）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44755244755244755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPqgN4A8p75fHicOTT3DiasFYOTwROYEF2apKLLbibdxtYEpTGl4e3p3aUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1001&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图，这是一种采用基于令牌 Token 的授权方式。在这个模式下，是由授权服务器（图中 Authorization Server）、API 网关（图中 API Gateway）、内部的微服务节点几个模块组成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;客户端应用首先使用账号密码或者其它身份信息去访问授权服务器（Authorization Server）获取 访问令牌（Access Token）；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;拿到访问令牌（Access Token）后带着它再去访问API网关（图中 API Gateway），API Gateway 自己是无法判断这个 Access Token 是否合法，所以走第 3 步；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;API Gateway 去调用 Authorization Server 校验 Access Token 的合法性；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;如果验证完 Access Token 是合法的，那 API Gateway 就将 Access Token 换成 JWT 令牌返回；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;注意：此处也可以不换成 JWT，而是直接返回原 Access Token。但是换成 JWT 更好，因为 Access Token 是一串不可读无意义的字符串，每次验证 Access Token 是否合法都需要去访问 Authorization Server 才知道。但是 JWT 令牌是一个包含 JSON 对象，有用户信息和其它数据的一个字符串，后面微服务节点拿到 JWT 之后，自己就可以做校验，减少了交互次数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;API Gateway 有了JWT之后，就将请求向后端微服务节点进行转发，同时会带上这个 JWT；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;微服务节点收到请求后，读取里面的 JWT，然后通过加密算法验证这个 JWT，验证通过后，就处理请求逻辑。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这里面就使用到了 OAuth2.0 的原理，不过这只是 OAuth2.0 各类模式中的一种。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.4 OAuth2.0 的访问安全 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.4.1 什么是 OAuth2.0&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;OAuth2.0 是一种访问授权协议框架。它是基于 Token 令牌的授权方式，在不暴露用户密码的情况下，使应用方能够获取到用户数据的访问权限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如：你开发了一个视频网站，可以采用第三方微信登陆，那么只要用户在微信上对这个网站授权了，那这个网站就可以在无需用户密码的情况下获取用户在微信上的头像。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OAuth2.0 的流程如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5453296703296703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPzo81UTYwRlPyvUkC8JfQZzDmVtYNDzQphfQA6Jf1uiaAj3eNDXSA8ibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.4.2 OAuth2.0 主要名词解释&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.4.3 OAuth2.0 有四种授权模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;授权码（Authorization Code）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;授权码模式是指客户端应用先去申请一个授权码，然后再拿着这个授权码去获取令牌的模式。&lt;/span&gt;&lt;span&gt;这也是目前最为常用的一种模式，安全性比较高，适用于我们常用的前后端分离项目。通过前端跳转的方式去访问授权服务器获取授权码，然后后端再用这个授权码访问授权服务器以获取访问令牌。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;工作流程图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7126917712691772&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPicbBORnTcUIFOiaWJP16YgwByAANAFjJ0KgU2YZia1Kc29wpV5z6xQCcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;717&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;第一步，客户端的前端页面（图中 UserAgent）将用户跳转到授权服务器（Authorization Server）里进行授权，授权完成后，返回授权码（Authorization Code）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二步，客户端的后端服务（图中 Client）携带授权码（Authorization Code）去访问 授权服务器，然后获得正式的访问令牌（Access Token）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面的前端和后端分别做不同的逻辑，前端接触不到 Access Token，保证了 Access Token 的安全性。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;简化模式（Implicit）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;工作流程图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6607142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPTH3cq7p9iaQz9fb8tgQNgPTNvx1u5HUuUvapYIavTKuvSsGeOKLPLicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;840&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一步，应用（纯前端的应用）将用户跳转到授权服务器（Authorization Server）里进行授权。授权完成后，授权服务器直接将 Access Token 返回给 前端应用，令牌存储在前端页面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二步，应用（纯前端的应用）携带访问令牌（Access Token）去访问资源，获取资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在整个过程中，虽然令牌是在前端 URL 中直接传递，但令牌不是放在 HTTP 协议中 URL 参数字段中的，而是放在 URL 锚点里。因为锚点数据不会被浏览器发到服务器，因此有一定的安全保障。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;用户名密码（Resource Owner Credentials）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5200458190148912&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPuiba9dl1B6Qeyo3y9nEOq9GerTO2m0HW46oO6p6FvZdiaUYvnoR0kbGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;873&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;这种方式最容易理解了，直接使用用户名、密码作为授权方式去访问授权服务器，从而获取 Access Token。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个方式因为需要用户给出自己的密码，所以非常的不安全性。一般仅在客户端应用与授权服务器、资源服务器是归属统一公司、团队，互相非常信任的情况下采用。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;客户端凭证（Client Credentials）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2599784250269687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMP1xJ2kvRyokTlHtdzQzwTxKUlibrlJR9oHLfw1K6ia6wUicCQApQI73xYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;这是适用于服务器间通信的场景。客户端应用拿一个用户凭证去找授权服务器获取Access Token。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 容器技术&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.1 为什么需要容器技术&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;传统的 PaaS 技术虽然也可以一键将本地应用部署到云上，并且也是采用隔离环境的形式去部署，但是其兼容性非常的不好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为其主要原理就是将本地应用程序和启停脚本一同打包，然后上传到云服务器上，然后再在云服务器里通过脚本启动这个应用程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的做法，看起来很理想。但是在实际情况下，由于本地与云端的环境差异，导致上传到云端的应用运行的时候经常各种报错，需要各种修改配置和参数来做兼容服务环境。甚至在项目迭代过程中不同的版本代码都需要重新去做适配，非常耗费精力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而以Docker为代表的容器技术却通过一个小创新完美的解决了这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Docker 的方案中，它不仅打包了本地应用程序，而且还将本地环境（操作系统的一部分）也打包了，组成一个叫做「 Docker镜像 」的文件包。所以这个「 Docker镜像 」就包含了应用运行所需的全部依赖，我们可以直接基于这个「 Docker镜像 」在本地进行开发与测试，完成之后，再直接将这个「 Docker镜像 」一键上传到云端运行即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Docker 实现了本地与云端的环境完全一致，做到了真正的一次开发随处运行，避免了类似“我在本地正常运行，传到云端就不可以了”的说辞。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2 什么是容器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来看一下容器与虚拟机的对比区别：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7900146842878121&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPPvlkbfJlmqDoy44ZJlx7911DHSicib8tSQt5tsdj9HrPXUJxqnrfYW2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;虚拟机是在宿主机上基于 Hypervisor 软件虚拟出一套操作系统所需的硬件设备，再在这些虚拟硬件上安装操作系统 Guest OS，然后不同的应用程序就可以运行在不同的 Guest OS 上，应用之间也就相互独立、资源隔离。&lt;/span&gt;&lt;span&gt;但是由于需要 Hypervisor 来创建虚拟机，且每个虚拟机里需要完整的运行一套操作系统 Guest OS，因此这个方式会带来很多额外资源的开销。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Docker容器中却没有 Hypervisor 这一层，虽然它需要在宿主机中运行 Docker Engine，但它的原理却完全不同于 Hypervisor，它并没有虚拟出硬件设备，更没有独立部署全套的操作系统 Guest OS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Docker容器没有那么复杂的实现原理，它其实就是一个普通进程而已，只不过它是一种经过特殊处理过的普通进程。&lt;/span&gt;&lt;span&gt;我们启动容器的时候（docker run …），Docker Engine 只不过是启动了一个进程，这个进程就运行着我们容器里的应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但 Docker Engine 对这个进程做了一些特殊处理，通过这些特殊处理之后，这个进程所看到的外部环境就不再是宿主机的环境（它看不到宿主机中的其它进程了，以为自己是当前操作系统唯一一个进程），并且 Docker Engine 还对这个进程所使用得资源进行了限制，防止它对宿主机资源的无限使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对比下来就是，容器比虚拟机更加轻量级，花销也更小，更好地利用好主机的资源。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.3 容器如何做到资源隔离和限制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Docker 容器对这个进程的隔离主要采用两个核心技术点 &lt;/span&gt;&lt;span&gt;Namespace 和 &lt;/span&gt;&lt;span&gt;Cgroups。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPHD3iazsvKLyWv1hkjj7KrcTs6fmvXbtmwycwIkxpfP4Eic0dIcKywn7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结来说就是，Namespace 为容器进程开辟隔离进程，Cgroups 限制容器进程之间抢夺资源，从此保证了容器之间独立运行和隔离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;Namespace 技术&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;Namespace 是 Linux 操作系统默认提供的 API，包括 PID Namespace、Mount Namespace、IPC Namespace、Network Namespace 等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以 PID Namespace 举例，它的功能是可以让我们在创建进程的时候，告诉Linux系统，我们要创建的进程需要一个新的独立的进程空间，并且这个进程在这个新的进程空间里的 PID=1。也就是说这个进程只看得到这个新进程空间里的东西，看不到外面宿主机环境里的东西，也看不到其它进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过这只是一个虚拟空间，事实上这个进程在宿主机里 PID 该是啥还是啥，没有变化，只不过在这个进程空间里，该进程以为自己的 PID=1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;打个比方，就像是一个班级，每个人在这个班里都有一个编号。班里有 90 人，然后来了一位新同学，那他在班里的编号就是 91。可是老师为了给这位同学特别照顾，所以在班里开辟了一块独立的看不到外面的小隔间，并告诉这个同学他的编号是 1。由于这位同学在这个小空间里隔离着，所以他真的以为自己就是班上的第一位同学且编号为 1。当然了，事实上这位同学在班上的编号依然是 91。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Network Namespace 也是类似的技术原理，让这个进程只能看到当前 Namespace 空间里的网络设备，看不到宿主机真实情况。同理，其它 Mount、IPC 等 Namespace 也是这样。&lt;/span&gt;&lt;span&gt;Namespace 技术其实就是修改了应用进程的视觉范围，但应用进程的本质却没有变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，Docker容器里虽然带有一部分操作系统（文件系统相关），但它并没有内核，因此多个容器之间是共用宿主机的操作系统内核的。这一点与虚拟机的原理是完全不一样的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;Cgroups 技术&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cgroup 全称是 Control Group，其功能就是限制进程组所使用的最大资源（这些资源可以是 CPU、内存、磁盘等等）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然 Namespace 技术 只能改变一下进程组的视觉范围，并不能真实的对资源做出限制。那么为了防止容器（进程）之间互相抢资源，甚至某个容器把宿主机资源全部用完导致其它容器也宕掉的情况发生。因此，必须采用 Cgroup 技术对容器的资源进行限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cgroup 技术也是 Linux 默认提供的功能，在 Linux 系统的 /sys/fs/cgroup 下面有一些子目录 cpu、memory 等。Cgroup 技术提供的功能就是可以基于这些目录实现对这些资源进行限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;例如，在 /sys/fs/cgroup/cpu 下面创建一个 dockerContainer 子目录，系统就会自动在这个新建的目录下面生成一些配置文件，这些配置文件就是用来控制资源使用量的。例如可以在这些配置文件里面设置某个进程ID对CPU的最大使用率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;Cgroup 对其它内存、磁盘等资源也是采用同样原理做限制。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.4 什么是容器镜像&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;一个基础的容器镜像其实就是一个 rootfs，它包含操作系统的文件系统（文件和目录），但并不包含操作系统的内核。&lt;/span&gt;&lt;span&gt;rootfs 是在容器里根目录上挂载的一个全新的文件系统，此文件系统与宿主机的文件系统无关，是一个完全独立的，用于给容器进行提供环境的文件系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于一个Docker容器而言，需要基于 pivot_root 指令，将容器内的系统根目录切换到rootfs上。这样，有了这个 rootfs，容器就能够为进程构建出一个完整的文件系统，且实现了与宿主机的环境隔离。也正是有了rootfs，才能实现基于容器的本地应用与云端应用运行环境的一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，为了方便镜像的复用，Docker 在镜像中引入了层（Layer）的概念，可以将不同的镜像一层一层的迭在一起。这样，如果我们要做一个新的镜像，就可以基于之前已经做好的某个镜像的基础上继续做。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7900146842878121&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPPvlkbfJlmqDoy44ZJlx7911DHSicib8tSQt5tsdj9HrPXUJxqnrfYW2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;如上图，这个例子中最底层是操作系统引导。往上一层就是基础镜像层（Linux 的文件系统），再往上就是我们需要的各种应用镜像，Docker 会把这些镜像联合挂载在一个挂载点上，这些镜像层都是只读的。只有最上面的容器层是可读可写的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种分层的方案其实是基于联合文件系统 UnionFS（Union File System）的技术实现的。它可以将不同的目录全部挂载在同一个目录下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;举个例子，假如有文件夹 test1 和 test2 ，这两个文件夹里面有相同的文件，也有不同的文件。然后我们可以采用联合挂载的方式，将这两个文件夹挂载到 test3 上，那么 test3 目录里就有了 test1 和 test2 的所有文件（相同的文件有去重，不同的文件都保留）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;这个原理应用在 Docker 镜像中。比如有 2 个同学，同学 A 已经做好了一个基于 Linux 的 Java 环境的镜像，同学 S 想搭建一个 Java Web 环境，那么他就不必再去做 Java 环境的镜像了，可以直接基于同学 A 的镜像在上面增加 Tomcat 后生成新镜像即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.5 容器技术在微服务的实践&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着微服务的流行，容器技术也相应的被大家重视起来。容器技术主要解决了以下两个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;环境一致性问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如 Java 的 jar/war 包部署会依赖于环境的问题（操着系统的版本，JDK 版本问题）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;镜像部署问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如 Java、Ruby、NodeJS 等等的发布系统是不一样的，每个环境都得很麻烦的部署一遍，采用 Docker 镜像，就屏蔽了这类问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;部署实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图是 Docker 容器部署的一个完整过程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5453125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDpQU30Pf4xXicmas1l3xyMPskScqibnrwvnmQzxACGzEBiajsQwhvRRJk4SkxvxRkYkfVHWjcQBGAYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更重要的是，拥有如此多服务的集群环境迁移、复制也非常轻松，只需选择好各服务对应的 Docker 服务镜像、配置好相互之间访问地址就能很快搭建出一份完全一样的新集群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.6 容器调度&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前基于容器的调度平台有 &lt;/span&gt;&lt;span&gt;Kubernetes（K8S）、&lt;/span&gt;&lt;span&gt;Mesos、&lt;/span&gt;&lt;span&gt;Omega。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;本文主要介绍了微服务架构下的服务监控、容错隔离、访问安全以及结合容器技术实现服务发布和部署。初窥了微服务架构的模块，相信&lt;/span&gt;&lt;span&gt;对微服务架构会有所帮助。&lt;/span&gt;&lt;span&gt;再深入就需要有针对性的技术实践才能加深了解。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>