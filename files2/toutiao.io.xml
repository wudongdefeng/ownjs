<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>cffd621bb17c21d31a43f2f3a2323b24</guid>
<title>Kvrocks 在货拉拉全链路 Trace 下的应用</title>
<link>https://toutiao.io/k/ej26sex</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;作者简介：&lt;/blockquote&gt;&lt;blockquote&gt;宋高飞，主要从事客户端、服务cpp、golang等领域， 熟悉流媒体推流、即时通讯等系统开发。&lt;/blockquote&gt;&lt;blockquote&gt;席在盛，资深后端研发工程师，开发过KMS、API网关等基础组件，也主导研发过大型业务系统（贷后资产管理）等。目前主要负责监控产品Trace、Java SDK研发工作。&lt;/blockquote&gt;&lt;h2&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;传统Trace场景下，没有完全符合Trace场景的存储数据库，在业务量增长的情况下，一款&lt;strong&gt;高性能、大容量、持久化&lt;/strong&gt;的 NoSQL存储数据库就越来越重要。Kvrocks 基于 RocksDB 之上支持 redis协议的 kv 数据库，相比于其它的同类开源产品，它更年轻，因此框架功能更简洁，历史包袱更小，并且社区活跃度很高，我们最终选择了 Kvrocks 为基础进行二次开发。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;二、Trace 介绍&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;分布式链路追踪作为分布式应用可观测（Metric&amp;amp;Trace&amp;amp;Log）技术的重要组成部分，在故障诊断、性能调优、架构演进等方面发挥着重要作用。货拉拉基于Apache开源Skywalking V8搭建的Trace平台，目前架构已演进到V3.0版本，接入应用累计1000+；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;545&quot; data-ratio=&quot;0.8801742919389978&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsPrEz6DRLTnEAfhvy0mfqcKXwWKolRFcB7G3YngToyhCWB6J94lQRDw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1836&quot; data-width=&quot;619&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;336&quot; data-ratio=&quot;0.7706422018348624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsKrHicxkibqzVmlTfVEtR1ICahXexjGicAe5pdiawow6rFNJicZfAVgCu0kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;436&quot; data-width=&quot;436&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;420&quot; data-ratio=&quot;0.7332317073170732&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsL1M10NSsuFqBAjFHoia4NeibHWelgIPmcWcwwgAPNvEyN9al6Df9oh1Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;656&quot; data-width=&quot;571&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;业务高速增长背景下，&lt;/strong&gt;&lt;strong&gt;Trace &lt;/strong&gt;&lt;strong&gt;数据存储面临的问题？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在成本约束前提下， Trace采样率不高（热数据1H内稳定在50%，冷数据3D在10%左右），导致在排障过程中，部分链路数据缺失，不能借助Trace数据定位问题，不利于故障的快速定位和恢复。&lt;/p&gt;&lt;p&gt;如何破解当前面临的问题？&lt;/p&gt;&lt;p&gt;在数据结构优化带来的收益有限前提下，让我们重新开始考虑是否有更合适Trace数据的存储方案。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;三、Kvrocks&lt;/strong&gt;&lt;/h2&gt;&lt;h3&gt;&lt;strong&gt;3.1 Kvrocks 简介&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Kvrocks 使用reuse_port多线程监听同一个端口来并发处理请求，在单个worker线程中处理redis协议，并转换为RocksDB支持的kv类型，一个 Kvrocks 节点使用一个RocksDB实例。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;472&quot; data-ratio=&quot;1.0227848101265822&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsg8ZtECuYIVYptEyNtYOh1QZDORhHPAFpgMDicr3NQ51LAHfr7t1wR6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;790&quot; data-width=&quot;462&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;3.2 RocksDB 简介&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;RocksDB底层是LSM Tree，其是通过将写请求的数据缓存在内存，等待被批量写入磁盘，与InnoDB相比，大大降低了io次数，同时删除和修改也都是写入新的记录，极大的提高了写性能。数据文件在磁盘上通过某种Compaction策略进行合并组成特定的层级结构。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;430&quot; data-ratio=&quot;0.6589147286821705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDstEmptTNuaGr4aXLFjvB2Gxiclq2OxPVeoZhiaKB8A6TBFLecn4Vtw1zg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2580&quot; data-width=&quot;650&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;3.2.1 Memtable&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Memtable默认实现为跳表，写请求都被缓存在Memtable中，当被写满数据会更改为immutable Memtable等待落盘，同时我们可以对Memtable的大小、可留在内存中的个数、刷盘时合并个数等参数进行控制来达到优化性能的目的。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;3.2.2 Compaction&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;为什么需要Compaction？&lt;/strong&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;为了优化读取性能。如果不进行Compaction，所有SST文件如果范围重合，那么就需要遍历读取所有的SST文件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为了被修改或删除的数据。如果不进行Compaction，SST文件中可能存在大量相同的key，占用额外的磁盘空间，而只有一个最新版本的key才是我们需要的。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Compaction带来了&lt;strong&gt;写放大、读放大、空间放大&lt;/strong&gt;，不同的Compaction就是在这三者之间进行平衡以适配流量负载，达到最好的性能。&lt;/p&gt;&lt;p&gt;写放大：&lt;strong&gt;Write amplification&lt;/strong&gt; is the ratio of bytes written to storage versus bytes written to the database.&lt;/p&gt;&lt;p&gt;读放大：&lt;strong&gt;Read amplification&lt;/strong&gt; is the number of disk reads per query.&lt;/p&gt;&lt;p&gt;空间放大：&lt;strong&gt;Space amplification&lt;/strong&gt; is the ratio of the size of database files on disk to data size.&lt;/p&gt;&lt;p&gt;因此写放大影响写入性能，读放大影响读取性能，空间放大影响磁盘占用空间。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Leveled Compaction Strategy&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;此策略将在磁盘上的文件分成多个层级，L0、L1等。每一层都是上一层的数倍大小，被称为扇出。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;313&quot; data-ratio=&quot;0.5265625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsMJ6Jib9iaDFuvjMlf6lPZtprXm1B6cAMWJrfSSkVbzEmlfZ7srDLf7lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;591&quot;/&gt;&lt;/p&gt;&lt;p&gt;L0包含从Memtable落盘的文件，因为同时只存在一个可被写入的Memtable，因此每个Memtable之间的数据范围可能是重叠的，但除了L0每一层都是一个有序数据集。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;310&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsA1zSDlzQS50bUngl8uQTaScjctJlPA10r8QWpia8ClvVazuWmibicCC1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;616&quot;/&gt;&lt;/p&gt;&lt;p&gt;因此从L0到L1层级的合并是需要所有文件参与的合并。而其他层的合并只需要some-to-some。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;312&quot; data-ratio=&quot;0.48671875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDs2ktHE7pebPoibjsfHsIeR4iaCljdLvWg2EbUwIx9PTxsiafn18GR1SKOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;636&quot;/&gt;&lt;/p&gt;&lt;p&gt;L0层一般数据少，为方便分析，以下说明都是忽略L0层。&lt;/p&gt;&lt;p&gt;读放大：因为除了L0外的每一层都是一个有序结果集，因此查询只需要二分查找（因为每个文件都有范围，所以只需要在包含查询key的文件中进行查找）即可，读放大最坏的情况为每一层都进行一次二分查找。&lt;/p&gt;&lt;p&gt;写放大：假设Ln层是Ln-1层的K倍大小，Ln-1层的数据合并到Ln层最坏情况是Ln层的所有文件都需要参与进行合并，因此一次合并的写放大为K，最坏情况下就是每一层都出现写放大为K的情况。&lt;/p&gt;&lt;p&gt;空间放大：假设扇出为10，最坏情况下Ln-1层的数据在Ln层都有，空间放大最坏情况为(1+10+100)/100=1.11...&lt;/p&gt;&lt;p&gt;&lt;strong&gt;总结：此策略读放大和空间放大较优，写放大较大。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Universal Compaction Strategy&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Universal策略属于LSM Tree中tiered策略家族，也是将数据文件在磁盘上分层，但是这个分层不同于leveled策略，它是概念上的一种分层，为了描述树的形状和估计写放大。在tiered策略中，每一层有多个排序结果集。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;135&quot; data-ratio=&quot;0.26823529411764707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsq4e6l7EFHKzMg9c8YkmKUz3kCta4dvh59gb4GI8eVO2VDZYBsb813Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;425&quot; data-width=&quot;492&quot;/&gt;&lt;/p&gt;&lt;p&gt;每次合并都是将所有Ln-1层的排序结果集合并为一个新的Ln层的排序结果集。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;176&quot; data-ratio=&quot;0.28826151560178304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsqfhANN8YcViapEfS1rsROG5HNr6uKXUgS66tjT1ibTribariaGmnuL9cbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot; data-width=&quot;601&quot;/&gt;&lt;/p&gt;&lt;p&gt;理论上的tiered策略在最大层，会存在多个最大的排序结果集，也就是可能存在多个数据的版本，最坏情况下，有几个排序结果集，空间放大至少就是几倍，此时需要将最大层的所有排序结果集进行合并，所以存在major Compaction和minor Compaction两种。在各种工程中实现是不同的，在RocksDB中是惰性Compact，只有排序结果集的个数达到指定个数才会进行Compact，并且遵循以下几个规则：&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;周期性的尝试将旧的排序结果集合并到最底层。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果空间放大大于指定值，尝试一次major compaction。空间放大的计算方式为 其它排序结果集/最大的排序结果集。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;根据size_ratio进行一次minor Compaction。此种方式尽可能将大小相近的排序结果集进行合并。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如上三种都没有触发，那么尝试一次minor Compaction，规则类似于第三条。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;此类策略的各种放大难以用数学模型描述，但是从合并的操作来看，universal Compaction每次合并是将上层的排序结果集往更底层合并，所以写放大比leveled Compaction小很多。同时因为每层都存在多个排序结果集，所以读放大比较大。major Compaction的存在导致最大层的最大结果集需要进行合并，此时需要双倍的空间。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;总结：此策略是优化了写放大，但是牺牲了读放大和空间放大，并且会在major Compaction的时候有非常大的尖刺。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;scylladb官网中两种策略的空间放大比较&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;以恒定的速度不停的写入新数据&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;400&quot; data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsVMtCEDiae1h3UUIFrGrBXQ0R5wtjD8d2qlb9NF3M37mxaKRgN3RA34Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot; data-width=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;反复写入1.2GB的数据&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;800&quot; data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsrLDekQdvdeujK7WJoiayzSggRmYcdsyM9Il1Nece8qBkRXoxerOKxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot; data-width=&quot;1400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;FIFO Compaction&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;顾名思义，此策略只有一层结构，并且先入先出，当达到指定的磁盘占用量时会自动删除最旧的文件。&lt;/p&gt;&lt;p&gt;此策略写放大为 1（因为即便是Compaction，也是指定最新的几个文件进行一次归并排序，不需要更多次了），同时不存在空间放大（只是在Compaction时临时占用几个文件的大小，可忽略不计）&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;四、货拉拉Trace场景下的尝试&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Trace场景本来使用的是HBase，Trace业务属于典型的写应用场景，超过60w的写QPS，一天偶尔二十的读QPS，并且数据存在过期的特征。&lt;/p&gt;&lt;p&gt;我们选用32C 128G 本地NVMe SSD进行了初步测试。&lt;/p&gt;&lt;p&gt;参数条件：&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Memtable大小256M，个数6个。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可动态调整SST文件大小。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;后台Flush和Compaction线程12个。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最小Memtable合并数量2个。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;641&quot; data-ratio=&quot;0.50078125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsCOreibAEQ8WgRK24ibClORJ8nuevFcJadcpShJzJHwOImwVVutPQDmVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;418&quot; data-ratio=&quot;0.4717832957110609&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsDb5KrhqVsP2IY2q3xyT68FQFt3kbU8OGWLuJdx8IwJVDdlYB1dVduQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;886&quot; data-width=&quot;886&quot;/&gt;&lt;/p&gt;&lt;p&gt;测试结果：出现Compaction pending，服务撑不住写入压力。&lt;/p&gt;&lt;p&gt;出现了Compaction pending，这表示底层线程已经堆积了太多的Compaction任务，对数据的写入造成了影响。&lt;/p&gt;&lt;p&gt;那么我们增多Memtable的个数，增多Compaction线程的数量，这样我们给更多的cpu和更多的内存来缓冲，虽然最终的结果依然还是pending，不过好消息是坚持的时间久了一点，表示我们的方向没错。&lt;/p&gt;&lt;p&gt;参数改进：&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Memtable大小512M，个数20个。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不可动态调整SST文件大小，文件大小1个G。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;后台Flush和Compaction线程20个。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Block cache增加到20G。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;测试结果：依然出现Compaction pending。&lt;/p&gt;&lt;p&gt;同时我们观察到出现Compaction pending的时候，L1层的所有文件都在合并：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;418&quot; data-ratio=&quot;0.418&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDs5uIicOBzLPUx2A1XL82ibVC6uicKxm10GmXEM6KC6ElFm1DM3txKYkLiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot; data-width=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;544&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsFr3be8aEBk4QFSmWicFCN9jEZaZBRx1hDHSOFn7HhCcRNS88BiayFaWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;那么，根据对 Leveled 的理解，在L0层是多个排序结果集，当合并时，大概率需要与L1层的文件全部进行合并，因此这里就出现了瓶颈，我们就测试了单机双节点，事实证明，它是一个解决方案，但考虑到可运维性和扩缩容，不是最优。&lt;/p&gt;&lt;p&gt;考虑到Compaction pending是因为写入数据量太快导致底层来不及进行合并，那么我们就尝试了对写放大较友好的universal Compaction策略：&lt;/p&gt;&lt;p&gt;参数调整：修改合并策略为universal策略&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;666&quot; data-ratio=&quot;0.5203125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDszTjJoWRbb58zeoAYKoHAvp0Sw31jq2WyA6QoATIVt7fGsG89G5jTDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;测试结果：运行了三天，没有出现Compaction pending，同时在QPS比较高的时候，出现了较多尖刺。&lt;/p&gt;&lt;p&gt;通过监控分析，出现尖刺时请求的RT都非常高，达到了1.5s甚至更高，这时候通过kvrocks支持的perflog将RocksDB底层执行请求时的时间分析抓了出来，发现主要有以下原因：&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;hset &lt;/em&gt;时会对同一个&lt;em&gt;key&lt;/em&gt;进行加锁操作，影响写入效率。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;改进方法：kvrocks的hset数据结构是通过存储一个meta data，其中有数据类型、版本、大小、过期时间等元数据，真实的field和value数据是通过拼接namespace+slot+key+filed作为一个key（其中的size忽略了），每次对hset添加数据都会对meta data进行修改，所以原操作是有一个锁的。Trace业务使用方式极其简单的情况下，完全可以去掉meta data和锁。&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;请求到达后，虽然是多线程处理，但是最终写入请求还是单线程进行写入内存、日志刷入磁盘。其中一半慢请求都是因为这个原因。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;改进方法：在不需要快照视图一致性的情况下，可以打开unordered_write参数来大大提升写入吞吐量。&lt;/p&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读取请求的时候对太多的文件进行搜索查询，导致&lt;em&gt;io&lt;/em&gt;操作太多。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;改进方法：在转换为存入RocksDB的key时，将Trace自带的时间戳提前，这样多个排序结果集之间的key range重合大大减少，可以极大的提高读取性能。&lt;/p&gt;&lt;p&gt;这次能扛住极大的写入压力了：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;668&quot; data-ratio=&quot;0.521875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsqW4cGIPXLGmt65B0hGTNl8nSkgUH1joZu3gDgQuibX0W1cu8Ujic9k3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;测试结果：写入压力可以承载，但是空间放大太高。&lt;/p&gt;&lt;p&gt;空间放大，高达1.7倍的空间放大，导致即便是方案可用，成本也会不可控。&lt;/p&gt;&lt;p&gt;最终目光转向了FIFO：&lt;/p&gt;&lt;p&gt;参数调整：&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Memtable大小更改为1个G，同时10个Memtable触发合并刷盘。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关闭FIFO策略的Compaction。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1212&quot; data-ratio=&quot;0.946875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsYj9gVEeue89uFX0QIpr5yVWGzo6iaFDco3U0sCjMnAUY7ulUmUyn8bA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;发现FIFO方案完美符合Trace场景，业务不存在删除命令，数据到期自动删除，基本不存在的写放大能承载极高流量等特性。当然，我们也被迫舍弃了读性能，不过恰恰契合Trace的业务。&lt;/p&gt;&lt;h4&gt;Kvrocks 的数据迁移&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;624&quot; data-ratio=&quot;1.2813141683778233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsnFLzQNoBh3080rL22g4sa1UmpYvTKmO4Gl4iahQYBe4CKwfb2BvlxWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;487&quot; data-width=&quot;487&quot;/&gt;&lt;/p&gt;&lt;p&gt;数据迁移分为全量和增量两个过程：&lt;/p&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;通过使用snapshot快照复制传输文件来进行现有数据的全量迁移&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过WAL log来进行增量数据迁移，将数据组织成redis协议格式的请求发送到新节点&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;短暂禁止迁移槽的写入来将增量数据迁移过程中新增的增量数据迁移完成&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最终修改集群拓扑信息，结束整个迁移过程&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Kvrocks 的迁移数据依赖于WAL log来进行增量数据的迁移，当数据量TB级别的时候全量迁移时间可能比较长，导致WAL log已经被刷新，然后继续全量迁移，造成迁移不仅完不成，还一直对机器造成巨大的压力，唯一解决方案就是扩大WAL log。&lt;/p&gt;&lt;p&gt;最终确定扩容方案为&lt;strong&gt;请求转发&lt;/strong&gt;，此方案依赖于Trace数据具有过期特性且key中存在时间戳。我们将每次集群拓扑信息变更全部记录下来，当读请求发送到某个节点时，检查key中的时间戳和集群变更的时间戳，判断key落在了哪个时间段的集群中，再将请求转发到对应的节点进行查询即可。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;目前Trace切换 Kvrocks 存储后，已0故障稳定运行&lt;strong&gt;3个月&lt;/strong&gt;。最终实现了近百T数据、集群最高70w QPS、并且成本降低55%的目标。Kvrocks 能够满足Trace场景下的数据存储需求，且在性能和成本方面比Hbase更优。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;625&quot; data-ratio=&quot;1.0468883205456097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDswcb8OwYaqiaKOJ41h15UicnGvJBWAicOB6gVpBVG5gySSnrEmFjE9xNYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1173&quot; data-width=&quot;597&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;297&quot; data-ratio=&quot;0.4833574529667149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsFoEAS3ENxqymq3IhB1gkg7SmerlHaIlTCiaeWE1cFL8vYeSDcqqO85w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1382&quot; data-width=&quot;611&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;314&quot; data-ratio=&quot;0.5457142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MdDic47keiar5SiaFA7ZRI7gzqxxjcX9rDsWmW3bCN87MFh8XFNDOf1DlIbnGXNuPhWZTCmI1LzMkwyZ6fs8RP1Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot; data-width=&quot;572&quot;/&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;支持Trace数据的冷热分离。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对老旧数据再次进行Compaction，提高压缩率。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;进一步提升读取性能。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;以上就是 Kvrocks 在货拉拉的实践过程，谢谢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f6487bea9c096217eb98a084bae2e15e</guid>
<title>凹语言版贪吃蛇</title>
<link>https://toutiao.io/k/rfp0392</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;main data-v-7dd55a9c=&quot;&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9266589057043073&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QAncwTWS4GpYurv1a23SqfW5X0Vf32lMBex2ic4w8YKfxVXFicukQRyzU1UJOGEYNqFLo2sGggM6Jf9zXMReRJhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;859&quot;/&gt;&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;模块分解&lt;/h2&gt;&lt;p&gt;凹语言实现的贪吃蛇主要由以下三个模块组成：&lt;/p&gt;&lt;p&gt;代码：https://gitee.com/wa-lang/wa/tree/master/_examples/snake&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;canvas包&lt;/h2&gt;&lt;p&gt;canvas包是凹语言侧操作页面画布对象的接口。画布对象&lt;code&gt;Canvas&lt;/code&gt;定义如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#画布对象&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt; Canvas &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    device_id: &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画布对象对应的网页DOM对象id&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    width:     &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画布宽度，以像素为单位&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    height:    &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画布高度，以像素为单位&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    frame_buf: []&lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画布帧缓存，容量为Width &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Canvas&lt;/code&gt;对应于网页中的画布DOM对象，页面中的一块可逐像素操作的矩形区域。由于一个应用可能创建多个画布，因此&lt;code&gt;Canvas&lt;/code&gt;对象中有一个&lt;code&gt;device_id&lt;/code&gt;属性用于区别不同的画布。除宽度&lt;code&gt;width&lt;/code&gt;、高度&lt;code&gt;height&lt;/code&gt;属性外，&lt;code&gt;Canvas&lt;/code&gt;最重要的属性是它的帧缓存&lt;code&gt;frame_buf&lt;/code&gt;，&lt;code&gt;frame_buf&lt;/code&gt;是一个动态数组，其中按行主序保存着画布每个像素的颜色值（颜色值为8位RGBA格式，每个像素占用4字节，即1个32位无符号整型数u32）。&lt;/p&gt;&lt;p&gt;&lt;code&gt;NewCanvas&lt;/code&gt;函数用于创建并初始化一个&lt;code&gt;Canvas&lt;/code&gt;对象：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#wa:import wa_js_env newCanvas&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;newCanvas_JS&lt;/span&gt;&lt;span&gt;(w, h: &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;#创建一个宽度为w像素、高度为h像素的画布对象&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; NewCanvas(w, h: &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;Canvas {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; canvas Canvas&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;canvas.device_id &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;newCanvas_JS&lt;/span&gt;&lt;span&gt;(w, h)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;canvas.width &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; w&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;canvas.height &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; h&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;canvas.frame_buf &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;make&lt;/span&gt;&lt;span&gt;([]&lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;, w &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; h)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;canvas&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于Wasm不能直接操作网页中的DOM对象，因此&lt;code&gt;NewCanvas&lt;/code&gt;函数需要调用由JS宿主环境导入的&lt;code&gt;newCanvas_JS&lt;/code&gt;函数方可完成画布DOM对象的创建。编译标签&lt;code&gt;#wa:import wa_js_env newCanvas&lt;/code&gt;标明了后续的&lt;code&gt;newCanvas_JS&lt;/code&gt;是由外部导入的以及对应的导入路径，因此它只定义了原型而没有函数体。画布DOM对象创建后，代码&lt;code&gt;make([]u32, w * h)&lt;/code&gt;创建了对应宽高的帧缓存，并执行了其他一些初始化操作。&lt;/p&gt;&lt;p&gt;凹语言侧代码可通过&lt;code&gt;Canvas&lt;/code&gt;对象的下列方法读写画布帧缓存：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#获取画布对象坐标为(x, y)处的像素颜色值&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; Canvas.GetPixel(x, y: &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.frame_buf[y &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.width &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; x]&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;#设置画布对象坐标(x, y)处的颜色值为color&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; Canvas.SetPixel(x, y, color: &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;) {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.frame_buf[y &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.width &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; x] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; color&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当整个帧缓存填充完毕后，通过&lt;code&gt;Canvas.Flush&lt;/code&gt;方法将帧缓存数据更新至页面中的画布对象；与创建画布DOM对象类似，该操作也需要通过JS环境导入的函数完成：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#wa:import wa_js_env updateCanvas&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;updateCanvas_JS&lt;/span&gt;&lt;span&gt;(id: &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;, buf: &lt;/span&gt;&lt;span&gt;*u32&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; Canvas.Flush() {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;updateCanvas_JS&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.device_id, &lt;/span&gt;&lt;span&gt;&amp;amp;this&lt;/span&gt;&lt;span&gt;.frame_buf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;])&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了&lt;code&gt;Canvas&lt;/code&gt;对象外，canvas包还需要处理页面画布DOM对象上的交互事件（如键盘按键、鼠标点击等），否则用户无法操作贪吃蛇走向希望的方向。与此相关的&lt;code&gt;CanvasEvents&lt;/code&gt;对象定义如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#画布事件回调函数原型&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt; OnTouch &lt;/span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; (x, y: &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt; OnKey &lt;/span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt;(key: &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;#画布事件&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt; CanvasEvents &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;Device_id:   &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画布设备ID&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    OnMouseDown: OnTouch &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标按下时的回调处理函数&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    OnMouseUp:   OnTouch &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标松开时的回调处理函数&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;OnKeyDown:   OnKey   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;键盘按下时的回调处理函数&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;OnKeyUp:     OnKey   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;键盘弹起时的回调处理函数&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; canvas_events: []CanvasEvents&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个&lt;code&gt;CanvasEvents&lt;/code&gt;对应某个&lt;code&gt;Canvas&lt;/code&gt;的一组交互事件回调函数，其对应关系由&lt;code&gt;CanvasEvents.Device_id&lt;/code&gt;和&lt;code&gt;Canvas.device_id&lt;/code&gt;确定。canvas包的包级变量&lt;code&gt;canvas_events&lt;/code&gt;是一个动态数组，凹语言侧代码可以通过&lt;code&gt;AttachCanvasEvents&lt;/code&gt;函数将一个事件对象附加到事件对象数组中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; AttachCanvasEvents(e: CanvasEvents) {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt; canvas_events {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; canvas_events[i].Device_id &lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt; e.Device_id {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;canvas_events[i] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;canvas_events &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(canvas_events, e)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当某个画布DOM对象上产生鼠标点击事件时，即可通过遍历&lt;code&gt;canvas_events&lt;/code&gt;数组，调用与该画布关联的鼠标点击回调函数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;供外部JS调用的鼠标按下事件响应函数&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;id为画布DOM对象对应的Canvas对象id&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;(x, y)为画布像素坐标系坐标&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; OnMouseDown(id: &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;, x, y:&lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;) {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; _, i &lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt; canvas_events {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; i.Device_id &lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt; id {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;i.OnMouseDown(x, y)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;游戏主逻辑&lt;/h2&gt;&lt;p&gt;游戏主逻辑由&lt;code&gt;GameState&lt;/code&gt;对象的全局实例&lt;code&gt;gameState&lt;/code&gt;实现，它的定义如下&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt; GameState &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;w, h  :&lt;/span&gt;&lt;span&gt;i32&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;scale :&lt;/span&gt;&lt;span&gt;i32&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;grid  :[]&lt;/span&gt;&lt;span&gt;i8&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;body  :[]Position&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;dir   :&lt;/span&gt;&lt;span&gt;i32&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;ca :&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;canvas.Canvas&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; gameState: GameState&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; GameState.Init(w, h: &lt;/span&gt;&lt;span&gt;i32&lt;/span&gt;&lt;span&gt;, scale: &lt;/span&gt;&lt;span&gt;i32&lt;/span&gt;&lt;span&gt;) {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.w &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; w&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.h &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; h&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.scale &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; scale&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.grid &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;make&lt;/span&gt;&lt;span&gt;([]&lt;/span&gt;&lt;span&gt;i8&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;(w&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;h))&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ca &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; canvas.NewCanvas(&lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;(w&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;scale), &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;(h&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;scale))&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; caev: canvas.CanvasEvents&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;caev.Device_id &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ca.GetDeviceID()&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;caev.OnMouseDown &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt;(x, y: &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;) {}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;caev.OnMouseUp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt;(x, y: &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;) {}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;caev.OnKeyUp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt;(key: &lt;/span&gt;&lt;span&gt;u32&lt;/span&gt;&lt;span&gt;) {}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;caev.OnKeyDown &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.OnKeyDown&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;Dirs[DirNull] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Position{x: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, y: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;Dirs[DirLeft] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Position{x: &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, y: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;Dirs[DirUp] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Position{x: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, y: &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;Dirs[DirRight] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Position{x: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, y: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;Dirs[DirDown] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Position{x: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, y: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;canvas.AttachCanvasEvents(caev)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;GameState&lt;/code&gt;的&lt;code&gt;ca&lt;/code&gt;属性类型为&lt;code&gt;Canvas&lt;/code&gt;，用于输出图形结果；&lt;code&gt;grid&lt;/code&gt;是以行主序保存的棋盘格状态；&lt;code&gt;body&lt;/code&gt;动态数组记录了贪吃蛇身体的每个节点的棋盘格坐标。由于1个像素在屏幕上非常小难以看清，因此1个棋盘格实际对应画布上一个10像素*10像素的正方形区域。&lt;code&gt;GameState.Init&lt;/code&gt;方法除了初始化上述属性，还通过&lt;code&gt;canvas.AttachCanvasEvents&lt;/code&gt;方法挂接了相应的交互事件回调函数，特别需要注意的是，该处挂接的&lt;code&gt;OnKeyDown&lt;/code&gt;事件是一个对象方法，它本质上是一个闭包。&lt;/p&gt;&lt;p&gt;游戏的处理流程很简单：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; GameState.Step() {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dir &lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt; DirNull {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;newHead &lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body)&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;newHead.x &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; Dirs[&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dir].x&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;newHead.y &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; Dirs[&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dir].y&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; newHead.x &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;newHead.x &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.w &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; newHead.x &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.w {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;newHead.x &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; newHead.y &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;newHead.y &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.h &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; newHead.y &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.h {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;newHead.y &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.grid[newHead.y&lt;/span&gt;&lt;span&gt;*this&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;newHead.x] {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; GridBody:&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Start()&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; GridFood:&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.SetGridType(newHead, GridBody)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body, newHead)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GenFood()&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.SetGridType(newHead, GridBody)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.SetGridType(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;], GridNull)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body, newHead)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:]&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ca.Flush()&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; Step() {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;gameState.Step()&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;() {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;gameState.Init(&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;gameState.Start()&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;既按行进方向移动贪吃蛇的身体，并判断是否吃到自己或食物。&lt;code&gt;Step&lt;/code&gt;函数导出到外部JS环境，是消息循环入口。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;页面环境&lt;/h2&gt;&lt;p&gt;页面环境的主要运行逻辑位于wa_app.js中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;WaApp&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;//..&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;let&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;let&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;importsObject&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;wa_js_env&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newCanvas&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;let&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;canvas&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;document&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;canvas&lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;updateCanvas&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;let&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_ctx&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createImageData&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_canvas&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_canvas&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;let&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;buf_len&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_canvas&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_canvas&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;let&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;buf&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;memUint8Array&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;buf_len&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;buf_len&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;              &lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;buf&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_ctx&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;putImageData&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;WebAssembly&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;instantiateStreaming&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;fetch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;importsObject&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;res&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_inst&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;res&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;instance&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_inst&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;exports&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_start&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;mem&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_inst&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;exports&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;memory&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;memView&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;addr&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;DataView&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_inst&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;exports&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;memory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;addr&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;memUint8Array&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;addr&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Uint8Array&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;mem&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;addr&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;//..&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;gameLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;waApp&lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;_inst&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;exports&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;snake.Step&lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;]()&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;waApp&lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;WaApp&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;waApp&lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./snake.wasm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;timer&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;gameLoop&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;IS_MOBILE&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;150&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)()&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它使用&lt;code&gt;WebAssembly.instantiateStreaming&lt;/code&gt;方法创建了贪吃蛇的Wasm实例，并通过导入对象将&lt;code&gt;newCanvas&lt;/code&gt;/&lt;code&gt;updateCanvas&lt;/code&gt;等方法注入实例供凹语言侧调用；并周期性的调用导出的&lt;code&gt;snake.Step&lt;/code&gt;方法驱动游戏进程。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;小结&lt;/h2&gt;&lt;p&gt;贪吃蛇例子较为完整的展示了如何使用凹语言开发网页应用。其中使用了动态数组、方法值闭包、自定义对象等特性，特别是凹语言与JS环境如何互相调用及传递数据。该例子体现了凹语言用于更复杂应用的开发潜力。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QAncwTWS4GoROF9U9uuibsPByH1AYvk61pjsHNUNXdQdhpUupxiad7y0PXdibspZpCobBCkqtpHAzR4icFhwicWPajg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/p&gt;&lt;/main&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0aa62b167c6c1060769754381aaf74fa</guid>
<title>某个外包公司的面试总结</title>
<link>https://toutiao.io/k/g7nt2sa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;header class=&quot;post-header&quot;&gt;
&lt;h1 class=&quot;post-title&quot; itemprop=&quot;name headline&quot;&gt;某个外包公司的面试总结
&lt;/h1&gt;
&lt;p class=&quot;post-meta&quot;&gt;
&lt;span class=&quot;post-time&quot;&gt;
&lt;span class=&quot;post-meta-item-icon&quot;&gt;
&lt;i class=&quot;fa fa-calendar-o&quot;/&gt;
&lt;/span&gt;
&lt;span class=&quot;post-meta-item-text&quot;&gt;Posted on&lt;/span&gt;
&lt;time title=&quot;Created: 2022-04-12 22:23:35&quot; itemprop=&quot;dateCreated datePublished&quot; datetime=&quot;2022-04-12T22:23:35+08:00&quot;&gt;2022-04-12&lt;/time&gt;
&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;post-meta-item-icon&quot;&gt;
&lt;i class=&quot;fa fa-calendar-check-o&quot;/&gt;
&lt;/span&gt;
&lt;span class=&quot;post-meta-item-text&quot;&gt;Edited on&lt;/span&gt;
&lt;time title=&quot;Modified: 2022-04-17 20:32:31&quot; itemprop=&quot;dateModified&quot; datetime=&quot;2022-04-17T20:32:31+08:00&quot;&gt;2022-04-17&lt;/time&gt;
&lt;/span&gt;
&lt;/p&gt;
&lt;/header&gt;
&lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;
&lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;/&gt;缘起&lt;/h2&gt;&lt;p&gt;无非就是“又”失业了，重新开始找工作，原本还不想招惹外包公司，无奈行情不好，外包工作也是工作呀，于是乎，就定了某个外包公司的面试，第一面：外包公司的技术面。&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;
&lt;h2 id=&quot;心得体会&quot;&gt;&lt;a href=&quot;#心得体会&quot; class=&quot;headerlink&quot; title=&quot;心得体会&quot;/&gt;心得体会&lt;/h2&gt;&lt;p&gt;主要问题都是跟 aws 有关系，这个岗位的甲方是个外企，肯定重度使用 aws。而且还在用 aws 的 eks 服务。&lt;/p&gt;
&lt;p&gt;感觉面试官的视野还是很重要的。&lt;/p&gt;
&lt;h2 id=&quot;几个具体问题&quot;&gt;&lt;a href=&quot;#几个具体问题&quot; class=&quot;headerlink&quot; title=&quot;几个具体问题&quot;/&gt;几个具体问题&lt;/h2&gt;&lt;p&gt;有个细节：腾讯会议面试，面试官几个人，可能是三个，首先特意让我把视频打开，于是我打开了，但是对方并没有打开。好吧，我是求职者，不对等也正常。&lt;/p&gt;
&lt;p&gt;但为什么面试需要让面试者打开视频呢？这个不太明白，也许相关 HR 会比较清楚这一点。&lt;/p&gt;
&lt;h3 id=&quot;关于-eks-的-ingress&quot;&gt;&lt;a href=&quot;#关于-eks-的-ingress&quot; class=&quot;headerlink&quot; title=&quot;关于 eks 的 ingress&quot;/&gt;关于 eks 的 ingress&lt;/h3&gt;&lt;p&gt;问我 eks 里的服务通过 ingress 暴露出去，然后数据包是怎么从外网到 pod 的。&lt;/p&gt;
&lt;p&gt;这个题我答的不好，前东家其实差不多就是这个架构：nginx-ingress，然后外面是 aws 的 LB，我一直在解释外网流量到 aws 的 LB 设备之后然后是转到 eks 集群的 node 节点的某个 tcp 端口，我的意思是，其实服务最终是通过 nodeport 透出去的。&lt;/p&gt;
&lt;p&gt;上面我说的这个大概是基本上没太大问题的，但是人家问的应该不是这个。:(&lt;/p&gt;
&lt;p&gt;其实上面我提到的 nodeport 透出去的服务正是 nginx-ingress（或者是 nginx-ingress-controller，具体忘了，我得再看看 nginx-ingress）&lt;/p&gt;
&lt;h3 id=&quot;关于被-nginx-反代的服务如何获得客户端的真实-IP-的问题&quot;&gt;&lt;a href=&quot;#关于被-nginx-反代的服务如何获得客户端的真实-IP-的问题&quot; class=&quot;headerlink&quot; title=&quot;关于被 nginx 反代的服务如何获得客户端的真实 IP 的问题&quot;/&gt;关于被 nginx 反代的服务如何获得客户端的真实 IP 的问题&lt;/h3&gt;&lt;p&gt;这个其实我比较熟悉，http 基本协议嘛。&lt;/p&gt;
&lt;p&gt;我说这个简单，在反代的 nginx 配置里将 client ip 直接写入一个特定的 http 头，然后真实的服务里再把这个头取出来即可。&lt;/p&gt;
&lt;p&gt;其实这个回答完全没毛病，我之前有项目就是这么干的。但面试官却感觉好像抓住了什么一样拼命问我到底是哪个 http 头？搞得我都有点上头了，我于是说：“哪个头不一样吗，只要跟后端协商好了就行了”。还被追问，还问一般标准是哪个头，于是我只能说 X-Forwarded-For，于是面试官认可了。&lt;/p&gt;
&lt;p&gt;我其实没有细说为什么要另外弄一个头，这是因为客户端访问服务，中间可能会过 n 层代理，理论上每一层都会且必须要往 X-Forwarded-For 里写东西，但实际上，守规矩的人有，但绝对不是全部！于是我们的逻辑就是单独再搞一个 http 头，算是有点私有协议的意思，自己用，这样感觉比直接用 X-Forwarded-For 更靠谱一些。&lt;/p&gt;
&lt;h3 id=&quot;Jenkins-怎么做代码触发自动构建（CI）&quot;&gt;&lt;a href=&quot;#Jenkins-怎么做代码触发自动构建（CI）&quot; class=&quot;headerlink&quot; title=&quot;Jenkins 怎么做代码触发自动构建（CI）&quot;/&gt;Jenkins 怎么做代码触发自动构建（CI）&lt;/h3&gt;&lt;p&gt;某个面试官问的，我当时回答：我不知道。我真不知道，或者我们曾经也有用过这种功能，但因为具体不是我配的，我就没了解到。但我知道，这个是绝度可以实现的，大致猜想是通过 webhook 之类的东西来做就可以。&lt;/p&gt;
&lt;p&gt;我又说，我们有时并没有用 Jenkins，面试官就逼问：“没有 Jenkins 怎么做 CI/CD 呢？”，我当时就笑了，说：“我的好几个前司，项目的 CI/CD 是直接在 gitlab 里做的。”（他可能不太清楚 gitlab 本身就有 CI/CD 的功能）。而我恰恰由于要维护这个，曾经大概看过相关配置。&lt;/p&gt;
&lt;p&gt;估计他也不知道 github-action 之类的东西吧。&lt;/p&gt;
&lt;h3 id=&quot;关于-serverless&quot;&gt;&lt;a href=&quot;#关于-serverless&quot; class=&quot;headerlink&quot; title=&quot;关于 serverless&quot;/&gt;关于 serverless&lt;/h3&gt;&lt;p&gt;我回答说之前的某司，我用过 aws 上的什么服务来着（我真是这么说的，我忘了那个叫 Lambda 了），用那个写了个 python 程序，定时执行一些操作。那个我理解就是 serverless&lt;/p&gt;
&lt;h3 id=&quot;用过多少-aws-的服务&quot;&gt;&lt;a href=&quot;#用过多少-aws-的服务&quot; class=&quot;headerlink&quot; title=&quot;用过多少 aws 的服务&quot;/&gt;用过多少 aws 的服务&lt;/h3&gt;&lt;p&gt;于是我就说了一堆，但的确好多服务我忘了名字了，我只能简单介绍下这个服务是干啥的。我估计我用的好多服务面试官们也没用过，：）。这个很正常，就像他们用过的服务有些我也没用过一样。&lt;/p&gt;
&lt;h3 id=&quot;eks-中的服务暴露出来的几种方法&quot;&gt;&lt;a href=&quot;#eks-中的服务暴露出来的几种方法&quot; class=&quot;headerlink&quot; title=&quot;eks 中的服务暴露出来的几种方法&quot;/&gt;eks 中的服务暴露出来的几种方法&lt;/h3&gt;&lt;p&gt;我居然只回答出 nodeport 和 ingress 两种，连 LB 设备这个都忘了。:(&lt;/p&gt;
&lt;h2 id=&quot;结果&quot;&gt;&lt;a href=&quot;#结果&quot; class=&quot;headerlink&quot; title=&quot;结果&quot;/&gt;结果&lt;/h2&gt;&lt;p&gt;最终的结果，自然是挂了呀。:(&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bf0039dd01e3ebfff8d6c4a55dd60b28</guid>
<title>用这 4 招优雅的实现 Spring Boot 异步线程间数据传递</title>
<link>https://toutiao.io/k/6vrh5a2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是不才陈某~&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 自定义线程池实现异步开发相信看过陈某的文章都了解，但是在实际开发中需要在父子线程之间传递一些数据，比如用户信息，链路信息等等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如用户登录信息使用ThreadLocal存放保证线程隔离，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 公众号：码猿技术专栏&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 用户上下文信息&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OauthContext&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;final&lt;/span&gt;  ThreadLocal&amp;lt;LoginVal&amp;gt; loginValThreadLocal=&lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  LoginVal &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; loginValThreadLocal.get();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(LoginVal loginVal)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        loginValThreadLocal.set(loginVal);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;clear&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        loginValThreadLocal.remove();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么子线程想要获取这个LoginVal如何做呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天就来介绍几种优雅的方式实现Spring Boot 内部的父子线程的数据传递。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4755244755244755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rARWUZvTNzKLMlHRF0tlboH9uuuKBJq3n6rhLCO7zP9KByeO6W8uKHxNlWyicPDVpX3ZeQy0HD5pyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1001&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 手动设置&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每执行一次异步线程都要分为两步：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取父线程的LoginVal&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将LoginVal设置到子线程，达到复用&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;handlerAsync&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//1. 获取父线程的loginVal&lt;/span&gt;&lt;br/&gt;        LoginVal loginVal = OauthContext.get();&lt;br/&gt;        log.info(&lt;span&gt;&quot;父线程的值：{}&quot;&lt;/span&gt;,OauthContext.get());&lt;br/&gt;        CompletableFuture.runAsync(()-&amp;gt;{&lt;br/&gt;            &lt;span&gt;//2. 设置子线程的值，复用&lt;/span&gt;&lt;br/&gt;           OauthContext.set(loginVal);&lt;br/&gt;           log.info(&lt;span&gt;&quot;子线程的值：{}&quot;&lt;/span&gt;,OauthContext.get());&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然能够实现目的，但是每次开异步线程都需要手动设置，重复代码太多，看了头疼，你认为优雅吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 线程池设置TaskDecorator&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TaskDecorator是什么？官方api的大致意思：这是一个执行回调方法的装饰器，主要应用于传递上下文，或者提供任务的监控/统计信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道有这么一个东西，如何去使用？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TaskDecorator是一个接口，首先需要去实现它，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 公众号：码猿技术专栏&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 上下文装饰器&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ContextTaskDecorator&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;TaskDecorator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Runnable &lt;span&gt;decorate&lt;/span&gt;&lt;span&gt;(Runnable runnable)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取父线程的loginVal&lt;/span&gt;&lt;br/&gt;        LoginVal loginVal = OauthContext.get();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; () -&amp;gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 将主线程的请求信息，设置到子线程中&lt;/span&gt;&lt;br/&gt;                OauthContext.set(loginVal);&lt;br/&gt;                &lt;span&gt;// 执行子线程，这一步不要忘了&lt;/span&gt;&lt;br/&gt;                runnable.run();&lt;br/&gt;            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 线程结束，清空这些信息，否则可能造成内存泄漏&lt;/span&gt;&lt;br/&gt;                OauthContext.clear();&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我只是设置了LoginVal，实际开发中其他的共享数据，比如&lt;code&gt;SecurityContext&lt;/code&gt;，&lt;code&gt;RequestAttributes&lt;/code&gt;....&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;TaskDecorator&lt;/code&gt;需要结合线程池使用，实际开发中异步线程建议使用线程池，只需要在对应的线程池配置一下，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Bean&lt;/span&gt;(&lt;span&gt;&quot;taskExecutor&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; ThreadPoolTaskExecutor &lt;span&gt;taskExecutor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ThreadPoolTaskExecutor poolTaskExecutor = &lt;span&gt;new&lt;/span&gt; ThreadPoolTaskExecutor();&lt;br/&gt;        poolTaskExecutor.setCorePoolSize(xx);&lt;br/&gt;        poolTaskExecutor.setMaxPoolSize(xx);&lt;br/&gt;        &lt;span&gt;// 设置线程活跃时间（秒）&lt;/span&gt;&lt;br/&gt;        poolTaskExecutor.setKeepAliveSeconds(xx);&lt;br/&gt;        &lt;span&gt;// 设置队列容量&lt;/span&gt;&lt;br/&gt;        poolTaskExecutor.setQueueCapacity(xx);&lt;br/&gt;        &lt;span&gt;//设置TaskDecorator，用于解决父子线程间的数据复用&lt;/span&gt;&lt;br/&gt;        poolTaskExecutor.setTaskDecorator(&lt;span&gt;new&lt;/span&gt; ContextTaskDecorator());&lt;br/&gt;        poolTaskExecutor.setRejectedExecutionHandler(&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy());&lt;br/&gt;        &lt;span&gt;// 等待所有任务结束后再关闭线程池&lt;/span&gt;&lt;br/&gt;        poolTaskExecutor.setWaitForTasksToCompleteOnShutdown(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; poolTaskExecutor;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时业务代码就不需要去设置子线程的值，直接使用即可，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;handlerAsync&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;父线程的用户信息：{}&quot;&lt;/span&gt;, OauthContext.get());&lt;br/&gt;        &lt;span&gt;//执行异步任务，需要指定的线程池&lt;/span&gt;&lt;br/&gt;        CompletableFuture.runAsync(()-&amp;gt; log.info(&lt;span&gt;&quot;子线程的用户信息：{}&quot;&lt;/span&gt;, OauthContext.get()),taskExecutor);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看一下结果，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.061921296296296294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rARWUZvTNzKLMlHRF0tlboHPquFxUfx8LlfgSwasrxY2bASk4iasVhWlGcDqPPCUicHHmPJAZPqGMtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用的是&lt;code&gt;CompletableFuture&lt;/code&gt;执行异步任务，使用&lt;code&gt;@Async&lt;/code&gt;这个注解同样是可行的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;注意&lt;/span&gt;：无论使用何种方式，都需要指定线程池&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. InheritableThreadLocal&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案不建议使用，InheritableThreadLocal虽然能够实现父子线程间的复用，但是在线程池中使用会存在复用的问题，具体的可以看陈某之前的文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;amp;mid=2247512365&amp;amp;idx=1&amp;amp;sn=f847a72fecda9852ad23879e78e07af2&amp;amp;chksm=fcf76ee0cb80e7f6df3c15868f89a7722db5152625b2e60c2ba78f4bc14112fbc45280e52fac&amp;amp;scene=21&amp;amp;cur_album_id=2042874937312346114#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;微服务中使用阿里开源的TTL，优雅的实现身份信息的线程间复用&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案使用也是非常简单，直接用InheritableThreadLocal替换ThreadLocal即可，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 公众号：码猿技术专栏&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 用户上下文信息&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OauthContext&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;final&lt;/span&gt;  InheritableThreadLocal&amp;lt;LoginVal&amp;gt; loginValThreadLocal=&lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  LoginVal &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; loginValThreadLocal.get();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(LoginVal loginVal)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        loginValThreadLocal.set(loginVal);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;clear&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        loginValThreadLocal.remove();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. TransmittableThreadLocal&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TransmittableThreadLocal是阿里开源的工具，弥补了InheritableThreadLocal的缺陷，在使用线程池等会池化复用线程的执行组件情况下，提供&lt;code&gt;ThreadLocal&lt;/code&gt;值的传递功能，解决异步执行时上下文传递的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用起来也是非常简单，添加依赖如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;transmittable-thread-local&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.14.2&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OauthContext改造代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 公众号：码猿技术专栏&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 用户上下文信息&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OauthContext&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;final&lt;/span&gt; TransmittableThreadLocal&amp;lt;LoginVal&amp;gt; loginValThreadLocal=&lt;span&gt;new&lt;/span&gt; TransmittableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  LoginVal &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; loginValThreadLocal.get();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(LoginVal loginVal)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        loginValThreadLocal.set(loginVal);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;clear&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        loginValThreadLocal.remove();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于TransmittableThreadLocal想深入了解其原理可以看陈某之前的文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;amp;mid=2247512365&amp;amp;idx=1&amp;amp;sn=f847a72fecda9852ad23879e78e07af2&amp;amp;chksm=fcf76ee0cb80e7f6df3c15868f89a7722db5152625b2e60c2ba78f4bc14112fbc45280e52fac&amp;amp;scene=21&amp;amp;cur_album_id=2042874937312346114#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;微服务中使用阿里开源的TTL，优雅的实现身份信息的线程间复用&lt;/a&gt;，应用还是非常广泛的&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TransmittableThreadLocal原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从定义来看，&lt;code&gt;TransimittableThreadLocal&lt;/code&gt;继承于&lt;code&gt;InheritableThreadLocal&lt;/code&gt;，并实现&lt;code&gt;TtlCopier&lt;/code&gt;接口，它里面只有一个&lt;code&gt;copy&lt;/code&gt;方法。所以主要是对&lt;code&gt;InheritableThreadLocal&lt;/code&gt;的扩展。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TransmittableThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;InheritableThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;TtlCopier&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;TransimittableThreadLocal&lt;/code&gt;中添加&lt;code&gt;holder&lt;/code&gt;属性。这个属性的作用就是被标记为具备线程传递资格的对象都会被添加到这个对象中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要标记一个类，比较容易想到的方式，就是给这个类新增一个&lt;code&gt;Type&lt;/code&gt;字段，还有一个方法就是将具备这种类型的的对象都添加到一个静态全局集合中。之后使用时，这个集合里的所有值都具备这个标记。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 1. holder本身是一个InheritableThreadLocal对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 2. 这个holder对象的value是WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, ?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//   2.1 WeekHashMap的value总是null,且不可能被使用。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    2.2 WeekHasshMap支持value=null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; InheritableThreadLocal&amp;lt;WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, ?&amp;gt;&amp;gt; holder = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, ?&amp;gt;&amp;gt;() {&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;protected&lt;/span&gt; WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, ?&amp;gt; initialValue() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt;();&lt;br/&gt;  }&lt;br/&gt; &lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 重写了childValue方法，实现上直接将父线程的属性作为子线程的本地变量对象。&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;protected&lt;/span&gt; WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, ?&amp;gt; childValue(WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, ?&amp;gt; parentValue) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; WeakHashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt;(parentValue);&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用代码是通过&lt;code&gt;TtlExecutors&lt;/code&gt;工具类对线程池对象进行包装。工具类只是简单的判断，输入的线程池是否已经被包装过、非空校验等，然后返回包装类&lt;code&gt;ExecutorServiceTtlWrapper&lt;/code&gt;。根据不同的线程池类型，有不同和的包装类。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Nullable&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;getTtlExecutorService&lt;/span&gt;&lt;span&gt;(@Nullable ExecutorService executorService)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (TtlAgent.isTtlAgentLoaded() || executorService == &lt;span&gt;null&lt;/span&gt; || executorService &lt;span&gt;instanceof&lt;/span&gt; TtlEnhanced) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; executorService;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ExecutorServiceTtlWrapper(executorService);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入包装类&lt;code&gt;ExecutorServiceTtlWrapper&lt;/code&gt;。可以注意到不论是通过&lt;code&gt;ExecutorServiceTtlWrapper#submit&lt;/code&gt;方法或者是&lt;code&gt;ExecutorTtlWrapper#execute&lt;/code&gt;方法，都会将线程对象包装成&lt;code&gt;TtlCallable&lt;/code&gt;或者&lt;code&gt;TtlRunnable&lt;/code&gt;，用于在真正执行&lt;code&gt;run&lt;/code&gt;方法前做一些业务逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 在ExecutorServiceTtlWrapper实现submit方法&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@NonNull&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;Future&amp;lt;T&amp;gt; &lt;span&gt;submit&lt;/span&gt;&lt;span&gt;(@NonNull Callable&amp;lt;T&amp;gt; task)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; executorService.submit(TtlCallable.get(task));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 在ExecutorTtlWrapper实现execute方法&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(@NonNull Runnable command)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  executor.execute(TtlRunnable.get(command));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，重点的核心逻辑应该是在&lt;code&gt;TtlCallable#call()&lt;/code&gt;或者&lt;code&gt;TtlRunnable#run()&lt;/code&gt;中。以下以&lt;code&gt;TtlCallable&lt;/code&gt;为例，&lt;code&gt;TtlRunnable&lt;/code&gt;同理类似。在分析&lt;code&gt;call()&lt;/code&gt;方法之前，先看一个类&lt;code&gt;Transmitter&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Transmitter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;    * 捕获当前线程中的是所有TransimittableThreadLocal和注册ThreadLocal的值。&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@NonNull&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object &lt;span&gt;capture&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Snapshot(captureTtlValues(), captureThreadLocalValues());&lt;br/&gt;  }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;    * 捕获TransimittableThreadLocal的值,将holder中的所有值都添加到HashMap后返回。&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; captureTtlValues() {&lt;br/&gt;    HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; ttl2Value = &lt;br/&gt;      &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt;();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (TransmittableThreadLocal&amp;lt;Object&amp;gt; threadLocal : holder.get().keySet()) {&lt;br/&gt;      ttl2Value.put(threadLocal, threadLocal.copyValue());&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ttl2Value;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;    * 捕获注册的ThreadLocal的值,也就是原本线程中的ThreadLocal,可以注册到TTL中，在&lt;br/&gt;    * 进行线程池本地变量传递时也会被传递。&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HashMap&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; captureThreadLocalValues() {&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; threadLocal2Value = &lt;br/&gt;      &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt;();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(Map.Entry&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;,TtlCopier&amp;lt;Object&amp;gt;&amp;gt;entry:threadLocalHolder.entrySet()){&lt;br/&gt;      &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Object&amp;gt; threadLocal = entry.getKey();&lt;br/&gt;      &lt;span&gt;final&lt;/span&gt; TtlCopier&amp;lt;Object&amp;gt; copier = entry.getValue();&lt;br/&gt;      threadLocal2Value.put(threadLocal, copier.copy(threadLocal.get()));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; threadLocal2Value;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;    * 将捕获到的本地变量进行替换子线程的本地变量，并且返回子线程现有的本地变量副本backup。&lt;br/&gt;    * 用于在执行run/call方法之后，将本地变量副本恢复。&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@NonNull&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object &lt;span&gt;replay&lt;/span&gt;&lt;span&gt;(@NonNull Object captured)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Snapshot capturedSnapshot = (Snapshot) captured;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Snapshot(replayTtlValues(capturedSnapshot.ttl2Value), &lt;br/&gt;                        replayThreadLocalValues(capturedSnapshot.threadLocal2Value));&lt;br/&gt;  }&lt;br/&gt; &lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;    * 替换TransmittableThreadLocal&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@NonNull&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; replayTtlValues(&lt;span&gt;@NonNull&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; captured) {&lt;br/&gt;    &lt;span&gt;// 创建副本backup&lt;/span&gt;&lt;br/&gt;    HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; backup = &lt;br/&gt;      &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;&amp;gt; iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) {&lt;br/&gt;      TransmittableThreadLocal&amp;lt;Object&amp;gt; threadLocal = iterator.next();&lt;br/&gt;      &lt;span&gt;// 对当前线程的本地变量进行副本拷贝&lt;/span&gt;&lt;br/&gt;      backup.put(threadLocal, threadLocal.get());&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 若出现调用线程中不存在某个线程变量，而线程池中线程有，则删除线程池中对应的本地变量&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!captured.containsKey(threadLocal)) {&lt;br/&gt;        iterator.remove();&lt;br/&gt;        threadLocal.superRemove();&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 将捕获的TTL值打入线程池获取到的线程TTL中。&lt;/span&gt;&lt;br/&gt;    setTtlValuesTo(captured);&lt;br/&gt;    &lt;span&gt;// 是一个扩展点，调用TTL的beforeExecute方法。默认实现为空&lt;/span&gt;&lt;br/&gt;    doExecuteCallback(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; backup;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HashMap&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; replayThreadLocalValues(&lt;span&gt;@NonNull&lt;/span&gt; HashMap&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; captured) {&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; backup = &lt;br/&gt;      &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt;();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; entry : captured.entrySet()) {&lt;br/&gt;      &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Object&amp;gt; threadLocal = entry.getKey();&lt;br/&gt;      backup.put(threadLocal, threadLocal.get());&lt;br/&gt;      &lt;span&gt;final&lt;/span&gt; Object value = entry.getValue();&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (value == threadLocalClearMark) threadLocal.remove();&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; threadLocal.set(value);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; backup;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;    * 清除单线线程的所有TTL和TL，并返回清除之气的backup&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@NonNull&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object &lt;span&gt;clear&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; ttl2Value = &lt;br/&gt;      &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; threadLocal2Value = &lt;br/&gt;      &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt;();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(Map.Entry&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;,TtlCopier&amp;lt;Object&amp;gt;&amp;gt;entry:threadLocalHolder.entrySet()){&lt;br/&gt;      &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Object&amp;gt; threadLocal = entry.getKey();&lt;br/&gt;      threadLocal2Value.put(threadLocal, threadLocalClearMark);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; replay(&lt;span&gt;new&lt;/span&gt; Snapshot(ttl2Value, threadLocal2Value));&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;    * 还原&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;restore&lt;/span&gt;&lt;span&gt;(@NonNull Object backup)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Snapshot backupSnapshot = (Snapshot) backup;&lt;br/&gt;    restoreTtlValues(backupSnapshot.ttl2Value);&lt;br/&gt;    restoreThreadLocalValues(backupSnapshot.threadLocal2Value);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;restoreTtlValues&lt;/span&gt;&lt;span&gt;(@NonNull HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; backup)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 扩展点，调用TTL的afterExecute&lt;/span&gt;&lt;br/&gt;    doExecuteCallback(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;&amp;gt; iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) {&lt;br/&gt;      TransmittableThreadLocal&amp;lt;Object&amp;gt; threadLocal = iterator.next();&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!backup.containsKey(threadLocal)) {&lt;br/&gt;        iterator.remove();&lt;br/&gt;        threadLocal.superRemove();&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 将本地变量恢复成备份版本&lt;/span&gt;&lt;br/&gt;    setTtlValuesTo(backup);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setTtlValuesTo&lt;/span&gt;&lt;span&gt;(@NonNull HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; ttlValues)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; entry : ttlValues.entrySet()) {&lt;br/&gt;      TransmittableThreadLocal&amp;lt;Object&amp;gt; threadLocal = entry.getKey();&lt;br/&gt;      threadLocal.set(entry.getValue());&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;restoreThreadLocalValues&lt;/span&gt;&lt;span&gt;(@NonNull HashMap&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; backup)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; entry : backup.entrySet()) {&lt;br/&gt;      &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Object&amp;gt; threadLocal = entry.getKey();&lt;br/&gt;      threadLocal.set(entry.getValue());&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 快照类，保存TTL和TL&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Snapshot&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; ttl2Value;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; threadLocal2Value;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Snapshot&lt;/span&gt;&lt;span&gt;(HashMap&amp;lt;TransmittableThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; ttl2Value,&lt;br/&gt;                     HashMap&amp;lt;ThreadLocal&amp;lt;Object&amp;gt;, Object&amp;gt; threadLocal2Value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.ttl2Value = ttl2Value;&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.threadLocal2Value = threadLocal2Value;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入&lt;code&gt;TtlCallable#call()&lt;/code&gt;方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; V &lt;span&gt;call&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;  Object captured = capturedRef.get();&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (captured == &lt;span&gt;null&lt;/span&gt; || releaseTtlValueReferenceAfterCall &amp;amp;&amp;amp; &lt;br/&gt;      !capturedRef.compareAndSet(captured, &lt;span&gt;null&lt;/span&gt;)) {&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;TTL value reference is released after call!&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 调用replay方法将捕获到的当前线程的本地变量，传递给线程池线程的本地变量，&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 并且获取到线程池线程覆盖之前的本地变量副本。&lt;/span&gt;&lt;br/&gt;  Object backup = replay(captured);&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 线程方法调用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; callable.call();&lt;br/&gt;  } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 使用副本进行恢复。&lt;/span&gt;&lt;br/&gt;    restore(backup);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这基本上线程池方式传递本地变量的核心代码已经大概看完了。总的来说在创建&lt;code&gt;TtlCallable&lt;/code&gt;对象是，调用&lt;code&gt;capture()&lt;/code&gt;方法捕获调用方的本地线程变量，在&lt;code&gt;call()&lt;/code&gt;执行时，将捕获到的线程变量，替换到线程池所对应获取到的线程的本地变量中，并且在执行完成之后，将其本地变量恢复到调用之前。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述列举了4种方案，陈某这里推荐方案2和方案4，其中两种方案的缺点非常明显，实际开发中也是采用的方案2或者方案4&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f65bf66dc63c6820bd902203a5d205ef</guid>
<title>分布式系统关键路径延迟分析实践</title>
<link>https://toutiao.io/k/tj2iqn1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;span&gt;作者 | 月色如海&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;导读 &lt;/section&gt;&lt;section&gt;&lt;span&gt;introduction&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随着对用户体验的不断追求，延迟分析成为大型分布式系统中不可或缺的一环。本文介绍了目前在线服务中常用的延迟分析方法，重点讲解了关键路径分析的原理和技术实现方案，实践表明此方案效果显著，在耗时优化方面发挥了重要作用，希望这些内容能够对有兴趣的读者产生启发，并有所帮助。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;全文4528字，预计阅读时间12分钟。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;GEEK TALK&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;strong/&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;近年来，互联网服务的响应延迟(latency)对用户体验的影响愈发重要，然而当前对于服务接口的延迟分析却没有很好的手段。特别是互联网业务迭代速度快，功能更新周期短，必须在最短的时间内定位到延迟瓶颈。然而，服务端一般都由分布式系统构成，内部存在着复杂的调度和并发调用关系，传统的延迟分析方法效率低下，难以满足当下互联网服务的延迟分析需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关键路径分析(Critical Path Tracing)作为近年来崛起的延迟分析方法，受到Google，Meta，Uber等公司的青睐，并在在线服务中获得了广泛应用。百度App推荐服务作为亿级用户量的大型分布式服务，也成功落地应用关键路径延迟分析平台，在优化产品延迟、保障用户体验方面发挥了重要的作用。本文介绍面向在线服务常用的延迟分析方法，并详细介绍关键路径分析的技术实现和平台化方案，最后结合实际案例，说明如何在百度App推荐服务中收获实际业务收益。&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;GEEK TALK&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;常用分布式系统延迟分析方法&lt;/strong&gt;&lt;strong/&gt;&lt;strong/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;当前业界常用的服务延迟分析有RPC监控(RPC telemetry)，CPU剖析(CPU Profiling)，分布式追踪(Distributed Tracing)，下面以一个具体的系统结构进行举例说明：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4694656488549618&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;524&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9ySItcFQFzLnc5F5ZOaQkGE0T4bNayqd8cqJXdWF0jIhWgWrOALHQcNzOibDwqgpGlgfNlb2455vQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;△图1 系统结构示例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;A、B、C、D、E分别为五个系统服务，A1到A4、B1到B5分别为A、B系统内的子组件(可以理解为A、B系统内部进一步的细化组成部分)，箭头标识服务或组件之间的调用关系。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.1 &lt;/strong&gt;&lt;strong&gt;RPC监控&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;RPC是目前微服务系统之间常用的调用方式，业界主要开源的RPC框架有BRPC、GRPC、Thrift等。这些RPC框架通常都集成了统计打印功能，打印的信息中含有特定的名称和对应的耗时信息，外部的监控系统（例如：Prometheus）会进行采集，并通过仪表盘进行展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;130&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.225&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9ySItcFQFzLnc5F5ZOaQkGXw7gcjGuSLk9sfz4DKIVicZDYBMl8Kesrj7ESLibWsiaMJrtP9H3awh4A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;△图2 RPC耗时监控UI实例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;此分析方式比较简单直接，如果服务之间的调用关系比较简单，则此方式是有效的，如果系统复杂，则基于RPC分析结果进行的优化往往不会有预期的效果。如图1，A调用B，A2和A3是并行调用，A3内部进行复杂的CPU计算任务，如果A2的耗时高于A3，则分析A-&amp;gt;B的RPC延时是有意义的，如果A3高于A2,则减少A-&amp;gt;B的服务调用时间对总体耗时没有任何影响。此外RPC分析无法检测系统内部的子组件，对整体延迟的分析具有很大的局限性。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.2 &lt;/strong&gt;&lt;strong&gt;CPU Profiling&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;CPU分析是将函数调用堆栈的样本收集和聚合，高频出现的函数认为是主要的延迟路径，下图是CPU火焰图的展示效果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;350&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.60625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9ySItcFQFzLnc5F5ZOaQkGHAnjrBFJlO7ePSK8Rqu6q0shksS71WGXFfOsKJVeDlVSazal3r2YOQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;△图3 cpu火焰图&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;水平的宽度表示抽样的次数，垂直方向表示调用的关系，火焰图通常是看顶层的哪个函数宽度最大，出现“平顶”表示该函数存在性能问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CPU Profiling可以解决上面说的RPC监控的不足，然而由于依然无法知晓并行的A2和A3谁的耗时高，因此按照RPC链路分析结果还是按照CPU分析的结果进行优化哪个真正有效果将变得不确定，最好的方式就是都进行优化，然而这在大型复杂的系统中成本将会变得很大。可见CPU Profiling同样具有一定的局限性。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.3 &lt;/strong&gt;&lt;strong&gt;分布式追踪&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;分布式追踪目前在各大公司都有了很好的实践(例如Google的Dapper，Uber的Jaeger)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;312&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.540625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9ySItcFQFzLnc5F5ZOaQkGVpwfsoS8m1y7ouNiaCZOjVt3ZOQJwdmdweiaQgDutPNGgoCV4Xvm42eg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;△图4 分布式追踪效果示例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;分布式追踪将要追踪的“节点”通过span标识，将spans按照特定方式构建成trace，效果如图4所示，从左到右表示时间线上的不同节点耗时，同一个起始点表示并发执行。这需要收集所有跨服务请求的信息，包括具体的时间点以及调用的父子关系，从而在外部还原系统调用的拓扑关系，包含每个服务工作的开始和结束时间，以及服务间是并行运行还是串行运行的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常，大多数分布式跟踪默认情况下包括RPC访问，没有服务内部子组件信息，这需要开发人员根据自身系统的结构进行补全，然而系统内部自身运行的组件数目有时过于庞大，甚者达到成百上千个，这就使得成本成为了分布式跟踪进行详细延迟分析的主要障碍，为了在成本和数据量之间进行权衡，往往会放弃细粒度的追踪组件，这就使得分析人员需要花费额外的精力去进一步分析延迟真正的“耗费点”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍关键路径分析的基本原理和实际的应用。&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;GEEK TALK&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;h2&gt;&lt;strong&gt;关键路径分析&lt;/strong&gt;&lt;strong/&gt;&lt;strong/&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.1 介绍&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;关键路径在服务内部定义为一条耗时最长的路径，如果将上面的子组件抽象成不同的节点，则关键路径是由一组节点组成，这部分节点是&lt;strong&gt;分布式系统中请求处理速度最慢的有序集合&lt;/strong&gt;。一个系统中可能有成百上千个子组件，但是关键路径可能只有数十个节点，这样数量级式的缩小使得成本大大降低。我们在上图的基础上加上各个子模块的耗时信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.6212765957446809&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;470&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9ySItcFQFzLnc5F5ZOaQkGhXnXabZFPq2D4bjvx5kIf8JcnVh3dg7BFBx3Suon7uCR1jGgEkhB9g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;△图5 加上耗时信息的示例系统结构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如图5所示，在B中B1并行调用B3、B4、B5，延迟分别为100,150,120，然后再调用内部的B2，进行返回，关键路径为B&lt;strong&gt;1-&amp;gt;B4-&amp;gt;B2&lt;/strong&gt;，延迟为10 + 150 + 10 = 170，在A中A1并行调用A2，A3。A2和A3都完成后再调用A4，然后返回，关键路径为&lt;strong&gt;A1-&amp;gt;A2-&amp;gt;A4&lt;/strong&gt;，延迟为15 + 170 + 10 = 195 ，因此这个系统的关键路径为红色线条的路径&lt;strong&gt;A1-&amp;gt;A2-&amp;gt;B1-&amp;gt;B4-&amp;gt;B2-&amp;gt;A4&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过这个简单的分布式系统结构表述出关键路径，其描述了分布式系统中请求处理速度最慢步骤的有序列表。可见优化关键路径上的节点肯定能达到降低整体耗时的目的。实际系统中的关键路径远比以上描述的复杂的多，下面进一步介绍关键路径分析的技术实现和平台化方案。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2 &lt;/strong&gt;&lt;strong&gt;实际应用解决方案&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;关键路径数据的采集到可视化分析的流程如图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;196&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3397212543554007&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9ySItcFQFzLnc5F5ZOaQkGEdXuHS8nVmuOcTYGyxoAF3km56rcW4aGYfCmd2m6xdU0nBpwcLnI3w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;△图6 数据处理流程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h4 data-morpho-type=&quot;heading&quot; data-uuid=&quot;41fcb150-79e3-11ed-88b2-cf4429771cd0&quot; data-slate-node=&quot;element&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2.1 核心关键路径的产出和上报&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;关键路径由服务自身进行产出，一般大型分布式服务都会采用算子化执行框架，只要集成到框架内部，所有依赖的服务都可以统一产出关键路径。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于算子化执行框架，考虑到如下简单的图结构：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;169&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2921875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9ySItcFQFzLnc5F5ZOaQkG7xgLqtBT2Wrt2ak64ZickRg8FpgoNB3VtzYHBRZiczwBqYTXSiciaDl52g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;△图7 一种简单的图结构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;P1-P4是4个策略算子，按照图示调度执行。采集SDK收集每个算子开始和结束的运行时刻，汇总为关键路径基础数据上报。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-morpho-type=&quot;heading&quot; data-uuid=&quot;48643fe0-79e3-11ed-88b2-cf4429771cd0&quot; data-slate-node=&quot;element&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.2 核心关键路径的汇聚和计算&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;一个服务内部的关键路径往往反映不了整个分布式系统延时的常态情况，这就需要将不同服务内部关键进行汇聚。这里的汇聚是按照时间段进行汇聚，这就需要collector收到数据后按照上传携带过来的时间点分到对应时间的窗口内，收集完成后进行各种延时指标的计算以及关键路径的汇聚，这里有三种汇聚方式:&lt;/span&gt;&lt;/p&gt;&lt;h5 data-morpho-type=&quot;heading&quot; data-uuid=&quot;df6b4540-79ee-11ed-88b2-cf4429771cd0&quot; data-slate-node=&quot;element&quot;&gt;&lt;strong&gt;&lt;span&gt;1、节点关键路径汇聚&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;这里是将系统的关键路径拼接到一起，组成一条完整路径，将各个节点进行汇聚，选择出现次数最多的路径作为最“核心”的关键路径。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-morpho-type=&quot;heading&quot; data-uuid=&quot;52c06130-79e3-11ed-88b2-cf4429771cd0&quot; data-slate-node=&quot;element&quot;&gt;&lt;strong&gt;&lt;span&gt;2、服务关键路径汇聚&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;节点关键路径是节点粒度的表示形态，然而在一个系统中服务的路径关系是怎样的呢？这就需要服务关键路径来表示。为了更好的表征服务内部的耗时情况，对节点进行聚合抽象。将所有计算型节点统一归为一个叫inner的节点，作为起始节点，其他访问外部服务的节点不变，在重新转换后的路径中选择出现次数最多的路径作为服务关键路径，聚合后的路径可以标识服务“自身”和“外部”的延时分布情况。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-morpho-type=&quot;heading&quot; data-uuid=&quot;55f48a20-79e3-11ed-88b2-cf4429771cd0&quot; data-slate-node=&quot;element&quot;&gt;&lt;span&gt;&lt;strong&gt;3、平铺节点类型汇聚&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;这部分主要是对于核心路径比较分散的子节点，例如B中B1访问B3/B4/B5等多个下游（在实际的系统中可能有数十个节点出现在关键路径中，但是没有一个节点有绝对的核心占比，各个节点在关键路径中相对比较分散，且经常周期性改变）,对这种情况直接统计并筛选出核心占比&amp;gt;x%（x%根据特定需求进行确定，x越小则收集到的关键节点越精细）的节点，需要注意的是这里是平铺取的节点，并不是一条“核心”的关键路径。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-morpho-type=&quot;heading&quot; data-uuid=&quot;5ae975e0-79e3-11ed-88b2-cf4429771cd0&quot; data-slate-node=&quot;element&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2.3 核心关键路径的存储和展示&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;数据库存储的是计算好的结果，以时间、用户类型、流量来源等作为查询关键字，方便进行多维度分析。这里使用OLAP Engine进行存储，方便数据分析和查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;展示的内容主要有以下几部分：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;核心占比：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;节点出现在关键路径中的概率&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;核心贡献度：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;节点出现在关键路径中时，自身耗时占整个路径总耗时的比例&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;综合贡献度：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;核心占比和核心贡献度两者相乘，作为综合衡量的标准&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;均值：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;节点耗时的平均值&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分位值：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;节点耗时的不同分位值。分位值是统计学中的概念，即把所有的数值从小到大排序，取前N%位置的值即为该分位的值，常用的有50分位、80分位、90分位等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;核心占比高贡献度很低或者贡献度高占比很低的节点优化的效果往往不是很显著，因此使用综合贡献度做为核心占比和核心贡献度的综合考量，这个指标高的节点是我们需要重点关注的，也是优化收益较大的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从耗时优化的角度出发，这里有两个主要的诉求，一个是查询某个时间段的关键路径，依此来指导进行特定节点或阶段的优化。另一个是需要进行关键路径的对比，找到diff的节点，挖掘具体的原因来进行优化，整体延时的退化往往是由于特定节点的恶化造成的，这里的对比可以是不同时间、不同地域、甚至是不同流量成分的对比，这样为延迟分析提供了多维度的指导依据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关键路径的效果如图8所示，在页面上可以按照特定维度进行排序，便于进一步的筛选。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;73&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.1265625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9ySItcFQFzLnc5F5ZOaQkG1R0K7YOMRBIzo5oVPJldwy766VadzZ52RQnQHLLNPZfibupKLIzXyLg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;△图8 核心关键路径示例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;GEEK TALK&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;h4 data-morpho-type=&quot;heading&quot; data-uuid=&quot;6b75b570-7abc-11ed-891c-97ae1bac19b2&quot; data-slate-node=&quot;element&quot;&gt;&lt;strong&gt;应用&lt;br/&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;strong/&gt;&lt;strong/&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;百度App推荐系统内部建设了关键路径延迟分析平台Focus，已上线1年多，成功支持了日常的耗时分析和优化工作，保证了百度App Feed流推荐接口的毫秒级响应速度，提供用户顺滑的反馈体验。获得研发，运维和算法团队的一致好评。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以推荐服务的一个实际线上问题举例，某天监控系统发现系统出口耗时突破监控阈值，关键路径延迟分析平台自动通过服务关键路径定位到是某个服务B出了问题，然后通过观察服务B的节点关键路径发现是节点X有问题，然而节点X下游请求的是多个下游，这时通过平铺节点类型发现平时耗时比较低的队列Y延时突增，核心占比和贡献度都异常高，通知下游负责的owner进行定位，发现确实是服务本身异常，整个定位过程全自动化，无需人工按个模块排查。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;371&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.642369020501139&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9ySItcFQFzLnc5F5ZOaQkGaBRErOnicBx9cqPw4LeGQicyg5nc31nkuYCYQdFHnjHLibSLst4G0uP1A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;878&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;△图9 系统延迟异常后的自动定位分析过程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;GEEK TALK&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;05&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;h4 data-morpho-type=&quot;heading&quot; data-uuid=&quot;ac0ec490-7abd-11ed-891c-97ae1bac19b2&quot; data-slate-node=&quot;element&quot;&gt;&lt;strong&gt;总结&lt;br/&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在当下大型分布式系统中，服务接口的低响应延迟是保证用户体验的重要关键。各大公司也纷纷投入大量精力来优化延时，然而复杂的系统结构使得优化难度较大，这就需要借助创新的优化方法。本文通过具体的例子介绍了关键路径分析的原理，在百度App推荐系统中实际应用落地的平台化方案，最后分享了实际案例。延迟耗时分析方向还有很多新的发展方向和创新空间，也欢迎对该方向感兴趣的业界同仁一起探讨。&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文由高可用架构转载。技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzAwMDU1MTE1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONl06YmHad4csRU93kcbJ76JIWzEAmOSVooibFHHkzfWzzkc7dpU4H06Wp9F6Z687vIghdawxvl47A/0?wx_fmt=png&quot; data-nickname=&quot;高可用架构&quot; data-alias=&quot;ArchNotes&quot; data-signature=&quot;高可用架构公众号。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;       &lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>