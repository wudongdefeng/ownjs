<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>439d191b0f2b207cf79e985d5458f4ce</guid>
<title>什么是真正的程序员？| 码农周刊第 323 期</title>
<link>https://toutiao.io/k/v08ikpz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;什么是真正的程序员？| 码农周刊第 323 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第323期（2020-10-28）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3230&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3230&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;适合入门&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;该框架由阿里云机器学习 PAI 团队研发，让自然语言处理场景的模型预训练和迁移学习开发与部署更加简单和高效。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;硬核&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;论文笔记&lt;/p&gt;
        
        &lt;p&gt;系列文章&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;因子分解机算法&lt;/p&gt;
        
        &lt;p&gt;深入讲解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;Yahoo 开源的 Kafka 集群管理平台&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;更多可能&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;源码分析&lt;/p&gt;
        
        &lt;p&gt;一个 Android Jetpack 扩展库&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;倾向于使用 Less 或 Stylus&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;这里有最接地气的架构师一线实战经验、核心技能的分享。运营和产品的总结。以及一些个人的深度思考。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 268968 即可&lt;/p&gt;
        
        &lt;p&gt;GO PHP JS 一网打尽&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 146415 即可&lt;/p&gt;
        
        &lt;p&gt;分享技术，专注程序员成长&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 137785 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;Coding虽易，debug不易....&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 98777 即可&lt;/p&gt;
        
        &lt;p&gt;专注分享Java实战技术、Java基础原理、微服务实战技术、分布式系统架构&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 22887 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书为对基本概率论感兴趣的读者以及之前未接触过此方向的人提供了一个坚实的基础。通过对话的方式和详细的数学推导，在迷人的风格和信息丰富的讨论上取得了平衡。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;真实&lt;/p&gt;
        
        &lt;p&gt;值得思考&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>543dddb1fc9500e836849f412c711271</guid>
<title>技术选型：为什么批处理我们却选择了 Flink</title>
<link>https://toutiao.io/k/0n78gha</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;最近接手了一个改造多平台日志服务的需求，经过梳理，我认为之前服务在设计上存在缺陷。经过一段时间的技术方案调研，最终我们决定选择使用 Flink 重构该服务。&lt;/p&gt;&lt;p&gt;目前重构后的服务已成功经受了国庆节流量洪峰的考验，今日特来总结回顾，和大家分享一下经验。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;业务需求及背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在了解改造服务的需求前，我们首先要明确，要解决什么问题以及目前的服务是如何解决的。&lt;/p&gt;&lt;p&gt;当前的业务逻辑还是比较清晰的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;采集同一时段不同数据源的日志；&lt;/li&gt;&lt;li&gt;对采集的数据进行处理；&lt;/li&gt;&lt;li&gt;将处理后的数据上传到指定位置，供客户下载。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们面临的痛点和难点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;日志的数据量比较大：每小时未压缩的日志数据量有 50 多个 G，节假日等特殊时间节点，日志量会翻倍。&lt;/li&gt;&lt;li&gt;目前服务使用单机进行处理，速度比较慢，扩容不方便。&lt;/li&gt;&lt;li&gt;目前服务处理数据时需要清洗字段，按时间排序，统计某字段的频率等步骤。这些步骤都属于 ETL 中的常规操作，但是目前是以代码的形式实现的，我们想以配置形式减少重复编码，尽量更加简单、通用。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;方案1：我们需要一个数据库吗?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;针对以上业务需求，有同学提出：“我们可以把所有原始数据放到数据库中，后续的 ETL 可以通过 SQL 实现。”&lt;/p&gt;&lt;p&gt;如果你一听到&quot;数据库&quot;想到的就是 Pg、Mysql、Oracle 等，觉得这个方案不具有可行性，那你就错了。数据库的类型和维度是非常丰富的，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2046f993e1c0a87adb39d2d697e87749_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;811&quot; data-rawheight=&quot;618&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-2046f993e1c0a87adb39d2d697e87749_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;811&quot; data-rawheight=&quot;618&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-2046f993e1c0a87adb39d2d697e87749_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2046f993e1c0a87adb39d2d697e87749_b.jpg&quot;/&gt;&lt;figcaption&gt;△数据库行业全景图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;按业务负载特征，关系型数据库可分为 OLTP 数据库（交易型）和 OLAP 数据库（分析型) ：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;OLTP，Online Transaction Processing。OLTP 数据库最大的特点是支持事务，增删查改等功能强大，适合需要被频繁修改的&quot;热数据&quot;。我们耳熟能详的 Mysql、Pg 等都属于这一类。缺点就是由于支持事务，插入时比较慢。拿来实现我们的需求显然是不合适的。&lt;/li&gt;&lt;li&gt;OLAP，Online Analytical Processing，数据分析为主。不支持事务，或者说是对事务的支持有限。OLAP 的场景是：大多数是读请求，数据总是以相当大的批(&amp;gt; 1000 rows)进行写入，不修改已添加的数据。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;方案 1 小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;OLAP 的使用场景符合我们的需求，为此我们还专门去调研了一下 ClickHouse。但是有一个因素让我们最终放弃了使用 OLAP。请注意，数据库存储的数据都是二维的，有行和列两个维度。但是日志只有行一个维度。如果说为了把日志存入数据库把每行日志都切分，那统计字段的需求也就顺手实现了，又何必存到数据呢?&lt;/p&gt;&lt;p&gt;所以，OLAP 使用场景隐含的一个特点是：存入的数据需要被多维度反复分析的。这样才有把数据存入数据库的动力，像我们当前的需求对日志进行简单的变形后仍旧以文本日志的形式输出，使用 OLAP 是不合适的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;方案2：Hive 为什么不行?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;看到这，熟悉大数据的同学可能会觉得我们水平很 Low，因为业务需求归根到底就是三个字：批处理。 &lt;/p&gt;&lt;p&gt;那我们为什么第一时间没有考虑上大数据呢？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b2359f08971047d09d069c415a66dab9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;740&quot; data-rawheight=&quot;417&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-b2359f08971047d09d069c415a66dab9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;740&quot; data-rawheight=&quot;417&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-b2359f08971047d09d069c415a66dab9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b2359f08971047d09d069c415a66dab9_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 大数据处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;大数据确实如雷贯耳，但现在我们的日志处理这块大部分都是用 Golang 实现的，团队内的其他业务用了 Python、Lua、C，就是没有用过到 Java。而目前大数据都是基于 JVM 开发的。Golang 调用这些服务没有一个好用的客户端。&lt;/p&gt;&lt;p&gt;所以基于团队目前的技术储备，大数据才没有成为我们的首选。但是从目前的状况来看大数据是最优解了。那么我们该选用大数据的什么组件实现需求呢?&lt;/p&gt;&lt;p&gt;放弃使用数据库直接使用 HDFS 存储日志文件，应该是毋庸置疑的。&lt;/p&gt;&lt;p&gt;我们需求是离线批处理数据，对时效性没有要求，MapReduce 和 Hive 都能满足需求。但是 MapReduce 与 Hive 相比，Hive 在 MapReduce 上做了一层封装并且支持 SQL。看起来 Hive 是非常合适的。&lt;/p&gt;&lt;p&gt;那为什么最终放弃了 Hive 呢?&lt;/p&gt;&lt;ul&gt;&lt;li&gt;机器资源问题。公司其他团队已经有一套 HDFS 的设施，只用来做存储，Hadoop 的 MapReduce 这个组件根本没跑起来。那套 HDFS 部署的机器资源比较紧张，他们担心我们使用 MapReduce 和 Hive 跑计算，会影响现在 HDFS 的性能; 我们想审批一批新的机器，重新使用 Ambari 搭建一套 Hadoop，却被告知没那么多闲置的机器资源。而且我们即便申请下来了机器，只跑目前服务也跑不满，机器资源大部分也会被闲置，也有浪费资源的嫌疑。&lt;/li&gt;&lt;li&gt;存储分离是趋势。在调研中我们发现，像 Hadoop 这样把存储和计算放到一起的已经比较&quot;落伍&quot;了。Hadoop 存储分离，需要修改源码，目前没有开源实现，只是云厂商和各个大数据公司有相关商业产品。从这个角度讲，即便我们自己搞定了机器资源搭一套 Hadoop，也只不过是拾人牙慧罢了。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4a36a4acf61b6fb5522c4202e55e7735_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;504&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-4a36a4acf61b6fb5522c4202e55e7735_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;504&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-4a36a4acf61b6fb5522c4202e55e7735_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4a36a4acf61b6fb5522c4202e55e7735_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 大数据生态图，图片来源于小枣君&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;方案 2 小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;再合适的技术方案不能落地也是空谈。但是技术方案想要落地时，已经不是一个单纯的技术问题了，资源限制，团队限制等都需要考虑在内。&lt;/p&gt;&lt;p&gt;一个优秀的技术方案立足于解决当下的问题，并且能放眼未来勾画蓝图，这样大家觉得 &quot;有利可图&quot;，才愿意跟你一起折腾。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;方案3：为什么我们放弃了 Spark?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;通用的计算引擎&lt;/b&gt;&lt;/p&gt;&lt;p&gt;虽然使用 HDFS 的团队不赞成在他们的机器上跑 Hive，但是我们把日志数据存到他们的 HDFS 上还是没问题的。在已知 &quot;存储和分离是趋势&quot; 是前提的基础下，&quot;我们到底需要什么&quot; 这个问题已经有答案了。&lt;/p&gt;&lt;p&gt;我们需要的是一个通用的计算引擎。存储已经剥离给 HDFS 了，所以我们只需要找一个工具，帮我们处理 ETL 就可以了。Spark 和 Flink 正是这样的场景。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Spark 与 Flink 初次交锋&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Spark 和 Flink 之间，我们毫不犹豫地选择了 Spark。原因非常简单：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Spark 适合批处理。Spark 当初的设计目标就是用来替换 MapReduce。而 Spark 流处理的能力是后来加上去的。所以用 Spark 进行批处理，可谓得心应手。&lt;/li&gt;&lt;li&gt;Spark 成熟度高。Spark 目前已经发布到 3.0，而 Flink 尚在 Flink 1.x 阶段。Flink 向来以流处理闻名，虽然被国内某云收购后开始鼓吹 &quot;流批一体&quot;，但是线上效果还是有待检验的。&lt;/li&gt;&lt;li&gt;Scala 的加持。Spark 大部分是用 Scala 实现的。Scala 是一门多范式的编程语言，并且与 Haskell 有很深的渊源。Haskell 是一门大名鼎鼎的函数式编程语言。对于函数式编程语言，想必大多数程序猿都有一种 &quot;虽不能至，然心向往之&quot; 的情结。现在使用 Spark 能捎带着耍一耍函数式编程语言 Scala，岂不妙哉？&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cab5f3da76c389c723b5cdfbcfc32b77_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;753&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-cab5f3da76c389c723b5cdfbcfc32b77_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;753&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-cab5f3da76c389c723b5cdfbcfc32b77_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-cab5f3da76c389c723b5cdfbcfc32b77_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Scala&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;挥泪斩 Spark&lt;/b&gt;&lt;/p&gt;&lt;p&gt;前文已经交代过了，我们否决掉 Hive 的一个重要因素是没有足够的机器资源。所以我们把 Spark 直接部署到云平台上。&lt;/p&gt;&lt;p&gt;对于我司的云平台要补充一些细节。&lt;/p&gt;&lt;p&gt;我们的云平台是基于 K8S 二次开发的，目前还在迭代当中，因此&quot;Spark on K8S&quot; 的运行模式我们暂时用不了。在这样的情况下，我们采用了 &quot;Spark Standalone&quot; 的模式。Standalone 模式，也就是Master Slaver 模式，类似于 Nginx 那样的架构，Master 节点负责接收分发任务，Slaver 节点负责&quot;干活&quot;。&lt;/p&gt;&lt;p&gt;等到我们在云平台上以 &quot;Spark Standalone&quot; 模式部署好了，跑了几个测试 Case 发现了新问题。我们的云平台与办公网络是隔离的，如果办公网络想访问云平台的某个 Docker 容器，需要配置域名。而 Spark 的管理页面上很多 URL 的 domain 是所在机器的 IP，容器的 IP 是虚拟 IP，容器重启后IP 就会改变。具体如图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-814f1110cacc77ebd8cff4ebee4be9fd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;301&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-814f1110cacc77ebd8cff4ebee4be9fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;301&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-814f1110cacc77ebd8cff4ebee4be9fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-814f1110cacc77ebd8cff4ebee4be9fd_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 部署在云平台的 spark&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Spark 的管理平台非常重要，因为能从这上面看到当前各个节点运行情况，任务的异常信息等，现在很多链接不能访问，不利于我们对 Spark 任务进行问题排查和调优。基于这个原因，我们最终放弃了 Spark。&lt;/p&gt;&lt;p&gt;&lt;b&gt;方案 3 小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Spark 你真的很优秀，擅长批处理，如此成熟，还有函数式的基因 。。。这些优点早让我倾心不已。&lt;/p&gt;&lt;p&gt;Spark 你真的是个好人，如果不是云平台的限制，我一定选择你。&lt;/p&gt;&lt;p&gt;Spark，对不起。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;方案4：Flink，真香！&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;给 Spark 发完好人卡后，我们看一看新欢 Flink。不客气的说，Flink 初期时很多实现都是抄的 Spark，所以二者的很多概念相似。所以 Flink 同样有 Standalone 模式，我们在部署阶段没遇到任何问题。&lt;/p&gt;&lt;p&gt;在跑了几个 Flink 测试 Case 后，我们由衷的感叹 Flink 真香。&lt;/p&gt;&lt;p&gt;放弃 Spark 时我们的痛点在于 &quot;部署在云平台上的 Spark 服务的管理界面很多功能无法使用&quot;，而 Flink 的管理平台完全没有这个问题。除此之外，Flink 管理平台的 &quot;颜值&quot; 和功能都是 Spark 无法比拟的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;管理平台颜值对比&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-81f492437b2251f815d5ecc50871e4c5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;155&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-81f492437b2251f815d5ecc50871e4c5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;155&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-81f492437b2251f815d5ecc50871e4c5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-81f492437b2251f815d5ecc50871e4c5_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Spark管理平台页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5c6ba1581fc95f0f3415440f80d516d0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;487&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5c6ba1581fc95f0f3415440f80d516d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;487&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5c6ba1581fc95f0f3415440f80d516d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5c6ba1581fc95f0f3415440f80d516d0_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Flink管理平台页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;对比之下，Spark 的页面完全是个&quot;黄脸婆&quot;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Flink 管理平台功能&lt;/b&gt;&lt;/p&gt;&lt;p&gt;由于 Spark 的功能很多不能使用，所以就不重点和 Flink 做比较了。这里只说 Flink 几个让人眼前一亮的功能。&lt;/p&gt;&lt;p&gt;部署了 Flink 或 Spark 服务后，该如何下发计算任务呢? 一般是通过 bin 目录下的一个名称中包含 submit 的可执行程序。那如果想把 Flink 或 Spark 做成微服务，通过 http 接口去下发任务呢?&lt;/p&gt;&lt;p&gt;Spark1.0 的时候支持 http，2.0时这个功能基本上废掉了，很多参数不支持了，把 http 这个功能交由 jobService 一个第三方开源组件去实现。这个 jobService 的开源组件对云平台的支持也非常不友好。所以在我们看来，Spark 通过 Http 下发任务的路子基本被堵死了。&lt;/p&gt;&lt;p&gt;反观 Flink，管理平台的接口是 Restful 的，不仅支持 Http 下发计算任务，还可以通过相关接口查看任务状态和获取异常或返回值。&lt;/p&gt;&lt;p&gt;Flink 的任务分为几个不同的阶段，每个不同的阶段有不同的颜色。这样仅从颜色就可以判断出当前 Flink 任务执行的大致情况。如下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4b93584c342c4241557a8a73b9236757_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;232&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-4b93584c342c4241557a8a73b9236757_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;232&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-4b93584c342c4241557a8a73b9236757_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4b93584c342c4241557a8a73b9236757_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Flink管理平台页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在任务详情页面，会有任务分解图和任务执行耗时表格，这两个结合起来能够知道当然 Flink 任务是如何分解的，是否出现数据倾斜的情况，哪个步骤耗时最多，是否有优化的空间。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5fbdbc218db74ca27303a7c0de607018_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;390&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5fbdbc218db74ca27303a7c0de607018_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;390&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5fbdbc218db74ca27303a7c0de607018_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5fbdbc218db74ca27303a7c0de607018_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-82e9fa77f69d496a517d722ebba0de46_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;510&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-82e9fa77f69d496a517d722ebba0de46_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;510&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-82e9fa77f69d496a517d722ebba0de46_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-82e9fa77f69d496a517d722ebba0de46_b.jpg&quot;/&gt;&lt;figcaption&gt; △ 管理平台页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这就是做批处理技术选型时候的心路历程，随笔记了下来，希望对大家有所帮助。&lt;/p&gt;&lt;p&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/583/%25E5%25A6%2582%25E4%25BD%2595%25E9%2580%2589%25E6%258B%25A9%25E9%2580%2582%25E5%2590%2588%25E8%2587%25AA%25E5%25B7%25B1%25E7%25BD%2591%25E7%25AB%2599%25E7%259A%2584%25E9%2598%25B2%25E7%259B%2597%25E9%2593%25BE.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-56c5b7b098e6252cc7acb7a601428c09_180x120.jpg&quot; data-image-width=&quot;960&quot; data-image-height=&quot;640&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;如何选择适合自己网站的防盗链&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic2.zhimg.com/v2-56c5b7b098e6252cc7acb7a601428c09_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/577/HTTP%252F3%2520%25E6%259D%25A5%25E4%25BA%2586%25EF%25BC%258C%25E4%25BD%25A0%25E4%25BA%2586%25E8%25A7%25A3%25E5%25AE%2583%25E4%25B9%2588%25EF%25BC%259F.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-cddf6e4c200fe6cc94c4b8edfdae7521_180x120.jpg&quot; data-image-width=&quot;1080&quot; data-image-height=&quot;523&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;HTTP/3 来了，你了解它么？&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic2.zhimg.com/v2-cddf6e4c200fe6cc94c4b8edfdae7521_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>15f33ee5cac979e5809118dd15bd8771</guid>
<title>解绑 WebRTC：开启 WebRTC 终结篇？</title>
<link>https://toutiao.io/k/splcfvg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;elementor-widget-container&quot;&gt;

&lt;p&gt;WebRTC在2020年逐渐开始解绑。随着差异化时代到来，这样的新举措似乎预示着WebRTC的终结。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://bloggeek.me/wp-content/uploads/2020/08/202008-webrtc-unbundling.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;WebRTC丰富了我们的生活。曾几何时，它是能在浏览器运行实时媒体的唯一方法。之后，其他同类服务层出不穷，但都没有正式发布。&lt;/p&gt;



&lt;p&gt;现在，是WebRTC 1.0正式发行的时候了。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;走向差异化&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;要用图表解释WebRTC的发展之路的话，看起来是这样子的：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://bloggeek.me/wp-content/uploads/2020/08/202008-webrtc-stages.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;2020年开启了WebRTC差异化阶段&lt;/p&gt;



&lt;p&gt;从2019年底，到最近疫情期间的大趋势，我们已经能预测WebRTC的未来走向——成败在于能否做到差异化。&lt;/p&gt;



&lt;p&gt;截至目前，所有供应商都可以访问由Google（和另一个浏览器供应商）实现的同一个WebRTC堆栈，其在浏览器中的功能完全相同。&lt;/p&gt;



&lt;p&gt;这远远不够。&lt;/p&gt;



&lt;p&gt;我在之前的&lt;a href=&quot;https://bloggeek.me/googles-private-webrtc-roadmap-2020/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;这篇文章&lt;/a&gt;中提到了这一点。从那时起，Google进行了很多尝试，都表明差异化是其之后的大方向。&lt;/p&gt;



&lt;p&gt;目前市面上有2个WebRTC堆栈，一个可供所有人使用，另一个供Google内部，在本地应用程序里使用。尽管我们都可以这样做，但现在Google正在加足马力发展这一项。&lt;/p&gt;



&lt;p&gt;有趣的是谷歌并不自己来做这件事，而是解绑了WebRTC。这样，Google（和其他公司）就不需要去维护两个单独的堆栈，在WebRTC的基础上实现自己的“差异化”。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;解绑WebRTC&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;你可能感到很迷惑。所以在继续往下读之前，我建议你先看看web.dev第二天直播的最后15分钟：&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;https://youtu.be/r3QPKK0JPtI&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;https://youtu.be/r3QPKK0JPtI&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;Google展示了Chrome取得的进展及其未来前景。&lt;/p&gt;



&lt;p&gt;本次会议的整个框架不尽如人意。 Google在考虑如何能解决Zoom的问题。其实大部分行家都知道答案，那就是在浏览器中使用WebRTC。&lt;/p&gt;



&lt;p&gt;这里提出的解决方案是把WebRTC分解为3个独立的组件：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://bloggeek.me/wp-content/uploads/2020/08/202008-webrtc-unbundling-technologies.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;组件会解绑WebRTC&lt;/p&gt;



&lt;p&gt;1. WebTransport：允许在客户端和“ 网络服务器”（本文特指媒体服务器）之间发送双向低延迟类UDP流量&lt;/p&gt;



&lt;p&gt;2. WebCodecs：使浏览器能够独立于WebRTC编码和解码音视频&lt;/p&gt;



&lt;p&gt;3. &lt;a href=&quot;https://bloggeek.me/webassembly-in-webrtc/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;WebAssembly &lt;/a&gt;：用于运行代码的浏览器加速器和用于机器学习的启动器&lt;/p&gt;



&lt;p&gt;尽管这些都可以用于新的开发用例（例如Google Stadia，实现起来更简单），但它们也可以用于实现类似于WebRTC的功能（不具有端对端功能）。&lt;/p&gt;



&lt;p&gt;WebTransport替代了&lt;a href=&quot;https://webrtcglossary.com/srtp/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;SRTP&lt;/a&gt;。WebCodecs负责编码/解码。WebAssembly负责所有区分工作和一些繁重的工作（诸如带宽估算之类的事情）。但我并不确定回音消除和其他音频算法的去向如何，可能会放在WebCodecs内部，或者使用WebAssembly实现。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;WebRTC&lt;/strong&gt;&lt;strong&gt;解绑后会发生什么？&lt;/strong&gt;&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://bloggeek.me/wp-content/uploads/2020/08/202008-fortune-cookie.jpg&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这不仅仅是个想法，而已经发生在Google和标准化组织内部了。今天的讨论是关于启用新的用例，但是更重要的是讨论这对WebRTC的未来意味着什么。&lt;/p&gt;



&lt;p&gt;解绑WebRTC后，我们还需要它吗？&lt;/p&gt;



&lt;p&gt;比如Google，他们已经开始朝着差异化方向发展，所以不难看出他们将如何在自己的应用中弃用WebRTC：&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;Google Stadia&lt;/strong&gt;&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://bloggeek.me/wp-content/uploads/2020/08/202008-google-stadia.jpg&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;Stadia是否还会使用WebRTC呢？&lt;/p&gt;



&lt;p&gt;Google Stadia服务于云游戏。它使用WebRTC是因为WebRTC是Google能提供的最接近且唯一的用于低延迟实时流向网络浏览器的解决方案。&lt;/p&gt;



&lt;p&gt;WebRTC能给Google Stadia什么？&lt;/p&gt;



&lt;p&gt;1. 在浏览器中实时解码视频的能力&lt;/p&gt;



&lt;p&gt;2. 低延迟将用户操作从远程控制发送回云&lt;/p&gt;



&lt;p&gt;这只是WebRTC的一小部分功能，而大材小用可能会妨碍Google进一步优化性能。&lt;/p&gt;



&lt;p&gt;基于&lt;a href=&quot;https://bloggeek.me/who-needs-quic-in-webrtc/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;QUIC&lt;/a&gt;而非&lt;a href=&quot;https://bloggeek.me/sctp-data-channel/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;SCTP&lt;/a&gt;，Stadia中已经实现了发回用户操作的功能。这是因为Google对QUIC的控制要比对SCTP的控制更有效。他们可能早就在用基于Stadia的QUIC WebTransport早期实现了。&lt;/p&gt;



&lt;p&gt;解码部分？同样，通过WebTransport会更容易操作并完成，这样就不用操心设置和维护WebRTC端对端连接的复杂性了。&lt;/p&gt;



&lt;p&gt;对于Stadia而言，解绑WebRTC，意味着从使用WebRTC到使用WebTransport + WebCodecs的组合。这是自然而然的选择。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;Google Duo和&lt;strong&gt;Google&lt;/strong&gt; Meet&lt;/strong&gt;&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://bloggeek.me/wp-content/uploads/2020/08/202008-google-meet.jpg&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;解绑WebRTC是否会提高Duo和Meet的竞争力呢？情况尚不明朗。&lt;/figcaption&gt;&lt;/figure&gt;



&lt;p&gt;两者都基于WebRTC建立，十分依赖它。且在疫情爆发期间他们都进行了优化，这样一来就更需要发挥WebRTC的作用了。&lt;/p&gt;



&lt;p&gt;但这足以适应当下需求吗？&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;WebRTC&lt;/strong&gt;&lt;strong&gt;的差异化&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;最近，为适应疫情期间激增的需求，谷歌在WebRTC内部，以及基于WebRTC添加了差异化层次和功能。一夜之间，视频应用变得炙手可热；Zoom应用普及度创新高，且最终上市。这使得谷歌高管注意到了这两种产品。&lt;/p&gt;



&lt;p&gt;同时这也加快了谷歌推出路线图、引入新功能的步伐，大多数更新都是为赶上Zoom，补全谷歌之前没有的功能。包括简单的性能优化、增强安全性（如谷歌 Duo的E2EE技术）以及机器学习等，具体来说就是：&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Duo本地应用中的专有丢包隐藏算法&lt;/li&gt;&lt;li&gt;Meet基于云的降噪功能&lt;/li&gt;&lt;li&gt;Meet即将上线的切换背景功能&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;…&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;Duo / Meet&lt;/strong&gt;&lt;strong&gt;解绑 WebRTC的好处&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;如果解绑，谷歌真的就能提高创新能力和运行速度吗？不使用WebRTC的话，那要使用WebTransport、WebCodecs和WebAssembly吗？这样究竟能带来什么好处？&lt;/p&gt;



&lt;p&gt;1. 某些功能的上市速度更快，无需与标准化组织就如何引入功能进行讨论（E2EE要求Insertable Streams引入WebRTC）；&lt;/p&gt;



&lt;p&gt;2. 谷歌 Meet主要基于服务器，WebRTC的P2P功能对其来说可有可无。解绑它会降低实现的复杂性；&lt;/p&gt;



&lt;p&gt;3. 可以以差异化方式给更多部分添加机器学习功能，不再开源。比如新&lt;a href=&quot;https://ai.googleblog.com/2020/04/improving-audio-quality-in-duo-with.html&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;WaveNetEQ丢包隐藏&lt;/a&gt;可以不用WebRTC，仅在本机应用程序中添加，理论上我们现在可以搭建该功能，无需维护两个单独的实现。&lt;/p&gt;



&lt;p&gt;如果我是谷歌高管，我会计划在未来3-5年内解绑WebRTC，迁移到这种新的方案。当然过程会很缓慢，但这样做确实是有道理的。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;谷歌是否可以/应该维护两个版本的WebRTC呢？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;如今，出于各种考量，谷歌同时维护两个不同的WebRTC版本。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://bloggeek.me/wp-content/uploads/2020/08/202008-libwebrtc-or-googwebrtc.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;首先是大众熟知，也乐意使用的第一个版本。该版本搭载于Chrome，在&lt;a href=&quot;https://webrtc.org/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;webrtc.org&lt;/a&gt;可见。&lt;/p&gt;



&lt;p&gt;其次是谷歌使用和推广的第二个版本，该版本使用机器学习，着力于发展差异化，WaveNetEQ就是从这里发展而来的。&lt;/p&gt;



&lt;p&gt;你觉得谷歌是会派工程师改进Chrome里WebRTC代码中的丢包隐藏算法，还是会派他们改善WaveNetEQ丢包隐藏算法？如果他们没这么多人手（他们确实没有），哪一种做法能满足其需求呢？&lt;/p&gt;



&lt;p&gt;在我看来，之后谷歌会大量减少对Chrome内部WebRTC的投资，重点转向基于WebAssembly，使用专有媒体引擎实现的WebTransport和WebCodecs。&lt;/p&gt;



&lt;p&gt;那么这种改变马上就会发生吗？并不是。&lt;/p&gt;



&lt;p&gt;你是否要担心这样的改变，早做准备呢？这要看情况，对大部分人来说，答案是肯定的。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;公平竞争即将结束，弱肉强食的世界即将到来&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;WebRTC开启了一个新世界。它提供了一个公平的竞争环境。让大家用相对较少的钱，就能使用实时语音和视频通信技术。它带领我们到达了今天的位置，但也只能到这儿了。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://bloggeek.me/wp-content/uploads/2020/08/202008-webrtc-survival.png&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;最近一系列变化标志着大环境由基于WebRTC的公平竞争，转向了弱肉强食。&lt;/figcaption&gt;&lt;/figure&gt;



&lt;p&gt;如果想维持现状，浏览器供应商需要进一步投资，提高WebRTC实现的质量并开源该操作。但问题就出在这里。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;苹果（Safari）&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;苹果并没有对WebRTC的实现进行任何投资。&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;苹果好像更关心HEVC的实现，不太在意其音频功能是否能在移动端搭载WebRTC的Safari正常运转；&lt;/li&gt;&lt;li&gt;现在苹果从谷歌获得了&lt;a href=&quot;https://bloggeek.me/how-to-pick-the-right-webrtc-mobile-sdk-build-for-your-application/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;libwebrtc&lt;/a&gt;实现，将其安装于Safari内部，从而对其的媒体管道进行了令牌调整；&lt;/li&gt;&lt;li&gt;从我个人来讲，苹果并没有用libwebrtc使用的媒体算法，对Safari WebRTC实现的质量进行任何具体的改进。&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;可以理解，毕竟苹果更重视FaceTime而不是WebRTC。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;火狐浏览器&lt;/strong&gt;&lt;strong&gt;（Mozilla&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;其实火狐这方面的实现做得不错。&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;火狐使用libwebrtc作为基础，同时用自己的组件替换了libwebrtc的组件；&lt;/li&gt;&lt;li&gt;替换的组件包括音频和视频的媒体捕获器和渲染器；&lt;/li&gt;&lt;li&gt;火狐投入了大量资金来发展自己的音频管道，&lt;/li&gt;&lt;/ul&gt;



&lt;ul&gt;&lt;li&gt;火狐投入了大量资金来发展自己的音频管道，这其实也影响到了WebRTC的质量。&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;&lt;strong&gt;微软（Edge）&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;微软最新发布的Edge版本是基于Chromium运行的。&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;据我所知，目前微软对WebRTC的投入并不多；&lt;/li&gt;&lt;li&gt;微软完全有能力改善Windows 10的Chromium（以及扩展Edge）的媒体管道实现；&lt;/li&gt;&lt;li&gt;但问题是：&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;他们是否有理由这样做？&lt;/p&gt;



&lt;p&gt;他们会把成果同谷歌分享吗？还是将其保留在自己的Edge实现里？&lt;/p&gt;



&lt;p&gt;如果微软愿意同谷歌分享成果，谷歌又是否会接受呢？&lt;/p&gt;



&lt;p&gt;另外，Microsoft Teams的浏览器体验比本机应用程序体验差一些。目前Teams所有的投资都用于提高应用程序的质量和用户体验。浏览器的维护还没有提上日程。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;谷歌浏览器（Chrome）&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;谷歌坚信WebRTC是最佳选择。&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;目前，许多针对浏览器中WebRTC的优化和改进即将上线；&lt;/li&gt;&lt;li&gt;但是，现在的很多优化都被不被网络和开源社区所接受，例如WaveNetEQ，这还只是沧海一粟，未来会有更多这样的事情发生；&lt;/li&gt;&lt;li&gt;他们有权利选择怎么做，但这样做是否能进一步推动WebRTC一体化，惠及社区的目标实现呢？&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;现在我们正朝着差异化方向迈进，主流供应商会逐渐解绑WebRTC，或者在发展自身外有余力时，才会分出精力改进WebRTC。&lt;/p&gt;



&lt;p&gt;今时不同往日，公平竞争的环境不再。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;WebRTC&lt;/strong&gt;&lt;strong&gt;的未来何去何从&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;以上讲的是我个人认为WebRTC将来最可能会面临的情况。&lt;/p&gt;



&lt;p&gt;现在，我们有很多途径采用WebRTC，对其进行优化。比如如何使我们的应用程序更具可扩展性，提供更好的媒体质量和用户体验；再比如扩展我们的呼叫规模，使其可容纳数百名用户或者更多。在这些领域进行投资将是未来大势。&lt;/p&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;文章地址：&lt;a href=&quot;https://bloggeek.me/webrtc-unbundling/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;https://bloggeek.me/webrtc-unbundling/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文作者：Tsahi Levent-Levi&lt;/p&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9e2249bfe2b0be506de95423687e2b46</guid>
<title>Guava：拯救垃圾代码，写出优雅高效，效率提升 N 倍</title>
<link>https://toutiao.io/k/3u67plz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;最近在看一个同学代码的时候，发现代码中大量使用了 Google 开源的 Guava 核心库中的内容，让代码简单清晰了不少，故学习分享出 Guava 中我认为最实用的功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Guava&lt;/strong&gt; 项目是 Google 公司开源的 Java 核心库，它主要是包含一些在 Java 开发中经常使用到的功能，如&lt;strong&gt;数据校验&lt;/strong&gt;、&lt;strong&gt;不可变集合&lt;/strong&gt;、计数集合，集合增强操作、I/O、缓存、字符串操作等。并且 &lt;strong&gt;Guava&lt;/strong&gt; 广泛用于 Google 内部的 Java 项目中，也被其他公司广泛使用，甚至在新版 JDK 中直接引入了 &lt;strong&gt;Guava&lt;/strong&gt; 中的优秀类库，所以质量毋庸置疑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用方式直接 mavan 依赖引入。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.google.guava&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;guava&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;30.0-jre&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据校验&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据校验说来十分简单，一是&lt;strong&gt;非空判断&lt;/strong&gt;，二是&lt;strong&gt;预期值判断&lt;/strong&gt;。非空判断我想每一个 Java 开发者都很熟悉，一开始都经常和 &lt;code&gt;NullPointException&lt;/code&gt; 打交道。处理的方式我们自然是一个 &lt;code&gt;if( xx == null)&lt;/code&gt; 就能轻松解决。预期值判断也是类似，检查数据值是不是自己想要的结果即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使这么简单的操作，我们是不是还经常出错呢？而且写起来的代码总是一行判断一行异常抛出，怎么看都觉得那么优雅。还好，现在就来尝试第一次使用 Guava 吧。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非空判断&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String param = &lt;span&gt;&quot;未读代码&quot;&lt;/span&gt;;&lt;br/&gt;String name = Preconditions.checkNotNull(param);&lt;br/&gt;System.out.println(name); &lt;span&gt;// 未读代码&lt;/span&gt;&lt;br/&gt;String param2 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;String name2 = Preconditions.checkNotNull(param2); &lt;span&gt;// NullPointerException&lt;/span&gt;&lt;br/&gt;System.out.println(name2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入了 Guava 后可以直接使用 &lt;code&gt;Preconditions.checkNotNull&lt;/code&gt; 进行非空判断，好处为觉得有两个，一是语义清晰代码优雅；二是你也可以自定义报错信息，这样如果参数为空，报错的信息清晰，可以直接定位到具体参数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String param2 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;String name2 = Preconditions.checkNotNull(param2,&lt;span&gt;&quot;param2 is null&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// java.lang.NullPointerException: param2 is null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;预期值判断&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和非空判断类似，可以比较当前值和预期值，如果不相等可以自定义报错信息抛出。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String param = &lt;span&gt;&quot;www.wdbyte.com2&quot;&lt;/span&gt;;&lt;br/&gt;String wdbyte = &lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;;&lt;br/&gt;Preconditions.checkArgument(wdbyte.equals(param), &lt;span&gt;&quot;[%s] 404 NOT FOUND&quot;&lt;/span&gt;, param);&lt;br/&gt;&lt;span&gt;// java.lang.IllegalArgumentException: [www.wdbyte.com2] 404 NOT FOUND&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;是否越界&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Preconditions&lt;/code&gt; 类还可以用来检查数组和集合的元素获取是否越界。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Guava 中快速创建ArrayList&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;d&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 开始校验&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; index = Preconditions.checkElementIndex(&lt;span&gt;5&lt;/span&gt;, list.size());&lt;br/&gt;&lt;span&gt;// java.lang.IndexOutOfBoundsException: index (5) must be less than size (4)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中快速创建 List 的方式也是 Guava 提供的，后面会详细介绍 Guava 中集合创建的超多姿势。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不可变的集合&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建不可变集合是我个人最喜欢 Guava 的一个原因，因为创建一个&lt;strong&gt;不能删除、不能修改、不能增加元素&lt;/strong&gt;的集合实在是太实用了。这样的集合你完全不用担心发生什么问题，总的来说有下面几个优点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程安全，因为不能修改任何元素，可以随意多线程使用且没有并发问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以无忧的提供给第三方使用，反正修改不了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;减少内存占用，因为不能改变，所以内部实现可以最大程度节约内存占用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以用作常量集合。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建方式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了那么多，那么到底怎么使用呢？赶紧撸起代码来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 创建方式1：of&lt;/span&gt;&lt;br/&gt;ImmutableSet&amp;lt;String&amp;gt; immutableSet = ImmutableSet.of(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;immutableSet.forEach(System.out::println);&lt;br/&gt;&lt;span&gt;// a&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// b&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// c&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 创建方式2：builder&lt;/span&gt;&lt;br/&gt;ImmutableSet&amp;lt;String&amp;gt; immutableSet2 = ImmutableSet.&amp;lt;String&amp;gt;builder()&lt;br/&gt;    .add(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;br/&gt;    .add(&lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;未读代码&quot;&lt;/span&gt;))&lt;br/&gt;    .build();&lt;br/&gt;immutableSet2.forEach(System.out::println);&lt;br/&gt;&lt;span&gt;// hello&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 未读代码&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 创建方式3：从其他集合中拷贝创建&lt;/span&gt;&lt;br/&gt;ArrayList&amp;lt;String&amp;gt; arrayList = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;br/&gt;arrayList.add(&lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;);&lt;br/&gt;arrayList.add(&lt;span&gt;&quot;https&quot;&lt;/span&gt;);&lt;br/&gt;ImmutableSet&amp;lt;String&amp;gt; immutableSet3 = ImmutableSet.copyOf(arrayList);&lt;br/&gt;immutableSet3.forEach(System.out::println);&lt;br/&gt;&lt;span&gt;// www.wdbyte.com&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// https&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;都可以正常打印遍历结果，但是如果进行增删改，会直接报 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; .&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 JDK 中也提供了一个不可变集合，可以像下面这样创建。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ArrayList&amp;lt;String&amp;gt; arrayList = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;br/&gt;arrayList.add(&lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;);&lt;br/&gt;arrayList.add(&lt;span&gt;&quot;https&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// JDK Collections 创建不可变 List&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; list = Collections.unmodifiableList(arrayList);&lt;br/&gt;list.forEach(System.out::println);&lt;span&gt;// www.wdbyte.com https&lt;/span&gt;&lt;br/&gt;list.add(&lt;span&gt;&quot;未读代码&quot;&lt;/span&gt;); &lt;span&gt;// java.lang.UnsupportedOperationException&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;注意事项&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 Guava 创建的不可变集合是拒绝 &lt;code&gt;null&lt;/code&gt; 值的，因为在 Google 内部调查中，95% 的情况下都不需要放入 &lt;code&gt;null&lt;/code&gt; 值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 JDK 提供的不可变集合创建成功后，原集合添加元素会体现在不可变集合中，而 Guava 的不可变集合不会有这个问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   List&amp;lt;String&amp;gt; arrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;   arrayList.add(&lt;span&gt;&quot;a&quot;&lt;/span&gt;);&lt;br/&gt;   arrayList.add(&lt;span&gt;&quot;b&quot;&lt;/span&gt;);&lt;br/&gt;   List&amp;lt;String&amp;gt; jdkList = Collections.unmodifiableList(arrayList);&lt;br/&gt;   ImmutableList&amp;lt;String&amp;gt; immutableList = ImmutableList.copyOf(arrayList);&lt;br/&gt;   arrayList.add(&lt;span&gt;&quot;ccc&quot;&lt;/span&gt;);&lt;br/&gt;   jdkList.forEach(System.out::println);&lt;span&gt;// result: a b ccc&lt;/span&gt;&lt;br/&gt;   System.out.println(&lt;span&gt;&quot;-------&quot;&lt;/span&gt;);&lt;br/&gt;   immutableList.forEach(System.out::println);&lt;span&gt;// result: a b&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果不可变集合的元素是引用对象，那么引用对象的属性是可以更改的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其他不可变集合&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不可变集合除了上面演示的 &lt;code&gt;set&lt;/code&gt; 之外，还有很多不可变集合，下面是 Guava 中不可变集合和其他集合的对应关系。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;可变集合接口&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;属于JDK还是Guava&lt;/th&gt;&lt;th&gt;&lt;strong&gt;不可变版本&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Collection&lt;/td&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableCollection&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;List&lt;/td&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableList&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Set&lt;/td&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableSet&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SortedSet/NavigableSet&lt;/td&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableSortedSet&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableMap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SortedMap&lt;/td&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableSortedMap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Multiset&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableMultiset&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SortedMultiset&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableSortedMultiset&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Multimap&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableMultimap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ListMultimap&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableListMultimap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SetMultimap&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableSetMultimap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BiMap&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableBiMap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ClassToInstanceMap&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableClassToInstanceMap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Table&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableTable&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;集合操作工厂&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这里只会介绍一个创建方法，但是为什么还是单独拿出来介绍了呢？看下去你就会&lt;strong&gt;大呼好用&lt;/strong&gt;。虽然 JDK 中已经提供了大量的集合相关的操作方法，用起来也是非常的方便，但是 Guava 还是增加了一些十分好用的方法，保证让你用上一次就爱不释手，&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建集合。&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 创建一个 ArrayList 集合&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; list1 = Lists.newArrayList();&lt;br/&gt;&lt;span&gt;// 创建一个 ArrayList 集合，同时塞入3个数据&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; list2 = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 创建一个 ArrayList 集合，容量初始化为10&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; list3 = Lists.newArrayListWithCapacity(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;LinkedList&amp;lt;String&amp;gt; linkedList1 = Lists.newLinkedList();&lt;br/&gt;CopyOnWriteArrayList&amp;lt;String&amp;gt; cowArrayList = Lists.newCopyOnWriteArrayList();&lt;br/&gt;&lt;br/&gt;HashMap&amp;lt;Object, Object&amp;gt; hashMap = Maps.newHashMap();&lt;br/&gt;ConcurrentMap&amp;lt;Object, Object&amp;gt; concurrentMap = Maps.newConcurrentMap();&lt;br/&gt;TreeMap&amp;lt;Comparable, Object&amp;gt; treeMap = Maps.newTreeMap();&lt;br/&gt;&lt;br/&gt;HashSet&amp;lt;Object&amp;gt; hashSet = Sets.newHashSet();&lt;br/&gt;HashSet&amp;lt;String&amp;gt; newHashSet = Sets.newHashSet(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Guava 为每一个集合都添加了工厂方法创建方式，上面已经展示了部分集合的工厂方法创建方式。是不是十分的好用呢。而且可以在创建时直接扔进去几个元素，这个简直太赞了，再也不用一个个 &lt;code&gt;add&lt;/code&gt; 了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;集合交集并集差集&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过于简单，直接看代码和输出结果吧。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Set&amp;lt;String&amp;gt; newHashSet1 = Sets.newHashSet(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;Set&amp;lt;String&amp;gt; newHashSet2 = Sets.newHashSet(&lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;d&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 交集&lt;/span&gt;&lt;br/&gt;SetView&amp;lt;String&amp;gt; intersectionSet = Sets.intersection(newHashSet1, newHashSet2);&lt;br/&gt;System.out.println(intersectionSet); &lt;span&gt;// [b, c]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 并集&lt;/span&gt;&lt;br/&gt;SetView&amp;lt;String&amp;gt; unionSet = Sets.union(newHashSet1, newHashSet2);&lt;br/&gt;System.out.println(unionSet); &lt;span&gt;// [a, b, c, d]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// newHashSet1 中存在，newHashSet2 中不存在&lt;/span&gt;&lt;br/&gt;SetView&amp;lt;String&amp;gt; setView = Sets.difference(newHashSet1, newHashSet2);&lt;br/&gt;System.out.println(setView); &lt;span&gt;// [a]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;有数量的集合&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个真的太有用了，因为我们经常会需要设计可以计数的集合，或者 value 是 &lt;code&gt;List&lt;/code&gt; 的 &lt;code&gt;Map&lt;/code&gt; 集合，如果说你不太明白，看下面这段代码，是否某天夜里你也这样写过。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;统计相同元素出现的次数（下面的代码我已经尽可能精简写法了）。&lt;/p&gt;&lt;p&gt;JDK 原生写法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;// Java 统计相同元素出现的次数。&lt;/span&gt;&lt;br/&gt;   List&amp;lt;String&amp;gt; words = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;d&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;   Map&amp;lt;String, Integer&amp;gt; countMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Integer&amp;gt;();&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (String word : words) {&lt;br/&gt;       Integer count = countMap.get(word);&lt;br/&gt;       count = (count == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt; : ++count;&lt;br/&gt;       countMap.put(word, count);&lt;br/&gt;   }&lt;br/&gt;   countMap.forEach((k, v) -&amp;gt; System.out.println(k + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + v));&lt;br/&gt;   &lt;span&gt;/**&lt;br/&gt;    * result:&lt;br/&gt;    * a:2&lt;br/&gt;    * b:1&lt;br/&gt;    * c:2&lt;br/&gt;    * d:1&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管已经尽量优化代码，代码量还是不少的，那么在 Guava 中有什么不一样呢？在 Guava. 中主要是使用 &lt;code&gt;HashMultiset&lt;/code&gt; 类，看下面。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   ArrayList&amp;lt;String&amp;gt; arrayList = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;d&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;   HashMultiset&amp;lt;String&amp;gt; multiset = HashMultiset.create(arrayList);&lt;br/&gt;   multiset.elementSet().forEach(s -&amp;gt; System.out.println(s + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + multiset.count(s)));&lt;br/&gt;   &lt;span&gt;/**&lt;br/&gt;    * result:&lt;br/&gt;    * a:2&lt;br/&gt;    * b:1&lt;br/&gt;    * c:2&lt;br/&gt;    * d:1&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，只要把元素添加进去就行了，不用在乎是否重复，最后都可以使用 &lt;code&gt;count&lt;/code&gt; 方法统计重复元素数量。看着舒服，写着优雅，&lt;code&gt;HashMultiset&lt;/code&gt; 是 Guava 中实现的 &lt;code&gt;Collection&lt;/code&gt; 类，可以轻松统计元素数量。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一对多，value 是 &lt;code&gt;List&lt;/code&gt; 的 &lt;code&gt;Map&lt;/code&gt; 集合。&lt;/p&gt;&lt;p&gt;假设一个场景，需要把很多动物按照种类进行分类，我相信最后你会写出类似的代码。&lt;/p&gt;&lt;p&gt;JDK 原生写法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; animalMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;   HashSet&amp;lt;String&amp;gt; dogSet = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;br/&gt;   dogSet.add(&lt;span&gt;&quot;旺财&quot;&lt;/span&gt;);&lt;br/&gt;   dogSet.add(&lt;span&gt;&quot;大黄&quot;&lt;/span&gt;);&lt;br/&gt;   animalMap.put(&lt;span&gt;&quot;狗&quot;&lt;/span&gt;, dogSet);&lt;br/&gt;   HashSet&amp;lt;String&amp;gt; catSet = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;br/&gt;   catSet.add(&lt;span&gt;&quot;加菲&quot;&lt;/span&gt;);&lt;br/&gt;   catSet.add(&lt;span&gt;&quot;汤姆&quot;&lt;/span&gt;);&lt;br/&gt;   animalMap.put(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;, catSet);&lt;br/&gt;   System.out.println(animalMap.get(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;)); &lt;span&gt;// [加菲, 汤姆]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一行查询猫得到了猫类的 &quot;加菲&quot; 和 ”汤姆“。这个代码简直太烦做了，如果使用 Guava 呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;// use guava&lt;/span&gt;&lt;br/&gt;   HashMultimap&amp;lt;String, String&amp;gt; multimap = HashMultimap.create();&lt;br/&gt;   multimap.put(&lt;span&gt;&quot;狗&quot;&lt;/span&gt;, &lt;span&gt;&quot;大黄&quot;&lt;/span&gt;);&lt;br/&gt;   multimap.put(&lt;span&gt;&quot;狗&quot;&lt;/span&gt;, &lt;span&gt;&quot;旺财&quot;&lt;/span&gt;);&lt;br/&gt;   multimap.put(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;, &lt;span&gt;&quot;加菲&quot;&lt;/span&gt;);&lt;br/&gt;   multimap.put(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;, &lt;span&gt;&quot;汤姆&quot;&lt;/span&gt;);&lt;br/&gt;   System.out.println(multimap.get(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;)); &lt;span&gt;// [加菲, 汤姆]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMultimap 可以扔进去重复的 key 值，最后获取时可以得到所有的 value 值，可以看到输出结果和 JDK 写法上是一样的，但是代码已经无比清爽。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;字符串操作&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为开发中最长使用的数据类型，字符串操作的增强可以让开发更加高效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;字符拼接&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 8 中其实已经内置了字符串拼接方法，但是它只是简单的拼接，没有额外操作，比如过滤掉 null 元素，去除前后空格等。先看一下 JDK 8 中字符串拼接的几种方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// JDK 方式一&lt;/span&gt;&lt;br/&gt;ArrayList&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;String join = String.join(&lt;span&gt;&quot;,&quot;&lt;/span&gt;, list);&lt;br/&gt;System.out.println(join); &lt;span&gt;// a,b,c,null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// JDK 方式二&lt;/span&gt;&lt;br/&gt;String result = list.stream().collect(Collectors.joining(&lt;span&gt;&quot;,&quot;&lt;/span&gt;));&lt;br/&gt;System.out.println(result); &lt;span&gt;// a,b,c,null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// JDK 方式三&lt;/span&gt;&lt;br/&gt;StringJoiner stringJoiner = &lt;span&gt;new&lt;/span&gt; StringJoiner(&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;br/&gt;list.forEach(stringJoiner::add);&lt;br/&gt;System.out.println(stringJoiner.toString()); &lt;span&gt;// a,b,c,null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 null 值也被拼接到了字符串里，这有时候不是我们想要的，那么使用 Guava 有什么不一样呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ArrayList&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;String join = Joiner.on(&lt;span&gt;&quot;,&quot;&lt;/span&gt;).skipNulls().join(list);&lt;br/&gt;System.out.println(join); &lt;span&gt;// a,b,c&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;String join1 = Joiner.on(&lt;span&gt;&quot;,&quot;&lt;/span&gt;).useForNull(&lt;span&gt;&quot;空值&quot;&lt;/span&gt;).join(&lt;span&gt;&quot;旺财&quot;&lt;/span&gt;, &lt;span&gt;&quot;汤姆&quot;&lt;/span&gt;, &lt;span&gt;&quot;杰瑞&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;System.out.println(join1); &lt;span&gt;// 旺财,汤姆,杰瑞,空值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到使用 &lt;code&gt;skipNulls()&lt;/code&gt; 可以跳过空值，使用 &lt;code&gt;useFornull(String)&lt;/code&gt; 可以为空值自定义显示文本。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;字符串分割&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 中是自带字符串分割的，我想你也一定用过，那就是 String 的 split 方法，但是这个方法有一个问题，就是如果最后一个元素为空，那么就会丢弃，奇怪的是第一个元素为空却不会丢弃，这就十分迷惑，下面通过一个例子演示这个问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String str = &lt;span&gt;&quot;,a,,b,&quot;&lt;/span&gt;;&lt;br/&gt;String[] splitArr = str.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;br/&gt;Arrays.stream(splitArr).forEach(System.out::println);&lt;br/&gt;System.out.println(&lt;span&gt;&quot;------&quot;&lt;/span&gt;);&lt;br/&gt;/**&lt;br/&gt; *&lt;br/&gt; * a&lt;br/&gt; * &lt;br/&gt; * b&lt;br/&gt; * ------&lt;br/&gt; */&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以自己测试下，最后一个元素不是空，直接消失了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用 Guava 是怎样的操作方式呢？Guava 提供了 Splitter 类，并且有一系列的操作方式可以直观的控制分割逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String str = &lt;span&gt;&quot;,a ,,b ,&quot;&lt;/span&gt;;&lt;br/&gt;Iterable&amp;lt;String&amp;gt; split = Splitter.on(&lt;span&gt;&quot;,&quot;&lt;/span&gt;)&lt;br/&gt;    .omitEmptyStrings() &lt;span&gt;// 忽略空值&lt;/span&gt;&lt;br/&gt;    .trimResults() &lt;span&gt;// 过滤结果中的空白&lt;/span&gt;&lt;br/&gt;    .split(str);&lt;br/&gt;split.forEach(System.out::println);&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * a&lt;br/&gt; * b&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓存&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发中我们可能需要使用小规模的缓存，来提高访问速度。这时引入专业的缓存中间件可能又觉得浪费。现在可以了， Guava 中提供了简单的缓存类，且可以根据预计容量、过期时间等自动过期已经添加的元素。即使这样我们也要预估好可能占用的内存空间，以防内存占用过多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在看一下在 Guava 中缓存该怎么用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testCache&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ExecutionException, InterruptedException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    CacheLoader cacheLoader = &lt;span&gt;new&lt;/span&gt; CacheLoader&amp;lt;String, Animal&amp;gt;() {&lt;br/&gt;        &lt;span&gt;// 如果找不到元素，会调用这里&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Animal &lt;span&gt;load&lt;/span&gt;&lt;span&gt;(String s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    };&lt;br/&gt;    LoadingCache&amp;lt;String, Animal&amp;gt; loadingCache = CacheBuilder.newBuilder()&lt;br/&gt;        .maximumSize(&lt;span&gt;1000&lt;/span&gt;) &lt;span&gt;// 容量&lt;/span&gt;&lt;br/&gt;        .expireAfterWrite(&lt;span&gt;3&lt;/span&gt;, TimeUnit.SECONDS) &lt;span&gt;// 过期时间&lt;/span&gt;&lt;br/&gt;        .removalListener(&lt;span&gt;new&lt;/span&gt; MyRemovalListener()) &lt;span&gt;// 失效监听器&lt;/span&gt;&lt;br/&gt;        .build(cacheLoader); &lt;span&gt;//&lt;/span&gt;&lt;br/&gt;    loadingCache.put(&lt;span&gt;&quot;狗&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Animal(&lt;span&gt;&quot;旺财&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;    loadingCache.put(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Animal(&lt;span&gt;&quot;汤姆&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;    loadingCache.put(&lt;span&gt;&quot;狼&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Animal(&lt;span&gt;&quot;灰太狼&quot;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    loadingCache.invalidate(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;); &lt;span&gt;// 手动失效&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    Animal animal = loadingCache.get(&lt;span&gt;&quot;狼&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(animal);&lt;br/&gt;    Thread.sleep(&lt;span&gt;4&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 狼已经自动过去，获取为 null 值报错&lt;/span&gt;&lt;br/&gt;    System.out.println(loadingCache.get(&lt;span&gt;&quot;狼&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * key=猫,value=Animal{name=&#x27;汤姆&#x27;, age=3},reason=EXPLICIT&lt;br/&gt;     * Animal{name=&#x27;灰太狼&#x27;, age=4}&lt;br/&gt;     * key=狗,value=Animal{name=&#x27;旺财&#x27;, age=1},reason=EXPIRED&lt;br/&gt;     * key=狼,value=Animal{name=&#x27;灰太狼&#x27;, age=4},reason=EXPIRED&lt;br/&gt;     *&lt;br/&gt;     * com.google.common.cache.CacheLoader$InvalidCacheLoadException: CacheLoader returned null for key 狼.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 缓存移除监听器&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyRemovalListener&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RemovalListener&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Animal&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onRemoval&lt;/span&gt;&lt;span&gt;(RemovalNotification&amp;lt;String, Animal&amp;gt; notification)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String reason = String.format(&lt;span&gt;&quot;key=%s,value=%s,reason=%s&quot;&lt;/span&gt;, notification.getKey(), notification.getValue(), notification.getCause());&lt;br/&gt;        System.out.println(reason);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer age;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Animal{&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;name=&#x27;&quot;&lt;/span&gt; + name + &lt;span&gt;&#x27;\&#x27;&#x27;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;, age=&quot;&lt;/span&gt; + age +&lt;br/&gt;            &lt;span&gt;&#x27;}&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt;&lt;span&gt;(String name, Integer age)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中主要分为 CacheLoader、MyRemovalListener、LoadingCache。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CacheLoader 中重写了 &lt;code&gt;load&lt;/code&gt; 方法，这个方法会在查询缓存没有命中时被调用，我这里直接返回了 &lt;code&gt;null&lt;/code&gt;，其实这样会在没有命中时抛出 &lt;code&gt;CacheLoader returned null for key&lt;/code&gt; 异常信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MyRemovalListener 作为缓存元素失效时的监听类，在有元素缓存失效时会自动调用 &lt;code&gt;onRemoval&lt;/code&gt; 方法，这里需要注意的是这个方法是同步方法，如果这里耗时较长，会阻塞直到处理完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LoadingCache 就是缓存的主要操作对象了，常用的就是其中的 &lt;code&gt;put&lt;/code&gt; 和 &lt;code&gt;get&lt;/code&gt; 方法了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍了我认为最常用的 Guava 功能，Guava 作为 Google 公司开源的 Java 开发核心库，个人觉得实用性还是很高的。引入后不仅能快速的实现一些开发中常用的功能，而且还可以让代码更加的优雅简洁。我觉得适用于每一个 Java 项目。Guava 的其他的功能你也可以自己去发现。它的 Github 地址是：https://github.com/google/guava.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://github.com/google/guava/wiki&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;订阅&lt;/h2&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>72ec13b2bfc4d1a55c4a1264f6584cba</guid>
<title>中了源码的毒，给你一副良药</title>
<link>https://toutiao.io/k/imkoquw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近期阿宝哥在团队内搞了一个 &lt;strong&gt;「如何读源码」&lt;/strong&gt; 的专题，主要目的是让团队的小伙伴们了解读源码的思路与技巧。在此期间，阿宝哥也写了 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247486544&amp;amp;idx=1&amp;amp;sn=70b610d286d1ecd44b53a1f128a3669f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;77.9K 的 Axios 项目有哪些值得借鉴的地方&lt;/a&gt;、&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247486413&amp;amp;idx=1&amp;amp;sn=f9a2d3a0f7f89817ce0f5abb4a2698ed&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;从 12.9K 的前端开源项目我学到了啥&lt;/a&gt; 和 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247486436&amp;amp;idx=1&amp;amp;sn=8f51cb6bdb75d8feef01ea3a2faee849&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;如何让你的 Express 飞起来&lt;/a&gt; 三篇源码解析的文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中前两篇在&lt;strong&gt;「掘金社区」&lt;/strong&gt;获得不错的评价，平均 630 多个👍，所以阿宝哥就想写一篇文章来分享一下本人读源码的思路、技巧与工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，让我们开始出发吧！在进入正题之前，我们先来个读源码前的 &lt;strong&gt;「灵魂四连问」&lt;/strong&gt; 热热身。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;一、灵魂四连问&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1.1 为什么要读源代码&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEdH3WkAPg7s4Slkyn4P0VkVXRkDZLm7yE5h3dtF1d875g1ib4JHvQfR7A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.36936936936936937&quot; data-w=&quot;888&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1.2 如何选择项目&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEd1Lia2t735clJzsiasz7ByfcGD9PgicrMY3vDIVeib2ezVJcVVhtic4SkLZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.42696629213483145&quot; data-w=&quot;890&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1.3 如何阅读源码&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;238&quot; data-ratio=&quot;0.4247191011235955&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEdhW7vgBzfqicVuO1ozYVmM19yPtspWjne2wRjhay4rQIBPD2WDeyScjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;890&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1.4 有实际的案例么&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEdu4A9qyDM8bLqwYHVHicrMDTUWzPbmYCsBZ2Lib2G2Xj5VM0x5ejf34YA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.42567567567567566&quot; data-w=&quot;888&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然前两篇文章比较受大家喜欢，接下来阿宝哥就以最受欢迎的 Axios 为例，来分享一下读源码的思路与技巧。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;二、如何品读 Axios？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.1 走进 Axios&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 是一个基于 Promise 的 HTTP 客户端，同时支持浏览器和 Node.js 环境。它是一个优秀的 HTTP 客户端，被广泛地应用在大量的 Web 项目中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEdialVxib4YqViaQlDyg9wYoEIH8zJUic6muwF9LDr92cSvhpeN9giaHy4ebg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5995475113122172&quot; data-w=&quot;884&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上图可知，Axios 项目的 Star 数为 &lt;strong&gt;「78.1K」&lt;/strong&gt;，Fork 数也高达 &lt;strong&gt;「7.3K」&lt;/strong&gt;，是一个很优秀的开源项目，所以值得大家细细品读。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.2 发现 Axios 的美&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在确认 Axios 为 “追求目标” 之后，下一步我们就需要来发现它身上的优点（特性）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEdVyAEA9NpNyWDybbayHgHOia72oSPjA2QNQMNtXfMlaHOWAdicWyaNv6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.49213483146067416&quot; data-w=&quot;890&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个人对 “美” 都有不同的看法，对于阿宝哥来说，我看中了图中已选中的三点。因此，它们也很光荣地成为读源码的三个切入点。当然切入点也不是越多越好，可以先找自己最感兴趣的地方作为切入点。需要注意的是，如果切入点之间有关联关系的话，建议做个简单的排序。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.3 感受 Axios 的美&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择切入点之后，我们就可以开始逐一感受 Axios 的设计之美。以 &lt;strong&gt;「能够拦截请求与响应」&lt;/strong&gt; 这个切入点为例，首先我们就会接触到 &lt;strong&gt;「拦截器」&lt;/strong&gt; 的概念。所以我们需要先了解拦截器是什么、拦截器有什么作用以及如何使用拦截器，这里我们可以从项目的 &lt;strong&gt;「官方文档」&lt;/strong&gt; 或者项目中的 &lt;strong&gt;「README.md」&lt;/strong&gt; 文档入手。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.1 拦截器的作用&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 提供了请求拦截器和响应拦截器来分别处理请求和响应，它们的作用如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;请求拦截器：该类拦截器的作用是在请求发送前统一执行某些操作，比如在请求头中添加 token 字段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;响应拦截器：该类拦截器的作用是在接收到服务器响应后统一执行某些操作，比如发现响应状态码为 401 时，自动跳转到登录页。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.2 拦截器的使用&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 添加请求拦截器 —— 处理请求配置对象&lt;/span&gt;&lt;br/&gt;axios.interceptors.request.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  config.headers.token = &lt;span&gt;&#x27;added by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; config;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 添加响应拦截器 —— 处理响应对象&lt;/span&gt;&lt;br/&gt;axios.interceptors.response.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  data.data = data.data + &lt;span&gt;&#x27; - modified by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; data;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;axios({&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;/hello&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;method&lt;/span&gt;: &lt;span&gt;&#x27;get&#x27;&lt;/span&gt;,&lt;br/&gt;}).then(&lt;span&gt;&lt;span&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;axios res.data: &#x27;&lt;/span&gt;, res.data)&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解完拦截器的作用和用法之后，我们就会把焦点聚焦到 &lt;strong&gt;「axios」&lt;/strong&gt; 对象，因为注册拦截器和发送请求都与它有紧密的联系。不过在看具体源码之前，阿宝哥建议先对功能点做一下梳理。以下是阿宝哥的分析思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 的作用是用于发送 HTTP 请求，请求拦截器和响应拦截器分别对应于 HTTP 请求的不同阶段，它们的本质是一个实现特定功能的函数。这时我们就可以按照功能把发送 HTTP 请求拆解成不同类型的子任务，比如有 &lt;strong&gt;「用于处理请求配置对象的子任务」&lt;/strong&gt;，&lt;strong&gt;「用于发送 HTTP 请求的子任务」&lt;/strong&gt; 和 &lt;strong&gt;「用于处理响应对象的子任务」&lt;/strong&gt;。当我们按照指定的顺序来执行这些子任务时，就可以完成一次完整的 HTTP 请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然已经提到了任务，我们就会联想到任务管理系统的基本功能：任务注册、任务编排（优先级排序）和任务调度等。因此我们就可以考虑从 &lt;strong&gt;「任务注册、任务编排和任务调度」&lt;/strong&gt; 三个方面来分析 Axios 拦截器的实现。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.3 任务注册&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 添加请求拦截器 —— 处理请求配置对象&lt;/span&gt;&lt;br/&gt;axios.interceptors.request.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  config.headers.token = &lt;span&gt;&#x27;added by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; config;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 添加响应拦截器 —— 处理响应对象&lt;/span&gt;&lt;br/&gt;axios.interceptors.response.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  data.data = data.data + &lt;span&gt;&#x27; - modified by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; data;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;lib/axios.js&lt;/code&gt; 路径下，我们可以找到 &lt;strong&gt;「axios」&lt;/strong&gt; 对象的定义。为了能直观地了解对象之间的关系，阿宝哥建议大家在读源码的过程中，多动手画画图。比如阿宝哥使用下图来总结一下 &lt;code&gt;Axios&lt;/code&gt; 对象与 &lt;code&gt;InterceptorManager&lt;/code&gt; 对象的内部结构与关系：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEdianzgaYLoibUVvdeA8MuCUZ26uFibvZj6bibs0N0PNkiaejpSchmjvzbfFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.36944444444444446&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.4 任务编排&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经知道如何注册拦截器任务，但仅仅注册任务是不够，我们还需要对已注册的任务进行编排，这样才能确保任务的执行顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样对于任务编排，也可以使用图的形式来展现任务编排后的结果。&lt;strong&gt;「这里有一个小技巧，就是可以采用对比的形式来展示任务编排后的结果，这样子会更加清楚任务编排的处理逻辑。」&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEdJeqibuGpnnrtEo1YTBQKlfdqhhe7UibRpmmwke0bYwWoqLePPicic5C8pw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5194805194805194&quot; data-w=&quot;1078&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.5 任务调度&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任务编排完成后，要发起 HTTP 请求，我们还需要按编排后的顺序执行任务调度。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEdPOmIibU7seVXRoDRbjSMh93dKSWJh43c2ElprS5rRYa4DIWUSpxIWOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4064272211720227&quot; data-w=&quot;1058&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;需要注意的是：在阅读源码过程中，不要太在意细节。比如在研究 Axios 拦截器原理时，不需要再深入了解 &lt;strong&gt;「dispatchRequest」&lt;/strong&gt; 背后的具体实现，只需知道该方法用于实现发送 HTTP 请求即可，这样才不会把整个线路拉得太长。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分析完特定的功能点之后，也许你已经读懂的具体的源代码。但阿宝哥觉得这并不是最重要的，&lt;strong&gt;「更重要的是思考它的设计思想，这样设计有什么好处，对于我们有没有什么值得借鉴和学习的地方」&lt;/strong&gt;。比如参考 Axios 拦截器的设计模型，我们就可以抽出以下通用的任务处理模型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEdZpceN73RIFe6ErKdqEpcMeHh6If0Pqc2ibnCQvXGyo279tlB9unZfSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.3054945054945055&quot; data-w=&quot;910&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面阿宝哥以 Axios 的拦截器为例，分享了读 Axios 源码的思路与技巧。接下来阿宝哥来分享一些读源码的建议和辅助工具。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;三、读源码的建议&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEdtRql3BYmBc0VZ0QhPFwYndmowicb7waJfe9ZibrzibwwVYTz113HjhWuw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5185185185185185&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;四、读源码辅助工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对下列辅助工具感兴趣的话，可以通过以下图片来源的链接，来直接打开每个工具的在线地址。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEd30yI8LhicvP6iaSmvh3ftPGmKr9B62EuJwaFCDHvvXQVkuicDFYInLXbw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.618&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图片来源：https://www.processon.com/view/link/5f6d2beff346fb166d0ac4fd）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;五、总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实除了上面的内容之外，读优秀开源项目还有挺多值得关注的地方。阿宝哥在学习 BetterScroll 项目源码时，总结了一张思维导图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEd2KUWosB3O4oCcxYVibIy6phiazdaJZFXEek6SmLicN5x8Btk6O3JFflXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6325167037861915&quot; data-w=&quot;898&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图片来源：https://www.processon.com/view/link/5f6d2beff346fb166d0ac4fd）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面阿宝哥用一张图来总结一下 axios 和 better-scroll 这两个开源项目的学习路线：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2TYoqiaIuGUKwUUL8HWuQEdHbl2vaynicricvyC8icQS5RfI2N5843GBjI38eGUyAnDnOw2IVpcicummQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.562962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;1、Axios 项目的切入点是从 Github 中的功能特性中筛选出来的；&lt;/p&gt;&lt;p&gt;2、BetterScroll 的切入点是从掘金上 “BetterScroll 2.0 发布：精益求精，与你同行” 这篇文章中介绍的功能亮点中找到的。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;除此之外，阿宝哥也来简单总结一下本文介绍的读源码的思路与技巧：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;站在巨人的肩膀，提前阅读一些项目相关的优质文章；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;汇总学习或工作中遇到的问题，带着问题进行源码学习；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;明确阅读源码的主线或切入点；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽可能从简单的示例出发来分析每个功能点；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;先梳理清楚主要流程，不要太在意细节，避免把整个线路拉得太长；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在阅读源码过程中，要多多画图，这样理解起来会更加直观。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文阿宝哥分享了个人读源码的思路、技巧与工具，希望阅读完本文能对你有所启发或帮助。如果你有读源码更好的思路与技巧，欢迎随时跟阿宝哥交流。有写得不好的地方，也请各位见谅哈。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;六、参考资源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;聚焦全栈，专注分享 TypeScript、Web API、前端架构等技术干货。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;1&quot; data-cropselx2=&quot;517&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;287&quot; data-ratio=&quot;0.55390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rr8AYsibjj4I8JiaAA9pIOib3bX4WN78BcjbtSuMgoxOH5tTOzPk6qmrFEg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>