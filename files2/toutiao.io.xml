<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1ea45e3215c337d25fe086cb4beaa676</guid>
<title>订单超时自动取消 3 种方案——我们用这种！</title>
<link>https://toutiao.io/k/2twi0wt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg4NjYyODc4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J4jTHmo8Xh6qM32ASOtVbXNoiaegrI26qLRw6r6FTI7dZw6TMT7vecvnjd1O8xSsM5MiajIuQZicxSC6KFK8TMpbg/0?wx_fmt=png&quot; data-nickname=&quot;java突击队&quot; data-alias=&quot;&quot; data-signature=&quot;技术经验分享&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是苏三，大家对电商购物应该都比较熟悉了，我们应该注意到，在下单之后，通常会有一个倒计时，如果超过支付时间，订单就会被自动取消。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1700680272108843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWet6dkExtrdrG1hWr2LicsD4Ny38KlJpVr1x1Jiaia3VewGGAO7XN4Rl8lhw0eDL0bZRlq9JYTadicybQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;588&quot;/&gt;&lt;figcaption&gt;下单&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天，我们来聊聊订单超时未支付自动取消的几种方案。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.定时任务&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是最容易想到的办法，定时任务去轮询数据库，取消即将超时的订单。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.863013698630137&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWet6dkExtrdrG1hWr2LicsD4HnLvHicEQLt8XmsiaJ6FcD9M75QCTANDsr7HfKqYkRCVY8tHNbhwMcuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;730&quot;/&gt;&lt;figcaption&gt;订单轮询&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定时任务实现方式有很多种，大概可以分为两类：&lt;code&gt;本地定时任务&lt;/code&gt;和&lt;code&gt;分布式定时任务&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8498098859315589&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWet6dkExtrdrG1hWr2LicsD4SicS56Z5N58TQYqamMy2nKubtMSvDOHxmL0rYBkF5rABgE60P6D6v0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;figcaption&gt;定时任务实现&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地定时任务，适用于单机版的业务系统，实现方式非常多样：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;永动机线程：开启一个线程，通过sleep去完成定时，一些开源中间件的某些定时任务是通过这种方式实现的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JDK Timer：JDK提供了Timer API，也提供了很多周期性的方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延迟线程池：JDK还提供了延迟线程池ScheduledExecutorService，API和Timer类似。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Task：Sprig框架也提供了一些定时任务的实现，使用起来更加简单。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Quartz：Quartz框架更进一步，提供了可以动态配置的线程池。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式定时任务：适用于分布式的业务系统，主要的实现框架有两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;xxl-job：大众点评的许雪里开源的，一款基于MySQL的轻量级分布式定时任务框架。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;elastic-job：当当开发的弹性分布式任务调度系统，功能很强大，相对重一些。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定时任务实现的优点是开发起来比较简单，但是它也有一些缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对数据库的压力很大，定时任务造成人为的波峰，执行的时刻数据库的压力会陡增&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计时不准，定时任务做不到非常精确的时间控制，比如半小时订单过期，但是定时任务很难卡准这个点&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.被动取消&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章开头的那个倒计时器，大家觉得是怎么做的呢？一般是客户端计时+服务端检查。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么意思呢？就是这个倒计时由客户端去做，但是客户端定时去服务端检查，修正倒计时的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这个订单超时自动取消，也可以由客户端去做：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户留在收银台的时候，客户端倒计时+主动查询订单状态，服务端每次都去检查一下订单是否超时、剩余时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户每次进入订单相关的页面，查询订单的时候，服务端也检查一下订单是否超时&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9067796610169492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWet6dkExtrdrG1hWr2LicsD4PMZdwqQIA2VA8QJwbkOv3IAL3GGnKuh8jkBG96zG26QyO5cXfnTic5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;figcaption&gt;被动取消&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式实现起来也比较简单，但是它也有缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;依赖客户端，如果客户端不发起请求，订单可能永远没法过期，一直占用库存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，也可以&lt;code&gt;被动取消&lt;/code&gt;+&lt;code&gt;定时任务&lt;/code&gt;，通过定时任务去做兜底的操作。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.延时消息&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三种方案，就是利用延时消息了，可以使用RocketMQ、RabbitMQ、Kafka的延时消息，消息发送后，有一定延时才会投递。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.584958217270195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWet6dkExtrdrG1hWr2LicsD4psG3CspMFIjcX7ShEG6SvNiaqI4LJ9LV7ElrFsWE9sWfZXZrjnBE6OA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;718&quot;/&gt;&lt;figcaption&gt;延时消息&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用的就是这种，消息队列采用的是RocketMQ，其实RocketMQ延时也是利用定时任务实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用延时消息的优点是比较高效、好扩展，缺点是引入了新的技术组件，增加了复杂度。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面的三种，其实还有一些其它的方式，例如本地延迟队列、时间轮算法、Redis过期监听……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我觉得，应该不会有人真考虑过在生产上使用这些方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里再给大家提个小问题，假如我们接入了一种支付方式，支付的周期非常长，我们需要延长订单的有效时间，这种情况下，大家会怎么实现订单超时未支付自动取消呢？&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;[1].Java中定时任务的6种实现方式，你知道几种？:https://juejin.cn/post/6992719702032121864&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2].订单超时未支付自动取消8种实现方案:https://blog.csdn.net/Anenan/article/details/126368753：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近苏三的知识星球&lt;span&gt;【&lt;/span&gt;&lt;strong&gt;Java突击队&lt;/strong&gt;&lt;span&gt;】&lt;/span&gt;，每天都会更新很多干货内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很多独家的干货内容，比如：Java后端学习路线，分享实战项目，源码分析，百万级系统设计，系统上线的一些坑，MQ专题，真实面试题，每天都会回答大家提出的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几天星球开通了3个优质专栏：痛点问题、高频面试题 和 性能优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个专栏都是大家非常关心，和非常有价值的话题，我相信在专栏中你会学到很多东西，值回票价。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.215625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5juNjoTDB1fgb1dG7wI612XPgTKQp00H2FdpUzqMFWboLsbgQhkDPzwysRodCL5HcBPHGvONmdoXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;券后只需&lt;span&gt;84&lt;/span&gt;元，随着干货内容越来越多，而且&lt;span&gt;苏三的&lt;/span&gt;demo项目要上线了，价值越来越大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;过几天还会涨价，目前这批优惠券仅剩十几张，要上车的抓紧时间。&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dfad3dbb8b91ae686fc79e2e800bef77</guid>
<title>交互式推荐在外卖场景的探索与应用</title>
<link>https://toutiao.io/k/r495hyk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;89&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.10841121495327102&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVsE4Nicq51WdnKEhcaEEYDS4h6jA6JOZ3fnENgFV1B6ianDTqaQ3nzNOjvHUB79ocldrVj4YlkAW6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1070&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第552&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2023年 第004篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;103&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;103&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU2zk0q52HtKQjubeUEyZHBic5ADGrKxgSd0tibyMiasOHXjb46qFBw7PTfuWAxXzWq32lDkL05icwkMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;section&gt;&lt;span&gt;外卖场景的用户停留时长低于传统电商，对用户实时需求的理解和反馈有更高的要求。针对业务问题，外卖推荐团队从2021年起开始持续投入，最终摸索出了一套适用于外卖场景的交互式推荐架构和策略，并取得了较好的收益。下文将详细介绍外卖首页Feed在搭建交互式推荐时遇到的挑战和解决思路。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 背景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1.1 什么是交互式推荐？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1.2 为什么需要交互式推荐？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 问题与挑战&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 主要工作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.1 交互式推荐框架&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.2 评估方式和评估指标&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.3 用户意图理解&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.4 推荐排序策略&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 总结与展望&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5. 本文作者&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6. 参考文献&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7. 招聘信息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; 1. 背景 &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1.1 什么是交互式推荐？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;交互式推荐是一种互动式实时推荐产品模块，主要通过理解用户需求、以互动的方式进行推荐。交互式推荐由Youtube在2018年提出&lt;sup&gt;[1]&lt;/sup&gt;，主要用于解决推荐系统的延迟&lt;sup&gt;[2]&lt;/sup&gt;和与用户互动偏弱的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从2021年下半年开始，美团外卖推荐技术团队在外卖首页Feed上持续进行探索，2022上半年完成全量。具体流程如视频1所示：用户从首页Feed进入商家详情页并退出之后，动态地插入新的推荐内容到用户推荐列表中。其主要优势是根据用户的实时需求动态插入卡片进行反馈，进而增强用户的使用体验。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;视频1 &lt;/span&gt;&lt;span&gt;外卖首页Feed中的交互式推荐形态&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2 为什么需要交互式推荐？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;我们发现，外卖首页Feed在&lt;strong&gt;用户即时兴趣的捕捉和反馈上存在痛点&lt;/strong&gt;，“对比型”用户的选购效率和体验不佳。外卖首页Feed作为泛意图用户主要选购场景之一，用户在浏览到成单过程中通常需要进行一番对比、才能逐步收敛意图，然后做出最终决策。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但受限于长列表的翻页模式，首页Feed根据用户需求实时调整推荐结果的能力不足。具体表现在，一部分用户的浏览深度不足一页，推荐系统没有额外的机会根据用户兴趣调整推荐结果。另一部分用户虽然有较深的浏览深度，但需要等到翻页时推荐系统才能重新理解用户意图，实时性不足。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;业界优化这类问题的主要产品形态有交互式推荐、动态翻页、端上重排这三种。交互式推荐由于是在用户可视范围内插入，用户感知较强；后两种的主流形态是在用户不可见区域更新推荐，用户感知相对较弱。其实，这三种形态在美团外卖均有尝试，本文重点聚焦于交互式推荐的介绍。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; 2. 问题与挑战 &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;我们在外卖场景搭建交互式推荐时，主要面临以下难点和挑战：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不同于传统的推荐系统，交互式推荐是由用户触发的推荐，外卖场景下，如何更好的匹配用户实时需求，搭建出一套适用于外卖的、基于端智能框架的推荐系统是我们首要解决的问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;作为首页Feed内部的个性化模块，交互式推荐只做单一模块的优化是不够的，还要考虑首页Feed整体的访购效率。那么，如何选择优化目标，以及如何衡量效果和收益，是摆在我们面前的第二个问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;主流的Feed形态是双列商品瀑布流，但外卖首页Feed是以商家为主的单列列表，如何避免交互在用户的选择路径上带来的“干扰感”，在合适的时机触发交互式推荐，是我们面临的第三个问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;交互式推荐具有动态插入效果，用户对于推荐结果好与坏的感受会更加明显。如何更好理解用户即时意图，如何利用首页Feed列表推荐结果优化交互式推荐的单商家卡片，是我们面临的第四个问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;本文将从以上四个方面，详细介绍外卖首页Feed交互式推荐从0到1搭建的全过程，以及针对以上问题的解决思路。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; 3. 主要工作 &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3.1 交互式推荐框架&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.1.1 整体链路&lt;/strong&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p&gt;&lt;span&gt;上文提到，要实现交互式推荐，搭建出一套适用于外卖的、基于端智能框架的推荐系统非常重要。搭建思路可以用“4W1H”来总结：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Where/How&lt;/strong&gt;：交互式推荐卡片展示在哪？交互式推荐卡片的展现形式是什么？涉及产品形态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Who/When&lt;/strong&gt;：交互式推荐需要对什么样的用户触发？在什么时机下触发？涉及用户意图理解。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;What&lt;/strong&gt;：交互式推荐卡片需要展示什么？涉及推荐策略。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;基于对上述问题的思考和多方探讨，我们最终和产品、端智能、客户端、应用服务和推荐工程等多个相关团队一起，搭建了这套适用于外卖首页Feed的交互式推荐链路。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;364&quot; data-ratio=&quot;0.6525934861278649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWQj5aLerxCKB7f5YLeCNsLjibb8KSQfRaNY2NeQDtqgO3ibibzibp5V0GPAtpbInVONyhRv6bicM7suxA/640?wx_fmt=jpeg&quot; data-w=&quot;829&quot;/&gt;&lt;p&gt;&lt;span&gt;图1 交互式推荐整体链路&lt;/span&gt;&lt;/p&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图1展示了从“用户点击首页Feed商家卡片”开始，到交互式推荐卡片展现”的全流程。用户进入点菜页后，由客户端调用端智能的意图理解引擎；满足交互式推荐的触发条件后，进行特征处理、计算和存储，并将计算好的将特征传递给客户端组装推荐请求；推荐请求由应用服务层透传给混排服务，再由混排调用商家推荐模块，经过召回、排序、机制、透出阶段，最终返回结果到客户端进行展示。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.2 产品形态&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;文章开头部分的视频1是我们线上的最终形态（&lt;/span&gt;&lt;span&gt;在用户点击商家下方插入单个商家卡片&lt;/span&gt;&lt;span&gt;），但在此之前，我们对交互式推荐的卡片形态和交互逻辑进行了多轮尝试。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在卡片形态上，我们先后探索、上线了搜索词卡片、多商家聚合卡片（&lt;/span&gt;&lt;span&gt;如视频2所示&lt;/span&gt;&lt;span&gt;）、单商家卡片（&lt;/span&gt;&lt;span&gt;如视频1所示&lt;/span&gt;&lt;span&gt;）等多种形态，测试不同卡片类型对用户选购的影响。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在交互逻辑上，为了避免插入动画对用户选购的“干扰感”，也对比了“在点击卡片上覆盖”和“在点击卡片下方插入”两种交互，测试对于用户选购的影响。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;视频2 交互式推荐双商家卡片展示样式&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在观测不同产品形态的效果差异时，我们重点关注插入的交互式卡片对于首页Feed的千人成交额的影响，实验数据见下表：&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;126&quot; data-ratio=&quot;0.21726479146459748&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWQj5aLerxCKB7f5YLeCNsLk76sD5K7xlNDvEXqsRCsPPY19IFFxmia5SuCNS8sXibhltkQFYJUL5KQ/640?wx_fmt=jpeg&quot; data-w=&quot;1031&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;113&quot; data-ratio=&quot;0.19544259421560034&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWQj5aLerxCKB7f5YLeCNsLKtKCic94JQBdibDL44Q0wNNxqoFIib4PD921ibH5sCcW6H8szdeVSc7KaQ/640?wx_fmt=jpeg&quot; data-w=&quot;1141&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;其中，UV_CXR = 交易用户数/曝光人数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在探索过程中，我们也迭代了以下3点认知：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;223&quot; data-ratio=&quot;0.3860232945091514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWQj5aLerxCKB7f5YLeCNsLMyiaUJujohCD58cB48ibBccAicv0KplG9Y7VJiaFuiaGob7XUfKjlCtrghw/640?wx_fmt=jpeg&quot; data-w=&quot;601&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2 转化漏斗：多商家聚合卡片转化漏斗（左），单商家卡片转化漏斗（右）&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 评估方式和评估指标&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;交互式推荐的目标是提升首页Feed整体访购效率，进而提升用户体验。评估其收益的核心指标，落脚到首页Feed整体转化效率。然而，交互式推荐有触发策略约束条件（&lt;/span&gt;&lt;span&gt;详见3.3节&lt;/span&gt;&lt;span&gt;），流量占比也较低，同时和首页Feed在用户成单上存在“挤占”效应。当交互式卡片的访购效率有较大幅度提升时，才能撬动首页Feed的整体效率。因此，只观测首页Feed整体效率，无法指导交互式推荐的日常策略的迭代和效果的分析，需要更直接、置信的指标衡量“什么是好的交互式推荐算法”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们评估交互式推荐算法，主要考虑两个维度：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了应对以上两个维度的评估，我们分别引入“曝光页面Page占比”、“同位置订单增量”来衡量交互式推荐对首页Feed曝光的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;评估覆盖面，常见指标是曝光量、曝光占比。但交互式推荐卡片插入后会改变首页Feed曝光量，直接计算其在首页Feed的曝光占比不合理。因此，我们将统计曝光的维度从“量”改为“页面”，通过计算交互式卡片曝光Page数在首页曝光Page数的占比来评估卡片覆盖面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;观测Page占比（&lt;/span&gt;&lt;span&gt;下文简称“曝光页面Page占比”&lt;/span&gt;&lt;span&gt;）便于评估交互式推荐的覆盖面和其理论上限的差异，如果用户在首页Feed的每次点击商家都触发并展示交互式商家卡片，曝光Page占比和首页Feed的Page CTR（&lt;/span&gt;&lt;span&gt;曝光点击率&lt;/span&gt;&lt;span&gt;）等同。因此，结合首页Feed的Page CTR，我们就可以观察到交互式推荐覆盖面和其理论上限的差距，便于继续优化逼近上限。曝光页面page占比对同一页面多次触发不敏感，因此，我们引入了交互式卡片曝光PV占比（&lt;/span&gt;&lt;span&gt;交互式卡片曝光量占首页Feed曝光量的比值&lt;/span&gt;&lt;span&gt;）、曝光UV（&lt;/span&gt;&lt;span&gt;曝光交互式卡片的用户占首页Feed曝光用户的比值&lt;/span&gt;&lt;span&gt;）占比辅助观测对首页Feed的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;评估匹配度，常见指标是曝光到成单的转化率。我们认为，交互式推荐插入的商家应该比上下文中的其他商家更符合用户当前的兴趣。因此，最直观的指标就是对比交互式卡片和首页Feed其他卡片的转化率，但这两类卡片对比，会存在三种偏差：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;人群偏差&lt;/strong&gt;：交互式推荐曝光人群是产生过点击的用户，这部分用户群体的转化率天然高于“大盘”。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;位置偏差&lt;/strong&gt;：交互式推荐卡片由用户点击触发，由于排在前面的商家往往更容易被点击，因此交互式卡片的曝光位置相对更加靠前。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;资源类型偏差&lt;/strong&gt;：首页Feed列表涉及较多主题、广告等异构流量，大部分异构流量往往并不是从转化率出发进行排序。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;上述3个偏差，使得交互式卡片转化率天然比首页Feed其他卡片转化率高，因此简单比较交互式卡片和首页Feed正常卡片之间的差异并不能正确评估交互式推荐本身的价值。而交互式推荐的产品特性是将原来曝光在首页Feed的卡片依次往后挤压，因此只有当交互式推荐卡片的转化率高于原本该位置的卡片（&lt;/span&gt;&lt;span&gt;也就是后来被挤压到交互式卡片的下一位的卡片&lt;/span&gt;&lt;span&gt;）的时候，交互式推荐才能产生正面效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于此，我们使用“对比同一次请求内，与下一位自然商家预估转化率的相对差异”（&lt;/span&gt;&lt;span&gt;下文简称相对下一位差异&lt;/span&gt;&lt;span&gt;）来衡量推荐卡片的匹配度，“同请求”解决了人群偏差问题，“下一位”缓解位置偏差问题，“自然商家”解决了资源类型偏差问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，扩大覆盖面通常会引起匹配度的下降，为了平衡这两个指标，我们引入“相对下一位差异乘以交互式卡片曝光量”作为策略迭代的辅助观测指标，其物理意义是插入交互式卡片并将原来的卡片往下挤压之后，在该位置产生的预期订单数的增量（&lt;/span&gt;&lt;span&gt;下文简称“同位置订单增量”&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 用户意图理解&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;交互式推荐，由推荐系统感知到用户的“交互”触发。其理解用户意图的流程主要包含两个阶段：1）用户对推荐系统的哪些行为可以触发交互式推荐；2）触发交互式推荐时用户的即时意图是什么样的。下文将会围绕这两部分展开说明。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;3&quot; data-cropselx2=&quot;514&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;321&quot; data-ratio=&quot;0.6217616580310881&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWQj5aLerxCKB7f5YLeCNsLuwgpUIhUT0smcClFnU68ZljiaFj1HUogoMSNUElbnleMOGk9H1C238Q/640?wx_fmt=jpeg&quot; data-w=&quot;772&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3 用户意图理解引擎&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.1 首次触发策略&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;为了探索不同触发时机对交互式卡片“相对下一位差异”、“曝光页面Page占比”等指标的影响，我们根据用户的不同需求，尝试了加购物车、点击菜品、停留时长（&lt;/span&gt;&lt;span&gt;10s/5s/2s/进店立即&lt;/span&gt;&lt;span&gt;）触发等时机。实验证明，放宽触发条件会增大交互式推荐不置信触发的风险，导致交互式卡片效率下降，但会带来交互式卡片曝光量的提升，覆盖更多的用户，有利于后续策略迭代。最终，我们采用“用户从首页Feed进店后立即触发”的首次触发策略。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.2 连续触发策略&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;由于用户在商家详情页的停留时长无法确定，且工程上无法实现在用户返回列表的瞬间请求推荐服务并展示结果，因此，在用户浏览商家详情页期间，系统需要连续多次向服务端请求推荐结果，用户在商家详情页的停留时长越长、需求越明确，服务端的推荐结果也就越精准。所以，我们采用“连续触发策略”，即随着用户在店内停留时间的增加，或者用户产生新的菜品点击、加购特征后，客户端会连续多次向后端服务发起请求，更新推荐结果。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.3 用户实时需求理解&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;如何通过端智能&lt;sup&gt;[3-4]&lt;/sup&gt;更好理解用户意图是我们关注的重点，相比服务端，用户在端上的特征主要有以下2个特点：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;实时性更好&lt;/strong&gt;：从“准实时”到“超实时”的交互。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;维度更细&lt;/strong&gt;：从“交互Item”进化到“Item交互的Micro-粒度”。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因此，借助端智能的能力，我们不再受限于首页Feed的分页请求更新机制，能够根据用户行为，更好理解用户需求，实时智能决策更新推荐结果，缓解反馈信号感知延迟问题。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;用户点击商家卡片后在店内的主要行为可以帮助我们更好理解用户实时需求。图4(a)展示了部分店内行为，图4(b)分析了部分不同的行为对比查看商家介绍行为，在用户当日完单率（当日完单率定义：当日用户在商家内发生某一行为，并在该自然日内外卖有成单）上的差异，说明不同行为下用户的需求有明显差异。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.76796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWTVwS9I5Jib7BznZWWlQicogsuwMCOWG387TszH2QoEgANQIicaOMxiaM1iak30F6VLjv0OsDDbGglsMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;span&gt;图4(a) 用户店内主要行为&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.76875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWTVwS9I5Jib7BznZWWlQicogR5WUcuZTQX8ukE5bjSQA4pytiaL2U20fRr9R4GlvicqFN89fVUDdrbAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;span&gt;图4(b) 用户店内主要行为对比“查看评论”当日下单率差异&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.4 推荐排序策略&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首页Feed一次展示整个列表，而交互式推荐一次仅展示1个商家卡片。为了推荐更精准的结果，就需要交互式推荐更准确的理解用户实时的外卖需求。因此，我们在首页Feed的推荐链路的基础上，通过优化“召回-&amp;gt;排序-&amp;gt;机制-&amp;gt;透出”链路，覆盖更多用户的同时，不断提升交互式推荐和用户兴趣的匹配度。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.1 召回&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;召回阶段分为两步（&lt;/span&gt;&lt;span&gt;如下图5所示&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3805309734513274&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWQj5aLerxCKB7f5YLeCNsLBa6CYIs75nYb5ezne0WwicCzAB5FQJ10tQPa4NeuhiaEutDVm8qvicg3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;span&gt;图5 召回阶段流程图&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先，一方面，我们直接复用了首页Feed推荐的召回链路，融合了双塔召回&lt;sup&gt;[5]&lt;/sup&gt;、User2Item召回&lt;sup&gt;[6]&lt;/sup&gt;、热销召回等多个召回算法。另一方面，为了加强对用户即时意图的理解和关注，我们新增了一路Item2Item Multi-Trigger旁路召回。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体做法是：我们将用户在首页Feed点击、加购的POI，作为Item2Item召回的Trigger，召回更多符合用户即时意图的商家。其中每个用户的Trigger数是不同的，每个Trigger召回的商家数量也是不同的，其数量满足N/M（&lt;/span&gt;&lt;span&gt;N是I2I Multi-Trigger召回的POI总数，M是Trigger数量&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，用户最近点击的商家能够帮我们更好理解用户即时意图。我们考虑到外卖场景“对比型”用户居多的特点，为了给用户带来更好的体验，提出了“同叶子品类”策略：约束了曝光的交互式卡片商家，必须和触发商家的叶子品类（&lt;/span&gt;&lt;span&gt;体现的是商家口味，和主营菜品有关，比如串串香、鸡肉卷&lt;/span&gt;&lt;span&gt;）相同。但是该方案会带来2个问题：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LBS约束下同叶子品类商家较少，导致交互式卡片曝光量少。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;外卖场景下商家品类定义的粗细（&lt;/span&gt;&lt;span&gt;每个商家包含由粗到细的多个级别的品类&lt;/span&gt;&lt;span&gt;）粒度不同，交互式推荐需要一套统一的品类定义方式，既要保证推荐商家品类与用户兴趣的高相关性，又需要推荐结果有一定的多样性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因此，我们参考了现有商家品类定义，考虑了商家口味、消费者相似性以及商家包含的商品品类分布等维度，通过聚类的方法重新定义了交互式推荐的相似品类。具体来说，我们将200个左右的细粒度的品类，定义为70个左右的粗粒度品类，在满足“对比型”用户诉求的同时，也为更多用户带来了新颖性、多样性的体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们提出的策略，在明显提升交互式卡片曝光页面Page占比的同时，对比下一位差异明显提升，具体效果可以见下表：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;58&quot; data-ratio=&quot;0.18125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWQj5aLerxCKB7f5YLeCNsLtZjRLfBHKpQ07woLFfTuUkLYQEPhAOoqqKIibxzcJwFMJnJD6DLXibKg/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.2 排序&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;排序阶段，模型的主要任务是预测CTR、CXR（&lt;/span&gt;&lt;span&gt;曝光转化率&lt;/span&gt;&lt;span&gt;），并将预估结果传给机制阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优化交互式推荐的排序模型，我们主要面临样本分布差异、训练样本少的问题。交互式推荐的单商家卡片形态和首页Feed的列表形态天然有差异，导致其样本分布上（&lt;/span&gt;&lt;span&gt;如点击率、转化率、人群分布上&lt;/span&gt;&lt;span&gt;）明显不一致，直接使用首页Feed的推荐模型缺少对交互式推荐场景个性化的关注，效果会有明显衰减。简单的做法是直接使用交互式推荐的样本训练模型，但是交互式推荐单场景样本较少，会导致模型鲁棒性不足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，我们选择了业界通用的Fine-tune的方法，在首页Feed排序模型的基础上，利用交互式推荐的样本Fine-tune排序模型。同时，我们充分利用了3.3.3节构建的用户实时需求理解模块，优化模型效果。当然，我们也探索了不同网络结构对于模型效果的提升，但是限于算力资源等约束，我们并没有上线更为复杂的交互式推荐排序模型，具体的模型结构如下图6所示。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;469&quot; data-ratio=&quot;0.81015625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWQj5aLerxCKB7f5YLeCNsLcwpkUrpML7XSHAicY9boRRlslLJ1iaxs9ib4JGTxAJ5nWlGS7wHH8VCiaQ/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图6 模型结构图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;输入模型的Embdding数据，经过MMoE&lt;sup&gt;[7]&lt;/sup&gt;层和3层的MLP网络，得到预测的pCTR、pCXR结果。其中，模型的输入特征分为5种类型：1）用户特征；2）商家特征；3）上下文特征；4）序列特征；5）触发交互式推荐的商家特征。序列特征，包含了实时曝光、点击等序列，并且使用了Micro-Behavior&lt;sup&gt;[8]&lt;/sup&gt;详细信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;触发交互式推荐的商家特征，包含商家的embdding表示、配送信息、优惠信息等，&lt;/span&gt;&lt;span&gt;排序模型离/在线效果如下表所示。&lt;/span&gt;&lt;span&gt;可以看出，对比首页Feed排序模型，优化后的交互式推荐排序在卡片效率上显著优于直接使用首页Feed排序模型的效果。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;45&quot; data-ratio=&quot;0.23984375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWQj5aLerxCKB7f5YLeCNsL3ic2DQz0OdNawxdJGLhVz0GJs8j97lqsUKZJ7WMZ4qV6aeib3MmZ5aPQ/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.3 机制&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;为了更为灵活的承载业务目标，我们引入了机制模块，目标是对排序阶段传过来的候选商家，根据不同业务目标进行顺序调整（&lt;/span&gt;&lt;span&gt;如CTR、CXR、新颖性等&lt;/span&gt;&lt;span&gt;）。最终，在兼顾新颖性的目标下，交互式推荐按照预估CXR排序，以最大化卡片和列表转化率。与此同时，我们还从解决负面反馈、优化体验两方面进行了体验优化：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过业务规则约束来解决负面反馈，主要包括：重复曝光商家过滤、预下单商家过滤、同品牌商家过滤、用户不喜欢&amp;amp;黑名单商家过滤，以及避免插入配送费过高、配送距离过远的商家。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在交互体验方面：1)通过在新颖性等目标上的探索，给用户更丰富的推荐体验；2）通过推荐理由的优化，为用户解释推荐原因。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.4 透出&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;透出阶段，主要判断机制阶段传过来的Top 1的商家是否展示给用户。理论上，用户每次“触发”交互式推荐，系统都有可能推荐一个新的商家进行展示。但是，不考虑商家质量的推荐策略对用户体验和首页Feed效果都有很大损伤。因此，我们探索了卡片的透出策略，即机制阶段透传的Top 1卡片是否展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图7所示，商家展示区域划分为ABCD四个区域：交互式推荐插卡位置（&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;）、触发商家（&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;）、触发商家上文（&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;）、触发商家下文（&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;）。交互式卡片插入后，D区域第一位商家下滑，动画效果会将用户的注意力吸引到交互式卡片A上。但是，用户是否在交互式推荐的商家A中成单，不仅和它是否满足用户偏好相关，还离不开和上下文商家C、B、D的对比效果——至少，A应该比C、B、D区域的商家更符合用户当前意图。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;423&quot; data-ratio=&quot;0.7317436661698957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWQj5aLerxCKB7f5YLeCNsLzLrdc9NibxXXbgxrhzveC24dIZOIec2XnXiaYxJic8EQnv9eicibKAN4hZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;671&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图7 商家展示区域划分&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们更关注首页Feed的转化率，因此，当交互式推荐商家比同上下文的其他商家的pCXR更高时，这个商家才应该被曝光，其形式是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;&amp;#10;\begin{aligned}&amp;#10;&amp;#10;    \mathbf{pCXR}_{交互式推荐商家} &amp;gt;\alpha*\mathbf{pCXR}_{下一位商家}&amp;#10;&amp;#10;\end{aligned}&amp;#10;&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -810.4 17353.7 1120.8&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mtable&quot;&gt;&lt;g data-mml-node=&quot;mtr&quot; transform=&quot;translate(0, 60.4)&quot;&gt;&lt;g data-mml-node=&quot;mtd&quot;&gt;&lt;g data-mml-node=&quot;msub&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;70&quot; d=&quot;M32 442L123 446Q214 450 215 450H221V409Q222 409 229 413T251 423T284 436T328 446T382 450Q480 450 540 388T600 223Q600 128 539 61T361 -6H354Q292 -6 236 28L227 34V-132H296V-194H287Q269 -191 163 -191Q56 -191 38 -194H29V-132H98V113V284Q98 330 97 348T93 370T83 376Q69 380 42 380H29V442H32ZM457 224Q457 303 427 349T350 395Q282 395 235 352L227 345V104L233 97Q274 45 337 45Q383 45 420 86T457 224Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(639, 0)&quot;&gt;&lt;path data-c=&quot;43&quot; d=&quot;M64 343Q64 502 174 599T468 697Q502 697 533 691T586 674T623 655T647 639T657 632L694 663Q703 670 711 677T723 687T730 692T735 695T740 696T746 697Q759 697 762 692T766 668V627V489V449Q766 428 762 424T742 419H732H720Q699 419 697 436Q690 498 657 545Q611 618 532 632Q522 634 496 634Q356 634 286 553Q232 488 232 343T286 133Q355 52 497 52Q597 52 650 112T704 237Q704 248 709 251T729 254H735Q750 254 755 253T763 248T766 234Q766 136 680 63T469 -11Q285 -11 175 86T64 343Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1470, 0)&quot;&gt;&lt;path data-c=&quot;58&quot; d=&quot;M327 0Q306 3 174 3Q52 3 43 0H33V62H98L162 63L360 333L157 624H48V686H59Q80 683 217 683Q368 683 395 686H408V624H335L393 540L452 458L573 623Q573 624 528 624H483V686H494Q515 683 646 683Q769 683 778 686H787V624H658L575 511Q493 398 493 397L508 376Q522 356 553 312T611 229L727 62H835V0H824Q803 3 667 3Q516 3 489 0H476V62H513L549 63L401 274L247 63Q247 62 292 62H338V0H327Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2339, 0)&quot;&gt;&lt;path data-c=&quot;52&quot; d=&quot;M394 0Q370 3 222 3Q75 3 51 0H39V62H147V624H39V686H234Q256 686 299 686T362 687Q479 687 554 669T681 593Q716 550 716 497Q716 390 568 338Q569 337 572 336T577 332Q605 317 623 300T650 258T662 218T668 172Q678 98 689 76Q707 40 748 40Q770 40 780 54T795 88T801 111Q805 117 827 117H831Q846 117 852 113T858 92Q857 78 852 63T834 30T797 1T739 -11Q630 -11 580 12T511 87Q506 104 506 168Q506 170 506 178T507 194Q507 289 438 313Q424 318 356 318H298V62H406V0H394ZM366 369Q459 370 490 381Q548 402 548 476V498V517Q548 578 513 600Q479 624 392 624H358H298V369H366Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(3201, -229.4) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;交&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(935, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;互&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(1870, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;式&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(2805, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;推&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(3740, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;荐&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(4675, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;商&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(5610, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;家&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(8156.8, 0)&quot;&gt;&lt;path data-c=&quot;3E&quot; d=&quot;M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(9212.6, 0)&quot;&gt;&lt;path data-c=&quot;3B1&quot; d=&quot;M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(10074.8, 0)&quot;&gt;&lt;path data-c=&quot;2217&quot; d=&quot;M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(10797, 0)&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;70&quot; d=&quot;M32 442L123 446Q214 450 215 450H221V409Q222 409 229 413T251 423T284 436T328 446T382 450Q480 450 540 388T600 223Q600 128 539 61T361 -6H354Q292 -6 236 28L227 34V-132H296V-194H287Q269 -191 163 -191Q56 -191 38 -194H29V-132H98V113V284Q98 330 97 348T93 370T83 376Q69 380 42 380H29V442H32ZM457 224Q457 303 427 349T350 395Q282 395 235 352L227 345V104L233 97Q274 45 337 45Q383 45 420 86T457 224Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(639, 0)&quot;&gt;&lt;path data-c=&quot;43&quot; d=&quot;M64 343Q64 502 174 599T468 697Q502 697 533 691T586 674T623 655T647 639T657 632L694 663Q703 670 711 677T723 687T730 692T735 695T740 696T746 697Q759 697 762 692T766 668V627V489V449Q766 428 762 424T742 419H732H720Q699 419 697 436Q690 498 657 545Q611 618 532 632Q522 634 496 634Q356 634 286 553Q232 488 232 343T286 133Q355 52 497 52Q597 52 650 112T704 237Q704 248 709 251T729 254H735Q750 254 755 253T763 248T766 234Q766 136 680 63T469 -11Q285 -11 175 86T64 343Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1470, 0)&quot;&gt;&lt;path data-c=&quot;58&quot; d=&quot;M327 0Q306 3 174 3Q52 3 43 0H33V62H98L162 63L360 333L157 624H48V686H59Q80 683 217 683Q368 683 395 686H408V624H335L393 540L452 458L573 623Q573 624 528 624H483V686H494Q515 683 646 683Q769 683 778 686H787V624H658L575 511Q493 398 493 397L508 376Q522 356 553 312T611 229L727 62H835V0H824Q803 3 667 3Q516 3 489 0H476V62H513L549 63L401 274L247 63Q247 62 292 62H338V0H327Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2339, 0)&quot;&gt;&lt;path data-c=&quot;52&quot; d=&quot;M394 0Q370 3 222 3Q75 3 51 0H39V62H147V624H39V686H234Q256 686 299 686T362 687Q479 687 554 669T681 593Q716 550 716 497Q716 390 568 338Q569 337 572 336T577 332Q605 317 623 300T650 258T662 218T668 172Q678 98 689 76Q707 40 748 40Q770 40 780 54T795 88T801 111Q805 117 827 117H831Q846 117 852 113T858 92Q857 78 852 63T834 30T797 1T739 -11Q630 -11 580 12T511 87Q506 104 506 168Q506 170 506 178T507 194Q507 289 438 313Q424 318 356 318H298V62H406V0H394ZM366 369Q459 370 490 381Q548 402 548 476V498V517Q548 578 513 600Q479 624 392 624H358H298V369H366Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(3201, -229.4) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;下&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(935, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;一&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(1870, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;位&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(2805, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;商&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(3740, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;家&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;随后，有几个问题：对比B、C、D区域哪些商家？交互式推荐商家A的pCXR要比对比商家高多少（&lt;/span&gt;&lt;span&gt;通过公式1比例系数α控制&lt;/span&gt;&lt;span&gt;）才应该被展示？对于后者，我们通过实验得出；对于前者，我们分析如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;C区域：用户已经浏览过，点击/成单的可能性更低。显然，对比该区域商家意义不大。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;B区域：用户“最近一次点击”&amp;amp;&amp;amp;“触发交互式推荐”的商家，用户对该商家很感兴趣。与其比较看似有明确意义，但该商家能曝光，说明是同类/相似商家中的佼佼者，在排序模型/特征不做改动的前提下，难以找到pCXR更好的商家。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;D区域：用户未浏览到，交互式商家卡片A一旦展示，其插卡的动态效果同时会使得用户更注意该区域。因此，与这部分商家做对比更符合直觉。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;由于限制了卡片的透出条件，交互式卡片曝光量明显下降。实验证明，当交互式推荐卡片对比下1位商家卡片的pCXR更高时，其同位置订单增量最高，曝光页面Page占比损失最少，策略最优。我们采用该方案。从实验数据看出，对比下N位pCXR均值时，随着N取值的变化，会影响交互式卡片的曝光量和效率，其效果与直接调整pCXR的过滤阈值α等同。在实际生产环境中，选取“交互式推荐同位置订单增量”较高时的参数α即可，这里我们取1。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;78&quot; data-ratio=&quot;0.2234375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWQj5aLerxCKB7f5YLeCNsL3TOibLW8GEAic3WCsEpIVj1Uzox3COBueFdacu2PouGjsevoSuTypWaw/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; 4. 总结与展望 &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;本文介绍了我们在首页Feed交互式推荐探索尝试，其中主要包括：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;依托端智能的能力，结合外卖场景下的用户“多店对比”的选购特点，搭建了“动态插入单卡商家”的交互式推荐系统。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;充分考虑插入卡片对首页Feed上下文的影响，提出了“同位置订单增量”等指标，从匹配度、覆盖面两方面构建了“什么是好的交互式推荐系统”的评估方式。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从业务理解、用户需求建模等方面出发，通过优化“触发-&amp;gt;召回-&amp;gt;排序-&amp;gt;机制-&amp;gt;透出”链路，提升系统对用户意图理解的准度，优化用户体验。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;目前，交互式推荐已在首页Feed全量，我们也收获了如下的业务收益：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;首页Feed千人成交额+0.43%，首页Feed曝光新颖性+1.16%。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;交互式卡片相对下一位自然商家的转化率+132%。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;未来，我们将从以下方向进行探索优化：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;优化产品形态&lt;/strong&gt;：从定制推荐理由、触发时机等多个角度继续优化交互式推荐的产品功能，并将动态化推荐能力扩展到外卖其他场景。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;承载更多业务目标&lt;/strong&gt;：在满足用户精准推荐的前提下，综合新颖性、多样性等多种差异化的业务目标，进行建模优化。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;扩大端智能优势&lt;/strong&gt;：现有的交互式推荐系统将特征处理、召回、排序、机制等流程都放在服务端完成，但是服务端&amp;lt;-&amp;gt;云端的性能限制了更多信息的加工利用，未来可以放到端上完成训练、预估，在实现“千人千模”的极致个性化体验的同时，有效保护用户的隐私。与此同时，我们可以借助端智能的优势，探索端上重排序的方案。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; 5. 本文作者 &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;| 姬晨、亚成、王炜、成龙、姜飞、王聪、北海等，来自到家事业群/到家研发平台/搜索推荐技术部。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| 姝阳、张婧等，来自到家事业群/外卖事业部/产品部。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; 6. 参考文献 &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[1] Christakopoulou K, Beutel A, Li R, et al. Q&amp;amp;R: A two-stage approach toward interactive recommendation[C]//Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery &amp;amp; Data Mining. 2018: 139-148.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[2] Xinran He, Junfeng Pan, et al. Practical lessons from predicting clicks on ads at facebook. In Proceedings of the Eighth International Workshop on Data Mining for Online Advertising. ACM, 1–9, 2014.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[3] Gong Y, Jiang Z, Feng Y, et al. EdgeRec: recommender system on edge in Mobile Taobao[C]//Proceedings of the 29th ACM International Conference on Information &amp;amp; Knowledge Management. 2020: 2477-2484.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;a href=&quot;https://tech.meituan.com/2022/06/16/edge-search-rerank.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;端智能在大众点评搜索重排序的应用实践&lt;/span&gt;&lt;/a&gt;&lt;span&gt;.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[5] Po-Sen Huang, Xiaodong He, Jianfeng Gao, Li Deng, Alex Acero, and Larry Heck. 2013. Learning Deep Structured Semantic Models for Web Search Using Clickthrough Data (CIKM ’13). Association for Computing Machinery, New York, NY, USA, 2333–2338.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[6] Yue Shi, Martha Larson, and Alan Hanjalic. 2014. Collaborative Filtering beyond the User-Item Matrix: A Survey of the State of the Art and Future Challenges. ACM Comput. Surv. 47, 1, Article 3 (may 2014), 45 pages.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[7] Jiaqi Ma, Zhe Zhao, Xinyang Yi, Jilin Chen, Lichan Hong, and Ed H Chi. 2018. Modeling task relationships in multi-task learning with multi-gate mixture-of-experts. In Proceedings of the 24th ACM SIGKDD international conference on knowledge discovery &amp;amp; data mining. 1930–1939.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[8] &lt;/span&gt;&lt;a href=&quot;https://tech.meituan.com/2022/12/08/scenario-aware-ranking-model-for-personalized-recommender-system.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;美团外卖推荐情境化智能流量分发的实践与探索&lt;/span&gt;&lt;/a&gt;&lt;span&gt;.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[9] Zhou G, Zhu X, Song C, et al. Deep interest network for click-through rate prediction[C]//Proceedings of the 24th ACM SIGKDD international conference on knowledge discovery &amp;amp; data mining. 2018: 1059-1068.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt; 招聘信息 &lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-source=&quot;bj.96weixin.com&quot;&gt;&lt;section&gt;&lt;strong&gt;搜索推荐算法工程师&lt;/strong&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;发展大规模深度学习、图学习等技术，利用注意力机制、记忆网络、关系网络等模块，从跨多个时空场景的海量数据中理解用户需求、发掘用户兴趣，优化点击率、转化率模型，为用户展示更合适、更感兴趣的美食和商品。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;发展强化学习、可解释深度学习、多模态学习、多目标优化等技术，优化重排、混排模型，智能调控流量分发，优化平台生态，实现消费者和商家共赢。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用知识图谱、计算视觉、自然语言生成等技术，面向用户兴趣，帮助商家自动化智能生成展示内容和文案，提升推广效率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;追踪并研究人工智能前沿技术，探索技术在零售、医疗电商场景的应用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;感兴趣的同学可以将简历发送至：libeihai02@meituan.com。期待与大家一起共事，共创未来。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt; 推荐阅读 &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  | &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651772253&amp;amp;idx=1&amp;amp;sn=1fdafab23fa83337296ee4a7142d22fd&amp;amp;chksm=bd120c108a658506bc061778ad1722b202f03d3e38f7e7da7d5e94e4019361c1a69077cd6b5a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团外卖推荐智能流量分发的实践与探索&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651772253&amp;amp;idx=1&amp;amp;sn=1fdafab23fa83337296ee4a7142d22fd&amp;amp;chksm=bd120c108a658506bc061778ad1722b202f03d3e38f7e7da7d5e94e4019361c1a69077cd6b5a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团外卖推荐智能流量分发的实践与探索&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团外卖推荐智能流量分发的实践与探索&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651769148&amp;amp;idx=1&amp;amp;sn=d7d8e5d907f973dfb58c35aa4f17e084&amp;amp;chksm=bd1210718a6599675e912e7486e116b87f5be0af2ba47ad63c82f7498c104a58a1a9eb84ea5a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团综合业务推荐系统的质量模型及实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团综合业务推荐系统的质量模型及实践&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651767107&amp;amp;idx=1&amp;amp;sn=d39bc1dacfa831c88827187bab44a83e&amp;amp;chksm=bd12180e8a659118dc91a25fafafc75bcae5b37f324eeaa31eaddbfc85dbabd9f04cc13347ec&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;TensorFlow在美团外卖推荐场景的GPU训练优化实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;TensorFlow在美团外卖推荐场景的GPU训练优化实践&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MjM5NjQ5MTI5OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVGibnsaEib3aNlqF0tOrA2RGEmNSbia2nnohE4Tpf95UyTiaSjDVbHRfY8WNBeTuLLTaVdSckkNyEx1Q/0?wx_fmt=png&quot; data-nickname=&quot;美团技术团队&quot; data-alias=&quot;meituantech&quot; data-signature=&quot;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团优选等技术团队对外交流的窗口。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9fcf7a553d54962c7a8e890e82a8167c</guid>
<title>数据分析指北网站更新(2023)</title>
<link>https://toutiao.io/k/3680y9p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;strong&gt;数据分析指北网站地址&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;https://havef.fun 或 https://da.havef.fun&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8746238716148446&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FQdpHx6HeJx7OqOcfjUicINEZYGXbDraPMKnBvribLe7Xcdoxzt0yw5MibQZHw357z1nYMwV5qhEyWsSgd82pa4icA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为庆祝新书《KNIME 视觉化数据分析》出版，网站大更新一次。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;导航和内容&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;网站的导航设置的更加清晰:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;指北系列（旧）：介绍了一些数据分析的核心理念以及 KNIME 的基础内容&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《KNIME 视觉化数据分析》介绍：纸质书目录，方便了解书中包含的具体内容&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;博客：断断续续的一些和数据分析相关的所思所想&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;咨询：介绍付费咨询服务以及咨询前需要做的一些准备工作&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其他：和数据分析&quot;不直接相关&quot;的一些内容&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;技术升级&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;流程图、状态图等完全支持&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;3.0806451612903225&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FQdpHx6HeJx7OqOcfjUicINEZYGXbDraPyvBwiaCPXf0zLe7zodZdyvDhdtVKib7BNakzxYFNFgibPqGWG6Tmvib9tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;124&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;评论的支持&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;只需要有一个 GitHub 账号，就可以在每个文章的最下面对文章内容进行评论了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3755047106325707&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FQdpHx6HeJx7OqOcfjUicINEZYGXbDraPN6AylYicc6BQCj0bUbhebvtVHtqUhgVicuO1iaesxyyaDrribZL4xjxcUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;743&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;阅读体验&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;可视化能力&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;除了一些基本的图表外，对一些高级图表也进行了支持。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9174434087882823&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FQdpHx6HeJx7OqOcfjUicINEZYGXbDraPfSyVhkEkH7yCkX2VxbB676nGn11BiatQBE4icHdVhlHOiazibhQCNVeUibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;751&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7355704697986577&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FQdpHx6HeJx7OqOcfjUicINEZYGXbDraPbgwD0SxsJIyuy48zWTIMlcBFDQxqNE47R1VTb4VNkICtHWB9dqllbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;745&quot;/&gt;&lt;/p&gt;&lt;p&gt;happy reading &amp;amp; writing!&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f986b5770ae935f5fa0e2de4a41c19a0</guid>
<title>手写一个性能较好的拖拽排序（上）</title>
<link>https://toutiao.io/k/x90rz7n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拖拽排序是前端的常见需求，特别是在管理系统或者编辑器里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如低代码编辑器就支持把组件拖到页面不同位置来添加组件、调整顺序：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7027027027027027&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YprkEU0TtGhT3jXa239y3wACf5BGvw0Ea16iaNKicc8rF0utiazdFcCjcYOG3YTt8uLQ7RN69Kkvynl5EstbiafIug/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1998&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么拖拽排序是怎么实现的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们分析下它会用到啥事件：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较容易想到的是 mousedown、mouseup、mousemove 等事件，这是 pc 端的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在移动端对应的就是 touchstart、touchmove、touchend 等事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mouse、touch 事件都可以统一为 pointer 事件，也就是 pointerdown、pointermove、pointerup 等事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以基于 pointer 事件来实现兼容 pc 和移动端的拖拽排序的效果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36295369211514394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGhT3jXa239y3wACf5BGvw0ELqiba7mQsUia9p3DykKk2GYe7vczz1WH3vBn6xnOMbhneLyRUjwmbicsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1598&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但从 pointer 事件开始处理还是挺麻烦的，而且拖拽是个常见的需求，所以浏览器后来提供了 drag 事件，包括 dragstart、drag、dragend、dragover、drop 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以现在实现拖拽排序可以从 pointer 事件开始处理，也可以直接从 drag 事件开始处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种方式实现拖拽排序我们都试一下，今天先实现第一种方式，基于 pointer 事件的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来理一下思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拖拽和排序分开来看：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拖拽可以给元素设置 fixed 定位，pointermove 的时候根据指针位置改变元素的 x、y，这样就能实现元素跟随指针移动的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这样性能不好，一般这种位移我们会用 transform 的 translate3d(x, y, 0) 来做，3D 的 transform 会触发硬件加速，也就是使用 GPU 来计算，性能更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那排序呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排序就是改变 dom 元素的顺序，可以找到要移动到的位置的下一个元素，通过 insertBefore 插入到它之前。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5144312393887945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGhT3jXa239y3wACf5BGvw0EOiaCiaO7WpC5l67omVA5wPlABnwcX9GhF7NhhRTSfXPTtDT5Cn3nicoug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端框架渲染的时候也经常用到 insertBefore 来调整 dom 元素位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拖拽和排序我们都知道怎么做了，那两者结合起来呢？也就是如何在拖拽的时候判断出排序移动到的位置？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个也比较容易想到，根据拖动的时候的指针位置在哪个元素内部，来确定拖动到的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 getBoundingClientRect 的 api 来获取元素的宽高和位置：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31447963800904977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGhT3jXa239y3wACf5BGvw0Em0rkicicr3j0T0ry9KNNGM1Lia72zpVNvbbdVpjg2ppKQKNK7ORIWpXbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后判断下指针位置是不是在这里面，就可以知道拖到哪个元素了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过 insertBefore 插到它前面就行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9121338912133892&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YprkEU0TtGhT3jXa239y3wACf5BGvw0EFdqbDQN1Igo9hdSVgWwPjFbHhVU3hkQJHIy6tcl5OkCfrhWjEn9Qxw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;956&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是 translate3D 来拖拽 + insertBefore 来排序的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这个拖拽的元素是用 cloneNode 复制的一份新节点，拖拽完之后删掉它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过上面这种还是生硬了点，而且性能也不好，因为每次拖动到新元素的位置都是 insertBefore 来操作 dom。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们期望的效果是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8793456032719836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YprkEU0TtGhT3jXa239y3wACf5BGvw0EroKicCSjo2nibibWAqrGvjkibwR5c3vriaME71ZsjRs9d5jJhFTM6q8Eqvg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;978&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个过渡的动画。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是直接 insertBefore 改变了 dom 顺序，是没有这种过渡效果的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚才我们用到过 translate3d，这里是不是也可以通过 getBoundingClientRect 记录下各个元素的位置，然后把位置有变动的元素 translate3d 到对应的位置的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可以设置 transition 效果了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且更重要的是，拖拽过程中只做 translate3d 的 transform，不调用 insertBefore 修改 dom 顺序，最后拖拽完成之后再操作 dom。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 n 次 dom 操作变成了一次，这样拖拽排序的性能会好得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小结一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;拖拽的实现可以通过 cloneNode 复制一个元素，fixed 定位到它原本的位置，然后 pointermove 的时候设置 tanslate3D 的值来改变位置。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;移动是通过 insertBefore 改变 dom 顺序，移动到的元素可以通过拖拽时的指针位置和元素位置对比来确定。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但是直接移动 dom 太生硬，性能也不好，所以我们拖拽过程中用 translate3D 改变位置，加上 transition 效果，拖拽完成后再用 insertBefore 改变 dom 顺序。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;dom 的位置和宽高用 getBoundingClientRect 获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路理清了，我们来实现一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先准备一个容器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;    &amp;lt;meta charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;style&amp;gt;&lt;br/&gt;        .container {&lt;br/&gt;            width: 400px;&lt;br/&gt;            margin: 0 auto;&lt;br/&gt;            background: pink;&lt;br/&gt;            padding: 20px;&lt;br/&gt;        }&lt;br/&gt;   &amp;lt;/style&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;    &amp;lt;div class=&lt;span&gt;&quot;container&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21308016877637131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGhT3jXa239y3wACf5BGvw0E42z8TZEw91h9aaBGbE3qHOYEz3EOHNqZZMHjicstbqa6AL4u1MgkeIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;948&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加个列表：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;    &amp;lt;meta charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;style&amp;gt;&lt;br/&gt;        .container {&lt;br/&gt;            width: 400px;&lt;br/&gt;            margin: 0 auto;&lt;br/&gt;            background: pink;&lt;br/&gt;            padding: 20px;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        .list {&lt;br/&gt;            display: flex;&lt;br/&gt;            flex-wrap: wrap;&lt;br/&gt;            gap: 15px;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        .list-item {&lt;br/&gt;            width: 100px;&lt;br/&gt;            height: 100px;&lt;br/&gt;            border: 1px solid &lt;span&gt;#000;&lt;/span&gt;&lt;br/&gt;            background: &lt;span&gt;#fff;&lt;/span&gt;&lt;br/&gt;            line-height: 100px;&lt;br/&gt;            text-align: center;&lt;br/&gt;            list-style: none;&lt;br/&gt;            user-select: none;&lt;br/&gt;        }&lt;br/&gt;    &amp;lt;/style&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;    &amp;lt;div class=&lt;span&gt;&quot;container&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;ul class=&lt;span&gt;&quot;list&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;li class=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;111&amp;lt;/li&amp;gt;&lt;br/&gt;            &amp;lt;li class=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;222&amp;lt;/li&amp;gt;&lt;br/&gt;            &amp;lt;li class=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;333&amp;lt;/li&amp;gt;&lt;br/&gt;            &amp;lt;li class=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;444&amp;lt;/li&amp;gt;&lt;br/&gt;            &amp;lt;li class=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;555&amp;lt;/li&amp;gt;&lt;br/&gt;            &amp;lt;li class=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;666&amp;lt;/li&amp;gt;&lt;br/&gt;            &amp;lt;li class=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;777&amp;lt;/li&amp;gt;&lt;br/&gt;            &amp;lt;li class=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;888&amp;lt;/li&amp;gt;&lt;br/&gt;            &amp;lt;li class=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;999&amp;lt;/li&amp;gt;&lt;br/&gt;        &amp;lt;/ul&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8778004073319755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGhT3jXa239y3wACf5BGvw0E7PcKDQfkBkuGPXPp7qvwDBRH6yD9ibno7X50okibazpfSLPIibibzwVLeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;982&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后开始写拖拽排序的逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Draggable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    containerElement = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;constructor&lt;/span&gt;(options) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.containerElement = options.element;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.init();&lt;br/&gt;    }&lt;br/&gt;    init(){&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.bindEventListener();&lt;br/&gt;    }&lt;br/&gt;    onPointerDown(e) {&lt;br/&gt;    }&lt;br/&gt;    onPointerMove(e) {&lt;br/&gt;    }&lt;br/&gt;    onPointerUp(e) {&lt;br/&gt;    }&lt;br/&gt;    bindEventListener() {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.containerElement.addEventListener(&lt;span&gt;&#x27;pointerdown&#x27;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.onPointerDown.bind(&lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.containerElement.addEventListener(&lt;span&gt;&#x27;pointermove&#x27;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.onPointerMove.bind(&lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.containerElement.addEventListener(&lt;span&gt;&#x27;pointerup&#x27;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.onPointerUp.bind(&lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;封装一个拖拽的 class，传入容器元素，绑定 pointerdown、pointermove、pointerup 事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子元素触发的事件会冒泡到父元素，所以把事件监听器绑在父元素就行，性能还更好。这种方式叫做事件代理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后这样用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; Draggable({&lt;br/&gt;    &lt;span&gt;element&lt;/span&gt;: &lt;span&gt;document&lt;/span&gt;.querySelector(&lt;span&gt;&#x27;.list&#x27;&lt;/span&gt;)&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来开始写拖拽的逻辑：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先处理 pointerDown，在指针按下的时候复制一个新的元素出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们加一个 drag 属性来记录拖动的元素，加一个 clone 属性记录 clone 出来的元素：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Draggable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    containerElement = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    drag = { &lt;span&gt;element&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt; };&lt;br/&gt;    clone = { &lt;span&gt;element&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;constructor&lt;/span&gt;(options) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.containerElement = options.element;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.init();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pointerDown 的时候通过 event.target 就可以拿到拖动的元素：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Draggable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    containerElement = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    drag = { &lt;span&gt;element&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;};&lt;br/&gt;    clone = { &lt;span&gt;element&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;    onPointerDown(e) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.drag.element = e.target;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.drag.element.classList.add(&lt;span&gt;&#x27;active&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.clone.element = &lt;span&gt;this&lt;/span&gt;.drag.element.cloneNode(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;document&lt;/span&gt;.body.appendChild(&lt;span&gt;this&lt;/span&gt;.clone.element);&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.clone.element.className = &lt;span&gt;&#x27;clone-item&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给拖动的元素加一个 active 的 class。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后调用 cloneNode 复制一个新的 dom 节点出来，参数 true 是子节点也复制的意思。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给它添加一个 clone-item 的 class。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加的 active 的样式是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;.active&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;background&lt;/span&gt;: skyblue;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 clone-item 的样式是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;.clone-item&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;position&lt;/span&gt;: fixed;&lt;br/&gt;    &lt;span&gt;left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;top&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;z-index&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;100px&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;100px&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#000&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;background&lt;/span&gt;: &lt;span&gt;#fff&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;line-height&lt;/span&gt;: &lt;span&gt;100px&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;text-align&lt;/span&gt;: center;&lt;br/&gt;    &lt;span&gt;list-style&lt;/span&gt;: none;&lt;br/&gt;    &lt;span&gt;user-select&lt;/span&gt;: none;&lt;br/&gt;    &lt;span&gt;pointer-events&lt;/span&gt;: none;&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0.8&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是 fixed 定位，加上有一个 opcity 的透明度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就达到了这样的效果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9344262295081968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGhT3jXa239y3wACf5BGvw0EYjsV1ICOkzkJjV6NuZJgAs8rPvUZJewKJqMTk9pg3fiaXeN4F7Eia21Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后要修改它们的位置，我们把全部的元素位置都计算一遍，放到一个数组里：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Draggable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    containerElement = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    rectList = [];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;constructor&lt;/span&gt;(options) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.containerElement = options.element;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.init();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    init() {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.getRectList();&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.bindEventListener();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    getRectList() {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.rectList.length = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; item &lt;span&gt;of&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.containerElement.children) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.rectList.push(item.getBoundingClientRect());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化的时候遍历元素的 children，通过 getBoundingClientRect 取出每个元素的 x、y、width、height 保存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后 onPointerDown 的时候就可以设置 clone 出元素的位置了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Draggable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    containerElement = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    rectList = [];&lt;br/&gt;    drag = { &lt;span&gt;element&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;index&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;firstIndex&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;};&lt;br/&gt;    clone = { &lt;span&gt;element&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;    onPointerDown(e) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.drag.element = e.target;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.drag.element.classList.add(&lt;span&gt;&#x27;active&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.clone.element = &lt;span&gt;this&lt;/span&gt;.drag.element.cloneNode(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;document&lt;/span&gt;.body.appendChild(&lt;span&gt;this&lt;/span&gt;.clone.element);&lt;br/&gt;            &lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; index = [].indexOf.call(&lt;span&gt;this&lt;/span&gt;.containerElement.children, &lt;span&gt;this&lt;/span&gt;.drag.element);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.drag.index = index;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.drag.firstIndex = index;&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.clone.x = &lt;span&gt;this&lt;/span&gt;.rectList[index].left;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.clone.y = &lt;span&gt;this&lt;/span&gt;.rectList[index].top;&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.clone.element.style.transition = &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.clone.element.className = &lt;span&gt;&#x27;clone-item&#x27;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.clone.element.style.transform = &lt;span&gt;&#x27;translate3d(&#x27;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.clone.x + &lt;span&gt;&#x27;px, &#x27;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.clone.y + &lt;span&gt;&#x27;px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 children 中查找当前 drag 的元素的下标，取出它的 x、y，然后通过 translate3d 设置 clone 出的元素的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 firstIndex 记录 drag 的元素的开始位置下标，index 记录移动后的位置的下标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后再处理位置的变化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Draggable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    isPointerDown = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    drag = { &lt;span&gt;element&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;index&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;firstIndex&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; };&lt;br/&gt;    clone = { &lt;span&gt;element&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;x&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;y&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; };&lt;br/&gt;    diff = { &lt;span&gt;x&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;y&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; };&lt;br/&gt;    lastPointerMove = { &lt;span&gt;x&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;y&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;    onPointerDown(e) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.isPointerDown = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.lastPointerMove.x = e.clientX;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.lastPointerMove.y = e.clientY;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    onPointerMove(e) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.isPointerDown) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.diff.x = e.clientX - &lt;span&gt;this&lt;/span&gt;.lastPointerMove.x;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.diff.y = e.clientY - &lt;span&gt;this&lt;/span&gt;.lastPointerMove.y;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.lastPointerMove.x = e.clientX;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.lastPointerMove.y = e.clientY;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.clone.x += &lt;span&gt;this&lt;/span&gt;.diff.x;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.clone.y += &lt;span&gt;this&lt;/span&gt;.diff.y;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.clone.element.style.transform = &lt;span&gt;&#x27;translate3d(&#x27;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.clone.x + &lt;span&gt;&#x27;px, &#x27;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.clone.y + &lt;span&gt;&#x27;px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按下的时候记录一个标记 isPointerDown，之后按下的状态才处理 pointermove 事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记录开始和移动的位置 lastPointerMove，还有位置的变化，也就是 diff。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新设置 clone 的元素的 translate3d 的 x、y，就达到了拖拽的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后是重头戏了，拖拽的过程中要判断指针是否碰到了啥元素，相关的元素要做位移：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是在 pointermove 里处理的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;onPointerMove(e) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.isPointerDown) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.rectList.length; i++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (i !== &lt;span&gt;this&lt;/span&gt;.drag.index &amp;amp;&amp;amp;&lt;br/&gt;                e.clientX &amp;gt; &lt;span&gt;this&lt;/span&gt;.rectList[i].left &amp;amp;&amp;amp; e.clientX &amp;lt; &lt;span&gt;this&lt;/span&gt;.rectList[i].right &amp;amp;&amp;amp;&lt;br/&gt;                e.clientY &amp;gt; &lt;span&gt;this&lt;/span&gt;.rectList[i].top &amp;amp;&amp;amp; e.clientY &amp;lt; &lt;span&gt;this&lt;/span&gt;.rectList[i].bottom) {&lt;br/&gt;                &lt;span&gt;// 碰到了第 i 个元素&lt;/span&gt;&lt;br/&gt;                &lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.drag.index = i;&lt;br/&gt;            }&lt;br/&gt;        }        &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;碰撞检测的逻辑也挺简单，就是指针在的位置的 x 是否在 left 和 right 内，y 是否在 top 和 bottom 内。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且更新了 drag 元素的 index 位新的下标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;碰撞了之后呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就开始移动元素了，就像前面分析的，设置 translate3d 并且加上 transition 效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但也不是所有的元素都移动，只是在开始位置的 index 和结束位置的 index 之间的元素需要动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是如果 drag 的元素原来在前面，那就是这个区间内 firstIndex 之前的不动，之后的往前移（firstIndex 是 drag 的元素的初始下标，index 是当前下标）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.drag.index &amp;lt; i) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;this&lt;/span&gt;.drag.index; j &amp;lt; i; j++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ( j &amp;lt; &lt;span&gt;this&lt;/span&gt;.drag.firstIndex) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.containerElement.children[j].style.transform = &lt;span&gt;&#x27;translate3d(0px, 0px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;const&lt;/span&gt; x = &lt;span&gt;this&lt;/span&gt;.rectList[j].left - &lt;span&gt;this&lt;/span&gt;.rectList[j + &lt;span&gt;1&lt;/span&gt;].left;&lt;br/&gt;            &lt;span&gt;const&lt;/span&gt; y = &lt;span&gt;this&lt;/span&gt;.rectList[j].top - &lt;span&gt;this&lt;/span&gt;.rectList[j + &lt;span&gt;1&lt;/span&gt;].top;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.containerElement.children[j + &lt;span&gt;1&lt;/span&gt;].style.transform = &lt;span&gt;&#x27;translate3d(&#x27;&lt;/span&gt; + x + &lt;span&gt;&#x27;px, &#x27;&lt;/span&gt; + y + &lt;span&gt;&#x27;px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.referenceElement = &lt;span&gt;this&lt;/span&gt;.containerElement.children[i + &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记录要 insertBefore 的目标元素，也就是它后面的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 drag 的元素原来在后面，那就是这个区间内的 firstIndex 之后的不动，之前的往后移：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.drag.index &amp;gt; i) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = i; j &amp;lt; &lt;span&gt;this&lt;/span&gt;.drag.index; j++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.drag.firstIndex &amp;lt;= j) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.containerElement.children[j + &lt;span&gt;1&lt;/span&gt;].style.transform = &lt;span&gt;&#x27;translate3d(0px, 0px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;const&lt;/span&gt; x = &lt;span&gt;this&lt;/span&gt;.rectList[j + &lt;span&gt;1&lt;/span&gt;].left - &lt;span&gt;this&lt;/span&gt;.rectList[j].left;&lt;br/&gt;            &lt;span&gt;const&lt;/span&gt; y = &lt;span&gt;this&lt;/span&gt;.rectList[j + &lt;span&gt;1&lt;/span&gt;].top - &lt;span&gt;this&lt;/span&gt;.rectList[j].top;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.containerElement.children[j].style.transform = &lt;span&gt;&#x27;translate3d(&#x27;&lt;/span&gt; + x + &lt;span&gt;&#x27;px, &#x27;&lt;/span&gt; + y + &lt;span&gt;&#x27;px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.referenceElement = &lt;span&gt;this&lt;/span&gt;.containerElement.children[i];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后移动它自己：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; x = &lt;span&gt;this&lt;/span&gt;.rectList[i].left - &lt;span&gt;this&lt;/span&gt;.rectList[&lt;span&gt;this&lt;/span&gt;.drag.firstIndex].left;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; y = &lt;span&gt;this&lt;/span&gt;.rectList[i].top - &lt;span&gt;this&lt;/span&gt;.rectList[&lt;span&gt;this&lt;/span&gt;.drag.firstIndex].top;&lt;br/&gt;&lt;span&gt;this&lt;/span&gt;.drag.element.style.transform = &lt;span&gt;&#x27;translate3d(&#x27;&lt;/span&gt; + x + &lt;span&gt;&#x27;px, &#x27;&lt;/span&gt; + y + &lt;span&gt;&#x27;px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;this&lt;/span&gt;.drag.index = i;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就实现了拖拽过程中的元素移动效果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8795180722891566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YprkEU0TtGhT3jXa239y3wACf5BGvw0EGw7FXGXibULgFXicH8Eibcx9HYqcZyRMY7h1eCTGdZIcZufrb6re0MGEg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;996&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在没有设置 transition，在 onPointerDown 里设置下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; item &lt;span&gt;of&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.containerElement.children) {&lt;br/&gt;    item.style.transition = &lt;span&gt;&#x27;transform 500ms&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在就平滑多了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8629032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YprkEU0TtGhT3jXa239y3wACf5BGvw0EmbcmRHTukkBRhb89Tn8Z3dibfocBib5y6ydSsICicia8GWcCwBuYzZVZSA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;992&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拖拽的过程做完了，最后再处理下指针释放的时候的元素移动就好了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;onPointerUp(e) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.isPointerDown) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.isPointerDown = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.referenceElement !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.containerElement.insertBefore(&lt;span&gt;this&lt;/span&gt;.drag.element, &lt;span&gt;this&lt;/span&gt;.referenceElement);&lt;br/&gt;        }&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.drag.element.classList.remove(&lt;span&gt;&#x27;active&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.clone.element.remove();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; item &lt;span&gt;of&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.containerElement.children) {&lt;br/&gt;            item.style.transition = &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;;&lt;br/&gt;            item.style.transform = &lt;span&gt;&#x27;translate3d(0px, 0px, 0px)&#x27;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行 insertBefore 改变元素位置，并且把所有的元素的位移置 0，删除 clone 出的用于拖拽的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样放手之后元素就完成了移动：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8962655601659751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YprkEU0TtGhT3jXa239y3wACf5BGvw0ENIZBSVtn2pVNGSu4SnqhGLpAiaSSUurYAczHye0WJia0DW84bTCbs7Ag/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;964&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，一个性能比较好的拖拽排序就完成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全部代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!DOCTYPE &lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;meta&lt;/span&gt; &lt;span&gt;charset&lt;/span&gt;=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;        &lt;span&gt;.container&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;400px&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;margin&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; auto;&lt;br/&gt;            &lt;span&gt;background&lt;/span&gt;: pink;&lt;br/&gt;            &lt;span&gt;padding&lt;/span&gt;: &lt;span&gt;20px&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;.list&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;display&lt;/span&gt;: flex;&lt;br/&gt;            &lt;span&gt;flex-wrap&lt;/span&gt;: wrap;&lt;br/&gt;            &lt;span&gt;gap&lt;/span&gt;: &lt;span&gt;15px&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;.list-item&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;100px&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;100px&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#000&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;background&lt;/span&gt;: &lt;span&gt;#fff&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;line-height&lt;/span&gt;: &lt;span&gt;100px&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;text-align&lt;/span&gt;: center;&lt;br/&gt;            &lt;span&gt;list-style&lt;/span&gt;: none;&lt;br/&gt;            &lt;span&gt;user-select&lt;/span&gt;: none;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;.active&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;background&lt;/span&gt;: skyblue;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;.clone-item&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;position&lt;/span&gt;: fixed;&lt;br/&gt;            &lt;span&gt;left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;top&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;z-index&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;100px&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;100px&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#000&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;background&lt;/span&gt;: &lt;span&gt;#fff&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;line-height&lt;/span&gt;: &lt;span&gt;100px&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;text-align&lt;/span&gt;: center;&lt;br/&gt;            &lt;span&gt;list-style&lt;/span&gt;: none;&lt;br/&gt;            &lt;span&gt;user-select&lt;/span&gt;: none;&lt;br/&gt;            &lt;span&gt;pointer-events&lt;/span&gt;: none;&lt;br/&gt;            &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0.8&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;ul&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;list&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;li&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;111&lt;span&gt;&amp;lt;/&lt;span&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;li&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;222&lt;span&gt;&amp;lt;/&lt;span&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;li&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;333&lt;span&gt;&amp;lt;/&lt;span&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;li&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;444&lt;span&gt;&amp;lt;/&lt;span&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;li&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;555&lt;span&gt;&amp;lt;/&lt;span&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;li&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;666&lt;span&gt;&amp;lt;/&lt;span&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;li&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;777&lt;span&gt;&amp;lt;/&lt;span&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;li&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;888&lt;span&gt;&amp;lt;/&lt;span&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;li&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;list-item&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;999&lt;span&gt;&amp;lt;/&lt;span&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Draggable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            containerElement = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            rectList = [];&lt;br/&gt;            isPointerDown = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            drag = { &lt;span&gt;element&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;index&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;firstIndex&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; };&lt;br/&gt;            clone = { &lt;span&gt;element&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;x&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;y&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; };&lt;br/&gt;            diff = { &lt;span&gt;x&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;y&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; };&lt;br/&gt;            referenceElement = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            lastPointerMove = { &lt;span&gt;x&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;y&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;constructor&lt;/span&gt;(options) {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.containerElement = options.element;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.init();&lt;br/&gt;            }&lt;br/&gt;            init() {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.getRectList();&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.bindEventListener();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            getRectList() {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.rectList.length = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; item &lt;span&gt;of&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.containerElement.children) {&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.rectList.push(item.getBoundingClientRect());&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            onPointerDown(e) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (e.pointerType === &lt;span&gt;&#x27;mouse&#x27;&lt;/span&gt; &amp;amp;&amp;amp; e.button !== &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (e.target === &lt;span&gt;this&lt;/span&gt;.containerElement) {&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.isPointerDown = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.containerElement.setPointerCapture(e.pointerId);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.lastPointerMove.x = e.clientX;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.lastPointerMove.y = e.clientY;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.drag.element = e.target;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.drag.element.classList.add(&lt;span&gt;&#x27;active&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;const&lt;/span&gt; index = [].indexOf.call(&lt;span&gt;this&lt;/span&gt;.containerElement.children, &lt;span&gt;this&lt;/span&gt;.drag.element);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.drag.index = index;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.drag.firstIndex = index;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.clone.x = &lt;span&gt;this&lt;/span&gt;.rectList[index].left;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.clone.y = &lt;span&gt;this&lt;/span&gt;.rectList[index].top;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.clone.element = &lt;span&gt;this&lt;/span&gt;.drag.element.cloneNode(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;document&lt;/span&gt;.body.appendChild(&lt;span&gt;this&lt;/span&gt;.clone.element);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.clone.element.style.transition = &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.clone.element.className = &lt;span&gt;&#x27;clone-item&#x27;&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.clone.element.style.transform = &lt;span&gt;&#x27;translate3d(&#x27;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.clone.x + &lt;span&gt;&#x27;px, &#x27;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.clone.y + &lt;span&gt;&#x27;px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; item &lt;span&gt;of&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.containerElement.children) {&lt;br/&gt;                    item.style.transition = &lt;span&gt;&#x27;transform 500ms&#x27;&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            onPointerMove(e) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.isPointerDown) {&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.diff.x = e.clientX - &lt;span&gt;this&lt;/span&gt;.lastPointerMove.x;&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.diff.y = e.clientY - &lt;span&gt;this&lt;/span&gt;.lastPointerMove.y;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.lastPointerMove.x = e.clientX;&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.lastPointerMove.y = e.clientY;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.clone.x += &lt;span&gt;this&lt;/span&gt;.diff.x;&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.clone.y += &lt;span&gt;this&lt;/span&gt;.diff.y;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.clone.element.style.transform = &lt;span&gt;&#x27;translate3d(&#x27;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.clone.x + &lt;span&gt;&#x27;px, &#x27;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.clone.y + &lt;span&gt;&#x27;px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.rectList.length; i++) {&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (i !== &lt;span&gt;this&lt;/span&gt;.drag.index &amp;amp;&amp;amp; e.clientX &amp;gt; &lt;span&gt;this&lt;/span&gt;.rectList[i].left &amp;amp;&amp;amp; e.clientX &amp;lt; &lt;span&gt;this&lt;/span&gt;.rectList[i].right &amp;amp;&amp;amp;&lt;br/&gt;                            e.clientY &amp;gt; &lt;span&gt;this&lt;/span&gt;.rectList[i].top &amp;amp;&amp;amp; e.clientY &amp;lt; &lt;span&gt;this&lt;/span&gt;.rectList[i].bottom) {&lt;br/&gt;                            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.drag.index &amp;lt; i) {&lt;br/&gt;                                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;this&lt;/span&gt;.drag.index; j &amp;lt; i; j++) {&lt;br/&gt;                                    &lt;span&gt;if&lt;/span&gt; ( j&amp;lt;&lt;span&gt;this&lt;/span&gt;.drag.firstIndex) {&lt;br/&gt;                                        &lt;span&gt;this&lt;/span&gt;.containerElement.children[j].style.transform = &lt;span&gt;&#x27;translate3d(0px, 0px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;                                    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                                        &lt;span&gt;const&lt;/span&gt; x = &lt;span&gt;this&lt;/span&gt;.rectList[j].left - &lt;span&gt;this&lt;/span&gt;.rectList[j + &lt;span&gt;1&lt;/span&gt;].left;&lt;br/&gt;                                        &lt;span&gt;const&lt;/span&gt; y = &lt;span&gt;this&lt;/span&gt;.rectList[j].top - &lt;span&gt;this&lt;/span&gt;.rectList[j + &lt;span&gt;1&lt;/span&gt;].top;&lt;br/&gt;                                        &lt;span&gt;this&lt;/span&gt;.containerElement.children[j + &lt;span&gt;1&lt;/span&gt;].style.transform = &lt;span&gt;&#x27;translate3d(&#x27;&lt;/span&gt; + x + &lt;span&gt;&#x27;px, &#x27;&lt;/span&gt; + y + &lt;span&gt;&#x27;px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;                                    }&lt;br/&gt;                                }&lt;br/&gt;                                &lt;span&gt;this&lt;/span&gt;.referenceElement = &lt;span&gt;this&lt;/span&gt;.containerElement.children[i + &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;                            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.drag.index &amp;gt; i) {&lt;br/&gt;                                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = i; j &amp;lt; &lt;span&gt;this&lt;/span&gt;.drag.index; j++) {&lt;br/&gt;                                    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.drag.firstIndex &amp;lt;= j) {&lt;br/&gt;                                        &lt;span&gt;this&lt;/span&gt;.containerElement.children[j + &lt;span&gt;1&lt;/span&gt;].style.transform = &lt;span&gt;&#x27;translate3d(0px, 0px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;                                    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                                        &lt;span&gt;const&lt;/span&gt; x = &lt;span&gt;this&lt;/span&gt;.rectList[j + &lt;span&gt;1&lt;/span&gt;].left - &lt;span&gt;this&lt;/span&gt;.rectList[j].left;&lt;br/&gt;                                        &lt;span&gt;const&lt;/span&gt; y = &lt;span&gt;this&lt;/span&gt;.rectList[j + &lt;span&gt;1&lt;/span&gt;].top - &lt;span&gt;this&lt;/span&gt;.rectList[j].top;&lt;br/&gt;                                        &lt;span&gt;this&lt;/span&gt;.containerElement.children[j].style.transform = &lt;span&gt;&#x27;translate3d(&#x27;&lt;/span&gt; + x + &lt;span&gt;&#x27;px, &#x27;&lt;/span&gt; + y + &lt;span&gt;&#x27;px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;                                    }&lt;br/&gt;                                }&lt;br/&gt;                                &lt;span&gt;this&lt;/span&gt;.referenceElement = &lt;span&gt;this&lt;/span&gt;.containerElement.children[i];&lt;br/&gt;                            }&lt;br/&gt;                            &lt;span&gt;const&lt;/span&gt; x = &lt;span&gt;this&lt;/span&gt;.rectList[i].left - &lt;span&gt;this&lt;/span&gt;.rectList[&lt;span&gt;this&lt;/span&gt;.drag.firstIndex].left;&lt;br/&gt;                            &lt;span&gt;const&lt;/span&gt; y = &lt;span&gt;this&lt;/span&gt;.rectList[i].top - &lt;span&gt;this&lt;/span&gt;.rectList[&lt;span&gt;this&lt;/span&gt;.drag.firstIndex].top;&lt;br/&gt;                            &lt;span&gt;this&lt;/span&gt;.drag.element.style.transform = &lt;span&gt;&#x27;translate3d(&#x27;&lt;/span&gt; + x + &lt;span&gt;&#x27;px, &#x27;&lt;/span&gt; + y + &lt;span&gt;&#x27;px, 0)&#x27;&lt;/span&gt;;&lt;br/&gt;                            &lt;span&gt;this&lt;/span&gt;.drag.index = i;&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            onPointerUp(e) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.isPointerDown) {&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.isPointerDown = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.drag.element.classList.remove(&lt;span&gt;&#x27;active&#x27;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.clone.element.remove();&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; item &lt;span&gt;of&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.containerElement.children) {&lt;br/&gt;                        item.style.transition = &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;;&lt;br/&gt;                        item.style.transform = &lt;span&gt;&#x27;translate3d(0px, 0px, 0px)&#x27;&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.referenceElement !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.containerElement.insertBefore(&lt;span&gt;this&lt;/span&gt;.drag.element, &lt;span&gt;this&lt;/span&gt;.referenceElement);&lt;br/&gt;     }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            bindEventListener() {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.containerElement.addEventListener(&lt;span&gt;&#x27;pointerdown&#x27;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.onPointerDown.bind(&lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.containerElement.addEventListener(&lt;span&gt;&#x27;pointermove&#x27;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.onPointerMove.bind(&lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.containerElement.addEventListener(&lt;span&gt;&#x27;pointerup&#x27;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.onPointerUp.bind(&lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;window&lt;/span&gt;.addEventListener(&lt;span&gt;&#x27;scroll&#x27;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.getRectList.bind(&lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;                &lt;span&gt;window&lt;/span&gt;.addEventListener(&lt;span&gt;&#x27;resize&#x27;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.getRectList.bind(&lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;                &lt;span&gt;window&lt;/span&gt;.addEventListener(&lt;span&gt;&#x27;orientationchange&#x27;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.getRectList.bind(&lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Draggable({&lt;br/&gt;            &lt;span&gt;element&lt;/span&gt;: &lt;span&gt;document&lt;/span&gt;.querySelector(&lt;span&gt;&#x27;.list&#x27;&lt;/span&gt;)&lt;br/&gt;        });&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拖拽排序是常见的需求，它有两种实现方式，一种是通过 pointer 事件（mouse、touch 事件）封装，一种是基于 drag 事件封装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章我们实现了基于 pointer 事件的拖拽排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心流程是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pointerdown 的时候 clone 一个新元素，pointermove 的时候改变它的 translate3d 来实现拖拽，pointerup 的时候删掉它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 getBoundingClientRect 取出每个元素的位置，pointermove 的时候判断指针在哪个元素，然后通过 translate3d 移动前后位置之间的元素，还要设置 transition 的过渡效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后 pointerup 的时候通过 insertBefore 完成元素移动，也就是排序的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自始至终，我们只改变了一次 dom 顺序，拖拽过程中只是设置了 translate 位置，这种实现方式性能会比较好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们基于 pointer 事件实现的拖拽排序还不错，那基于 drag 事件实现是怎样的呢？有啥区别呢？这个下篇文章再聊。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>27ea505b160b59194329dd824034e6f5</guid>
<title>Golang 编程“珠玑”</title>
<link>https://toutiao.io/k/oaoy42i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ go run gc.&lt;span class=&quot;code-snippet__function&quot;&gt;go&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__title&quot;&gt;HeapSys&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(bytes)&lt;/span&gt;,&lt;span class=&quot;code-snippet__title&quot;&gt;PoolSize&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(MiB)&lt;/span&gt;,&lt;span class=&quot;code-snippet__title&quot;&gt;HeapAlloc&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(MiB)&lt;/span&gt;,&lt;span class=&quot;code-snippet__title&quot;&gt;HeapInuse&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(MiB)&lt;/span&gt;,&lt;span class=&quot;code-snippet__title&quot;&gt;HeapIdle&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(bytes)&lt;/span&gt;,&lt;span class=&quot;code-snippet__title&quot;&gt;HeapReleased&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(bytes)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 12222464,     5.00,     7.11,     7.45,  4415488,  4300800&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 16384000,    10.00,    12.11,    12.45,  3334144,  3153920&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 24772608,    18.00,    20.11,    20.45,  3334144,  3121152&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 28966912,    22.00,    24.11,    24.45,  3334144,  3121152&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 33161216,    25.00,    27.11,    27.45,  4382720,  4169728&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 37355520,    32.00,    34.11,    34.45,  1236992,   991232&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 41549824,    36.00,    38.11,    38.45,  1236992,   991232&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 54132736,    48.00,    50.11,    50.45,  1236992,   991232&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 58327040,    51.00,    53.11,    53.45,  2285568,  2039808&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>