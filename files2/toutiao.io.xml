<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b9a75daddd7cc795152e15000a60bb23</guid>
<title>搜索中常见数据结构与算法探究（二）</title>
<link>https://toutiao.io/k/x07oz64</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;本文介绍了几个常见的匹配算法，通过算法过程和算法分析介绍了各个算法的优缺点和使用场景，并为后续的搜索文章做个铺垫；读者可以通过比较几种算法的差异，进一步了解匹配算法演进过程以及解决问题的场景；KMP算法和Double-Array TireTree是其中算法思想的集大成者，希望读者重点关注。&lt;/p&gt;

&lt;h3&gt;1 前言&lt;/h3&gt;

&lt;p&gt;上文探究了数据结构和算法的一些基础和部分线性数据结构和部分简单非线性数据结构，本文我们来一起探究图论，以及一些字符串模式匹配的高级数据结构和算法。【搜索中常见数据结构与算法探究（一）】（&lt;a href=&quot;https://developer.jdcloud.com/article/2153%EF%BC%89&quot;&gt;https://developer.jdcloud.com/article/2153）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;搜索作为企业级系统的重要组成部分，越来越发挥着重要的作用，ES已经成为每个互联网企业必备的工具集。而作为搜索的基础部分，文本匹配的重要性不言而喻。文本匹配不仅为精确搜索提供了方法，而且为模糊匹配提供了算法依据。比如相似度算法，最大搜索长度算法都是在匹配算法的基础上进行了变种和改良。&lt;/p&gt;

&lt;h3&gt;2 图论基础&lt;/h3&gt;

&lt;h4&gt;2.1 图的基本概念&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/403411cc-ca76-4737-bc44-5dffbaba979b20220325143547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以我们物流的抽象模型为例：每个配送中心是一个顶点，由两个顶点表示的配送中心间如果存在一条干线运输线，那么这两个顶点就用一条边连接。边可以由一个权，表示时间、距离和运输的成本。我们愿意迅速确定任何两个配送中心的最佳线路。这里的“最佳”可以是指最少边数的路径，也即经过的配送中心最少；也可以是对一种或所有权总量度所算出的最佳者。&lt;/p&gt;

&lt;h4&gt;2.2 图的表示方法&lt;/h4&gt;

&lt;p&gt;我们考虑实用情况，以有向图为例：&lt;br/&gt;
我们假设可以以省会城市开始对顶点编号。如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/1544c0cd-6307-47a2-a35f-1429aef7a75720220325143625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1）邻接矩阵&lt;br/&gt;
表示图的一种简单的方法是使用一个二维数据，称为邻接矩阵表示法。有一个二维数组A，对于每条边（u，v），置A[u][v]等于true；否则数组元素就是false。如果边有一个权，那么可以置A[u][v]等于该权，而使用很大或者很小的权作为标记表示不存在的边。虽然这种表示方法的优点是简单，但是，它的空间复杂度为θ（|V|^2）,如果图的边不是很多（稀疏的），那么这种表示的代价就太大了。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* &amp;lt;p/&amp;gt;
* Description: 使用邻接矩阵的图表示法
* &amp;lt;p/&amp;gt;
* Company: &amp;lt;a href=www.jd.com&amp;gt;京东&amp;lt;/a&amp;gt;
*
* @author &amp;lt;a href=mailto:pankun8@jd.com&amp;gt;pankun8&amp;lt;/a&amp;gt;
* @date 2021/11/11 15:41
*/
@Data
@NoArgsConstructor
public class Graph&amp;lt;T extends Node&amp;gt;{
/**
* 图的节点数
*/
private int n;

/**
* 图
*/
private T[] data;

/**
* 是否是有向图
*/
private Boolean directed;

/**
* 邻接矩阵
*/
private int[][] matrix;

public Graph(T[] data , Boolean directed){
this.n = data.length;
this.data = data;
this.directed = directed;
matrix = new int[n][n];
}


public void init(T[] data , Boolean directed){
this.n = data.length;
this.data = data;
this.directed = directed;
matrix = new int[n][n];
}
/**
*
* @param v 起点
* @param w 终点
* @param value 权重
*/
public void addEdge(int v , int w , int value){
if((v &amp;gt;=0 &amp;amp;&amp;amp; v &amp;lt; n) &amp;amp;&amp;amp; (w &amp;gt;= 0 &amp;amp;&amp;amp; w &amp;lt; n)){
if(hasEdge(v,w) == value){
return;
}
matrix[v][w] = value;
if(!this.directed){
matrix[w][v] = value;
}
n ++;
}
}

//判断两个节点中是否以及存在边
public int hasEdge(int v, int w){
if((v &amp;gt;=0 &amp;amp;&amp;amp; v &amp;lt; n) &amp;amp;&amp;amp; (w &amp;gt;= 0 &amp;amp;&amp;amp; w &amp;lt; n)){
return matrix[v][w];
}
return 0;
}

/**
* 状态转移函数
* @param index
* @param value
* @return
*/
public int stateTransfer(int index , int value){
int[] matrix = this.matrix[index];
for (int i = 0; i &amp;lt; matrix.length; i++) {
if(matrix[i] == value){
return i;
}
}
return Integer.MAX_VALUE;
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）邻接表&lt;br/&gt;
如果图是稀疏的，那么更好的解决办法是使用邻接表。&lt;/p&gt;

&lt;h4&gt;2.3 图的搜索算法&lt;/h4&gt;

&lt;p&gt;从图的某个订单出发，访问途中的所有顶点，并且一个顶点只能被访问一次。图的搜索（遍历）算法常见的有两种，如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  深度优先搜索算法（DFS）&lt;/li&gt;
&lt;li&gt;  广度优先搜索算法（BFS）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;3 数据结构与算法&lt;/h3&gt;

&lt;h4&gt;3.1 BF（Brute Force）算法&lt;/h4&gt;

&lt;p&gt;3.1.1 算法介绍&lt;/p&gt;

&lt;p&gt;BF（Brute Force）算法也可以叫暴力匹配算法或者朴素匹配算法。&lt;/p&gt;

&lt;p&gt;3.1.2 算法过程&lt;/p&gt;

&lt;p&gt;在讲解算法之前，我们先定义两个概念，方便后面讲解。他们分别是主串（S）和模式串（P）。比如说要在字符串A中查找字符串B，那么A就是主串，B就是模式串。我们把主串的长度记作n，模式串的长度记作m，并且n&amp;gt;m。算法过程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/3143bdd7-2e8e-4cd3-a665-94b44cdcc23d20220325144225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.1.3 算法分析&lt;/p&gt;

&lt;p&gt;BF算法从很“暴力”，当然也就比较简单，好懂，但是响应的性能也不高极端情况下时间复杂度函数为O(m*n)。&lt;br/&gt;
尽管理论上BF算法的时间复杂度很高，但在实际的开发中，它却是一个比较常用的字符串匹配算法，主要原因有以下两点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  朴素字符串匹配算法思想简单，代码实现也非常简单，不容易出错，容易调试和修改。&lt;/li&gt;
&lt;li&gt;  在实际的软件开发中，模式串和主串的长度都不会太长，大部分情况下，算法执行的效率都不会太低。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;3.2 RK（Rabin-Karp）算法&lt;/h4&gt;

&lt;p&gt;3.2.1 算法介绍&lt;/p&gt;

&lt;p&gt;RK算法全程叫Rabin-Karp算法，是有它的两位发明者Rabin和Karp的名字来命名，这个算法理解并不难，他其实是BF算法的升级版。&lt;/p&gt;

&lt;p&gt;3.2.2 算法过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/dbd5cdf1-7f05-48eb-96fa-e960381cf71d20220325144341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.2.3 算法分析&lt;/p&gt;

&lt;p&gt;在BF算法中当字符串不匹配时，需要比对每一个字符，如果不能匹配则重新调整I，J的值重新比对每一个字符，RK的思路是将模式串进行哈希算法得到s=hash(P)，然后将主串分割成n-m+1个子串，分别对其进行hash算法，然后逐个和s进行比对，减少逐个字符串比对的次数。其中hash函数的具体实现可自行选择。&lt;br/&gt;
整个RK算法包含两部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  计算模式串哈希和子串的哈希；&lt;/li&gt;
&lt;li&gt;  模式串哈希和子串哈希的比较；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一部分的只需要扫描一遍主串就能计算出所有子串的哈希值，这部分的时间复杂度是O(n)。模式串哈希值与每个子串哈希之间的比较的时间复杂度是O(1)，总共需要比对n-m+1次，所以这部分的时间复杂度为O(n)。所以RK算法的整体时间复杂度为O(n)。&lt;/p&gt;

&lt;h4&gt;3.3 KMP算法&lt;/h4&gt;

&lt;p&gt;3.3.1 算法介绍&lt;/p&gt;

&lt;p&gt;KMP算法是一种线性时间复杂度的字符串匹配算法，它是对BF(Brute-Force)算法的改进。KMP算法是由D.E.Knuth与V.R.Partt和J.H.Morris一起发现的，因此人们称它为Knuth-Morris-Pratt算法，简称KMP算法。&lt;/p&gt;

&lt;p&gt;前面介绍了BF算法，缺点就是时间消耗很大，KMP算法的主要思想就是：在匹配过程中发生匹配失败时，并不是简单的将模式串P的下标J重新置为0，而是根据一些匹配过程中得到的信息跳过不必要的匹配，从而达到一个较高的匹配效率。&lt;/p&gt;

&lt;p&gt;3.3.2 算法过程&lt;/p&gt;

&lt;p&gt;在介绍KMP算法之前，首先介绍几个字符串的概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  &lt;strong&gt;前缀：&lt;/strong&gt;不包含最后一个字符的所有以第一个字符开头的连续子串；&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;后缀&lt;/strong&gt;：不包含第一个字符的所有以最后一个字符结尾的连续子串；&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;最大公共前后缀&lt;/strong&gt;：前缀集合与后缀集合中长度最大的子串；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如字符串abcabc&lt;br/&gt;
前缀集合是a，ab，abc，abca，abcab&lt;br/&gt;
后缀集合为bcabc，cabc，abc，bc，c&lt;br/&gt;
最大公共前后缀为abc&lt;/p&gt;

&lt;p&gt;KMP算法的过程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/2f9c309b-b127-4c05-a4c9-384a61e0162420220325144526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么为什么KMP算法会知道在匹配失败时下标J回溯的那个位置呢？其实KMP算法在匹配的过程中将维护一些信息来帮助跳过不必要的匹配，这个信息就是KMP算法的重点，next数组也叫做fail数据或者前缀数据。下面我们来分析next数组的由来&lt;/p&gt;

&lt;p&gt;对于模式串P的每个元素P[j]，都存在一个实数k，使得模式串P开头的k个字符(P[0]P[1]…P[k-1])依次于P[j]前面的k(P[j-k]P[j-k+1]…P[j-1])个字符相同。如果这样的k有多个，则取最大的一个。模式串P中的每个位置j的字符都存在这样的信息，采用next数组表示，即next[j]=MAX{k}。&lt;/p&gt;

&lt;p&gt;从上述定义中可看到next(j)的逻辑意义就是求P[0]P[1]…P[j-1]的最大公共前后缀长度。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void genNext(Integer[] next , String p){
int j = 0 , k = -1;
char[] chars = p.toCharArray();
next[0] = -1;
while(j &amp;lt; p.length() - 1){
if(k == -1 || chars[j] == chars[k]){
j++;k++;
next[j] = k;
}else{
k = next[k];//此处为理解难点
}
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面分析next的求解过程：&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;特殊情况&lt;/strong&gt;&lt;br/&gt;
当j的值为0或者1的时候，它们的k值都为0，即next(0) = 0 、next(1) = 0。为了后面k值计算的方便，我们将next(0)的值设置为-1。&lt;br/&gt;
2）&lt;strong&gt;当P[j]==P[k]的情况&lt;/strong&gt;&lt;br/&gt;
当P[j]==P[k]时，必然有P[0]…P[k-1]==P[j-k]…P[j-1]，因此有P[0]…P[k]==P[j-k]…P[j]，这样就有next(j+1)=k+1。&lt;br/&gt;
3）&lt;strong&gt;当P[j]!=P[k]的情况&lt;/strong&gt;&lt;br/&gt;
当P[j]!=P[k]时，必然后next(j)=k，并且next(j+1)&amp;lt;k；也就是说P[0]…P[k-1]=P[j-k]…P[j-1]，因此此时k值需要向左移动重新进行匹配，next数组的作用就是在匹配失败时进行下标左移，所以k=next(k)进行下一轮循环。&lt;br/&gt;
4）&lt;strong&gt;算法优化&lt;/strong&gt;&lt;br/&gt;
上述算法有一个小问题就是当P[k]匹配失败后会跳转到next(k)继续进行匹配，但是此时有可能P[k]=P[next(k)]，此时匹配肯定是失败的所以对上述代码进行改进如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void genNext(Integer[] next , String p){
int j = 0 , k = -1;
char[] chars = p.toCharArray();
next[0] = -1;
while(j &amp;lt; p.length() - 1){
if(k == -1 || chars[j] == chars[k]){
j++;k++;
if(chars[j] == chars[k]){
next[j] = next[k];//如果两个相等
}else{
next[j] = k;
}
}else{
k = next[k];
}
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.3.3 算法分析&lt;/p&gt;

&lt;p&gt;KMP算法通过消除主串指针的回溯提高匹配的效率，整个算法分为两部分，next数据的求解，以及字符串匹配，从上一节的分析可知求解next数组的时间复杂度为O(m)，匹配算法的时间复杂度为O(n)，整体的时间复杂度为O(m+n)。KMP算法不是最快匹配算法，却是名气最大的，使用的范围也非常广。&lt;/p&gt;

&lt;h4&gt;3.4 BM算法&lt;/h4&gt;

&lt;p&gt;3.4.1 算法介绍&lt;/p&gt;

&lt;p&gt;Boyer-Moore字符串搜索算法是一种非常高效的字符串搜索算法。它由Bob Boyer和J Strother Moore发明，有实验统计它的性能是KMP算法的3-4倍。&lt;/p&gt;

&lt;p&gt;3.4.2 算法过程&lt;/p&gt;

&lt;p&gt;前面介绍的BF，KMP的算法的匹配过程虽然模式串的回溯过程不同，但是相同点都是从左往右逐个字符进行匹配，而BM算法则是采用的从右向左进行匹配，借助坏字符规则（SKip(j)）和好后缀（Shift(j)）规则，能够进行快速匹配。其中坏字符和好后缀示意如下图&lt;br/&gt;
&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/d720b9d3-c70c-4da6-8d19-087d0908098820220325144821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1）坏字符规则：在BM算法从右向左扫描的过程中，若发现某个字符S[i]不匹配时，则按照如下两种情况进行处理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  如果字符S[i]在模式串P中没有出现，那么从字符S[i]开始的m个文本显然是不可能和P匹配成功，直接全部跳过该区域。&lt;/li&gt;
&lt;li&gt;  如果字符S[i]在模式串P中出现，则以该字符进行对齐。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2）好后缀规则：在BM算法中，若发现某个字符不匹配的同时，已有部分字符匹配成功，则按照如下两种情况进行处理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  如果已经匹配的子串在模式串P中出现过，且子串的前一个字符和P[j]不相同，则将模式串移动到首次出现子串的前一个位置。&lt;/li&gt;
&lt;li&gt;  如果已经匹配的子串在模式串P中没有出现过，则找到已经匹配的子串最大前缀，并移动模式串P到最大前缀的前一个字符。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BM算法过程如下：&lt;br/&gt;
&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/ae00334a-aed0-497a-ba4b-f9c57e25a92620220325144939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.4.3 算法分析&lt;/p&gt;

&lt;p&gt;在BM算法中，如果匹配失败则取SKip(j)与Shift(j)中的较大者作为跳跃的距离。BM算法预处理阶段的复杂度为O(m+n)，搜索阶段的最好的时间复杂度为O(n/m)，最坏的时间复杂为为O(n*m)。由于BM算法采用的是后缀匹配算法，并且通过坏字符和好后缀共同作用下，可以跳过不必要的一些字符，具体Shift(j)的求解过程可参看KMP算法的next()函数过程。&lt;/p&gt;

&lt;h4&gt;3.5 TireTree&lt;/h4&gt;

&lt;p&gt;3.5.1 算法介绍&lt;/p&gt;

&lt;p&gt;在《搜索中常见的数据结构与算法探究（一）》中，我们介绍过一种树状的数据结构叫做HashTree，本章介绍的TireTree就是HashTree的一个变种。TireTree又叫做字典树或者前缀树，典型的应用是用于统计和排序大量的字符串，所以经常被搜索系统用于文本的统计或搜索。&lt;/p&gt;

&lt;p&gt;TireTree的核心思想是空间换时间。TrieTree是一种高效的索引方法，它实际上是一种确定有限自动机(DFA)，利用字符串的公共前缀来降低查询时间的开销以达到提高查询效率的目的，非常适合多模式匹配。TireTree有以下基本性质：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  根节点不包含字符，除根节点外每个节点都包含一个字符。&lt;/li&gt;
&lt;li&gt;  从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。&lt;/li&gt;
&lt;li&gt;  每个节点对应的所有子节点包含的字符都不相同。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.5.2 算法过程&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TireTree构建与查询&lt;/strong&gt;&lt;br/&gt;
我们以《搜索中常见的数据结构与算法探究（一）》案例二中提到的字谜单词为例，共包含this、two、fat和that四个单词，我们来探究一下TireTree的构建过程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/cd4ccf2e-2086-4507-8bb9-268c7286231220220325145101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上述过程描述了that，two，fat，that四个单词的插入TireTree的过程，其中黄色的节点代表有单词存在。由于TireTree的构建的过程是树的遍历，所以查询过程和创建过程可以视为一个过程。&lt;/p&gt;

&lt;h4&gt;3.5.3 算法分析&lt;/h4&gt;

&lt;p&gt;TireTree由于本身的特性非常适合前缀查找个普通查找，并且查询的时间复杂度为O(log(n))，和hash比较在一些场景下性能要优于甚至取代hash，例如说前缀查询（hash不支持前缀查询）。&lt;/p&gt;

&lt;p&gt;虽然TireTree的查询速度会有一定的提升但是缺不支持后缀查询，并且TireTree对空间利用率不高，且对中文的支持有限。&lt;/p&gt;

&lt;h4&gt;3.6 AC自动机&lt;/h4&gt;

&lt;p&gt;3.6.1 算法介绍&lt;/p&gt;

&lt;p&gt;AC自动机（Aho-Corasick automation）该算法在1975年产生于贝尔实验室，是著名的多模匹配算法之一。要搞懂AC自动机，先得有TireTree和KMP模式匹配算法的基础知识，上述章节有TireTree和KMP算法的详细介绍。&lt;/p&gt;

&lt;p&gt;3.6.2 算法过程&lt;/p&gt;

&lt;p&gt;AC自动机的构建过程需要如下步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  TireTree的构建，请参看TireTree章节&lt;/li&gt;
&lt;li&gt;  fail指针的构建 - 使当前字符失配时跳转到具有最长公共前后缀的字符继续匹配。如同 KMP算法一样， AC自动机在匹配时如果当前字符匹配失败，那么利用fail指针进行跳转。由此可知如果跳转，跳转后的串的前缀，必为跳转前的模式串的后缀并且跳转的新位置的深度一定小于跳之前的节点。fail指针的求解过程可是完全参照KMP算法的next指针求解过程，此处不再赘述。&lt;/li&gt;
&lt;li&gt;  AC自动机查找 - 查找过程和TireTree相同，只是在查找失败的时候感觉fail指针跳转到指定的位置继续进行匹配。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.6.3 算法分析&lt;/p&gt;

&lt;p&gt;AC自动机利用fail指针阻止了模式串匹配阶段的回溯，将时间复杂度优化到了O(n)。&lt;/p&gt;

&lt;h4&gt;3.7 Double-Array-TireTree&lt;/h4&gt;

&lt;p&gt;3.7.1 算法介绍&lt;/p&gt;

&lt;p&gt;前面提到过TireTree虽然很完美，但是空间利用率很低，虽然可以通过动态分配数组来解决这个问题。为了解决这个问题我们引入Double-Array-TireTree，顾名思义Double-Array-TireTree就是TireTree压缩到两个一维数组BASE和CHECK来表示整个树。Double-Array-TireTree拥有TireTree的所有优点，而且刻服了TireTree浪费空间的不足，使其应用范围更加广泛，例如词法分析器，图书搜索，拼写检查，常用单词过滤器，自然语言处理 中的字典构建等等。&lt;/p&gt;

&lt;p&gt;3.7.2 算法过程&lt;/p&gt;

&lt;p&gt;在介绍算法之前，我们提前简单介绍一个概念DFA（下一篇详细介绍）。DFA（Deterministic Finite State）有限自动机，通俗来讲DFA是指给定一个状态和一个输入变量，它能转到的下一个状态也就确定下来，同时状态是有限的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Double-Array-TireTree构建&lt;/strong&gt;&lt;br/&gt;
Double-Array-TireTree终究是一个树结构，树结构的两个重要的要素便是前驱和后继，把树压缩在双数组中，只需要保持能查到每个节点的前驱和后继。首先要介绍几个重要的概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  STATE：状态，实际是在数组中的下标&lt;/li&gt;
&lt;li&gt;  CODE：状态转移值，实际为转移字符的值&lt;/li&gt;
&lt;li&gt;  BASE：标识后继节点的基地址数组&lt;/li&gt;
&lt;li&gt;  CHECK：标识前驱节点的地址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从上面的概念的可以理解如下规则，假设一个输入的字符为c，状态从s转移到t&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  state[t] = base[state[s]] + code[c]&lt;/li&gt;
&lt;li&gt;  check[state[t]] = state[s]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;构建的过程大概也分为两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  动态输入词语，动态构建双数组&lt;/li&gt;
&lt;li&gt;  已知所有词语，静态构建双数组&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们以静态构建过为核心，我们以《搜索中常见的数据结构与算法探究（一）》案例二中提到的字谜单词为例，共包含this、two、fat和that四个单词为例，其中涉及都的字符集{a,f,h,i,o,s,t,w}共8个字符，为了后续描述方便，我们对这个八个字符进行编码，分别是a-1,f-2,h-3,i-4,o-5,s-6,t-7,w-8&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构建this，如下图&lt;/strong&gt;&lt;br/&gt;
&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/865491f2-a08a-4058-ba65-0728acdc220920220325145424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构建two，如下图&lt;/strong&gt;&lt;br/&gt;
&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/c929f74e-136c-46eb-99c6-5fa1f358be0920220325145449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构建fat，如下图&lt;/strong&gt;&lt;br/&gt;
&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/12f5762f-3720-4951-a50e-a026673d97da20220325145512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构建that，如下图&lt;/strong&gt;&lt;br/&gt;
&lt;img src=&quot;https://img1.jcloudcs.com/developer.jdcloud.com/a002cd70-818c-4627-b946-ce8edef2abac20220325145536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Double-Array-TireTree查询&lt;/strong&gt;&lt;br/&gt;
验证this是否在范围内如下过程&lt;br/&gt;
1）state[t] = base[state[null]]+code[t]= 0 + 7=7&lt;br/&gt;
check[7]=state[null]=0&lt;strong&gt;通过&lt;/strong&gt;&lt;br/&gt;
2）state[th] = base[state[t]]+code[h]=base[7]+3 =2+3=5&lt;br/&gt;
check[5]= state[t] = 7&lt;strong&gt;通过&lt;/strong&gt;&lt;br/&gt;
3）state[tha] = base[state[th]]+ code[a]=base[5]+1=5+1=6&lt;br/&gt;
check[6]=state[th]=5&lt;strong&gt;通过&lt;/strong&gt;&lt;br/&gt;
4）state[that] = base[state[tha]]+t = base[6]+7=11&lt;br/&gt;
check[11]=state[tha]=6&lt;strong&gt;通过&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;3.7.3 算法分析&lt;/p&gt;

&lt;p&gt;通过两个数据base和check将TireTree的数据压缩到两个数组中，既保留了TireTree的搜索的高效，又充分利用了存储空间。&lt;/p&gt;

&lt;h4&gt;3.8 其他数据结构&lt;/h4&gt;

&lt;p&gt;鉴于篇幅有限，DFA，FSA以及FST将在下一篇文章中再来一起讨论，敬请期待！&lt;/p&gt;

&lt;h3&gt;4 参考资料&lt;/h3&gt;

&lt;p&gt;参考书籍&lt;br/&gt;
《数据结构与算法分析：java语言描述》&lt;br/&gt;
《自动机理论、语言和计算导论》&lt;/p&gt;

&lt;p&gt;本篇文章对本系列的上一篇文章的常见数据结构做了补充，介绍了非线性数据结构的最后一种，图数据结构作为基本数据结构最复杂的一种，在多种企业级应用中都有使用，如网络拓扑，流程引擎，流程编排；另外本文重点介绍了几种常见的匹配算法，以及算法的演进过程和使用场景，为下一篇的主题，也是本系列的重点探究的目标，“搜索”做一个铺垫，敬请期待！&lt;/p&gt;

&lt;p&gt;作者： 潘坤 郑冰 曹东杰&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>df5d5ec099f091e2f10f85259855651b</guid>
<title>Paxos 选举出一个Leader 解决活锁，可是如果在存在 Leader 为什么要使用 Paxos?</title>
<link>https://toutiao.io/k/2bbd05t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2949547218628719&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxt327ybUOV0mEIPWEYAszrbTYOzzTeibNynwpNTSkcUtc2Ftjx0WVe8oGa3P9IL5wh65aoBUf4OIzOnKW9eCWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;773&quot;/&gt;&lt;/p&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;YqO7yZI8&quot;&gt;&lt;/p&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;YqO7yZI8&quot;&gt;解答题主的疑惑，需要先了解引入Leader的推导过程（即multi-paxos的推导过程），跟题主明确两个概念，basic-paxos（存在活锁）、multi-paxos（引入Leader）。&lt;/p&gt;&lt;h2 data-into-catalog-status=&quot;&quot;&gt;推导过程&lt;/h2&gt;&lt;p data-pid=&quot;lX6lLlgj&quot;&gt;我们知道basic-paxos存在活锁，并且需要两个阶段才能达成共识。因为这两个局限，我们推导出multi-paxos。&lt;/p&gt;&lt;h3 data-into-catalog-status=&quot;&quot;&gt;活锁（引入Leader）&lt;/h3&gt;&lt;p data-pid=&quot;JJE9rBVc&quot;&gt;活锁导致原因是因为，存在多个proposer发起提案，导致多个提案之间互相干扰，使得最终没有任何提案达成共识。&lt;/p&gt;&lt;p data-pid=&quot;bX9q0PQl&quot;&gt;解决这个问题，最简单的方案，自然是引入&lt;span&gt;（并非一个）&lt;/span&gt;权威的成员，即Leader，只允许权威的成员发起提案。减少了发起提案成员的数量，提案相互干扰的概率自然也会降低。&lt;/p&gt;&lt;p data-pid=&quot;aRnBrMAN&quot;&gt;而这里提到的Leader，并非是一个全局唯一的强Leader，与题主理解的Leader稍有不同，在multi-paxos中允许存在同时存在多个Leader，如果引入一个强Leader，那确实有其他的算法可以替代，例如：Raft。所以在multi-paxos中，Leader是一个集合，它是Proposer的子集。&lt;/p&gt;&lt;p data-pid=&quot;cE2tSlLP&quot;&gt;因为多个Leader同时存在的缘故，Leader仅仅是为了降低活锁的概率，因此并不能完全规避活锁。&lt;/p&gt;&lt;p data-pid=&quot;vMg_eSb0&quot;&gt;另外，同时存在多个Leader会不会影响算法的正确性？不会，只要每个Leader按照preare → accept执行协商过程，最终正确性仍然可以保证，因为拥有最高的提案编号的多数派最多只会有一个，而其他更低提案编号的提案将不会达成共识。&lt;/p&gt;&lt;h3 data-into-catalog-status=&quot;&quot;&gt;需要两个阶段才能达成共识（省略prepare）&lt;/h3&gt;&lt;p data-pid=&quot;3HhhxFC2&quot;&gt;引入Leader后，我们可以很快的观察到，当没有提案干扰（即：只存在一个Leader）的情况，prepare阶段是非必须的。&lt;/p&gt;&lt;p data-pid=&quot;2dUMdUmp&quot;&gt;因为prepare阶段是用来协商提案编号的，而协商提案编号的目的是为了争取该提案编号发起提案的所有权。当只有一个Leader A存在的情况，没有其他成员和该Leader A争取发起提案的所有权，所以Leader A可以直接进入accept阶段，而跳过prepare阶段。当其他Leader B获取下一个提案编号的所有权后，那么Leader A的accept阶段，就不会获取到多数派的支持，从而重新进入prepare阶段。&lt;/p&gt;&lt;p data-pid=&quot;J7axq28l&quot;&gt;而这就是multi-paxos的协商过程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>43b9e8c9c0735e56174ddad115f4bbbb</guid>
<title>风控决策引擎——决策流构建实战</title>
<link>https://toutiao.io/k/zr21r1r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;h2&gt;引言&lt;/h2&gt;&lt;p&gt;本篇主要聚焦介绍风控决策引擎中决策树编排能力的构建。决策引擎是风控的大脑，而决策树的编排能力和体验是构建大脑的手段，如何构建&lt;strong&gt;高效&lt;/strong&gt;、&lt;strong&gt;丝滑&lt;/strong&gt;、&lt;strong&gt;稳定可靠&lt;/strong&gt;的决策树编排能力，是对风控决策引擎的一大挑战，本篇文章和大家分享一下过往构建心得。&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;任何系统在初期构建肯定不是往“&lt;strong&gt;一步到位&lt;/strong&gt;”的方向去构建的，只是架构设计者尽量向后期&lt;strong&gt;可扩展&lt;/strong&gt;、&lt;strong&gt;可维护&lt;/strong&gt;的方向去搭建。好的底层设计，不怕产品后期疯狂迭代，且改动调整方便。糟糕的“&lt;strong&gt;填鸭式&lt;/strong&gt;”代码，可能在当时为了尽快实现了功能，最终也会逐步发展成“&lt;strong&gt;屎山&lt;/strong&gt;”，维护成本越来越高，要么跑路，要么只能另起炉灶。&lt;/p&gt;&lt;h3&gt;MVP 小步迭代 1.0&lt;/h3&gt;&lt;p&gt;此阶段目标：&lt;strong&gt;最小化可行产品（MVP）；小布迭代，快速上线；一人分饰多角色。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;风控部门成立初期，人员少，缺少 UED 和 前端，毕竟风控本身对视觉设计和前端不是刚需，主要是后端研发和策略运营对抗黑产即可。此时为了能尽快上线决策树功能，研发人员本着&lt;strong&gt;小步快跑&lt;/strong&gt;的思想，直接在代码层资源目录 &lt;code&gt;resource&lt;/code&gt; 下放置决策树静态配置文件（具体实现在下文分解），每次更改都需要发版。本身引擎的构建也是不完善的，需要添加的功能很多，一周发个几版也是家常便饭的事，此阶段大家也是能接受的。&lt;/p&gt;&lt;h3&gt;“由静转动”2.0&lt;/h3&gt;&lt;p&gt;此阶段目标： &lt;strong&gt;无需发版，生产快速变更；稳定性相关考虑。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;随着部门队伍的逐步壮大，以及研发流程的规范，风控策略运营人员对于决策编排的&lt;strong&gt;响应时效&lt;/strong&gt;和&lt;strong&gt;可视化能力&lt;/strong&gt;需求越来越迫切，对于研发需要发版才能部署新的决策&lt;strong&gt;能力现状不满&lt;/strong&gt;，黑产是高效的，但是研发发版又是需要编排和时间的，大家都要发版，且集中在一个发版周期，策略周一提出的修改，待到周三和大家的需求一起上，此时黑产早撸完跑路了。同时发版是有一定的风险的，出错了需要立即回滚，此时又延误了策略上线的时间。&lt;/p&gt;&lt;p&gt;基于上述，我们考虑到是时候开放生产环境直接可视化的编排决策树能力了，但是我们没有前端的同学，找别的部门借可能又不熟悉决策引擎这一套流程规范，沟通成本还高。那折中了一个方案：将静态配置文件挪到 DB 存储中去，且配置以文本字符的形式展现在前端即可，不需要复杂的前端设计，只需要简单的表单文本框填充即可满足研发修改决策流的诉求。这样&lt;strong&gt;让原本静态的配置“动”起来&lt;/strong&gt;，直接在生产可配置，&lt;strong&gt;大大提高了生产部署的效率&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;可视化决策流编排 3.0&lt;/h3&gt;&lt;p&gt;此阶段目标：&lt;strong&gt;高效、稳定、智能的可视化决策树编排能力产品构建&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;接入风控的业务线越来越多，研发人员忙于风险场景对应的变量开发迭代，此时还需要分出一部分精力负责修改决策树。2.0 版本的决策树对运营来说就是一段字符串，不是一棵树，策略运营是没办法修改，也不敢修改，出错的风险太大。考虑到整个风控的体量和模式已经非常稳定了，也有一定的时间去考虑将决策编排做成一个可视化的产品&lt;strong&gt;交付策略人员使用&lt;/strong&gt;了，毕竟决策树的调整本身也是策略的职责之一，需要将此&lt;strong&gt;沉淀为一个高可用的产品&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;我们参照了业内 &lt;code&gt;BPMN&lt;/code&gt; 工作流的前端样式设计规范，摘取了在风控决策树种需要用到的元素，构建了自己的决策引擎智能编排能力，可视化的拖拽节点，&lt;strong&gt;可完全交付&lt;/strong&gt;给策略人员自行配置使用。&lt;/p&gt;&lt;h2&gt;设计实现&lt;/h2&gt;&lt;h3&gt;技术选型&lt;/h3&gt;&lt;p&gt;决策树，实际上就是一个变种 &lt;strong&gt;DAG（有向无环图）&lt;/strong&gt;，图中的节点在业务层面有不同的属性及功能。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30919220055710306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859yl3FVnvL8iaQsBY76PNfeeEA8AicMmqqob6sQmCnCxcmOC1picLpzibpc4NOzLSxpgTjqV7vQp63tiaGBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1436&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;那么如何存储这个 DAG 结构呢？用二维数组存储，是不能满足节点属性及边属性要求的，一是边界没法定义，可能这棵树很大，二是假设属性由关联表来实现，就会很割裂，没法直观看得到。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7607361963190185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859yl3FVnvL8iaQsBY76PNfeeEAzqxxP5QduRfiasM0aU53trBule5GNLJib6DichffgeMwRYXL3otc7mtsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;326&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;其实图可以用&lt;/span&gt;&lt;strong&gt;链表&lt;/strong&gt;&lt;span&gt;表示，链表的存储结构第一反应就是 &lt;/span&gt;&lt;strong&gt;JSON&lt;/strong&gt;&lt;span&gt; 或者 &lt;/span&gt;&lt;strong&gt;XML&lt;/strong&gt;&lt;span&gt; 来表示。可以想象， 如果用 JSON 来表示的话，层级嵌套关系会非常繁琐，毕竟 JSON 是用来序列化数据用的，展示方面，还是 XML 添加属性更为方便直观。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;数据结构&lt;/h3&gt;&lt;p&gt;举例简易决策树如下&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3013863773357444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859yl3FVnvL8iaQsBY76PNfeeEAXq4st2gFYCDWWejr2rIicEfdrzbb60WSPnu8hzdaaUcLRX1SK1XdibcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1659&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;如上决策树用 XML 数据结构表示如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;1.0&quot;&lt;/span&gt;&lt;span&gt; encoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt; standalone&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;no&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;flow&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;test01&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;建议决策流&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;!-- 开始节点 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;start&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;start&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;!-- 链接到下一节点 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;link&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;black01&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;/start&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;!-- 名单节点 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;nameList&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;black01&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;黑名单&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;!-- 名单属性：名单类型：黑/白/灰；领域类型；适用范围 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;field&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;type&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;black&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;field&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;domain&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;10001,10002&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;field&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;scope&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;deviceHash,phone,uid&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;link&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;split01&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;/nameList&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;!-- 分流节点 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;split&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;split01&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;是否为微信渠道&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;!-- 条件分支 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;condition&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;是&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;expr&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;system == &#x27;wechat&#x27;&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;strategy01&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;condition&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;10&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;否&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;strategy02&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;/split&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;!-- 策略节点 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;strategy&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;strategy01&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;微信专属策略&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;!-- 关联专属策略元数据 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;field&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;strategyGuid&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;25F7C71A5F834F24A12C478CEE4CB9EB&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;link&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;end&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;/strategy&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;strategy&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;strategy02&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;非微信渠道策略&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;field&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;strategyGuid&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;0FC8A95A4D6A4F169C77950BB4A98D80&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;link&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;end&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;/strategy&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;!-- 结束节点 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;end&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;end&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;结束&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/flow&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;上述数据结构非常直观的表示了当前需要绘制的决策树数据结构，相较于 JSON 的数据表现形式，XML 更灵活，扩展更方便，&lt;strong&gt;在横向和深度上可以有较好的平衡&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;决策流解析&lt;/h3&gt;&lt;p&gt;XML 是很成熟的技术实现了，市面上有很多解析 XML 的开源实现，如上数据结构我使用 &lt;code&gt;common-digester&lt;/code&gt;解析，POM 中引入如下依赖即可：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;!-- https://mvnrepository.com/artifact/commons-digester/commons-digester --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;commons-digester&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;commons-digester&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;1.8.1&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;实体关系如下：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42656449553001274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859yl3FVnvL8iaQsBY76PNfeeEAxZsuYxPUSVEOmhoc2hZ3b427unN7WibcpKGvWNc4pbQzwMTQVpZcXwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1566&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;XML 数据解析如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;FlowEntity&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; desc&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;INode&lt;/span&gt;&lt;span&gt; startNode&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;INode&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; nodeMap &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Digester&lt;/span&gt;&lt;span&gt; digester &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Digester&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;// parse flow node&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addObjectCreate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;FlowEntity&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addSetProperties&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;// parse start node&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addObjectCreate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow/start&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;StartNode&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addSetProperties&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow/start&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;// 在 FlowEntity 实现 addNode 方法，将当前节点录入&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addSetNext&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow/start&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;addNode&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addObjectCreate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow/start/link&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;LinkBranch&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addSetProperties&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow/start/link&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;// 在 StartNode 实现 addLink 方法，将当前边录入&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addSetNext&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow/start/link&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;addLink&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;// parse split node&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addObjectCreate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow/split&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;SplitNode&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addSetProperties&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow/split&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addSetNext&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow/split&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;addNode&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addObjectCreate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow/split/condition&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ConditionBranch&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addSetProperties&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow/split/condition&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;// 在 SplitNode 实现 addCondition 方法，将当前条件录入&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;addSetNext&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;flow/split/condition&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;addCondition&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;// 省略...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;InputStream&lt;/span&gt;&lt;span&gt; inputStream &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ByteArrayInputStream&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;xmlResource&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getBytes&lt;/span&gt;&lt;span&gt;());&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;FlowEntity&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; digester&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;inputStream&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;其中 &lt;code&gt;addNode&lt;/code&gt; 逻辑为将所有节点都存储在一个 &lt;code&gt;nodeMap&lt;/code&gt; 结构内，并且如果当前节点是开始节点，则赋值到 &lt;code&gt;startNode&lt;/code&gt;节点。&lt;/p&gt;&lt;p&gt;当 XML 解析完后，此时关联关系还没有建立，&lt;strong&gt;轮询每个节点后将节点与节点之间联系起来&lt;/strong&gt;，并且校验节点是够存在，确保能关联成一个树。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; assembleToNode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;INode&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; nodeMap&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Objects&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isNull&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;nodeMap&lt;/span&gt;&lt;span&gt;))&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(!&lt;/span&gt;&lt;span&gt;nodeMap&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;containsKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;))&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;RuntimeException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;%s to: %s can&#x27;t find node from nodeMap&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toNode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; nodeMap&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;决策流执行&lt;/h3&gt;&lt;p&gt;决策的执行只需要从 &lt;code&gt;startNode&lt;/code&gt; 执行开始，&lt;strong&gt;递归执行&lt;/strong&gt;，直到找到唯一的出口弹出即可。注意，策略接口是有输出决策结果的，如果是拒绝的话，此时可以&lt;strong&gt;直接中断流程&lt;/strong&gt;执行，返回结果即可。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;FlowContext&lt;/span&gt;&lt;span&gt; context&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;// 出口&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;EndNode&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;// 递归执行&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;其中，&lt;code&gt;SplitNode&lt;/code&gt;节点执行需要计算&lt;strong&gt;条件表达式&lt;/strong&gt;，只要满足一个条件，即可确定往下走的节点，&lt;strong&gt;子类覆盖实现&lt;/strong&gt;如下：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;注：条件表达式我之前单独发了一篇文章，感兴趣的话欢迎关注，可在我的&lt;strong&gt;历史文章归档&lt;/strong&gt;中查找，此处就不在展开说明了。&lt;/p&gt;&lt;/blockquote&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;FlowContext&lt;/span&gt;&lt;span&gt; context&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;Validate&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;notEmpty&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;condition&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;node id: {} desc: {} [condition] is empty&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getId&lt;/span&gt;&lt;span&gt;(),&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getDesc&lt;/span&gt;&lt;span&gt;());&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;// 主动判断&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;Optional&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ConditionBranch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; target &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; condition&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;stream&lt;/span&gt;&lt;span&gt;().&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;c &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt; c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;evaluate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;)).&lt;/span&gt;&lt;span&gt;findFirst&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;// TODO: 考虑返回默认兜底分支节点&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(!&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isPresent&lt;/span&gt;&lt;span&gt;())&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;RuntimeException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;node id: {} ConditionBranch expr execute find nothing, please check your expr condition&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    target&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;().&lt;/span&gt;&lt;span&gt;getToNode&lt;/span&gt;&lt;span&gt;().&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;code&gt;StrategyNode&lt;/code&gt; 节点执行原理和 &lt;code&gt;SplitNode&lt;/code&gt; 一致，只需要子类覆写实现方法，去执行相应的规则引擎，获取到决策结果，即可判断走向，此处就不在列出。&lt;/p&gt;&lt;p&gt;如上设计好了决策树的存储结构，再配合前端同学构建的基于 BPMN 流图的样式配合，&lt;strong&gt;定制风控需要的节点&lt;/strong&gt;信息和表达，即可随时构建一棵理想的树（此处一句话带过，但在丝滑编排和辅助校验上，前端同学付出了很多，当然这不是本篇文章的重点）。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7479838709677419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859yl3FVnvL8iaQsBY76PNfeeEA6pabQjGiaWCZ7PbLBfQRRVSribZmAdULDRK3rgCa1yOeYgtmNINAmjXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;992&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;本文分享了决策引擎中决策流图的思考及构建过程，从最小可用产品上线支撑业务发展到沉淀出可视化编排能力的工作区。当然，本文仅仅展示了通用决策流的思考构建过程，显示业务中还是会遇到各种挑战，比如&lt;strong&gt;对性能的要求&lt;/strong&gt;、&lt;strong&gt;对成本的控制&lt;/strong&gt;等等，挑战非常多，我将在后续一一分享出来，欢迎关注。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3MTIwNjY3MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/VaAN3q859ylWmoHoic1N6VWVqet95D1VKZibeKjId2zCve2On5VBFRO6fMpdCYiaBgJstyKKxddFYEyOqhDSTCPWA/0?wx_fmt=png&quot; data-nickname=&quot;咕咕鸡技术专栏&quot; data-alias=&quot;guguji_fly&quot; data-signature=&quot;擅长风控领域系统研发，有着丰富的大型系统设计、开发和调优的经验，在不断探索和学习的过程中，积累了宝贵的编程经验，希望我分享的文章能够给每一位读者带来帮助！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2&gt;往期精彩&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MTIwNjY3MA==&amp;amp;mid=2247483756&amp;amp;idx=1&amp;amp;sn=ad2ed1bb69de534299aa3e8f22ddee97&amp;amp;scene=21#wechat_redirect&quot; title=&quot;从 0 到 1 智能风控决策引擎构建&quot; data-linktype=&quot;2&quot;&gt;从 0 到 1 智能风控决策引擎构建&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MTIwNjY3MA==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=857c2fa9e3514e2da0d0a7298dfa7f7a&amp;amp;scene=21#wechat_redirect&quot; title=&quot;性能优化必备——火焰图&quot; data-linktype=&quot;2&quot;&gt;性能优化必备——火焰图&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MTIwNjY3MA==&amp;amp;mid=2247483745&amp;amp;idx=1&amp;amp;sn=e10bec68e51a8dca226cacce9a5258d5&amp;amp;scene=21#wechat_redirect&quot; title=&quot;我是怎么入行做风控的&quot; data-linktype=&quot;2&quot;&gt;我是怎么入行做风控的&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;欢迎关注公众号：&lt;strong&gt;咕咕鸡技术专栏&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;个人技术博客：https://jifuwei.github.io/&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3436123348017621&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859yl3FVnvL8iaQsBY76PNfeeEAibp11q60ibNNS04LsibAvpJEkPIno9qrxiaPcF1uDDUtM2icHAnJpyvK38Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1816&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b0681109e5e0d680ebc123d935db3a69</guid>
<title>MQTT 保留消息是什么？如何使用？</title>
<link>https://toutiao.io/k/6tq7oxu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;h2 id=&quot;什么是-mqtt-保留消息&quot;&gt;什么是 MQTT 保留消息？&lt;/h2&gt;
&lt;p&gt;发布者发布消息时，如果 Retained 标记被设置为 true，则该消息即是 MQTT 中的保留消息（Retained Message）。MQTT 服务器会为每个主题存储最新一条保留消息，以方便消息发布后才上线的客户端在订阅主题时仍可以接收到该消息。&lt;/p&gt;
&lt;p&gt;如下图，当客户端订阅主题时，如果服务端存在该主题匹配的保留消息，则该保留消息将被立即发送给该客户端。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/f0d556a72ee7d9f1fe609659aa7ed2a9.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;MQTT 保留消息&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/f0d556a72ee7d9f1fe609659aa7ed2a9.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/f0d556a72ee7d9f1fe609659aa7ed2a9.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/f0d556a72ee7d9f1fe609659aa7ed2a9.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;何时使用-mqtt-保留消息&quot;&gt;何时使用 MQTT 保留消息？&lt;/h2&gt;
&lt;p&gt;发布订阅模式虽然能让消息的发布者与订阅者充分解耦，但也存在一个缺点，即订阅者无法主动向发布者请求消息。订阅者何时收到消息完全依赖于发布者何时发布消息，这在某些场景中就产生了不便。&lt;/p&gt;
&lt;p&gt;借助保留消息，新的订阅者能够立即获取最近的状态，而不需要等待无法预期的时间，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;智能家居设备的状态只有在变更时才会上报，但是控制端需要在上线后就能获取到设备的状态；&lt;/li&gt;
&lt;li&gt;传感器上报数据的间隔太长，但是订阅者需要在订阅后立即获取到最新的数据；&lt;/li&gt;
&lt;li&gt;传感器的版本号、序列号等不会经常变更的属性，可在上线后发布一条保留消息告知后续的所有订阅者。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;mqtt-保留消息的使用&quot;&gt;MQTT 保留消息的使用&lt;/h2&gt;
&lt;p&gt;若要使用 MQTT 保留消息，只需在消息发布时将 Retained 状态设置为 true 即可。接下来我们以开源的跨平台 &lt;a href=&quot;https://mqttx.app/zh&quot;&gt;MQTT 5.0 桌面客户端工具 - MQTT X&lt;/a&gt; 为例，演示如何使用  MQTT 保留消息。&lt;/p&gt;
&lt;p&gt;打开 MQTT X 后如下所示，需点击 &lt;code&gt;New Connection&lt;/code&gt; 按钮创建一个 MQTT 连接。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/c3c89247952538c127839de49a398aec.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;创建 MQTT 连接 1&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/c3c89247952538c127839de49a398aec.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/c3c89247952538c127839de49a398aec.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/c3c89247952538c127839de49a398aec.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建页面如下，我们只需填写一个连接名称（Name），其他参数保持默认。Host 将默认为 &lt;a href=&quot;https://www.emqx.com/zh/cloud&quot;&gt;EMQX Cloud&lt;/a&gt; 提供的&lt;a href=&quot;https://www.emqx.com/zh/mqtt/public-mqtt5-broker&quot;&gt;公共 MQTT 服务器&lt;/a&gt;。连接参数填写完成后，点击右上角的 &lt;code&gt;Connect&lt;/code&gt; 按钮创建 MQTT 连接。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/199e08891e0a7ca0ad78efa8f986dc21.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;创建 MQTT 连接 2&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/199e08891e0a7ca0ad78efa8f986dc21.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/199e08891e0a7ca0ad78efa8f986dc21.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/199e08891e0a7ca0ad78efa8f986dc21.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;连接成功后将会看到连接名称旁边的状态为绿色。然后我们在右下角消息输入框向主题 &lt;code&gt;sensor/t1&lt;/code&gt; 发送一条普通的消息。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/d66d61a3e507c9371f6665ac1f6be289.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;MQTT 连接成功&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/d66d61a3e507c9371f6665ac1f6be289.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/d66d61a3e507c9371f6665ac1f6be289.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/d66d61a3e507c9371f6665ac1f6be289.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们选中右下角的 Retain 标记，并向主题 &lt;code&gt;sensor/t2&lt;/code&gt; 发送两条保留消息。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/2c202c92516bb9d1394b65410b236dde.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;发送 MQTT 保留消息&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/2c202c92516bb9d1394b65410b236dde.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/2c202c92516bb9d1394b65410b236dde.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/2c202c92516bb9d1394b65410b236dde.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击页面中间的 &lt;code&gt;New Subscription&lt;/code&gt; 按钮创建订阅。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/2e834540fa748f318f7a1f770070db64.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;订阅 MQTT 主题 1&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/2e834540fa748f318f7a1f770070db64.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/2e834540fa748f318f7a1f770070db64.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/2e834540fa748f318f7a1f770070db64.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下，我们订阅通配符主题 &lt;code&gt;sensor/+&lt;/code&gt;，该通配符主题将会匹配主题 &lt;code&gt;sensor/t1&lt;/code&gt; 及 &lt;code&gt;sensor/t2&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;关于通配符主题的更多细节，请查看博客&lt;a href=&quot;https://www.emqx.com/zh/blog/advanced-features-of-mqtt-topics&quot;&gt;通过案例理解 MQTT 主题与通配符&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/d7da8ae6e8cad9dffa82dee3b3014cc1.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;订阅 MQTT 主题 2&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/d7da8ae6e8cad9dffa82dee3b3014cc1.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/d7da8ae6e8cad9dffa82dee3b3014cc1.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/d7da8ae6e8cad9dffa82dee3b3014cc1.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，我们将会看到该订阅能成功收到第二条保留消息，&lt;code&gt;sensor/t1&lt;/code&gt; 的普通消息及 &lt;code&gt;sensor/t2&lt;/code&gt; 的第一条保留消息都未收到。可见 MQTT 服务器只会为每个主题存储最新一条保留消息。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/a1a9d7e1ca32f77a8e54f09dccccee99.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;接收 MQTT 保留消息&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/a1a9d7e1ca32f77a8e54f09dccccee99.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/a1a9d7e1ca32f77a8e54f09dccccee99.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/a1a9d7e1ca32f77a8e54f09dccccee99.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于-mqtt-保留消息的-q-amp-a&quot;&gt;关于 MQTT 保留消息的 Q&amp;amp;A&lt;/h2&gt;
&lt;h3 id=&quot;如何判断一条消息是否是保留消息&quot;&gt;如何判断一条消息是否是保留消息？&lt;/h3&gt;
&lt;p&gt;当客户端订阅了有保留消息的主题后，即会收到该主题的保留消息，可通过消息中的保留标志位判断是否是保留消息。需要注意的是，在保留消息发布前订阅主题，将不会收到保留消息。&lt;strong&gt;需要待保留消息发布后，重新订阅该主题，才会收到保留消息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图，我们先订阅主题 &lt;code&gt;sensor/t2&lt;/code&gt;，然后向该主题发布一条保留消息，该订阅会立即收到一条消息，但是该消息并不是保留消息。当我们删除该订阅，再次重新订阅 &lt;code&gt;sensor/t2&lt;/code&gt; 主题时，立即收到了刚刚发布的保留消息。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/06d1e7ec9edfebccf2425c39a73b1e6e.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;MQTT 保留消息&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/06d1e7ec9edfebccf2425c39a73b1e6e.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/06d1e7ec9edfebccf2425c39a73b1e6e.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/06d1e7ec9edfebccf2425c39a73b1e6e.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;保留消息将保存多久-如何删除&quot;&gt;保留消息将保存多久？如何删除？&lt;/h3&gt;
&lt;p&gt;服务器只会为每个主题保存最新一条保留消息，保留消息的保存时间与服务器的设置有关。若服务器设置保留消息存储在内存，则 MQTT 服务器重启后消息即会丢失；若存储在磁盘，则服务器重启后保留消息仍然存在。&lt;/p&gt;
&lt;p&gt;保留消息虽然存储在服务端中，但它并不属于会话的一部分。也就是说，即便发布这个保留消息的会话已结束，保留消息也不会被删除。删除保留消息有以下几种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端往某个主题发送一个 Payload 为空的保留消息，服务端就会删除这个主题下的保留消息；&lt;/li&gt;
&lt;li&gt;在 MQTT 服务器上删除，比如 EMQX MQTT 服务器提供了在 Dashboard 上删除保留消息的功能；&lt;/li&gt;
&lt;li&gt;MQTT 5.0 新增了消息过期间隔属性，发布时可使用该属性设置消息的过期时间，不管消息是否为保留消息，都将会在过期时间后自动被删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;emqx-中的-mqtt-保留消息&quot;&gt;EMQX 中的 MQTT 保留消息&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.emqx.com/zh/products/emqx&quot;&gt;EMQX&lt;/a&gt; 是一款全球下载量超千万的大规模分布式物联网 MQTT 服务器，自 2013 年在 GitHub 发布开源版本以来，获得了来自 50 多个国家和地区的 20000 余家企业用户的广泛认可，累计连接物联网关键设备超过 1 亿台。&lt;/p&gt;
&lt;p&gt;不久前，&lt;a href=&quot;https://www.emqx.com/zh/blog/emqx-v-5-0-released&quot;&gt;EMQX 发布了 5.0 版本&lt;/a&gt;，该版本通过一个 23 节点的集群达成了 &lt;a href=&quot;https://www.emqx.com/zh/blog/how-emqx-5-0-achieves-100-million-mqtt-connections&quot;&gt;1 亿 MQTT 连接&lt;/a&gt;+每秒 100 万消息吞吐，这使得 EMQX 5.0 成为目前为止全球最具扩展性的 MQTT 服务器。&lt;/p&gt;
&lt;p&gt;EMQX 5.0 支持在内置的 &lt;a href=&quot;https://www.emqx.com/zh/blog/an-easy-to-use-and-observable-mqtt-dashboard&quot;&gt;Dashboard&lt;/a&gt; 中查看、设置保留消息。感兴趣的读者可通过如下 Docker 命令安装 EMQX 5.0 开源版进行体验。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d --name emqx -p 1883:1883 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EMQX 安装成功后，使用浏览器访问 &lt;code&gt;http://127.0.0.1:18083/&lt;/code&gt; 即可体验 EMQX 5.0 全新 Dashboard。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;默认用户名为 admin，密码为 public&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;登录成功后，可在左侧菜单 &lt;code&gt;System -&amp;gt; Settings&lt;/code&gt; 中修改显示语言为中文。如下图，可点击&lt;code&gt;功能配置-&amp;gt;MQTT&lt;/code&gt; 菜单查看已保留的消息列表，同时也可以查看保留消息的 Payload 或者删除某条保留消息。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/6e338ebe3294d3d2a2e0293d9d3c2b95.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;查看 MQTT 保留消息&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/6e338ebe3294d3d2a2e0293d9d3c2b95.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/6e338ebe3294d3d2a2e0293d9d3c2b95.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/6e338ebe3294d3d2a2e0293d9d3c2b95.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击保留消息下的&lt;code&gt;设置&lt;/code&gt;菜单，可看到 EMQX 支持在 Dashboard 中设置保留消息的存储类型（内存或磁盘）、最大保留消息数、保留消息有效期等参数，点击保存后所有更改将会立即生效。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/2a9d290f5ac618a946e28d21d45834fb.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;设置 MQTT 保留消息&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/2a9d290f5ac618a946e28d21d45834fb.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/2a9d290f5ac618a946e28d21d45834fb.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/2a9d290f5ac618a946e28d21d45834fb.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;本文对 MQTT 保留消息进行了介绍及使用演示，用户可以参考本文更好地利用 MQTT 保留消息解决订阅后无法立即获取最近数据的问题。除此之外，MQTT 协议还具备更多实用特性，读者可查看 EMQ 提供的 &lt;a href=&quot;https://www.emqx.com/zh/mqtt&quot;&gt;MQTT 入门与进阶&lt;/a&gt;系列文章进行深入了解，探索 MQTT 的更多高级应用，开启 MQTT 应用及服务开发。&lt;/p&gt;
&lt;section class=&quot;promotion&quot;&gt;
    &lt;div&gt;&lt;p&gt;
        免费试用 EMQX Cloud
        &lt;/p&gt;&lt;p class=&quot;is-size-14 is-text-normal has-text-weight-normal&quot;&gt;全托管的 MQTT 消息云服务&lt;/p&gt;
    &lt;/div&gt;
    &lt;a href=&quot;https://accounts-zh.emqx.com/signup?continue=https://cloud.emqx.com/console/deployments/0?oper=new&quot; class=&quot;button is-gradient px-5&quot;&gt;开始试用 →&lt;/a&gt;
&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fd33f6771d4727c01f83f6a0fe54f0a8</guid>
<title>130 个学术网站 26 个科研工具</title>
<link>https://toutiao.io/k/rw2dlfo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;pythonic生物人&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;gh_d6ea706a4619&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;分享数据科学干货（涉及Python/R/统计等）&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>