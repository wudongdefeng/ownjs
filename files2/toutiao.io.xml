<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7b9214e8f9bc1f9d4763f45325f6dfec</guid>
<title>网上很火的开源网页图标🔥</title>
<link>https://toutiao.io/k/p43qsae</link>
<content:encoded>&lt;div&gt;&lt;div/&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>265d8e934b30da952026c2a098464541</guid>
<title>5小步快速集成使用sentinel限流</title>
<link>https://toutiao.io/k/xfw204e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在微服务系统中，缓存、限流、熔断是保证系统高可用的三板斧。本文通过如下几个小步骤，即可让spring项目快速集成使用sentinel实现系统限流。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、环境和资源准备&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sentinel支持许多流控方式，比如：单机限流、熔断降级、集群限流、系统保护规则、黑白名单授权等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍如何快速集成使用sentinel，文中以单机限流为例，使用代码而非控制台配置的方式限流。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;sentinel官网地址：https://sentinelguard.io/zh-cn/index.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;github地址：https://github.com/alibaba/Sentinel&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本文采用的版本是1.8.0，下载地址：https://github.com/alibaba/Sentinel/releases/tag/v1.8.0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sentinel-dashboard下载地址：https://github.com/alibaba/Sentinel/releases/download/v1.8.0/sentinel-dashboard-1.8.0.jar&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本文使用的项目地址：https://github.com/yclxiao/spring-sentinel-demo，代码中有一部分使用的是官方demo。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、启动sentinel-dashboard&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上文地址下载sentinel-dashboard，然后执行命令启动：&lt;code&gt;java -jar sentinel-dashboard-1.8.0.jar&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动完毕后，通过http://localhost:8080/#/dashboard访问dashboard，出现如下界面：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48148148148148145&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaKiaGaGnVlcFLgx8wh1c0AChyicuptP0P6DA6qiapXmCLTJ4wJmcTqQSJGDn628F7AicRU14QH95Q175sEVa2JRT9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、项目集成sentinel&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目中集成sentinel分如下5步。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1、引入pom&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- 这是sentinel的核心依赖 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba.csp&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;sentinel-core&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!-- 这是将自己项目和sentinel-dashboard打通的依赖 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba.csp&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;sentinel-transport-simple-http&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!-- 这是使用sentinel对限流资源进行AOP --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba.csp&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;sentinel-annotation-aspectj&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2、增加sentinel-aop&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AopConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; SentinelResourceAspect &lt;span&gt;sentinelResourceAspect&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SentinelResourceAspect();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3、增加&lt;code&gt;sentinel.properties&lt;/code&gt;配置&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;application.properties&lt;/code&gt;同级目录下，增加&lt;code&gt;sentinel.properties&lt;/code&gt;文件，配置内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# 集成到sentinel的项目名称&lt;br/&gt;project.name=spring-sentinel-demo&lt;br/&gt;# 对应的sentinel-dashboard地址&lt;br/&gt;csp.sentinel.dashboard.server=localhost:8080&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5138888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaKiaGaGnVlcFLgx8wh1c0AChyicuptP0P6YYyZptHTKLac5rVbibKo9p5lswWtEicW84397Qb2xrySdj8e36JkJibNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时需要加载&lt;code&gt;sentinel.properties&lt;/code&gt;配置，有两种加载方式，选择一种即可，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6583333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaKiaGaGnVlcFLgx8wh1c0AChyicuptP0P6qQemIlpFUYzBvoakObl6XsnA7uwR2dhQSXr0WAfYGnIYHrRGbb7j6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4、设置需要被限流的资源&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给需要被限流的资源打上注解&lt;code&gt;@SentinelResource&lt;/code&gt;，使用方式如下。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;默认情况下，超出配置的流控阈值后，直接抛出 FlowException（BlockException） 异常，可以使用blockHandler自定义。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;fallback用于配置熔断降级的方法，当发生慢调用、异常数、异常比例数，会调用fallback方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以针对部分异常情况做忽略处理，不再触发熔断降级。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;top&lt;/span&gt;.&lt;span&gt;mangod&lt;/span&gt;.&lt;span&gt;springsentineldemo&lt;/span&gt;.&lt;span&gt;service&lt;/span&gt;.&lt;span&gt;TestService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@SentinelResource&lt;/span&gt;(value = &lt;span&gt;&quot;test&quot;&lt;/span&gt;, blockHandler = &lt;span&gt;&quot;handleException&quot;&lt;/span&gt;, blockHandlerClass = {top.mangod.springsentineldemo.service.ExceptionUtil&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Test&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@SentinelResource&lt;/span&gt;(value = &lt;span&gt;&quot;hello&quot;&lt;/span&gt;, fallback = &lt;span&gt;&quot;helloFallback&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (s &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;invalid arg&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; String.format(&lt;span&gt;&quot;Hello at %d&quot;&lt;/span&gt;, s);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@SentinelResource&lt;/span&gt;(value = &lt;span&gt;&quot;helloAnother&quot;&lt;/span&gt;, defaultFallback = &lt;span&gt;&quot;defaultFallback&quot;&lt;/span&gt;,&lt;br/&gt;        exceptionsToIgnore = {IllegalStateException&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;helloAnother&lt;/span&gt;(&lt;span&gt;String&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (name == &lt;span&gt;null&lt;/span&gt; || &lt;span&gt;&quot;bad&quot;&lt;/span&gt;.equals(name)) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;oops&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;foo&quot;&lt;/span&gt;.equals(name)) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;oops&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Hello, &quot;&lt;/span&gt; + name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;helloFallback&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; s, Throwable ex)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// Do some log here.&lt;/span&gt;&lt;br/&gt;        ex.printStackTrace();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Oops, error occurred at &quot;&lt;/span&gt; + s;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;defaultFallback&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Go to default fallback&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;default_fallback&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5、指定和加载流控规则&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中我使用代码方式制定流控规则，在控制台中也可以直接配置流控规则，为什么不使用控制台方式呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是类似云原生的部署环境，比如：将spring应用打成docker镜像，然后在部署到Kubernetes中，部署之后Pod地址是会变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要应用的地址变化后，之前的配置就消失了。不可能每次地址变化后都到控制台去重新配置策略，所以需要选择代码方式制定规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流控规则一般会有如下几个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;资源限流规则&lt;code&gt;FlowRule&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异常熔断降级规则&lt;code&gt;DegradeRule&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统过载保护规则&lt;code&gt;SystemRule&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;访问黑白名单规则&lt;code&gt;AuthorityRule&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;控制台设置流控规则&lt;/strong&gt;，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47685185185185186&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaKiaGaGnVlcFLgx8wh1c0AChyicuptP0P6saKfkBVZjJmBUX6hJ5mVG4vVVq3ia7Xsq0DerMrib1VrpaJMicAInqG9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码制定和加载流控规则&lt;/strong&gt;，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 加载限流规则&lt;/span&gt;&lt;br/&gt;    initSentinelRule();&lt;br/&gt;    SpringApplication.run(SpringSentinelDemoApplication&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initSentinelRule&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 资源限流&lt;/span&gt;&lt;br/&gt;    FlowRule flowRule = &lt;span&gt;new&lt;/span&gt; FlowRule(&lt;span&gt;&quot;test&quot;&lt;/span&gt;)&lt;br/&gt;        .setCount(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;        .setGrade(RuleConstant.FLOW_GRADE_QPS);&lt;br/&gt;    List&amp;lt;FlowRule&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;/*if (method) {&lt;br/&gt;            FlowRule flowRule1 = new FlowRule(&quot;test:sayHello(java.lang.String)&quot;)&lt;br/&gt;                    .setCount(5)&lt;br/&gt;                    .setGrade(RuleConstant.FLOW_GRADE_QPS);&lt;br/&gt;            list.add(flowRule1);&lt;br/&gt;        }*/&lt;/span&gt;&lt;br/&gt;    list.add(flowRule);&lt;br/&gt;    FlowRuleManager.loadRules(list);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 异常降级&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/*List&amp;lt;DegradeRule&amp;gt; DegradeRules = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    DegradeRule degradeRule = new DegradeRule(&quot;&quot;);&lt;br/&gt;    degradeRule.setGrade(CircuitBreakerStrategy.ERROR_RATIO.getType());&lt;br/&gt;    degradeRule.setCount(0.7); // Threshold is 70% error ratio&lt;br/&gt;    degradeRule.setMinRequestAmount(100)&lt;br/&gt;            .setStatIntervalMs(30000) // 30s&lt;br/&gt;            .setTimeWindow(10);&lt;br/&gt;    DegradeRules.add(degradeRule);&lt;br/&gt;    DegradeRuleManager.loadRules(DegradeRules);*/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 系统负载保护&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/*List&amp;lt;SystemRule&amp;gt; systemRules = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    SystemRule systemRule = new SystemRule();&lt;br/&gt;    systemRule.setHighestSystemLoad(10);&lt;br/&gt;    systemRules.add(systemRule);&lt;br/&gt;    SystemRuleManager.loadRules(systemRules);*/&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 黑白名单授权访问&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/*AuthorityRule rule = new AuthorityRule();&lt;br/&gt;    rule.setResource(&quot;test&quot;);&lt;br/&gt;    rule.setStrategy(RuleConstant.AUTHORITY_WHITE);&lt;br/&gt;    rule.setLimitApp(&quot;appA,appB&quot;);&lt;br/&gt;    AuthorityRuleManager.loadRules(Collections.singletonList(rule));*/&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4、启动测试&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目启动完毕后，访问链接http://localhost:9091/foo，就可以在控制台上看到被限流的资源&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48148148148148145&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaKiaGaGnVlcFLgx8wh1c0AChyicuptP0P6DA6qiapXmCLTJ4wJmcTqQSJGDn628F7AicRU14QH95Q175sEVa2JRT9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在流控规则这里，可以看到上文中在代码里设置的规则：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44166666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaKiaGaGnVlcFLgx8wh1c0AChyicuptP0P6os2QBxaBhKT3qtfPbjRvwhmo42WicD12KUo91NoJrd1Cgb1gs3TJAsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动项目后，测试限流效果，如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1秒内多次访问http://localhost:9091/foo，可以看到触发了限流异常：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaKiaGaGnVlcFLgx8wh1c0AChyicuptP0P6nicHDZLguPibYQLQUWNjbE5o2RKw7vicqnRBiceHSfRVyiaKsrOqD0v87tA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;输入http://localhost:9091/foo?t=-1会触发异常。fallback用于配置熔断降级的方法，当发生慢调用、异常数、异常比例数时，会调用fallback方法。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5083333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaKiaGaGnVlcFLgx8wh1c0AChyicuptP0P60bxib84R0Xd9RGz5jicCr0Wf6S4cIUYMTxNF5Gxvpuwapu0IVou02GHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;输入http://localhost:9091/baz/foo、http://localhost:9091/baz/bad，会分别触发异常和默认fallback。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5018518518518519&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaKiaGaGnVlcFLgx8wh1c0AChyicuptP0P6wLZ6IKicjsKhmdcgqQHCjkQMSfFCTDDjSo1pm4KUiaKC1sGKcGGCJbQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5、总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍spring项目如何快速集成sentinel实现系统限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先启动sentinel-dashboard，然后使用5个简单步骤即可使用sentinel限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在应用server的IP地址频繁变动的场景下，建议使用代码方式限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流控的方式较多，你需要根据自身的业务需求做选择，我一般情况下选择单机流控和系统保护。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本篇完结！感谢你的阅读，欢迎点赞  关注  收藏  私信！！！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;http://www.mangod.top/articles/2023/09/18/1695000997906.html&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI3OTA2MDQyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/iaKiaGaGnVlcHDFk7YlZ6MLUftpPmuiaXDXcHh5EJWGjuByb7x8ZibwsAPKMhvUODRSOXGN4vOQ8VN2uou3etA8mAQ/0?wx_fmt=png&quot; data-nickname=&quot;不焦躁的程序员&quot; data-alias=&quot;yclxiaobjzcxy&quot; data-signature=&quot;13年IT行业经验，做过架构创过业，一起交流学习。专注于软件开发、云原生、大数据领域。关注我职业发展不焦虑。&quot; data-from=&quot;1&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a831deb58502fda3f28f6d0bdd94162c</guid>
<title>快速高质量交付的5大原则</title>
<link>https://toutiao.io/k/2xrzhon</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;em&gt;任何一个组织都希望能够又快又好的交付产品，但真的能做到吗？原文: &lt;span&gt;5 Principles for Quality at Speed&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0UVkuicFqborm0s4RZXdUgC6fQiaugsUa1jZTfAdsg6D0bdMEfImWlScCaJCK0qvld6U9c9UvuOhgiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原则塑造了我们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们面临压力时，生存机制会让我们依赖基于原则的潜在结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种行为本身没什么问题，但当有问题的原则让我们做出错误决定时，尤其在时间很紧迫的时候，问题就出现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在当今快节奏环境中，软件的交付越快越好，因此快速决策的压力无处不在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从平衡速度和质量的角度出发，必须限制正在进行的工作，而不是试图做太多事情，必须掌控两者的矛盾。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文讨论了软件工程的五个原则，以克服&quot;质量vs速度&quot;的困境，从而更快构建更好的软件。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 少即是多(Less is More)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;活跃而忙碌的文化总是围绕这种观念: 努力工作总比少工作好，会有更好的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不得不承认，我(或者说曾经)非常坚定的相信这一点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你观察成功的个人和组织，他们会反复说:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;把注意力集中在影响最小的事情上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;坚决选择不做某些事情&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于做或者不做某些事情依赖某些强烈的原则&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&quot;少即是多&quot;是个强大的原则，迫使我们专注于能提供大部分价值的东西，避免做其他低价值的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际案例从初创公司到服务数百万用户的公司都可以看到，通常他们都专注于解决某个特定问题，或者在更大的公司里会看到他们在每个阶段都集中精力于一件事情。例如，苹果先是推出iPod，然后是iPhone、iPad，然后专注于配件来打造品牌生活方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在软件工程中可以通过以下方式来应用这些原则:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通过帕累托分析来确定哪部分20%的努力产生了80%的结果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过技术组合和技术雷达以简化技术堆栈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;减少正在进行的工作(WIP, work-in-progress)从而获得更好的预期回报&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分析功能使用情况并删除使用率低于最小阈值的功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;编写更好、更少、需要更少注释的代码。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在更广泛层面上，少即是多就是更偏向于用最小实践来开发业务，而不是更时尚、更受追捧的实践——正如质量工程成熟度模型&lt;span&gt;MAMOS&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;所捍卫的那样。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 旧即是新(The Old is New)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前的创新速度，尤其是在技术领域，让我们觉得好像每天都有颠覆性解决方案出现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但大多数创新都是在经过验证的模型上逐步建立的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&quot;创新就是把现有的两种东西以一种新的方式组合在一起。&quot; — Tom Freston&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以软件行业的流行词汇为例:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;云是一种部署基础设施，可以实现自助服务和可扩展性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软件定义网络建立在历史悠久的7层网络之上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;许多质量实践都是基于戴明或丰田的实践&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个列表还在继续(包括ChatGPT)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点并不是说没有变化(渐进式和破坏性创新正在发生，改变着行业现状)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键是要了解营销手段背后的原因:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;利用了哪些成熟技术?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;要达到承诺的效果需要哪些条件?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该项创新能够持续或被取代的可能性有多大?&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的价值在于正确评估潜在机会，做好功课，确保掌握了所提出解决方案的基础。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的问题是，要足够强大的运用之前的&quot;少即是多&quot;原则，只保留最有价值的选项。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 慢即是快(Slow is Fast)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让·德·拉封丹(Jean De La Fontaine)的一则寓言讲述了龟兔赛跑的故事，令人惊讶的是，乌龟赢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样不可思议的事情也发生在软件行业。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从长远来看，跑得太快通常意味着会失去动力，原因如下:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;缺乏关键利益相关者的参与和支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺少预算、资源和团队来交付早期成果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只是让系统回到初始状态的表面变化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实践组织无法支持的复杂实践&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;未能使组织持续变革。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;速度是在适当地方做出正确选择的结果，尽量减少对组织成熟实践造成太大影响。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&quot;生活中没有什么事情像你想的那么重要。&quot; ― Daniel Kahneman,思考快与慢&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在越来越追求短期的文化中，拥有长期视角和持续努力的延迟反馈将变得更加稀有，而涉及到软件构建时，也会更加与众不同。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 质量无法测试(You Can’t Test Quality)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;捷径是危险的，测试和质量之间的捷径已经让组织中出现了很多欺骗行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这又回到了最基本的问题:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到公司需要以最少的测试获得最高的质量:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;由于复杂性、资源可用性或可行性等限制，&lt;strong&gt;质量属性不可能全部得到验证&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;更多的测试意味着更多的验证&lt;/strong&gt;，但并不代表更高的质量，尤其是在软件生命周期的早期阶段。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&quot;你无法检查产品的质量。&quot; — Harold F. Dodge&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的责任是培育生态系统，在这个生态系统中，质量属性被定义并且作为软件生产的一部分，必须成为一等公民。接下来的问题是，如何利用某种极简方法，尽可能快的验证哪里的质量属性得到了最充分的满足。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这需要转变思维模式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 做得更好，做得更快(Build Better, Build Faster)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;质量工程代表了许多软件团队所面临的&quot;质量vs速度&quot;这一历史矛盾的思维方式的改变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一悖论似乎没有正确答案:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;质量本身会减缓组织保持竞争力的速度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;速度本身会积累技术债务，而在这过程中会造成失败&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;范式的转变是&quot;质量决定速度(Quality enables Speed)&quot;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过在整个软件系统上部署最小实践集，用高质量支持更快的迭代周期，以最小复杂性和更易于更改的软件让事情流动起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以此开始，通过渐进式的、系统性的和可伸缩的实践按照成熟度模型来实现，应用&quot;做得更好，做得更快&quot;的原则来交付高质量软件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准备好进行质量工程了吗?&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;5 Principles for Quality at Speed: &lt;em&gt;https://qeunit.com/blog/5-principles-for-quality-at-speed&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;MAMOS: &lt;em&gt;https://qeunit.com/mamos&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>058b3ce4e4a55e0753ff4421b6dd243b</guid>
<title>什么是泛型的类型擦除？</title>
<link>https://toutiao.io/k/bubslmr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看一道常见的面试题，下面的代码的执行结果是什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    List&amp;lt;String&amp;gt; list1=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();&lt;br/&gt;    List&amp;lt;Integer&amp;gt; list2=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;    System.out.println(list1.getClass()==list2.getClass());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们知道&lt;code&gt;getClas&lt;/code&gt;方法获取的是对象运行时的类（Class），那么这个问题也就可以转化为&lt;code&gt;ArrayList&amp;lt;String&amp;gt;&lt;/code&gt;和&lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;&lt;/code&gt;的对象在运行时对应的Class是否相同？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接揭晓答案，运行上面的代码，程序会打印&lt;code&gt;true&lt;/code&gt;，说明虽然在代码中声明了具体的泛型，但是两个List对象对应的Class是一样的，对它们的类型进行打印，结果都是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;util&lt;/span&gt;.&lt;span&gt;ArrayList&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，虽然&lt;code&gt;ArrayList&amp;lt;String&amp;gt;&lt;/code&gt;和&lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;&lt;/code&gt;在编译时是不同的类型，但是在编译完成后都被编译器简化成了&lt;code&gt;ArrayList&lt;/code&gt;，这一现象，被称为泛型的&lt;strong&gt;类型擦除&lt;/strong&gt;(Type Erasure)。泛型的本质是参数化类型，而类型擦除使得类型参数只存在于编译期，在运行时，&lt;code&gt;jvm&lt;/code&gt;是并不知道泛型的存在的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为什么要进行泛型的类型擦除呢？查阅的一些资料中，解释说类型擦除的主要目的是避免过多的创建类而造成的运行时的过度消耗。试想一下，如果用&lt;code&gt;List&amp;lt;A&amp;gt;&lt;/code&gt;表示一个类型，再用&lt;code&gt;List&amp;lt;B&amp;gt;&lt;/code&gt;表示另一个类型，以此类推，无疑会引起类型的数量爆炸。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在对类型擦除有了一个大致的了解后，我们再看看下面的几个问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;类型擦除做了什么？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们说了，编译完成后会对泛型进行类型擦除，如果想要眼见为实，实际看一下的话应该怎么办呢？那么就需要对编译后的字节码文件进行反编译了，这里使用一个轻量级的小工具&lt;code&gt;Jad&lt;/code&gt;来进行反编译（可以从这个地址进行下载：&lt;code&gt;https://varaneckas.com/jad/&lt;/code&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Jad&lt;/code&gt;的使用也很简单，下载解压后，把需要反编译的字节码文件放在目录下，然后在命令行里执行下面的命令就可以在同目录下生成反编译后的&lt;code&gt;.java&lt;/code&gt;文件了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jad -sjava Test.class &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，工具准备好了，下面我们就看一下不同情况下的类型擦除。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;1、无限制类型擦除&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当类定义中的类型参数没有任何限制时，在类型擦除后，会被直接替换为&lt;code&gt;Object&lt;/code&gt;。在下面的例子中，&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;中的类型参数T就全被替换为了&lt;code&gt;Object&lt;/code&gt;（左侧为编译前的代码，右侧为通过字节码文件反编译得到的代码）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45767716535433073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbOer7sORfP56oLOmr1sTRrC1EBISHPgs4EqVEv4zgGHqPRC9ICkq41LuxsPFGiaojicMVnfKW4t8Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2、有限制类型擦除&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当类定义中的类型参数存在限制时，在类型擦除中替换为类型参数的上界或者下界。下面的代码中，经过擦除后&lt;code&gt;T&lt;/code&gt;被替换成了&lt;code&gt;Integer&lt;/code&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3768518518518518&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbOer7sORfP56oLOmr1sTRrndAcCABVojOfiaVwfqjwV8Gtdmgcg275ryX8aYk8Tl3cgibxPAogBk6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3、擦除方法中的类型参数&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较下面两边的代码，可以看到在擦除方法中的类型参数时，和擦除类定义中的类型参数一致，无限制时直接擦除为&lt;code&gt;Object&lt;/code&gt;，有限制时则会被擦除为上界或下界：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21473029045643152&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbOer7sORfP56oLOmr1sTRrYAfVGqzUt21t2bHB7iaDNh20b7JTiaEWTodsicHKDlHJa7Lw4nxPBBFug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;反射能获取泛型的类型吗？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;估计对Java反射比较熟悉小伙伴要有疑问了，反射中的&lt;code&gt;getTypeParameters&lt;/code&gt;方法可以获得类、数组、接口等实体的类型参数，如果类型被擦除了，那么能获取到什么呢？我们来尝试一下使用反射来获取类型参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(Arrays.asList(list1.getClass().getTypeParameters()));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[E]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，如果打印&lt;code&gt;Map&lt;/code&gt;对象的参数类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Map&amp;lt;String,Integer&amp;gt; map=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;System.out.println(Arrays.asList(map.getClass().getTypeParameters()));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终也只能够获取到：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[K, V]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到通过&lt;code&gt;getTypeParameters&lt;/code&gt;方法只能获取到泛型的参数占位符，而不能获得代码中真正的泛型类型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;能在指定类型的List中放入其他类型的对象吗？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用泛型的好处之一，就是在编译的时候能够检查类型安全，但是通过上面的例子，我们知道&lt;strong&gt;运行时&lt;/strong&gt;是没有泛型约束的，那么是不是就意味着，在运行时可以把一个类型的对象能放进另一类型的&lt;code&gt;List&lt;/code&gt;呢？我们先看看正常情况下，直接调用&lt;code&gt;add&lt;/code&gt;方法会有什么报错：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3238312428734322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbOer7sORfP56oLOmr1sTRrPo3ZhseY9hsMlxuerX03pPWhTG73R9UzUiaMvrTTIzzFbouqqSht6yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们尝试将&lt;code&gt;User&lt;/code&gt;类型的对象放入&lt;code&gt;String&lt;/code&gt;类型的数组时，泛型的约束会在编译期间就进行报错，提示提供的&lt;code&gt;User&lt;/code&gt;类型对象不适用于&lt;code&gt;String&lt;/code&gt;类型数组。那么既然编译时不行，那么我们就在运行时写入，借助真正运行的&lt;code&gt;class&lt;/code&gt;是没有泛型约束这一特性，使用反射在运行时写入：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ReflectTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        list.add(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;        ReflectTest reflectTest =&lt;span&gt;new&lt;/span&gt; ReflectTest();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Field field = ReflectTest&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getDeclaredField&lt;/span&gt;(&quot;&lt;span&gt;list&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;            field.setAccessible(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;            List list=(List) field.get(reflectTest);&lt;br/&gt;            list.add(&lt;span&gt;new&lt;/span&gt; User());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }        &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行上面的代码，不仅在编译期间可以通过语法检查，并且也可以正常地运行，我们使用&lt;code&gt;debug&lt;/code&gt;来看一下数组中的内容：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42452830188679247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbOer7sORfP56oLOmr1sTRrJ98nN7ibYlCyhUzib7X80QlS7gyWMYwOfJePlpibD0Cgsxo7aInSL38Zg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到虽然数组中声明的泛型类型是&lt;code&gt;String&lt;/code&gt;，但是仍然成功的放入了&lt;code&gt;User&lt;/code&gt;类型的对象。那么，如果我们在代码中尝试取出这个&lt;code&gt;User&lt;/code&gt;对象，程序还能正常执行吗，我们在上面代码的最后再加上一句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(list.get(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次执行代码，程序运行到最后的打印语句时，报错如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18618042226487524&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbOer7sORfP56oLOmr1sTRrm97ial00ibhJxiciamJvn51kuYwwVibmK1fHFZxBAVbbuYF6pAbnHwEibjtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1042&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异常提示&lt;code&gt;User&lt;/code&gt;类型的对象无法被转换成&lt;code&gt;String&lt;/code&gt;类型，这是否也就意味着，在取出对象时存在强制类型转换呢？我们来看一下&lt;code&gt;ArrayList&lt;/code&gt;中&lt;code&gt;get&lt;/code&gt;方法的源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    rangeCheck(index);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; elementData(index);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;E &lt;span&gt;elementData&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (E) elementData[index];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在取出元素时，会将这个元素强制类型转换成泛型中的类型，也就是说在上面的代码中，最后会尝试强制把&lt;code&gt;User&lt;/code&gt;对象转换成&lt;code&gt;String&lt;/code&gt;类型，在这一阶段程序会报错。通过这一过程，也再次证明了泛型可以对类型安全进行检测。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;类型擦除会引起什么问题？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们看一个稍微有点复杂的例子，首先声明一个接口，然后创建一个实现该接口的类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;T &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(T param)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Apple&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt;&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(Integer param)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; param;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照之前我们的理解，在进行类型擦除后，应该是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;Object &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(Object param)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Apple&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(Integer param)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; param;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果真是这样的话那么代码是无法运行的，因为虽然&lt;code&gt;Apple&lt;/code&gt;类中也有一个&lt;code&gt;get&lt;/code&gt;方法，但是与接口中的方法参数不一致，也就是说没有覆盖接口中的方法。针对这种情况，编译器会通过添加一个&lt;strong&gt;桥接方法&lt;/strong&gt;来满足语法上的要求，同时保证了基于泛型的多态能够有效。我们反编译上面代码生成的字节码文件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9714828897338403&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbOer7sORfP56oLOmr1sTRrp2FgxcIsdBiaUq6icTKq4tyA9a4tTmNEvB2l7UjwLsLibXxhDiapA3n4fQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;526&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，编译后的代码中生成了两个&lt;code&gt;get&lt;/code&gt;方法。参数为&lt;code&gt;Object&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;方法负责实现&lt;code&gt;Fruit&lt;/code&gt;接口中的同名方法，然后在实现类中又额外添加了一个参数为&lt;code&gt;Integer&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;方法，这个方法也就是理论上应该生成的带参数类型的方法。最终用接口方法调用额外添加的方法，通过这种方式构建了接口和实现类的关系，类似于起到了桥接的作用，因此也被称为桥接方法，最终，通过这种机制保证了泛型情况下的Java多态性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文由面试中常见的一道面试题入手，介绍了java中泛型的类型擦除相关知识，通过这一过程，也便于大家理解为什么平常总是说java中的泛型是一个&lt;strong&gt;伪泛型&lt;/strong&gt;，同时也有助于大家认识到java中泛型的一些缺陷。了解类型擦除的原因以及原理，相信能够方便大家在日常的工作中更好的使用泛型。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4NjYyODc4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J4jTHmo8Xh6qM32ASOtVbXNoiaegrI26qLRw6r6FTI7dZw6TMT7vecvnjd1O8xSsM5MiajIuQZicxSC6KFK8TMpbg/0?wx_fmt=png&quot; data-nickname=&quot;java突击队&quot; data-alias=&quot;&quot; data-signature=&quot;技术经验分享&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>29ff1648617d80f741014125210dc3a0</guid>
<title>聊聊JedisFactory</title>
<link>https://toutiao.io/k/ptzgdm3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content&amp;#10;                       autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;h1&gt;序&lt;/h1&gt;&lt;p&gt;本文主要研究一下JedisFactory&lt;/p&gt;&lt;h1&gt;PooledObjectFactory&lt;/h1&gt;&lt;p&gt;org/apache/commons/pool2/PooledObjectFactory.java&lt;/p&gt;&lt;pre&gt;&lt;code&gt;/**&lt;br/&gt; * An interface defining life-cycle methods for instances to be served by an&lt;br/&gt; * {@link ObjectPool}.&lt;br/&gt; * &amp;lt;p&amp;gt;&lt;br/&gt; * By contract, when an {@link ObjectPool} delegates to a&lt;br/&gt; * {@link PooledObjectFactory},&lt;br/&gt; * &amp;lt;/p&amp;gt;&lt;br/&gt; * &amp;lt;ol&amp;gt;&lt;br/&gt; *  &amp;lt;li&amp;gt;&lt;br/&gt; *   {@link #makeObject} is called whenever a new instance is needed.&lt;br/&gt; *  &amp;lt;/li&amp;gt;&lt;br/&gt; *  &amp;lt;li&amp;gt;&lt;br/&gt; *   {@link #activateObject} is invoked on every instance that has been&lt;br/&gt; *   {@link #passivateObject passivated} before it is&lt;br/&gt; *   {@link ObjectPool#borrowObject borrowed} from the pool.&lt;br/&gt; *  &amp;lt;/li&amp;gt;&lt;br/&gt; *  &amp;lt;li&amp;gt;&lt;br/&gt; *   {@link #validateObject} may be invoked on {@link #activateObject activated}&lt;br/&gt; *   instances to make sure they can be {@link ObjectPool#borrowObject borrowed}&lt;br/&gt; *   from the pool. {@link #validateObject} may also be used to&lt;br/&gt; *   test an instance being {@link ObjectPool#returnObject returned} to the pool&lt;br/&gt; *   before it is {@link #passivateObject passivated}. It will only be invoked&lt;br/&gt; *   on an activated instance.&lt;br/&gt; *  &amp;lt;/li&amp;gt;&lt;br/&gt; *  &amp;lt;li&amp;gt;&lt;br/&gt; *   {@link #passivateObject} is invoked on every instance when it is returned&lt;br/&gt; *   to the pool.&lt;br/&gt; *  &amp;lt;/li&amp;gt;&lt;br/&gt; *  &amp;lt;li&amp;gt;&lt;br/&gt; *   {@link #destroyObject} is invoked on every instance when it is being&lt;br/&gt; *   &quot;dropped&quot; from the pool (whether due to the response from&lt;br/&gt; *   {@link #validateObject}, or for reasons specific to the pool&lt;br/&gt; *   implementation.) There is no guarantee that the instance being destroyed&lt;br/&gt; *   will be considered active, passive or in a generally consistent state.&lt;br/&gt; *  &amp;lt;/li&amp;gt;&lt;br/&gt; * &amp;lt;/ol&amp;gt;&lt;br/&gt; * {@link PooledObjectFactory} must be thread-safe. The only promise&lt;br/&gt; * an {@link ObjectPool} makes is that the same instance of an object will not&lt;br/&gt; * be passed to more than one method of a {@code PoolableObjectFactory}&lt;br/&gt; * at a time.&lt;br/&gt; * &amp;lt;p&amp;gt;&lt;br/&gt; * While clients of a {@link KeyedObjectPool} borrow and return instances of&lt;br/&gt; * the underlying value type {@code V}, the factory methods act on instances of&lt;br/&gt; * {@link PooledObject PooledObject&amp;amp;lt;V&amp;amp;gt;}.  These are the object wrappers that&lt;br/&gt; * pools use to track and maintain state information about the objects that&lt;br/&gt; * they manage.&lt;br/&gt; * &amp;lt;/p&amp;gt;&lt;br/&gt; *&lt;br/&gt; * @param &amp;lt;T&amp;gt; Type of element managed in this factory.&lt;br/&gt; *&lt;br/&gt; * @see ObjectPool&lt;br/&gt; *&lt;br/&gt; * @since 2.0&lt;br/&gt; */&lt;br/&gt;public interface PooledObjectFactory&amp;lt;T&amp;gt; {&lt;br/&gt;&lt;br/&gt;  /**&lt;br/&gt;   * Creates an instance that can be served by the pool and wrap it in a&lt;br/&gt;   * {@link PooledObject} to be managed by the pool.&lt;br/&gt;   *&lt;br/&gt;   * @return a {@code PooledObject} wrapping an instance that can be served by the pool&lt;br/&gt;   *&lt;br/&gt;   * @throws Exception if there is a problem creating a new instance,&lt;br/&gt;   *    this will be propagated to the code requesting an object.&lt;br/&gt;   */&lt;br/&gt;  PooledObject&amp;lt;T&amp;gt; makeObject() throws Exception;&lt;br/&gt;&lt;br/&gt;  /**&lt;br/&gt;   * Destroys an instance no longer needed by the pool.&lt;br/&gt;   * &amp;lt;p&amp;gt;&lt;br/&gt;   * It is important for implementations of this method to be aware that there&lt;br/&gt;   * is no guarantee about what state {@code obj} will be in and the&lt;br/&gt;   * implementation should be prepared to handle unexpected errors.&lt;br/&gt;   * &amp;lt;/p&amp;gt;&lt;br/&gt;   * &amp;lt;p&amp;gt;&lt;br/&gt;   * Also, an implementation must take in to consideration that instances lost&lt;br/&gt;   * to the garbage collector may never be destroyed.&lt;br/&gt;   * &amp;lt;/p&amp;gt;&lt;br/&gt;   *&lt;br/&gt;   * @param p a {@code PooledObject} wrapping the instance to be destroyed&lt;br/&gt;   *&lt;br/&gt;   * @throws Exception should be avoided as it may be swallowed by&lt;br/&gt;   *    the pool implementation.&lt;br/&gt;   *&lt;br/&gt;   * @see #validateObject&lt;br/&gt;   * @see ObjectPool#invalidateObject&lt;br/&gt;   */&lt;br/&gt;  void destroyObject(PooledObject&amp;lt;T&amp;gt; p) throws Exception;&lt;br/&gt;&lt;br/&gt;  /**&lt;br/&gt;   * Ensures that the instance is safe to be returned by the pool.&lt;br/&gt;   *&lt;br/&gt;   * @param p a {@code PooledObject} wrapping the instance to be validated&lt;br/&gt;   *&lt;br/&gt;   * @return {@code false} if {@code obj} is not valid and should&lt;br/&gt;   *         be dropped from the pool, {@code true} otherwise.&lt;br/&gt;   */&lt;br/&gt;  boolean validateObject(PooledObject&amp;lt;T&amp;gt; p);&lt;br/&gt;&lt;br/&gt;  /**&lt;br/&gt;   * Reinitializes an instance to be returned by the pool.&lt;br/&gt;   *&lt;br/&gt;   * @param p a {@code PooledObject} wrapping the instance to be activated&lt;br/&gt;   *&lt;br/&gt;   * @throws Exception if there is a problem activating {@code obj},&lt;br/&gt;   *    this exception may be swallowed by the pool.&lt;br/&gt;   *&lt;br/&gt;   * @see #destroyObject&lt;br/&gt;   */&lt;br/&gt;  void activateObject(PooledObject&amp;lt;T&amp;gt; p) throws Exception;&lt;br/&gt;&lt;br/&gt;  /**&lt;br/&gt;   * Uninitializes an instance to be returned to the idle object pool.&lt;br/&gt;   *&lt;br/&gt;   * @param p a {@code PooledObject} wrapping the instance to be passivated&lt;br/&gt;   *&lt;br/&gt;   * @throws Exception if there is a problem passivating {@code obj},&lt;br/&gt;   *    this exception may be swallowed by the pool.&lt;br/&gt;   *&lt;br/&gt;   * @see #destroyObject&lt;br/&gt;   */&lt;br/&gt;  void passivateObject(PooledObject&amp;lt;T&amp;gt; p) throws Exception;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;PooledObjectFactory接口定义了makeObject、destroyObject、validateObject、activateObject、passivateObject方法&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;JedisFactory&lt;/h1&gt;&lt;p&gt;redis/clients/jedis/JedisFactory.java&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class JedisFactory implements PooledObjectFactory&amp;lt;Jedis&amp;gt; {&lt;br/&gt;  private final AtomicReference&amp;lt;HostAndPort&amp;gt; hostAndPort = new AtomicReference&amp;lt;HostAndPort&amp;gt;();&lt;br/&gt;  private final int connectionTimeout;&lt;br/&gt;  private final int soTimeout;&lt;br/&gt;  private final String user;&lt;br/&gt;  private final String password;&lt;br/&gt;  private final int database;&lt;br/&gt;  private final String clientName;&lt;br/&gt;  private final boolean ssl;&lt;br/&gt;  private final SSLSocketFactory sslSocketFactory;&lt;br/&gt;  private final SSLParameters sslParameters;&lt;br/&gt;  private final HostnameVerifier hostnameVerifier;&lt;br/&gt;&lt;br/&gt;  //......&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;  public void activateObject(PooledObject&amp;lt;Jedis&amp;gt; pooledJedis) throws Exception {&lt;br/&gt;    final BinaryJedis jedis = pooledJedis.getObject();&lt;br/&gt;    if (jedis.getDB() != database) {&lt;br/&gt;      jedis.select(database);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  @Override&lt;br/&gt;  public void destroyObject(PooledObject&amp;lt;Jedis&amp;gt; pooledJedis) throws Exception {&lt;br/&gt;    final BinaryJedis jedis = pooledJedis.getObject();&lt;br/&gt;    if (jedis.isConnected()) {&lt;br/&gt;      try {&lt;br/&gt;        try {&lt;br/&gt;          jedis.quit();&lt;br/&gt;        } catch (Exception e) {&lt;br/&gt;        }&lt;br/&gt;        jedis.disconnect();&lt;br/&gt;      } catch (Exception e) {&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  @Override&lt;br/&gt;  public PooledObject&amp;lt;Jedis&amp;gt; makeObject() throws Exception {&lt;br/&gt;    final HostAndPort hp = this.hostAndPort.get();&lt;br/&gt;    final Jedis jedis = new Jedis(hp.getHost(), hp.getPort(), connectionTimeout, soTimeout,&lt;br/&gt;        ssl, sslSocketFactory, sslParameters, hostnameVerifier);&lt;br/&gt;    try {&lt;br/&gt;      jedis.connect();&lt;br/&gt;      if (user != null) {&lt;br/&gt;        jedis.auth(user, password);&lt;br/&gt;      } else if (password != null) {&lt;br/&gt;        jedis.auth(password);&lt;br/&gt;      }&lt;br/&gt;      if (database != 0) {&lt;br/&gt;        jedis.select(database);&lt;br/&gt;      }&lt;br/&gt;      if (clientName != null) {&lt;br/&gt;        jedis.clientSetname(clientName);&lt;br/&gt;      }&lt;br/&gt;    } catch (JedisException je) {&lt;br/&gt;      jedis.close();&lt;br/&gt;      throw je;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    return new DefaultPooledObject&amp;lt;&amp;gt;(jedis);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  @Override&lt;br/&gt;  public void passivateObject(PooledObject&amp;lt;Jedis&amp;gt; pooledJedis) throws Exception {&lt;br/&gt;    // TODO maybe should select db 0? Not sure right now.&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  @Override&lt;br/&gt;  public boolean validateObject(PooledObject&amp;lt;Jedis&amp;gt; pooledJedis) {&lt;br/&gt;    final BinaryJedis jedis = pooledJedis.getObject();&lt;br/&gt;    try {&lt;br/&gt;      HostAndPort hostAndPort = this.hostAndPort.get();&lt;br/&gt;&lt;br/&gt;      String connectionHost = jedis.getClient().getHost();&lt;br/&gt;      int connectionPort = jedis.getClient().getPort();&lt;br/&gt;&lt;br/&gt;      return hostAndPort.getHost().equals(connectionHost)&lt;br/&gt;          &amp;amp;&amp;amp; hostAndPort.getPort() == connectionPort &amp;amp;&amp;amp; jedis.isConnected()&lt;br/&gt;          &amp;amp;&amp;amp; jedis.ping().equals(&quot;PONG&quot;);&lt;br/&gt;    } catch (final Exception e) {&lt;br/&gt;      return false;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;JedisFactory实现了PooledObjectFactory接口，其泛型为Jedis；其makeObject方法主要是创建Jedis并connect，auth、还有select db；其destroyObject主要是执行quit及disconnect方法；其validateObject方法执行ping命令；其activateObject方法判断db是否变化，有变化则重新select db；其passivateObject目前为空实现&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;borrowObject&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;    /**&lt;br/&gt;     * Borrows an object from the pool using the specific waiting time which only&lt;br/&gt;     * applies if {@link #getBlockWhenExhausted()} is true.&lt;br/&gt;     * &amp;lt;p&amp;gt;&lt;br/&gt;     * If there is one or more idle instance available in the pool, then an&lt;br/&gt;     * idle instance will be selected based on the value of {@link #getLifo()},&lt;br/&gt;     * activated and returned. If activation fails, or {@link #getTestOnBorrow()&lt;br/&gt;     * testOnBorrow} is set to {@code true} and validation fails, the&lt;br/&gt;     * instance is destroyed and the next available instance is examined. This&lt;br/&gt;     * continues until either a valid instance is returned or there are no more&lt;br/&gt;     * idle instances available.&lt;br/&gt;     * &amp;lt;/p&amp;gt;&lt;br/&gt;     * &amp;lt;p&amp;gt;&lt;br/&gt;     * If there are no idle instances available in the pool, behavior depends on&lt;br/&gt;     * the {@link #getMaxTotal() maxTotal}, (if applicable)&lt;br/&gt;     * {@link #getBlockWhenExhausted()} and the value passed in to the&lt;br/&gt;     * {@code borrowMaxWaitMillis} parameter. If the number of instances&lt;br/&gt;     * checked out from the pool is less than {@code maxTotal,} a new&lt;br/&gt;     * instance is created, activated and (if applicable) validated and returned&lt;br/&gt;     * to the caller. If validation fails, a {@code NoSuchElementException}&lt;br/&gt;     * is thrown.&lt;br/&gt;     * &amp;lt;/p&amp;gt;&lt;br/&gt;     * &amp;lt;p&amp;gt;&lt;br/&gt;     * If the pool is exhausted (no available idle instances and no capacity to&lt;br/&gt;     * create new ones), this method will either block (if&lt;br/&gt;     * {@link #getBlockWhenExhausted()} is true) or throw a&lt;br/&gt;     * {@code NoSuchElementException} (if&lt;br/&gt;     * {@link #getBlockWhenExhausted()} is false). The length of time that this&lt;br/&gt;     * method will block when {@link #getBlockWhenExhausted()} is true is&lt;br/&gt;     * determined by the value passed in to the {@code borrowMaxWaitMillis}&lt;br/&gt;     * parameter.&lt;br/&gt;     * &amp;lt;/p&amp;gt;&lt;br/&gt;     * &amp;lt;p&amp;gt;&lt;br/&gt;     * When the pool is exhausted, multiple calling threads may be&lt;br/&gt;     * simultaneously blocked waiting for instances to become available. A&lt;br/&gt;     * &quot;fairness&quot; algorithm has been implemented to ensure that threads receive&lt;br/&gt;     * available instances in request arrival order.&lt;br/&gt;     * &amp;lt;/p&amp;gt;&lt;br/&gt;     *&lt;br/&gt;     * @param borrowMaxWaitMillis The time to wait in milliseconds for an object&lt;br/&gt;     *                            to become available&lt;br/&gt;     *&lt;br/&gt;     * @return object instance from the pool&lt;br/&gt;     *&lt;br/&gt;     * @throws NoSuchElementException if an instance cannot be returned&lt;br/&gt;     *&lt;br/&gt;     * @throws Exception if an object instance cannot be returned due to an&lt;br/&gt;     *                   error&lt;br/&gt;     */&lt;br/&gt;    public T borrowObject(final long borrowMaxWaitMillis) throws Exception {&lt;br/&gt;        assertOpen();&lt;br/&gt;&lt;br/&gt;        final AbandonedConfig ac = this.abandonedConfig;&lt;br/&gt;        if (ac != null &amp;amp;&amp;amp; ac.getRemoveAbandonedOnBorrow() &amp;amp;&amp;amp;&lt;br/&gt;                (getNumIdle() &amp;lt; 2) &amp;amp;&amp;amp;&lt;br/&gt;                (getNumActive() &amp;gt; getMaxTotal() - 3) ) {&lt;br/&gt;            removeAbandoned(ac);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        PooledObject&amp;lt;T&amp;gt; p = null;&lt;br/&gt;&lt;br/&gt;        // Get local copy of current config so it is consistent for entire&lt;br/&gt;        // method execution&lt;br/&gt;        final boolean blockWhenExhausted = getBlockWhenExhausted();&lt;br/&gt;&lt;br/&gt;        boolean create;&lt;br/&gt;        final long waitTime = System.currentTimeMillis();&lt;br/&gt;&lt;br/&gt;        while (p == null) {&lt;br/&gt;            create = false;&lt;br/&gt;            p = idleObjects.pollFirst();&lt;br/&gt;            if (p == null) {&lt;br/&gt;                p = create();&lt;br/&gt;                if (p != null) {&lt;br/&gt;                    create = true;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            if (blockWhenExhausted) {&lt;br/&gt;                if (p == null) {&lt;br/&gt;                    if (borrowMaxWaitMillis &amp;lt; 0) {&lt;br/&gt;                        p = idleObjects.takeFirst();&lt;br/&gt;                    } else {&lt;br/&gt;                        p = idleObjects.pollFirst(borrowMaxWaitMillis,&lt;br/&gt;                                TimeUnit.MILLISECONDS);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;                if (p == null) {&lt;br/&gt;                    throw new NoSuchElementException(&lt;br/&gt;                            &quot;Timeout waiting for idle object&quot;);&lt;br/&gt;                }&lt;br/&gt;            } else {&lt;br/&gt;                if (p == null) {&lt;br/&gt;                    throw new NoSuchElementException(&quot;Pool exhausted&quot;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            if (!p.allocate()) {&lt;br/&gt;                p = null;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            if (p != null) {&lt;br/&gt;                try {&lt;br/&gt;                    factory.activateObject(p);&lt;br/&gt;                } catch (final Exception e) {&lt;br/&gt;                    try {&lt;br/&gt;                        destroy(p);&lt;br/&gt;                    } catch (final Exception e1) {&lt;br/&gt;                        // Ignore - activation failure is more important&lt;br/&gt;                    }&lt;br/&gt;                    p = null;&lt;br/&gt;                    if (create) {&lt;br/&gt;                        final NoSuchElementException nsee = new NoSuchElementException(&lt;br/&gt;                                &quot;Unable to activate object&quot;);&lt;br/&gt;                        nsee.initCause(e);&lt;br/&gt;                        throw nsee;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;                if (p != null &amp;amp;&amp;amp; getTestOnBorrow()) {&lt;br/&gt;                    boolean validate = false;&lt;br/&gt;                    Throwable validationThrowable = null;&lt;br/&gt;                    try {&lt;br/&gt;                        validate = factory.validateObject(p);&lt;br/&gt;                    } catch (final Throwable t) {&lt;br/&gt;                        PoolUtils.checkRethrow(t);&lt;br/&gt;                        validationThrowable = t;&lt;br/&gt;                    }&lt;br/&gt;                    if (!validate) {&lt;br/&gt;                        try {&lt;br/&gt;                            destroy(p);&lt;br/&gt;                            destroyedByBorrowValidationCount.incrementAndGet();&lt;br/&gt;                        } catch (final Exception e) {&lt;br/&gt;                            // Ignore - validation failure is more important&lt;br/&gt;                        }&lt;br/&gt;                        p = null;&lt;br/&gt;                        if (create) {&lt;br/&gt;                            final NoSuchElementException nsee = new NoSuchElementException(&lt;br/&gt;                                    &quot;Unable to validate object&quot;);&lt;br/&gt;                            nsee.initCause(validationThrowable);&lt;br/&gt;                            throw nsee;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);&lt;br/&gt;&lt;br/&gt;        return p.getObject();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;borrowObject方法在从idleObjects.pollFirst获取到的jedis不为null的时候会执行activateObject(&lt;code&gt;这里db没有变化，相等于空操作&lt;/code&gt;)，然后如果testOnBorrow为true则执行validateObject(&lt;code&gt;执行ping命令&lt;/code&gt;)&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;evict&lt;/h1&gt;&lt;p&gt;org/apache/commons/pool2/impl/GenericObjectPool.java&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    /**&lt;br/&gt;     * {@inheritDoc}&lt;br/&gt;     * &amp;lt;p&amp;gt;&lt;br/&gt;     * Successive activations of this method examine objects in sequence,&lt;br/&gt;     * cycling through objects in oldest-to-youngest order.&lt;br/&gt;     * &amp;lt;/p&amp;gt;&lt;br/&gt;     */&lt;br/&gt;    @Override&lt;br/&gt;    public void evict() throws Exception {&lt;br/&gt;        assertOpen();&lt;br/&gt;&lt;br/&gt;        if (idleObjects.size() &amp;gt; 0) {&lt;br/&gt;&lt;br/&gt;            PooledObject&amp;lt;T&amp;gt; underTest = null;&lt;br/&gt;            final EvictionPolicy&amp;lt;T&amp;gt; evictionPolicy = getEvictionPolicy();&lt;br/&gt;&lt;br/&gt;            synchronized (evictionLock) {&lt;br/&gt;                final EvictionConfig evictionConfig = new EvictionConfig(&lt;br/&gt;                        getMinEvictableIdleTimeMillis(),&lt;br/&gt;                        getSoftMinEvictableIdleTimeMillis(),&lt;br/&gt;                        getMinIdle());&lt;br/&gt;&lt;br/&gt;                final boolean testWhileIdle = getTestWhileIdle();&lt;br/&gt;&lt;br/&gt;                for (int i = 0, m = getNumTests(); i &amp;lt; m; i++) {&lt;br/&gt;                    if (evictionIterator == null || !evictionIterator.hasNext()) {&lt;br/&gt;                        evictionIterator = new EvictionIterator(idleObjects);&lt;br/&gt;                    }&lt;br/&gt;                    if (!evictionIterator.hasNext()) {&lt;br/&gt;                        // Pool exhausted, nothing to do here&lt;br/&gt;                        return;&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    try {&lt;br/&gt;                        underTest = evictionIterator.next();&lt;br/&gt;                    } catch (final NoSuchElementException nsee) {&lt;br/&gt;                        // Object was borrowed in another thread&lt;br/&gt;                        // Don&#x27;t count this as an eviction test so reduce i;&lt;br/&gt;                        i--;&lt;br/&gt;                        evictionIterator = null;&lt;br/&gt;                        continue;&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    if (!underTest.startEvictionTest()) {&lt;br/&gt;                        // Object was borrowed in another thread&lt;br/&gt;                        // Don&#x27;t count this as an eviction test so reduce i;&lt;br/&gt;                        i--;&lt;br/&gt;                        continue;&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    // User provided eviction policy could throw all sorts of&lt;br/&gt;                    // crazy exceptions. Protect against such an exception&lt;br/&gt;                    // killing the eviction thread.&lt;br/&gt;                    boolean evict;&lt;br/&gt;                    try {&lt;br/&gt;                        evict = evictionPolicy.evict(evictionConfig, underTest,&lt;br/&gt;                                idleObjects.size());&lt;br/&gt;                    } catch (final Throwable t) {&lt;br/&gt;                        // Slightly convoluted as SwallowedExceptionListener&lt;br/&gt;                        // uses Exception rather than Throwable&lt;br/&gt;                        PoolUtils.checkRethrow(t);&lt;br/&gt;                        swallowException(new Exception(t));&lt;br/&gt;                        // Don&#x27;t evict on error conditions&lt;br/&gt;                        evict = false;&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    if (evict) {&lt;br/&gt;                        destroy(underTest);&lt;br/&gt;                        destroyedByEvictorCount.incrementAndGet();&lt;br/&gt;                    } else {&lt;br/&gt;                        if (testWhileIdle) {&lt;br/&gt;                            boolean active = false;&lt;br/&gt;                            try {&lt;br/&gt;                                factory.activateObject(underTest);&lt;br/&gt;                                active = true;&lt;br/&gt;                            } catch (final Exception e) {&lt;br/&gt;                                destroy(underTest);&lt;br/&gt;                                destroyedByEvictorCount.incrementAndGet();&lt;br/&gt;                            }&lt;br/&gt;                            if (active) {&lt;br/&gt;                                if (!factory.validateObject(underTest)) {&lt;br/&gt;                                    destroy(underTest);&lt;br/&gt;                                    destroyedByEvictorCount.incrementAndGet();&lt;br/&gt;                                } else {&lt;br/&gt;                                    try {&lt;br/&gt;                                        factory.passivateObject(underTest);&lt;br/&gt;                                    } catch (final Exception e) {&lt;br/&gt;                                        destroy(underTest);&lt;br/&gt;                                        destroyedByEvictorCount.incrementAndGet();&lt;br/&gt;                                    }&lt;br/&gt;                                }&lt;br/&gt;                            }&lt;br/&gt;                        }&lt;br/&gt;                        if (!underTest.endEvictionTest(idleObjects)) {&lt;br/&gt;                            // TODO - May need to add code here once additional&lt;br/&gt;                            // states are used&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        final AbandonedConfig ac = this.abandonedConfig;&lt;br/&gt;        if (ac != null &amp;amp;&amp;amp; ac.getRemoveAbandonedOnMaintenance()) {&lt;br/&gt;            removeAbandoned(ac);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;evict方法在evict为false且testWhileIdle为true的时候，会执行activateObject方法，然后再执行validateObject方法&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;小结&lt;/h1&gt;&lt;p&gt;JedisFactory实现了PooledObjectFactory接口，其泛型为Jedis；其makeObject方法主要是创建Jedis并connect，auth、还有select db；其destroyObject主要是执行quit及disconnect方法；其validateObject方法执行ping命令；其activateObject方法判断db是否变化，有变化则重新select db；其passivateObject目前为空实现&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;目前borrowObject方法在从idleObjects.pollFirst获取到的jedis不为null的时候会执行activateObject(&lt;code&gt;这里db没有变化，相等于空操作&lt;/code&gt;)，然后如果testOnBorrow为true则执行validateObject(&lt;code&gt;执行ping命令&lt;/code&gt;)&lt;br/&gt;evict方法在evict为false且testWhileIdle为true的时候，会执行activateObject方法，然后再执行validateObject方法&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;doc&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>